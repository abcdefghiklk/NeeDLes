
======= fetch "public String getLanguage(boolean useDefault) {" 42056be^:"java/org/apache/jasper/compiler/PageInfo.java"

    public void setExtends(String value, Node.PageDirective n) {
======= fetch "public void setExtends(String value, Node.PageDirective n) {" 42056be^:"java/org/apache/jasper/compiler/PageInfo.java"

    }
======= fetch "public void setExtends(String value, Node.PageDirective n) {" 42056be^:"java/org/apache/jasper/compiler/PageInfo.java"

        /*
         * If page superclass is top level class (i.e. not in a package)
         * explicitly import it. If this is not done, the compiler will assume
         * the extended class is in the same pkg as the generated servlet.
         */
        if (value.indexOf('.') < 0)
            n.addImport(value);
======= fetch "public void visit(Node.PageDirective n) throws JasperException {" 42056be^:"java/org/apache/jasper/compiler/Validator.java"

                        pageInfo.setExtends(value, n);

======= fetch "public ELParser(String expression, boolean isDeferredSyntaxAllowedAsLiteral) {" b430e29^:"java/org/apache/jasper/compiler/ELParser.java"

        while (hasNext()) {
======= fetch "private boolean parseFunction() {" b430e29^:"java/org/apache/jasper/compiler/ELParser.java"

        if (hasNext()) {
======= fetch "private boolean parseFunction() {" b430e29^:"java/org/apache/jasper/compiler/ELParser.java"

                if (hasNext()) {
======= fetch "private boolean parseFunction() {" b430e29^:"java/org/apache/jasper/compiler/ELParser.java"

                        if (hasNext()) {
======= fetch "private boolean isELReserved(String id) {" b430e29^:"java/org/apache/jasper/compiler/ELParser.java"

        String trimmed = id.trim();
======= fetch "private boolean isELReserved(String id) {" b430e29^:"java/org/apache/jasper/compiler/ELParser.java"

            int result = reservedWords[k].compareTo(id);
======= fetch "private String skipUntilEL() {" b430e29^:"java/org/apache/jasper/compiler/ELParser.java"

     * @return true if there is something left in EL expression buffer other
     * than white spaces.
     */
    private boolean hasNext() {
        skipSpaces();
        return hasNextChar();
    }
    /*
======= fetch "private Token nextToken() {" b430e29^:"java/org/apache/jasper/compiler/ELParser.java"

        skipSpaces();
======= fetch "private Token parseQuotedChars(char quote) {" b430e29^:"java/org/apache/jasper/compiler/ELParser.java"

    private void skipSpaces() {
        while (hasNextChar()) {
            if (expression.charAt(index) > ' ')
                break;
            index++;
        }
    }
======= fetch "public void testCompound03() throws JasperException {" b430e29^:"test/org/apache/jasper/compiler/TestELParser.java"

    @Test
    public void testTernary01() throws JasperException {
        doTestParser("${true?true:false}");
    }
    @Test
    public void testTernary02() throws JasperException {
        doTestParser("${a==1?true:false}");
    }
    @Test
    public void testTernary03() throws JasperException {
        doTestParser("${a eq1?true:false}");
    }
    @Test
    public void testTernary04() throws JasperException {
        doTestParser(" ${ a eq 1 ? true : false } ");
    }
    @Test
    public void testTernary05() throws JasperException {
        // Note this is invalid EL
        doTestParser("${aeq1?true:false}");
    }
    @Test
    public void testTernary06() throws JasperException {
        doTestParser("${do:it(a eq1?true:false,y)}");
    }
    @Test
    public void testTernary07() throws JasperException {
        doTestParser(" $ { do:it( a eq 1 ? true : false, y ) } ");
    }

======= fetch "public WebappClassLoader() {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        this.parent = getParent();
        system = getSystemClassLoader();
        securityManager = System.getSecurityManager();
======= fetch "public WebappClassLoader() {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        ClassLoader p = getParent();
        if (p == null) {
            p = getSystemClassLoader();
        }
        this.parent = p;
        ClassLoader j = String.class.getClassLoader();
        if (j == null) {
            j = getSystemClassLoader();
            while (j.getParent() != null) {
                j = j.getParent();
            }
        }
        this.j2seClassLoader = j;
        securityManager = System.getSecurityManager();
======= fetch "public WebappClassLoader() {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

======= fetch "public WebappClassLoader(ClassLoader parent) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        this.parent = getParent();
======= fetch "public WebappClassLoader(ClassLoader parent) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        system = getSystemClassLoader();
        securityManager = System.getSecurityManager();
======= fetch "public WebappClassLoader(ClassLoader parent) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        securityManager = System.getSecurityManager();
======= fetch "public WebappClassLoader(ClassLoader parent) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

    protected ClassLoader parent = null;
======= fetch "public WebappClassLoader(ClassLoader parent) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * The system class loader.
======= fetch "public WebappClassLoader(ClassLoader parent) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

    protected final ClassLoader system;
======= fetch "public WebappClassLoader copyWithoutTransformers() {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        WebappClassLoader result = new WebappClassLoader(this.parent);
======= fetch "public URL getResource(String name) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            ClassLoader loader = parent;
            if (loader == null)
                loader = system;
            url = loader.getResource(name);
======= fetch "public URL getResource(String name) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            ClassLoader loader = parent;
            if (loader == null)
                loader = system;
            url = loader.getResource(name);
======= fetch "public InputStream getResourceAsStream(String name) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            ClassLoader loader = parent;
            if (loader == null)
                loader = system;
            stream = loader.getResourceAsStream(name);
======= fetch "public InputStream getResourceAsStream(String name) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            ClassLoader loader = parent;
            if (loader == null)
                loader = system;
            stream = loader.getResourceAsStream(name);
======= fetch "public InputStream getResourceAsStream(String name) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (system.getResource(resourceName) != null) {
======= fetch "public InputStream getResourceAsStream(String name) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                clazz = system.loadClass(name);
======= fetch "public InputStream getResourceAsStream(String name) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            ClassLoader loader = parent;
            if (loader == null)
                loader = system;
======= fetch "public InputStream getResourceAsStream(String name) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                clazz = Class.forName(name, false, loader);
======= fetch "public InputStream getResourceAsStream(String name) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            ClassLoader loader = parent;
            if (loader == null)
                loader = system;
======= fetch "public InputStream getResourceAsStream(String name) {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                clazz = Class.forName(name, false, loader);
======= fetch "public void stop() throws LifecycleException {" f28800c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        parent = null;

======= fetch "public static void doUpgrade(WsServerContainer sc, HttpServletRequest req," 11b1e83^:"java/org/apache/tomcat/websocket/server/UpgradeUtil.java"

        if (!subProtocols.isEmpty()) {
            subProtocol = sec.getConfigurator().
                    getNegotiatedSubprotocol(
                            sec.getSubprotocols(), subProtocols);
        }
======= fetch "public static void doUpgrade(WsServerContainer sc, HttpServletRequest req," 11b1e83^:"java/org/apache/tomcat/websocket/server/UpgradeUtil.java"

        Endpoint ep;
        try {
            Class<?> clazz = sec.getEndpointClass();
            if (Endpoint.class.isAssignableFrom(clazz)) {
                ep = (Endpoint) sec.getConfigurator().getEndpointInstance(
                        clazz);
            } else {
                ep = new PojoEndpointServer();
            }
        } catch (InstantiationException e) {
            throw new ServletException(e);
        }
======= fetch "public static void doUpgrade(WsServerContainer sc, HttpServletRequest req," 11b1e83^:"java/org/apache/tomcat/websocket/server/UpgradeUtil.java"

        Endpoint ep;
        try {
            Class<?> clazz = sec.getEndpointClass();
            if (Endpoint.class.isAssignableFrom(clazz)) {
                ep = (Endpoint) sec.getConfigurator().getEndpointInstance(
                        clazz);
            } else {
                ep = new PojoEndpointServer();
            }
        } catch (InstantiationException e) {
            throw new ServletException(e);
        }

======= fetch "public void initialize(Servlet servlet, ServletRequest request," 48650dd^:"java/org/apache/jasper/runtime/PageContextImpl.java"

        if (bufferSize == JspWriter.DEFAULT_BUFFER) {
            bufferSize = Constants.DEFAULT_BUFFER_SIZE;
        }
======= fetch "public void testDoForward() throws Exception {" 48650dd^:"test/org/apache/jasper/runtime/TestPageContextImpl.java"

    @Test
    public void testDefaultBufferSize() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp");
        // app dir is relative to server home
        Context ctx = tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        // Add the Servlet
        Tomcat.addServlet(ctx, "bug56010", new Bug56010());
        ctx.addServletMapping("/bug56010", "bug56010");
        tomcat.start();
        ByteChunk res = getUrl("http://localhost:" + getPort() + "/test/bug56010");
        String result = res.toString();
        Assert.assertTrue(result.contains("OK"));
    }
    public static class Bug56010 extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            PageContext pageContext = JspFactory.getDefaultFactory().getPageContext(
                    this, req, resp, null, false, JspWriter.DEFAULT_BUFFER, true);
            JspWriter out = pageContext.getOut();
            if (Constants.DEFAULT_BUFFER_SIZE == out.getBufferSize()) {
                resp.getWriter().println("OK");
            } else {
                resp.getWriter().println("FAIL");
            }
        }
    }

======= fetch "public E getSocket() {" 553ad39^:"java/org/apache/tomcat/util/net/SocketWrapper.java"

    public void access() { access(System.currentTimeMillis()); }

======= fetch "public TaglibXml getTaglibXml(TldResourcePath tldResourcePath) throws JasperExce" 5e6b884^:"java/org/apache/jasper/compiler/TldCache.java"

            URL url = servletContext.getResource(tldResourcePath.getWebappPath());
            URLConnection conn = url.openConnection();
            result[0] = conn.getLastModified();
            if ("file".equals(url.getProtocol())) {
                // Reading the last modified time opens an input stream so we
                // need to make sure it is closed again otherwise the TLD file
                // will be locked until GC runs.
                conn.getInputStream().close();

 * <p>Implementation of the <b>Valve</b> interface that generates a web server
 * access log with the detailed line contents matching a configurable pattern.
 * The syntax of the available patterns is similar to that supported by the
 * <a href="http://httpd.apache.org/">Apache HTTP Server</a>
 * <code>mod_log_config</code> module.  As an additional feature,
 * automatic rollover of log files when the date changes is also supported.</p>
 *
 * <p>Patterns for the logged message may include constant text or any of the
 * following replacement strings, for which the corresponding information
 * from the specified Response is substituted:</p>
 * <ul>
 * <li><b>%a</b> - Remote IP address
 * <li><b>%A</b> - Local IP address
 * <li><b>%b</b> - Bytes sent, excluding HTTP headers, or '-' if no bytes
 *     were sent
 * <li><b>%B</b> - Bytes sent, excluding HTTP headers
 * <li><b>%h</b> - Remote host name (or IP address if
 * <code>enableLookups</code> for the connector is false)
 * <li><b>%H</b> - Request protocol
 * <li><b>%l</b> - Remote logical username from identd (always returns '-')
 * <li><b>%m</b> - Request method
 * <li><b>%p</b> - Local port
 * <li><b>%q</b> - Query string (prepended with a '?' if it exists, otherwise
 *     an empty string
 * <li><b>%r</b> - First line of the request
 * <li><b>%s</b> - HTTP status code of the response
 * <li><b>%S</b> - User session ID
 * <li><b>%t</b> - Date and time, in Common Log Format format
 * <li><b>%t{format}</b> - Date and time, in any format supported by SimpleDateFormat
 * <li><b>%u</b> - Remote user that was authenticated
 * <li><b>%U</b> - Requested URL path
 * <li><b>%v</b> - Local server name
 * <li><b>%D</b> - Time taken to process the request, in millis
 * <li><b>%T</b> - Time taken to process the request, in seconds
 * <li><b>%I</b> - current Request thread name (can compare later with stacktraces)
 * </ul>
 * <p>In addition, the caller can specify one of the following aliases for
 * commonly utilized patterns:</p>
 * <ul>
 * <li><b>common</b> - <code>%h %l %u %t "%r" %s %b</code>
 * <li><b>combined</b> -
 *   <code>%h %l %u %t "%r" %s %b "%{Referer}i" "%{User-Agent}i"</code>
 * </ul>
 *
 * <p>
 * There is also support to write information from the cookie, incoming
 * header, the Session or something else in the ServletRequest.<br>
 * It is modeled after the
 * <a href="http://httpd.apache.org/">Apache HTTP Server</a> log configuration
 * syntax:</p>
 * <li><code>%{xxx}i</code> for incoming headers
 * <li><code>%{xxx}o</code> for outgoing response headers
 * <li><code>%{xxx}c</code> for a specific cookie
 * <li><code>%{xxx}r</code> xxx is an attribute in the ServletRequest
 * <li><code>%{xxx}s</code> xxx is an attribute in the HttpSession
 * <li><code>%{xxx}t</code> xxx is an enhanced SimpleDateFormat pattern
 * (see Configuration Reference document for details on supported time patterns)
 *
 * <p>
 * Log rotation can be on or off. This is dictated by the
 * <code>rotatable</code> property.
 * </p>
 *
 *
 * <p>
 * Conditional logging is also supported. This can be done with the
 * <code>conditionUnless</code> and <code>conditionIf</code> properties.
 * If the value returned from ServletRequest.getAttribute(conditionUnless)
 * yields a non-null value, the logging will be skipped.
 * If the value returned from ServletRequest.getAttribute(conditionIf)
 * yields the null value, the logging will be skipped.
 * The <code>condition</code> attribute is synonym for
 * <code>conditionUnless</code> and is provided for backwards compatibility.
 * </p>
 *
 * <p>
 * For extended attributes coming from a getAttribute() call,
 * it is you responsibility to ensure there are no newline or
 * control characters.
 * </p>
 *
 * @author Craig R. McClanahan
 * @author Jason Brittain
 * @author Remy Maucherat
 * @author Takayuki Kaneko
 * @author Peter Rossbach
 *
 * @version $Id$
======= fetch "public AccessLogValve() {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

        super(true);
======= fetch "public AccessLogValve() {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * enabled this component
     */
    protected boolean enabled = true;
    /**
     * The pattern used to format our access log lines.
     */
    protected String pattern = null;
======= fetch "public AccessLogValve() {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

     * The size of our global date format cache
     */
    private static final int globalCacheSize = 300;
    /**
     * The size of our thread local date format cache
     */
    private static final int localCacheSize = 60;
    /**
======= fetch "public AccessLogValve() {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

     * <p>Cache structure for formatted timestamps based on seconds.</p>
     *
     * <p>The cache consists of entries for a consecutive range of
     * seconds. The length of the range is configurable. It is
     * implemented based on a cyclic buffer. New entries shift the range.</p>
     *
     * <p>There is one cache for the CLF format (the access log standard
     * format) and a HashMap of caches for additional formats used by
     * SimpleDateFormat.</p>
     *
     * <p>Although the cache supports specifying a locale when retrieving a
     * formatted timestamp, each format will always use the locale given
     * when the format was first used. New locales can only be used for new formats.
     * The CLF format will always be formatted using the locale
     * <code>en_US</code>.</p>
     *
     * <p>The cache is not threadsafe. It can be used without synchronization
     * via thread local instances, or with synchronization as a global cache.</p>
     *
     * <p>The cache can be created with a parent cache to build a cache hierarchy.
     * Access to the parent cache is threadsafe.</p>
     *
     * <p>This class uses a small thread local first level cache and a bigger
     * synchronized global second level cache.</p>
     */
    protected static class DateFormatCache {
        protected class Cache {
            /* CLF log format */
            private static final String cLFFormat = "dd/MMM/yyyy:HH:mm:ss Z";
            /* Second used to retrieve CLF format in most recent invocation */
            private long previousSeconds = Long.MIN_VALUE;
            /* Value of CLF format retrieved in most recent invocation */
            private String previousFormat = "";
            /* First second contained in cache */
            private long first = Long.MIN_VALUE;
            /* Last second contained in cache */
            private long last = Long.MIN_VALUE;
            /* Index of "first" in the cyclic cache */
            private int offset = 0;
            /* Helper object to be able to call SimpleDateFormat.format(). */
            private final Date currentDate = new Date();
            protected final String cache[];
            private SimpleDateFormat formatter;
            private boolean isCLF = false;
            private Cache parent = null;
            private Cache(Cache parent) {
                this(null, parent);
            }
            private Cache(String format, Cache parent) {
                this(format, null, parent);
            }
            private Cache(String format, Locale loc, Cache parent) {
                cache = new String[cacheSize];
                for (int i = 0; i < cacheSize; i++) {
                    cache[i] = null;
                }
                if (loc == null) {
                    loc = cacheDefaultLocale;
                }
                if (format == null) {
                    isCLF = true;
                    format = cLFFormat;
                    formatter = new SimpleDateFormat(format, Locale.US);
                } else {
                    formatter = new SimpleDateFormat(format, loc);
                }
                formatter.setTimeZone(TimeZone.getDefault());
                this.parent = parent;
            }
            private String getFormatInternal(long time) {
                long seconds = time / 1000;
                /* First step: if we have seen this timestamp
                   during the previous call, and we need CLF, return the previous value. */
                if (seconds == previousSeconds) {
                    return previousFormat;
                }
                /* Second step: Try to locate in cache */
                previousSeconds = seconds;
                int index = (offset + (int)(seconds - first)) % cacheSize;
                if (index < 0) {
                    index += cacheSize;
                }
                if (seconds >= first && seconds <= last) {
                    if (cache[index] != null) {
                        /* Found, so remember for next call and return.*/
                        previousFormat = cache[index];
                        return previousFormat;
                    }
                /* Third step: not found in cache, adjust cache and add item */
                } else if (seconds >= last + cacheSize || seconds <= first - cacheSize) {
                    first = seconds;
                    last = first + cacheSize - 1;
                    index = 0;
                    offset = 0;
                    for (int i = 1; i < cacheSize; i++) {
                        cache[i] = null;
                    }
                } else if (seconds > last) {
                    for (int i = 1; i < seconds - last; i++) {
                        cache[(index + cacheSize - i) % cacheSize] = null;
                    }
                    first = seconds - (cacheSize - 1);
                    last = seconds;
                    offset = (index + 1) % cacheSize;
                } else if (seconds < first) {
                    for (int i = 1; i < first - seconds; i++) {
                        cache[(index + i) % cacheSize] = null;
                    }
                    first = seconds;
                    last = seconds + (cacheSize - 1);
                    offset = index;
                }
                /* Last step: format new timestamp either using
                 * parent cache or locally. */
                if (parent != null) {
                    synchronized(parent) {
                        previousFormat = parent.getFormatInternal(time);
                    }
                } else {
                    currentDate.setTime(time);
                    previousFormat = formatter.format(currentDate);
                    if (isCLF) {
                        StringBuilder current = new StringBuilder(32);
                        current.append('[');
                        current.append(previousFormat);
                        current.append(']');
                        previousFormat = current.toString();
                    }
                }
                cache[index] = previousFormat;
                return previousFormat;
            }
        }
        /* Number of cached entries */
        private int cacheSize = 0;
        private final Locale cacheDefaultLocale;
        private final DateFormatCache parent;
        protected final Cache cLFCache;
        private final HashMap<String, Cache> formatCache = new HashMap<>();
        protected DateFormatCache(int size, Locale loc, DateFormatCache parent) {
            cacheSize = size;
            cacheDefaultLocale = loc;
            this.parent = parent;
            Cache parentCache = null;
            if (parent != null) {
                synchronized(parent) {
                    parentCache = parent.getCache(null, null);
                }
            }
            cLFCache = new Cache(parentCache);
        }
        private Cache getCache(String format, Locale loc) {
            Cache cache;
            if (format == null) {
                cache = cLFCache;
            } else {
                cache = formatCache.get(format);
                if (cache == null) {
                    Cache parentCache = null;
                    if (parent != null) {
                        synchronized(parent) {
                            parentCache = parent.getCache(format, loc);
                        }
                    }
                    cache = new Cache(format, loc, parentCache);
                    formatCache.put(format, cache);
                }
            }
            return cache;
        }
        public String getFormat(long time) {
            return cLFCache.getFormatInternal(time);
        }
        public String getFormat(String format, Locale loc, long time) {
            return getCache(format, loc).getFormatInternal(time);
        }
    }
    /**
     * Global date format cache.
     */
    private static final DateFormatCache globalDateCache =
            new DateFormatCache(globalCacheSize, Locale.getDefault(), null);
    /**
     * Thread local date format cache.
     */
    private static final ThreadLocal<DateFormatCache> localDateCache =
            new ThreadLocal<DateFormatCache>() {
        @Override
        protected DateFormatCache initialValue() {
            return new DateFormatCache(localCacheSize, Locale.getDefault(), globalDateCache);
        }
    };
    /**
     * The system time when we last updated the Date that this valve
     * uses for log lines.
     */
    private static final ThreadLocal<Date> localDate =
            new ThreadLocal<Date>() {
        @Override
        protected Date initialValue() {
            return new Date();
        }
    };
    /**
     * The list of our format types.
     */
    private static enum FormatType {
        CLF, SEC, MSEC, MSEC_FRAC, SDF
    }
    /**
======= fetch "protected Date initialValue() {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * Are we doing conditional logging. default null.
     * It is the value of <code>conditionUnless</code> property.
     */
    protected String condition = null;
    /**
     * Are we doing conditional logging. default null.
     * It is the value of <code>conditionIf</code> property.
     */
    protected String conditionIf = null;
======= fetch "protected Date initialValue() {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * Name of locale used to format timestamps in log entries and in
     * log file name suffix.
     */
    protected String localeName = Locale.getDefault().toString();
    /**
     * Locale used to format timestamps in log entries and in
     * log file name suffix.
     */
    protected Locale locale = Locale.getDefault();
======= fetch "protected Date initialValue() {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * Array of AccessLogElement, they will be used to make log message.
     */
    protected AccessLogElement[] logElements = null;
    /**
     * @see #setRequestAttributesEnabled(boolean)
     */
    protected boolean requestAttributesEnabled = false;
    /**
     * Buffer pool used for log message generation. Pool used to reduce garbage
     * generation.
     */
    private SynchronizedStack<CharArrayWriter> charArrayWriters =
            new SynchronizedStack<>();
    /**
     * Log message buffers are usually recycled and re-used. To prevent
     * excessive memory usage, if a buffer grows beyond this size it will be
     * discarded. The default is 256 characters. This should be set to larger
     * than the typical access log message size.
     */
    private int maxLogMessageBufferSize = 256;
======= fetch "protected Date initialValue() {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

    public int getMaxLogMessageBufferSize() {
        return maxLogMessageBufferSize;
    }
    public void setMaxLogMessageBufferSize(int maxLogMessageBufferSize) {
        this.maxLogMessageBufferSize = maxLogMessageBufferSize;
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setRequestAttributesEnabled(boolean requestAttributesEnabled) {
        this.requestAttributesEnabled = requestAttributesEnabled;
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getRequestAttributesEnabled() {
        return requestAttributesEnabled;
    }
    /**
     * @return Returns the enabled.
     */
    public boolean getEnabled() {
        return enabled;
    }
    /**
     * @param enabled
     *            The enabled to set.
     */
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
======= fetch "public void setDirectory(String directory) {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * Return the format pattern.
     */
    public String getPattern() {
        return (this.pattern);
    }
    /**
     * Set the format pattern, first translating any recognized alias.
     *
     * @param pattern The new pattern
     */
    public void setPattern(String pattern) {
        if (pattern == null) {
            this.pattern = "";
        } else if (pattern.equals(Constants.AccessLog.COMMON_ALIAS)) {
            this.pattern = Constants.AccessLog.COMMON_PATTERN;
        } else if (pattern.equals(Constants.AccessLog.COMBINED_ALIAS)) {
            this.pattern = Constants.AccessLog.COMBINED_PATTERN;
        } else {
            this.pattern = pattern;
        }
        logElements = createLogElements();
    }
======= fetch "public void setSuffix(String suffix) {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * Return whether the attribute name to look for when
     * performing conditional logging. If null, every
     * request is logged.
     */
    public String getCondition() {
        return condition;
    }
    /**
     * Set the ServletRequest.attribute to look for to perform
     * conditional logging. Set to null to log everything.
     *
     * @param condition Set to null to log everything
     */
    public void setCondition(String condition) {
        this.condition = condition;
    }
    /**
     * Return whether the attribute name to look for when
     * performing conditional logging. If null, every
     * request is logged.
     */
    public String getConditionUnless() {
        return getCondition();
    }
    /**
     * Set the ServletRequest.attribute to look for to perform
     * conditional logging. Set to null to log everything.
     *
     * @param condition Set to null to log everything
     */
    public void setConditionUnless(String condition) {
        setCondition(condition);
    }
    /**
     * Return whether the attribute name to look for when
     * performing conditional logging. If null, every
     * request is logged.
     */
    public String getConditionIf() {
        return conditionIf;
    }
    /**
     * Set the ServletRequest.attribute to look for to perform
     * conditional logging. Set to null to log everything.
     *
     * @param condition Set to null to log everything
     */
    public void setConditionIf(String condition) {
        this.conditionIf = condition;
    }
======= fetch "public void setFileDateFormat(String fileDateFormat) {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * Return the locale used to format timestamps in log entries and in
     * log file name suffix.
     */
    public String getLocale() {
        return localeName;
    }
    /**
     * Set the locale used to format timestamps in log entries and in
     * log file name suffix. Changing the locale is only supported
     * as long as the AccessLogValve has not logged anything. Changing
     * the locale later can lead to inconsistent formatting.
     *
     * @param localeName The locale to use.
     */
    public void setLocale(String localeName) {
        this.localeName = localeName;
        locale = findLocale(localeName, locale);
    }
======= fetch "public synchronized void backgroundProcess() {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

     * Log a message summarizing the specified request and response, according
     * to the format specified by the <code>pattern</code> property.
     *
     * @param request Request being processed
     * @param response Response being processed
     *
     * @exception IOException if an input/output error has occurred
     * @exception ServletException if a servlet error has occurred
     */
    @Override
    public void invoke(Request request, Response response) throws IOException,
            ServletException {
        getNext().invoke(request, response);
    }
    @Override
    public void log(Request request, Response response, long time) {
        if (!getState().isAvailable() || !getEnabled() || logElements == null
                || condition != null
                && null != request.getRequest().getAttribute(condition)
                || conditionIf != null
                && null == request.getRequest().getAttribute(conditionIf)) {
            return;
        }
        /**
         * XXX This is a bit silly, but we want to have start and stop time and
         * duration consistent. It would be better to keep start and stop
         * simply in the request and/or response object and remove time
         * (duration) from the interface.
         */
        long start = request.getCoyoteRequest().getStartTime();
        Date date = getDate(start + time);
        CharArrayWriter result = charArrayWriters.pop();
        if (result == null) {
            result = new CharArrayWriter(128);
        }
        for (int i = 0; i < logElements.length; i++) {
            logElements[i].addElement(result, date, request, response, time);
        }
        log(result);
        if (result.size() <= maxLogMessageBufferSize) {
            result.reset();
            charArrayWriters.push(result);
        }
    }
    /**
======= fetch "private synchronized void close(boolean rename) {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

    @Override
======= fetch "protected synchronized void open() {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

     * This method returns a Date object that is accurate to within one second.
     * If a thread calls this method to get a Date and it's been less than 1
     * second since a new Date was created, this method simply gives out the
     * same Date again so that the system doesn't spend time creating Date
     * objects unnecessarily.
     *
     * @return Date
     */
    private static Date getDate(long systime) {
        Date date = localDate.get();
        date.setTime(systime);
        return date;
    }
    /**
     * Find a locale by name
     */
    protected static Locale findLocale(String name, Locale fallback) {
        if (name == null || name.isEmpty()) {
            return Locale.getDefault();
        } else {
            for (Locale l: Locale.getAvailableLocales()) {
                if (name.equals(l.toString())) {
                    return(l);
                }
            }
        }
        log.error(sm.getString("accessLogValve.invalidLocale", name));
        return fallback;
    }
    /**
======= fetch "protected synchronized void startInternal() throws LifecycleException {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

        setState(LifecycleState.STARTING);
======= fetch "protected synchronized void stopInternal() throws LifecycleException {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

        setState(LifecycleState.STOPPING);
======= fetch "protected synchronized void stopInternal() throws LifecycleException {" 92ce68a^:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * AccessLogElement writes the partial message into the buffer.
     */
    protected interface AccessLogElement {
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time);
    }
    /**
     * write thread name - %I
     */
    protected static class ThreadNameElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            RequestInfo info = request.getCoyoteRequest().getRequestProcessor();
            if(info != null) {
                buf.append(info.getWorkerThreadName());
            } else {
                buf.append("-");
            }
        }
    }
    /**
     * write local IP address - %A
     */
    protected static class LocalAddrElement implements AccessLogElement {
        private static final String LOCAL_ADDR_VALUE;
        static {
            String init;
            try {
                init = InetAddress.getLocalHost().getHostAddress();
            } catch (Throwable e) {
                ExceptionUtils.handleThrowable(e);
                init = "127.0.0.1";
            }
            LOCAL_ADDR_VALUE = init;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            buf.append(LOCAL_ADDR_VALUE);
        }
    }
    /**
     * write remote IP address - %a
     */
    protected class RemoteAddrElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (requestAttributesEnabled) {
                Object addr = request.getAttribute(REMOTE_ADDR_ATTRIBUTE);
                if (addr == null) {
                    buf.append(request.getRemoteAddr());
                } else {
                    buf.append(addr.toString());
                }
            } else {
                buf.append(request.getRemoteAddr());
            }
        }
    }
    /**
     * write remote host name - %h
     */
    protected class HostElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            String value = null;
            if (requestAttributesEnabled) {
                Object host = request.getAttribute(REMOTE_HOST_ATTRIBUTE);
                if (host != null) {
                    value = host.toString();
                }
            }
            if (value == null || value.length() == 0) {
                value = request.getRemoteHost();
            }
            if (value == null || value.length() == 0) {
                value = "-";
            }
            buf.append(value);
        }
    }
    /**
     * write remote logical username from identd (always returns '-') - %l
     */
    protected static class LogicalUserNameElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            buf.append('-');
        }
    }
    /**
     * write request protocol - %H
     */
    protected class ProtocolElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (requestAttributesEnabled) {
                Object proto = request.getAttribute(PROTOCOL_ATTRIBUTE);
                if (proto == null) {
                    buf.append(request.getProtocol());
                } else {
                    buf.append(proto.toString());
                }
            } else {
                buf.append(request.getProtocol());
            }
        }
    }
    /**
     * write remote user that was authenticated (if any), else '-' - %u
     */
    protected static class UserElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (request != null) {
                String value = request.getRemoteUser();
                if (value != null) {
                    buf.append(value);
                } else {
                    buf.append('-');
                }
            } else {
                buf.append('-');
            }
        }
    }
    /**
     * write date and time, in configurable format (default CLF) - %t or %t{format}
     */
    protected class DateAndTimeElement implements AccessLogElement {
        /**
         * Format prefix specifying request start time
         */
        private static final String requestStartPrefix = "begin";
        /**
         * Format prefix specifying response end time
         */
        private static final String responseEndPrefix = "end";
        /**
         * Separator between optional prefix and rest of format
         */
        private static final String prefixSeparator = ":";
        /**
         * Special format for seconds since epoch
         */
        private static final String secFormat = "sec";
        /**
         * Special format for milliseconds since epoch
         */
        private static final String msecFormat = "msec";
        /**
         * Special format for millisecond part of timestamp
         */
        private static final String msecFractionFormat = "msec_frac";
        /**
         * The patterns we use to replace "S" and "SSS" millisecond
         * formatting of SimpleDateFormat by our own handling
         */
        private static final String msecPattern = "{#}";
        private static final String trippleMsecPattern =
            msecPattern + msecPattern + msecPattern;
        /* Our format description string, null if CLF */
        private final String format;
        /* Whether to use begin of request or end of response as the timestamp */
        private final boolean usesBegin;
        /* The format type */
        private final FormatType type;
        /* Whether we need to postprocess by adding milliseconds */
        private boolean usesMsecs = false;
        protected DateAndTimeElement() {
            this(null);
        }
        /**
         * Replace the millisecond formatting character 'S' by
         * some dummy characters in order to make the resulting
         * formatted time stamps cacheable. We replace the dummy
         * chars later with the actual milliseconds because that's
         * relatively cheap.
         */
        private String tidyFormat(String format) {
            boolean escape = false;
            StringBuilder result = new StringBuilder();
            int len = format.length();
            char x;
            for (int i = 0; i < len; i++) {
                x = format.charAt(i);
                if (escape || x != 'S') {
                    result.append(x);
                } else {
                    result.append(msecPattern);
                    usesMsecs = true;
                }
                if (x == '\'') {
                    escape = !escape;
                }
            }
            return result.toString();
        }
        protected DateAndTimeElement(String header) {
            String format = header;
            boolean usesBegin = false;
            FormatType type = FormatType.CLF;
            if (format != null) {
                if (format.equals(requestStartPrefix)) {
                    usesBegin = true;
                    format = "";
                } else if (format.startsWith(requestStartPrefix + prefixSeparator)) {
                    usesBegin = true;
                    format = format.substring(6);
                } else if (format.equals(responseEndPrefix)) {
                    usesBegin = false;
                    format = "";
                } else if (format.startsWith(responseEndPrefix + prefixSeparator)) {
                    usesBegin = false;
                    format = format.substring(4);
                }
                if (format.length() == 0) {
                    type = FormatType.CLF;
                } else if (format.equals(secFormat)) {
                    type = FormatType.SEC;
                } else if (format.equals(msecFormat)) {
                    type = FormatType.MSEC;
                } else if (format.equals(msecFractionFormat)) {
                    type = FormatType.MSEC_FRAC;
                } else {
                    type = FormatType.SDF;
                    format = tidyFormat(format);
                }
            }
            this.format = format;
            this.usesBegin = usesBegin;
            this.type = type;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            long timestamp = date.getTime();
            long frac;
            if (usesBegin) {
                timestamp -= time;
            }
            switch (type) {
            case CLF:
                buf.append(localDateCache.get().getFormat(timestamp));
                break;
            case SEC:
                buf.append(Long.toString(timestamp / 1000));
                break;
            case MSEC:
                buf.append(Long.toString(timestamp));
                break;
            case MSEC_FRAC:
                frac = timestamp % 1000;
                if (frac < 100) {
                    if (frac < 10) {
                        buf.append('0');
                        buf.append('0');
                    } else {
                        buf.append('0');
                    }
                }
                buf.append(Long.toString(frac));
                break;
            case SDF:
                String temp = localDateCache.get().getFormat(format, locale, timestamp);
                if (usesMsecs) {
                    frac = timestamp % 1000;
                    StringBuilder trippleMsec = new StringBuilder(4);
                    if (frac < 100) {
                        if (frac < 10) {
                            trippleMsec.append('0');
                            trippleMsec.append('0');
                        } else {
                            trippleMsec.append('0');
                        }
                    }
                    trippleMsec.append(frac);
                    temp = temp.replace(trippleMsecPattern, trippleMsec);
                    temp = temp.replace(msecPattern, Long.toString(frac));
                }
                buf.append(temp);
                break;
            }
        }
    }
    /**
     * write first line of the request (method and request URI) - %r
     */
    protected static class RequestElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (request != null) {
                String method = request.getMethod();
                if (method == null) {
                    // No method means no request line
                    buf.append('-');
                } else {
                    buf.append(request.getMethod());
                    buf.append(' ');
                    buf.append(request.getRequestURI());
                    if (request.getQueryString() != null) {
                        buf.append('?');
                        buf.append(request.getQueryString());
                    }
                    buf.append(' ');
                    buf.append(request.getProtocol());
                }
            } else {
                buf.append('-');
            }
        }
    }
    /**
     * write HTTP status code of the response - %s
     */
    protected static class HttpStatusCodeElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (response != null) {
                // This approach is used to reduce GC from toString conversion
                int status = response.getStatus();
                if (100 <= status && status < 1000) {
                    buf.append((char) ('0' + (status / 100)))
                            .append((char) ('0' + ((status / 10) % 10)))
                            .append((char) ('0' + (status % 10)));
                } else {
                   buf.append(Integer.toString(status));
                }
            } else {
                buf.append('-');
            }
        }
    }
    /**
     * write local port on which this request was received - %p
     */
    protected class LocalPortElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (requestAttributesEnabled) {
                Object port = request.getAttribute(SERVER_PORT_ATTRIBUTE);
                if (port == null) {
                    buf.append(Integer.toString(request.getServerPort()));
                } else {
                    buf.append(port.toString());
                }
            } else {
                buf.append(Integer.toString(request.getServerPort()));
            }
        }
    }
    /**
     * write bytes sent, excluding HTTP headers - %b, %B
     */
    protected static class ByteSentElement implements AccessLogElement {
        private final boolean conversion;
        /**
         * if conversion is true, write '-' instead of 0 - %b
         */
        public ByteSentElement(boolean conversion) {
            this.conversion = conversion;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            // Don't need to flush since trigger for log message is after the
            // response has been committed
            long length = response.getBytesWritten(false);
            if (length <= 0) {
                // Protect against nulls and unexpected types as these values
                // may be set by untrusted applications
                Object start = request.getAttribute(
                        Globals.SENDFILE_FILE_START_ATTR);
                if (start instanceof Long) {
                    Object end = request.getAttribute(
                            Globals.SENDFILE_FILE_END_ATTR);
                    if (end instanceof Long) {
                        length = ((Long) end).longValue() -
                                ((Long) start).longValue();
                    }
                }
            }
            if (length <= 0 && conversion) {
                buf.append('-');
            } else {
                buf.append(Long.toString(length));
            }
        }
    }
    /**
     * write request method (GET, POST, etc.) - %m
     */
    protected static class MethodElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (request != null) {
                buf.append(request.getMethod());
            }
        }
    }
    /**
     * write time taken to process the request - %D, %T
     */
    protected static class ElapsedTimeElement implements AccessLogElement {
        private final boolean millis;
        /**
         * if millis is true, write time in millis - %D
         * if millis is false, write time in seconds - %T
         */
        public ElapsedTimeElement(boolean millis) {
            this.millis = millis;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (millis) {
                buf.append(Long.toString(time));
            } else {
                // second
                buf.append(Long.toString(time / 1000));
                buf.append('.');
                int remains = (int) (time % 1000);
                buf.append(Long.toString(remains / 100));
                remains = remains % 100;
                buf.append(Long.toString(remains / 10));
                buf.append(Long.toString(remains % 10));
            }
        }
    }
    /**
     * write time until first byte is written (commit time) in millis - %F
     */
    protected static class FirstByteTimeElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request, Response response, long time) {
            long commitTime = response.getCoyoteResponse().getCommitTime();
            if (commitTime == -1) {
                buf.append('-');
            } else {
                long delta = commitTime - request.getCoyoteRequest().getStartTime();
                buf.append(Long.toString(delta));
            }
        }
    }
    /**
     * write Query string (prepended with a '?' if it exists) - %q
     */
    protected static class QueryElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            String query = null;
            if (request != null) {
                query = request.getQueryString();
            }
            if (query != null) {
                buf.append('?');
                buf.append(query);
            }
        }
    }
    /**
     * write user session ID - %S
     */
    protected static class SessionIdElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (request == null) {
                buf.append('-');
            } else {
                Session session = request.getSessionInternal(false);
                if (session == null) {
                    buf.append('-');
                } else {
                    buf.append(session.getIdInternal());
                }
            }
        }
    }
    /**
     * write requested URL path - %U
     */
    protected static class RequestURIElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (request != null) {
                buf.append(request.getRequestURI());
            } else {
                buf.append('-');
            }
        }
    }
    /**
     * write local server name - %v
     */
    protected static class LocalServerNameElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            buf.append(request.getServerName());
        }
    }
    /**
     * write any string
     */
    protected static class StringElement implements AccessLogElement {
        private final String str;
        public StringElement(String str) {
            this.str = str;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            buf.append(str);
        }
    }
    /**
     * write incoming headers - %{xxx}i
     */
    protected static class HeaderElement implements AccessLogElement {
        private final String header;
        public HeaderElement(String header) {
            this.header = header;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            Enumeration<String> iter = request.getHeaders(header);
            if (iter.hasMoreElements()) {
                buf.append(iter.nextElement());
                while (iter.hasMoreElements()) {
                    buf.append(',').append(iter.nextElement());
                }
                return;
            }
            buf.append('-');
        }
    }
    /**
     * write a specific cookie - %{xxx}c
     */
    protected static class CookieElement implements AccessLogElement {
        private final String header;
        public CookieElement(String header) {
            this.header = header;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            String value = "-";
            Cookie[] c = request.getCookies();
            if (c != null) {
                for (int i = 0; i < c.length; i++) {
                    if (header.equals(c[i].getName())) {
                        value = c[i].getValue();
                        break;
                    }
                }
            }
            buf.append(value);
        }
    }
    /**
     * write a specific response header - %{xxx}o
     */
    protected static class ResponseHeaderElement implements AccessLogElement {
        private final String header;
        public ResponseHeaderElement(String header) {
            this.header = header;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (null != response) {
                Iterator<String> iter = response.getHeaders(header).iterator();
                if (iter.hasNext()) {
                    buf.append(iter.next());
                    while (iter.hasNext()) {
                        buf.append(',').append(iter.next());
                    }
                    return;
                }
            }
            buf.append('-');
        }
    }
    /**
     * write an attribute in the ServletRequest - %{xxx}r
     */
    protected static class RequestAttributeElement implements AccessLogElement {
        private final String header;
        public RequestAttributeElement(String header) {
            this.header = header;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            Object value = null;
            if (request != null) {
                value = request.getAttribute(header);
            } else {
                value = "??";
            }
            if (value != null) {
                if (value instanceof String) {
                    buf.append((String) value);
                } else {
                    buf.append(value.toString());
                }
            } else {
                buf.append('-');
            }
        }
    }
    /**
     * write an attribute in the HttpSession - %{xxx}s
     */
    protected static class SessionAttributeElement implements AccessLogElement {
        private final String header;
        public SessionAttributeElement(String header) {
            this.header = header;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            Object value = null;
            if (null != request) {
                HttpSession sess = request.getSession(false);
                if (null != sess) {
                    value = sess.getAttribute(header);
                }
            } else {
                value = "??";
            }
            if (value != null) {
                if (value instanceof String) {
                    buf.append((String) value);
                } else {
                    buf.append(value.toString());
                }
            } else {
                buf.append('-');
            }
        }
    }
    /**
     * parse pattern string and create the array of AccessLogElement
     */
    protected AccessLogElement[] createLogElements() {
        List<AccessLogElement> list = new ArrayList<>();
        boolean replace = false;
        StringBuilder buf = new StringBuilder();
        for (int i = 0; i < pattern.length(); i++) {
            char ch = pattern.charAt(i);
            if (replace) {
                /*
                 * For code that processes {, the behavior will be ... if I do
                 * not encounter a closing } - then I ignore the {
                 */
                if ('{' == ch) {
                    StringBuilder name = new StringBuilder();
                    int j = i + 1;
                    for (; j < pattern.length() && '}' != pattern.charAt(j); j++) {
                        name.append(pattern.charAt(j));
                    }
                    if (j + 1 < pattern.length()) {
                        /* the +1 was to account for } which we increment now */
                        j++;
                        list.add(createAccessLogElement(name.toString(),
                                pattern.charAt(j)));
                        i = j; /* Since we walked more than one character */
                    } else {
                        // D'oh - end of string - pretend we never did this
                        // and do processing the "old way"
                        list.add(createAccessLogElement(ch));
                    }
                } else {
                    list.add(createAccessLogElement(ch));
                }
                replace = false;
            } else if (ch == '%') {
                replace = true;
                list.add(new StringElement(buf.toString()));
                buf = new StringBuilder();
            } else {
                buf.append(ch);
            }
        }
        if (buf.length() > 0) {
            list.add(new StringElement(buf.toString()));
        }
        return list.toArray(new AccessLogElement[0]);
    }
    /**
     * create an AccessLogElement implementation which needs header string
     */
    protected AccessLogElement createAccessLogElement(String header, char pattern) {
        switch (pattern) {
        case 'i':
            return new HeaderElement(header);
        case 'c':
            return new CookieElement(header);
        case 'o':
            return new ResponseHeaderElement(header);
        case 'r':
            return new RequestAttributeElement(header);
        case 's':
            return new SessionAttributeElement(header);
        case 't':
            return new DateAndTimeElement(header);
        default:
            return new StringElement("???");
        }
    }
    /**
     * create an AccessLogElement implementation
     */
    protected AccessLogElement createAccessLogElement(char pattern) {
        switch (pattern) {
        case 'a':
            return new RemoteAddrElement();
        case 'A':
            return new LocalAddrElement();
        case 'b':
            return new ByteSentElement(true);
        case 'B':
            return new ByteSentElement(false);
        case 'D':
            return new ElapsedTimeElement(true);
        case 'F':
            return new FirstByteTimeElement();
        case 'h':
            return new HostElement();
        case 'H':
            return new ProtocolElement();
        case 'l':
            return new LogicalUserNameElement();
        case 'm':
            return new MethodElement();
        case 'p':
            return new LocalPortElement();
        case 'q':
            return new QueryElement();
        case 'r':
            return new RequestElement();
        case 's':
            return new HttpStatusCodeElement();
        case 'S':
            return new SessionIdElement();
        case 't':
            return new DateAndTimeElement();
        case 'T':
            return new ElapsedTimeElement(false);
        case 'u':
            return new UserElement();
        case 'U':
            return new RequestURIElement();
        case 'v':
            return new LocalServerNameElement();
        case 'I':
            return new ThreadNameElement();
        default:
            return new StringElement("???" + pattern + "???");
        }
    }

======= fetch "public SocketState process(SocketWrapper<S> wrapper," bd24edc^:"java/org/apache/coyote/AbstractProtocol.java"

                        state = processor.asyncDispatch(
                                nextDispatch.getSocketStatus());
    private final AbstractServletOutputStream upgradeServletOutputStream;
======= fetch "protected AbstractProcessor (HttpUpgradeHandler httpUpgradeHandler," bd24edc^:"java/org/apache/coyote/http11/upgrade/AbstractProcessor.java"

            AbstractServletOutputStream upgradeServletOutputStream) {
======= fetch "public final boolean isReady() {" bd24edc^:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

======= fetch "public final void setWriteListener(WriteListener listener) {" bd24edc^:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

        // Container is responsible for first call to onWritePossible() but only
        // need to do this if setting the listener for the first time rather
        // than changing it.
        synchronized (fireListenerLock) {
            fireListener = true;
        }
        socketWrapper.addDispatch(DispatchType.NON_BLOCKING_WRITE);
======= fetch "public final void setWriteListener(WriteListener listener) {" bd24edc^:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

======= fetch "protected final boolean isCloseRequired() {" bd24edc^:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

======= fetch "public void close() throws IOException {" bd24edc^:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

======= fetch "protected final void onWritePossible() throws IOException {" bd24edc^:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

                writeInternal(buffer, 0, buffer.length);
======= fetch "protected final void onWritePossible() throws IOException {" bd24edc^:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

           // Make sure isReady() and onWritePossible() have a consistent view of
            // buffer and fireListener when determining if the listener should fire
======= fetch "protected final void onWritePossible() throws IOException {" bd24edc^:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

    private final SocketWrapper<Long> wrapper;
    public AprServletOutputStream(SocketWrapper<Long> wrapper,
======= fetch "public AprServletOutputStream(SocketWrapper<Long> wrapper," bd24edc^:"java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java"

        super(socketWrapper);
======= fetch "public AprServletOutputStream(SocketWrapper<Long> wrapper," bd24edc^:"java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java"

        this.wrapper = wrapper;
        this.socket = wrapper.getSocket().longValue();
======= fetch "protected int doWrite(boolean block, byte[] b, int off, int len)" bd24edc^:"java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java"

        Lock readLock = wrapper.getBlockingStatusReadLock();
        WriteLock writeLock = wrapper.getBlockingStatusWriteLock();
======= fetch "protected int doWrite(boolean block, byte[] b, int off, int len)" bd24edc^:"java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java"

            if (wrapper.getBlockingStatus() == block) {
======= fetch "protected int doWrite(boolean block, byte[] b, int off, int len)" bd24edc^:"java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java"

            wrapper.setBlockingStatus(block);
======= fetch "private int doWriteInternal(byte[] b, int off, int len) throws IOException {" bd24edc^:"java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java"

                        Integer.valueOf(-written), Long.valueOf(socket), wrapper));
    public BioServletOutputStream(SocketWrapper<Socket> wrapper)
======= fetch "public BioServletOutputStream(SocketWrapper<Socket> wrapper)" bd24edc^:"java/org/apache/coyote/http11/upgrade/BioServletOutputStream.java"

        os = wrapper.getSocket().getOutputStream();
======= fetch "public NioServletOutputStream(" bd24edc^:"java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java"

            SocketWrapper<NioChannel> wrapper, NioSelectorPool pool) {
        channel = wrapper.getSocket();
======= fetch "public void testSetWriteListenerTwice() throws Exception {" bd24edc^:"test/org/apache/coyote/http11/upgrade/TestUpgrade.java"

    @Test
    public void testFirstCallToOnWritePossible() throws Exception {
        doTestFixedResponse(FixedResponseNonBlocking.class);
    }
======= fetch "private void doTestCheckClosed(" bd24edc^:"test/org/apache/coyote/http11/upgrade/TestUpgrade.java"

    private void doTestFixedResponse(
            Class<? extends HttpUpgradeHandler> upgradeHandlerClass)
                    throws Exception {
        UpgradeConnection conn = doUpgrade(upgradeHandlerClass);
        Reader r = conn.getReader();
        int c = r.read();
        Assert.assertEquals(FixedResponseNonBlocking.FIXED_RESPONSE, c);
    }
======= fetch "public void destroy() {" bd24edc^:"test/org/apache/coyote/http11/upgrade/TestUpgrade.java"

    public static class FixedResponseNonBlocking implements HttpUpgradeHandler {
        public static final char FIXED_RESPONSE = 'F';
        private ServletInputStream sis;
        private ServletOutputStream sos;
        @Override
        public void init(WebConnection connection) {
            try {
                sis = connection.getInputStream();
                sos = connection.getOutputStream();
            } catch (IOException ioe) {
                throw new IllegalStateException(ioe);
            }
            sis.setReadListener(new NoOpReadListener());
            sos.setWriteListener(new FixedResponseWriteListener());
        }
        @Override
        public void destroy() {
            // NO-OP
        }
        private class FixedResponseWriteListener extends NoOpWriteListener {
            @Override
            public void onWritePossible() {
                try {
                    sos.write(FIXED_RESPONSE);
                    sos.flush();
                } catch (IOException ioe) {
                    throw new IllegalStateException(ioe);
                }
            }
        }
    }
======= fetch "public void onError(Throwable throwable) {" bd24edc^:"test/org/apache/coyote/http11/upgrade/TestUpgrade.java"


======= fetch "protected boolean breakKeepAliveLoop(" d423ae2^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

        openSocket = keepAlive;
======= fetch "protected boolean breakKeepAliveLoop(" d423ae2^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            openSocket = socketWrapper.getSocket().getPoller().processSendfile(key,
                    (KeyAttachment) socketWrapper, true);

    private final Set<SAXParseException> errors = new HashSet<>();
    private final Set<SAXParseException> warnings = new HashSet<>();
======= fetch "public void warning(SAXParseException exception) throws SAXException {" 328adb1^:"java/org/apache/tomcat/util/descriptor/XmlErrorHandler.java"

    public Set<SAXParseException> getErrors() {
======= fetch "public void warning(SAXParseException exception) throws SAXException {" 328adb1^:"java/org/apache/tomcat/util/descriptor/XmlErrorHandler.java"

    public Set<SAXParseException> getWarnings() {

======= fetch "public boolean modified() {" 5594699^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (jars.length > jarModificationTimes.size()) {
            log.info(sm.getString("webappClassLoader.jarsAdded",
                    resources.getContext().getName()));
            return true;
        } else if (jars.length < jarModificationTimes.size()){
            log.info(sm.getString("webappClassLoader.jarsRemoved",
                    resources.getContext().getName()));
            return true;
        }
======= fetch "public boolean modified() {" 5594699^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        int jarCount = 0;
======= fetch "public boolean modified() {" 5594699^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                jarCount++;
======= fetch "public boolean modified() {" 5594699^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                    // Jars have been added and removed
======= fetch "public boolean modified() {" 5594699^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                jarModificationTimes.put(
                        jar.getName(), Long.valueOf(jar.getLastModified()));
======= fetch "public boolean modified() {" 5594699^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (jarCount < jarModificationTimes.size()){
            log.info(sm.getString("webappClassLoader.jarsRemoved",
                    resources.getContext().getName()));
            return true;
        }

    private static final int SHORT_TIMEOUT_SECS = 4;
    private static final long SHORT_TIMEOUT_DELAY_MSECS =
                                    ((SHORT_TIMEOUT_SECS + 3) * 1000);
    private static final int LONG_TIMEOUT_SECS = 10;
    private static final long LONG_TIMEOUT_DELAY_MSECS =
                                    ((LONG_TIMEOUT_SECS + 5) * 1000);
    private static String CLIENT_AUTH_HEADER = "authorization";
    private static String SERVER_COOKIES = "Set-Cookie";
    private static String BROWSER_COOKIES = "Cookie";
     * Try to access an unprotected resource without an established
     * SSO session.
     * This should be permitted.
    public void testAcceptPublicNonLogin() throws Exception {
======= fetch "public void testAcceptPublicNonLogin() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

                        false, false, 200);
======= fetch "public void testAcceptPublicNonLogin() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

    /*
     * Try to access a protected resource without an established
     * SSO session.
     * This should be rejected with SC_FORBIDDEN 403 status.
     */
======= fetch "public void testAcceptPublicNonLogin() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

    public void testRejectProtectedNonLogin() throws Exception {
======= fetch "public void testRejectProtectedNonLogin() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

                        false, true, 403);
======= fetch "public void testRejectProtectedNonLogin() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

     * the resource.
     * This should be rejected with SC_FORBIDDEN 401 status, which
     * will then be followed by successful re-authentication.
======= fetch "public void testRejectProtectedNonLogin() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

    public void testBasicLoginSessionTimeout() throws Exception {
        doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED,
                true, 401, false, 200);
        // wait long enough for my session to expire
        Thread.sleep(SHORT_TIMEOUT_DELAY_MSECS);
        doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED,
                true, 401, false, 200);
======= fetch "public void testBasicLoginSessionTimeout() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

======= fetch "public void testBasicLoginSessionTimeout() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

     * webapp, but without sending the SSO session cookie.
     * This should be rejected with SC_FORBIDDEN 403 status.
======= fetch "public void testBasicLoginSessionTimeout() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

    public void testBasicLoginRejectProtectedWithoutCookies() throws Exception {
        doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED,
                true, 401, false, 200);
======= fetch "public void testBasicLoginRejectProtectedWithoutCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

                        false, true, 403);
======= fetch "public void testBasicLoginRejectProtectedWithoutCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

     * webapp while sending the SSO session cookie provided by the
     * first webapp.
     * This should be successful with SC_OK 200 status.
======= fetch "public void testBasicLoginRejectProtectedWithoutCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

    public void testBasicLoginAcceptProtectedWithCookies() throws Exception {
        doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED,
                true, 401, false, 200);
======= fetch "public void testBasicLoginAcceptProtectedWithCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

                        true, false, 200);
======= fetch "public void testBasicLoginAcceptProtectedWithCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

     * webapp while sending the SSO session cookie provided by the
     * first webapp.
     * This should be successful with SC_OK 200 status.
======= fetch "public void testBasicLoginAcceptProtectedWithCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

     *
======= fetch "public void testBasicLoginAcceptProtectedWithCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

     * has expired.
     * This should be successful with SC_OK 200 status.
======= fetch "public void testBasicLoginAcceptProtectedWithCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

     *
     * Note: this test will run for slightly more than 3 minutes.
======= fetch "public void testBasicExpiredAcceptProtectedWithCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED,
                true, 401, false, 200);
======= fetch "public void testBasicExpiredAcceptProtectedWithCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

                        true, false, 200);
======= fetch "public void testBasicExpiredAcceptProtectedWithCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        // but not long enough for NonLogin session expiry
        Thread.sleep(SHORT_TIMEOUT_DELAY_MSECS);
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                        true, false, 200);
======= fetch "public void testBasicExpiredAcceptProtectedWithCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        // wait long enough for my NonLogin session to expire
        // and tear down the SSO session at the same time.
        Thread.sleep(LONG_TIMEOUT_DELAY_MSECS);
======= fetch "public void testBasicExpiredAcceptProtectedWithCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

                        false, true, 403);
======= fetch "public void testBasicExpiredAcceptProtectedWithCookies() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

    public void doTestNonLogin(String uri, boolean addCookies,
            boolean expectedReject, int expectedRC)
            throws Exception {
======= fetch "public void doTestNonLogin(String uri, boolean addCookies," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        if (addCookies) {
            addCookies(reqHeaders);
        }
======= fetch "public void doTestNonLogin(String uri, boolean addCookies," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        if (useCookie && (cookies != null)) {
            reqHeaders.put(CLIENT_COOKIE_HEADER + ":", cookies);
        }
======= fetch "public void doTestNonLogin(String uri, boolean addCookies," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        if (expectedReject) {
======= fetch "public void doTestNonLogin(String uri, boolean addCookies," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

            assertEquals(200, rc);
======= fetch "public void doTestNonLogin(String uri, boolean addCookies," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

            saveCookies(respHeaders);
======= fetch "public void doTestNonLogin(String uri, boolean addCookies," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

    public void doTestBasic(String user, String pwd, String uri,
            boolean expectedReject1, int expectedRC1,
            boolean expectedReject2, int expectedRC2) throws Exception {
        // the first access attempt should be challenged
        Map<String,List<String>> reqHeaders1 = new HashMap<>();
        Map<String,List<String>> respHeaders1 = new HashMap<>();
======= fetch "public void doTestBasic(String user, String pwd, String uri," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        ByteChunk bc = new ByteChunk();
        int rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders1,
                respHeaders1);
======= fetch "public void doTestBasic(String user, String pwd, String uri," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        if (expectedReject1) {
            assertEquals(expectedRC1, rc);
            assertTrue(bc.getLength() > 0);
======= fetch "public void doTestBasic(String user, String pwd, String uri," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

            assertEquals(200, rc);
            assertEquals("OK", bc.toString());
            return;
======= fetch "public void doTestBasic(String user, String pwd, String uri," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        // the second access attempt should be successful
        String credentials = user + ":" + pwd;
        String base64auth = Base64.encodeBase64String(
                credentials.getBytes(StandardCharsets.ISO_8859_1));
        String authLine = "Basic " + base64auth;
        List<String> auth = new ArrayList<>();
        auth.add(authLine);
        Map<String,List<String>> reqHeaders2 = new HashMap<>();
        reqHeaders2.put(CLIENT_AUTH_HEADER, auth);
        Map<String,List<String>> respHeaders2 = new HashMap<>();
        bc.recycle();
        rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders2,
                respHeaders2);
======= fetch "public void doTestBasic(String user, String pwd, String uri," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        if (expectedReject2) {
            assertEquals(expectedRC2, rc);
            assertNull(bc.toString());
======= fetch "public void doTestBasic(String user, String pwd, String uri," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

            assertEquals(200, rc);
            assertEquals("OK", bc.toString());
            saveCookies(respHeaders2);
======= fetch "public void doTestBasic(String user, String pwd, String uri," ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

    /*
     * setup two webapps for every test
     *
     * note: the super class tearDown method will stop tomcat
     */
======= fetch "public void setUp() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        Tomcat tomcat = getTomcatInstance();
======= fetch "public void setUp() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        setUpNonLogin(tomcat);
        setUpLogin(tomcat);
======= fetch "public void setUp() throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

    private void setUpNonLogin(Tomcat tomcat) throws Exception {
======= fetch "private void setUpNonLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN,
======= fetch "private void setUpNonLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        ctxt.setSessionTimeout(LONG_TIMEOUT_SECS);
======= fetch "private void setUpNonLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        // Add protected servlet
        Tomcat.addServlet(ctxt, "TesterServlet1", new TesterServlet());
        ctxt.addServletMapping(URI_PROTECTED, "TesterServlet1");
======= fetch "private void setUpNonLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        ctxt.addConstraint(sc1);
======= fetch "private void setUpNonLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        // Add unprotected servlet
        Tomcat.addServlet(ctxt, "TesterServlet2", new TesterServlet());
        ctxt.addServletMapping(URI_PUBLIC, "TesterServlet2");
======= fetch "private void setUpNonLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        ctxt.addConstraint(sc2);
======= fetch "private void setUpNonLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        ctxt.setLoginConfig(lc);
        ctxt.getPipeline().addValve(new NonLoginAuthenticator());
======= fetch "private void setUpNonLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

    private void setUpLogin(Tomcat tomcat) throws Exception {
======= fetch "private void setUpLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        Context ctxt = tomcat.addContext(CONTEXT_PATH_LOGIN,
======= fetch "private void setUpLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        ctxt.setSessionTimeout(SHORT_TIMEOUT_SECS);
        // Add protected servlet
        Tomcat.addServlet(ctxt, "TesterServlet3", new TesterServlet());
        ctxt.addServletMapping(URI_PROTECTED, "TesterServlet3");
======= fetch "private void setUpLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        // Add protected servlet to the context
        Tomcat.addServlet(basicContext, "TesterServlet3",
                new TesterServletEncodeUrl());
        basicContext.addServletMapping(URI_PROTECTED, "TesterServlet3");
======= fetch "private void setUpLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        ctxt.addConstraint(sc);
======= fetch "private void setUpLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        // Configure the appropriate authenticator
======= fetch "private void setUpLogin(Tomcat tomcat) throws Exception {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        ctxt.setLoginConfig(lc);
        ctxt.getPipeline().addValve(new BasicAuthenticator());
======= fetch "protected void saveCookies(Map<String,List<String>> respHeaders) {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        cookies = respHeaders.get(SERVER_COOKIES);
======= fetch "protected void addCookies(Map<String,List<String>> reqHeaders) {" ad129f8^:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

            reqHeaders.put(BROWSER_COOKIES + ":", cookies);

======= fetch "public String getMBeanKeyProperties() {" 5964a52^:"java/org/apache/catalina/core/ContainerBase.java"

                ContextName cn = new ContextName(c.getName());
======= fetch "public void fileModified(File newWar) {" 5964a52^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            ContextName cn = new ContextName(deployWar.getName());
======= fetch "public void fileRemoved(File removeWar) {" 5964a52^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            ContextName cn = new ContextName(removeWar.getName());
======= fetch "protected String upload(HttpServletRequest request, StringManager smClient)" 5964a52^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                ContextName cn = new ContextName(filename);
======= fetch "public static ObjectName createObjectName(String domain," 5964a52^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

            ContextName cn = new ContextName(context.getName());
======= fetch "public static ObjectName createObjectName(String domain," 5964a52^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

            ContextName cn = new ContextName(context.getName());
======= fetch "public static ObjectName createObjectName(String domain," 5964a52^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

            ContextName cn = new ContextName(context.getName());
======= fetch "static ObjectName createObjectName(String domain, Loader loader)" 5964a52^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        ContextName cn = new ContextName(context.getName());
======= fetch "public String getMBeanKeyProperties() {" 5964a52^:"java/org/apache/catalina/startup/FailedContext.java"

                ContextName cn = new ContextName(c.getName());
======= fetch "protected void deployApps(String name) {" 5964a52^:"java/org/apache/catalina/startup/HostConfig.java"

        ContextName cn = new ContextName(name);
======= fetch "protected void deployDescriptors(File configBase, String[] files) {" 5964a52^:"java/org/apache/catalina/startup/HostConfig.java"

                ContextName cn = new ContextName(files[i]);
======= fetch "protected void deployWARs(File appBase, String[] files) {" 5964a52^:"java/org/apache/catalina/startup/HostConfig.java"

                ContextName cn = new ContextName(files[i]);
======= fetch "protected void deployDirectories(File appBase, String[] files) {" 5964a52^:"java/org/apache/catalina/startup/HostConfig.java"

                ContextName cn = new ContextName(files[i]);
======= fetch "public synchronized void checkUndeploy() {" 5964a52^:"java/org/apache/catalina/startup/HostConfig.java"

        ContextName previous = new ContextName(iter.next());
======= fetch "public synchronized void checkUndeploy() {" 5964a52^:"java/org/apache/catalina/startup/HostConfig.java"

            ContextName current = new ContextName(iter.next());
======= fetch "public void store(PrintWriter aWriter, int indent, Object aContext)" 5964a52^:"java/org/apache/catalina/storeconfig/StandardContextSF.java"

                    ContextName cn = new ContextName(context.getName());
    public ContextName(String name) {
======= fetch "public ContextName(String name) {" 5964a52^:"java/org/apache/catalina/util/ContextName.java"

        if (tmp1.toLowerCase(Locale.ENGLISH).endsWith(".war") ||
                tmp1.toLowerCase(Locale.ENGLISH).endsWith(".xml")) {
    private static final ContextName  APP_NAME = new ContextName("myapp");
======= fetch "public void setUp() throws Exception {" 5964a52^:"test/org/apache/catalina/util/TestContextName.java"

        cn11 = new ContextName("ROOT");
        cn12 = new ContextName("foo");
        cn13 = new ContextName("foo#bar");
        cn14 = new ContextName("ROOT##A");
        cn15 = new ContextName("foo##D");
        cn16 = new ContextName("foo#bar##E");
======= fetch "public void setUp() throws Exception {" 5964a52^:"test/org/apache/catalina/util/TestContextName.java"

        cn18 = new ContextName("/ROOT#bar");
        cn19 = new ContextName("/ROOT#bar##A");
        cn20 = new ContextName("/ROOT##A");
======= fetch "public void testGetBaseName() {" 5964a52^:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("foo.war", cn21.getBaseName());
        assertEquals("foo", cn22.getBaseName());
======= fetch "public void testGetPath() {" 5964a52^:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("/foo.war", cn21.getPath());
        assertEquals("/foo", cn22.getPath());
======= fetch "public void testGetVersion() {" 5964a52^:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("", cn21.getVersion());
        assertEquals("", cn22.getVersion());
======= fetch "public void testGetName() {" 5964a52^:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("/foo.war", cn21.getName());
        assertEquals("/foo", cn22.getName());
======= fetch "public void testGetDisplayName() {" 5964a52^:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("/foo.war", cn21.getDisplayName());
        assertEquals("/foo", cn22.getDisplayName());
======= fetch "public void testConstructorString() {" 5964a52^:"test/org/apache/catalina/util/TestContextName.java"

        doTestConstructorString(cn21);
        doTestConstructorString(cn22);
======= fetch "private void doTestConstructorString(ContextName src) {" 5964a52^:"test/org/apache/catalina/util/TestContextName.java"

        doCompare(src, new ContextName(src.getBaseName()));
        doCompare(src, new ContextName(src.getDisplayName()));
        doCompare(src, new ContextName(src.getName()));

======= fetch "public ContextName(String path, String version) {" 346e264^:"java/org/apache/catalina/util/ContextName.java"

        // Path should never be null or '/'
        if (path == null || "/".equals(path)) {
======= fetch "public void setUp() throws Exception {" 346e264^:"test/org/apache/catalina/util/TestContextName.java"

        cn17 = new ContextName("/ROOT", null);
        cn18 = new ContextName("/ROOT#bar");
        cn19 = new ContextName("/ROOT#bar##A");
        cn20 = new ContextName("/ROOT##A");
======= fetch "public void testGetBaseName() {" 346e264^:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("ROOT", cn17.getBaseName());
        assertEquals("ROOT#bar", cn18.getBaseName());
        assertEquals("ROOT#bar##A", cn19.getBaseName());
        assertEquals("ROOT##A", cn20.getBaseName());
======= fetch "public void testGetPath() {" 346e264^:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("", cn17.getPath());
        assertEquals("/ROOT/bar", cn18.getPath());
        assertEquals("/ROOT/bar", cn19.getPath());
        assertEquals("", cn20.getPath());
======= fetch "public void testGetVersion() {" 346e264^:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("", cn17.getVersion());
        assertEquals("", cn18.getVersion());
        assertEquals("A", cn19.getVersion());
        assertEquals("A", cn20.getVersion());
======= fetch "public void testGetName() {" 346e264^:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("", cn17.getName());
        assertEquals("/ROOT/bar", cn18.getName());
        assertEquals("/ROOT/bar##A", cn19.getName());
        assertEquals("##A", cn20.getName());
======= fetch "public void testGetDisplayName() {" 346e264^:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("/", cn17.getDisplayName());
        assertEquals("/ROOT/bar", cn18.getDisplayName());
        assertEquals("/ROOT/bar##A", cn19.getDisplayName());
        assertEquals("/##A", cn20.getDisplayName());
======= fetch "public void testConstructorString() {" 346e264^:"test/org/apache/catalina/util/TestContextName.java"

        doTestConstructorString(cn17);
        doTestConstructorString(cn18);
        doTestConstructorString(cn19);
        doTestConstructorString(cn20);

======= fetch "public void recycle() {" 411e4cc^:"java/org/apache/coyote/Response.java"

        // Servlet 3.1 non-blocking write listener
======= fetch "public void recycle() {" 411e4cc^:"java/org/apache/coyote/Response.java"

        fireListener = false;
        registeredForWrite = false;

======= fetch "protected void scanJspConfig() throws IOException, SAXException {" bcb9c58^:"java/org/apache/jasper/servlet/TldScanner.java"

            TldResourcePath tldResourcePath;
            if (resourcePath.endsWith(".jar")) {
                // if the path points to a jar file, the TLD is presumed to be
                // inside at META-INF/taglib.tld
                tldResourcePath = new TldResourcePath(
                        url, resourcePath, "META-INF/taglib.tld");
======= fetch "protected void scanJspConfig() throws IOException, SAXException {" bcb9c58^:"java/org/apache/jasper/servlet/TldScanner.java"

                tldResourcePath = new TldResourcePath(url, resourcePath);
            }
            // parse TLD but store using the URI supplied in the descriptor
            TaglibXml tld = tldParser.parse(tldResourcePath);
            uriTldResourcePathMap.put(taglibURI, tldResourcePath);
            tldResourcePathTaglibXmlMap.put(tldResourcePath, tld);
            if (tld.getListeners() != null) {
                listeners.addAll(tld.getListeners());

======= fetch "private String initClassPath() {" 8a5179c^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

            for(int i = 0; i < urls.length; i++) {
                // Tomcat 4 can use URL's other than file URL's,
                // a protocol other than file: will generate a
                // bad file system path, so only add file:
                // protocol URL's to the classpath.
                if( urls[i].getProtocol().equals("file") ) {
                    cpath.append(urls[i].getFile()+sep);

 * <td>10\.\d{1,3}\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|169\.254\.\d{1,3}\.\d{1,3}|127\.\d{1,3}\.\d{1,3}\.\d{1,3} <br/>
 * By default, 10/8, 192.168/16, 169.254/16 and 127/8 are allowed ; 172.16/12 has not been enabled by default because it is complex to
 * describe with regular expressions</td>
======= fetch "protected static String listToCommaDelimitedString(List<String> stringList) {" c1be72f^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            "127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}");
 * <td>10\.\d{1,3}\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|169\.254\.\d{1,3}\.\d{1,3}|127\.\d{1,3}\.\d{1,3}\.\d{1,3}<br/>
 * By default, 10/8, 192.168/16, 169.254/16 and 127/8 are allowed ; 172.16/12 has not been enabled by default because it is complex to
 * describe with regular expressions</td>
======= fetch "protected static String listToCommaDelimitedString(List<String> stringList) {" c1be72f^:"java/org/apache/catalina/valves/RemoteIpValve.java"

            "127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}");
        10\.\d{1,3}\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|169\.254\.\d{1,3}\.\d{1,3}|127\.\d{1,3}\.\d{1,3}\.\d{1,3}
        10\.\d{1,3}\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|169\.254\.\d{1,3}\.\d{1,3}|127\.\d{1,3}\.\d{1,3}\.\d{1,3}

======= fetch "protected void webConfig() {" f4da7dc^:"java/org/apache/catalina/startup/ContextConfig.java"

        Map<String,WebXml> fragments = processJarsForWebFragments();
======= fetch "protected InputSource getWebXmlSource(String filename, String path) {" f4da7dc^:"java/org/apache/catalina/startup/ContextConfig.java"

    protected Map<String,WebXml> processJarsForWebFragments() {
======= fetch "protected InputSource getWebXmlSource(String filename, String path) {" f4da7dc^:"java/org/apache/catalina/startup/ContextConfig.java"

        boolean parseRequired = true;
        Set<String> absoluteOrder = application.getAbsoluteOrdering();
        if (absoluteOrder != null && absoluteOrder.isEmpty() &&
                !context.getXmlValidation()) {
            // Skip parsing when there is an empty absolute ordering and
            // validation is not enabled
            parseRequired = false;
        }
======= fetch "protected InputSource getWebXmlSource(String filename, String path) {" f4da7dc^:"java/org/apache/catalina/startup/ContextConfig.java"

                new FragmentJarScannerCallback(webXmlParser, delegate);
======= fetch "private WebXml buildMergedWebXml() throws JasperException {" f4da7dc^:"java/org/apache/jasper/servlet/JspCServletContext.java"

        // If an empty absolute ordering element is present, fragment processing
        // may be skipped.
        Set<String> absoluteOrdering = webXml.getAbsoluteOrdering();
        if (absoluteOrdering != null && absoluteOrdering.isEmpty()) {
            return webXml;
        }
======= fetch "private WebXml buildMergedWebXml() throws JasperException {" f4da7dc^:"java/org/apache/jasper/servlet/JspCServletContext.java"

        FragmentJarScannerCallback callback = new FragmentJarScannerCallback(webXmlParser, false);
    public FragmentJarScannerCallback(WebXmlParser webXmlParser, boolean delegate) {
======= fetch "public FragmentJarScannerCallback(WebXmlParser webXmlParser, boolean delegate) {" f4da7dc^:"java/org/apache/tomcat/util/descriptor/web/FragmentJarScannerCallback.java"

        this.parseRequired = parseRequired;
======= fetch "public void scan(JarURLConnection jarConn, String webappPath, boolean isWebapp)" f4da7dc^:"java/org/apache/tomcat/util/descriptor/web/FragmentJarScannerCallback.java"

            // files
            if (isWebapp) {

    /**
     * Property name to set to configure used SSLContext. The value should be an
     * instance of SSLContext. If this property is present, the SSL_TRUSTSTORE*
     * properties are ignored.
     */
    public static final String SSL_CONTEXT_PROPERTY =
            "org.apache.tomcat.websocket.SSL_CONTEXT";
======= fetch "private SSLEngine createSSLEngine(Map<String,Object> userProperties)" ef3f56e^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

            // Create the SSL Context
            SSLContext sslContext = SSLContext.getInstance("TLS");
            // Trust store
            String sslTrustStoreValue =
                    (String) userProperties.get(SSL_TRUSTSTORE_PROPERTY);
            if (sslTrustStoreValue != null) {
                String sslTrustStorePwdValue = (String) userProperties.get(
                        SSL_TRUSTSTORE_PWD_PROPERTY);
                if (sslTrustStorePwdValue == null) {
                    sslTrustStorePwdValue = SSL_TRUSTSTORE_PWD_DEFAULT;
                }
======= fetch "private SSLEngine createSSLEngine(Map<String,Object> userProperties)" ef3f56e^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

                File keyStoreFile = new File(sslTrustStoreValue);
                KeyStore ks = KeyStore.getInstance("JKS");
                try (InputStream is = new FileInputStream(keyStoreFile)) {
                    ks.load(is, sslTrustStorePwdValue.toCharArray());
                }
======= fetch "private SSLEngine createSSLEngine(Map<String,Object> userProperties)" ef3f56e^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

                TrustManagerFactory tmf = TrustManagerFactory.getInstance(
                        TrustManagerFactory.getDefaultAlgorithm());
                tmf.init(ks);
======= fetch "private SSLEngine createSSLEngine(Map<String,Object> userProperties)" ef3f56e^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

                sslContext.init(null, tmf.getTrustManagers(), null);
            } else {
                sslContext.init(null, null, null);

======= fetch "public GSSCredential run() throws GSSException {" bba9747^:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

            outToken = gssContext.acceptSecContext(decoded, 0, decoded.length);
======= fetch "public GSSCredential run() throws GSSException {" bba9747^:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

    /**
     * This class gets a gss credential via a privileged action.
     */
    private static class AcceptAction implements PrivilegedExceptionAction<byte[]> {
        GSSContext gssContext;
        byte[] decoded;
        AcceptAction(GSSContext context, byte[] decodedToken) {
            this.gssContext = context;
            this.decoded = decodedToken;
        }
        @Override
        public byte[] run() throws GSSException {
            return gssContext.acceptSecContext(decoded,
                    0, decoded.length);
        }
    }

======= fetch "public void realWriteChars(char buf[], int off, int len)" f4970a7^:"java/org/apache/catalina/connector/OutputBuffer.java"

                bb.flushBuffer();
======= fetch "public void flushBuffer()" f4970a7^:"java/org/apache/tomcat/util/buf/ByteChunk.java"

    /** Make space for len chars. If len is small, allocate
     *        a reserve space too. Never grow bigger than limit.
======= fetch "public void flushBuffer()" f4970a7^:"java/org/apache/tomcat/util/buf/ByteChunk.java"

    private void makeSpace(int count)
    {

======= fetch "public WebResource getResource(String path) {" a63bf3a^:"java/org/apache/catalina/webresources/DirResourceSet.java"

            File f = file(path.substring(webAppMount.length()), true);
======= fetch "public WebResource getResource(String path) {" a63bf3a^:"java/org/apache/catalina/webresources/DirResourceSet.java"

            if (!f.exists()) {
                return new EmptyResource(root, path, f);
            }
    private final File file;
======= fetch "public EmptyResource(WebResourceRoot root, String webAppPath) {" a63bf3a^:"java/org/apache/catalina/webresources/EmptyResource.java"

        this(root, webAppPath, null);
    }
    public EmptyResource(WebResourceRoot root, String webAppPath, File file) {
======= fetch "public EmptyResource(WebResourceRoot root, String webAppPath) {" a63bf3a^:"java/org/apache/catalina/webresources/EmptyResource.java"

        this.file = file;
======= fetch "public String getCanonicalPath() {" a63bf3a^:"java/org/apache/catalina/webresources/EmptyResource.java"

        return null;
======= fetch "protected final WebResource getResourceInternal(String path," a63bf3a^:"java/org/apache/catalina/webresources/StandardRoot.java"

        WebResource mainEmpty = null;
======= fetch "protected final WebResource getResourceInternal(String path," a63bf3a^:"java/org/apache/catalina/webresources/StandardRoot.java"

                    if (virtual == null && result.isVirtual()) {
                        virtual = result;
======= fetch "protected final WebResource getResourceInternal(String path," a63bf3a^:"java/org/apache/catalina/webresources/StandardRoot.java"

        return new EmptyResource(this, path);
======= fetch "public final void testWrite() {" a63bf3a^:"test/org/apache/catalina/webresources/AbstractTestResourceSet.java"

    // ------------------------------------------------------ getCanonicalPath()
    @Test
    public final void testGetCanonicalPathExists() {
        WebResource exists =
                resourceRoot.getResource(getMount() + "/d1/d1-f1.txt");
        String existsCanonicalPath = exists.getCanonicalPath();
        URL existsUrl = exists.getURL();
        if ("file".equals(existsUrl.getProtocol())) {
            // Should have a canonical path
            Assert.assertNotNull(existsCanonicalPath);
        } else {
            Assert.assertNull(existsCanonicalPath);
        }
    }
    @Test
    public final void testGetCanonicalPathDoesNotExist() {
        WebResource exists =
                resourceRoot.getResource(getMount() + "/d1/d1-f1.txt");
        WebResource doesNotExist =
                resourceRoot.getResource(getMount() + "/d1/dummy.txt");
        String doesNotExistCanonicalPath = doesNotExist.getCanonicalPath();
        URL existsUrl = exists.getURL();
        if ("file".equals(existsUrl.getProtocol())) {
            // Should be possible to construct a canonical path for a resource
            // that doesn't exist given that a resource that does exist in the
            // same directory has a URL with the file protocol
            Assert.assertNotNull(doesNotExistCanonicalPath);
        } else {
            Assert.assertNull(doesNotExistCanonicalPath);
        }
    }

======= fetch "public Principal getUserPrincipal() {" 8f67335^:"java/org/apache/catalina/connector/Request.java"

            GSSCredential gssCredential =
                    ((TomcatPrincipal) userPrincipal).getGssCredential();
            if (gssCredential != null) {
                int left = -1;
                try {
                    left = gssCredential.getRemainingLifetime();
                } catch (GSSException e) {
                    log.warn(sm.getString("coyoteRequest.gssLifetimeFail",
                            userPrincipal.getName()), e);
                }
                if (left == 0) {
                    // GSS credential has expired. Need to re-authenticate.
                    try {
                        logout();
                    } catch (ServletException e) {
                        // Should never happen (no code called by logout()
                        // throws a ServletException
                    }
                    return null;
                }
            }

======= fetch "public void open() throws Exception {" 13c6551^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                    log.error(sm.getString("memoryUserDatabase.fileNotFound",
                            file.getAbsolutePath()));

    /**
     * The QOP that should be used for the connection to the LDAP server after
     * authentication. This value is used to set the
     * <code>javax.security.sasl.qop</code> environment property for the LDAP
     * connection.
     */
    protected String spengoDelegationQop = "auth-conf";
======= fetch "public void setTimeLimit(int timeLimit) {" 27806aa^:"java/org/apache/catalina/realm/JNDIRealm.java"

======= fetch "public void setUseDelegatedCredential(boolean useDelegatedCredential) {" 27806aa^:"java/org/apache/catalina/realm/JNDIRealm.java"

    public String getSpengoDelegationQop() {
        return spengoDelegationQop;
    }
    public void setSpengoDelegationQop(String spengoDelegationQop) {
        this.spengoDelegationQop = spengoDelegationQop;
    }
======= fetch "protected synchronized Principal getPrincipal(DirContext context," 27806aa^:"java/org/apache/catalina/realm/JNDIRealm.java"

                        "javax.security.sasl.qop", "auth-conf");
        <p>When the JNIRealm is used with the SPNEGO authenticator, delegated

======= fetch "public StandardRoot(Context context) {" a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

    private String[] list(String path, boolean doStateCheck) {
        if (doStateCheck) {
            checkState();
======= fetch "public StandardRoot(Context context) {" a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

        checkState();
======= fetch "public boolean mkdir(String path) {" a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

        checkState();
======= fetch "public boolean write(String path, InputStream is, boolean overwrite) {" a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

        checkState();
======= fetch "public WebResource getResource(String path) {" a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

    private WebResource getResource(String path, boolean doStateCheck,
======= fetch "private WebResource getResource(String path, boolean doStateCheck," a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

        if (doStateCheck) {
            checkState();
======= fetch "public WebResource getClassLoaderResource(String path) {" a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

        checkPath(path);
======= fetch "public WebResource getClassLoaderResource(String path) {" a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

        checkPath(path);
======= fetch "public WebResource getClassLoaderResource(String path) {" a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

    private void checkPath(String path) {
======= fetch "private void checkPath(String path) {" a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

        return RequestUtil.normalize(path);
======= fetch "protected final WebResource getResourceInternal(String path," a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

        checkState();
======= fetch "protected final WebResource getResourceInternal(String path," a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

    private WebResource[] listResources(String path, boolean doStateCheck) {
        if (doStateCheck) {
            checkState();
======= fetch "public void setContext(Context context) {" a1ad6ce^:"java/org/apache/catalina/webresources/StandardRoot.java"

    private void checkState() {
        if (!getState().isAvailable()) {
            throw new IllegalStateException(
                    sm.getString("standardRoot.checkStateNotStarted"));
        }
    }

======= fetch "public void service(org.apache.coyote.Request req," cb62f86^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            AtomicBoolean error = new AtomicBoolean(false);
            res.action(ActionCode.IS_ERROR, error);
======= fetch "public void service(org.apache.coyote.Request req," cb62f86^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            if (!comet && !async) {
======= fetch "public final void action(ActionCode actionCode, Object param) {" cb62f86^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        } else if (actionCode == ActionCode.IS_ERROR) {
            ((AtomicBoolean) param).set(error);
======= fetch "public final void action(ActionCode actionCode, Object param) {" cb62f86^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        } else if (actionCode == ActionCode.IS_ERROR) {
            ((AtomicBoolean) param).set(error);
======= fetch "public void action(ActionCode actionCode, Object param) {" cb62f86^:"java/org/apache/coyote/spdy/SpdyProcessor.java"

        } else if (actionCode == ActionCode.IS_ERROR) {
            ((AtomicBoolean) param).set(error);
======= fetch "private void doTestBug53677(boolean flush) throws Exception {" cb62f86^:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

    private static CountDownLatch bug55772Latch1 = new CountDownLatch(1);
    private static CountDownLatch bug55772Latch2 = new CountDownLatch(1);
    private static CountDownLatch bug55772Latch3 = new CountDownLatch(1);
    private static boolean bug55772IsSecondRequest = false;
    private static boolean bug55772RequestStateLeaked = false;
    @Test
    public void testBug55772() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        tomcat.getConnector().setProperty("processorCache", "1");
        tomcat.getConnector().setProperty("maxThreads", "1");
        // Must have a real docBase - just use temp
        Context ctxt = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctxt, "async", new Bug55772Servlet());
        ctxt.addServletMapping("/*", "async");
        tomcat.start();
        String request1 = "GET /async HTTP/1.1\r\n" +
                "Host: localhost:" + getPort() + "\r\n" +
                "Connection: keep-alive\r\n" +
                "Cache-Control: max-age=0\r\n" +
                "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\n" +
                "User-Agent: Request1\r\n" +
                "Accept-Encoding: gzip,deflate,sdch\r\n" +
                "Accept-Language: en-US,en;q=0.8,fr;q=0.6,es;q=0.4\r\n" +
                "Cookie: something.that.should.not.leak=true\r\n" +
                "\r\n";
        String request2 = "GET /async HTTP/1.1\r\n" +
                "Host: localhost:" + getPort() + "\r\n" +
                "Connection: keep-alive\r\n" +
                "Cache-Control: max-age=0\r\n" +
                "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\n" +
                "User-Agent: Request2\r\n" +
                "Accept-Encoding: gzip,deflate,sdch\r\n" +
                "Accept-Language: en-US,en;q=0.8,fr;q=0.6,es;q=0.4\r\n" +
                "\r\n";
        try (final Socket connection = new Socket("localhost", getPort())) {
            connection.setSoLinger(true, 0);
            Writer writer = new OutputStreamWriter(connection.getOutputStream(),
                    B2CConverter.getCharset("US-ASCII"));
            writer.write(request1);
            writer.flush();
            bug55772Latch1.await();
            connection.close();
        }
        bug55772Latch2.await();
        bug55772IsSecondRequest = true;
        try (final Socket connection = new Socket("localhost", getPort())) {
            connection.setSoLinger(true, 0);
            Writer writer = new OutputStreamWriter(connection.getOutputStream(),
                    B2CConverter.getCharset("US-ASCII"));
            writer.write(request2);
            writer.flush();
            connection.getInputStream().read();
        }
        bug55772Latch3.await();
        if (bug55772RequestStateLeaked) {
            Assert.fail("State leaked between requests!");
        }
    }
    private static class Bug55772Servlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            if (bug55772IsSecondRequest) {
                Cookie[] cookies = req.getCookies();
                if (cookies != null && cookies.length > 0) {
                    for (Cookie cookie : req.getCookies()) {
                        if (cookie.getName().equalsIgnoreCase("something.that.should.not.leak")) {
                            bug55772RequestStateLeaked = true;
                        }
                    }
                }
                bug55772Latch3.countDown();
            } else {
                req.getCookies(); // We have to do this so Tomcat will actually parse the cookies from the request
            }
            req.setAttribute("org.apache.catalina.ASYNC_SUPPORTED", Boolean.TRUE);
            AsyncContext asyncContext = req.startAsync();
            asyncContext.setTimeout(5000);
            bug55772Latch1.countDown();
            PrintWriter writer = asyncContext.getResponse().getWriter();
            writer.print('\n');
            writer.flush();
            bug55772Latch2.countDown();
        }
    }

======= fetch "protected void initInternal() throws LifecycleException {" 0a4e847^:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

        // This property must be false for SPNEGO to work
        System.setProperty(Constants.USE_SUBJECT_CREDS_ONLY_PROPERTY, "false");

======= fetch "public void bind() throws Exception {" 014cf1c^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            sslContext = SSLContext.make(rootPool, value, SSL.SSL_MODE_SERVER);

======= fetch "private void checkNamedAttributes(Node.CustomTag n," 7ee1275^:"java/org/apache/jasper/compiler/Validator.java"

                        result = new Node.JspAttribute(tai, qName, uri,
                                localName, value, false, el, dynamic);
======= fetch "private void checkNamedAttributes(Node.CustomTag n," 7ee1275^:"java/org/apache/jasper/compiler/Validator.java"

        private static class XmlEscapeNonELVisitor extends ELParser.TextBuilder {
            @Override
            public void visit(Text n) throws JasperException {
                output.append(xmlEscape(n.getText()));
            }
        }
======= fetch "private static void validateXmlView(PageData xmlView, Compiler compiler)" 7ee1275^:"java/org/apache/jasper/compiler/Validator.java"

    protected static String xmlEscape(String s) {
        if (s == null) {
            return null;
        }
        int len = s.length();
        /*
         * Look for any "bad" characters, Escape "bad" character was found
         */
        // ASCII " 34 & 38 ' 39 < 60 > 62
        for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            if (c >= '\"' && c <= '>' &&
                    (c == '<' || c == '>' || c == '\'' || c == '&' || c == '"')) {
                // need to escape them and then quote the whole string
                StringBuilder sb = new StringBuilder((int) (len * 1.2));
                sb.append(s, 0, i);
                int pos = i + 1;
                for (int j = i; j < len; j++) {
                    c = s.charAt(j);
                    if (c >= '\"' && c <= '>') {
                        if (c == '<') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&lt;");
                            pos = j + 1;
                        } else if (c == '>') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&gt;");
                            pos = j + 1;
                        } else if (c == '\'') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&#039;"); // &apos;
                            pos = j + 1;
                        } else if (c == '&') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&amp;");
                            pos = j + 1;
                        } else if (c == '"') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&#034;"); // &quot;
                            pos = j + 1;
                        }
                    }
                }
                if (pos < len) {
                    sb.append(s, pos, len);
                }
                return sb.toString();
            }
        }
        return s;
    }
======= fetch "private void doHandlePageException(Throwable t) throws IOException," 7ee1275^:"java/org/apache/jasper/runtime/PageContextImpl.java"

    protected static String XmlEscape(String s) {
        if (s == null) {
            return null;
        }
        int len = s.length();
        /*
         * Look for any "bad" characters, Escape "bad" character was found
         */
        // ASCII " 34 & 38 ' 39 < 60 > 62
        for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            if (c >= '\"' && c <= '>' &&
                    (c == '<' || c == '>' || c == '\'' || c == '&' || c == '"')) {
                // need to escape them and then quote the whole string
                StringBuilder sb = new StringBuilder((int) (len * 1.2));
                sb.append(s, 0, i);
                int pos = i + 1;
                for (int j = i; j < len; j++) {
                    c = s.charAt(j);
                    if (c >= '\"' && c <= '>') {
                        if (c == '<') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&lt;");
                            pos = j + 1;
                        } else if (c == '>') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&gt;");
                            pos = j + 1;
                        } else if (c == '\'') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&#039;"); // &apos;
                            pos = j + 1;
                        } else if (c == '&') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&amp;");
                            pos = j + 1;
                        } else if (c == '"') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&#034;"); // &quot;
                            pos = j + 1;
                        }
                    }
                }
                if (pos < len) {
                    sb.append(s, pos, len);
                }
                return sb.toString();
            }
        }
        return s;
    }
======= fetch "public Object run() throws Exception {" 7ee1275^:"java/org/apache/jasper/runtime/PageContextImpl.java"

        if (escape && retValue != null) {
            retValue = XmlEscape(retValue.toString());
        }
======= fetch "public void testBug55198() throws Exception {" 7ee1275^:"test/org/apache/jasper/compiler/TestParser.java"

        Assert.assertTrue(result.contains("&quot;bar&quot;") ||
                result.contains("&#034;bar&#034;"));
        Assert.assertTrue(result.contains("&quot;foo&quot;") ||
                result.contains("&#034;foo&#034;"));
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Performance tests for {@link PageContextImpl}.
 */
    private static String[] bug53867TestData = new String[] {
            "Hello World!",
            "<meta http-equiv=\"Content-Language\">",
            "This connection has limited network connectivity.",
            "Please use this web page & to access file server resources." };
    @Test
    public void testBug53867() {
        for (int i = 0; i < 10; i++) {
            doTestBug53867();
        }
    }
    private static void doTestBug53867() {
        int count = 100000;
        for (int j = 0; j < bug53867TestData.length; j++) {
            Assert.assertEquals(doTestBug53867OldVersion(bug53867TestData[j]),
                    PageContextImpl.XmlEscape(bug53867TestData[j]));
        }
        for (int i = 0; i < 100; i++) {
            for (int j = 0; j < bug53867TestData.length; j++) {
                doTestBug53867OldVersion(bug53867TestData[j]);
            }
        }
        for (int i = 0; i < 100; i++) {
            for (int j = 0; j < bug53867TestData.length; j++) {
                PageContextImpl.XmlEscape(bug53867TestData[j]);
            }
        }
        long start = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            for (int j = 0; j < bug53867TestData.length; j++) {
                doTestBug53867OldVersion(bug53867TestData[j]);
            }
        }
        System.out.println(
                "Old escape:" + (System.currentTimeMillis() - start));
        start = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            for (int j = 0; j < bug53867TestData.length; j++) {
                PageContextImpl.XmlEscape(bug53867TestData[j]);
            }
        }
        System.out.println(
                "New escape:" + (System.currentTimeMillis() - start));
    }
    private static String doTestBug53867OldVersion(String s) {
        if (s == null)
            return null;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '<') {
                sb.append("&lt;");
            } else if (c == '>') {
                sb.append("&gt;");
            } else if (c == '\'') {
                sb.append("&#039;"); // &apos;
            } else if (c == '&') {
                sb.append("&amp;");
            } else if (c == '"') {
                sb.append("&#034;"); // &quot;
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

    // Executor configuration
    public static final String EXECUTOR_CORE_SIZE_INIT_PARAM =
            "org.apache.tomcat.websocket.executorCoreSize";
    public static final String EXECUTOR_MAX_SIZE_INIT_PARAM =
            "org.apache.tomcat.websocket.executorMaxSize";
    public static final String EXECUTOR_KEEPALIVETIME_SECONDS_INIT_PARAM =
            "org.apache.tomcat.websocket.executorKeepAliveTimeSeconds";
======= fetch "public void contextDestroyed(ServletContextEvent sce) {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsContextListener.java"

            ((WsServerContainer) obj).shutdownExecutor();
======= fetch "public void onWritePossible() {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java"

            wsRemoteEndpointServer.onWritePossible();
======= fetch "public WsRemoteEndpointImplServer(ServletOutputStream sos," 3f316f1^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

        this.executorService = serverContainer.getExecutorService();
======= fetch "protected void doWrite(SendHandler handler, ByteBuffer... buffers) {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

        onWritePossible();
======= fetch "protected void doWrite(SendHandler handler, ByteBuffer... buffers) {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

    public void onWritePossible() {
======= fetch "public void onWritePossible() {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

                    clearHandler(null);
======= fetch "public void onWritePossible() {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

            clearHandler(ioe);
======= fetch "protected void doClose() {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

            clearHandler(new EOFException());
======= fetch "protected long getTimeoutExpiry() {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

    protected void onTimeout() {
======= fetch "protected void onTimeout() {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

            clearHandler(new SocketTimeoutException());
======= fetch "protected void onTimeout() {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

    private void clearHandler(Throwable t) {
======= fetch "private void clearHandler(Throwable t) {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

            if (useDispatch) {
                OnResultRunnable r = onResultRunnables.poll();
                if (r == null) {
                    r = new OnResultRunnable(onResultRunnables);
                }
                r.init(sh, t);
                if (executorService == null || executorService.isShutdown()) {
                    // Can't use the executor so call the runnable directly.
                    // This may not be strictly specification compliant in all
                    // cases but during shutdown only close messages are going
                    // to be sent so there should not be the issue of nested
                    // calls leading to stack overflow as described in bug
                    // 55715. The issues with nested calls was the reason for
                    // the separate thread requirement in the specification.
                    r.run();
                } else {
                    executorService.execute(r);
                }
            } else {
                if (t == null) {
                    sh.onResult(new SendResult());
                } else {
                    sh.onResult(new SendResult(t));
                }
            }
        }
    }
    private static class OnResultRunnable implements Runnable {
        private final Queue<OnResultRunnable> queue;
        private volatile SendHandler sh;
        private volatile Throwable t;
        private OnResultRunnable(Queue<OnResultRunnable> queue) {
            this.queue = queue;
        }
        private void init(SendHandler sh, Throwable t) {
            this.sh = sh;
            this.t = t;
        }
        @Override
        public void run() {
======= fetch "private void clearHandler(Throwable t) {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

            t = null;
            sh = null;
            // Return the Runnable to the queue when it has been finished with
            // Note if this method takes an age to finish there shouldn't be any
            // thread safety issues as the fields are cleared above.
            queue.add(this);
    private final ExecutorService executorService;
        // Executor config
        int executorCoreSize = 0;
        int executorMaxSize = 10;
        long executorKeepAliveTimeSeconds = 60;
        value = servletContext.getInitParameter(
                Constants.EXECUTOR_CORE_SIZE_INIT_PARAM);
        if (value != null) {
            executorCoreSize = Integer.parseInt(value);
        }
        value = servletContext.getInitParameter(
                Constants.EXECUTOR_MAX_SIZE_INIT_PARAM);
        if (value != null) {
            executorMaxSize = Integer.parseInt(value);
        }
        value = servletContext.getInitParameter(
                Constants.EXECUTOR_KEEPALIVETIME_SECONDS_INIT_PARAM);
        if (value != null) {
            executorKeepAliveTimeSeconds = Long.parseLong(value);
        }
        // Use a per web application executor for any threads the the WebSocket
        // server code needs to create. Group all of the threads under a single
        // ThreadGroup.
        StringBuffer threadGroupName = new StringBuffer("WebSocketServer-");
        threadGroupName.append(servletContext.getVirtualServerName());
        threadGroupName.append('-');
        if ("".equals(servletContext.getContextPath())) {
            threadGroupName.append("ROOT");
        } else {
            threadGroupName.append(servletContext.getContextPath());
        }
        ThreadGroup threadGroup = new ThreadGroup(threadGroupName.toString());
        WsThreadFactory wsThreadFactory = new WsThreadFactory(threadGroup);
        executorService = new ThreadPoolExecutor(executorCoreSize,
                executorMaxSize, executorKeepAliveTimeSeconds, TimeUnit.SECONDS,
                new LinkedBlockingQueue<Runnable>(), wsThreadFactory);
======= fetch "public void closeAuthenticatedSession(String httpSessionId) {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

    ExecutorService getExecutorService() {
        return executorService;
    }
    void shutdownExecutor() {
        executorService.shutdown();
        try {
            executorService.awaitTermination(10, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            // Ignore the interruption and carry on
        }
    }
======= fetch "private static void validateEncoders(Class<? extends Encoder>[] encoders)" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

======= fetch "public int compare(TemplatePathMatch tpm1, TemplatePathMatch tpm2) {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

    private static class WsThreadFactory implements ThreadFactory {
        private final ThreadGroup tg;
        private final AtomicLong count = new AtomicLong(0);
        private WsThreadFactory(ThreadGroup tg) {
            this.tg = tg;
        }
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(tg, r);
            t.setName(tg.getName() + "-" + count.incrementAndGet());
            return t;
        }
    }
======= fetch "public void backgroundProcess() {" 3f316f1^:"java/org/apache/tomcat/websocket/server/WsWriteTimeout.java"

                    endpoint.onTimeout();

======= fetch "public String toString() {" ad50e54^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

    private InputStream getResourceAsStream(String uri)
======= fetch "private InputStream getResourceAsStream(String uri)" ad50e54^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

        if (uri.startsWith("file:")) {
            return new FileInputStream(new File(uri.substring(5)));
======= fetch "private InputStream getResourceAsStream(String uri)" ad50e54^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                String real = ctxt.getRealPath(uri);
======= fetch "private InputStream getResourceAsStream(String uri)" ad50e54^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                    return ctxt.getResourceAsStream(uri);
======= fetch "private InputStream getResourceAsStream(String uri)" ad50e54^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                return ctxt.getResourceAsStream(uri);

======= fetch "private boolean loadedByThisOrChild(Object o) {" d244284^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        while (tg.getParent() != null) {
            tg = tg.getParent();

======= fetch "public void setValue(ELContext context, Object base, Object property," b82c0c6^:"java/javax/el/ArrayELResolver.java"

            if (value != null &&
                    !base.getClass().getComponentType().isAssignableFrom(
                            value.getClass())) {
======= fetch "private static Wrapper resolveAmbiguousWrapper(Set<Wrapper> candidates," b82c0c6^:"java/javax/el/Util.java"

    private static boolean isAssignableFrom(Class<?> src, Class<?> target) {
======= fetch "public void testSetValue07() {" b82c0c6^:"test/javax/el/TestArrayELResolver.java"

     * Tests setting arrays of primitives.
     * https://issues.apache.org/bugzilla/show_bug.cgi?id=55691
     */
    @Test
    public void testSetValue08() {
        ArrayELResolver resolver = new ArrayELResolver();
        ELContext context = new StandardELContext(
                ELManager.getExpressionFactory());
        int[] base = new int[] { 1, 2, 3 };
        resolver.setValue(context, base, new Integer(1), Integer.valueOf(4));
        Assert.assertEquals(Integer.valueOf(base[1]), Integer.valueOf(4));
    }
    /**

======= fetch "public static Object coerceToType(Class<?> type, String value) {" 514cefb^:"java/org/apache/tomcat/websocket/Util.java"

            MessageHandler listener, EndpointConfig endpointConfig) {
======= fetch "public static Object coerceToType(Class<?> type, String value) {" 514cefb^:"java/org/apache/tomcat/websocket/Util.java"

                            getOnMessageMethod(listener), null,
======= fetch "public static Object coerceToType(Class<?> type, String value) {" 514cefb^:"java/org/apache/tomcat/websocket/Util.java"

                            getOnMessageMethod(listener), null,
======= fetch "public static Object coerceToType(Class<?> type, String value) {" 514cefb^:"java/org/apache/tomcat/websocket/Util.java"

                            getOnMessageMethod(listener), null,
======= fetch "public static Object coerceToType(Class<?> type, String value) {" 514cefb^:"java/org/apache/tomcat/websocket/Util.java"

                        new PojoMessageHandlerWholeBinary(listener, m, null,
======= fetch "public static Object coerceToType(Class<?> type, String value) {" 514cefb^:"java/org/apache/tomcat/websocket/Util.java"

                        new PojoMessageHandlerWholeText(listener, m, null,
======= fetch "public void addMessageHandler(MessageHandler listener) {" 514cefb^:"java/org/apache/tomcat/websocket/WsSession.java"

                Util.getMessageHandlers(listener, endpointConfig);

======= fetch "static CloseCode getCloseCode(int code) {" 4e4a24a^:"java/org/apache/tomcat/websocket/Util.java"

    public static Class<?> getDecoderType(Class<? extends Decoder> Decoder) {
        return (Class<?>) Util.getGenericType(Decoder.class, Decoder);
======= fetch "private static Object getTypeParameter(Class<?> clazz, Type argType) {" 4e4a24a^:"java/org/apache/tomcat/websocket/Util.java"

        } else if (argType instanceof ParameterizedType) {
            return ((ParameterizedType) argType).getRawType();
======= fetch "public void testGetEncoderTypeGenericMultipleSubclassSwap() {" 4e4a24a^:"test/org/apache/tomcat/websocket/TestUtil.java"

    @Test
    public void testGetEncoderTypeSimpleWithGenericType() {
        Assert.assertEquals(List.class,
                Util.getEncoderType(SimpleEncoderWithGenericType.class));
    }
======= fetch "public void doSomething(Boolean thing) {" 4e4a24a^:"test/org/apache/tomcat/websocket/TestUtil.java"

    private static class SimpleEncoderWithGenericType
            implements Encoder.Text<List<String>> {
        @Override
        public void init(EndpointConfig endpointConfig) {
            // NO-OP
        }
        @Override
        public void destroy() {
            // NO-OP
        }
        @Override
        public String encode(List<String> object) throws EncodeException {
            return null;
        }
    }
    private static final String PATH_GENERICS_EP = "/echoGenericsEP";
======= fetch "public void testAnnotatedEndPoints() throws Exception {" 4e4a24a^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

    @Test
    public void testGenericsCoders() throws Exception {
        // Set up utility classes
        GenericsServer server = new GenericsServer();
        SingletonConfigurator.setInstance(server);
        ServerConfigListener.setPojoClazz(GenericsServer.class);
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        ctx.addApplicationListener(new ApplicationListener(
                ServerConfigListener.class.getName(), false));
        Tomcat.addServlet(ctx, "default", new DefaultServlet());
        ctx.addServletMapping("/", "default");
        WebSocketContainer wsContainer =
                ContainerProvider.getWebSocketContainer();
        tomcat.start();
        GenericsClient client = new GenericsClient();
        URI uri = new URI("ws://localhost:" + getPort() + PATH_GENERICS_EP);
        Session session = wsContainer.connectToServer(client, uri);
        ArrayList<String> list = new ArrayList<>(2);
        list.add("str1");
        list.add("str2");
        session.getBasicRemote().sendObject(list);
        // Should not take very long
        int i = 0;
        while (i < 20) {
            if (server.received.size() > 0 && client.received.size() > 0) {
                break;
            }
            Thread.sleep(100);
        }
        // Check messages were received
        Assert.assertEquals(1, server.received.size());
        Assert.assertEquals(server.received.peek().toString(), "[str1, str2]");
        Assert.assertEquals(1, client.received.size());
        Assert.assertEquals(client.received.peek().toString(), "[str1, str2]");
        session.close();
    }
======= fetch "private int testEvent(String name, int count) throws InterruptedException {" 4e4a24a^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

    @ClientEndpoint(decoders={ListStringDecoder.class},
            encoders={ListStringEncoder.class})
    public static class GenericsClient {
        private Queue<Object> received = new ConcurrentLinkedQueue<>();
        @OnMessage
        public void rx(List<String> in) {
            received.add(in);
        }
    }
======= fetch "public void  rx(MsgByte in) {" 4e4a24a^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

    @ServerEndpoint(value=PATH_GENERICS_EP,
            decoders={ListStringDecoder.class},
            encoders={ListStringEncoder.class},
            configurator=SingletonConfigurator.class)
    public static class GenericsServer {
        private Queue<Object> received = new ConcurrentLinkedQueue<>();
        @OnMessage
        public List<String> rx(List<String> in) {
            received.add(in);
            // Echo the message back
            return in;
        }
    }
======= fetch "public boolean willDecode(ByteBuffer bb) {" 4e4a24a^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

    public static class ListStringEncoder implements Encoder.Text<List<String>> {
        @Override
        public void init(EndpointConfig endpointConfig) {
            Server.addLifeCycleEvent(getClass().getName() + ":init");
        }
        @Override
        public void destroy() {
            Server.addLifeCycleEvent(getClass().getName() + ":destroy");
        }
        @Override
        public String encode(List<String> str) throws EncodeException {
            StringBuffer sbuf = new StringBuffer();
            sbuf.append("[");
            for (String s: str){
                sbuf.append(s).append(",");
            }
            sbuf.deleteCharAt(sbuf.lastIndexOf(",")).append("]");
            return sbuf.toString();
        }
    }
    public static class ListStringDecoder implements Decoder.Text<List<String>> {
        @Override
        public void init(EndpointConfig endpointConfig) {
             Server.addLifeCycleEvent(getClass().getName() + ":init");
        }
        @Override
        public void destroy() {
            Server.addLifeCycleEvent(getClass().getName() + ":destroy");
        }
        @Override
        public List<String> decode(String str) throws DecodeException {
            List<String> lst = new ArrayList<>(1);
            str = str.substring(1,str.length()-1);
            String[] strings = str.split(",");
            for (String t : strings){
                lst.add(t);
            }
            return lst;
        }
        @Override
        public boolean willDecode(String str) {
            return str.startsWith("[") && str.endsWith("]");
        }
    }

======= fetch "protected Digester createStartDigester() {" 86ec1f4^:"java/org/apache/catalina/startup/Catalina.java"

        digester.setClassLoader(StandardServer.class.getClassLoader());
======= fetch "protected Digester createStopDigester() {" 86ec1f4^:"java/org/apache/catalina/startup/Catalina.java"

        digester.setUseContextClassLoader(true);
======= fetch "public void stopServer(String[] arguments) {" 86ec1f4^:"java/org/apache/catalina/startup/Catalina.java"

            digester.setClassLoader(Thread.currentThread().getContextClassLoader());

        <init-param>
            <param-name>gzip</param-name>
            <param-value>true</param-value>
        </init-param>
     * Should be serve gzip versions of files. By default, it's set to true.
     */
    protected boolean gzip = true;
    /**
======= fetch "public void init() throws ServletException {" f0101d0^:"java/org/apache/catalina/servlets/DefaultServlet.java"

        if (getServletConfig().getInitParameter("gzip") != null)
            gzip = Boolean.parseBoolean(getServletConfig().getInitParameter("gzip"));
======= fetch "protected void serveResource(HttpServletRequest request," f0101d0^:"java/org/apache/catalina/servlets/DefaultServlet.java"

        // Serve a gzipped version of the file if present
        if (gzip
                && checkIfGzip(request)
                && resource.isFile()
                && !path.endsWith(".gz")) {
            WebResource gzipResource = resources.getResource(path + ".gz");
            if (gzipResource.exists() && gzipResource.isFile()) {
                gzipResource.setMimeType(contentType);
                response.addHeader("Content-Encoding", "gzip");
                resource = gzipResource;
            }
        }
======= fetch "protected boolean checkIfNoneMatch(HttpServletRequest request," f0101d0^:"java/org/apache/catalina/servlets/DefaultServlet.java"

    /**
     * Check if the user agent supports gzip encoding.
     *
     * @param request   The servlet request we are processing
     * @return boolean true if the user agent supports gzip encoding,
     * and false if the user agent does not support gzip encoding
     */
    protected boolean checkIfGzip(HttpServletRequest request) {
        Enumeration<String> headers = request.getHeaders("Accept-Encoding");
        while (headers.hasMoreElements()) {
            String header = headers.nextElement();
            if (header.indexOf("gzip") != -1) {
                return true;
            }
        }
        return false;
    }
======= fetch "public void testGetSpecials() throws Exception {" f0101d0^:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

     * Verify serving of gzipped resources from context root.
     */
    @Test
    public void testGzippedFile() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir =
            new File("test/webapp");
        File gzipIndex = new File(appDir, "index.html.gz");
        long gzipSize = gzipIndex.length();
        File index = new File(appDir, "index.html");
        long indexSize = index.length();
        // app dir is relative to server home
        tomcat.addWebapp(null, "", appDir.getAbsolutePath());
        tomcat.start();
        TestGzipClient gzipClient = new TestGzipClient(getPort());
        gzipClient.reset();
        gzipClient.setRequest(new String[] {
                "GET /index.html HTTP/1.1" + CRLF +
                "Host: localhost" + CRLF +
                "Connection: Close" + CRLF +
                "Accept-Encoding: gzip" + CRLF + CRLF });
        gzipClient.connect();
        gzipClient.processRequest();
        assertTrue(gzipClient.isResponse200());
        List<String> responseHeaders = gzipClient.getResponseHeaders();
        assertTrue(responseHeaders.contains("Content-Length: " + gzipSize));
        gzipClient.reset();
        gzipClient.setRequest(new String[] {
                "GET /index.html HTTP/1.1" + CRLF +
                "Host: localhost" + CRLF +
                "Connection: Close" + CRLF+ CRLF });
        gzipClient.connect();
        gzipClient.processRequest();
        assertTrue(gzipClient.isResponse200());
        responseHeaders = gzipClient.getResponseHeaders();
        assertTrue(responseHeaders.contains("Content-Type: text/html"));
        assertFalse(responseHeaders.contains("Content-Encoding: gzip"));
        assertTrue(responseHeaders.contains("Content-Length: " + indexSize));
    }
    /**
======= fetch "public boolean isResponseBodyOK() {" f0101d0^:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

    private static class TestGzipClient extends SimpleHttpClient {
        public TestGzipClient(int port) {
            setPort(port);
        }
        @Override
        public boolean isResponseBodyOK() {
            return true;
        }
    }
      <add>
        <bug>54095</bug>: Add support to the Default Servlet for serving
        gzipped versions of static resources directly from disk as an
        alternative to Tomcat compressing them on each request. Patch by
        Philippe Marschall. (markt)
      </add>
  <property name="gzip">
        If a gzipped version of a file exists (a file with <code>.gz</code>
        appended to the file name located alongside the original file), Tomcat
        will serve the gzipped file if the user agent supports gzip and this
        option is enabled. [true]
  </property>

======= fetch "protected String nextFile() {" 06d8338^:"java/org/apache/jasper/JspC.java"

    protected void initWebXml() {
======= fetch "protected void initWebXml() {" 06d8338^:"java/org/apache/jasper/JspC.java"

            throw new JasperException(ioe);
      <fix>
        <bug>55251</bug>: Do not allow JspC task to fail silently if the web.xml
        or web.xml fragment can not be generated. (markt)
      </fix>

======= fetch "public boolean isLiteral() {" af49b44^:"java/org/apache/jasper/compiler/Node.java"

            return !expression && (el != null) && !namedAttribute;

    private static TomcatURLStreamHandlerFactory instance =
            new TomcatURLStreamHandlerFactory();
     * Obtain a reference to the singleton instance,
======= fetch "public static TomcatURLStreamHandlerFactory getInstance() {" bd56eea^:"java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java"

        getInstanceInternal(true);
======= fetch "public static TomcatURLStreamHandlerFactory getInstance() {" bd56eea^:"java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java"

    private static TomcatURLStreamHandlerFactory getInstanceInternal(boolean register) {
        // Double checked locking. OK because instance is volatile.
        if (instance == null) {
            synchronized (TomcatURLStreamHandlerFactory.class) {
                if (instance == null) {
                    instance = new TomcatURLStreamHandlerFactory(register);
                }
            }
        }
        return instance;
    }
    private final boolean registered;
======= fetch "public static TomcatURLStreamHandlerFactory getInstance() {" bd56eea^:"java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java"

======= fetch "public static TomcatURLStreamHandlerFactory getInstance() {" bd56eea^:"java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java"

     *
     * @returns <code>true</code> if the factory is already registered with the
     *          JVM or was successfully registered as a result of this call.
     *          <code>false</code> if the factory was disabled prior to this
     *          call.
======= fetch "public static TomcatURLStreamHandlerFactory getInstance() {" bd56eea^:"java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java"

    public static void register() {
        // Calling this method loads this class which in turn triggers all the
        // necessary registration.
======= fetch "public static void register() {" bd56eea^:"java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java"

     * Since the JVM only allows a single call to
     * {@link URL#setURLStreamHandlerFactory(URLStreamHandlerFactory)} and
     * Tomcat needs to register a handler, provide a mechanism to allow
     * applications to register their own handlers.
======= fetch "public static void register() {" bd56eea^:"java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java"

    public static void addUserFactory(URLStreamHandlerFactory factory) {
        instance.userFactories.add(factory);
======= fetch "public static void release(ClassLoader classLoader) {" bd56eea^:"java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java"

    private TomcatURLStreamHandlerFactory() {
======= fetch "private TomcatURLStreamHandlerFactory() {" bd56eea^:"java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java"

        URL.setURLStreamHandlerFactory(this);

======= fetch "public void destroy() {" 95faaec^:"java/org/apache/catalina/manager/StatusManagerServlet.java"

        // No actions necessary

    extends URLClassLoader
    implements Lifecycle
 {
======= fetch "protected boolean removeEldestEntry(" dd0cba7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

    /**
     * Holds the class file transformers decorating this class loader. The
     * CopyOnWriteArrayList is thread safe. It is expensive on writes, but
     * those should be rare. It is very fast on reads, since synchronization
     * is not actually used. Importantly, the ClassLoader will never block
     * iterating over the transformers while loading a class.
     */
    private final List<ClassFileTransformer> transformers = new CopyOnWriteArrayList<>();
======= fetch "public void setClearReferencesHttpClientKeepAliveThread(" dd0cba7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

    /**
     * Adds the specified class file transformer to this class loader. The
     * transformer will then be able to modify the bytecode of any classes
     * loaded by this class loader after the invocation of this method.
     *
     * @param transformer The transformer to add to the class loader
     */
    @Override
    public void addTransformer(ClassFileTransformer transformer) {
        if (transformer == null) {
            throw new IllegalArgumentException(sm.getString(
                    "webappClassLoader.addTransformer.illegalArgument", getContextName()));
        }
        if (this.transformers.contains(transformer)) {
            // if the same instance of this transformer was already added, bail out
            log.warn(sm.getString("webappClassLoader.addTransformer.duplicate",
                    transformer, getContextName()));
            return;
        }
        this.transformers.add(transformer);
        log.info(sm.getString("webappClassLoader.addTransformer", transformer, getContextName()));
    }
    /**
     * Removes the specified class file transformer from this class loader.
     * It will no longer be able to modify the byte code of any classes
     * loaded by the class loader after the invocation of this method.
     * However, any classes already modified by this transformer will
     * remain transformed.
     *
     * @param transformer The transformer to remove
     */
    @Override
    public void removeTransformer(ClassFileTransformer transformer) {
        if (transformer == null) {
            return;
        }
        if (this.transformers.remove(transformer)) {
            log.info(sm.getString("webappClassLoader.removeTransformer",
                    transformer, getContextName()));
            return;
        }
    }
    /**
     * Returns a copy of this class loader without any class file
     * transformers. This is a tool often used by Java Persistence API
     * providers to inspect entity classes in the absence of any
     * instrumentation, something that can't be guaranteed within the
     * context of a {@link ClassFileTransformer}'s
     * {@link ClassFileTransformer#transform(ClassLoader, String, Class,
     * ProtectionDomain, byte[]) transform} method.
     * <p>
     * The returned class loader's resource cache will have been cleared
     * so that classes already instrumented will not be retained or
     * returned.
     *
     * @return the transformer-free copy of this class loader.
     */
    @Override
    public WebappClassLoader copyWithoutTransformers() {
        WebappClassLoader loader = new WebappClassLoader(this.parent);
        loader.antiJARLocking = this.antiJARLocking;
        loader.resources = this.resources;
        loader.delegate = this.delegate;
        loader.lastJarAccessed = this.lastJarAccessed;
        loader.repositoryPath = this.repositoryPath;
        loader.repository = this.repository;
        loader.jarPath = this.jarPath;
        loader.loaderDir = this.loaderDir;
        loader.canonicalLoaderDir = this.canonicalLoaderDir;
        loader.started = this.started;
        loader.needConvert = this.needConvert;
        loader.clearReferencesStatic = this.clearReferencesStatic;
        loader.clearReferencesStopThreads = this.clearReferencesStopThreads;
        loader.clearReferencesStopTimerThreads = this.clearReferencesStopTimerThreads;
        loader.clearReferencesLogFactoryRelease = this.clearReferencesLogFactoryRelease;
        loader.clearReferencesHttpClientKeepAliveThread = this.clearReferencesHttpClientKeepAliveThread;
        loader.repositoryURLs = this.repositoryURLs.clone();
        loader.jarFiles = this.jarFiles.clone();
        loader.jarRealFiles = this.jarRealFiles.clone();
        loader.jarNames = this.jarNames.clone();
        loader.lastModifiedDates = this.lastModifiedDates.clone();
        loader.paths = this.paths.clone();
        loader.notFoundResources.putAll(this.notFoundResources);
        loader.permissionList.addAll(this.permissionList);
        loader.loaderPC.putAll(this.loaderPC);
        return loader;
    }
======= fetch "public String toString() {" dd0cba7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (this.transformers.size() > 0) {
            sb.append("----------> Class file transformers:\r\n");
            for (ClassFileTransformer transformer : this.transformers) {
                sb.append(transformer).append("\r\n");
            }
        }
======= fetch "public URL getResource(String name) {" dd0cba7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                            && (!(name.endsWith(".class")))) {
======= fetch "protected boolean openJARs() {" dd0cba7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        String classPath = tempPath + ".class";
======= fetch "protected boolean openJARs() {" dd0cba7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

    protected ResourceEntry findResourceInternal(String name, String path) {
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dd0cba7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        boolean isClassResource = path.endsWith(".class");
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dd0cba7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                        if (antiJARLocking && !(path.endsWith(".class"))) {
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dd0cba7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                            (".class"))) {
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dd0cba7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (isClassResource && entry.binaryContent != null &&
                this.transformers.size() > 0) {
            // If the resource is a class just being loaded, decorate it
            // with any attached transformers
            String className = name.endsWith(CLASS_FILE_SUFFIX) ?
                    name.substring(0, name.length() - CLASS_FILE_SUFFIX.length()) : name;
            String internalName = className.replace(".", "/");
            for (ClassFileTransformer transformer : this.transformers) {
                try {
                    byte[] transformed = transformer.transform(
                            this, internalName, null, null, entry.binaryContent
                    );
                    if (transformed != null) {
                        entry.binaryContent = transformed;
                    }
                } catch (IllegalClassFormatException e) {
                    log.error(sm.getString("webappClassLoader.transformError", name), e);
                    return null;
                }
            }
        }
======= fetch "protected boolean validateJarFile(File file)" dd0cba7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                String name = triggers[i].replace('.', '/') + ".class";

    private final HashMap<String,ArrayList<String>> paramHashValues =
            new HashMap<>();

======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," f627cc8^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

        JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri);
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," f627cc8^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri);

======= fetch "public GSSCredential run() throws GSSException {" 910d4d9^:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

                log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail",
                        e));
======= fetch "public GSSCredential run() throws GSSException {" 910d4d9^:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

            log.error(sm.getString("spnegoAuthenticator.serviceLoginFail", e));

======= fetch "protected void doGet(HttpServletRequest request," f74257e^:"java/org/apache/catalina/servlets/DefaultServlet.java"

        serveResource(request, response, true);
======= fetch "protected void doHead(HttpServletRequest request," f74257e^:"java/org/apache/catalina/servlets/DefaultServlet.java"

        serveResource(request, response, false);
======= fetch "protected String rewriteUrl(String path) {" f74257e^:"java/org/apache/catalina/servlets/DefaultServlet.java"

     * @param request The servlet request we are processing
======= fetch "protected String rewriteUrl(String path) {" f74257e^:"java/org/apache/catalina/servlets/DefaultServlet.java"

     * @param content Should the content be included?
======= fetch "protected void serveResource(HttpServletRequest request," f74257e^:"java/org/apache/catalina/servlets/DefaultServlet.java"

                                 boolean content)
======= fetch "protected void serveResource(HttpServletRequest request," f74257e^:"java/org/apache/catalina/servlets/DefaultServlet.java"

                    copy(resource, renderResult, writer);
======= fetch "protected void copy(WebResource resource, InputStream is," f74257e^:"java/org/apache/catalina/servlets/DefaultServlet.java"

     * @param encoding  The encoding to use when reading the source input stream
======= fetch "protected void copy(WebResource resource, InputStream is," f74257e^:"java/org/apache/catalina/servlets/DefaultServlet.java"

    protected void copy(WebResource resource, InputStream is, PrintWriter writer)
            throws IOException {
======= fetch "protected void copy(WebResource resource, InputStream is, PrintWriter writer)" f74257e^:"java/org/apache/catalina/servlets/DefaultServlet.java"

        if (fileEncoding == null) {
======= fetch "protected void copy(WebResource resource, InputStream is, PrintWriter writer)" f74257e^:"java/org/apache/catalina/servlets/DefaultServlet.java"

            reader = new InputStreamReader(resourceInputStream,
                                           fileEncoding);

======= fetch "public void invoke(Request request, Response response)" b284611^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                Request[] requests = (Request[])
                        session.getAttribute(cometRequestsAttribute);
======= fetch "public void invoke(Request request, Response response)" b284611^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                            requests);
======= fetch "public void invoke(Request request, Response response)" b284611^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                    session.setAttribute(cometRequestsAttribute, newRequests);
======= fetch "public void event(Request request, Response response, CometEvent event)" b284611^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                             reqs = (Request[])
                                session.getAttribute(cometRequestsAttribute);
======= fetch "public void event(Request request, Response response, CometEvent event)" b284611^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                                                newConnectionInfos);
======= fetch "public void sessionDestroyed(HttpSessionEvent se) {" b284611^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

        Request[] reqs = (Request[])
            se.getSession().getAttribute(cometRequestsAttribute);
======= fetch "public void sessionDestroyed(HttpSessionEvent se) {" b284611^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

    private static class ConnectionList implements Serializable {
        private static final long serialVersionUID = 1L;
        private transient Request[] connectionList = null;
        private ConnectionList(Request[] connectionList){
            this.connectionList = connectionList;
        }
        public Request[] get(){
            return connectionList;
        }
    }
        <bug>52558</bug>: Refactor <code>CometConnectionManagerValve</code> so
        that it does not prevent the session from being serialized in when
        running in a cluster. (markt) 
      </fix>
      <fix>

======= fetch "public static String interpreterCall(boolean isTagFile, String expression," 66932c4^:"java/org/apache/jasper/compiler/JspUtil.java"

        String targetType = expectedType.getCanonicalName();
======= fetch "public static String interpreterCall(boolean isTagFile, String expression," 66932c4^:"java/org/apache/jasper/compiler/JspUtil.java"

                targetType = Boolean.class.getName();
======= fetch "public static String interpreterCall(boolean isTagFile, String expression," 66932c4^:"java/org/apache/jasper/compiler/JspUtil.java"

                targetType = Byte.class.getName();
======= fetch "public static String interpreterCall(boolean isTagFile, String expression," 66932c4^:"java/org/apache/jasper/compiler/JspUtil.java"

                targetType = Character.class.getName();
======= fetch "public static String interpreterCall(boolean isTagFile, String expression," 66932c4^:"java/org/apache/jasper/compiler/JspUtil.java"

                targetType = Short.class.getName();
======= fetch "public static String interpreterCall(boolean isTagFile, String expression," 66932c4^:"java/org/apache/jasper/compiler/JspUtil.java"

                targetType = Integer.class.getName();
======= fetch "public static String interpreterCall(boolean isTagFile, String expression," 66932c4^:"java/org/apache/jasper/compiler/JspUtil.java"

                targetType = Long.class.getName();
======= fetch "public static String interpreterCall(boolean isTagFile, String expression," 66932c4^:"java/org/apache/jasper/compiler/JspUtil.java"

                targetType = Float.class.getName();
======= fetch "public static String interpreterCall(boolean isTagFile, String expression," 66932c4^:"java/org/apache/jasper/compiler/JspUtil.java"

                targetType = Double.class.getName();
======= fetch "public static String interpreterCall(boolean isTagFile, String expression," 66932c4^:"java/org/apache/jasper/compiler/JspUtil.java"

                        + targetType

    
    <attribute name="validationQueryTimeout" required="false">
      <p>(int) The timeout in seconds before a connection validation queries fail.  This works by calling 
         <code>java.sql.Statement.setQueryTimeout(seconds)</code> on the statement that executes the <code>validationQuery</code>.
         The pool itself doesn't timeout the query, it is still up to the JDBC driver to enforce query timeouts. 
         A value less than or equal to zero will disable this feature. 
         The default value is <code>-1</code>.
      </p>
    </attribute>
======= fetch "protected PooledConnection createConnection(long now, PooledConnection notUsed," b022c57^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                error =true;
======= fetch "protected PooledConnection createConnection(long now, PooledConnection notUsed," b022c57^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        return null;
======= fetch "public static PoolConfiguration parsePoolProperties(Properties properties) {" b022c57^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        
        value = properties.getProperty(PROP_VALIDATIONQUERY_TIMEOUT);
        if (value != null) {
            poolProperties.setValidationQueryTimeout(Integer.parseInt(value));
        }
======= fetch "public void setValidatorClassName(String className) {" b022c57^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    
    /**
     * {@inheritDoc}
     */
    
    @Override
    public void setValidationQueryTimeout(int validationQueryTimeout) {
        this.poolProperties.setValidationQueryTimeout(validationQueryTimeout);
    }
======= fetch "public String getValidationQuery() {" b022c57^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    
    @Override
    public int getValidationQueryTimeout() {
        return getPoolProperties().getValidationQueryTimeout();
    }
    
    /**
     * {@inheritDoc}
     */
     * The timeout in seconds before a connection validation queries fail.
     * A value less than or equal to zero will disable this feature.  Defaults to -1. 
     * @return the timeout value in seconds 
     */
    public int getValidationQueryTimeout();
    
    /**
     * The timeout in seconds before a connection validation queries fail.
     * A value less than or equal to zero will disable this feature.  Defaults to -1. 
     */
    public void setValidationQueryTimeout(int validationQueryTimeout);
    
    /**
    private volatile int validationQueryTimeout = -1;
======= fetch "public String getValidationQuery() {" b022c57^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    @Override
    public int getValidationQueryTimeout() {
        return validationQueryTimeout;
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public void setValidationQueryTimeout(int validationQueryTimeout) {
        this.validationQueryTimeout = validationQueryTimeout;
    }
    
    /**
     * {@inheritDoc}
     */
======= fetch "public boolean validate(int validateAction,String sql) {" b022c57^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            
            int validationQueryTimeout = poolProperties.getValidationQueryTimeout();
            if (validationQueryTimeout > 0) {
                stmt.setQueryTimeout(validationQueryTimeout);
            }
            
======= fetch "public String getValidationQuery() {" b022c57^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    
    @Override
    public int getValidationQueryTimeout() {
        return getPoolProperties().getValidationQueryTimeout();
    }
======= fetch "public void setValidationQuery(String validationQuery) {" b022c57^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    @Override
    public void setValidationQueryTimeout(int validationQueryTimeout) {
        getPoolProperties().setValidationQueryTimeout(validationQueryTimeout);
    }
    
             
    <attribute    name="validationQueryTimeout"
           description="The timeout in seconds before a connection validation queries fail"
                  type="java.lang.Integer"
             writeable="false" />
    
    private static int TIMEOUT = 10;
    private static boolean isTimeoutSet;
    private static final String longQuery = "select * from test as A, test as B, test as C, test as D, test as E";
    
    @Before
    public void setUp() throws SQLException {
        DriverManager.registerDriver(new MockDriver());
        
        // use our mock driver
        this.datasource.setDriverClassName(MockDriver.class.getName());
        this.datasource.setUrl(MockDriver.url);
        
        // Required to trigger validation query's execution 
        this.datasource.setInitialSize(1);
        this.datasource.setTestOnBorrow(true);
        this.datasource.setValidationInterval(-1);
        this.datasource.setValidationQuery("SELECT 1");
        this.datasource.setValidationQueryTimeout(TIMEOUT);
        
        TIMEOUT = 10;
        isTimeoutSet = false;
    }
    
    @After
    public void tearDown() throws SQLException {
        DriverManager.deregisterDriver(new MockDriver());
    }
    
    @Test
    public void testValidationQueryTimeoutEnabled() throws Exception {
        // because testOnBorrow is true, this triggers the validation query
        this.datasource.getConnection();
        Assert.assertTrue(isTimeoutSet);
    }
    
    @Test
    public void testValidationQueryTimeoutDisabled() throws Exception {
        this.datasource.setValidationQueryTimeout(-1);
        
        // because testOnBorrow is true, this triggers the validation query
        this.datasource.getConnection();
        Assert.assertFalse(isTimeoutSet);
    }
    
    @Test
    public void testValidationQueryTimeoutWithQueryTimeoutInterceptor() throws Exception {
        int interceptorTimeout = 30;
        this.datasource.setJdbcInterceptors(
                            QueryTimeoutInterceptor.class.getName()+
                            "(queryTimeout="+ interceptorTimeout +")");
        
        // because testOnBorrow is true, this triggers the validation query
        Connection con = this.datasource.getConnection();
        Assert.assertTrue(isTimeoutSet);
        
        // increase the expected timeout to 30, which is what we set for the interceptor
        TIMEOUT = 30;
        
        // now create a statement, make sure the query timeout is set by the interceptor
        Statement st = con.createStatement();
        Assert.assertEquals(interceptorTimeout, st.getQueryTimeout());
        st.close();
        st = con.prepareStatement("");
        Assert.assertEquals(interceptorTimeout, st.getQueryTimeout());
        st.close();
        st = con.prepareCall("");
        Assert.assertEquals(interceptorTimeout, st.getQueryTimeout());
        st.close();
        con.close();
        
        // pull another connection and check it
        TIMEOUT = 10;
        isTimeoutSet = false;
        this.datasource.getConnection();
        Assert.assertTrue(isTimeoutSet);
    }
    
    // this test depends on the execution time of the validation query
    //   specifically, it needs to run for longer than 1 second to pass
    //   if this fails
    @Test(expected=SQLException.class) 
    public void testValidationQueryTimeoutOnConnection() throws Exception {
        // use our mock driver
        this.datasource.setDriverClassName("org.h2.Driver");
        this.datasource.setUrl("jdbc:h2:~/.h2/test;QUERY_TIMEOUT=0;DB_CLOSE_ON_EXIT=FALSE");
        
        // Required to trigger validation query's execution 
        this.datasource.setTestOnConnect(true);
        this.datasource.setValidationInterval(-1);
        this.datasource.setValidationQuery(longQuery);
        this.datasource.setValidationQueryTimeout(1);
        
        this.datasource.getConnection();
    }
    
    @Test(expected=SQLException.class)
    public void testValidationInvalidOnConnection() throws Exception {
        // use our mock driver
        this.datasource.setDriverClassName("org.h2.Driver");
        this.datasource.setUrl("jdbc:h2:~/.h2/test;QUERY_TIMEOUT=0;DB_CLOSE_ON_EXIT=FALSE");
        
        // Required to trigger validation query's execution 
        this.datasource.setTestOnBorrow(true);
        this.datasource.setInitialSize(1);
        this.datasource.setTestOnConnect(true);
        this.datasource.setValidationInterval(-1);
        this.datasource.setValidationQuery("SELECT");
        this.datasource.setValidationQueryTimeout(1);
        
        this.datasource.getConnection();
    }
    
    @Test
    public void testLongValidationQueryTime() throws Exception {
        // use our mock driver
        this.datasource.setDriverClassName("org.h2.Driver");
        this.datasource.setUrl("jdbc:h2:~/.h2/test;QUERY_TIMEOUT=0;DB_CLOSE_ON_EXIT=FALSE");
        Connection con = this.datasource.getConnection();
        Statement stmt = null;
        long start = 0, end = 0;
        try {
            stmt = con.createStatement();
            // set the query timeout to 2 sec
            //  this keeps this test from slowing things down too much
            stmt.setQueryTimeout(2);
            // assert that our long query takes longer than one second to run
            //  this is a requirement for other tests to run properly
            start = System.currentTimeMillis();
            stmt.execute(longQuery);
        } catch (SQLException ex) {}
        finally {
            end = System.currentTimeMillis();
        
            if (stmt != null) { stmt.close(); }
            if (con != null) { con.close(); }
            
            Assert.assertTrue(start != 0 && end != 0);
            Assert.assertTrue((end - start) > 1000);
        }
    }
    
    @Test
    public void testValidationQueryTimeoutOnBorrow() throws Exception {
        // use our mock driver
        this.datasource.setDriverClassName("org.h2.Driver");
        this.datasource.setUrl("jdbc:h2:~/.h2/test;QUERY_TIMEOUT=0;DB_CLOSE_ON_EXIT=FALSE");
        
        // Required to trigger validation query's execution 
        this.datasource.setTestOnBorrow(true);
        this.datasource.setValidationInterval(-1);
        this.datasource.setValidationQuery(longQuery);
        this.datasource.setValidationQueryTimeout(1);
        
        // assert that even though the validation query times out, we still get a connection
        Connection con = this.datasource.getConnection();
        Assert.assertNotNull(con);
        Statement st = con.createStatement();
        ResultSet rs = st.executeQuery("SELECT 1");
        rs.close();
        st.close();
        con.close();
    }
    
    /**
     * Mock Driver, Connection and Statement implementations use to verify setQueryTimeout was called.
     */
    public static class MockDriver implements java.sql.Driver {
        public static final String url = "jdbc:tomcat:mock";
        public MockDriver() {
        }
        @Override
        public boolean acceptsURL(String url) throws SQLException {
            return url!=null && url.equals(MockDriver.url);
        }
        @Override
        public Connection connect(String url, Properties info) throws SQLException {
            return new MockConnection(info);
        }
        @Override
        public int getMajorVersion() {
            return 0;
        }
        @Override
        public int getMinorVersion() {
            return 0;
        }
        @Override
        public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) throws SQLException {
            return null;
        }
        @Override
        public boolean jdbcCompliant() {
            return false;
        }
        @Override
        public Logger getParentLogger() throws SQLFeatureNotSupportedException {
            return null;
        }
    }
    
    public static class MockConnection extends org.apache.tomcat.jdbc.test.driver.Connection {
        public MockConnection(Properties info) {
            super(info);
        }
        @Override
        public Statement createStatement() throws SQLException {
            return new MockStatement();
        }
    }
    
    public static class MockStatement extends org.apache.tomcat.jdbc.test.driver.Statement {
        @Override
        public void setQueryTimeout(int seconds) throws SQLException {
            super.setQueryTimeout(seconds);
            Assert.assertEquals(TIMEOUT, seconds);
            isTimeoutSet = true;
        }
    }

======= fetch "public boolean isValid() {" 262c069^:"java/org/apache/catalina/ha/session/DeltaSession.java"

        if (this.expiring) {
            return true;
        }
======= fetch "public boolean isValid() {" 262c069^:"java/org/apache/catalina/ha/session/DeltaSession.java"

        if (this.expiring) {
            return true;
        }
======= fetch "public void expire(boolean notify, boolean notifyCluster) {" 262c069^:"java/org/apache/catalina/ha/session/DeltaSession.java"

        if (expiring)
======= fetch "public void expire(boolean notify, boolean notifyCluster) {" 262c069^:"java/org/apache/catalina/ha/session/DeltaSession.java"

        String expiredId = getIdInternal();
        if(notifyCluster && expiredId != null && manager != null &&
           manager instanceof DeltaManager) {
            DeltaManager dmanager = (DeltaManager)manager;
            CatalinaCluster cluster = dmanager.getCluster();
            ClusterMessage msg = dmanager.requestCompleted(expiredId, true);
            if (msg != null) {
                cluster.send(msg);
======= fetch "public void expire(boolean notify, boolean notifyCluster) {" 262c069^:"java/org/apache/catalina/ha/session/DeltaSession.java"

        }
======= fetch "public void expire(boolean notify, boolean notifyCluster) {" 262c069^:"java/org/apache/catalina/ha/session/DeltaSession.java"

        super.expire(notify);
======= fetch "public void expire(boolean notify, boolean notifyCluster) {" 262c069^:"java/org/apache/catalina/ha/session/DeltaSession.java"

        if (notifyCluster) {
            if (log.isDebugEnabled())
                log.debug(sm.getString("deltaSession.notifying",
                                       ((ClusterManager)manager).getName(),
                                       Boolean.valueOf(isPrimarySession()),
                                       expiredId));
            if ( manager instanceof DeltaManager ) {
                ( (DeltaManager) manager).sessionExpired(expiredId);
======= fetch "public boolean isValid() {" 262c069^:"java/org/apache/catalina/session/StandardSession.java"

        if (this.expiring) {
            return true;
        }
======= fetch "public boolean isValid() {" 262c069^:"java/org/apache/catalina/session/StandardSession.java"

        if (this.expiring) {
            return true;
        }
======= fetch "public boolean isValid() {" 262c069^:"java/org/apache/catalina/session/StandardSession.java"

        return (this.isValid);
======= fetch "public void expire(boolean notify) {" 262c069^:"java/org/apache/catalina/session/StandardSession.java"

        // Check to see if expire is in progress or has previously been called
        if (expiring || !isValid)
======= fetch "public void expire(boolean notify) {" 262c069^:"java/org/apache/catalina/session/StandardSession.java"

            // Double check locking - expiring and isValid need to be volatile
            if (expiring || !isValid)
======= fetch "public void expire(boolean notify) {" 262c069^:"java/org/apache/catalina/session/StandardSession.java"

            setValid(false);
======= fetch "public void expire(boolean notify) {" 262c069^:"java/org/apache/catalina/session/StandardSession.java"

            setValid(false);
======= fetch "protected boolean isValidInternal() {" 262c069^:"java/org/apache/catalina/session/StandardSession.java"

        return (this.isValid || this.expiring);

======= fetch "public void configureSessionContext(SSLSessionContext sslSessionContext) {" f126b5a^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            if (JSSESocketFactory.defaultKeystoreType.equals(keystoreType)) {

    <attribute name="ignoreExceptionOnPreLoad" required="false">
      <p>(boolean) Flag whether ignore error of connection creation while initializing the pool.
         Set to true if you want to ignore error of connection creation while initializing the pool.
         Set to false if you want to fail the initialization of the pool by throwing exception.
         The default value is <code>false</code>.
      </p>
    </attribute>
======= fetch "protected void init(PoolConfiguration properties) throws SQLException {" 4aa42d7^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            if (jmxPool!=null) jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_INIT, getStackTrace(x));
            close(true);
            throw x;
        PROP_PROPAGATEINTERRUPTSTATE
======= fetch "public static PoolConfiguration parsePoolProperties(Properties properties) {" 4aa42d7^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        value = properties.getProperty(PROP_IGNOREEXCEPTIONONPRELOAD);
        if (value != null) {
            poolProperties.setIgnoreExceptionOnPreLoad(Boolean.parseBoolean(value));
        }
======= fetch "public void setPropagateInterruptState(boolean propagateInterruptState) {" 4aa42d7^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isIgnoreExceptionOnPreLoad() {
        return getPoolProperties().isIgnoreExceptionOnPreLoad();
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setIgnoreExceptionOnPreLoad(boolean ignoreExceptionOnPreLoad) {
        getPoolProperties().setIgnoreExceptionOnPreLoad(ignoreExceptionOnPreLoad);
    }
    /**
     * Set to true if you want to ignore error of connection creation while initializing the pool.
     * Set to false if you want to fail the initialization of the pool by throwing exception.
     * @param ignoreExceptionOnPreLoad set to true if you want to ignore error of connection creation while initializing the pool.
     */
    public void setIgnoreExceptionOnPreLoad(boolean ignoreExceptionOnPreLoad);
    /**
     * @see PoolConfiguration#setIgnoreExceptionOnPreLoad(boolean)
     */
    public boolean isIgnoreExceptionOnPreLoad();
    private volatile boolean ignoreExceptionOnPreLoad = false;
======= fetch "public void setPropagateInterruptState(boolean propagateInterruptState) {" 4aa42d7^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isIgnoreExceptionOnPreLoad() {
        return ignoreExceptionOnPreLoad;
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setIgnoreExceptionOnPreLoad(boolean ignoreExceptionOnPreLoad) {
        this.ignoreExceptionOnPreLoad = ignoreExceptionOnPreLoad;
    }
======= fetch "public void setPropagateInterruptState(boolean propagateInterruptState) {" 4aa42d7^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    public boolean isIgnoreExceptionOnPreLoad() {
        return getPoolProperties().isIgnoreExceptionOnPreLoad();
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setIgnoreExceptionOnPreLoad(boolean ignoreExceptionOnPreLoad) {
        getPoolProperties().setIgnoreExceptionOnPreLoad(ignoreExceptionOnPreLoad);
    }
    /**
     * {@inheritDoc}
     */
    @Override

======= fetch "protected void close(boolean force) {" 41225cd^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                } else {
                    Thread.interrupted();
======= fetch "private PooledConnection borrowConnection(int wait, String username, String pass" 41225cd^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                } else {
                    Thread.interrupted();

======= fetch "public final void action(ActionCode actionCode, Object param) {" cf1e104^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
            if (param == null) return;
            long timeout = ((Long)param).longValue();
            socketWrapper.setTimeout(timeout);
======= fetch "public SocketState asyncDispatch(SocketStatus status) {" cf1e104^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

            resetTimeouts();
======= fetch "public void recycle(boolean socketClosing) {" cf1e104^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

    // Methods called by asyncDispatch
    /**
     * Provides a mechanism for those connector implementations (currently only
     * NIO) that need to reset timeouts from Async timeouts to standard HTTP
     * timeouts once async processing completes.
     */
    protected abstract void resetTimeouts();
    // Methods called by prepareResponse()
    protected abstract void output(byte[] src, int offset, int length)
            throws IOException;
======= fetch "protected abstract void setTimeout(SocketWrapper<S> socketWrapper," cf1e104^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

    // Methods called by prepareResponse()
    protected abstract void output(byte[] src, int offset, int length)
            throws IOException;
======= fetch "protected void actionInternal(ActionCode actionCode, Object param) {" cf1e104^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
            if (param == null) return;
            long timeout = ((Long)param).longValue();
            socketWrapper.setTimeout(timeout);
======= fetch "protected void actionInternal(ActionCode actionCode, Object param) {" cf1e104^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

    protected void resetTimeouts() {
        // NO-OP. The AJP APR/native connector only uses the timeout value on
        //        time SocketWrapper for async timeouts.
    }
    @Override
======= fetch "protected void actionInternal(ActionCode actionCode, Object param) {" cf1e104^:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
            if (param == null) return;
            long timeout = ((Long)param).longValue();
            final KeyAttachment ka =
                    (KeyAttachment)socketWrapper.getSocket().getAttachment(false);
            if (keepAliveTimeout > 0) {
                ka.setTimeout(timeout);
            }
======= fetch "protected void actionInternal(ActionCode actionCode, Object param) {" cf1e104^:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

    protected void resetTimeouts() {
        // The NIO connector uses the timeout configured on the wrapper in the
        // poller. Therefore, it needs to be reset once asycn processing has
        // finished.
        final NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socketWrapper.getSocket().getAttachment(false);
        if (!error && attach != null &&
                asyncStateMachine.isAsyncDispatching()) {
            long soTimeout = endpoint.getSoTimeout();
            //reset the timeout
            if (keepAliveTimeout > 0) {
                attach.setTimeout(keepAliveTimeout);
            } else {
                attach.setTimeout(soTimeout);
            }
        }
    }
    @Override
======= fetch "protected void actionInternal(ActionCode actionCode, Object param) {" cf1e104^:"java/org/apache/coyote/ajp/AjpProcessor.java"

        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
            if (param == null) return;
            long timeout = ((Long)param).longValue();
            // if we are not piggy backing on a worker thread, set the timeout
            socketWrapper.setTimeout(timeout);
======= fetch "protected void actionInternal(ActionCode actionCode, Object param) {" cf1e104^:"java/org/apache/coyote/ajp/AjpProcessor.java"

    protected void resetTimeouts() {
        // NO-OP. The AJP BIO connector only uses the timeout value on the
        //        SocketWrapper for async timeouts.
    }
    @Override

======= fetch "public Principal authenticate(String username, String credentials) {" 7e74aee^:"java/org/apache/catalina/realm/JNDIRealm.java"

                containerLog.warn(sm.getString("jndiRealm.exception"), e);
======= fetch "public Principal authenticate(String username, String credentials) {" 7e74aee^:"java/org/apache/catalina/realm/JNDIRealm.java"

                containerLog.warn(sm.getString("jndiRealm.exception"), e);
======= fetch "public Principal authenticate(String username, String credentials) {" 7e74aee^:"java/org/apache/catalina/realm/JNDIRealm.java"

                containerLog.warn(sm.getString("jndiRealm.exception"), e);
======= fetch "protected Principal getPrincipal(String username," 7e74aee^:"java/org/apache/catalina/realm/JNDIRealm.java"

                containerLog.warn(sm.getString("jndiRealm.exception"), e);
======= fetch "protected Principal getPrincipal(String username," 7e74aee^:"java/org/apache/catalina/realm/JNDIRealm.java"

                containerLog.warn(sm.getString("jndiRealm.exception"), e);
======= fetch "protected DirContext open() throws NamingException {" 7e74aee^:"java/org/apache/catalina/realm/JNDIRealm.java"

            containerLog.warn(sm.getString("jndiRealm.exception"), e);

     * Should any response body be swallowed and not sent to the client.
     */
    private boolean swallowResponse = false;
    /**
======= fetch "public void recycle(boolean socketClosing) {" 6d99103^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        swallowResponse = false;
======= fetch "protected void prepareResponse() throws IOException {" 6d99103^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        // Responses with certain status codes are not permitted to include a
        // response body.
        int statusCode = response.getStatus();
        if (statusCode < 200 || statusCode == 204 || statusCode == 205 ||
                statusCode == 304) {
            // No entity body
            swallowResponse = true;
        }
        // Responses to HEAD requests are not permitted to incude a response
        // body.
        MessageBytes methodMB = request.method();
        if (methodMB.equals("HEAD")) {
            // No entity body
            swallowResponse = true;
        }
======= fetch "protected void prepareResponse() throws IOException {" 6d99103^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        responseMessage.appendInt(response.getStatus());
======= fetch "public int doWrite(ByteChunk chunk, Response res)" 6d99103^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

            int len = chunk.getLength();
            // 4 - hardcoded, byte[] marshaling overhead
            // Adjust allowed size if packetSize != default (Constants.MAX_PACKET_SIZE)
            int chunkSize = Constants.MAX_SEND_SIZE + packetSize - Constants.MAX_PACKET_SIZE;
            int off = 0;
            while (len > 0) {
                int thisTime = len;
                if (thisTime > chunkSize) {
                    thisTime = chunkSize;
======= fetch "public int doWrite(ByteChunk chunk, Response res)" 6d99103^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

                len -= thisTime;
                responseMessage.reset();
                responseMessage.appendByte(Constants.JK_AJP13_SEND_BODY_CHUNK);
                responseMessage.appendBytes(chunk.getBytes(), chunk.getOffset() + off, thisTime);
                responseMessage.end();
                output(responseMessage.getBuffer(), 0, responseMessage.getLen());
                off += thisTime;
            }
======= fetch "public int doWrite(ByteChunk chunk, Response res)" 6d99103^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

            bytesWritten += chunk.getLength();
======= fetch "public void testKeepAlive() throws Exception {" 6d99103^:"test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java"

======= fetch "public void testSimplePost() throws Exception {" 6d99103^:"test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java"

    /*
     * Bug 55453
     */
    @Test
    public void test304WithBody() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctx, "bug55453", new Tester304WithBodyServlet());
        ctx.addServletMapping("/", "bug55453");
        tomcat.start();
        SimpleAjpClient ajpClient = new SimpleAjpClient();
        ajpClient.setPort(getPort());
        ajpClient.connect();
        validateCpong(ajpClient.cping());
        TesterAjpMessage forwardMessage = ajpClient.createForwardMessage("/");
        forwardMessage.end();
        TesterAjpMessage responseHeaders =
                ajpClient.sendMessage(forwardMessage, null);
        // Expect 2 messages: headers, end
        validateResponseHeaders(responseHeaders, 304);
        validateResponseEnd(ajpClient.readMessage(), true);
        // Double check the connection is still open
        validateCpong(ajpClient.cping());
        ajpClient.disconnect();
    }
======= fetch "private void validateCpong(TesterAjpMessage message) throws Exception {" 6d99103^:"test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java"

    private static class Tester304WithBodyServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setStatus(304);
            resp.getWriter().print("Body not permitted for 304 response");
        }
    }

======= fetch "public void setHostname(String s) {" 058f044^:"java/org/apache/catalina/startup/Tomcat.java"

     * web application and any WEB-INF/web.xml packaged with the application
     * will be processed normally. Normal web fragment and
======= fetch "public Context addWebapp(Host host, String url, String name, String path) {" 058f044^:"java/org/apache/catalina/startup/Tomcat.java"

        ctx.setConfigFile(getWebappConfigFile(path, url));
======= fetch "private void silence(Host host, String ctx) {" 058f044^:"java/org/apache/catalina/startup/Tomcat.java"

        String base = "org.apache.catalina.core.ContainerBase.[default].[";
======= fetch "private void silence(Host host, String ctx) {" 058f044^:"java/org/apache/catalina/startup/Tomcat.java"

            base += getHost().getName();
======= fetch "private void silence(Host host, String ctx) {" 058f044^:"java/org/apache/catalina/startup/Tomcat.java"

            base += host.getName();
======= fetch "private void silence(Host host, String ctx) {" 058f044^:"java/org/apache/catalina/startup/Tomcat.java"

        base += "].[";
        base += ctx;
        base += "]";
        Logger.getLogger(base).setLevel(Level.WARNING);
======= fetch "public String getServletClass() {" 058f044^:"java/org/apache/catalina/startup/Tomcat.java"

    protected URL getWebappConfigFile(String path, String url) {
        File docBase = new File(path);
        if (docBase.isDirectory()) {
            return getWebappConfigFileFromDirectory(docBase, url);
        } else {
            return getWebappConfigFileFromJar(docBase, url);
        }
    }
    private URL getWebappConfigFileFromDirectory(File docBase, String url) {
        URL result = null;
        File webAppContextXml = new File(docBase, Constants.ApplicationContextXml);
        if (webAppContextXml.exists()) {
            try {
                result = webAppContextXml.toURI().toURL();
            } catch (MalformedURLException e) {
                Logger.getLogger(getLoggerName(getHost(), url)).log(Level.WARNING,
                        "Unable to determine web application context.xml " + docBase, e);
            }
        }
        return result;
    }
    private URL getWebappConfigFileFromJar(File docBase, String url) {
        URL result = null;
        JarFile jar = null;
        try {
            jar = new JarFile(docBase);
            JarEntry entry = jar.getJarEntry(Constants.ApplicationContextXml);
            if (entry != null) {
                result = new URL("jar:" + docBase.toURI().toString() + "!/"
                        + Constants.ApplicationContextXml);
            }
        } catch (IOException e) {
            Logger.getLogger(getLoggerName(getHost(), url)).log(Level.WARNING,
                    "Unable to determine web application context.xml " + docBase, e);
        } finally {
            if (jar != null) {
                try {
                    jar.close();
                } catch (IOException e) {
                    // ignore
                }
            }
        }
        return result;
    }
======= fetch "public void testBug53301() throws Exception {" 058f044^:"test/org/apache/catalina/startup/TestTomcat.java"

    @Test
    public void testGetWebappConfigFileFromDirectory() {
        Tomcat tomcat = new Tomcat();
        assertNotNull(tomcat.getWebappConfigFile("test/deployment/dirContext", ""));
    }
    @Test
    public void testGetWebappConfigFileFromDirectoryNegative() {
        Tomcat tomcat = new Tomcat();
        assertNull(tomcat.getWebappConfigFile("test/deployment/dirNoContext", ""));
    }
    @Test
    public void testGetWebappConfigFileFromJar() {
        Tomcat tomcat = new Tomcat();
        assertNotNull(tomcat.getWebappConfigFile("test/deployment/context.war", ""));
    }
    @Test
    public void testGetWebappConfigFileFromJarNegative() {
        Tomcat tomcat = new Tomcat();
        assertNull(tomcat.getWebappConfigFile("test/deployment/noContext.war", ""));
    }
    @Test
    public void testBug51526() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appFile = new File("test/deployment/context.war");
        StandardContext context = (StandardContext) tomcat.addWebapp(null, "/test",
                appFile.getAbsolutePath());
        tomcat.start();
        assertEquals("WAR_CONTEXT", context.getSessionCookieName());
    }

======= fetch "protected boolean removeSessionAttribute(ContextName cn, String sessionId," 9a22360^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "</td>\n" +
        "</tr>\n" +

======= fetch "public static MediaType parseMediaType(StringReader input)" 8b03dcf^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

            String value = "";
======= fetch "public static MediaType parseMediaType(StringReader input)" 8b03dcf^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

                String value = readTokenOrQuotedString(input, true);
======= fetch "public static MediaType parseMediaType(StringReader input)" 8b03dcf^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

            } else {
                parameters.put(attribute.toLowerCase(Locale.ENGLISH), "");
======= fetch "public void testBug53353() throws IOException {" 8b03dcf^:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

    @Test
    public void testBug55454() throws IOException {
        String input = "text/html;;charset=UTF-8";
        StringReader sr = new StringReader(input);
        MediaType m = HttpParser.parseMediaType(sr);
        assertEquals("text", m.getType());
        assertEquals("html", m.getSubtype());
        assertTrue(m.getParameterCount() == 1);
        assertEquals("UTF-8", m.getParameterValue("charset"));
        assertEquals("UTF-8", m.getCharset());
        assertEquals("text/html; charset=UTF-8", m.toString());
    }

======= fetch "public Object getValue(EvaluationContext ctx)" ab70f07^:"java/org/apache/el/parser/AstFunction.java"

            // Call to a constructor or a static method
            obj = ctx.getImportHandler().resolveClass(this.localName);
            if (obj != null) {
                return ctx.getELResolver().invoke(ctx, new ELClass((Class<?>) obj), "<init>", null,
                        ((AstMethodParameters) this.children[0]).getParameters(ctx));
            }
            obj = ctx.getImportHandler().resolveStatic(this.localName);
            if (obj != null) {
                return ctx.getELResolver().invoke(ctx, new ELClass((Class<?>) obj), this.localName,
                        null, ((AstMethodParameters) this.children[0]).getParameters(ctx));
            }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testImport01() {
        ELProcessor processor = new ELProcessor();
        Object result = processor.getValue("Integer(1000)", Integer.class);
        Assert.assertEquals(Integer.valueOf(1000), result);
    }
    @Test
    public void testImport02() {
        ELProcessor processor = new ELProcessor();
        processor.getELManager().getELContext().getImportHandler()
                .importStatic("java.lang.Integer.valueOf");
        Object result = processor.getValue("valueOf(1000)", Integer.class);
        Assert.assertEquals(Integer.valueOf(1000), result);
    }

======= fetch "public void setReadListener(ReadListener listener) {" 7f6ea48^:"java/org/apache/catalina/connector/InputBuffer.java"

        if (isFinished() || isReady()) {
======= fetch "public boolean isFinished() {" 7f6ea48^:"java/org/apache/catalina/connector/InputBuffer.java"

        return available() == 0;
======= fetch "public boolean isFinished() {" 7f6ea48^:"java/org/apache/catalina/connector/Request.java"

        AtomicBoolean result = new AtomicBoolean(false);
        coyoteRequest.action(ActionCode.REQUEST_BODY_FULLY_READ, result);
        return result.get();
======= fetch "public void setAvailable(int available) {" 7f6ea48^:"java/org/apache/coyote/Request.java"

    // -------------------- Input Buffer --------------------
======= fetch "public void setAvailable(int available) {" 7f6ea48^:"java/org/apache/coyote/Request.java"

    // -------------------- Input Buffer --------------------
======= fetch "public void testNonBlockingWriteError() throws Exception {" 7f6ea48^:"test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java"

                servlet.wlistener.onErrorInvoked);
======= fetch "public void testNonBlockingWriteError() throws Exception {" 7f6ea48^:"test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java"

    @Test
    public void testBug55438NonBlockingReadWriteEmptyRead() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        StandardContext ctx = (StandardContext) tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        NBReadWriteServlet servlet = new NBReadWriteServlet();
        String servletName = NBReadWriteServlet.class.getName();
        Tomcat.addServlet(ctx, servletName, servlet);
        ctx.addServletMapping("/", servletName);
        tomcat.start();
        Map<String, List<String>> resHeaders = new HashMap<>();
        int rc = postUrl(false, new BytesStreamer() {
            @Override
            public byte[] next() {
                return new byte[] {};
            }
            @Override
            public int getLength() {
                return 0;
            }
            @Override
            public int available() {
                return 0;
            }
        }, "http://localhost:" +
                getPort() + "/", new ByteChunk(), resHeaders, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
    }
======= fetch "public void onComplete(AsyncEvent event) throws IOException {" 7f6ea48^:"test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java"

    @WebServlet(asyncSupported = true)
    public class NBReadWriteServlet extends TesterServlet {
        private static final long serialVersionUID = 1L;
        public volatile TestReadWriteListener rwlistener;
        @Override
        protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            // step 1 - start async
            AsyncContext actx = req.startAsync();
            actx.setTimeout(Long.MAX_VALUE);
            // step 2 - notify on read
            ServletInputStream in = req.getInputStream();
            rwlistener = new TestReadWriteListener(actx);
            in.setReadListener(rwlistener);
        }
    }
======= fetch "public void onComplete(AsyncEvent event) throws IOException {" 7f6ea48^:"test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java"

        public volatile boolean onErrorInvoked = false;
======= fetch "public void onError(Throwable throwable) {" 7f6ea48^:"test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java"

            onErrorInvoked = true;
======= fetch "public void onError(Throwable throwable) {" 7f6ea48^:"test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java"

    private class TestReadWriteListener implements ReadListener {
        AsyncContext ctx;
        private final StringBuilder body = new StringBuilder();
        public TestReadWriteListener(AsyncContext ctx) {
            this.ctx = ctx;
        }
        @Override
        public void onDataAvailable() throws IOException {
            ServletInputStream in = ctx.getRequest().getInputStream();
            String s = "";
            byte[] b = new byte[8192];
            int read = 0;
            do {
                read = in.read(b);
                if (read == -1) {
                    break;
                }
                s += new String(b, 0, read);
            } while (in.isReady());
            log.info("Read [" + s + "]");
            body.append(s);
        }
        @Override
        public void onAllDataRead() throws IOException {
            log.info("onAllDataRead");
            ServletOutputStream output = ctx.getResponse().getOutputStream();
            output.setWriteListener(new WriteListener() {
                @Override
                public void onWritePossible() throws IOException {
                    ServletOutputStream output = ctx.getResponse().getOutputStream();
                    if (output.isReady()) {
                        log.info("Writing [" + body.toString() + "]");
                        output.write(body.toString().getBytes("utf-8"));
                    }
                    ctx.complete();
                }
                @Override
                public void onError(Throwable throwable) {
                    log.info("ReadWriteListener.onError");
                    throwable.printStackTrace();
                }
            });
        }
        @Override
        public void onError(Throwable throwable) {
            log.info("ReadListener.onError");
            throwable.printStackTrace();
        }
    }

    private final Map<String,Segment> segments = new LinkedHashMap<>();
======= fetch "public UriTemplate(String path) throws DeploymentException {" 98ee5b4^:"java/org/apache/tomcat/websocket/server/UriTemplate.java"

        Set<String> paramNames = new HashSet<>();
======= fetch "public UriTemplate(String path) throws DeploymentException {" 98ee5b4^:"java/org/apache/tomcat/websocket/server/UriTemplate.java"

                if (!paramNames.add(segment)) {
                    throw new IllegalArgumentException(sm.getString(
                            "uriTemplate.duplicateParameter", segment));
                }
======= fetch "public UriTemplate(String path) throws DeploymentException {" 98ee5b4^:"java/org/apache/tomcat/websocket/server/UriTemplate.java"

            Segment old =
                    this.segments.put(segment, new Segment(index, segment));
            if (old != null) {
                throw new IllegalArgumentException(
                        sm.getString("uriTemplate.duplicateName", segment));
            }
======= fetch "public UriTemplate(String path) throws DeploymentException {" 98ee5b4^:"java/org/apache/tomcat/websocket/server/UriTemplate.java"

                candidate.getSegments().values().iterator();
        Iterator<Segment> targetSegments = segments.values().iterator();
======= fetch "public String getNormalizedPath() {" 98ee5b4^:"java/org/apache/tomcat/websocket/server/UriTemplate.java"

    private Map<String,Segment> getSegments() {
      <Method name="testDuplicate" />
    <Bug  pattern="DLS_DEAD_LOCAL_STORE"/>
======= fetch "public void testSpecExample2_03() throws Exception {" 98ee5b4^:"test/org/apache/tomcat/websocket/server/TestUriTemplate.java"

   }
======= fetch "public void testSpecExample2_04() throws Exception {" 98ee5b4^:"test/org/apache/tomcat/websocket/server/TestUriTemplate.java"

   }
======= fetch "public void testSpecExample2_04() throws Exception {" 98ee5b4^:"test/org/apache/tomcat/websocket/server/TestUriTemplate.java"

    public void testDuplicate() throws Exception {
======= fetch "public void testDuplicate() throws Exception {" 98ee5b4^:"test/org/apache/tomcat/websocket/server/TestUriTemplate.java"

   }

======= fetch "protected synchronized Principal getPrincipal(DirContext context," 135e2c4^:"java/org/apache/catalina/realm/JNDIRealm.java"

        Hashtable<?, ?> preservedEnvironment = null;
======= fetch "protected synchronized Principal getPrincipal(DirContext context," 135e2c4^:"java/org/apache/catalina/realm/JNDIRealm.java"

                // Preserve the current context environment parameters
                preservedEnvironment = context.getEnvironment();
======= fetch "protected synchronized Principal getPrincipal(DirContext context," 135e2c4^:"java/org/apache/catalina/realm/JNDIRealm.java"

            try {
                context.removeFromEnvironment(
                        Context.SECURITY_AUTHENTICATION);
            } catch (NamingException e) {
                // Ignore
            }
            try {
                context.removeFromEnvironment(
                        "javax.security.sasl.server.authentication");
            } catch (NamingException e) {
                // Ignore
            }
            try {
                context.removeFromEnvironment(
                        "javax.security.sasl.qop");
            } catch (NamingException e) {
                // Ignore
            }
======= fetch "protected synchronized Principal getPrincipal(DirContext context," 135e2c4^:"java/org/apache/catalina/realm/JNDIRealm.java"

    private void restoreEnvironmentParameter(DirContext context,
            String parameterName, Hashtable<?, ?> preservedEnvironment) {
        try {
            context.removeFromEnvironment(parameterName);
            if (preservedEnvironment != null && preservedEnvironment.containsKey(parameterName)) {
                context.addToEnvironment(parameterName,
                        preservedEnvironment.get(parameterName));
            }
        } catch (NamingException e) {
            // Ignore
        }
    }

======= fetch "public Session load(String id)" e19e794^:"java/org/apache/catalina/session/FileStore.java"

        ClassLoader oldThreadContextCL = Thread.currentThread().getContextClassLoader();
======= fetch "public Session load(String id)" e19e794^:"java/org/apache/catalina/session/FileStore.java"

            if (classLoader != null)
======= fetch "public Session load(String id)" e19e794^:"java/org/apache/catalina/session/FileStore.java"

            else
======= fetch "public Session load(String id)" e19e794^:"java/org/apache/catalina/session/FileStore.java"

            }
            StandardSession session =
                    (StandardSession) manager.createEmptySession();
            session.readObjectData(ois);
            session.setManager(manager);
            return (session);
======= fetch "public Session load(String id)" e19e794^:"java/org/apache/catalina/session/FileStore.java"

        }
        try {
            StandardSession session =
                (StandardSession) manager.createEmptySession();
            session.readObjectData(ois);
            session.setManager(manager);
            return (session);
======= fetch "public Session load(String id)" e19e794^:"java/org/apache/catalina/session/FileStore.java"

            // Close the input stream
            try {
                ois.close();
            } catch (IOException f) {
                // Ignore
======= fetch "public Session load(String id)" e19e794^:"java/org/apache/catalina/session/FileStore.java"

            Thread.currentThread().setContextClassLoader(oldThreadContextCL);
======= fetch "public Session load(String id)" e19e794^:"java/org/apache/catalina/session/JDBCStore.java"

                ClassLoader oldThreadContextCL = Thread.currentThread().getContextClassLoader();
======= fetch "public Session load(String id)" e19e794^:"java/org/apache/catalina/session/JDBCStore.java"

                            Thread.currentThread().setContextClassLoader(classLoader);
======= fetch "public Session load(String id)" e19e794^:"java/org/apache/catalina/session/JDBCStore.java"

                    Thread.currentThread().setContextClassLoader(oldThreadContextCL);

        FilterRegistration fr = servletContext.addFilter(

======= fetch "protected void validateSecurityRoles() {" df02b95^:"java/org/apache/catalina/startup/ContextConfig.java"

                    log.info(sm.getString("contextConfig.role.auth", roles[j]));
======= fetch "protected void validateSecurityRoles() {" df02b95^:"java/org/apache/catalina/startup/ContextConfig.java"

                log.info(sm.getString("contextConfig.role.runas", runAs));
======= fetch "protected void validateSecurityRoles() {" df02b95^:"java/org/apache/catalina/startup/ContextConfig.java"

                    log.info(sm.getString("contextConfig.role.link", link));

======= fetch "private void configure() {" 7d0408e^:"java/org/apache/juli/FileHandler.java"

                setFormatter(new SimpleFormatter());
======= fetch "private void configure() {" 7d0408e^:"java/org/apache/juli/FileHandler.java"

            setFormatter(new SimpleFormatter());

======= fetch "public String getRealPath(String path) {" aa15bac^:"java/org/apache/catalina/core/StandardContext.java"

        // The WebResources API expects all paths to start with /. This is a
        // special case for consistency with earlier Tomcat versions.
        if ("".equals(path)) {
            path = "/";
        }

======= fetch "protected synchronized String getPassword(String username) {" 6cd42af^:"java/org/apache/catalina/realm/JDBCRealm.java"

                dbConnection.commit();
======= fetch "protected synchronized String getPassword(String username) {" 6cd42af^:"java/org/apache/catalina/realm/JDBCRealm.java"

                dbConnection.commit();

======= fetch "private void sendCloseMessage(CloseReason closeReason) {" d370084^:"java/org/apache/tomcat/websocket/WsSession.java"

            log.error(sm.getString("wsSession.sendCloseFail"), ioe);

======= fetch "public void scan(JarScanType scanType, ServletContext context," 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

                        process(callback, url, true);
======= fetch "public void scan(JarScanType scanType, ServletContext context," 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

                        // Extract the jarName if there is one to be found
                        String jarName = getJarName(urls[i]);
                        // Skip JARs known not to be interesting
                        if (jarName != null &&
                                jarScanFilter.check(scanType, jarName)) {
======= fetch "public void scan(JarScanType scanType, ServletContext context," 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

                                log.debug(sm.getString("jarScan.classloaderJarScan", urls[i]));
======= fetch "public void scan(JarScanType scanType, ServletContext context," 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

                                process(callback, urls[i], isWebapp);
======= fetch "public void scan(JarScanType scanType, ServletContext context," 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

                                        "jarScan.classloaderFail",urls[i]), ioe);
======= fetch "public void scan(JarScanType scanType, ServletContext context," 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

                            // JAR / directory has been skipped
======= fetch "public void scan(JarScanType scanType, ServletContext context," 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

                                log.trace(sm.getString("jarScan.classloaderJarNoScan", urls[i]));
======= fetch "private boolean isWebappClassLoader(ClassLoader classLoader) {" 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

    private void process(JarScannerCallback callback, URL url, boolean isWebapp)
            throws IOException {
======= fetch "private void process(JarScannerCallback callback, URL url, boolean isWebapp)" 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

                        } else if (f.isDirectory() && scanAllDirectories) {
                            File metainf = new File(f.getAbsoluteFile() +
                                    File.separator + "META-INF");
                            if (metainf.isDirectory()) {
======= fetch "private void process(JarScannerCallback callback, URL url, boolean isWebapp)" 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

                            } else {
                                File metainf = new File(f.getAbsoluteFile() +
                                        File.separator + "META-INF");
                                if (metainf.isDirectory()) {
                                    callback.scan(f, isWebapp);
                                }
======= fetch "private void process(JarScannerCallback callback, URL url, boolean isWebapp)" 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

    /*
     * Extract the JAR name, if present, from a URL
     */
    private String getJarName(URL url) {
        String name = null;
        String path = url.getPath();
        int end = path.indexOf(Constants.JAR_EXT);
        if (end != -1) {
            int start = path.lastIndexOf('/', end);
            name = path.substring(start + 1, end + 4);
        } else if (isScanAllDirectories()){
            int start = path.lastIndexOf('/');
            name = path.substring(start + 1);
======= fetch "private String getJarName(URL url) {" 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

        return name;
    }
======= fetch "private String getJarName(URL url) {" 7540e90^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

       <p>The comma separated list of JAR file name patterns to skip when
       scanning for TLDs. If not specified, the default is obtained from the
       <code>tomcat.util.scan.StandardJarScanFilter.jarsToSkip</code> system
       property.</p>
       <p>The comma separated list of JAR file name patterns to scan when
       scanning for TLDs. If not specified, the default is obtained from the
       <code>tomcat.util.scan.StandardJarScanFilter.jarsToScan</code> system
       property.</p>
       <p>The comma separated list of JAR file name patterns to skip when
       scanning for pluggable features. If not specified, the default is
       obtained from the
       <p>The comma separated list of JAR file name patterns to scan when
       scanning for pluggable features. If not specified, the default is
       obtained from the
  used to scan the web application for JAR files. It is typically used during
  web application start to identify configuration files such as TLDs or
  web-fragment.xml files that must be processed as part of the web application
  initialisation.</p>
       if are expanded Jar files. The default is <code>false</code>. Tomcat
       directory to be an expanded JAR file.</p>

    private PageInfo pageInfo;
======= fetch "public void apply(Node.Nodes page, ErrorDispatcher err, PageInfo pageInfo)" 11c05b7^:"java/org/apache/jasper/compiler/TagPluginManager.java"

        this.pageInfo = pageInfo;
        page.visit(new Node.Visitor() {
            @Override
            public void visit(Node.CustomTag n)
                    throws JasperException {
                invokePlugin(n);
                visitBody(n);
            }
        });
======= fetch "private void loadTagPlugins(ErrorDispatcher err, InputStream is)" 11c05b7^:"java/org/apache/jasper/compiler/TagPluginManager.java"

    private void invokePlugin(Node.CustomTag n) {
======= fetch "private void invokePlugin(Node.CustomTag n) {" 11c05b7^:"java/org/apache/jasper/compiler/TagPluginManager.java"

    private static class NodeVisitor extends Node.Visitor {
        private TagPluginManager manager;
        private PageInfo pageInfo;
        public NodeVisitor(TagPluginManager manager, PageInfo pageInfo) {
            this.manager = manager;
            this.pageInfo = pageInfo;
        }
        @Override
        public void visit(Node.CustomTag n) throws JasperException {
            manager.invokePlugin(n, pageInfo);
            visitBody(n);
        }
    }

======= fetch "protected void webConfig() {" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

            processServletContainerInitializers(orderedFragments);
======= fetch "protected WebXml createWebXml() {" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

     * Implementations will be added in web-fragment.xml priority order.
======= fetch "protected WebXml createWebXml() {" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

    protected void processServletContainerInitializers(
            Set<WebXml> fragments) {
======= fetch "protected void processServletContainerInitializers(" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

        for (WebXml fragment : fragments) {
            URL url = fragment.getURL();
            Jar jar = null;
            InputStream is = null;
            List<ServletContainerInitializer> detectedScis = null;
======= fetch "protected void processServletContainerInitializers(" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

                if ("jar".equals(url.getProtocol())) {
                    jar = JarFactory.newInstance(url);
                    is = jar.getInputStream(SCI_LOCATION);
                } else if ("file".equals(url.getProtocol())) {
                    String path = url.getPath();
                    File file = new File(path, SCI_LOCATION);
                    if (file.exists()) {
                        is = new FileInputStream(file);
                    }
                }
                if (is != null) {
                    detectedScis = getServletContainerInitializers(is);
                }
            } catch (IOException ioe) {
                log.error(sm.getString(
                        "contextConfig.servletContainerInitializerFail", url,
                        context.getName()));
                ok = false;
                return;
            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException e) {
                        // Ignore
                    }
                }
                if (jar != null) {
                    jar.close();
======= fetch "protected void processServletContainerInitializers(" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

                continue;
======= fetch "protected void processServletContainerInitializers(" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

            if (detectedScis == null) {
======= fetch "protected void processServletContainerInitializers(" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

            for (ServletContainerInitializer sci : detectedScis) {
                initializerClassMap.put(sci, new HashSet<Class<?>>());
                HandlesTypes ht = null;
                try {
                    ht = sci.getClass().getAnnotation(HandlesTypes.class);
                } catch (Exception e) {
                    if (log.isDebugEnabled()) {
                        log.info(sm.getString("contextConfig.sci.debug", url),
                                e);
                    } else {
                        log.info(sm.getString("contextConfig.sci.info", url));
                    }
                }
                if (ht != null) {
                    Class<?>[] types = ht.value();
                    if (types != null) {
                        for (Class<?> type : types) {
                            if (type.isAnnotation()) {
                                handlesTypesAnnotations = true;
                            } else {
                                handlesTypesNonAnnotations = true;
                            }
                            Set<ServletContainerInitializer> scis = typeInitializerMap
                                    .get(type);
                            if (scis == null) {
                                scis = new HashSet<>();
                                typeInitializerMap.put(type, scis);
                            }
                            scis.add(sci);
                        }
                    }
                }
======= fetch "protected void processServletContainerInitializers(" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

        }
    }
======= fetch "protected void processServletContainerInitializers(" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

    /**
     * Extract the name of the ServletContainerInitializer.
     *
     * @param is    The resource where the name is defined
     * @return      The class name
     * @throws IOException
     */
    protected List<ServletContainerInitializer> getServletContainerInitializers(
            InputStream is) throws IOException {
        List<ServletContainerInitializer> initializers = new ArrayList<>();
        if (is != null) {
            String line = null;
            try {
                BufferedReader br = new BufferedReader(new InputStreamReader(
                        is, "UTF-8"));
                while ((line = br.readLine()) != null) {
                    line = line.trim();
                    if (line.length() > 0) {
                        int i = line.indexOf('#');
                        if (i > -1) {
                            if (i == 0) {
                                continue;
                            }
                            line = line.substring(0, i).trim();
                        }
                        initializers.add(getServletContainerInitializer(line));
                    }
======= fetch "protected void processServletContainerInitializers(" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

            } catch (UnsupportedEncodingException e) {
                // Should never happen with UTF-8
                // If it does - ignore & return null
======= fetch "protected void processServletContainerInitializers(" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

        return initializers;
    }
    protected ServletContainerInitializer getServletContainerInitializer(
            String className) throws IOException {
        ServletContainerInitializer sci = null;
        try {
            Class<?> clazz = Class.forName(className, true, context.getLoader()
                    .getClassLoader());
            sci = (ServletContainerInitializer) clazz.newInstance();
        } catch (ClassNotFoundException e) {
            log.error(sm.getString("contextConfig.invalidSci", className), e);
            throw new IOException(e);
        } catch (InstantiationException e) {
            log.error(sm.getString("contextConfig.invalidSci", className), e);
            throw new IOException(e);
        } catch (IllegalAccessException e) {
            log.error(sm.getString("contextConfig.invalidSci", className), e);
            throw new IOException(e);
        }
        return sci;
======= fetch "protected ServletContainerInitializer getServletContainerInitializer(" 6e514c0^:"java/org/apache/catalina/startup/ContextConfig.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * A variation of Java's JAR ServiceLoader that respects exclusion rules for web applications.
 * <p/>
 * Primarily intended for use loading ServletContainerInitializers as defined by Servlet 8.2.4.
 * This implementation does not attempt lazy loading as the container is required to
 * introspect all implementations discovered.
 * <p/>
 * If the ServletContext defines ORDERED_LIBS, then only JARs in WEB-INF/lib
 * that are named in that set will be included in the search for
 * provider configuration files; if ORDERED_LIBS is not defined then
 * all JARs will be searched for provider configuration files. Providers
 * defined by resources in the parent ClassLoader will always be returned.
 * <p/>
 * Provider classes will be loaded using the context's ClassLoader.
 *
 * @see javax.servlet.ServletContainerInitializer
 * @see java.util.ServiceLoader
 */
    private static final String LIB = "/WEB-INF/lib/";
    private static final String SERVICES = "META-INF/services/";
    private static final Charset UTF8 = Charset.forName("UTF-8");
    private final ServletContext context;
    /**
     * Construct a loader to load services from a ServletContext.
     *
     * @param context the context to use
     */
    public WebappServiceLoader(ServletContext context) {
        this.context = context;
    }
    /**
     * Load the providers for a service type.
     *
     * @param serviceType the type of service to load
     * @return an unmodifiable collection of service providers
     * @throws IOException if there was a problem loading any service
     */
    public Collection<T> load(Class<T> serviceType) throws IOException {
        String configFile = SERVICES + serviceType.getName();
        Set<String> servicesFound = new HashSet<>();
        ClassLoader loader = context.getClassLoader();
        // if the ServletContext has ORDERED_LIBS, then use that to specify the
        // set of JARs from WEB-INF/lib that should be used for loading services
        @SuppressWarnings("unchecked")
        List<String> orderedLibs = (List<String>) context.getAttribute(ServletContext.ORDERED_LIBS);
        if (orderedLibs != null) {
            // handle ordered libs directly, ...
            for (String lib : orderedLibs) {
                URL jarUrl = context.getResource(LIB + lib);
                if (jarUrl == null) {
                    // should not happen, just ignore
                    continue;
                }
                String base = jarUrl.toExternalForm();
                URL url;
                if (base.endsWith("/")) {
                    url = new URL(base + configFile);
                } else {
                    url = new URL("jar:" + base + "!/" + configFile);
                }
                try {
                    parseConfigFile(servicesFound, url);
                } catch (FileNotFoundException e) {
                    // no provider file found, this is OK
                }
            }
            // and the parent ClassLoader for all others
            loader = loader.getParent();
        }
        Enumeration<URL> resources;
        if (loader == null) {
            resources = ClassLoader.getSystemResources(configFile);
        } else {
            resources = loader.getResources(configFile);
        }
        while (resources.hasMoreElements()) {
            parseConfigFile(servicesFound, resources.nextElement());
        }
        // load the discovered services
        if (servicesFound.isEmpty()) {
            return Collections.emptyList();
        }
        return loadServices(serviceType, servicesFound);
    }
    private void parseConfigFile(Set<String> servicesFound, URL url) throws IOException {
        try (InputStream is = url.openStream()) {
            BufferedReader reader = new BufferedReader(new InputStreamReader(is, UTF8));
            String line;
            while ((line = reader.readLine()) != null) {
                int i = line.indexOf('#');
                if (i >= 0) {
                    line = line.substring(0, i);
                }
                line = line.trim();
                if (line.length() == 0) {
                    continue;
                }
                if (servicesFound.contains(line)) {
                    continue;
                }
                servicesFound.add(line);
            }
        }
    }
    private Collection<T> loadServices(Class<T> serviceType, Set<String> servicesFound) throws IOException {
        ClassLoader loader = context.getClassLoader();
        List<T> services = new ArrayList<>(servicesFound.size());
        for (String serviceClass : servicesFound) {
            try {
                Class<?> clazz = Class.forName(serviceClass, true, loader);
                services.add(serviceType.cast(clazz.newInstance()));
            } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | ClassCastException e) {
                throw new IOException(e);
            }
        }
        return Collections.unmodifiableCollection(services);
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testWebapp() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-fragments-empty-absolute-ordering");
        StandardContext ctxt = (StandardContext) tomcat.addContext(null, "/test", appDir.getAbsolutePath());
        ctxt.addLifecycleListener(new ContextConfig());
        tomcat.start();
        WebappServiceLoader<ServletContainerInitializer> loader =
                new WebappServiceLoader<>(ctxt.getServletContext());
        Collection<ServletContainerInitializer> initializers = loader.load(ServletContainerInitializer.class);
    }

======= fetch "protected void output(byte[] src, int offset, int length)" 11bf498^:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

        long writeTimeout = att.getTimeout();
======= fetch "private synchronized int writeToSocket(ByteBuffer bytebuffer, boolean block, boo" 11bf498^:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

        long writeTimeout = att.getTimeout();
======= fetch "private int doWriteInternal (boolean block, byte[] b, int off, int len)" 11bf498^:"java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java"

        long writeTimeout = att.getTimeout();
======= fetch "protected void doFlush() throws IOException {" 11bf498^:"java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java"

        long writeTimeout = att.getTimeout();
======= fetch "public void reset(Poller poller, NioChannel channel, long soTimeout) {" 11bf498^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

            setWriteTimeout(soTimeout);
======= fetch "protected void awaitLatch(CountDownLatch latch, long timeout, TimeUnit unit) thr" 11bf498^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        public void setWriteTimeout(long writeTimeout) {
            this.writeTimeout = writeTimeout;
        }
        public long getWriteTimeout() {return this.writeTimeout;}
======= fetch "protected void awaitLatch(CountDownLatch latch, long timeout, TimeUnit unit) thr" 11bf498^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        private long writeTimeout = -1;

======= fetch "private void registerAuthenticatedSession(WsSession wsSession," ab6f21d^:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

        if (wsSession == null) {

======= fetch "public void setElIgnored(String elIgnored) {" 85f611e^:"java/org/apache/tomcat/util/descriptor/web/JspPropertyGroup.java"

    private final Set<String> includeCodas = new LinkedHashSet<>();
======= fetch "public void addIncludeCoda(String includeCoda) {" 85f611e^:"java/org/apache/tomcat/util/descriptor/web/JspPropertyGroup.java"

    public Set<String> getIncludeCodas() { return includeCodas; }
======= fetch "public void addIncludeCoda(String includeCoda) {" 85f611e^:"java/org/apache/tomcat/util/descriptor/web/JspPropertyGroup.java"

    private final Set<String> includePreludes = new LinkedHashSet<>();
======= fetch "public void addIncludePrelude(String includePrelude) {" 85f611e^:"java/org/apache/tomcat/util/descriptor/web/JspPropertyGroup.java"

    public Set<String> getIncludePreludes() { return includePreludes; }
======= fetch "public void testBug51584() throws Exception {" 85f611e^:"test/org/apache/jasper/compiler/TestCompiler.java"

    @Test
    public void testBug55262() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug55262.jsp");
        String result = res.toString();
        Pattern prelude = Pattern.compile(
                "(.*This is a prelude\\.){2}.*",
                Pattern.MULTILINE | Pattern.DOTALL);
        Pattern coda = Pattern.compile(
                "(.*This is a coda\\.){2}.*",
                Pattern.MULTILINE|Pattern.DOTALL);
        assertTrue(prelude.matcher(result).matches());
        assertTrue(coda.matcher(result).matches());
    }
======= fetch "public void testWebapp() throws Exception {" 85f611e^:"test/org/apache/jasper/servlet/TestJspCServletContext.java"

        Assert.assertEquals(1, propertyGroups.size());
        JspPropertyGroupDescriptor groupDescriptor =
                propertyGroups.iterator().next();
======= fetch "public void testWebapp() throws Exception {" 85f611e^:"test/org/apache/jasper/servlet/TestJspCServletContext.java"

        groupDescriptor = groupIterator.next();
        Assert.assertEquals(2, groupDescriptor.getIncludePreludes().size());
        Assert.assertEquals(2, groupDescriptor.getIncludeCodas().size());
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private JspPropertyGroup group = new JspPropertyGroup();
    @Test
    public void testBug55262() {
        group.addIncludePrelude("/prelude");
        group.addIncludePrelude("/prelude");
        group.addIncludeCoda("/coda");
        group.addIncludeCoda("/coda");
        Assert.assertEquals(2, group.getIncludePreludes().size());
        Assert.assertEquals(2, group.getIncludeCodas().size());
    }
    </jsp-property-group>
    <jsp-property-group>
      <url-pattern>/bug5nnnn/bug55262.jsp</url-pattern>
      <include-prelude>/bug5nnnn/bug55262-prelude.jspf</include-prelude>
      <include-prelude>/bug5nnnn/bug55262-prelude.jspf</include-prelude>
      <include-coda>/bug5nnnn/bug55262-coda.jspf</include-coda>
      <include-coda>/bug5nnnn/bug55262-coda.jspf</include-coda>
      <default-content-type>text/plain</default-content-type>
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  --%>
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  --%>
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  --%>

======= fetch "private void processWebDotXml() {" c6a45a6^:"java/org/apache/jasper/compiler/JspConfig.java"

            Vector<String> includePreludes = new Vector<>();
            includePreludes.addAll(jspPropertyGroup.getIncludePreludes());
            Vector<String> includeCodas = new Vector<>();
            includeCodas.addAll(jspPropertyGroup.getIncludeCodas());
            JspProperty property = new JspProperty(jspPropertyGroup.getIsXml(),
                    jspPropertyGroup.getElIgnored(),
                    jspPropertyGroup.getScriptingInvalid(),
                    jspPropertyGroup.getPageEncoding(),
                    includePreludes,
                    includeCodas,
                    jspPropertyGroup.getDeferredSyntaxAllowedAsLiteral(),
                    jspPropertyGroup.getTrimDirectiveWhitespaces(),
                    jspPropertyGroup.getDefaultContentType(),
                    jspPropertyGroup.getBuffer(),
                    jspPropertyGroup.getErrorOnUndeclaredNamespace());
======= fetch "private void processWebDotXml() {" c6a45a6^:"java/org/apache/jasper/compiler/JspConfig.java"

                Vector<String> includePreludes = new Vector<>();
                includePreludes.addAll(jspPropertyGroup.getIncludePreludes());
                Vector<String> includeCodas = new Vector<>();
                includeCodas.addAll(jspPropertyGroup.getIncludeCodas());
                JspProperty property = new JspProperty(jspPropertyGroup.getIsXml(),
                        jspPropertyGroup.getElIgnored(),
                        jspPropertyGroup.getScriptingInvalid(),
                        jspPropertyGroup.getPageEncoding(),
                        includePreludes,
                        includeCodas,
                        jspPropertyGroup.getDeferredSyntaxAllowedAsLiteral(),
                        jspPropertyGroup.getTrimDirectiveWhitespaces(),
                        jspPropertyGroup.getDefaultContentType(),
                        jspPropertyGroup.getBuffer(),
                        jspPropertyGroup.getErrorOnUndeclaredNamespace());

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private JspC jspc;
    private File outputDir;
    @Before
    public void init() {
        jspc = new JspC();
        outputDir = new File("output/jspc");
    }
    @Test
    public void precompileWebapp_2_2() throws IOException {
        File appDir = new File("test/webapp-2.2");
        File webappOut = new File(outputDir, appDir.getName());
        precompile(appDir, webappOut);
        verify(webappOut);
    }
    @Test
    public void precompileWebapp_2_3() throws IOException {
        File appDir = new File("test/webapp-2.3");
        File webappOut = new File(outputDir, appDir.getName());
        precompile(appDir, webappOut);
        verify(webappOut);
    }
    @Test
    public void precompileWebapp_2_4() throws IOException {
        File appDir = new File("test/webapp-2.4");
        File webappOut = new File(outputDir, appDir.getName());
        precompile(appDir, webappOut);
        verify(webappOut);
    }
    @Test
    public void precompileWebapp_2_5() throws IOException {
        File appDir = new File("test/webapp-2.5");
        File webappOut = new File(outputDir, appDir.getName());
        precompile(appDir, webappOut);
        verify(webappOut);
    }
    @Test
    public void precompileWebapp_3_0() throws IOException {
        File appDir = new File("test/webapp-3.0");
        File webappOut = new File(outputDir, appDir.getName());
        precompile(appDir, webappOut);
        verify(webappOut);
    }
    @Test
    public void precompileWebapp_3_1() throws IOException {
        File appDir = new File("test/webapp-3.1");
        File webappOut = new File(outputDir, appDir.getName());
        precompile(appDir, webappOut);
        verify(webappOut);
    }
    private void verify(File webappOut) {
        // for now, just check some expected files exist
        Assert.assertTrue(new File(webappOut, "generated_web.xml").exists());
        Assert.assertTrue(new File(webappOut,
                "org/apache/jsp/el_002das_002dliteral_jsp.java").exists());
        Assert.assertTrue(new File(webappOut,
                "org/apache/jsp/tld_002dversions_jsp.java").exists());
    }
    private void precompile(File appDir, File webappOut) throws IOException {
        remove(webappOut);
        webappOut.mkdirs();
        jspc.setUriroot(appDir.toString());
        jspc.setOutputDir(webappOut.toString());
        jspc.setValidateXml(false);
        jspc.setWebXml(new File(webappOut, "generated_web.xml").toString());
        jspc.execute();
    }
    private void remove(File base) throws IOException{
        if (!base.exists()) {
            return;
        }
        Files.walkFileTree(base.toPath(), new SimpleFileVisitor<Path>(){
            @Override
            public FileVisitResult visitFile(Path file,
                    BasicFileAttributes attrs) throws IOException {
                Files.delete(file);
                return FileVisitResult.CONTINUE;
            }
            @Override
            public FileVisitResult postVisitDirectory(Path dir,
                    IOException exc) throws IOException {
                Files.delete(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    }
      <add>
        Create test cases for JspC. Patch by Jeremy Boynes. (markt)
      </add>

======= fetch "protected void initServletContext() throws IOException, JasperException {" 186a782^:"java/org/apache/jasper/JspC.java"

        tldLocationsCache = TldLocationsCache.getInstance(context);

======= fetch "public JspCServletContext(PrintWriter aLogWriter, URL aResourceBaseURL)" 8d6537d^:"java/org/apache/jasper/servlet/JspCServletContext.java"

        // Use this class's classloader as Ant will have set the TCCL to its own
        webXmlParser.setClassLoader(getClass().getClassLoader());
======= fetch "public boolean parseWebXml(InputSource source, WebXml dest," 8d6537d^:"java/org/apache/tomcat/util/descriptor/web/WebXmlParser.java"

    /**
     * Sets the ClassLoader to be used for creating descriptor objects.
     * @param classLoader the ClassLoader to be used for creating descriptor objects
     */
    public void setClassLoader(ClassLoader classLoader) {
        webDigester.setClassLoader(classLoader);
        webFragmentDigester.setClassLoader(classLoader);
    }

    protected abstract Log getLog();
======= fetch "public final SocketState upgradeDispatch(SocketStatus status)" 68f6f6f^:"java/org/apache/coyote/http11/upgrade/AbstractProcessor.java"

        } else if (status == SocketStatus.STOP) {
            try {
                upgradeServletInputStream.close();
            } catch (IOException ioe) {
                getLog().debug(sm.getString(
                        "abstractProcessor.isCloseFail", ioe));
            }
            try {
                upgradeServletOutputStream.close();
            } catch (IOException ioe) {
                getLog().debug(sm.getString(
                        "abstractProcessor.osCloseFail", ioe));
            }
            return SocketState.CLOSED;
    private static final Log log = LogFactory.getLog(AprProcessor.class);
    @Override
    protected Log getLog() {return log;}
    private static final Log log = LogFactory.getLog(BioProcessor.class);
    @Override
    protected Log getLog() {return log;}
    private static final Log log = LogFactory.getLog(NioProcessor.class);
    @Override
    protected Log getLog() {return log;}
======= fetch "private void doRun(SelectionKey key, KeyAttachment ka) {" 68f6f6f^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                        if (socket.isHandshakeComplete()) {
======= fetch "private void doRun(SelectionKey key, KeyAttachment ka) {" 68f6f6f^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                    // Suppress null warnings for key in this block since
                    // key can't be null in this block

======= fetch "protected void onTimeout() {" 4758796^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

        clearHandler(new SocketTimeoutException());
======= fetch "private void clearHandler(Throwable t) {" 4758796^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

        if (t == null) {
            sh.onResult(new SendResult());
        } else {
            sh.onResult(new SendResult(t));

======= fetch "private void prepareResponse() {" 95ee699^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        // Add date header
        headers.setValue("Date").setString(FastHttpDateFormat.getCurrentDate());

======= fetch "public void startElement(" 6c54031^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        String currentPrefix = getPrefix(current.getQName());
======= fetch "public void startElement(" 6c54031^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        if (JSP_URI.equals(uri) && TEXT_ACTION.equals(current.getLocalName())
                && "jsp".equals(currentPrefix)) {
  <a href="#" onclick="window.alert(&quot;${'foo'}&quot;)">foo</a>
  <a href="#" onclick="window.alert(&quot;bar&quot;)">bar</a>

======= fetch "private void processWebDotXml() {" c8376e8^:"java/org/apache/jasper/compiler/JspConfig.java"

        if (ctxt.getMajorVersion() < 2) {
======= fetch "private void processWebDotXml() {" c8376e8^:"java/org/apache/jasper/compiler/JspConfig.java"

        if (ctxt.getMajorVersion() == 2) {
            if (ctxt.getMinorVersion() < 5) {
======= fetch "private void processWebDotXml() {" c8376e8^:"java/org/apache/jasper/compiler/JspConfig.java"

            if (ctxt.getMinorVersion() < 4) {

======= fetch "public boolean isServlet22() {" aa7896b^:"java/org/apache/catalina/core/StandardContext.java"

        if (this.publicId == null)
            return (false);
        if (this.publicId.equals
            (org.apache.catalina.startup.Constants.WebDtdPublicId_22))
            return (true);
        else
            return (false);
======= fetch "public boolean isServlet22() {" aa7896b^:"java/org/apache/catalina/core/StandardContext.java"

======= fetch "public void setVersion(String version) {" aa7896b^:"java/org/apache/tomcat/util/descriptor/web/WebXml.java"

        if (version == null) return;
        // Update major and minor version
        // Expected format is n.n - allow for any number of digits just in case
        String major = null;
        String minor = null;
        int split = version.indexOf('.');
        if (split < 0) {
            // Major only
            major = version;
        } else {
            major = version.substring(0, split);
            minor = version.substring(split + 1);
        }
        if (major == null || major.length() == 0) {
            majorVersion = 0;
        } else {
            try {
                majorVersion = Integer.parseInt(major);
            } catch (NumberFormatException nfe) {
                log.warn(sm.getString("webXml.version.nfe", major, version),
                        nfe);
                majorVersion = 0;
            }
======= fetch "public void setVersion(String version) {" aa7896b^:"java/org/apache/tomcat/util/descriptor/web/WebXml.java"

        if (minor == null || minor.length() == 0) {
            minorVersion = 0;
        } else {
            try {
                minorVersion = Integer.parseInt(minor);
            } catch (NumberFormatException nfe) {
                log.warn(sm.getString("webXml.version.nfe", minor, version),
                        nfe);
======= fetch "public void setVersion(String version) {" aa7896b^:"java/org/apache/tomcat/util/descriptor/web/WebXml.java"

            }
======= fetch "public void setVersion(String version) {" aa7896b^:"java/org/apache/tomcat/util/descriptor/web/WebXml.java"

======= fetch "public void setPublicId(String publicId) {" aa7896b^:"java/org/apache/tomcat/util/descriptor/web/WebXml.java"

            // skip
        } else if (org.apache.catalina.startup.Constants.WebSchemaPublicId_31.
                equalsIgnoreCase(publicId) ||
                org.apache.catalina.startup.Constants.WebFragmentSchemaPublicId_31.
                equalsIgnoreCase(publicId)) {
            majorVersion = 3;
            minorVersion = 1;
            this.publicId = publicId;
        } else if (org.apache.catalina.startup.Constants.WebSchemaPublicId_30.
                equalsIgnoreCase(publicId) ||
                org.apache.catalina.startup.Constants.WebFragmentSchemaPublicId_30.
                equalsIgnoreCase(publicId)) {
            majorVersion = 3;
            minorVersion = 0;
            this.publicId = publicId;
        } else if (org.apache.catalina.startup.Constants.WebSchemaPublicId_25.
                equalsIgnoreCase(publicId)) {
            majorVersion = 2;
            minorVersion = 5;
            this.publicId = publicId;
        } else if (org.apache.catalina.startup.Constants.WebSchemaPublicId_24.
                equalsIgnoreCase(publicId)) {
            majorVersion = 2;
            minorVersion = 4;
            this.publicId = publicId;
        } else if (org.apache.catalina.startup.Constants.WebDtdPublicId_23.
                equalsIgnoreCase(publicId)) {
            majorVersion = 2;
            minorVersion = 3;
            this.publicId = publicId;
        } else if (org.apache.catalina.startup.Constants.WebDtdPublicId_22.
                equalsIgnoreCase(publicId)) {
            majorVersion = 2;
            minorVersion = 2;
            this.publicId = publicId;
        } else if ("datatypes".equals(publicId)) {
            // Will occur when validation is enabled and dependencies are
            // traced back. Ignore it.
        } else {
            // Unrecognised publicId
            log.warn(sm.getString("webXml.unrecognisedPublicId", publicId));
======= fetch "public XMLReader getXMLReader() throws SAXException {" aa7896b^:"java/org/apache/tomcat/util/digester/Digester.java"

        reader.setProperty(
                "http://xml.org/sax/properties/lexical-handler", this);
======= fetch "public EntityResolver getEntityResolver(){" aa7896b^:"java/org/apache/tomcat/util/digester/Digester.java"

    /**
     * Resolve the requested external entity.
     *
     * @param publicId The public identifier of the entity being referenced
     * @param systemId The system identifier of the entity being referenced
     *
     * @exception SAXException if a parsing exception occurs
     *
     */
======= fetch "public EntityResolver getEntityResolver(){" aa7896b^:"java/org/apache/tomcat/util/digester/Digester.java"

    public InputSource resolveEntity(String publicId, String systemId)
            throws SAXException {
======= fetch "public InputSource resolveEntity(String publicId, String systemId)" aa7896b^:"java/org/apache/tomcat/util/digester/Digester.java"

            saxLog.debug("resolveEntity('" + publicId + "', '" + systemId + "')");
======= fetch "public InputSource resolveEntity(String publicId, String systemId)" aa7896b^:"java/org/apache/tomcat/util/digester/Digester.java"

        if (publicId != null)
            this.publicId = publicId;
======= fetch "public InputSource resolveEntity(String publicId, String systemId)" aa7896b^:"java/org/apache/tomcat/util/digester/Digester.java"

                    log.debug(" Trying to resolve using system ID '" + systemId + "'");
======= fetch "public InputSource resolveEntity(String publicId, String systemId)" aa7896b^:"java/org/apache/tomcat/util/digester/Digester.java"

                // resolve systemId against baseURI if it is not absolute
                if (baseURI != null) {
                    try {
                        URI uri = new URI(systemId);
                        if (!uri.isAbsolute()) {
                            entityURL = new URI(baseURI).resolve(uri).toString();
                        }
                    } catch (URISyntaxException e) {
                        if (log.isDebugEnabled()) {
                            log.debug("Invalid URI '" + baseURI + "' or '" +
                                    systemId + "'");
                        }
                    }
                }
======= fetch "public InputSource resolveEntity(String publicId, String systemId)" aa7896b^:"java/org/apache/tomcat/util/digester/Digester.java"

    // ------------------------------------------------- ErrorHandler Methods
======= fetch "public InputSource resolveEntity(String publicId, String systemId)" aa7896b^:"java/org/apache/tomcat/util/digester/Digester.java"

    @Override
    public void startDTD(String name, String publicId, String systemId)
            throws SAXException {
        setPublicId(publicId);
    }
    // ------------------------------------------------- ErrorHandler Methods
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testWebapp() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp/WEB-INF/web.xml"));
        Assert.assertEquals("3.1", desc.getVersion());
    }
    @Test
    public void testWebapp_2_2() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp-2.2/WEB-INF/web.xml"));
        Assert.assertEquals("2.2", desc.getVersion());
        Assert.assertEquals(XmlIdentifiers.WEB_22_PUBLIC, desc.getPublicId());
    }
    @Test
    public void testWebapp_2_3() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp-2.3/WEB-INF/web.xml"));
        Assert.assertEquals("2.3", desc.getVersion());
        Assert.assertEquals(XmlIdentifiers.WEB_23_PUBLIC, desc.getPublicId());
    }
    @Test
    public void testWebapp_2_4() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp-2.4/WEB-INF/web.xml"));
        Assert.assertEquals("2.4", desc.getVersion());
    }
    @Test
    public void testWebapp_2_5() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp-2.5/WEB-INF/web.xml"));
        Assert.assertEquals("2.5", desc.getVersion());
    }
    @Test
    public void testWebapp_3_0() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp-3.0/WEB-INF/web.xml"));
        Assert.assertEquals("3.0", desc.getVersion());
    }
    @Test
    public void testWebapp_3_1() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp-3.1/WEB-INF/web.xml"));
        Assert.assertEquals("3.1", desc.getVersion());
    }
======= fetch "public void testParseVersion() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        // Reset
======= fetch "public void testParseVersion() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        Assert.assertEquals(0, webxml.getMajorVersion());
        Assert.assertEquals(0, webxml.getMinorVersion());
======= fetch "public void testParseVersion() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        Assert.assertEquals(0, webxml.getMajorVersion());
        Assert.assertEquals(0, webxml.getMinorVersion());
        // major only
        webxml.setVersion("3");
        Assert.assertEquals(3, webxml.getMajorVersion());
        Assert.assertEquals(0, webxml.getMinorVersion());
        // no minor digit
        webxml.setVersion("0.0");   // reset
        webxml.setVersion("3.");
        Assert.assertEquals(3, webxml.getMajorVersion());
        Assert.assertEquals(0, webxml.getMinorVersion());
        // minor only
        webxml.setVersion("0.0");   // reset
        webxml.setVersion(".5");
        Assert.assertEquals(0, webxml.getMajorVersion());
        Assert.assertEquals(5, webxml.getMinorVersion());
        // leading & training zeros
        webxml.setVersion("0.0");   // reset
        webxml.setVersion("002.500");
======= fetch "public void testParseVersion() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        Assert.assertEquals(500, webxml.getMinorVersion());
======= fetch "public void testParsePublicIdVersion22() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        webxml.setPublicId(
                org.apache.catalina.startup.Constants.WebDtdPublicId_22);
======= fetch "public void testParsePublicIdVersion23() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        webxml.setPublicId(
                org.apache.catalina.startup.Constants.WebDtdPublicId_23);
======= fetch "public void testParsePublicIdVersion23() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

    public void testParsePublicIdVersion24() {
======= fetch "public void testParsePublicIdVersion24() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        webxml.setPublicId(
                org.apache.catalina.startup.Constants.WebSchemaPublicId_24);
======= fetch "public void testParsePublicIdVersion24() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

    public void testParsePublicIdVersion25() {
======= fetch "public void testParsePublicIdVersion25() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        webxml.setPublicId(
                org.apache.catalina.startup.Constants.WebSchemaPublicId_25);
======= fetch "public void testParsePublicIdVersion25() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

    public void testParsePublicIdVersion30() {
======= fetch "public void testParsePublicIdVersion30() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        webxml.setPublicId(
                org.apache.catalina.startup.Constants.WebSchemaPublicId_30);
======= fetch "public void testParsePublicIdVersion30() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

    public void testParsePublicIdVersion31() {
======= fetch "public void testParsePublicIdVersion31() {" aa7896b^:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        webxml.setPublicId(
                org.apache.catalina.startup.Constants.WebSchemaPublicId_31);

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * A resolver for locally cached XML resources.
 */
    private final Class<?> base;
    private final Map<String,String> publicIds;
    private final Map<String,String> systemIds;
    /**
     * Constructor providing mappings of public and system identifiers to local
     * resources. Each map contains a mapping from a well-known identifier to a
     * resource path that will be further resolved using the base Class using
     * Class#getResource(String).
     *
     * @param base the class to use to locate local copies
     * @param publicIds mapping of public identifiers to local resources
     * @param systemIds mapping of system identifiers to local resources
     */
    public LocalResolver(Class<?> base, Map<String,String> publicIds,
            Map<String,String> systemIds) {
        this.base = base;
        this.publicIds = publicIds;
        this.systemIds = systemIds;
    }
    @Override
    public InputSource resolveEntity(String publicId, String systemId)
            throws SAXException, IOException {
        return resolveEntity(null, publicId, null, systemId);
    }
    @Override
    public InputSource resolveEntity(String name, String publicId,
            String baseURI, String systemId) throws SAXException, IOException {
        String resolved = resolve(publicId, systemId, baseURI);
        if (resolved == null) {
            return null;
        }
        URL url = base.getResource(resolved);
        if (url != null) {
            resolved = url.toExternalForm();
        }
        InputSource is = new InputSource(resolved);
        is.setPublicId(publicId);
        return is;
    }
    @Override
    public InputSource getExternalSubset(String name, String baseURI)
            throws SAXException, IOException {
        return null;
    }
    private String resolve(String publicId, String systemId, String baseURI) {
        // try resolving using the publicId
        String resolved = publicIds.get(publicId);
        if (resolved != null) {
            return resolved;
        }
        // try resolving using the systemId
        if (systemId == null) {
            return null;
        }
        systemId = resolve(baseURI, systemId);
        resolved = systemIds.get(systemId);
        if (resolved != null) {
            return resolved;
        }
        // fall back to the supplied systemId
        return systemId;
    }
    private static String resolve(String baseURI, String systemId) {
        try {
            if (baseURI == null) {
                return systemId;
            }
            URI systemUri = new URI(systemId);
            if (systemUri.isAbsolute()) {
                return systemId;
            }
            return new URI(baseURI).resolve(systemUri).toString();
        } catch (URISyntaxException e) {
            return systemId;
        }
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Defines constants for well-known Public and System identifiers documented by
 * the Servlet and JSP specifications.
 */
    // from W3C
    public static final String XML_2001_XSD = "http://www.w3.org/2001/xml.xsd";
    public static final String DATATYPES_PUBLIC = "datatypes";
    public static final String XSD_10_PUBLIC =
            "-//W3C//DTD XMLSCHEMA 200102//EN";
    // from J2EE 1.2
    public static final String WEB_22_PUBLIC =
            "-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN";
    public static final String WEB_22_SYSTEM =
            "http://java.sun.com/dtd/web-app_2_2.dtd";
    public static final String TLD_11_PUBLIC =
            "-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.1//EN";
    public static final String TLD_11_SYSTEM =
            "http://java.sun.com/dtd/web-jsptaglibrary_1_1.dtd";
    // from J2EE 1.3
    public static final String WEB_23_PUBLIC =
            "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN";
    public static final String WEB_23_SYSTEM =
            "http://java.sun.com/dtd/web-app_2_3.dtd";
    public static final String TLD_12_PUBLIC =
            "-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN";
    public static final String TLD_12_SYSTEM =
            "http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd";
    // from J2EE 1.4
    public static final String WEB_24_XSD =
            "http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd";
    public static final String TLD_20_XSD =
            "http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd";
    public static final String WEBSERVICES_11_XSD =
            "http://www.ibm.com/webservices/xsd/j2ee_web_services_1_1.xsd";
    // from JavaEE 5
    public static final String WEB_25_XSD =
            "http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd";
    public static final String TLD_21_XSD =
            "http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd";
    public static final String WEBSERVICES_12_XSD =
            "http://java.sun.com/xml/ns/javaee/javaee_web_services_1_2.xsd";
    // from JavaEE 6
    public static final String WEB_30_XSD =
            "http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd";
    public static final String WEB_FRAGMENT_30_XSD =
            "http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd";
    public static final String WEBSERVICES_13_XSD =
            "http://java.sun.com/xml/ns/javaee/javaee_web_services_1_3.xsd";
    // from JavaEE 7
    public static final String WEB_31_XSD =
            "http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd";
    public static final String WEB_FRAGMENT_31_XSD =
            "http://xmlns.jcp.org/xml/ns/javaee/web-fragment_3_1.xsd";
    public static final String WEBSERVICES_14_XSD =
            "http://xmlns.jcp.org/xml/ns/javaee/javaee_web_services_1_4.xsd";
    private XmlIdentifiers() {
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private final Map<String, String> publicIds = new HashMap<>();
    private final Map<String, String> systemIds = new HashMap<>();
    private LocalResolver resolver =
            new LocalResolver(ServletContext.class, publicIds, systemIds);
    private String WEB_22_LOCAL;
    private String WEB_31_LOCAL;
    private String WEBCOMMON_31_LOCAL;
    @Before
    public void init() {
        publicIds.put(XmlIdentifiers.WEB_22_PUBLIC,
                "/javax/servlet/resources/web-app_2_2.dtd");
        systemIds.put(XmlIdentifiers.WEB_31_XSD,
                "/javax/servlet/resources/web-app_3_1.xsd");
        WEB_22_LOCAL = getClass().getResource(
                "/javax/servlet/resources/web-app_2_2.dtd").toExternalForm();
        WEB_31_LOCAL = getClass().getResource(
                "/javax/servlet/resources/web-app_3_1.xsd").toExternalForm();
        WEBCOMMON_31_LOCAL = getClass().getResource(
                "/javax/servlet/resources/web-common_3_1.xsd").toExternalForm();
    }
    @Test
    public void unknownNullIdIsNull() throws IOException, SAXException {
        Assert.assertNull(resolver.resolveEntity(null, null));
    }
    @Test
    public void unknownPublicIdIsNull() throws IOException, SAXException {
        Assert.assertNull(resolver.resolveEntity("unknown", null));
    }
    @Test
    public void unknownSystemIdIsReturned() throws IOException, SAXException {
        InputSource source = resolver.resolveEntity(null, "unknown");
        Assert.assertEquals(null, source.getPublicId());
        Assert.assertEquals("unknown", source.getSystemId());
    }
    @Test
    public void unknownSystemIdIsResolvedAgainstBaseURI()
            throws IOException, SAXException {
        InputSource source = resolver.resolveEntity(
                null, null, "http://example.com/home.html", "unknown");
        Assert.assertEquals(null, source.getPublicId());
        Assert.assertEquals("http://example.com/unknown", source.getSystemId());
    }
    @Test
    public void publicIdIsResolved() throws IOException, SAXException {
        InputSource source = resolver.resolveEntity(
                XmlIdentifiers.WEB_22_PUBLIC, XmlIdentifiers.WEB_22_SYSTEM);
        Assert.assertEquals(XmlIdentifiers.WEB_22_PUBLIC, source.getPublicId());
        Assert.assertEquals(WEB_22_LOCAL, source.getSystemId());
    }
    @Test
    public void systemIdIsIgnoredWhenPublicIdIsResolved()
            throws IOException, SAXException {
        InputSource source = resolver.resolveEntity(
                XmlIdentifiers.WEB_22_PUBLIC, "unknown");
        Assert.assertEquals(XmlIdentifiers.WEB_22_PUBLIC, source.getPublicId());
        Assert.assertEquals(WEB_22_LOCAL, source.getSystemId());
    }
    @Test
    public void systemIdIsResolved() throws IOException, SAXException {
        InputSource source =
                resolver.resolveEntity(null, XmlIdentifiers.WEB_31_XSD);
        Assert.assertEquals(null, source.getPublicId());
        Assert.assertEquals(WEB_31_LOCAL, source.getSystemId());
    }
    @Test
    public void relativeSystemIdIsResolvedAgainstBaseURI()
            throws IOException, SAXException {
        InputSource source = resolver.resolveEntity(
                null, null, WEB_31_LOCAL, "web-common_3_1.xsd");
        Assert.assertEquals(null, source.getPublicId());
        Assert.assertEquals(WEBCOMMON_31_LOCAL, source.getSystemId());
    }
    @Test
    public void absoluteSystemIdOverridesBaseURI()
            throws IOException, SAXException {
        InputSource source = resolver.resolveEntity(null, null,
                "http://example.com/home.html", XmlIdentifiers.WEB_31_XSD);
        Assert.assertEquals(null, source.getPublicId());
        Assert.assertEquals(WEB_31_LOCAL, source.getSystemId());
    }

      manifest="${tomcat.manifests}/jsp-api.jar.manifest"
      notice="${tomcat.manifests}/jsp-api.jar.notice"
      license="${tomcat.manifests}/jsp-api.jar.license" />
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
            targetNamespace="http://java.sun.com/xml/ns/j2ee"
            xmlns:j2ee="http://java.sun.com/xml/ns/j2ee"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            version="2.0">
  <xsd:annotation>
    <xsd:documentation>
      @(#)jsp_2_0.xsds  1.17 03/18/03
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      This is the XML Schema for the JSP 2.0 deployment descriptor
      types.  The JSP 2.0 schema contains all the special
      structures and datatypes that are necessary to use JSP files
      from a web application.
      The contents of this schema is used by the web-app_2_4.xsd
      file to define JSP specific content.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      The following conventions apply to all J2EE
      deployment descriptor elements unless indicated otherwise.
      - In elements that specify a pathname to a file within the
        same JAR file, relative filenames (i.e., those not
        starting with "/") are considered relative to the root of
        the JAR file's namespace.  Absolute filenames (i.e., those
        starting with "/") also specify names in the root of the
        JAR file's namespace.  In general, relative names are
        preferred.  The exception is .war files where absolute
        names are preferred for consistency with the Servlet API.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:include schemaLocation="j2ee_1_4.xsd"/>
  <xsd:complexType name="jsp-configType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-configType is used to provide global configuration
        information for the JSP files in a web application. It has
        two subelements, taglib and jsp-property-group.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="taglib"
                   type="j2ee:taglibType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="jsp-property-group"
                   type="j2ee:jsp-property-groupType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="jsp-fileType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-file element contains the full path to a JSP file
        within the web application beginning with a `/'.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:restriction base="j2ee:pathType"/>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="jsp-property-groupType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-property-groupType is used to group a number of
        files so they can be given global property information.
        All files so described are deemed to be JSP files.  The
        following additional properties can be described:
            - Control whether EL is ignored
            - Control whether scripting elements are invalid
            - Indicate pageEncoding information.
            - Indicate that a resource is a JSP document (XML)
            - Prelude and Coda automatic includes.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="j2ee:descriptionGroup"/>
      <xsd:element name="url-pattern"
                   type="j2ee:url-patternType"
                   maxOccurs="unbounded"/>
      <xsd:element name="el-ignored"
                   type="j2ee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Can be used to easily set the isELIgnored
            property of a group of JSP pages.  By default, the
            EL evaluation is enabled for Web Applications using
            a Servlet 2.4 or greater web.xml, and disabled
            otherwise.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="page-encoding"
                   type="j2ee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of page-encoding are those of the
            pageEncoding page directive.  It is a
            translation-time error to name different encodings
            in the pageEncoding attribute of the page directive
            of a JSP page and in a JSP configuration element
            matching the page.  It is also a translation-time
            error to name different encodings in the prolog
            or text declaration of a document in XML syntax and
            in a JSP configuration element matching the document.
            It is legal to name the same encoding through
            mulitple mechanisms.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="scripting-invalid"
                   type="j2ee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Can be used to easily disable scripting in a
            group of JSP pages.  By default, scripting is
            enabled.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="is-xml"
                   type="j2ee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            If true, denotes that the group of resources
            that match the URL pattern are JSP documents,
            and thus must be interpreted as XML documents.
            If false, the resources are assumed to not
            be JSP documents, unless there is another
            property group that indicates otherwise.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="include-prelude"
                   type="j2ee:pathType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The include-prelude element is a context-relative
            path that must correspond to an element in the
            Web Application.  When the element is present,
            the given path will be automatically included (as
            in an include directive) at the beginning of each
            JSP page in this jsp-property-group.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="include-coda"
                   type="j2ee:pathType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The include-coda element is a context-relative
            path that must correspond to an element in the
            Web Application.  When the element is present,
            the given path will be automatically included (as
            in an include directive) at the end of each
            JSP page in this jsp-property-group.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="taglibType">
    <xsd:annotation>
      <xsd:documentation>
        The taglibType defines the syntax for declaring in
        the deployment descriptor that a tag library is
        available to the application.  This can be done
        to override implicit map entries from TLD files and
        from the container.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="taglib-uri"
                   type="j2ee:string">
        <xsd:annotation>
          <xsd:documentation>
            A taglib-uri element describes a URI identifying a
            tag library used in the web application.  The body
            of the taglib-uri element may be either an
            absolute URI specification, or a relative URI.
            There should be no entries in web.xml with the
            same taglib-uri value.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="taglib-location"
                   type="j2ee:pathType">
        <xsd:annotation>
          <xsd:documentation>
            the taglib-location element contains the location
            (as a resource relative to the root of the web
            application) where to find the Tag Library
            Description file for the tag library.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  **  The actual Sun XSD for this stripped down XSD can be found at
  **  http://java.sun.com/xml/ns/javaee/jsp_2_1.xsd
  **  This XSD contains only the functional elements for programatic use.
            targetNamespace="http://java.sun.com/xml/ns/javaee"
            xmlns:javaee="http://java.sun.com/xml/ns/javaee"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            version="2.1">
    <xsd:include schemaLocation="javaee_5.xsd" />
    <xsd:complexType name="jsp-configType">
        <xsd:sequence>
            <xsd:element name="taglib" type="javaee:taglibType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="jsp-property-group" type="javaee:jsp-property-groupType" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="jsp-fileType">
        <xsd:simpleContent>
            <xsd:restriction base="javaee:pathType" />
        </xsd:simpleContent>
    </xsd:complexType>
    <xsd:complexType name="jsp-property-groupType">
        <xsd:sequence>
            <xsd:group ref="javaee:descriptionGroup"/>
            <xsd:element name="url-pattern" type="javaee:url-patternType" maxOccurs="unbounded" />
            <xsd:element name="el-ignored" type="javaee:true-falseType" minOccurs="0" />
            <xsd:element name="page-encoding" type="javaee:string" minOccurs="0" />
            <xsd:element name="scripting-invalid" type="javaee:true-falseType" minOccurs="0" />
            <xsd:element name="is-xml" type="javaee:true-falseType" minOccurs="0" />
            <xsd:element name="include-prelude" type="javaee:pathType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="include-coda" type="javaee:pathType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="deferred-syntax-allowed-as-literal" type="javaee:true-falseType" minOccurs="0" />
            <xsd:element name="trim-directive-whitespaces" type="javaee:true-falseType" minOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="taglibType">
        <xsd:sequence>
            <xsd:element name="taglib-uri" type="javaee:string" />
            <xsd:element name="taglib-location" type="javaee:pathType" />
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
            targetNamespace="http://java.sun.com/xml/ns/javaee"
            xmlns:javaee="http://java.sun.com/xml/ns/javaee"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            version="2.2">
  <xsd:annotation>
    <xsd:documentation>
      $Id$
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
      Copyright 2003-2009 Sun Microsystems, Inc. All rights reserved.
      The contents of this file are subject to the terms of either the
      GNU General Public License Version 2 only ("GPL") or the Common
      Development and Distribution License("CDDL") (collectively, the
      "License").  You may not use this file except in compliance with
      the License. You can obtain a copy of the License at
      https://glassfish.dev.java.net/public/CDDL+GPL.html or
      glassfish/bootstrap/legal/LICENSE.txt.  See the License for the
      specific language governing permissions and limitations under the
      License.
      When distributing the software, include this License Header
      Notice in each file and include the License file at
      glassfish/bootstrap/legal/LICENSE.txt.  Sun designates this
      particular file as subject to the "Classpath" exception as
      provided by Sun in the GPL Version 2 section of the License file
      that accompanied this code.  If applicable, add the following
      below the License Header, with the fields enclosed by brackets []
      replaced by your own identifying information:
      "Portions Copyrighted [year] [name of copyright owner]"
      Contributor(s):
      If you wish your version of this file to be governed by only the
      CDDL or only the GPL Version 2, indicate your decision by adding
      "[Contributor] elects to include this software in this
      distribution under the [CDDL or GPL Version 2] license."  If you
      don't indicate a single choice of license, a recipient has the
      option to distribute your version of this file under either the
      CDDL, the GPL Version 2 or to extend the choice of license to its
      licensees as provided above.  However, if you add GPL Version 2
      code and therefore, elected the GPL Version 2 license, then the
      option applies only if the new code is made subject to such
      option by the copyright holder.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      The Apache Software Foundation elects to include this software under the
      CDDL license.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      This is the XML Schema for the JSP 2.2 deployment descriptor
      types.  The JSP 2.2 schema contains all the special
      structures and datatypes that are necessary to use JSP files
      from a web application.
      The contents of this schema is used by the web-common_3_0.xsd
      file to define JSP specific content.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      The following conventions apply to all Java EE
      deployment descriptor elements unless indicated otherwise.
      - In elements that specify a pathname to a file within the
      same JAR file, relative filenames (i.e., those not
      starting with "/") are considered relative to the root of
      the JAR file's namespace.  Absolute filenames (i.e., those
      starting with "/") also specify names in the root of the
      JAR file's namespace.  In general, relative names are
      preferred.  The exception is .war files where absolute
      names are preferred for consistency with the Servlet API.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:include schemaLocation="javaee_6.xsd"/>
  <xsd:complexType name="jsp-configType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-configType is used to provide global configuration
        information for the JSP files in a web application. It has
        two subelements, taglib and jsp-property-group.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="taglib"
                   type="javaee:taglibType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="jsp-property-group"
                   type="javaee:jsp-property-groupType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
    </xsd:sequence>
    <xsd:attribute name="id"
                   type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="jsp-fileType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-file element contains the full path to a JSP file
        within the web application beginning with a `/'.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:restriction base="javaee:pathType"/>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="jsp-property-groupType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-property-groupType is used to group a number of
        files so they can be given global property information.
        All files so described are deemed to be JSP files.  The
        following additional properties can be described:
        - Control whether EL is ignored.
        - Control whether scripting elements are invalid.
        - Indicate pageEncoding information.
        - Indicate that a resource is a JSP document (XML).
        - Prelude and Coda automatic includes.
        - Control whether the character sequence #{ is allowed
        when used as a String literal.
        - Control whether template text containing only
        whitespaces must be removed from the response output.
        - Indicate the default contentType information.
        - Indicate the default buffering model for JspWriter
        - Control whether error should be raised for the use of
        undeclared namespaces in a JSP page.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="javaee:descriptionGroup"/>
      <xsd:element name="url-pattern"
                   type="javaee:url-patternType"
                   maxOccurs="unbounded"/>
      <xsd:element name="el-ignored"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Can be used to easily set the isELIgnored
            property of a group of JSP pages.  By default, the
            EL evaluation is enabled for Web Applications using
            a Servlet 2.4 or greater web.xml, and disabled
            otherwise.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="page-encoding"
                   type="javaee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of page-encoding are those of the
            pageEncoding page directive.  It is a
            translation-time error to name different encodings
            in the pageEncoding attribute of the page directive
            of a JSP page and in a JSP configuration element
            matching the page.  It is also a translation-time
            error to name different encodings in the prolog
            or text declaration of a document in XML syntax and
            in a JSP configuration element matching the document.
            It is legal to name the same encoding through
            mulitple mechanisms.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="scripting-invalid"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Can be used to easily disable scripting in a
            group of JSP pages.  By default, scripting is
            enabled.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="is-xml"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            If true, denotes that the group of resources
            that match the URL pattern are JSP documents,
            and thus must be interpreted as XML documents.
            If false, the resources are assumed to not
            be JSP documents, unless there is another
            property group that indicates otherwise.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="include-prelude"
                   type="javaee:pathType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The include-prelude element is a context-relative
            path that must correspond to an element in the
            Web Application.  When the element is present,
            the given path will be automatically included (as
            in an include directive) at the beginning of each
            JSP page in this jsp-property-group.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="include-coda"
                   type="javaee:pathType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The include-coda element is a context-relative
            path that must correspond to an element in the
            Web Application.  When the element is present,
            the given path will be automatically included (as
            in an include directive) at the end of each
            JSP page in this jsp-property-group.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="deferred-syntax-allowed-as-literal"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The character sequence #{ is reserved for EL expressions.
            Consequently, a translation error occurs if the #{
            character sequence is used as a String literal, unless
            this element is enabled (true). Disabled (false) by
            default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="trim-directive-whitespaces"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Indicates that template text containing only whitespaces
            must be removed from the response output. It has no
            effect on JSP documents (XML syntax). Disabled (false)
            by default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="default-content-type"
                   type="javaee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of default-content-type are those of the
            contentType page directive.  It specifies the default
            response contentType if the page directive does not include
            a contentType attribute.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="buffer"
                   type="javaee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of buffer are those of the
            buffer page directive.  It specifies if buffering should be
            used for the output to response, and if so, the size of the
            buffer to use.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="error-on-undeclared-namespace"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The default behavior when a tag with unknown namespace is used
            in a JSP page (regular syntax) is to silently ignore it.  If
            set to true, then an error must be raised during the translation
            time when an undeclared tag is used in a JSP page.  Disabled
            (false) by default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id"
                   type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="taglibType">
    <xsd:annotation>
      <xsd:documentation>
        The taglibType defines the syntax for declaring in
        the deployment descriptor that a tag library is
        available to the application.  This can be done
        to override implicit map entries from TLD files and
        from the container.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="taglib-uri"
                   type="javaee:string">
        <xsd:annotation>
          <xsd:documentation>
            A taglib-uri element describes a URI identifying a
            tag library used in the web application.  The body
            of the taglib-uri element may be either an
            absolute URI specification, or a relative URI.
            There should be no entries in web.xml with the
            same taglib-uri value.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="taglib-location"
                   type="javaee:pathType">
        <xsd:annotation>
          <xsd:documentation>
            the taglib-location element contains the location
            (as a resource relative to the root of the web
            application) where to find the Tag Library
            Description file for the tag library.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id"
                   type="xsd:ID"/>
  </xsd:complexType>
            targetNamespace="http://xmlns.jcp.org/xml/ns/javaee"
            xmlns:javaee="http://xmlns.jcp.org/xml/ns/javaee"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            version="2.3">
  <xsd:annotation>
    <xsd:documentation>
      DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
      Copyright (c) 2009-2013 Oracle and/or its affiliates. All rights reserved.
      The contents of this file are subject to the terms of either the GNU
      General Public License Version 2 only ("GPL") or the Common Development
      and Distribution License("CDDL") (collectively, the "License").  You
      may not use this file except in compliance with the License.  You can
      obtain a copy of the License at
      https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
      or packager/legal/LICENSE.txt.  See the License for the specific
      language governing permissions and limitations under the License.
      When distributing the software, include this License Header Notice in each
      file and include the License file at packager/legal/LICENSE.txt.
      GPL Classpath Exception:
      Oracle designates this particular file as subject to the "Classpath"
      exception as provided by Oracle in the GPL Version 2 section of the License
      file that accompanied this code.
      Modifications:
      If applicable, add the following below the License Header, with the fields
      enclosed by brackets [] replaced by your own identifying information:
      "Portions Copyright [year] [name of copyright owner]"
      Contributor(s):
      If you wish your version of this file to be governed by only the CDDL or
      only the GPL Version 2, indicate your decision by adding "[Contributor]
      elects to include this software in this distribution under the [CDDL or GPL
      Version 2] license."  If you don't indicate a single choice of license, a
      recipient has the option to distribute your version of this file under
      either the CDDL, the GPL Version 2 or to extend the choice of license to
      its licensees as provided above.  However, if you add GPL Version 2 code
      and therefore, elected the GPL Version 2 license, then the option applies
      only if the new code is made subject to such option by the copyright
      holder.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      The Apache Software Foundation elects to include this software under the
      CDDL license.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      This is the XML Schema for the JSP 2.3 deployment descriptor
      types.  The JSP 2.3 schema contains all the special
      structures and datatypes that are necessary to use JSP files
      from a web application.
      The contents of this schema is used by the web-common_3_1.xsd
      file to define JSP specific content.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      The following conventions apply to all Java EE
      deployment descriptor elements unless indicated otherwise.
      - In elements that specify a pathname to a file within the
      same JAR file, relative filenames (i.e., those not
      starting with "/") are considered relative to the root of
      the JAR file's namespace.  Absolute filenames (i.e., those
      starting with "/") also specify names in the root of the
      JAR file's namespace.  In general, relative names are
      preferred.  The exception is .war files where absolute
      names are preferred for consistency with the Servlet API.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:include schemaLocation="javaee_7.xsd"/>
  <xsd:complexType name="jsp-configType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-configType is used to provide global configuration
        information for the JSP files in a web application. It has
        two subelements, taglib and jsp-property-group.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="taglib"
                   type="javaee:taglibType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="jsp-property-group"
                   type="javaee:jsp-property-groupType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
    </xsd:sequence>
    <xsd:attribute name="id"
                   type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="jsp-fileType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-file element contains the full path to a JSP file
        within the web application beginning with a `/'.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:restriction base="javaee:pathType"/>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="jsp-property-groupType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-property-groupType is used to group a number of
        files so they can be given global property information.
        All files so described are deemed to be JSP files.  The
        following additional properties can be described:
        - Control whether EL is ignored.
        - Control whether scripting elements are invalid.
        - Indicate pageEncoding information.
        - Indicate that a resource is a JSP document (XML).
        - Prelude and Coda automatic includes.
        - Control whether the character sequence #{ is allowed
        when used as a String literal.
        - Control whether template text containing only
        whitespaces must be removed from the response output.
        - Indicate the default contentType information.
        - Indicate the default buffering model for JspWriter
        - Control whether error should be raised for the use of
        undeclared namespaces in a JSP page.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="javaee:descriptionGroup"/>
      <xsd:element name="url-pattern"
                   type="javaee:url-patternType"
                   maxOccurs="unbounded"/>
      <xsd:element name="el-ignored"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Can be used to easily set the isELIgnored
            property of a group of JSP pages.  By default, the
            EL evaluation is enabled for Web Applications using
            a Servlet 2.4 or greater web.xml, and disabled
            otherwise.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="page-encoding"
                   type="javaee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of page-encoding are those of the
            pageEncoding page directive.  It is a
            translation-time error to name different encodings
            in the pageEncoding attribute of the page directive
            of a JSP page and in a JSP configuration element
            matching the page.  It is also a translation-time
            error to name different encodings in the prolog
            or text declaration of a document in XML syntax and
            in a JSP configuration element matching the document.
            It is legal to name the same encoding through
            mulitple mechanisms.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="scripting-invalid"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Can be used to easily disable scripting in a
            group of JSP pages.  By default, scripting is
            enabled.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="is-xml"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            If true, denotes that the group of resources
            that match the URL pattern are JSP documents,
            and thus must be interpreted as XML documents.
            If false, the resources are assumed to not
            be JSP documents, unless there is another
            property group that indicates otherwise.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="include-prelude"
                   type="javaee:pathType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The include-prelude element is a context-relative
            path that must correspond to an element in the
            Web Application.  When the element is present,
            the given path will be automatically included (as
            in an include directive) at the beginning of each
            JSP page in this jsp-property-group.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="include-coda"
                   type="javaee:pathType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The include-coda element is a context-relative
            path that must correspond to an element in the
            Web Application.  When the element is present,
            the given path will be automatically included (as
            in an include directive) at the end of each
            JSP page in this jsp-property-group.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="deferred-syntax-allowed-as-literal"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The character sequence #{ is reserved for EL expressions.
            Consequently, a translation error occurs if the #{
            character sequence is used as a String literal, unless
            this element is enabled (true). Disabled (false) by
            default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="trim-directive-whitespaces"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Indicates that template text containing only whitespaces
            must be removed from the response output. It has no
            effect on JSP documents (XML syntax). Disabled (false)
            by default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="default-content-type"
                   type="javaee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of default-content-type are those of the
            contentType page directive.  It specifies the default
            response contentType if the page directive does not include
            a contentType attribute.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="buffer"
                   type="javaee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of buffer are those of the
            buffer page directive.  It specifies if buffering should be
            used for the output to response, and if so, the size of the
            buffer to use.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="error-on-undeclared-namespace"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The default behavior when a tag with unknown namespace is used
            in a JSP page (regular syntax) is to silently ignore it.  If
            set to true, then an error must be raised during the translation
            time when an undeclared tag is used in a JSP page.  Disabled
            (false) by default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id"
                   type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="taglibType">
    <xsd:annotation>
      <xsd:documentation>
        The taglibType defines the syntax for declaring in
        the deployment descriptor that a tag library is
        available to the application.  This can be done
        to override implicit map entries from TLD files and
        from the container.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="taglib-uri"
                   type="javaee:string">
        <xsd:annotation>
          <xsd:documentation>
            A taglib-uri element describes a URI identifying a
            tag library used in the web application.  The body
            of the taglib-uri element may be either an
            absolute URI specification, or a relative URI.
            There should be no entries in web.xml with the
            same taglib-uri value.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="taglib-location"
                   type="javaee:pathType">
        <xsd:annotation>
          <xsd:documentation>
            the taglib-location element contains the location
            (as a resource relative to the root of the web
            application) where to find the Tag Library
            Description file for the tag library.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id"
                   type="xsd:ID"/>
  </xsd:complexType>
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
   This is the DTD defining the JavaServer Pages 1.1 Tag Library
   descriptor (.tld) (XML) file format/syntax.
   A Tag Library is a JAR file containing a valid instance of a Tag Library
   Descriptor (taglib.tld) file in the META-INF subdirectory, along with the
   appropriate implementing classes, and other resources required to
   implement the tags defined therein.
   Use is subject to license terms.
  -->
            a JSP authoring tool to create names with a mnemonic
            value; for example, the it may be used as the prefered
            prefix value in taglib directives
            should be user discernable
          xmlns CDATA #FIXED
                "http://java.sun.com/j2ee/dtds/web-jsptaglibrary_1_1.dtd"
                implementation itself, and is most likely in a
                different "langage", e.g embedded SQL statements.
  by a scriptlet expression (optional)
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
   This is the DTD defining the JavaServer Pages 1.2 Tag Library
   descriptor (.tld) (XML) file format/syntax.
   A Tag Library is a JAR file containing a valid instance of a Tag Library
   Descriptor (taglib.tld) file in the META-INF subdirectory, along with the
   appropriate implementing classes, and other resources required to
   implement the tags defined therein.
   Use is subject to license terms.
  -->
          "-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN">
  <!DOCTYPE taglib
        PUBLIC "-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN"
        "http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd">
                a JSP authoring tool to create names with a mnemonic
                value; for example, the it may be used as the prefered
                prefix value in taglib directives
                is intended to be displayed by tools
                should be user discernable
                  display-name?, small-icon?, large-icon?, description?,
                  validator?, listener*, tag+) >
        xmlns CDATA #FIXED
        "http://java.sun.com/JSP/TagLibraryDescriptor"
                  javax.servlet.jsp.tagext.Tag
                  javax.servlet.jsp.tagext.TagExtraInfo
                  by tools
                  use of this tag
               small-icon?, large-icon?, description?, variable*, attribute*,
               example?) >
                implementation itself, and is most likely in a
                different "langage", e.g embedded SQL statements.
                         time) value will give the name of the
                         variable.  One of name-given or
                         name-from-attribute is required.
                         java.lang.String is default.
                         True is the default.
                         defined.  NESTED is default.
                    declare?, scope?, description?) >
  by a scriptlet expression (optional)
  by a scriptlet expression (optional)
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
     targetNamespace="http://java.sun.com/xml/ns/j2ee"
     xmlns:j2ee="http://java.sun.com/xml/ns/j2ee"
     xmlns:xsd="http://www.w3.org/2001/XMLSchema"
     xmlns:xml="http://www.w3.org/XML/1998/namespace"
     elementFormDefault="qualified"
     attributeFormDefault="unqualified"
     version="2.0">
  <xsd:annotation>
    <xsd:documentation>
      %W% %G%
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      <![CDATA[
        This is the XML Schema for the JSP Taglibrary
        descriptor.  All Taglibrary descriptors must
        indicate the tag library schema by using the Taglibrary
        namespace:
        http://java.sun.com/xml/ns/j2ee
        and by indicating the version of the schema by
        using the version element as shown below:
            <taglib xmlns="http://java.sun.com/xml/ns/j2ee"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="..."
              version="2.0">
              ...
            </taglib>
        The instance documents may indicate the published
        version of the schema using xsi:schemaLocation attribute
        for J2EE namespace with the following location:
        http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd
        ]]>
    </xsd:documentation>
  </xsd:annotation>
  <xsd:include schemaLocation="j2ee_1_4.xsd"/>
  <xsd:element name="taglib" type="j2ee:tldTaglibType">
    <xsd:annotation>
      <xsd:documentation>
        The taglib tag is the document root.
        The definition of taglib is provided
        by the tldTaglibType.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:unique name="tag-name-uniqueness">
      <xsd:annotation>
        <xsd:documentation>
          The taglib element contains, among other things, tag and
          tag-file elements.
          The name subelements of these elements must each be unique.
        </xsd:documentation>
      </xsd:annotation>
      <xsd:selector xpath="j2ee:tag|j2ee:tag-file"/>
      <xsd:field    xpath="j2ee:name"/>
    </xsd:unique>
    <xsd:unique name="function-name-uniqueness">
      <xsd:annotation>
        <xsd:documentation>
          The taglib element contains function elements.
          The name subelements of these elements must each be unique.
        </xsd:documentation>
      </xsd:annotation>
      <xsd:selector xpath="j2ee:function"/>
      <xsd:field    xpath="j2ee:name"/>
    </xsd:unique>
  </xsd:element>
  <xsd:complexType name="body-contentType">
    <xsd:annotation>
      <xsd:documentation>
        Specifies the type of body that is valid for a tag.
        This value is used by the JSP container to validate
        that a tag invocation has the correct body syntax and
        by page composition tools to assist the page author
        in providing a valid tag body.
        There are currently four values specified:
        tagdependent    The body of the tag is interpreted by the tag
                        implementation itself, and is most likely
                        in a different "language", e.g embedded SQL
                        statements.
        JSP             The body of the tag contains nested JSP
                        syntax.
        empty           The body must be empty
        scriptless      The body accepts only template text, EL
                        Expressions, and JSP action elements.  No
                        scripting elements are allowed.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:restriction base="j2ee:string">
        <xsd:enumeration value="tagdependent"/>
        <xsd:enumeration value="JSP"/>
        <xsd:enumeration value="empty"/>
        <xsd:enumeration value="scriptless"/>
      </xsd:restriction>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="extensibleType" abstract="true">
    <xsd:annotation>
      <xsd:documentation>
        The extensibleType is an abstract base type that is used to
        define the type of extension-elements. Instance documents
        must substitute a known type to define the extension by
        using xsi:type attribute to define the actual type of
        extension-elements.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="functionType">
    <xsd:annotation>
      <xsd:documentation>
        The function element is used to provide information on each
        function in the tag library that is to be exposed to the EL.
        The function element may have several subelements defining:
        description         Optional tag-specific information
        display-name        A short name that is intended to be
                            displayed by tools
        icon                Optional icon element that can be used
                            by tools
        name                A unique name for this function
        function-class      Provides the name of the Java class that
                            implements the function
        function-signature  Provides the signature, as in the Java
                            Language Specification, of the Java
                            method that is to be used to implement
                            the function.
        example             Optional informal description of an
                            example of a use of this function
        function-extension  Zero or more extensions that provide extra
                            information about this function, for tool
                            consumption
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="j2ee:descriptionGroup"/>
      <xsd:element name="name"
                   type="j2ee:tld-canonical-nameType">
        <xsd:annotation>
          <xsd:documentation>
            A unique name for this function.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="function-class"
                   type="j2ee:fully-qualified-classType">
        <xsd:annotation>
          <xsd:documentation>
            Provides the fully-qualified class name of the Java
            class containing the static method that implements
            the function.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="function-signature"
                   type="j2ee:string">
        <xsd:annotation>
          <xsd:documentation>
            Provides the signature, of the static Java method that is
            to be used to implement the function.  The syntax of the
            function-signature element is as follows:
                FunctionSignature ::= ReturnType S MethodName S?
                                      '(' S? Parameters? S? ')'
                ReturnType        ::= Type
                MethodName        ::= Identifier
                Parameters        ::=   Parameter
                                      | ( Parameter S? ',' S? Parameters )
                Parameter         ::= Type
                Where:
                     * Type is a basic type or a fully qualified Java class name
                      (including package name), as per the 'Type' production
                      in the Java Language Specification, Second Edition,
                      Chapter 18.
                    * Identifier is a Java identifier, as per the 'Identifier'
                      production in the Java Language Specification, Second
                      Edition, Chapter 18.
            Example:
            java.lang.String nickName( java.lang.String, int )
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="example"
                   type="j2ee:xsdStringType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The example element contains an informal description
            of an example of the use of this function.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="function-extension"
                   type="j2ee:tld-extensionType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            Function extensions are for tool use only and must not affect
            the behavior of a container.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="tagFileType">
    <xsd:annotation>
      <xsd:documentation>
        Defines an action in this tag library that is implemented
        as a .tag file.
        The tag-file element has two required subelements:
        description       Optional tag-specific information
        display-name      A short name that is intended to be
                          displayed by tools
        icon              Optional icon element that can be used
                          by tools
        name              The unique action name
        path              Where to find the .tag file implementing this
                          action, relative to the root of the web
                          application or the root of the JAR file for a
                          tag library packaged in a JAR.  This must
                          begin with /WEB-INF/tags if the .tag file
                          resides in the WAR, or /META-INF/tags if the
                          .tag file resides in a JAR.
        example           Optional informal description of an
                          example of a use of this tag
        tag-extension     Zero or more extensions that provide extra
                          information about this tag, for tool
                          consumption
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="j2ee:descriptionGroup"/>
      <xsd:element name="name"
                   type="j2ee:tld-canonical-nameType"/>
      <xsd:element name="path"
                   type="j2ee:pathType"/>
      <xsd:element name="example"
                   type="j2ee:xsdStringType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The example element contains an informal description
            of an example of the use of a tag.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="tag-extension"
                   type="j2ee:tld-extensionType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            Tag extensions are for tool use only and must not affect
            the behavior of a container.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="tagType">
    <xsd:annotation>
      <xsd:documentation>
        The tag defines a unique tag in this tag library.  It has one
        attribute, id.
        The tag element may have several subelements defining:
        description       Optional tag-specific information
        display-name      A short name that is intended to be
                          displayed by tools
        icon              Optional icon element that can be used
                          by tools
        name              The unique action name
        tag-class         The tag handler class implementing
                          javax.servlet.jsp.tagext.JspTag
        tei-class         An optional subclass of
                          javax.servlet.jsp.tagext.TagExtraInfo
        body-content      The body content type
        variable          Optional scripting variable information
        attribute         All attributes of this action that are
                          evaluated prior to invocation.
        dynamic-attributes Whether this tag supports additional
                           attributes with dynamic names.  If
                           true, the tag-class must implement the
                           javax.servlet.jsp.tagext.DynamicAttributes
                           interface.  Defaults to false.
        example           Optional informal description of an
                          example of a use of this tag
        tag-extension     Zero or more extensions that provide extra
                          information about this tag, for tool
                          consumption
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="j2ee:descriptionGroup"/>
      <xsd:element name="name"
                   type="j2ee:tld-canonical-nameType"/>
      <xsd:element name="tag-class"
                   type="j2ee:fully-qualified-classType">
        <xsd:annotation>
          <xsd:documentation>
            Defines the subclass of javax.serlvet.jsp.tagext.JspTag
            that implements the request time semantics for
            this tag. (required)
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="tei-class"
                   type="j2ee:fully-qualified-classType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Defines the subclass of javax.servlet.jsp.tagext.TagExtraInfo
            for this tag. (optional)
            If this is not given, the class is not consulted at
            translation time.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="body-content"
                   type="j2ee:body-contentType">
        <xsd:annotation>
          <xsd:documentation>
            Specifies the format for the body of this tag.
            The default in JSP 1.2 was "JSP" but because this
            is an invalid setting for simple tag handlers, there
            is no longer a default in JSP 2.0.  A reasonable
            default for simple tag handlers is "scriptless" if
            the tag can have a body.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="variable"
                   type="j2ee:variableType"
                   minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="attribute"
                   type="j2ee:tld-attributeType"
                   minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="dynamic-attributes"
                   type="j2ee:generic-booleanType"
                   minOccurs="0"/>
      <xsd:element name="example"
                   type="j2ee:xsdStringType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The example element contains an informal description
            of an example of the use of a tag.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="tag-extension"
                   type="j2ee:tld-extensionType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            Tag extensions are for tool use only and must not affect
            the behavior of a container.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="tld-attributeType">
    <xsd:annotation>
      <xsd:documentation>
        The attribute element defines an attribute for the nesting
        tag.  The attributre element may have several subelements
        defining:
        description     a description of the attribute
        name            the name of the attribute
        required        whether the attribute is required or
                        optional
        rtexprvalue     whether the attribute is a runtime attribute
        type            the type of the attributes
        fragment        whether this attribute is a fragment
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="description"
                   type="j2ee:descriptionType"
                   minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="name"
                   type="j2ee:java-identifierType"/>
      <xsd:element name="required"
                   type="j2ee:generic-booleanType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Defines if the nesting attribute is required or
            optional.
            If not present then the default is "false", i.e
            the attribute is optional.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:choice>
        <xsd:sequence>
          <xsd:element name="rtexprvalue"
                       type="j2ee:generic-booleanType"
                       minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>
                Defines if the nesting attribute can have scriptlet
                expressions as a value, i.e the value of the
                attribute may be dynamically calculated at request
                time, as opposed to a static value determined at
                translation time.
                If not present then the default is "false", i.e the
                attribute has a static value
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="type"
                       type="j2ee:fully-qualified-classType"
                       minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>
                Defines the Java type of the attributes value.  For
                static values (those determined at translation time)
                the type is always java.lang.String.
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:element name="fragment"
                     type="j2ee:generic-booleanType"
                     minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>
              "true" if this attribute is of type
              javax.jsp.tagext.JspFragment, representing dynamic
              content that can be re-evaluated as many times
              as needed by the tag handler.  If omitted or "false",
              the default is still type="java.lang.String"
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="tld-canonical-nameType">
    <xsd:annotation>
      <xsd:documentation>
        Defines the canonical name of a tag or attribute being
        defined.
        The name must conform to the lexical rules for an NMTOKEN.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:restriction base="j2ee:xsdNMTOKENType"/>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="tld-extensionType">
    <xsd:annotation>
      <xsd:documentation>
        The tld-extensionType is used to indicate
        extensions to a specific TLD element.
        It is used by elements to designate an extension block
        that is targeted to a specific extension designated by
        a set of extension elements that are declared by a
        namespace. The namespace identifies the extension to
        the tool that processes the extension.
        The type of the extension-element is abstract. Therefore,
        a concrete type must be specified by the TLD using
        xsi:type attribute for each extension-element.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="extension-element"
                   type="j2ee:extensibleType"
                   maxOccurs="unbounded"/>
    </xsd:sequence>
    <xsd:attribute name="namespace"
                   use="required"
                   type="xsd:anyURI"/>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="tldTaglibType">
    <xsd:annotation>
      <xsd:documentation>
        The taglib tag is the document root, it defines:
        description     a simple string describing the "use" of this taglib,
                        should be user discernable
        display-name    the display-name element contains a
                        short name that is intended to be displayed
                        by tools
        icon            optional icon that can be used by tools
        tlib-version    the version of the tag library implementation
        short-name      a simple default short name that could be
                        used by a JSP authoring tool to create
                        names with a mnemonic value; for example,
                        the it may be used as the prefered prefix
                        value in taglib directives
        uri             a uri uniquely identifying this taglib
        validator       optional TagLibraryValidator information
        listener        optional event listener specification
        tag             tags in this tag library
        tag-file        tag files in this tag library
        function        zero or more EL functions defined in this
                        tag library
        taglib-extension zero or more extensions that provide extra
                        information about this taglib, for tool
                        consumption
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="j2ee:descriptionGroup"/>
      <xsd:element name="tlib-version"
                   type="j2ee:dewey-versionType">
        <xsd:annotation>
          <xsd:documentation>
            Describes this version (number) of the taglibrary.
            It is described as a dewey decimal.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="short-name"
                   type="j2ee:tld-canonical-nameType">
        <xsd:annotation>
          <xsd:documentation>
            Defines a simple default name that could be used by
            a JSP authoring tool to create names with a
            mnemonicvalue; for example, it may be used as the
            preferred prefix value in taglib directives.  Do
            not use white space, and do not start with digits
            or underscore.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="uri"
                   type="j2ee:xsdAnyURIType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Defines a public URI that uniquely identifies this
            version of the taglibrary.  Leave it empty if it
            does not apply.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="validator"
                   type="j2ee:validatorType"
                   minOccurs="0">
      </xsd:element>
      <xsd:element name="listener"
                   type="j2ee:listenerType"
                   minOccurs="0" maxOccurs="unbounded">
      </xsd:element>
      <xsd:element name="tag"
                   type="j2ee:tagType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="tag-file"
                   type="j2ee:tagFileType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="function"
                   type="j2ee:functionType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="taglib-extension"
                   type="j2ee:tld-extensionType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            Taglib extensions are for tool use only and must not affect
            the behavior of a container.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="version"
                   type="j2ee:dewey-versionType"
                   fixed="2.0"
                   use="required">
      <xsd:annotation>
        <xsd:documentation>
          Describes the JSP version (number) this taglibrary
          requires in order to function (dewey decimal)
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="validatorType">
    <xsd:annotation>
      <xsd:documentation>
        A validator that can be used to validate
        the conformance of a JSP page to using this tag library is
        defined by a validatorType.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="description"
                   type="j2ee:descriptionType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="validator-class"
                   type="j2ee:fully-qualified-classType">
        <xsd:annotation>
          <xsd:documentation>
            Defines the TagLibraryValidator class that can be used
            to validate the conformance of a JSP page to using this
            tag library.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="init-param"
                   type="j2ee:param-valueType"
                   minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The init-param element contains a name/value pair as an
            initialization param.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="variable-scopeType">
    <xsd:annotation>
      <xsd:documentation>
        This type defines scope of the scripting variable.  See
        TagExtraInfo for details.  The allowed values are,
        "NESTED", "AT_BEGIN" and "AT_END".
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:restriction base="j2ee:string">
        <xsd:enumeration value="NESTED"/>
        <xsd:enumeration value="AT_BEGIN"/>
        <xsd:enumeration value="AT_END"/>
      </xsd:restriction>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="variableType">
    <xsd:annotation>
      <xsd:documentation>
        The variableType provides information on the scripting
        variables defined by using this tag.  It is a (translation
        time) error for a tag that has one or more variable
        subelements to have a TagExtraInfo class that returns a
        non-null value from a call to getVariableInfo().
        The subelements of variableType are of the form:
        description              Optional description of this
                                 variable
        name-given               The variable name as a constant
        name-from-attribute      The name of an attribute whose
                                 (translation time) value will
                                 give the name of the
                                 variable.  One of name-given or
                                 name-from-attribute is required.
        variable-class           Name of the class of the variable.
                                 java.lang.String is default.
        declare                  Whether the variable is declared
                                 or not.  True is the default.
        scope                    The scope of the scripting varaible
                                 defined.  NESTED is default.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="description"
                   type="j2ee:descriptionType"
                   minOccurs="0" maxOccurs="unbounded"/>
      <xsd:choice>
        <xsd:element name="name-given"
                     type="j2ee:java-identifierType">
          <xsd:annotation>
            <xsd:documentation>
              The name for the scripting variable.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="name-from-attribute"
                     type="j2ee:java-identifierType">
          <xsd:annotation>
            <xsd:documentation>
              The name of an attribute whose
              (translation-time) value will give the name of
              the variable.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:choice>
      <xsd:element name="variable-class"
                   type="j2ee:fully-qualified-classType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The optional name of the class for the scripting
            variable.  The default is java.lang.String.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="declare"
                   type="j2ee:generic-booleanType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Whether the scripting variable is to be defined
            or not.  See TagExtraInfo for details.  This
            element is optional and "true" is the default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="scope"
                   type="j2ee:variable-scopeType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The element is optional and "NESTED" is the default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  ** This XSD contains only the programatic elements required for an implementation.
  ** For the XSD from Sun that includes documentation and other copyrighted information
  ** please refer to http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd for a fully documented and latest
  **  XSD.
            xmlns:javaee="http://java.sun.com/xml/ns/javaee"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            version="2.1">
    <xsd:include schemaLocation="javaee_5.xsd" />
    <xsd:element name="taglib" type="javaee:tldTaglibType">
        <xsd:unique name="tag-name-uniqueness">
            <xsd:selector xpath="javaee:tag|javaee:tag-file" />
            <xsd:field xpath="javaee:name" />
        </xsd:unique>
        <xsd:unique name="function-name-uniqueness">
            <xsd:selector xpath="javaee:function" />
            <xsd:field xpath="javaee:name" />
        </xsd:unique>
    </xsd:element>
    <xsd:complexType name="body-contentType">
        <xsd:simpleContent>
            <xsd:restriction base="javaee:string">
                <xsd:enumeration value="tagdependent" />
                <xsd:enumeration value="JSP" />
                <xsd:enumeration value="empty" />
                <xsd:enumeration value="scriptless" />
            </xsd:restriction>
        </xsd:simpleContent>
    </xsd:complexType>
    <xsd:complexType name="extensibleType" abstract="true">
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="functionType">
        <xsd:sequence>
            <xsd:group ref="javaee:descriptionGroup" />
            <xsd:element name="name" type="javaee:tld-canonical-nameType"></xsd:element>
            <xsd:element name="function-class" type="javaee:fully-qualified-classType"></xsd:element>
            <xsd:element name="function-signature" type="javaee:string"></xsd:element>
            <xsd:element name="example" type="javaee:xsdStringType" minOccurs="0"></xsd:element>
            <xsd:element name="function-extension" type="javaee:tld-extensionType" minOccurs="0" maxOccurs="unbounded"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tagFileType">
        <xsd:sequence>
            <xsd:group ref="javaee:descriptionGroup" />
            <xsd:element name="name" type="javaee:tld-canonical-nameType" />
            <xsd:element name="path" type="javaee:pathType" />
            <xsd:element name="example" type="javaee:xsdStringType" minOccurs="0"></xsd:element>
            <xsd:element name="tag-extension" type="javaee:tld-extensionType" minOccurs="0" maxOccurs="unbounded"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tagType">
        <xsd:sequence>
            <xsd:group ref="javaee:descriptionGroup" />
            <xsd:element name="name" type="javaee:tld-canonical-nameType" />
            <xsd:element name="tag-class" type="javaee:fully-qualified-classType"></xsd:element>
            <xsd:element name="tei-class" type="javaee:fully-qualified-classType" minOccurs="0"></xsd:element>
            <xsd:element name="body-content" type="javaee:body-contentType"></xsd:element>
            <xsd:element name="variable" type="javaee:variableType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="attribute" type="javaee:tld-attributeType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="dynamic-attributes" type="javaee:generic-booleanType" minOccurs="0" />
            <xsd:element name="example" type="javaee:xsdStringType" minOccurs="0" />
            <xsd:element name="tag-extension" type="javaee:tld-extensionType" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tld-attributeType">
        <xsd:sequence>
            <xsd:element name="description" type="javaee:descriptionType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="name" type="javaee:java-identifierType" />
            <xsd:element name="required" type="javaee:generic-booleanType" minOccurs="0"></xsd:element>
            <xsd:choice>
                <xsd:sequence>
                    <xsd:sequence minOccurs="0">
                        <xsd:element name="rtexprvalue" type="javaee:generic-booleanType"></xsd:element>
                        <xsd:element name="type" type="javaee:fully-qualified-classType" minOccurs="0"></xsd:element>
                    </xsd:sequence>
                    <xsd:choice>
                        <xsd:element name="deferred-value" type="javaee:tld-deferred-valueType" minOccurs="0"></xsd:element>
                        <xsd:element name="deferred-method" type="javaee:tld-deferred-methodType" minOccurs="0"></xsd:element>
                    </xsd:choice>
                </xsd:sequence>
                <xsd:element name="fragment" type="javaee:generic-booleanType" minOccurs="0"></xsd:element>
            </xsd:choice>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tld-canonical-nameType">
        <xsd:simpleContent>
            <xsd:restriction base="javaee:xsdNMTOKENType" />
        </xsd:simpleContent>
    </xsd:complexType>
    <xsd:complexType name="tld-deferred-methodType">
        <xsd:sequence>
            <xsd:element name="method-signature" type="javaee:string" minOccurs="0"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tld-deferred-valueType">
        <xsd:sequence>
            <xsd:element name="type" type="javaee:fully-qualified-classType" minOccurs="0"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tld-extensionType">
        <xsd:sequence>
            <xsd:element name="extension-element" type="javaee:extensibleType" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="namespace" use="required" type="xsd:anyURI" />
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tldTaglibType">
        <xsd:sequence>
            <xsd:group ref="javaee:descriptionGroup" />
            <xsd:element name="tlib-version" type="javaee:dewey-versionType"></xsd:element>
            <xsd:element name="short-name" type="javaee:tld-canonical-nameType">
            </xsd:element>
            <xsd:element name="uri" type="javaee:xsdAnyURIType" minOccurs="0">
            </xsd:element>
            <xsd:element name="validator" type="javaee:validatorType" minOccurs="0">
            </xsd:element>
            <xsd:element name="listener" type="javaee:listenerType" minOccurs="0" maxOccurs="unbounded"></xsd:element>
            <xsd:element name="tag" type="javaee:tagType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="tag-file" type="javaee:tagFileType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="function" type="javaee:functionType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="taglib-extension" type="javaee:tld-extensionType" minOccurs="0" maxOccurs="unbounded"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="version" type="javaee:dewey-versionType" fixed="2.1" use="required"></xsd:attribute>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="validatorType">
        <xsd:sequence>
            <xsd:element name="description" type="javaee:descriptionType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="validator-class" type="javaee:fully-qualified-classType"></xsd:element>
            <xsd:element name="init-param" type="javaee:param-valueType" minOccurs="0" maxOccurs="unbounded"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="variable-scopeType">
        <xsd:simpleContent>
            <xsd:restriction base="javaee:string">
                <xsd:enumeration value="NESTED" />
                <xsd:enumeration value="AT_BEGIN" />
                <xsd:enumeration value="AT_END" />
            </xsd:restriction>
        </xsd:simpleContent>
    </xsd:complexType>
    <xsd:complexType name="variableType">
        <xsd:sequence>
            <xsd:element name="description" type="javaee:descriptionType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:choice>
                <xsd:element name="name-given" type="javaee:java-identifierType"></xsd:element>
                <xsd:element name="name-from-attribute" type="javaee:java-identifierType"></xsd:element>
            </xsd:choice>
            <xsd:element name="variable-class" type="javaee:fully-qualified-classType" minOccurs="0"></xsd:element>
            <xsd:element name="declare" type="javaee:generic-booleanType" minOccurs="0"></xsd:element>
            <xsd:element name="scope" type="javaee:variable-scopeType" minOccurs="0"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
        "/javax/servlet/jsp/resources/jsp_2_0.xsd";
        "/javax/servlet/jsp/resources/jsp_2_1.xsd";
        "/javax/servlet/jsp/resources/jsp_2_2.xsd";
        "/javax/servlet/jsp/resources/jsp_2_3.xsd";
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/
   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
   1. Definitions.
      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.
      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.
      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.
      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.
      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.
      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.
      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).
      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.
      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."
      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.
   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.
   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.
   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:
      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and
      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and
      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and
      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.
      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.
   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.
   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.
   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.
   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.
   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.
   END OF TERMS AND CONDITIONS
   APPENDIX: How to apply the Apache License to your work.
      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.
   Copyright [yyyy] [name of copyright owner]
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 - jsp_2_2.xsd
 - jsp_2_3.xsd
   1.1. Contributor. means each individual or entity that creates or contributes
        to the creation of Modifications.
   1.2. Contributor Version. means the combination of the Original Software,
        prior Modifications used by a Contributor (if any), and the
        Modifications made by that particular Contributor.
   1.3. Covered Software. means (a) the Original Software, or (b) Modifications,
        or (c) the combination of files containing Original Software with files
        containing Modifications, in each case including portions thereof.
   1.4. Executable. means the Covered Software in any form other than Source
        Code.
   1.5. Initial Developer. means the individual or entity that first makes
        Original Software available under this License.
   1.6. Larger Work. means a work which combines Covered Software or portions
        thereof with code not governed by the terms of this License.
   1.7. License. means this document.
   1.8. Licensable. means having the right to grant, to the maximum extent
        possible, whether at the time of the initial grant or subsequently
        acquired, any and all of the rights conveyed herein.
   1.9. Modifications. means the Source Code and Executable form of any of the
        following:
        A. Any file that results from an addition to, deletion from or
           modification of the contents of a file containing Original Software
           or previous Modifications;
        B. Any new file that contains any part of the Original Software or
           previous Modification; or
        C. Any new file that is contributed or otherwise made available under
           the terms of this License.
   1.10. Original Software. means the Source Code and Executable form of
         computer software code that is originally released under this License.
   1.11. Patent Claims. means any patent claim(s), now owned or hereafter
         acquired, including without limitation, method, process, and apparatus
         claims, in any patent Licensable by grantor.
   1.12. Source Code. means (a) the common form of computer software code in
         which modifications are made and (b) associated documentation included
         in or with such code.
   1.13. You. (or .Your.) means an individual or a legal entity exercising
         rights under, and complying with all of the terms of, this License. For
         legal entities, .You. includes any entity which controls, is controlled
         by, or is under common control with You. For purposes of this
         definition, .control. means (a) the power, direct or indirect, to cause
         the direction or management of such entity, whether by contract or
         otherwise, or (b) ownership of more than fifty percent (50%) of the
         outstanding shares or beneficial ownership of such entity.
      2.1. The Initial Developer Grant.
      Conditioned upon Your compliance with Section 3.1 below and subject to
      third party intellectual property claims, the Initial Developer hereby
      grants You a world-wide, royalty-free, non-exclusive license:
        (a) under intellectual property rights (other than patent or trademark)
            Licensable by Initial Developer, to use, reproduce, modify, display,
            perform, sublicense and distribute the Original Software (or
            portions thereof), with or without Modifications, and/or as part of
            a Larger Work; and
        (b) under Patent Claims infringed by the making, using or selling of
            Original Software, to make, have made, use, practice, sell, and
            offer for sale, and/or otherwise dispose of the Original Software
            (or portions thereof).
        (c) The licenses granted in Sections 2.1(a) and (b) are effective on the
            date Initial Developer first distributes or otherwise makes the
            Original Software available to a third party under the terms of this
            License.
        (d) Notwithstanding Section 2.1(b) above, no patent license is granted:
            (1) for code that You delete from the Original Software, or (2) for
            infringements caused by: (i) the modification of the Original
            Software, or (ii) the combination of the Original Software with
            other software or devices.
    2.2. Contributor Grant.
    Conditioned upon Your compliance with Section 3.1 below and subject to third
    party intellectual property claims, each Contributor hereby grants You a
    world-wide, royalty-free, non-exclusive license:
        (a) under intellectual property rights (other than patent or trademark)
            Licensable by Contributor to use, reproduce, modify, display,
            perform, sublicense and distribute the Modifications created by such
            Contributor (or portions thereof), either on an unmodified basis,
            with other Modifications, as Covered Software and/or as part of a
            Larger Work; and
        (b) under Patent Claims infringed by the making, using, or selling of
            Modifications made by that Contributor either alone and/or in
            combination with its Contributor Version (or portions of such
            combination), to make, use, sell, offer for sale, have made, and/or
            otherwise dispose of: (1) Modifications made by that Contributor (or
            portions thereof); and (2) the combination of Modifications made by
            that Contributor with its Contributor Version (or portions of such
            combination).
        (c) The licenses granted in Sections 2.2(a) and 2.2(b) are effective on
            the date Contributor first distributes or otherwise makes the
            Modifications available to a third party.
        (d) Notwithstanding Section 2.2(b) above, no patent license is granted:
            (1) for any code that Contributor has deleted from the Contributor
            Version; (2) for infringements caused by: (i) third party
            modifications of Contributor Version, or (ii) the combination of
            Modifications made by that Contributor with other software (except
            as part of the Contributor Version) or other devices; or (3) under
            Patent Claims infringed by Covered Software in the absence of
            Modifications made by that Contributor.
      3.1. Availability of Source Code.
      Any Covered Software that You distribute or otherwise make available in
      Executable form must also be made available in Source Code form and that
      Source Code form must be distributed only under the terms of this License.
      You must include a copy of this License with every copy of the Source Code
      form of the Covered Software You distribute or otherwise make available.
      You must inform recipients of any such Covered Software in Executable form
      as to how they can obtain such Covered Software in Source Code form in a
      reasonable manner on or through a medium customarily used for software
      exchange.
      3.2. Modifications.
      The Modifications that You create or to which You contribute are governed
      by the terms of this License. You represent that You believe Your
      Modifications are Your original creation(s) and/or You have sufficient
      rights to grant the rights conveyed by this License.
      3.3. Required Notices.
      You must include a notice in each of Your Modifications that identifies
      You as the Contributor of the Modification. You may not remove or alter
      any copyright, patent or trademark notices contained within the Covered
      Software, or any notices of licensing or any descriptive text giving
      attribution to any Contributor or the Initial Developer.
      3.4. Application of Additional Terms.
      You may not offer or impose any terms on any Covered Software in Source
      Code form that alters or restricts the applicable version of this License
      or the recipients. rights hereunder. You may choose to offer, and to
      charge a fee for, warranty, support, indemnity or liability obligations to
      one or more recipients of Covered Software. However, you may do so only on
      Your own behalf, and not on behalf of the Initial Developer or any
      Contributor. You must make it absolutely clear that any such warranty,
      support, indemnity or liability obligation is offered by You alone, and
      You hereby agree to indemnify the Initial Developer and every Contributor
      for any liability incurred by the Initial Developer or such Contributor as
      a result of warranty, support, indemnity or liability terms You offer.
      3.5. Distribution of Executable Versions.
      You may distribute the Executable form of the Covered Software under the
      terms of this License or under the terms of a license of Your choice,
      which may contain terms different from this License, provided that You are
      in compliance with the terms of this License and that the license for the
      Executable form does not attempt to limit or alter the recipient.s rights
      in the Source Code form from the rights set forth in this License. If You
      distribute the Covered Software in Executable form under a different
      license, You must make it absolutely clear that any terms which differ
      from this License are offered by You alone, not by the Initial Developer
      or Contributor. You hereby agree to indemnify the Initial Developer and
      every Contributor for any liability incurred by the Initial Developer or
      such Contributor as a result of any such terms You offer.
      3.6. Larger Works.
      You may create a Larger Work by combining Covered Software with other code
      not governed by the terms of this License and distribute the Larger Work
      as a single product. In such a case, You must make sure the requirements
      of this License are fulfilled for the Covered Software.
      4.1. New Versions.
      Sun Microsystems, Inc. is the initial license steward and may publish
      revised and/or new versions of this License from time to time. Each
      version will be given a distinguishing version number. Except as provided
      in Section 4.3, no one other than the license steward has the right to
      modify this License.
      4.2. Effect of New Versions.
      You may always continue to use, distribute or otherwise make the Covered
      Software available under the terms of the version of the License under
      which You originally received the Covered Software. If the Initial
      Developer includes a notice in the Original Software prohibiting it from
      being distributed or otherwise made available under any subsequent version
      of the License, You must distribute and make the Covered Software
      available under the terms of the version of the License under which You
      originally received the Covered Software. Otherwise, You may also choose
      to use, distribute or otherwise make the Covered Software available under
      the terms of any subsequent version of the License published by the
      license steward.
      4.3. Modified Versions.
      When You are an Initial Developer and You want to create a new license for
      Your Original Software, You may create and use a modified version of this
      License if You: (a) rename the license and remove any references to the
      name of the license steward (except to note that the license differs from
      this License); and (b) otherwise make it clear that the license contains
      terms which differ from this License.
   COVERED SOFTWARE IS PROVIDED UNDER THIS LICENSE ON AN .AS IS. BASIS, WITHOUT
   WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT
   LIMITATION, WARRANTIES THAT THE COVERED SOFTWARE IS FREE OF DEFECTS,
   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING. THE ENTIRE RISK
   AS TO THE QUALITY AND PERFORMANCE OF THE COVERED SOFTWARE IS WITH YOU. SHOULD
   ANY COVERED SOFTWARE PROVE DEFECTIVE IN ANY RESPECT, YOU (NOT THE INITIAL
   DEVELOPER OR ANY OTHER CONTRIBUTOR) ASSUME THE COST OF ANY NECESSARY
   SERVICING, REPAIR OR CORRECTION. THIS DISCLAIMER OF WARRANTY CONSTITUTES AN
   ESSENTIAL PART OF THIS LICENSE. NO USE OF ANY COVERED SOFTWARE IS AUTHORIZED
   HEREUNDER EXCEPT UNDER THIS DISCLAIMER.
      6.1. This License and the rights granted hereunder will terminate
           automatically if You fail to comply with terms herein and fail to
           cure such breach within 30 days of becoming aware of the breach.
           Provisions which, by their nature, must remain in effect beyond the
           termination of this License shall survive.
      6.2. If You assert a patent infringement claim (excluding declaratory
           judgment actions) against Initial Developer or a Contributor (the
           Initial Developer or Contributor against whom You assert such claim
           is referred to as .Participant.) alleging that the Participant
           Software (meaning the Contributor Version where the Participant is a
           Contributor or the Original Software where the Participant is the
           Initial Developer) directly or indirectly infringes any patent, then
           any and all rights granted directly or indirectly to You by such
           Participant, the Initial Developer (if the Initial Developer is not
           the Participant) and all Contributors under Sections 2.1 and/or 2.2
           of this License shall, upon 60 days notice from Participant terminate
           prospectively and automatically at the expiration of such 60 day
           notice period, unless if within such 60 day period You withdraw Your
           claim with respect to the Participant Software against such
           Participant either unilaterally or pursuant to a written agreement
           with Participant.
      6.3. In the event of termination under Sections 6.1 or 6.2 above, all end
           user licenses that have been validly granted by You or any
           distributor hereunder prior to termination (excluding licenses
           granted to You by any distributor) shall survive termination.
   UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER TORT (INCLUDING
   NEGLIGENCE), CONTRACT, OR OTHERWISE, SHALL YOU, THE INITIAL DEVELOPER, ANY
   OTHER CONTRIBUTOR, OR ANY DISTRIBUTOR OF COVERED SOFTWARE, OR ANY SUPPLIER OF
   ANY OF SUCH PARTIES, BE LIABLE TO ANY PERSON FOR ANY INDIRECT, SPECIAL,
   INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER INCLUDING, WITHOUT
   LIMITATION, DAMAGES FOR LOST PROFITS, LOSS OF GOODWILL, WORK STOPPAGE,
   COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL OTHER COMMERCIAL DAMAGES OR
   LOSSES, EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED OF THE POSSIBILITY OF
   SUCH DAMAGES. THIS LIMITATION OF LIABILITY SHALL NOT APPLY TO LIABILITY FOR
   DEATH OR PERSONAL INJURY RESULTING FROM SUCH PARTY.S NEGLIGENCE TO THE EXTENT
   APPLICABLE LAW PROHIBITS SUCH LIMITATION. SOME JURISDICTIONS DO NOT ALLOW THE
   EXCLUSION OR LIMITATION OF INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THIS
   EXCLUSION AND LIMITATION MAY NOT APPLY TO YOU.
   The Covered Software is a .commercial item,. as that term is defined in 48
   C.F.R. 2.101 (Oct. 1995), consisting of .commercial computer software. (as
   that term is defined at 48 C.F.R. ? 252.227-7014(a)(1)) and commercial
   computer software documentation. as such terms are used in 48 C.F.R. 12.212
   (Sept. 1995). Consistent with 48 C.F.R. 12.212 and 48 C.F.R. 227.7202-1
   through 227.7202-4 (June 1995), all U.S. Government End Users acquire Covered
   Software with only those rights set forth herein. This U.S. Government Rights
   clause is in lieu of, and supersedes, any other FAR, DFAR, or other clause or
   provision that addresses Government rights in computer software under this
   License.
   This License represents the complete agreement concerning subject matter
   hereof. If any provision of this License is held to be unenforceable, such
   provision shall be reformed only to the extent necessary to make it
   enforceable. This License shall be governed by the law of the jurisdiction
   specified in a notice contained within the Original Software (except to the
   extent applicable law, if any, provides otherwise), excluding such
   jurisdiction's conflict-of-law provisions. Any litigation relating to this
   License shall be subject to the jurisdiction of the courts located in the
   jurisdiction and venue specified in a notice contained within the Original
   Software, with the losing party responsible for costs, including, without
   limitation, court costs and reasonable attorneys. fees and expenses. The
   application of the United Nations Convention on Contracts for the
   International Sale of Goods is expressly excluded. Any law or regulation
   which provides that the language of a contract shall be construed against
   the drafter shall not apply to this License. You agree that You alone are
   responsible for compliance with the United States export administration
   regulations (and the export control laws and regulation of any other
   countries) when You use, distribute or otherwise make available any Covered
   Software.
   As between Initial Developer and the Contributors, each party is responsible
   for claims and damages arising, directly or indirectly, out of its
   utilization of rights under this License and You agree to work with Initial
   Developer and Contributors to distribute such responsibility on an equitable
   basis. Nothing herein is intended or shall be deemed to constitute any
   admission of liability.
   NOTICE PURSUANT TO SECTION 9 OF THE COMMON DEVELOPMENT AND DISTRIBUTION
   LICENSE (CDDL)
   The code released under the CDDL shall be governed by the laws of the State
   of California (excluding conflict-of-law provisions). Any litigation relating
   to this License shall be subject to the jurisdiction of the Federal Courts of
   the Northern District of California and the state courts of the State of
   California, with venue lying in Santa Clara County, California.
 - jsp_2_2.xsd
 - jsp_2_3.xsd
      <name>
        Apache License, Version 2.0 and
        Common Development And Distribution License (CDDL) Version 1.0
      </name>
      <url>
        http://www.apache.org/licenses/LICENSE-2.0.txt and
        http://www.opensource.org/licenses/cddl1.txt
      </url>
      <comments>
        The Apache License, version 2.0 applies to all files apart from
        jsp_2_2.xsd and jsp_2_3.xsd to which the CDDL version 1.0 applies.
      </comments>
        javaee_5.xsd, javaee_web_services_1_2.xsd,
        javaee_web_services_client_1_2.xsd, javaee_6.xsd,
        javaee_web_services_1_3.xsd, javaee_web_services_client_1_3.xsd,
        web-app_3_0.xsd, web-common_3_0.xsd, web-fragment_3_0.xsd, javaee_7.xsd,
        javaee_web_services_1_4.xsd, javaee_web_services_client_1_4.xsd,
        web-app_3_1.xsd, web-common_3_1.xsd and web-fragment_3_1.xsd to which
        the CDDL version 1.0 applies.

======= fetch "protected void processServletContainerInitializers(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

            ServletContainerInitializer sci = null;
======= fetch "protected void processServletContainerInitializers(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

                    sci = getServletContainerInitializer(is);
======= fetch "protected void processServletContainerInitializers(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

            if (sci == null) {
======= fetch "protected void processServletContainerInitializers(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

            initializerClassMap.put(sci, new HashSet<Class<?>>());
======= fetch "protected void processServletContainerInitializers(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

            HandlesTypes ht = null;
            try {
                ht = sci.getClass().getAnnotation(HandlesTypes.class);
            } catch (Exception e) {
                if (log.isDebugEnabled()) {
                    log.info(sm.getString("contextConfig.sci.debug", url), e);
                } else {
                    log.info(sm.getString("contextConfig.sci.info", url));
======= fetch "protected void processServletContainerInitializers(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

            }
            if (ht != null) {
                Class<?>[] types = ht.value();
                if (types != null) {
                    for (Class<?> type : types) {
                        if (type.isAnnotation()) {
                            handlesTypesAnnotations = true;
                        } else {
                            handlesTypesNonAnnotations = true;
                        }
                        Set<ServletContainerInitializer> scis =
                            typeInitializerMap.get(type);
                        if (scis == null) {
                            scis = new HashSet<>();
                            typeInitializerMap.put(type, scis);
======= fetch "protected void processServletContainerInitializers(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

                        scis.add(sci);
======= fetch "protected void processServletContainerInitializers(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

======= fetch "protected void processServletContainerInitializers(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

     *
======= fetch "protected void processServletContainerInitializers(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

    protected ServletContainerInitializer getServletContainerInitializer(
======= fetch "protected ServletContainerInitializer getServletContainerInitializer(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

        String className = null;
======= fetch "protected ServletContainerInitializer getServletContainerInitializer(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

                BufferedReader br =
                    new BufferedReader(new InputStreamReader(is, "UTF-8"));
                line = br.readLine();
                if (line != null && line.trim().length() > 0) {
                    className = line.trim();
======= fetch "protected ServletContainerInitializer getServletContainerInitializer(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

        return initializers;
    }
    protected ServletContainerInitializer getServletContainerInitializer(
            String className) throws IOException {
======= fetch "protected ServletContainerInitializer getServletContainerInitializer(" b932ace^:"java/org/apache/catalina/startup/ContextConfig.java"

            Class<?> clazz = Class.forName(className,true,
                    context.getLoader().getClassLoader());
             sci = (ServletContainerInitializer) clazz.newInstance();

======= fetch "public void run() {" 00e4f3f^:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

                        Future<Integer> f = socketChannel.write(socketWriteBuffer);
                        Integer socketWrite = f.get();
                        if (socketWrite.intValue() != r.bytesProduced()) {
                            throw new IOException(sm.getString(
                                    "asyncChannelWrapperSecure.writeFail",
                                    Integer.valueOf(socketWrite.intValue()),
                                    Integer.valueOf(r.bytesProduced())));

======= fetch "public void recycle() {" 2eb065f^:"java/org/apache/coyote/Request.java"

        localNameMB.recycle();

======= fetch "public MessageHandlerInfo(Method m, List<DecoderEntry> decoderEntries) {" a267dbf^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                } else if (decoderMatch.hasMatches()) {

    public static final String WS_PROTOCOL_HEADER_NAME_LOWER =
            WS_PROTOCOL_HEADER_NAME.toLowerCase(Locale.ENGLISH);
======= fetch "public Session connectToServer(Endpoint endpoint," a634d85^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

            // Header names are always stored in lower case
======= fetch "public Session connectToServer(Endpoint endpoint," a634d85^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

                    Constants.WS_PROTOCOL_HEADER_NAME);
======= fetch "private void parseHeaders(String line, Map<String,List<String>> headers) {" a634d85^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

        // Header names are case insensitive so always use lower case
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testWsSubprotocols() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        ctx.addApplicationListener(new ApplicationListener(Config.class
                .getName(), false));
        Tomcat.addServlet(ctx, "default", new DefaultServlet());
        ctx.addServletMapping("/", "default");
        tomcat.start();
        WebSocketContainer wsContainer = ContainerProvider
                .getWebSocketContainer();
        tomcat.start();
        Session wsSession = wsContainer.connectToServer(
                TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder
                        .create().preferredSubprotocols(Arrays.asList("sp3"))
                        .build(), new URI("ws://localhost:" + getPort()
                        + SubProtocolsEndpoint.PATH_BASIC));
        Assert.assertTrue(wsSession.isOpen());
        if (wsSession.getNegotiatedSubprotocol() != null) {
            Assert.assertTrue(wsSession.getNegotiatedSubprotocol().isEmpty());
        }
        wsSession.close();
        wsSession = wsContainer.connectToServer(
                TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder
                        .create().preferredSubprotocols(Arrays.asList("sp2"))
                        .build(), new URI("ws://localhost:" + getPort()
                        + SubProtocolsEndpoint.PATH_BASIC));
        Assert.assertTrue(wsSession.isOpen());
        Assert.assertEquals("sp2", wsSession.getNegotiatedSubprotocol());
        Assert.assertArrayEquals(new String[]{"sp1","sp2"},
                SubProtocolsEndpoint.subprotocols.toArray(new String[2]));
        wsSession.close();
    }
    @ServerEndpoint(value = "/echo", subprotocols = {"sp1","sp2"})
    public static class SubProtocolsEndpoint {
        public static String PATH_BASIC = "/echo";
        public static List<String> subprotocols;
        @OnOpen
        public void processOpen(@SuppressWarnings("unused") Session session,
                EndpointConfig  epc) {
            subprotocols = ((ServerEndpointConfig)epc).getSubprotocols();
        }
    }
    public static class Config extends WsListener {
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            super.contextInitialized(sce);
            ServerContainer sc = (ServerContainer) sce.getServletContext()
                    .getAttribute(Constants.
                            SERVER_CONTAINER_SERVLET_CONTEXT_ATTRIBUTE);
            try {
                sc.addEndpoint(SubProtocolsEndpoint.class);
            } catch (DeploymentException e) {
                throw new IllegalStateException(e);
            }
        }
    }

======= fetch "public void addEndpoint(Class<?> pojo) throws DeploymentException {" b069c78^:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

                subprotocols(Arrays.asList(annotation.subprotocols())).

======= fetch "public WsPongMessage(ByteBuffer applicationData) {" 19c0bd3^:"java/org/apache/tomcat/websocket/WsPongMessage.java"

        this.applicationData = applicationData;

======= fetch "public SocketState process(SocketWrapper<S> socketWrapper)" 4da2de0^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

                setSocketTimeout(endpoint.getSoTimeout());

======= fetch "private boolean processDataControl() throws IOException {" ddd73d0^:"java/org/apache/tomcat/websocket/WsFrameBase.java"

                mhPong.onMessage(new WsPongMessage(controlBufferBinary));
======= fetch "private void sendMessageText(boolean last) throws WsIOException {" ddd73d0^:"java/org/apache/tomcat/websocket/WsFrameBase.java"

            if (mh instanceof MessageHandler.Partial<?>) {
                ((MessageHandler.Partial<String>) mh).onMessage(
                        messageBufferText.toString(), last);
            } else {
                // Caller ensures last == true if this branch is used
                ((MessageHandler.Whole<String>) mh).onMessage(
                        messageBufferText.toString());
======= fetch "private void sendMessageText(boolean last) throws WsIOException {" ddd73d0^:"java/org/apache/tomcat/websocket/WsFrameBase.java"

            messageBufferText.clear();
======= fetch "private void sendMessageBinary(ByteBuffer msg, boolean last)" ddd73d0^:"java/org/apache/tomcat/websocket/WsFrameBase.java"

            if (mh instanceof MessageHandler.Partial<?>) {
                ((MessageHandler.Partial<ByteBuffer>) mh).onMessage(msg, last);
            } else {
                // Caller ensures last == true if this branch is used
                ((MessageHandler.Whole<ByteBuffer>) mh).onMessage(msg);

 * <td>RemoteIPProxiesHeader</td>
 *   remoteIpProxiesHeader="x-forwarded-by"
 *   remoteIpProxiesHeader="x-forwarded-by"
 *   remoteIpProxiesHeader="x-forwarded-by"
 *   remoteIpProxiesHeader="x-forwarded-by"

======= fetch "protected void setRequestLineReadTimeout() throws IOException {" df6cee7^:"java/org/apache/coyote/http11/Http11Processor.java"

            socket.getSocket().setSoTimeout(endpoint.getSoTimeout());

    extends RealmBase
 {
     protected boolean useContextClassLoader = true;
======= fetch "protected Principal authenticate(String username," 6871d4c^:"java/org/apache/catalina/realm/JAASRealm.java"

            loginContext = new LoginContext(appName, callbackHandler);
======= fetch "protected void startInternal() throws LifecycleException {" 6871d4c^:"java/org/apache/catalina/realm/JAASRealm.java"

    /**
     * Load custom JAAS Configuration
     */
    protected Configuration getConfig() {
        try {
            if (jaasConfigurationLoaded) {
                return jaasConfiguration;
            }
            synchronized (this) {
                if (configFile == null) {
                    jaasConfigurationLoaded = true;
                    return null;
                }
                URL resource = Thread.currentThread().getContextClassLoader().
                        getResource(configFile);
                URI uri = resource.toURI();
                Class<Configuration> sunConfigFile = (Class<Configuration>)
                        Class.forName("com.sun.security.auth.login.ConfigFile");
                Constructor<Configuration> constructor =
                        sunConfigFile.getConstructor(URI.class);
                Configuration config = constructor.newInstance(uri);
                this.jaasConfiguration = config;
                this.jaasConfigurationLoaded = true;
                return this.jaasConfiguration;
            }
        } catch (URISyntaxException ex) {
            throw new RuntimeException(ex);
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(ex);
        } catch (SecurityException ex) {
            throw new RuntimeException(ex);
        } catch (InstantiationException ex) {
            throw new RuntimeException(ex);
        } catch (IllegalAccessException ex) {
            throw new RuntimeException(ex);
        } catch (IllegalArgumentException ex) {
            throw new RuntimeException(ex);
        } catch (InvocationTargetException ex) {
            throw new RuntimeException(ex.getCause());
        } catch (ClassNotFoundException ex) {
            throw new RuntimeException(ex);
        }
    }
      <attribute name="configFile" required="false">
        <p>The name of a JAAS configuration file to use with this Realm. It will
        be searched for using <code>ClassLoader#getResource(String)</code> so it
        is possible for the configuration to be bundled within a web
        application. If not specified, the default JVM global JAAS configuration
        willbe used.</p>
      </attribute>

======= fetch "private int readSocket(boolean timeout, boolean block) throws IOException {" 9a01f2d^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

                NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
                if ( att == null ) throw new IOException("Key must be cancelled.");
                nRead = pool.read(socket.getBufHandler().getReadBuffer(),socket,selector,att.getTimeout());

======= fetch "public AttributeNamesEnumerator() {" ca956bd^:"java/org/apache/catalina/core/ApplicationHttpRequest.java"

            for (int i = 0; i < specialAttributes.length; i++) {
======= fetch "public AttributeNamesEnumerator() {" ca956bd^:"java/org/apache/catalina/core/ApplicationHttpRequest.java"

                    break;

======= fetch "protected String getPartialServletStackTrace(Throwable t) {" b7cad6b^:"java/org/apache/catalina/valves/ErrorReportValve.java"

        for (int i = 0; i < elements.length; i++) {
======= fetch "protected String getPartialServletStackTrace(Throwable t) {" b7cad6b^:"java/org/apache/catalina/valves/ErrorReportValve.java"

                break;

    protected String rmiBindAddress = null;
     * Get the inet address on which the Platform RMI server is exported.
     * @return The textual representation of inet address
     */
    public String getRmiBindAddress() {
        return rmiBindAddress;
    }
    /**
     * Set the inet address on which the Platform RMI server is exported.
     * @param theRmiBindAddress The textual representation of inet address
     */
    public void setRmiBindAddress(String theRmiBindAddress) {
        rmiBindAddress = theRmiBindAddress;
    }
    /**
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 45f59bb^:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

                if (rmiBindAddress != null) {
                    throw new IllegalStateException(sm.getString(
                            "jmxRemoteLifecycleListener.sslRmiBindAddress"));
                }
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 45f59bb^:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

            // Force server bind address if required
            if (rmiBindAddress != null) {
                try {
                    ssf = new RmiServerBindSocketFactory(
                            InetAddress.getByName(rmiBindAddress));
                } catch (UnknownHostException e) {
                    log.error(sm.getString(
                            "jmxRemoteLifecycleListener.invalidRmiBindAddress",
                            rmiBindAddress), e);
                }
            }
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 45f59bb^:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

                    rmiServerPortPlatform, env,
======= fetch "private JMXConnectorServer createServer(String serverName," 45f59bb^:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

            HashMap<String,Object> theEnv, MBeanServer theMBeanServer) {
======= fetch "private JMXConnectorServer createServer(String serverName," 45f59bb^:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

            LocateRegistry.createRegistry(theRmiRegistryPort);
======= fetch "private void destroyServer(String serverName," 45f59bb^:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

    implements RMIClientSocketFactory, Serializable {
======= fetch "public Socket createSocket(String host, int port) throws IOException {" 45f59bb^:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

    }
    public static class RmiServerBindSocketFactory
            implements RMIServerSocketFactory {
======= fetch "public Socket createSocket(String host, int port) throws IOException {" 45f59bb^:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

        private final InetAddress bindAddress;
======= fetch "public Socket createSocket(String host, int port) throws IOException {" 45f59bb^:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

        public RmiServerBindSocketFactory(InetAddress address) {
            bindAddress = address;
        }
        @Override
        public ServerSocket createServerSocket(int port) throws IOException  {
            return new ServerSocket(port, 0, bindAddress);
        }
      <attribute name="rmiBindAddress" required="false">
        <p>The address of the interface to be used by JMX/RMI server. Setting
        this option to <code>true</code> is incompatible with setting the system
        property <code>com.sun.management.jmxremote.ssl</code> to
        <code>true</code>.</p>
      </attribute>

======= fetch "public void testProgrammaticEndPoints() throws Exception{" d71136a^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

                ((MsgString) client.received.peek()).getData());
======= fetch "public void onMessage(MsgString in) {" d71136a^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

                MsgString msg = new MsgString();
                msg.setData(MESSAGE_ONE);
======= fetch "public ByteBuffer encode(MsgByte msg) throws EncodeException {" d71136a^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            reply.flip();
======= fetch "public MsgByte decode(ByteBuffer bb) throws DecodeException {" d71136a^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            bb.position(bb.position() + 2);

======= fetch "public void addElement(CharArrayWriter buf, Date date, Request request," 7aea9cb^:"java/org/apache/catalina/valves/AccessLogValve.java"

     * write time until first byte is written (commit time) in millis - %F
     */
    protected static class FirstByteTimeElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request, Response response, long time) {
            long commitTime = response.getCoyoteResponse().getCommitTime();
            if (commitTime == -1) {
                buf.append('-');
            } else {
                long delta = commitTime - request.getCoyoteRequest().getStartTime();
                buf.append(Long.toString(delta));
            }
        }
    }
    /**
======= fetch "protected AccessLogElement createAccessLogElement(char pattern) {" 7aea9cb^:"java/org/apache/catalina/valves/AccessLogValve.java"

        case 'F':
            return new FirstByteTimeElement();
    private long commitTime = -1;
======= fetch "public void setCommitted(boolean v) {" 7aea9cb^:"java/org/apache/coyote/Response.java"

        if (v && !this.commited) {
            this.commitTime = System.currentTimeMillis();
        }
======= fetch "public void setCommitted(boolean v) {" 7aea9cb^:"java/org/apache/coyote/Response.java"

    /**
     * Return the time the response was committed (based on System.currentTimeMillis).
     *
     * @return the time the response was committed
     */
    public long getCommitTime() {
        return commitTime;
    }
======= fetch "public void sendHeaders() {" 7aea9cb^:"java/org/apache/coyote/Response.java"

        commited = true;
======= fetch "public void recycle() {" 7aea9cb^:"java/org/apache/coyote/Response.java"

        commitTime = -1;
    <li><b>%F</b> - Time taken to commit the response, in millis</li>

======= fetch "protected void stopInternal() throws LifecycleException {" 3a36a8f^:"java/org/apache/catalina/core/StandardService.java"

        mapperListener.stop();
======= fetch "public void start() {" 3a36a8f^:"java/org/apache/catalina/startup/Catalina.java"

            log.error("Catalina.start: ", e);

======= fetch "protected void setSession(WsSession wsSession) {" 93bcdde^:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java"

    protected void setEncoders(List<Class<? extends Encoder>> encoders)
======= fetch "protected void setEncoders(List<Class<? extends Encoder>> encoders)" 93bcdde^:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java"

        for (Class<? extends Encoder> encoderClazz : encoders) {
======= fetch "protected void setEncoders(List<Class<? extends Encoder>> encoders)" 93bcdde^:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java"

                instance.init(endpointConfig);
======= fetch "private Encoder findEncoder(Object obj) {" 93bcdde^:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java"

    protected final void close() {
        for (EncoderEntry entry : encoderEntries) {
            entry.getEncoder().destroy();
        }
        doClose();
    }
======= fetch "private Encoder findEncoder(Object obj) {" 93bcdde^:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java"

    protected abstract void close();
======= fetch "protected void doWrite(SendHandler handler, ByteBuffer... data) {" 93bcdde^:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplClient.java"

    protected void close() {
======= fetch "public WsSession(Endpoint localEndpoint," 93bcdde^:"java/org/apache/tomcat/websocket/WsSession.java"

            boolean secure, List<Class<? extends Encoder>> encoders,
            Map<String,Object> userProperties)
======= fetch "public WsSession(Endpoint localEndpoint," 93bcdde^:"java/org/apache/tomcat/websocket/WsSession.java"

        this.wsRemoteEndpoint.setEncoders(encoders);
======= fetch "public WsSession(Endpoint localEndpoint," 93bcdde^:"java/org/apache/tomcat/websocket/WsSession.java"

        this.userProperties.putAll(userProperties);
======= fetch "public Session connectToServer(Endpoint endpoint," 93bcdde^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

                clientEndpointConfiguration.getEncoders(),
                clientEndpointConfiguration.getUserProperties());
======= fetch "public void init(WebConnection connection) {" 93bcdde^:"java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java"

                    pathParameters, secure, endpointConfig.getEncoders(),
                    endpointConfig.getUserProperties());
======= fetch "public void onWritePossible() {" 93bcdde^:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

    protected void close() {
======= fetch "public void test() throws Exception {" 93bcdde^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

        session.close();
        Thread.sleep(100);
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgStringEncoder.class.getName()+":init"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgStringDecoder.class.getName()+":init"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgByteEncoder.class.getName()+":init"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgByteDecoder.class.getName()+":init"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgStringEncoder.class.getName()+":destroy"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgStringDecoder.class.getName()+":destroy"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgByteEncoder.class.getName()+":destroy"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgByteDecoder.class.getName()+":destroy"));
======= fetch "public void  rx(MsgByte in) {" 93bcdde^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

        static HashMap<String, Boolean> lifeCyclesCalled = new HashMap<>(8);
======= fetch "public MsgByte rx(MsgByte in) {" 93bcdde^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

        public static void addLifeCycleEvent(String event){
            lifeCyclesCalled.put(event, Boolean.TRUE);
        }
        public static boolean isLifeCycleEventCalled(String event){
            Boolean called = lifeCyclesCalled.get(event);
            return called == null ? false : called.booleanValue();
        }
======= fetch "public void init(EndpointConfig endpointConfig) {" 93bcdde^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            // NO-OP
======= fetch "public void destroy() {" 93bcdde^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            // NO-OP
======= fetch "public void init(EndpointConfig endpointConfig) {" 93bcdde^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            // NO-OP
======= fetch "public void destroy() {" 93bcdde^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            // NO-OP
======= fetch "public void init(EndpointConfig endpointConfig) {" 93bcdde^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            // NO-OP
======= fetch "public void destroy() {" 93bcdde^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            // NO-OP
======= fetch "public void init(EndpointConfig endpointConfig) {" 93bcdde^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            // NO-OP
======= fetch "public void destroy() {" 93bcdde^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            // NO-OP

======= fetch "public MessageMethod(Method m, List<DecoderEntry> decoderEntries) {" 366ddff^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                    boolean foundBinaryDecoderMatch = false;
                    boolean foundTextDecoderMatch = false;
======= fetch "public MessageMethod(Method m, List<DecoderEntry> decoderEntries) {" 366ddff^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                                if (indexByteBuffer == -1) {
                                    indexByteBuffer = i;
                                } else {
                                    throw new IllegalArgumentException(sm.getString(
                                            "pojoMethodMapping.duplicateMessageParam",
                                            m.getName(), m.getDeclaringClass().getName()));
======= fetch "public MessageMethod(Method m, List<DecoderEntry> decoderEntries) {" 366ddff^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                                break;
======= fetch "public MessageMethod(Method m, List<DecoderEntry> decoderEntries) {" 366ddff^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                                if (indexString == -1) {
                                    indexString = i;
                                } else {
                                    throw new IllegalArgumentException(sm.getString(
                                            "pojoMethodMapping.duplicateMessageParam",
                                            m.getName(), m.getDeclaringClass().getName()));

    extends AuthenticatorBase {
======= fetch "either the original SSO logon was of DIGEST or SSL (which" c4a50f5^:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

        String username = null;
        String password = null;
======= fetch "either the original SSO logon was of DIGEST or SSL (which" c4a50f5^:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

            if (authorizationBC.startsWithIgnoreCase("basic ", 0)) {
                authorizationBC.setOffset(authorizationBC.getOffset() + 6);
                byte[] decoded = Base64.decodeBase64(
                        authorizationBC.getBuffer(),
                        authorizationBC.getOffset(),
                        authorizationBC.getLength());
                // Get username and password
                int colon = -1;
                for (int i = 0; i < decoded.length; i++) {
                    if (decoded[i] == ':') {
                        colon = i;
                        break;
                    }
                }
======= fetch "either the original SSO logon was of DIGEST or SSL (which" c4a50f5^:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

                if (colon < 0) {
                    username = new String(decoded, B2CConverter.ISO_8859_1);
                } else {
                    username = new String(
                            decoded, 0, colon, B2CConverter.ISO_8859_1);
                    password = new String(
                            decoded, colon + 1, decoded.length - colon - 1,
                            B2CConverter.ISO_8859_1);
======= fetch "either the original SSO logon was of DIGEST or SSL (which" c4a50f5^:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

                authorizationBC.setOffset(authorizationBC.getOffset() - 6);
======= fetch "either the original SSO logon was of DIGEST or SSL (which" c4a50f5^:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

            principal = context.getRealm().authenticate(username, password);
            if (principal != null) {
                register(request, response, principal,
                        HttpServletRequest.BASIC_AUTH, username, password);
                return (true);
======= fetch "either the original SSO logon was of DIGEST or SSL (which" c4a50f5^:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

        // the request could not be authenticated, so reissue the challenge
======= fetch "either the original SSO logon was of DIGEST or SSL (which" c4a50f5^:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

======= fetch "protected String getAuthMethod() {" c4a50f5^:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

    /**
     * Parser for an HTTP Authorization header for BASIC authentication
     * as per RFC 2617 section 2, and the Base64 encoded credentials as
     * per RFC 2045 section 6.8.
     */
    protected static class BasicCredentials {
        // the only authentication method supported by this parser
        // note: we include single white space as its delimiter
        private static final String METHOD = "basic ";
        private ByteChunk authorization;
        private int initialOffset;
        private int base64blobOffset;
        private int base64blobLength;
        private String username = null;
        private String password = null;
        /**
         * Parse the HTTP Authorization header for BASIC authentication
         * as per RFC 2617 section 2, and the Base64 encoded credentials
         * as per RFC 2045 section 6.8.
         *
         * @param input The header value to parse in-place
         *
         * @throws IllegalArgumentException If the header does not conform
         *                                  to RFC 2617
         */
        public BasicCredentials(ByteChunk input)
                throws IllegalArgumentException {
            authorization = input;
            initialOffset = input.getOffset();
            parseMethod();
            byte[] decoded = parseBase64();
            parseCredentials(decoded);
        }
        /**
         * Trivial accessor.
         *
         * @return  the decoded username token as a String, which is
         *          never be <code>null</code>, but can be empty.
         */
        public String getUsername() {
            return username;
        }
        /**
         * Trivial accessor.
         *
         * @return  the decoded password token as a String, or <code>null</code>
         *          if no password was found in the credentials.
         */
        public String getPassword() {
            return password;
        }
        /*
         * The authorization method string is case-insensitive and must
         * hae at least one space character as a delimiter.
         */
        private void parseMethod() throws IllegalArgumentException {
            if (authorization.startsWithIgnoreCase(METHOD, 0)) {
                // step past the auth method name
                base64blobOffset = initialOffset + METHOD.length();
                base64blobLength = authorization.getLength() - METHOD.length();
            }
            else {
                // is this possible, or permitted?
                throw new IllegalArgumentException(
                        "Authorization header method is not \"Basic\"");
            }
        }
        /*
         * Decode the base64-user-pass token, which RFC 2617 states
         * can be longer than the 76 characters per line limit defined
         * in RFC 2045. The base64 decoder will ignore embedded line
         * break characters as well as surplus surrounding white space.
         */
        private byte[] parseBase64() throws IllegalArgumentException {
            byte[] decoded = Base64.decodeBase64(
                        authorization.getBuffer(),
                        base64blobOffset, base64blobLength);
            //  restore original offset
            authorization.setOffset(initialOffset);
            if (decoded == null) {
                throw new IllegalArgumentException(
                        "Basic Authorization credentials are not Base64");
            }
            return decoded;
        }
        /*
         * Extract the mandatory username token and separate it from the
         * optional password token. Tolerate surplus surrounding white space.
         */
        private void parseCredentials(byte[] decoded)
                throws IllegalArgumentException {
            int colon = -1;
            for (int i = 0; i < decoded.length; i++) {
                if (decoded[i] == ':') {
                    colon = i;
                    break;
                }
            }
            if (colon < 0) {
                username = new String(decoded, B2CConverter.ISO_8859_1);
                // password will remain null!
            }
            else {
                username = new String(
                            decoded, 0, colon, B2CConverter.ISO_8859_1);
                password = new String(
                            decoded, colon + 1, decoded.length - colon - 1,
                            B2CConverter.ISO_8859_1);
                // tolerate surplus white space around credentials
                if (password.length() > 1) {
                    password = password.trim();
                }
            }
            // tolerate surplus white space around credentials
            if (username.length() > 1) {
                username = username.trim();
            }
        }
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Test the BasicAuthenticator's BasicCredentials inner class and the
 * associated Base64 decoder.
 */
    private static final String NICE_METHOD = "Basic";
    private static final String USER_NAME = "userid";
    private static final String PASSWORD = "secret";
    /*
     * test cases with good BASIC Auth credentials - Base64 strings
     * can have zero, one or two trailing pad characters
     */
    @Test
    public void testGoodCredentials() throws Exception {
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    @Test
    public void testGoodCredentialsNoPassword() throws Exception {
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, null);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertNull(credentials.getPassword());
    }
    @Test
    public void testGoodCrib() throws Exception {
        final String BASE64_CRIB = "dXNlcmlkOnNlY3JldA==";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    @Test
    public void testGoodCribUserOnly() throws Exception {
        final String BASE64_CRIB = "dXNlcmlk";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertNull(credentials.getPassword());
    }
    @Test
    public void testGoodCribOnePad() throws Exception {
        final String PASSWORD1 = "secrets";
        final String BASE64_CRIB = "dXNlcmlkOnNlY3JldHM=";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD1, credentials.getPassword());
    }
    /*
     * RFC 2045 says the Base64 encoded string should be represented
     * as lines of no more than 76 characters. However, RFC 2617
     * says a base64-user-pass token is not limited to 76 char/line.
     * It also says all line breaks, including mandatory ones,
     * should be ignored during decoding.
     * This test case has a line break in the Base64 string.
     * (See also testGoodCribBase64Big below).
     */
    @Test
    public void testGoodCribLineWrap() throws Exception {
        final String USER_LONG = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                + "abcdefghijklmnopqrstuvwxyz0123456789+/AAAABBBBCCCC"
                + "DDDD";                   // 80 characters
        final String BASE64_CRIB = "QUJDREVGR0hJSktMTU5PUFFSU1RVVldY"
                + "WVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0"
                + "\n" + "NTY3ODkrL0FBQUFCQkJCQ0NDQ0REREQ=";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_LONG, credentials.getUsername());
    }
    /*
     * RFC 2045 says the Base64 encoded string should be represented
     * as lines of no more than 76 characters. However, RFC 2617
     * says a base64-user-pass token is not limited to 76 char/line.
     */
    @Test
    public void testGoodCribBase64Big() throws Exception {
        // Our decoder accepts a long token without complaint.
        final String USER_LONG = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                + "abcdefghijklmnopqrstuvwxyz0123456789+/AAAABBBBCCCC"
                + "DDDD";                   // 80 characters
        final String BASE64_CRIB = "QUJDREVGR0hJSktMTU5PUFFSU1RVVldY"
                + "WVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0"
                + "NTY3ODkrL0FBQUFCQkJCQ0NDQ0REREQ="; // no new line
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_LONG, credentials.getUsername());
    }
    /*
     * verify the parser follows RFC2617 by treating the auth-scheme
     * token as case-insensitive.
     */
    @Test
    public void testAuthMethodCaseBasic() throws Exception {
        final String METHOD = "bAsIc";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(METHOD, USER_NAME, PASSWORD);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * Confirm the Basic parser rejects an invalid authentication method.
     */
    @Test
    public void testAuthMethodBadMethod() throws Exception {
        final String METHOD = "BadMethod";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(METHOD, USER_NAME, PASSWORD);
        @SuppressWarnings("unused")
        BasicAuthenticator.BasicCredentials credentials = null;
        try {
            credentials = new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
            Assert.fail("IllegalArgumentException expected");
        }
        catch (Exception e) {
            Assert.assertTrue(e instanceof IllegalArgumentException);
            Assert.assertTrue(e.getMessage().contains("header method"));
        }
    }
    /*
     * Confirm the Basic parser tolerates excess white space after
     * the authentication method.
     *
     * RFC2617 does not define the separation syntax between the auth-scheme
     * and basic-credentials tokens. Tomcat tolerates any amount of white
     * (within the limits of HTTP header sizes).
     */
    @Test
    public void testAuthMethodExtraLeadingSpace() throws Exception {
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD + " ", USER_NAME, PASSWORD);
        final BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * invalid decoded credentials cases
     */
    @Test
    public void testWrongPassword() throws Exception {
        final String PWD_WRONG = "wrong";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PWD_WRONG);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertNotSame(PASSWORD, credentials.getPassword());
    }
    @Test
    public void testMissingUsername() throws Exception {
        final String EMPTY_USER_NAME = "";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, EMPTY_USER_NAME, PASSWORD);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(EMPTY_USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    @Test
    public void testShortUsername() throws Exception {
        final String SHORT_USER_NAME = "a";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, SHORT_USER_NAME, PASSWORD);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(SHORT_USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    @Test
    public void testShortPassword() throws Exception {
        final String SHORT_PASSWORD = "a";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, SHORT_PASSWORD);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(SHORT_PASSWORD, credentials.getPassword());
    }
    @Test
    public void testPasswordHasSpaceEmbedded() throws Exception {
        final String PASSWORD_SPACE = "abc def";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD_SPACE);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD_SPACE, credentials.getPassword());
    }
    @Test
    public void testPasswordHasColonEmbedded() throws Exception {
        final String PASSWORD_COLON = "abc:def";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD_COLON);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD_COLON, credentials.getPassword());
    }
    @Test
    public void testPasswordHasColonLeading() throws Exception {
        final String PASSWORD_COLON = ":abcdef";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD_COLON);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD_COLON, credentials.getPassword());
    }
    @Test
    public void testPasswordHasColonTrailing() throws Exception {
        final String PASSWORD_COLON = "abcdef:";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD_COLON);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD_COLON, credentials.getPassword());
    }
    /*
     * Confirm the Basic parser tolerates excess white space after
     * the base64 blob.
     *
     * RFC2617 does not define this case, but asks servers to be
     * tolerant of this kind of client deviation.
     */
    @Test
    public void testAuthMethodExtraTrailingSpace() throws Exception {
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD, "    ");
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * Confirm the Basic parser tolerates excess white space around
     * the username inside the base64 blob.
     *
     * RFC2617 does not define the separation syntax between the auth-scheme
     * and basic-credentials tokens. Tomcat should tolerate any reasonable
     * amount of white space.
     */
    @Test
    public void testUserExtraSpace() throws Exception {
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, " " + USER_NAME + " ", PASSWORD);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * Confirm the Basic parser tolerates excess white space around
     * the username within the base64 blob.
     *
     * RFC2617 does not define the separation syntax between the auth-scheme
     * and basic-credentials tokens. Tomcat should tolerate any reasonable
     * amount of white space.
     */
    @Test
    public void testPasswordExtraSpace() throws Exception {
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, " " + PASSWORD + " ");
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                    AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * invalid base64 string tests
     *
     * Refer to RFC2045 section 6.8.
     */
    /*
     * non-trailing "=" should trigger premature termination of the
     * decoder, returning a truncated string that will eventually
     * result in an authentication Assert.failure.
     */
    @Test
    public void testBadBase64InlineEquals() throws Exception {
        final String BASE64_CRIB = "dXNlcmlkOnNlY3J=dAo=";
        final String TRUNCATED_PWD = "secr";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                    AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertNotSame(PASSWORD, credentials.getPassword());
        Assert.assertEquals(TRUNCATED_PWD, credentials.getPassword());
    }
    /*
     * "-" is not a legal base64 character. The RFC says it must be
     * ignored by the decoder. This will scramble the decoded string
     * and eventually result in an authentication Assert.failure.
     */
    @Test
    public void testBadBase64Char() throws Exception {
        final String BASE64_CRIB = "dXNlcmlkOnNl-3JldHM=";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                    AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertNotSame(PASSWORD, credentials.getPassword());
    }
    /*
     * "-" is not a legal base64 character. The RFC says it must be
     * ignored by the decoder. This is a very strange case because the
     * next character is a pad, which terminates the string normally.
     * It is likely (but not certain) the decoded password will be
     * damaged and subsequent authentication will fail.
     */
    @Test
    public void testBadBase64LastChar() throws Exception {
        final String BASE64_CRIB = "dXNlcmlkOnNlY3JldA-=";
        final String POSSIBLY_DAMAGED_PWD = "secret";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                    AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(POSSIBLY_DAMAGED_PWD, credentials.getPassword());
    }
    /*
     * The trailing third "=" is illegal. However, the RFC says the decoder
     * must terminate as soon as the first pad is detected, so no error
     * will be detected unless the payload has been damaged in some way.
     */
    @Test
    public void testBadBase64TooManyEquals() throws Exception {
        final String BASE64_CRIB = "dXNlcmlkOnNlY3JldA===";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                    AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * there should be a multiple of 4 encoded characters. However,
     * the RFC says the decoder should pad the input string with
     * zero bits out to the next boundary. An error will not be detected
     * unless the payload has been damaged in some way - this
     * particular crib has no damage.
     */
    @Test
    public void testBadBase64BadLength() throws Exception {
        final String BASE64_CRIB = "dXNlcmlkOnNlY3JldA";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                    AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * Encapsulate the logic to generate an HTTP header
     * for BASIC Authentication.
     * Note: only used internally, so no need to validate arguments.
     */
    private final class BasicAuthHeader {
        private  final String HTTP_AUTH = "authorization: ";
        private  final byte[] HEADER =
                HTTP_AUTH.getBytes(B2CConverter.ISO_8859_1);
        private ByteChunk authHeader;
        private int initialOffset = 0;
        /*
         * This method creates a valid base64 blob
         */
        private BasicAuthHeader(String method, String username,
                String password) {
            this(method, username, password, null);
        }
        /*
         * This method creates valid base64 blobs with optional trailing data
         */
        private BasicAuthHeader(String method, String username,
                String password, String extraBlob) {
            prefix(method);
            String userCredentials =
                    ((password == null) || (password.length() < 1))
                    ? username
                    : username + ":" + password;
            byte[] credentialsBytes =
                    userCredentials.getBytes(B2CConverter.ISO_8859_1);
            String base64auth = Base64.encodeBase64String(credentialsBytes);
            byte[] base64Bytes =
                    base64auth.getBytes(B2CConverter.ISO_8859_1);
            byte[] extraBytes =
                    ((extraBlob == null) || (extraBlob.length() < 1))
                    ? null :
                    extraBlob.getBytes(B2CConverter.ISO_8859_1);
            try {
                authHeader.append(base64Bytes, 0, base64Bytes.length);
                if (extraBytes != null) {
                    authHeader.append(extraBytes, 0, extraBytes.length);
                }
            }
            catch (IOException ioe) {
                throw new IllegalStateException("unable to extend ByteChunk:"
                        + ioe.getMessage());
            }
            // emulate tomcat server - offset points to method in header
            authHeader.setOffset(initialOffset);
        }
        /*
         * This method allows injection of cribbed base64 blobs,
         * without any validation of the contents
         */
        private BasicAuthHeader(String method, String fakeBase64) {
            prefix(method);
            byte[] fakeBytes = fakeBase64.getBytes(B2CConverter.ISO_8859_1);
            try {
                authHeader.append(fakeBytes, 0, fakeBytes.length);
            }
            catch (IOException ioe) {
                throw new IllegalStateException("unable to extend ByteChunk:"
                        + ioe.getMessage());
            }
            // emulate tomcat server - offset points to method in header
            authHeader.setOffset(initialOffset);
        }
        /*
         * construct the common authorization header
         */
        private void prefix(String method) {
            authHeader = new ByteChunk();
            authHeader.setBytes(HEADER, 0, HEADER.length);
            initialOffset = HEADER.length;
            String methodX = method + " ";
            byte[] methodBytes = methodX.getBytes(B2CConverter.ISO_8859_1);
            try {
                authHeader.append(methodBytes, 0, methodBytes.length);
            }
            catch (IOException ioe) {
                throw new IllegalStateException("unable to extend ByteChunk:"
                        + ioe.getMessage());
            }
        }
        private ByteChunk getHeader() {
            return authHeader;
        }
    }
======= fetch "public void testAuthMethodExtraSpace() throws Exception {" c4a50f5^:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

     * using white space around the username credential.
     *
     * The request is rejected with 401 SC_UNAUTHORIZED status.
     *
     * TODO: RFC2617 does not define the separation syntax between the
     *       auth-scheme and basic-credentials tokens. Tomcat should tolerate
     *       any reasonable amount of white space and return SC_OK.
======= fetch "public void testUserExtraSpace() throws Exception {" c4a50f5^:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                NO_COOKIES, HttpServletResponse.SC_UNAUTHORIZED);
======= fetch "public void testUserExtraSpace() throws Exception {" c4a50f5^:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

     * using white space around the password credential.
     *
     * The request is rejected with 401 SC_UNAUTHORIZED status.
     *
     * TODO: RFC2617 does not define the separation syntax between the
     *       auth-scheme and basic-credentials tokens. Tomcat should tolerate
     *       any reasonable amount of white space and return SC_OK.
======= fetch "public void testPasswordExtraSpace() throws Exception {" c4a50f5^:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                NO_COOKIES, HttpServletResponse.SC_UNAUTHORIZED);

======= fetch "private void process(JarScannerCallback callback, URL url, boolean isWebapp)" c7c30b6^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

            if (urlStr.startsWith("file:") || urlStr.startsWith("jndi:")) {

======= fetch "protected synchronized void startInternal() throws LifecycleException {" f78c1a4^:"java/org/apache/catalina/core/StandardContext.java"

            // Check constraints for uncovered HTTP methods
            // Needs to be after SCIs and listeners as they may programatically
            // change constraints
            if (ok) {
                checkConstraintsForUncoveredMethods();
            }
======= fetch "protected synchronized void startInternal() throws LifecycleException {" f78c1a4^:"java/org/apache/catalina/core/StandardContext.java"

    private void checkConstraintsForUncoveredMethods() {
        // TODO - Add an option to lower the log level of any uncovered method
        //        warnings to debug
        // TODO - Implement adding constraints to deny uncovered methods
        Set<String> coveredPatterns = new HashSet<>();
        Map<String,Set<String>> urlMethodMap = new HashMap<>();
        Map<String,Set<String>> urlOmittedMethodMap = new HashMap<>();
        // First build the lists of covered patterns and those patterns that
        // might be uncovered
        for (SecurityConstraint constraint : constraints) {
            SecurityCollection[] collections = constraint.findCollections();
            for (SecurityCollection collection : collections) {
                String[] patterns = collection.findPatterns();
                String[] methods = collection.findMethods();
                String[] omittedMethods = collection.findOmittedMethods();
                // Simple case: no methods
                if (methods.length == 0 && omittedMethods.length == 0) {
                    for (String pattern : patterns) {
                        coveredPatterns.add(pattern);
                    }
                    continue;
                }
                // Pre-calculate so we don't do this for every iteration of the
                // following loop
                List<String> omNew = null;
                if (omittedMethods.length == 0) {
                    omNew = Arrays.asList(omittedMethods);
                }
                // Only need to process uncovered patterns
                for (String pattern : patterns) {
                    if (!coveredPatterns.contains(pattern)) {
                        if (methods.length == 0) {
                            // Build the interset of omitted methods for this
                            // pattern
                            Set<String> om = urlOmittedMethodMap.get(pattern);
                            if (om == null) {
                                om = new HashSet<>();
                                urlMethodMap.put(pattern, om);
                            }
                            om.retainAll(omNew);
                        } else {
                            // Build the union of methods for this pattern
                            Set<String> m = urlMethodMap.get(pattern);
                            if (m == null) {
                                m = new HashSet<>();
                                urlMethodMap.put(pattern, m);
                            }
                            for (String method : methods) {
                                m.add(method);
                            }
                        }
                    }
                }
            }
        }
        // Now check the potentially uncovered patterns
        for (Map.Entry<String, Set<String>> entry : urlMethodMap.entrySet()) {
            String pattern = entry.getKey();
            if (coveredPatterns.contains(pattern)) {
                // Fully covered. Ignore any partial coverage
                urlOmittedMethodMap.remove(pattern);
                continue;
            }
            Set<String> omittedMethods = urlOmittedMethodMap.get(pattern);
            Set<String> methods = entry.getValue();
            if (omittedMethods == null) {
                StringBuilder msg = new StringBuilder();
                for (String method : methods) {
                    msg.append(method);
                    msg.append(' ');
                }
                log.error(sm.getString("standardContext.uncoveredHttpMethod",
                        pattern, msg.toString().trim()));
                continue;
            }
            // As long as every omitted method as a corresponding method the
            // pattern is fully covered.
            omittedMethods.removeAll(methods);
            if (omittedMethods.size() > 0) {
                StringBuilder msg = new StringBuilder();
                for (String method : omittedMethods) {
                    msg.append(method);
                    msg.append(' ');
                }
                log.error(sm.getString(
                        "standardContext.uncoveredHttpOmittedMethod",
                        pattern, msg.toString().trim()));
            }
        }
    }

======= fetch "private boolean isExpression(Node n, String value, boolean checkDeferred) {" 3e2ceee^:"java/org/apache/jasper/compiler/Validator.java"

                            break;
======= fetch "private boolean isExpression(Node n, String value, boolean checkDeferred) {" 3e2ceee^:"java/org/apache/jasper/compiler/Validator.java"

                            break;

======= fetch "public boolean inSet(Member m, Member[] set) {" 4979721^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            for (int j=0; j<mbrs.length; j++ )

======= fetch "private boolean isLocked(String path, String ifHeader) {" 82bccd2^:"java/org/apache/catalina/servlets/WebdavServlet.java"

                if (ifHeader.indexOf(token) != -1)
======= fetch "private boolean isLocked(String path, String ifHeader) {" 82bccd2^:"java/org/apache/catalina/servlets/WebdavServlet.java"

                    break;
                }
======= fetch "private boolean isLocked(String path, String ifHeader) {" 82bccd2^:"java/org/apache/catalina/servlets/WebdavServlet.java"

                    if (ifHeader.indexOf(token) != -1)
======= fetch "private boolean isLocked(String path, String ifHeader) {" 82bccd2^:"java/org/apache/catalina/servlets/WebdavServlet.java"

                        break;
                    }

======= fetch "private void doTestBasic(String uri, BasicCredentials credentials," c48a2ed^:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                        break;
======= fetch "public void testSessionExpiryContainer() throws Exception {" c48a2ed^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                    break;

======= fetch "public String getProperty(String name) {" 99562d3^:"java/org/apache/juli/ClassLoaderLogManager.java"

        ClassLoader classLoader = Thread.currentThread()
            .getContextClassLoader();
======= fetch "public String getProperty(String name) {" 99562d3^:"java/org/apache/juli/ClassLoaderLogManager.java"

        String result = null;
        // If a prefix is defined look for a prefixed property first
======= fetch "public String getProperty(String name) {" 99562d3^:"java/org/apache/juli/ClassLoaderLogManager.java"

            name = prefix + name;
======= fetch "public String getProperty(String name) {" 99562d3^:"java/org/apache/juli/ClassLoaderLogManager.java"

        return result;
    }
    private String findProperty(String name) {
        ClassLoader classLoader = Thread.currentThread()
                .getContextClassLoader();
======= fetch "public String getProperty(String name) {" 99562d3^:"java/org/apache/juli/ClassLoaderLogManager.java"

        // Simple property replacement (mostly for folder names)
        if (result != null) {
            result = replace(result);
        }
======= fetch "public String getProperty(String name) {" 99562d3^:"java/org/apache/juli/ClassLoaderLogManager.java"


 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * <p>
 * A {@link Filter} that enable client-side cross-origin requests by
 * implementing W3C's CORS (<b>C</b>ross-<b>O</b>rigin <b>R</b>esource
 * <b>S</b>haring) specification for resources. Each {@link HttpServletRequest}
 * request is inspected as per specification, and appropriate response headers
 * are added to {@link HttpServletResponse}.
 * </p>
 *
 * <p>
 * By default, it also sets following request attributes, that help to
 * determine the nature of the request downstream.
 * <ul>
 * <li><b>cors.isCorsRequest:</b> Flag to determine if the request is a CORS
 * request. Set to <code>true</code> if a CORS request; <code>false</code>
 * otherwise.</li>
 * <li><b>cors.request.origin:</b> The Origin URL, i.e. the URL of the page from
 * where the request is originated.</li>
 * <li>
 * <b>cors.request.type:</b> Type of request. Possible values:
 * <ul>
 * <li>SIMPLE: A request which is not preceded by a pre-flight request.</li>
 * <li>ACTUAL: A request which is preceded by a pre-flight request.</li>
 * <li>PRE_FLIGHT: A pre-flight request.</li>
 * <li>NOT_CORS: A normal same-origin request.</li>
 * <li>INVALID_CORS: A cross-origin request which is invalid.</li>
 * </ul>
 * </li>
 * <li><b>cors.request.headers:</b> Request headers sent as
 * 'Access-Control-Request-Headers' header, for pre-flight request.</li>
 * </ul>
 * </p>
 *
 * @see <a href="http://www.w3.org/TR/cors/">CORS specification</a>
 *
 */
    private static final Log log = LogFactory.getLog(CorsFilter.class);
    private static final StringManager sm =
            StringManager.getManager(Constants.Package);
    /**
     * A {@link Collection} of origins consisting of zero or more origins that
     * are allowed access to the resource.
     */
    private final Collection<String> allowedOrigins;
    /**
     * Determines if any origin is allowed to make request.
     */
    private boolean anyOriginAllowed;
    /**
     * A {@link Collection} of methods consisting of zero or more methods that
     * are supported by the resource.
     */
    private final Collection<String> allowedHttpMethods;
    /**
     * A {@link Collection} of headers consisting of zero or more header field
     * names that are supported by the resource.
     */
    private final Collection<String> allowedHttpHeaders;
    /**
     * A {@link Collection} of exposed headers consisting of zero or more header
     * field names of headers other than the simple response headers that the
     * resource might use and can be exposed.
     */
    private final Collection<String> exposedHeaders;
    /**
     * A supports credentials flag that indicates whether the resource supports
     * user credentials in the request. It is true when the resource does and
     * false otherwise.
     */
    private boolean supportsCredentials;
    /**
     * Indicates (in seconds) how long the results of a pre-flight request can
     * be cached in a pre-flight result cache.
     */
    private long preflightMaxAge;
    /**
     * Determines if the request should be decorated or not.
     */
    private boolean decorateRequest;
    public CorsFilter() {
        this.allowedOrigins = new HashSet<>();
        this.allowedHttpMethods = new HashSet<>();
        this.allowedHttpHeaders = new HashSet<>();
        this.exposedHeaders = new HashSet<>();
    }
    @Override
    public void doFilter(final ServletRequest servletRequest,
            final ServletResponse servletResponse, final FilterChain filterChain)
            throws IOException, ServletException {
        if (!(servletRequest instanceof HttpServletRequest) ||
                !(servletResponse instanceof HttpServletResponse)) {
            throw new ServletException(sm.getString("corsFilter.onlyHttp"));
        }
        // Safe to downcast at this point.
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        // Determines the CORS request type.
        CorsFilter.CORSRequestType requestType = checkRequestType(request);
        // Adds CORS specific attributes to request.
        if (decorateRequest) {
            CorsFilter.decorateCORSProperties(request, requestType);
        }
        switch (requestType) {
        case SIMPLE:
            // Handles a Simple CORS request.
            this.handleSimpleCORS(request, response, filterChain);
            break;
        case ACTUAL:
            // Handles an Actual CORS request.
            this.handleSimpleCORS(request, response, filterChain);
            break;
        case PRE_FLIGHT:
            // Handles a Pre-flight CORS request.
            this.handlePreflightCORS(request, response, filterChain);
            break;
        case NOT_CORS:
            // Handles a Normal request that is not a cross-origin request.
            this.handleNonCORS(request, response, filterChain);
            break;
        default:
            // Handles a CORS request that violates specification.
            this.handleInvalidCORS(request, response, filterChain);
            break;
        }
    }
    @Override
    public void init(final FilterConfig filterConfig) throws ServletException {
        // Initialize defaults
        parseAndStore(DEFAULT_ALLOWED_ORIGINS, DEFAULT_ALLOWED_HTTP_METHODS,
                DEFAULT_ALLOWED_HTTP_HEADERS, DEFAULT_EXPOSED_HEADERS,
                DEFAULT_SUPPORTS_CREDENTIALS, DEFAULT_PREFLIGHT_MAXAGE,
                DEFAULT_DECORATE_REQUEST);
        if (filterConfig != null) {
            String configAllowedOrigins = filterConfig
                    .getInitParameter(PARAM_CORS_ALLOWED_ORIGINS);
            String configAllowedHttpMethods = filterConfig
                    .getInitParameter(PARAM_CORS_ALLOWED_METHODS);
            String configAllowedHttpHeaders = filterConfig
                    .getInitParameter(PARAM_CORS_ALLOWED_HEADERS);
            String configExposedHeaders = filterConfig
                    .getInitParameter(PARAM_CORS_EXPOSED_HEADERS);
            String configSupportsCredentials = filterConfig
                    .getInitParameter(PARAM_CORS_SUPPORT_CREDENTIALS);
            String configPreflightMaxAge = filterConfig
                    .getInitParameter(PARAM_CORS_PREFLIGHT_MAXAGE);
            String configDecorateRequest = filterConfig
                    .getInitParameter(PARAM_CORS_REQUEST_DECORATE);
            parseAndStore(configAllowedOrigins, configAllowedHttpMethods,
                    configAllowedHttpHeaders, configExposedHeaders,
                    configSupportsCredentials, configPreflightMaxAge,
                    configDecorateRequest);
        }
    }
    /**
     * Handles a CORS request of type {@link CORSRequestType}.SIMPLE.
     *
     * @param request
     *            The {@link HttpServletRequest} object.
     * @param response
     *            The {@link HttpServletResponse} object.
     * @param filterChain
     *            The {@link FilterChain} object.
     * @throws IOException
     * @throws ServletException
     * @see <a href="http://www.w3.org/TR/cors/#resource-requests">Simple
     *      Cross-Origin Request, Actual Request, and Redirects</a>
     */
    protected void handleSimpleCORS(final HttpServletRequest request,
            final HttpServletResponse response, final FilterChain filterChain)
            throws IOException, ServletException {
        CorsFilter.CORSRequestType requestType = checkRequestType(request);
        if (!(requestType == CorsFilter.CORSRequestType.SIMPLE ||
                requestType == CorsFilter.CORSRequestType.ACTUAL)) {
            throw new IllegalArgumentException(
                    sm.getString("corsFilter.wrongType2",
                            CorsFilter.CORSRequestType.SIMPLE,
                            CorsFilter.CORSRequestType.ACTUAL));
        }
        final String origin = request
                .getHeader(CorsFilter.REQUEST_HEADER_ORIGIN);
        final String method = request.getMethod();
        // Section 6.1.2
        if (!isOriginAllowed(origin)) {
            handleInvalidCORS(request, response, filterChain);
            return;
        }
        if (!allowedHttpMethods.contains(method)) {
            handleInvalidCORS(request, response, filterChain);
            return;
        }
        // Section 6.1.3
        // Add a single Access-Control-Allow-Origin header.
        if (anyOriginAllowed && !supportsCredentials) {
            // If resource doesn't support credentials and if any origin is
            // allowed
            // to make CORS request, return header with '*'.
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,
                    "*");
        } else {
            // If the resource supports credentials add a single
            // Access-Control-Allow-Origin header, with the value of the Origin
            // header as value.
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,
                    origin);
        }
        // Section 6.1.3
        // If the resource supports credentials, add a single
        // Access-Control-Allow-Credentials header with the case-sensitive
        // string "true" as value.
        if (supportsCredentials) {
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS,
                    "true");
        }
        // Section 6.1.4
        // If the list of exposed headers is not empty add one or more
        // Access-Control-Expose-Headers headers, with as values the header
        // field names given in the list of exposed headers.
        if ((exposedHeaders != null) && (exposedHeaders.size() > 0)) {
            String exposedHeadersString = join(exposedHeaders, ",");
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS,
                    exposedHeadersString);
        }
        // Forward the request down the filter chain.
        filterChain.doFilter(request, response);
    }
    /**
     * Handles CORS pre-flight request.
     *
     * @param request
     *            The {@link HttpServletRequest} object.
     * @param response
     *            The {@link HttpServletResponse} object.
     * @param filterChain
     *            The {@link FilterChain} object.
     * @throws IOException
     * @throws ServletException
     */
    protected void handlePreflightCORS(final HttpServletRequest request,
            final HttpServletResponse response, final FilterChain filterChain)
            throws IOException, ServletException {
        CORSRequestType requestType = checkRequestType(request);
        if (requestType != CORSRequestType.PRE_FLIGHT) {
            throw new IllegalArgumentException(
                    sm.getString("corsFilter.wrongType1",
                            CORSRequestType.PRE_FLIGHT.name().toLowerCase()));
        }
        final String origin = request
                .getHeader(CorsFilter.REQUEST_HEADER_ORIGIN);
        // Section 6.2.2
        if (!isOriginAllowed(origin)) {
            handleInvalidCORS(request, response, filterChain);
            return;
        }
        // Section 6.2.3
        String accessControlRequestMethod = request.getHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD);
        if (accessControlRequestMethod == null ||
                !HTTP_METHODS.contains(accessControlRequestMethod.trim())) {
            handleInvalidCORS(request, response, filterChain);
            return;
        } else {
            accessControlRequestMethod = accessControlRequestMethod.trim();
        }
        // Section 6.2.4
        String accessControlRequestHeadersHeader = request.getHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS);
        List<String> accessControlRequestHeaders = new LinkedList<>();
        if (accessControlRequestHeadersHeader != null &&
                !accessControlRequestHeadersHeader.trim().isEmpty()) {
            String[] headers = accessControlRequestHeadersHeader.trim().split(
                    ",");
            for (String header : headers) {
                accessControlRequestHeaders.add(header.trim().toLowerCase());
            }
        }
        // Section 6.2.5
        if (!allowedHttpMethods.contains(accessControlRequestMethod)) {
            handleInvalidCORS(request, response, filterChain);
            return;
        }
        // Section 6.2.6
        if (!accessControlRequestHeaders.isEmpty()) {
            for (String header : accessControlRequestHeaders) {
                if (!allowedHttpHeaders.contains(header)) {
                    handleInvalidCORS(request, response, filterChain);
                    return;
                }
            }
        }
        // Section 6.2.7
        if (supportsCredentials) {
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,
                    origin);
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS,
                    "true");
        } else {
            if (anyOriginAllowed) {
                response.addHeader(
                        CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,
                        "*");
            } else {
                response.addHeader(
                        CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,
                        origin);
            }
        }
        // Section 6.2.8
        if (preflightMaxAge > 0) {
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_MAX_AGE,
                    String.valueOf(preflightMaxAge));
        }
        // Section 6.2.9
        response.addHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_METHODS,
                accessControlRequestMethod);
        // Section 6.2.10
        if ((allowedHttpHeaders != null) && (!allowedHttpHeaders.isEmpty())) {
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_HEADERS,
                    join(allowedHttpHeaders, ","));
        }
        // Do not forward the request down the filter chain.
    }
    /**
     * Handles a request, that's not a CORS request, but is a valid request i.e.
     * it is not a cross-origin request. This implementation, just forwards the
     * request down the filter chain.
     *
     * @param request
     *            The {@link HttpServletRequest} object.
     * @param response
     *            The {@link HttpServletResponse} object.
     * @param filterChain
     *            The {@link FilterChain} object.
     * @throws IOException
     * @throws ServletException
     */
    private void handleNonCORS(final HttpServletRequest request,
            final HttpServletResponse response, final FilterChain filterChain)
            throws IOException, ServletException {
        // Let request pass.
        filterChain.doFilter(request, response);
    }
    /**
     * Handles a CORS request that violates specification.
     *
     * @param request
     *            The {@link HttpServletRequest} object.
     * @param response
     *            The {@link HttpServletResponse} object.
     * @param filterChain
     *            The {@link FilterChain} object.
     */
    private void handleInvalidCORS(final HttpServletRequest request,
            final HttpServletResponse response, final FilterChain filterChain) {
        String origin = request.getHeader(CorsFilter.REQUEST_HEADER_ORIGIN);
        String method = request.getMethod();
        String accessControlRequestHeaders = request.getHeader(
                REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS);
        response.setContentType("text/plain");
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        response.resetBuffer();
        if (log.isDebugEnabled()) {
            // Debug so no need for i18n
            StringBuilder message =
                    new StringBuilder("Invalid CORS request; Origin=");
            message.append(origin);
            message.append(";Method=");
            message.append(method);
            if (accessControlRequestHeaders != null) {
                message.append(";Access-Control-Request-Headers=");
                message.append(accessControlRequestHeaders);
            }
            log.debug(message.toString());
        }
    }
    @Override
    public void destroy() {
        // NOOP
    }
    /**
     * Decorates the {@link HttpServletRequest}, with CORS attributes.
     * <ul>
     * <li><b>cors.isCorsRequest:</b> Flag to determine if request is a CORS
     * request. Set to <code>true</code> if CORS request; <code>false</code>
     * otherwise.</li>
     * <li><b>cors.request.origin:</b> The Origin URL.</li>
     * <li><b>cors.request.type:</b> Type of request. Values:
     * <code>simple</code> or <code>preflight</code> or <code>not_cors</code> or
     * <code>invalid_cors</code></li>
     * <li><b>cors.request.headers:</b> Request headers sent as
     * 'Access-Control-Request-Headers' header, for pre-flight request.</li>
     * </ul>
     *
     * @param request
     *            The {@link HttpServletRequest} object.
     * @param corsRequestType
     *            The {@link CORSRequestType} object.
     */
    protected static void decorateCORSProperties(
            final HttpServletRequest request,
            final CORSRequestType corsRequestType) {
        if (request == null) {
            throw new IllegalArgumentException(
                    sm.getString("corsFilter.nullRequest"));
        }
        if (corsRequestType == null) {
            throw new IllegalArgumentException(
                    sm.getString("corsFilter.nullRequestType"));
        }
        switch (corsRequestType) {
        case SIMPLE:
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST,
                    Boolean.TRUE);
            request.setAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN,
                    request.getHeader(CorsFilter.REQUEST_HEADER_ORIGIN));
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE,
                    corsRequestType.name().toLowerCase());
            break;
        case ACTUAL:
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST,
                    Boolean.TRUE);
            request.setAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN,
                    request.getHeader(CorsFilter.REQUEST_HEADER_ORIGIN));
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE,
                    corsRequestType.name().toLowerCase());
            break;
        case PRE_FLIGHT:
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST,
                    Boolean.TRUE);
            request.setAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN,
                    request.getHeader(CorsFilter.REQUEST_HEADER_ORIGIN));
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE,
                    corsRequestType.name().toLowerCase());
            String headers = request.getHeader(
                    REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS);
            if (headers == null) {
                headers = "";
            }
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS, headers);
            break;
        case NOT_CORS:
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST,
                    Boolean.FALSE);
            break;
        default:
            // Don't set any attributes
            break;
        }
    }
    /**
     * Joins elements of {@link Set} into a string, where each element is
     * separated by the provided separator.
     *
     * @param elements
     *            The {@link Set} containing elements to join together.
     * @param joinSeparator
     *            The character to be used for separating elements.
     * @return The joined {@link String}; <code>null</code> if elements
     *         {@link Set} is null.
     */
    protected static String join(final Collection<String> elements,
            final String joinSeparator) {
        String separator = ",";
        if (elements == null) {
            return null;
        }
        if (joinSeparator != null) {
            separator = joinSeparator;
        }
        StringBuilder buffer = new StringBuilder();
        boolean isFirst = true;
        for (String element : elements) {
            if (!isFirst) {
                buffer.append(separator);
            } else {
                isFirst = false;
            }
            if (element != null) {
                buffer.append(element);
            }
        }
        return buffer.toString();
    }
    /**
     * Determines the request type.
     *
     * @param request
     */
    protected CORSRequestType checkRequestType(final HttpServletRequest request) {
        CORSRequestType requestType = CORSRequestType.INVALID_CORS;
        if (request == null) {
            throw new IllegalArgumentException(
                    sm.getString("corsFilter.nullRequest"));
        }
        String originHeader = request.getHeader(REQUEST_HEADER_ORIGIN);
        // Section 6.1.1 and Section 6.2.1
        if (originHeader != null) {
            if (originHeader.isEmpty()) {
                requestType = CORSRequestType.INVALID_CORS;
            } else if (!isValidOrigin(originHeader)) {
                requestType = CORSRequestType.INVALID_CORS;
            } else {
                String method = request.getMethod();
                if (method != null && HTTP_METHODS.contains(method)) {
                    if ("OPTIONS".equals(method)) {
                        String accessControlRequestMethodHeader =
                                request.getHeader(
                                        REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD);
                        if (accessControlRequestMethodHeader != null &&
                                !accessControlRequestMethodHeader.isEmpty()) {
                            requestType = CORSRequestType.PRE_FLIGHT;
                        } else if (accessControlRequestMethodHeader != null &&
                                accessControlRequestMethodHeader.isEmpty()) {
                            requestType = CORSRequestType.INVALID_CORS;
                        } else {
                            requestType = CORSRequestType.ACTUAL;
                        }
                    } else if ("GET".equals(method) || "HEAD".equals(method)) {
                        requestType = CORSRequestType.SIMPLE;
                    } else if ("POST".equals(method)) {
                        String contentType = request.getContentType();
                        if (contentType != null) {
                            contentType = contentType.toLowerCase().trim();
                            if (SIMPLE_HTTP_REQUEST_CONTENT_TYPE_VALUES
                                    .contains(contentType)) {
                                requestType = CORSRequestType.SIMPLE;
                            } else {
                                requestType = CORSRequestType.ACTUAL;
                            }
                        }
                    } else if (COMPLEX_HTTP_METHODS.contains(method)) {
                        requestType = CORSRequestType.ACTUAL;
                    }
                }
            }
        } else {
            requestType = CORSRequestType.NOT_CORS;
        }
        return requestType;
    }
    /**
     * Checks if the Origin is allowed to make a CORS request.
     *
     * @param origin
     *            The Origin.
     * @return <code>true</code> if origin is allowed; <code>false</code>
     *         otherwise.
     */
    private boolean isOriginAllowed(final String origin) {
        if (anyOriginAllowed) {
            return true;
        }
        // If 'Origin' header is a case-sensitive match of any of allowed
        // origins, then return true, else return false.
        return allowedOrigins.contains(origin);
    }
    /**
     * Parses each param-value and populates configuration variables. If a param
     * is provided, it overrides the default.
     *
     * @param allowedOrigins
     *            A {@link String} of comma separated origins.
     * @param allowedHttpMethods
     *            A {@link String} of comma separated HTTP methods.
     * @param allowedHttpHeaders
     *            A {@link String} of comma separated HTTP headers.
     * @param exposedHeaders
     *            A {@link String} of comma separated headers that needs to be
     *            exposed.
     * @param supportsCredentials
     *            "true" if support credentials needs to be enabled.
     * @param preflightMaxAge
     *            The amount of seconds the user agent is allowed to cache the
     *            result of the pre-flight request.
     * @throws ServletException
     */
    private void parseAndStore(final String allowedOrigins,
            final String allowedHttpMethods, final String allowedHttpHeaders,
            final String exposedHeaders, final String supportsCredentials,
            final String preflightMaxAge, final String decorateRequest)
                    throws ServletException {
        if (allowedOrigins != null) {
            if (allowedOrigins.trim().equals("*")) {
                this.anyOriginAllowed = true;
            } else {
                this.anyOriginAllowed = false;
                Set<String> setAllowedOrigins =
                        parseStringToSet(allowedOrigins);
                this.allowedOrigins.clear();
                this.allowedOrigins.addAll(setAllowedOrigins);
            }
        }
        if (allowedHttpMethods != null) {
            Set<String> setAllowedHttpMethods =
                    parseStringToSet(allowedHttpMethods);
            this.allowedHttpMethods.clear();
            this.allowedHttpMethods.addAll(setAllowedHttpMethods);
        }
        if (allowedHttpHeaders != null) {
            Set<String> setAllowedHttpHeaders =
                    parseStringToSet(allowedHttpHeaders);
            Set<String> lowerCaseHeaders = new HashSet<>();
            for (String header : setAllowedHttpHeaders) {
                String lowerCase = header.toLowerCase();
                lowerCaseHeaders.add(lowerCase);
            }
            this.allowedHttpHeaders.clear();
            this.allowedHttpHeaders.addAll(lowerCaseHeaders);
        }
        if (exposedHeaders != null) {
            Set<String> setExposedHeaders = parseStringToSet(exposedHeaders);
            this.exposedHeaders.clear();
            this.exposedHeaders.addAll(setExposedHeaders);
        }
        if (supportsCredentials != null) {
            // For any value other then 'true' this will be false.
            this.supportsCredentials = Boolean
                    .parseBoolean(supportsCredentials);
        }
        if (preflightMaxAge != null) {
            try {
                if (!preflightMaxAge.isEmpty()) {
                    this.preflightMaxAge = Long.parseLong(preflightMaxAge);
                } else {
                    this.preflightMaxAge = 0L;
                }
            } catch (NumberFormatException e) {
                throw new ServletException(
                        sm.getString("corsFilter.invalidPreFlightMaxAge"), e);
            }
        }
        if (decorateRequest != null) {
            // For any value other then 'true' this will be false.
            this.decorateRequest = Boolean.parseBoolean(decorateRequest);
        }
    }
    /**
     * Takes a comma separated list and returns a Set<String>.
     *
     * @param data
     *            A comma separated list of strings.
     * @return Set<String>
     */
    private Set<String> parseStringToSet(final String data) {
        String[] splits;
        if (data != null && data.length() > 0) {
            splits = data.split(",");
        } else {
            splits = new String[] {};
        }
        Set<String> set = new HashSet<>();
        if (splits.length > 0) {
            for (String split : splits) {
                set.add(split.trim());
            }
        }
        return set;
    }
    /**
     * Checks if a given origin is valid or not. Criteria:
     * <ul>
     * <li>If an encoded character is present in origin, it's not valid.</li>
     * <li>Origin should be a valid {@link URI}</li>
     * </ul>
     *
     * @param origin
     * @see <a href="http://tools.ietf.org/html/rfc952">RFC952</a>
     */
    protected static boolean isValidOrigin(String origin) {
        // Checks for encoded characters. Helps prevent CRLF injection.
        if (origin.contains("%")) {
            return false;
        }
        URI originURI;
        try {
            originURI = new URI(origin);
        } catch (URISyntaxException e) {
            return false;
        }
        // If scheme for URI is null, return false. Return true otherwise.
        return originURI.getScheme() != null;
    }
    /**
     * Determines if any origin is allowed to make CORS request.
     *
     * @return <code>true</code> if it's enabled; false otherwise.
     */
    public boolean isAnyOriginAllowed() {
        return anyOriginAllowed;
    }
    /**
     * Returns a {@link Set} of headers that should be exposed by browser.
     */
    public Collection<String> getExposedHeaders() {
        return exposedHeaders;
    }
    /**
     * Determines is supports credentials is enabled.
     */
    public boolean isSupportsCredentials() {
        return supportsCredentials;
    }
    /**
     * Returns the preflight response cache time in seconds.
     *
     * @return Time to cache in seconds.
     */
    public long getPreflightMaxAge() {
        return preflightMaxAge;
    }
    /**
     * Returns the {@link Set} of allowed origins that are allowed to make
     * requests.
     *
     * @return {@link Set}
     */
    public Collection<String> getAllowedOrigins() {
        return allowedOrigins;
    }
    /**
     * Returns a {@link Set} of HTTP methods that are allowed to make requests.
     *
     * @return {@link Set}
     */
    public Collection<String> getAllowedHttpMethods() {
        return allowedHttpMethods;
    }
    /**
     * Returns a {@link Set} of headers support by resource.
     *
     * @return {@link Set}
     */
    public Collection<String> getAllowedHttpHeaders() {
        return allowedHttpHeaders;
    }
    // -------------------------------------------------- CORS Response Headers
    /**
     * The Access-Control-Allow-Origin header indicates whether a resource can
     * be shared based by returning the value of the Origin request header in
     * the response.
     */
    public static final String RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN =
            "Access-Control-Allow-Origin";
    /**
     * The Access-Control-Allow-Credentials header indicates whether the
     * response to request can be exposed when the omit credentials flag is
     * unset. When part of the response to a preflight request it indicates that
     * the actual request can include user credentials.
     */
    public static final String RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS =
            "Access-Control-Allow-Credentials";
    /**
     * The Access-Control-Expose-Headers header indicates which headers are safe
     * to expose to the API of a CORS API specification
     */
    public static final String RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS =
            "Access-Control-Expose-Headers";
    /**
     * The Access-Control-Max-Age header indicates how long the results of a
     * preflight request can be cached in a preflight result cache.
     */
    public static final String RESPONSE_HEADER_ACCESS_CONTROL_MAX_AGE =
            "Access-Control-Max-Age";
    /**
     * The Access-Control-Allow-Methods header indicates, as part of the
     * response to a preflight request, which methods can be used during the
     * actual request.
     */
    public static final String RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_METHODS =
            "Access-Control-Allow-Methods";
    /**
     * The Access-Control-Allow-Headers header indicates, as part of the
     * response to a preflight request, which header field names can be used
     * during the actual request.
     */
    public static final String RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_HEADERS =
            "Access-Control-Allow-Headers";
    // -------------------------------------------------- CORS Request Headers
    /**
     * The Origin header indicates where the cross-origin request or preflight
     * request originates from.
     */
    public static final String REQUEST_HEADER_ORIGIN = "Origin";
    /**
     * The Access-Control-Request-Method header indicates which method will be
     * used in the actual request as part of the preflight request.
     */
    public static final String REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD =
            "Access-Control-Request-Method";
    /**
     * The Access-Control-Request-Headers header indicates which headers will be
     * used in the actual request as part of the preflight request.
     */
    public static final String REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS =
            "Access-Control-Request-Headers";
    // ----------------------------------------------------- Request attributes
    /**
     * The prefix to a CORS request attribute.
     */
    public static final String HTTP_REQUEST_ATTRIBUTE_PREFIX = "cors.";
    /**
     * Attribute that contains the origin of the request.
     */
    public static final String HTTP_REQUEST_ATTRIBUTE_ORIGIN =
            HTTP_REQUEST_ATTRIBUTE_PREFIX + "request.origin";
    /**
     * Boolean value, suggesting if the request is a CORS request or not.
     */
    public static final String HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST =
            HTTP_REQUEST_ATTRIBUTE_PREFIX + "isCorsRequest";
    /**
     * Type of CORS request, of type {@link CORSRequestType}.
     */
    public static final String HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE =
            HTTP_REQUEST_ATTRIBUTE_PREFIX + "request.type";
    /**
     * Request headers sent as 'Access-Control-Request-Headers' header, for
     * pre-flight request.
     */
    public static final String HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS =
            HTTP_REQUEST_ATTRIBUTE_PREFIX + "request.headers";
    // -------------------------------------------------------------- Constants
    /**
     * Enumerates varies types of CORS requests. Also, provides utility methods
     * to determine the request type.
     */
    protected static enum CORSRequestType {
        /**
         * A simple HTTP request, i.e. it shouldn't be pre-flighted.
         */
        SIMPLE,
        /**
         * A HTTP request that needs to be pre-flighted.
         */
        ACTUAL,
        /**
         * A pre-flight CORS request, to get meta information, before a
         * non-simple HTTP request is sent.
         */
        PRE_FLIGHT,
        /**
         * Not a CORS request, but a normal request.
         */
        NOT_CORS,
        /**
         * An invalid CORS request, i.e. it qualifies to be a CORS request, but
         * fails to be a valid one.
         */
        INVALID_CORS
    }
    /**
     * {@link Collection} of HTTP methods. Case sensitive.
     *
     * @see  <a href="http://tools.ietf.org/html/rfc2616#section-5.1.1"
     *       >http://tools.ietf.org/html/rfc2616#section-5.1.1</a>
     *
     */
    public static final Collection<String> HTTP_METHODS =
            new HashSet<>(Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT",
                    "DELETE", "TRACE", "CONNECT"));
    /**
     * {@link Collection} of non-simple HTTP methods. Case sensitive.
     */
    public static final Collection<String> COMPLEX_HTTP_METHODS =
            new HashSet<>(Arrays.asList("PUT", "DELETE", "TRACE", "CONNECT"));
    /**
     * {@link Collection} of Simple HTTP methods. Case sensitive.
     *
     * @see  <a href="http://www.w3.org/TR/cors/#terminology"
     *       >http://www.w3.org/TR/cors/#terminology</a>
     */
    public static final Collection<String> SIMPLE_HTTP_METHODS =
            new HashSet<>(Arrays.asList("GET", "POST", "HEAD"));
    /**
     * {@link Collection} of Simple HTTP request headers. Case in-sensitive.
     *
     * @see  <a href="http://www.w3.org/TR/cors/#terminology"
     *       >http://www.w3.org/TR/cors/#terminology</a>
     */
    public static final Collection<String> SIMPLE_HTTP_REQUEST_HEADERS =
            new HashSet<>(Arrays.asList("Accept", "Accept-Language",
                    "Content-Language"));
    /**
     * {@link Collection} of Simple HTTP request headers. Case in-sensitive.
     *
     * @see  <a href="http://www.w3.org/TR/cors/#terminology"
     *       >http://www.w3.org/TR/cors/#terminology</a>
     */
    public static final Collection<String> SIMPLE_HTTP_RESPONSE_HEADERS =
            new HashSet<>(Arrays.asList("Cache-Control", "Content-Language",
                    "Content-Type", "Expires", "Last-Modified", "Pragma"));
    /**
     * {@link Collection} of Simple HTTP request headers. Case in-sensitive.
     *
     * @see  <a href="http://www.w3.org/TR/cors/#terminology"
     *       >http://www.w3.org/TR/cors/#terminology</a>
     */
    public static final Collection<String> SIMPLE_HTTP_REQUEST_CONTENT_TYPE_VALUES =
            new HashSet<>(Arrays.asList("application/x-www-form-urlencoded",
                    "multipart/form-data", "text/plain"));
    // ------------------------------------------------ Configuration Defaults
    /**
     * By default, all origins are allowed to make requests.
     */
    public static final String DEFAULT_ALLOWED_ORIGINS = "*";
    /**
     * By default, following methods are supported: GET, POST, HEAD and OPTIONS.
     */
    public static final String DEFAULT_ALLOWED_HTTP_METHODS =
            "GET,POST,HEAD,OPTIONS";
    /**
     * By default, time duration to cache pre-flight response is 30 mins.
     */
    public static final String DEFAULT_PREFLIGHT_MAXAGE = "1800";
    /**
     * By default, support credentials is turned on.
     */
    public static final String DEFAULT_SUPPORTS_CREDENTIALS = "true";
    /**
     * By default, following headers are supported:
     * Origin,Accept,X-Requested-With, Content-Type,
     * Access-Control-Request-Method, and Access-Control-Request-Headers.
     */
    public static final String DEFAULT_ALLOWED_HTTP_HEADERS =
            "Origin,Accept,X-Requested-With,Content-Type," +
            "Access-Control-Request-Method,Access-Control-Request-Headers";
    /**
     * By default, none of the headers are exposed in response.
     */
    public static final String DEFAULT_EXPOSED_HEADERS = "";
    /**
     * By default, request is decorated with CORS attributes.
     */
    public static final String DEFAULT_DECORATE_REQUEST = "true";
    // ----------------------------------------Filter Config Init param-name(s)
    /**
     * Key to retrieve allowed origins from {@link FilterConfig}.
     */
    public static final String PARAM_CORS_ALLOWED_ORIGINS =
            "cors.allowed.origins";
    /**
     * Key to retrieve support credentials from {@link FilterConfig}.
     */
    public static final String PARAM_CORS_SUPPORT_CREDENTIALS =
            "cors.support.credentials";
    /**
     * Key to retrieve exposed headers from {@link FilterConfig}.
     */
    public static final String PARAM_CORS_EXPOSED_HEADERS =
            "cors.exposed.headers";
    /**
     * Key to retrieve allowed headers from {@link FilterConfig}.
     */
    public static final String PARAM_CORS_ALLOWED_HEADERS =
            "cors.allowed.headers";
    /**
     * Key to retrieve allowed methods from {@link FilterConfig}.
     */
    public static final String PARAM_CORS_ALLOWED_METHODS =
            "cors.allowed.methods";
    /**
     * Key to retrieve preflight max age from {@link FilterConfig}.
     */
    public static final String PARAM_CORS_PREFLIGHT_MAXAGE =
            "cors.preflight.maxage";
    /**
     * Key to determine if request should be decorated.
     */
    public static final String PARAM_CORS_REQUEST_DECORATE =
            "cors.request.decorate";
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private FilterChain filterChain = new TesterFilterChain();
    /**
     * Tests if a GET request is treated as simple request.
     *
     * @See http://www.w3.org/TR/cors/#simple-method
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimpleGET() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("GET");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "https://www.apache.org"));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Tests if a POST request is treated as simple request.
     *
     * @See http://www.w3.org/TR/cors/#simple-method
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimplePOST() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setContentType("text/plain");
        request.setMethod("POST");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "https://www.apache.org"));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Tests if a HEAD request is treated as simple request.
     *
     * @See http://www.w3.org/TR/cors/#simple-method
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimpleHEAD() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("HEAD");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "https://www.apache.org"));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Test the presence of specific origin in response, when '*' is not used.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimpleSpecificHeader() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("POST");
        request.setContentType("text/plain");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Tests the prsence of the origin (and not '*') in the response, when
     * supports credentials is enabled alongwith any origin, '*'.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimpleAnyOriginAndSupportsCredentials()
            throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("GET");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getFilterConfigAnyOriginAndSupportsCredentials());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS)
                .equals(
                        "true"));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Tests the presence of the origin (and not '*') in the response, when
     * supports credentials is enabled alongwith any origin, '*'.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimpleAnyOriginAndSupportsCredentialsDisabled()
            throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("GET");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getFilterConfigAnyOriginAndSupportsCredentialsDisabled());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.ANY_ORIGIN));
        Assert.assertNull(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Tests the presence of exposed headers in response, if configured.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimpleWithExposedHeaders() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("POST");
        request.setContentType("text/plain");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getFilterConfigWithExposedHeaders());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "https://www.apache.org"));
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS)
                .equals(TesterFilterConfigs.EXPOSED_HEADERS));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Checks if an OPTIONS request is processed as pre-flight.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterPreflight() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.PRE_FLIGHT.name().toLowerCase()));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS).equals(
                "Content-Type"));
    }
    /**
     * Checks if an OPTIONS request is processed as pre-flight where any origin
     * is enabled.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterPreflightAnyOrigin() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.PRE_FLIGHT.name().toLowerCase()));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS).equals(
                "Content-Type"));
    }
    /**
     * Checks if an OPTIONS request is processed as pre-flight.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterPreflightInvalidOrigin() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://www.example.com");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(response.getStatus(),
                HttpServletResponse.SC_FORBIDDEN);
    }
    @Test
    public void testDoFilterPreflightNegativeMaxAge() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfigNegativeMaxAge());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertNull(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_MAX_AGE));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.PRE_FLIGHT.name().toLowerCase()));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS).equals(
                "Content-Type"));
    }
    @Test
    public void testDoFilterPreflightWithCredentials() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSecureFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS)
                .equals("true"));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.PRE_FLIGHT.name().toLowerCase()));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS).equals(
                "Content-Type"));
    }
    @Test
    public void testDoFilterPreflightWithoutCredentialsAndSpecificOrigin()
            throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getFilterConfigSpecificOriginAndSupportsCredentialsDisabled());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertNull(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.PRE_FLIGHT.name().toLowerCase()));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS).equals(
                "Content-Type"));
    }
    /**
     * Negative test, when a CORS request arrives, with a null origin.
     */
    @Test
    public void testDoFilterNullOrigin() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setMethod("POST");
        request.setContentType("text/plain");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.NOT_CORS, requestType);
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertFalse(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
    }
    @Test
    public void testDoFilterInvalidCORSOriginNotAllowed() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "www.google.com");
        request.setMethod("POST");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    @Test(expected = ServletException.class)
    public void testDoFilterNullRequestNullResponse() throws IOException,
            ServletException {
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.doFilter(null, null, filterChain);
    }
    @Test(expected = ServletException.class)
    public void testDoFilterNullRequestResponse() throws IOException,
            ServletException {
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.doFilter(null, response, filterChain);
    }
    @Test(expected = ServletException.class)
    public void testDoFilterRequestNullResponse() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.doFilter(request, null, filterChain);
    }
    @Test
    public void testInitDefaultFilterConfig() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("GET");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(null);
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "https://www.apache.org"));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    @Test(expected = ServletException.class)
    public void testInitInvalidFilterConfig() throws ServletException {
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getFilterConfigInvalidMaxPreflightAge());
        // If we don't get an exception at this point, then all mocked objects
        // worked as expected.
    }
    /**
     * Tests if a non-simple request is given to simple request handler.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test(expected = IllegalArgumentException.class)
    public void testNotSimple() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        corsFilter.handleSimpleCORS(request, response, filterChain);
    }
    /**
     * When a non-preflight request is given to a pre-flight request handler.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test(expected = IllegalArgumentException.class)
    public void testNotPreflight() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("GET");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.handlePreflightCORS(request, response, filterChain);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testDecorateCORSPropertiesNullRequestNullCORSRequestType() {
        CorsFilter.decorateCORSProperties(null, null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testDecorateCORSPropertiesNullRequestValidCORSRequestType() {
        CorsFilter.decorateCORSProperties(null,
                CorsFilter.CORSRequestType.SIMPLE);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testDecorateCORSPropertiesValidRequestNullRequestType() {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        CorsFilter.decorateCORSProperties(request, null);
    }
    @Test
    public void testDecorateCORSPropertiesCORSRequestTypeNotCORS() {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        CorsFilter.decorateCORSProperties(request,
                CorsFilter.CORSRequestType.NOT_CORS);
        Assert.assertFalse(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
    }
    @Test
    public void testDecorateCORSPropertiesCORSRequestTypeInvalidCORS() {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        CorsFilter
                .decorateCORSProperties(request,
                        CorsFilter.CORSRequestType.INVALID_CORS);
        Assert.assertNull(request
                .getAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST));
    }
    @Test
    public void testCheckSimpleRequestTypeAnyOrigin() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://www.w3.org");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.SIMPLE, requestType);
    }
    /**
     * Happy path test, when a valid CORS Simple request arrives.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckSimpleRequestType() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.SIMPLE, requestType);
    }
    /**
     * Happy path test, when a valid CORS Simple request arrives.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckActualRequestType() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setMethod("PUT");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.ACTUAL, requestType);
    }
    /**
     * Happy path test, when a valid CORS Simple request arrives.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckActualRequestTypeMethodPOSTNotSimpleHeaders()
            throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setMethod("POST");
        request.setContentType("application/json");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.ACTUAL, requestType);
    }
    /**
     * Happy path test, when a valid CORS Pre-flight request arrives.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckPreFlightRequestType() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.PRE_FLIGHT, requestType);
    }
    /**
     * when a valid CORS Pre-flight request arrives, with no
     * Access-Control-Request-Method
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckPreFlightRequestTypeNoACRM() throws ServletException,
            IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.ACTUAL, requestType);
    }
    /**
     * when a valid CORS Pre-flight request arrives, with empty
     * Access-Control-Request-Method
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckPreFlightRequestTypeEmptyACRM()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    /**
     * Happy path test, when a valid CORS Pre-flight request arrives.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckPreFlightRequestTypeNoHeaders()
            throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "PUT");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.PRE_FLIGHT, requestType);
    }
    /**
     * Section 6.2.3
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckPreFlightRequestTypeInvalidRequestMethod()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "POLITE");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * Section Section 6.2.5
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckPreFlightRequestTypeUnsupportedRequestMethod()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "TRACE");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * Section Section 6.2.6
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckPreFlightRequestTypeUnsupportedRequestHeaders()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "X-ANSWER");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSecureFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * Section Section 6.2.7
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckPreFlightRequestTypeAnyOriginNoWithCredentials()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Origin");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getFilterConfigAnyOriginAndSupportsCredentialsDisabled());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "*"));
        Assert.assertNull(response
                .getHeader(CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS));
    }
    @Test
    public void testCheckPreFlightRequestTypeOriginNotAllowed()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "www.ebay.com");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "PUT");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSecureFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * Happy path test, when a valid CORS Pre-flight request arrives.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckPreFlightRequestTypeEmptyHeaders()
            throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.PRE_FLIGHT, requestType);
    }
    /**
     * Negative test, when a CORS request arrives, with an empty origin.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckNotCORSRequestTypeEmptyOrigin()
            throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    /**
     * Tests for failure, when a different domain is used, that's not in the
     * allowed list of origins.
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckInvalidOrigin() throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "www.example.com");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * Tests for failure, when a different sub-domain is used, that's not in the
     * allowed list of origins.
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckInvalidOriginNotAllowedSubdomain()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://commons.apache.org");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * PUT is not an allowed request method.
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckInvalidRequestMethod() throws ServletException,
            IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://tomcat.apache.org");
        request.setMethod("PUT");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * When requestMethod is null
     *
     * @throws ServletException
     */
    @Test
    public void testCheckNullRequestMethod() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://tomcat.apache.org");
        request.setMethod(null);
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    /**
     * "http://tomcat.apache.org" is an allowed origin and
     * "https://tomcat.apache.org" is not, because scheme doesn't match
     *
     * @throws ServletException
     */
    @Test
    public void testCheckForSchemeVariance() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "https://tomcat.apache.org");
        request.setMethod("POST");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    /**
     * "http://tomcat.apache.org" is an allowed origin and
     * "http://tomcat.apache.org:8080" is not, because ports doesn't match
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckForPortVariance() throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://tomcat.apache.org:8080");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * Tests for failure, when an invalid {@link HttpServletRequest} is
     * encountered.
     *
     * @throws ServletException
     */
    @Test(expected = IllegalArgumentException.class)
    public void testCheckRequestTypeNull() throws ServletException {
        HttpServletRequest request = null;
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.checkRequestType(request);
    }
    @Test
    public void testJoin() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = ",";
        elements.add("world");
        elements.add("peace");
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue("world,peace".equals(join));
    }
    @Test
    public void testJoinSingleElement() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = ",";
        elements.add("world");
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue("world".equals(join));
    }
    @Test
    public void testJoinSepNull() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = null;
        elements.add("world");
        elements.add("peace");
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue("world,peace".equals(join));
    }
    @Test
    public void testJoinElementsNull() {
        Set<String> elements = null;
        String separator = ",";
        String join = CorsFilter.join(elements, separator);
        Assert.assertNull(join);
    }
    @Test
    public void testJoinOneNullElement() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = ",";
        elements.add(null);
        elements.add("peace");
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue(",peace".equals(join));
    }
    @Test
    public void testJoinAllNullElements() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = ",";
        elements.add(null);
        elements.add(null);
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue("".equals(join));
    }
    @Test
    public void testJoinAllEmptyElements() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = ",";
        elements.add("");
        elements.add("");
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue("".equals(join));
    }
    @Test
    public void testJoinPipeSeparator() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = "|";
        elements.add("world");
        elements.add("peace");
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue("world|peace".equals(join));
    }
    @Test
    public void testWithFilterConfig() throws ServletException {
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        Assert.assertTrue(corsFilter.getAllowedHttpHeaders().size() == 6);
        Assert.assertTrue(corsFilter.getAllowedHttpMethods().size() == 4);
        Assert.assertTrue(corsFilter.getAllowedOrigins().size() == 0);
        Assert.assertTrue(corsFilter.isAnyOriginAllowed());
        Assert.assertTrue(corsFilter.getExposedHeaders().size() == 0);
        Assert.assertTrue(corsFilter.isSupportsCredentials());
        Assert.assertTrue(corsFilter.getPreflightMaxAge() == 1800);
    }
    @Test(expected = ServletException.class)
    public void testWithFilterConfigInvalidPreflightAge()
            throws ServletException {
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getFilterConfigInvalidMaxPreflightAge());
    }
    @Test
    public void testWithStringParserEmpty() throws ServletException {
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getEmptyFilterConfig());
        Assert.assertTrue(corsFilter.getAllowedHttpHeaders().size() == 0);
        Assert.assertTrue(corsFilter.getAllowedHttpMethods().size() == 0);
        Assert.assertTrue(corsFilter.getAllowedOrigins().size() == 0);
        Assert.assertTrue(corsFilter.getExposedHeaders().size() == 0);
        Assert.assertFalse(corsFilter.isSupportsCredentials());
        Assert.assertTrue(corsFilter.getPreflightMaxAge() == 0);
    }
    /**
     * If an init param is null, it's default value will be used.
     *
     * @throws ServletException
     */
    @Test
    public void testWithStringParserNull() throws ServletException {
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getNullFilterConfig());
        Assert.assertTrue(corsFilter.getAllowedHttpHeaders().size() == 6);
        Assert.assertTrue(corsFilter.getAllowedHttpMethods().size() == 4);
        Assert.assertTrue(corsFilter.getAllowedOrigins().size() == 0);
        Assert.assertTrue(corsFilter.isAnyOriginAllowed());
        Assert.assertTrue(corsFilter.getExposedHeaders().size() == 0);
        Assert.assertTrue(corsFilter.isSupportsCredentials());
        Assert.assertTrue(corsFilter.getPreflightMaxAge() == 1800);
    }
    @Test
    public void testValidOrigin() {
        Assert.assertTrue(CorsFilter.isValidOrigin("http://www.w3.org"));
    }
    @Test
    public void testInValidOriginCRLF() {
        Assert.assertFalse(CorsFilter.isValidOrigin("http://www.w3.org\r\n"));
    }
    @Test
    public void testInValidOriginEncodedCRLF1() {
        Assert.assertFalse(CorsFilter.isValidOrigin("http://www.w3.org%0d%0a"));
    }
    @Test
    public void testInValidOriginEncodedCRLF2() {
        Assert.assertFalse(CorsFilter.isValidOrigin("http://www.w3.org%0D%0A"));
    }
    @Test
    public void testInValidOriginEncodedCRLF3() {
        Assert.assertFalse(CorsFilter
                .isValidOrigin("http://www.w3.org%0%0d%0ad%0%0d%0aa"));
    }
    @Test
    public void testCheckInvalidCRLF1() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://www.w3.org\r\n");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    @Test
    public void testCheckInvalidCRLF2() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://www.w3.org\r\n");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    @Test
    public void testCheckInvalidCRLF3() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://www.w3.org%0d%0a");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    @Test
    public void testCheckInvalidCRLF4() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://www.w3.org%0D%0A");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    @Test
    public void testDecorateRequestDisabled() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("GET");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getFilterConfigDecorateRequestDisabled());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "https://www.apache.org"));
        Assert.assertNull(request
                .getAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST));
        Assert.assertNull(request
                .getAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN));
        Assert.assertNull(request
                .getAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS));
        Assert.assertNull(request
                .getAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE));
    }
    @Test
    public void testDestroy() {
        // Nothing to test.
        // NO-OP
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    @Override
    public void doFilter(ServletRequest request, ServletResponse response)
            throws IOException, ServletException {
        // NoOp
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    public static final String HTTPS_WWW_APACHE_ORG = "https://www.apache.org";
    public static final String HTTP_TOMCAT_APACHE_ORG =
            "http://tomcat.apache.org";
    public static final String EXPOSED_HEADERS = "X-CUSTOM-HEADER";
    /**
     * Any origin
     */
    public static final String ANY_ORIGIN = "*";
    public static final TesterServletContext mockServletContext =
            new TesterServletContext();
    public static FilterConfig getDefaultFilterConfig() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS;
        final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials =
                CorsFilter.DEFAULT_SUPPORTS_CREDENTIALS;
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getFilterConfigAnyOriginAndSupportsCredentials() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + ",PUT";
        final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials = "true";
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig
            getFilterConfigAnyOriginAndSupportsCredentialsDisabled() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + ",PUT";
        final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials = "false";
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig
            getFilterConfigSpecificOriginAndSupportsCredentialsDisabled() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + ",PUT";
        final String allowedOrigins =
                HTTP_TOMCAT_APACHE_ORG + "," + HTTPS_WWW_APACHE_ORG;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials = "false";
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getFilterConfigWithExposedHeaders() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS;
        final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS;
        final String exposedHeaders = EXPOSED_HEADERS;
        final String supportCredentials =
                CorsFilter.DEFAULT_SUPPORTS_CREDENTIALS;
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getSecureFilterConfig() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + ",PUT";
        final String allowedOrigins = HTTPS_WWW_APACHE_ORG;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials = "true";
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getNullFilterConfig() {
        return generateFilterConfig(null, null, null, null, null, null, null);
    }
    public static FilterConfig getSpecificOriginFilterConfig() {
        final String allowedOrigins =
                HTTPS_WWW_APACHE_ORG + "," + HTTP_TOMCAT_APACHE_ORG;
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + ",PUT";
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials =
                CorsFilter.DEFAULT_SUPPORTS_CREDENTIALS;
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getSpecificOriginFilterConfigNegativeMaxAge() {
        final String allowedOrigins =
                HTTPS_WWW_APACHE_ORG + "," + HTTP_TOMCAT_APACHE_ORG;
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + ",PUT";
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials =
                CorsFilter.DEFAULT_SUPPORTS_CREDENTIALS;
        final String preflightMaxAge = "-1";
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getFilterConfigInvalidMaxPreflightAge() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS;
        final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials =
                CorsFilter.DEFAULT_SUPPORTS_CREDENTIALS;
        final String preflightMaxAge = "abc";
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getEmptyFilterConfig() {
        final String allowedHttpHeaders = "";
        final String allowedHttpMethods = "";
        final String allowedOrigins = "";
        final String exposedHeaders = "";
        final String supportCredentials = "";
        final String preflightMaxAge = "";
        final String decorateRequest = "";
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getFilterConfigDecorateRequestDisabled() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS;
        final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials =
                CorsFilter.DEFAULT_SUPPORTS_CREDENTIALS;
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = "false";
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    private static FilterConfig generateFilterConfig(
            final String allowedHttpHeaders, final String allowedHttpMethods,
            final String allowedOrigins, final String exposedHeaders,
            final String supportCredentials, final String preflightMaxAge,
            final String decorateRequest) {
        FilterConfig filterConfig = new FilterConfig() {
            @Override
            public String getFilterName() {
                return "cors-filter";
            }
            @Override
            public ServletContext getServletContext() {
                return mockServletContext;
            }
            @Override
            public String getInitParameter(String name) {
                if (CorsFilter.PARAM_CORS_ALLOWED_HEADERS
                        .equalsIgnoreCase(name)) {
                    return allowedHttpHeaders;
                } else if (CorsFilter.PARAM_CORS_ALLOWED_METHODS
                        .equalsIgnoreCase(name)) {
                    return allowedHttpMethods;
                } else if (CorsFilter.PARAM_CORS_ALLOWED_ORIGINS
                        .equalsIgnoreCase(name)) {
                    return allowedOrigins;
                } else if (CorsFilter.PARAM_CORS_EXPOSED_HEADERS
                        .equalsIgnoreCase(name)) {
                    return exposedHeaders;
                } else if (CorsFilter.PARAM_CORS_SUPPORT_CREDENTIALS
                        .equalsIgnoreCase(name)) {
                    return supportCredentials;
                } else if (CorsFilter.PARAM_CORS_PREFLIGHT_MAXAGE
                        .equalsIgnoreCase(name)) {
                    return preflightMaxAge;
                } else if (CorsFilter.PARAM_CORS_REQUEST_DECORATE
                        .equalsIgnoreCase(name)) {
                    return decorateRequest;
                }
                return null;
            }
            @Override
            public Enumeration<String> getInitParameterNames() {
                return null;
            }
        };
        return filterConfig;
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    private Map<String, Object> attributes = new HashMap<>();
    private Map<String, List<String>> headers = new HashMap<>();
    private String method;
    private String contentType;
    @Override
    public Object getAttribute(String name) {
        return attributes.get(name);
    }
    @Override
    public Enumeration<String> getAttributeNames() {
        return Collections.enumeration(attributes.keySet());
    }
    @Override
    public String getCharacterEncoding() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void setCharacterEncoding(String env)
            throws UnsupportedEncodingException {
    }
    @Override
    public int getContentLength() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getContentType() {
        return this.contentType;
    }
    public void setContentType(String contentType) {
        this.contentType = contentType;
    }
    @Override
    public ServletInputStream getInputStream() throws IOException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getParameter(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Enumeration<String> getParameterNames() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String[] getParameterValues(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Map<String,String[]> getParameterMap() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getProtocol() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getScheme() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getServerName() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public int getServerPort() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public BufferedReader getReader() throws IOException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getRemoteAddr() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getRemoteHost() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void setAttribute(String name, Object o) {
        attributes.put(name, o);
    }
    @Override
    public void removeAttribute(String name) {
        attributes.remove(name);
    }
    @Override
    public Locale getLocale() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Enumeration<Locale> getLocales() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isSecure() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public RequestDispatcher getRequestDispatcher(String path) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getRealPath(String path) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public int getRemotePort() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getLocalName() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getLocalAddr() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public int getLocalPort() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getAuthType() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Cookie[] getCookies() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public long getDateHeader(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getHeader(String name) {
        List<String> list = headers.get(name);
        if (list != null) {
            return list.get(0);
            // return CorsFilter.join(new HashSet<>(list), ",");
        }
        return null;
    }
    public void setHeader(String name, String value) {
        List<String> values = new ArrayList<>();
        values.add(value);
        headers.put(name, values);
    }
    @Override
    public Enumeration<String> getHeaders(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Enumeration<String> getHeaderNames() {
        return Collections.enumeration(headers.keySet());
    }
    @Override
    public int getIntHeader(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getMethod() {
        return method;
    }
    public void setMethod(String method) {
        this.method = method;
    }
    @Override
    public String getPathInfo() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getPathTranslated() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getContextPath() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getQueryString() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getRemoteUser() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isUserInRole(String role) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Principal getUserPrincipal() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getRequestedSessionId() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getRequestURI() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public StringBuffer getRequestURL() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getServletPath() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public HttpSession getSession(boolean create) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public HttpSession getSession() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isRequestedSessionIdValid() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isRequestedSessionIdFromCookie() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isRequestedSessionIdFromURL() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isRequestedSessionIdFromUrl() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public long getContentLengthLong() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public ServletContext getServletContext() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public AsyncContext startAsync() throws IllegalStateException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public AsyncContext startAsync(ServletRequest servletRequest,
            ServletResponse servletResponse) throws IllegalStateException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isAsyncStarted() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isAsyncSupported() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public AsyncContext getAsyncContext() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public DispatcherType getDispatcherType() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String changeSessionId() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean authenticate(HttpServletResponse response)
            throws IOException, ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void login(String username, String password)
            throws ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void logout() throws ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Collection<Part> getParts() throws IOException, ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Part getPart(String name) throws IOException, ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public <T extends HttpUpgradeHandler> T upgrade(
            Class<T> httpUpgradeHandlerClass) throws IOException {
        throw new RuntimeException("Not implemented");
    }
    private PrintWriter pw;
    private List<String> headerNames = new ArrayList<>();
    private List<String> headerValues = new ArrayList<>();
    private int status;
======= fetch "public TesterHttpServletResponse() {" 72edec7^:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

    @Override
    public PrintWriter getWriter() throws IOException {
        if (pw == null) {
            pw = new PrintWriter(new StringWriter());
        }
        return pw;
    }
    @Override
    public String getHeader(String name) {
        int index = headerNames.indexOf(name);
        if (index != -1) {
            return headerValues.get(index);
        }
        return null;
    }
    @Override
    public void setHeader(String name, String value) {
        int index = headerNames.indexOf(name);
        if (index != -1) {
            headerValues.set(index, value);
        } else {
            headerNames.add(name);
            headerValues.add(value);
        }
    }
    @Override
    public void addHeader(String name, String value) {
        headerNames.add(name);
        headerValues.add(value);
    }
    @Override
    public int getStatus() {
        return status;
    }
    @Override
    public void setStatus(int status) {
        this.status = status;
    }
======= fetch "public ServletOutputStream getOutputStream() throws IOException {" 72edec7^:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

    public PrintWriter getWriter() throws IOException { return null; }
    @Override
======= fetch "public void setLocale(Locale locale) {/* NOOP */}" 72edec7^:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

    public String getHeader(String name) { return null; }
    @Override
======= fetch "public void setLocale(Locale locale) {/* NOOP */}" 72edec7^:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

    @Override
    public int getStatus() { return -1; }
======= fetch "public void addDateHeader(String name, long value) {/* NOOP */}" 72edec7^:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

    public void addHeader(String name, String value) {/* NOOP */}
    @Override
======= fetch "public void setDateHeader(String name, long value) {/* NOOP */}" 72edec7^:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

    public void setHeader(String name, String value) {/* NOOP */}
    @Override
======= fetch "public void setIntHeader(String name, int value) {/* NOOP */}" 72edec7^:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

    @Override
    public void setStatus(int status) {/* NOOP */}
  <subsection name="Introduction">
    <p>This filter triggers parameters parsing in a request and rejects the
    request if some parameters were skipped during parameter parsing because
    of parsing errors or request size limitations (such as
    <code>maxParameterCount</code> attribute in a
    <a href="http.html">Connector</a>).
    This filter can be used to ensure that none parameter values submitted by
    client are lost.</p>
    <p>Note that parameter parsing may consume the body of an HTTP request, so
    caution is needed if the servlet protected by this filter uses
    <code>request.getInputStream()</code> or <code>request.getReader()</code>
    calls. In general the risk of breaking a web application by adding this
    filter is not so high, because parameter parsing does check content type
    of the request before consuming the request body.</p>
    <p>Note, that for the POST requests to be parsed correctly, a
    <code>SetCharacterEncodingFilter</code> filter must be configured above
    this one. See CharacterEncoding page in the FAQ for details.</p>
    <p>The request is rejected with HTTP status code 400 (Bad Request).</p>
  </subsection>
  <subsection name="Filter Class Name">
    <p>The filter class name for the Failed Request Filter is
    <strong><code>org.apache.catalina.filters.FailedRequestFilter</code>
    </strong>.</p>
  </subsection>
  <subsection name="Initialisation parameters">
    <p>The Failed Request Filter does not support any initialization parameters.</p>
  </subsection>

======= fetch "public void setLocalWar(String localWar) {" 712a351^:"java/org/apache/catalina/ant/DeployTask.java"

     * The context path of the web application we are managing.
     */
    protected String path = null;
    public String getPath() {
        return (this.path);
    }
    public void setPath(String path) {
        this.path = path;
    }
    /**
======= fetch "public void execute() throws BuildException {" 712a351^:"java/org/apache/catalina/ant/DeployTask.java"

        StringBuilder sb = new StringBuilder("/deploy?path=");
======= fetch "public void execute() throws BuildException {" 712a351^:"java/org/apache/catalina/ant/DeployTask.java"

            sb.append(URLEncoder.encode(this.path, getCharset()));

======= fetch "public void register(Request request, HttpServletResponse response," 6d789fe^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

                request.removeNote(Constants.REQ_SSOID_NOTE);

======= fetch "public void run() {" 6c6b25c^:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

        private HandshakeStatus handshakeStatus;
        private Status resultStatus;
======= fetch "public void run() {" 6c6b25c^:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

                HandshakeStatus handshakeStatus =
                        sslEngine.getHandshakeStatus();
======= fetch "public void run() {" 6c6b25c^:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

                            handshakeStatus = checkResult(r, true);
======= fetch "public void run() {" 6c6b25c^:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

                            if (socketReadBuffer.position() == 0) {
======= fetch "public void run() {" 6c6b25c^:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

                            handshakeStatus = checkResult(r, false);
======= fetch "public void run() {" 6c6b25c^:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

        private HandshakeStatus checkResult(SSLEngineResult result,
                boolean wrap) throws SSLException {
======= fetch "private HandshakeStatus checkResult(SSLEngineResult result," 6c6b25c^:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

            if (result.getStatus() != Status.OK) {
======= fetch "private HandshakeStatus checkResult(SSLEngineResult result," 6c6b25c^:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

            return result.getHandshakeStatus();

======= fetch "private void parseParts() {" cccd0ac^:"java/org/apache/catalina/connector/Request.java"

                    ApplicationPart part = new ApplicationPart(item, mce);
    private final MultipartConfigElement mce;
    public ApplicationPart(FileItem fileItem, MultipartConfigElement mce) {
======= fetch "public ApplicationPart(FileItem fileItem, MultipartConfigElement mce) {" cccd0ac^:"java/org/apache/catalina/core/ApplicationPart.java"

        this.mce = mce;
======= fetch "public void write(String fileName) throws IOException {" cccd0ac^:"java/org/apache/catalina/core/ApplicationPart.java"

            file = new File(mce.getLocation(), fileName);

======= fetch "private void loadTagPlugins(ErrorDispatcher err, InputStream is)" 65ab66e^:"java/org/apache/jasper/compiler/TagPluginManager.java"

                Class<?> pluginClass = Class.forName(pluginClassStr);

======= fetch "public void onAccept(Object socket) {" 6272fca^:"java/org/apache/tomcat/spdy/NetSupportSocket.java"

        ctx.getExecutor().execute(ch.inputThread);

    private boolean compress = false;
======= fetch "public void start() throws Exception {" c25112b^:"java/org/apache/coyote/spdy/SpdyProxyProtocol.java"

        spdyContext.setTlsComprression(false, false);
======= fetch "public void onStream(SpdyConnection con, SpdyStream ch) throws IOException {" c25112b^:"java/org/apache/coyote/spdy/SpdyProxyProtocol.java"

    public boolean isCompress() {
        return compress;
    }
    public void setCompress(boolean compress) {
        this.compress = compress;
    }
      <add>
        Experimental support for SDPY. Includes contributions from Sheldon Shao.
        (costin)
      </add>

======= fetch "public boolean parseRequestLine(boolean useAvailableDataOnly)" f763975^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

        }
        if (parsingRequestLinePhase == 6) {
            // Mark the current buffer position
======= fetch "public boolean parseRequestLine(boolean useAvailableDataOnly)" f763975^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            // Mark the current buffer position
======= fetch "public boolean parseRequestLine(boolean useAvailableDataOnly)" f763975^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

    public static final String CRLF = "\r\n";
======= fetch "public boolean isResponseBodyOK() {" f763975^:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

    /**
     * Test case for https://issues.apache.org/bugzilla/show_bug.cgi?id=54947
     */
    @Test
    public void testBug54947() {
        Bug54947Client client = new Bug54947Client();
        client.doRequest();
        assertTrue(client.isResponse200());
        assertTrue(client.isResponseBodyOK());
    }
    /**
     * Bug 54947 test client.
     */
    private class Bug54947Client extends SimpleHttpClient {
        private Exception doRequest() {
            Tomcat tomcat = getTomcatInstance();
            Context root = tomcat.addContext("", TEMP_DIR);
            Tomcat.addServlet(root, "Bug54947", new TesterServlet());
            root.addServletMapping("/test", "Bug54947");
            try {
                tomcat.start();
                setPort(tomcat.getConnector().getLocalPort());
                // Open connection
                connect();
                String[] request = new String[2];
                request[0] = "GET http://localhost:8080/test HTTP/1.1" + CR;
                request[1] = LF +
                        "Connection: close" + CRLF +
                        CRLF;
                setRequest(request);
                processRequest(); // blocks until response has been read
                // Close the connection
                disconnect();
            } catch (Exception e) {
                return e;
            }
            return null;
        }
        @Override
        public boolean isResponseBodyOK() {
            if (getResponseBody() == null) {
                return false;
            }
            if (!getResponseBody().contains("OK")) {
                return false;
            }
            return true;
        }
    }

    public void testGet() throws Exception {
        doTest("GET", "GET", false);
======= fetch "public void testGet() throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

    public void testPostNoContinue() throws Exception {
        doTest("POST", "GET", false);
======= fetch "public void testPostNoContinue() throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

    public void testPostWithContinue() throws Exception {
        doTest("POST", "GET", true);
======= fetch "public void testPostWithContinue() throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

    public void testPostNoContinuePostRedirect() throws Exception {
        doTest("POST", "POST", false);
======= fetch "public void testPostNoContinuePostRedirect() throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

    public void testPostWithContinuePostRedirect() throws Exception {
        doTest("POST", "POST", true);
======= fetch "public void testPostWithContinuePostRedirect() throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

    private void doTest(String resourceMethod, String redirectMethod,
            boolean useContinue) throws Exception {
        FormAuthClient client = new FormAuthClient();
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        // First request for authenticated resource
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        client.doResourceRequest(resourceMethod);
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        String loginUri = client.extractBodyUri(
                FormAuthClient.LOGIN_PARAM_TAG,
                FormAuthClient.LOGIN_RESOURCE);
        String originalSessionId = null;
        if (serverWillUseCookies && clientShouldUseCookies) {
            originalSessionId = client.getSessionId();
        }
        else {
            originalSessionId = client.extractPathSessionId(loginUri);
        }
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        // Second request for the login page
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        client.doLoginRequest();
        assertTrue(client.isResponse302());
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        String redirectUri = client.getRedirectUri();
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        // Third request - follow the redirect
        client.doResourceRequest(redirectMethod);
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        String protectedUri = client.extractBodyUri(
                FormAuthClient.RESOURCE_PARAM_TAG,
                FormAuthClient.PROTECTED_RESOURCE);
        String newSessionId = null;
        if (serverWillUseCookies && clientShouldUseCookies) {
            newSessionId = client.getSessionId();
        }
        else {
            newSessionId = client.extractPathSessionId(protectedUri);
        }
        boolean sessionIdIsChanged = !(originalSessionId.equals(newSessionId));
        assertTrue(sessionIdIsChanged == serverWillChangeSessid);
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        // Subsequent requests - direct to the resource
        for (int i = 0; i < 5; i++) {
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            client.doResourceRequest(resourceMethod);
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            assertTrue(client.isResponseBodyOK());
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

    /*
     * Encapsulate the logic needed to run a suitably-configured tomcat
     * instance, send it an HTTP request and process the server response
     */
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        private static final String LOGIN_PAGE = "j_security_check";
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        private String protectedPage = "index.jsp";
        private String protectedLocation = "/examples/jsp/security/protected/";
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        private String sessionId = null;
======= fetch "private void doTest(String resourceMethod, String redirectMethod," 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        private FormAuthClient() throws Exception {
======= fetch "private FormAuthClient() throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            setUseCookies(clientShouldUseCookies);
            ctx.setCookies(serverShouldUseCookies);
======= fetch "private FormAuthClient() throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            // perhaps this does not work until tomcat has started?
            ctx.setSessionTimeout(TIMEOUT_MINS);
            // Valve pipeline is only established after tomcat starts
            Valve[] valves = ctx.getPipeline().getValves();
            for (Valve valve : valves) {
                if (valve instanceof AuthenticatorBase) {
                    ((AuthenticatorBase)valve)
                            .setChangeSessionIdOnAuthentication(
                                                serverShouldChangeSessid);
                    break;
                }
            }
======= fetch "private FormAuthClient() throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        private void doResourceRequest(String method) throws Exception {
======= fetch "private void doResourceRequest(String method) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            String requestTail;
            requestHead.append(method).append(" ").append(protectedLocation)
                    .append(protectedPage);
            if ("GET".equals(method)) {
                requestHead.append("?role=bar");
======= fetch "private void doResourceRequest(String method) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            // next, add the constant http headers
======= fetch "private void doResourceRequest(String method) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            // then any optional http headers
======= fetch "private void doResourceRequest(String method) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            if (sessionId != null) {
                requestHead.append("Cookie: JSESSIONID=").append(sessionId)
                        .append(CRLF);
======= fetch "private void doResourceRequest(String method) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            // finally, for posts only, deal with the request content
======= fetch "private void doResourceRequest(String method) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

                if (requestTail == null) {
                    requestTail = "role=bar";
                }
======= fetch "private void doResourceRequest(String method) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

                requestHead.append("Content-length: 8").append(CRLF);
                requestHead.append(CRLF);
                requestTail = "role=bar";
            } else {
                requestTail = CRLF;
======= fetch "private void doResourceRequest(String method) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            String request[] = new String[2];
            request[0] = requestHead.toString();
            request[1] = requestTail;
            doRequest(request);
        }
======= fetch "private void doResourceRequest(String method) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        private void doLoginRequest() throws Exception {
            StringBuilder requestHead = new StringBuilder(128);
            requestHead.append("POST ").append(protectedLocation)
                    .append(LOGIN_PAGE).append(" HTTP/1.1").append(CRLF);
            requestHead.append("Host: localhost").append(CRLF);
            requestHead.append("Connection: close").append(CRLF);
            if (getUseContinue()) {
                requestHead.append("Expect: 100-continue").append(CRLF);
            }
            if (sessionId != null) {
                requestHead.append("Cookie: JSESSIONID=").append(sessionId)
                        .append(CRLF);
            }
            requestHead.append(
                    "Content-Type: application/x-www-form-urlencoded").append(
                    CRLF);
            requestHead.append("Content-length: 35").append(CRLF);
======= fetch "private void doLoginRequest() throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

======= fetch "private void doLoginRequest() throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            request[1] = "j_username=tomcat&j_password=tomcat";
======= fetch "private void doRequest(String request[]) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

======= fetch "private void doRequest(String request[]) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            String newSessionId = getSessionId();
            if (newSessionId != null) {
                sessionId = newSessionId;
            }
======= fetch "private void doRequest(String request[]) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

======= fetch "private void doRequest(String request[]) throws Exception {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

        /*
         * verify the server response html body is the page we expect,
         * based on the dialogue position within doTest.
         */
======= fetch "public boolean isResponseBodyOK() {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            if (requestCount == 1) {
                // First request should result in the login page
                assertContains(getResponseBody(),
                        "<title>Login Page for Examples</title>");
                return true;
            } else if (requestCount == 2) {
                // Second request should result in a redirect
                return true;
            } else {
                // Subsequent requests should result in the protected page
                // The role parameter should have reached the page
                String body = getResponseBody();
                assertContains(body,
                        "<title>Protected Page for Examples</title>");
                assertContains(body,
                        "<input type=\"text\" name=\"role\" value=\"bar\"");
                return true;
======= fetch "public boolean isResponseBodyOK() {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            return fullPath;
======= fetch "public boolean isResponseBodyOK() {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

    /*
     * extract the session id path element (if it exists in the given url)
     */
    private String extractPathSessionId(String url) {
        String sessionId = null;
        int iStart = url.indexOf(SESSION_PARAMETER_START);
        if (iStart > -1) {
            iStart += SESSION_PARAMETER_START.length();
            String remainder = url.substring(iStart);
            StringTokenizer parser =
                    new StringTokenizer(remainder, SESSION_PATH_PARAMETER_TAILS);
            if (parser.hasMoreElements()) {
                sessionId = parser.nextToken();
            }
            else {
                sessionId = url.substring(iStart);
            }
        }
        return sessionId;
    }
======= fetch "private void assertContains(String body, String expected) {" 0de078e^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

                fail("Response body check failure.\n"

    public AbstractOutputBuffer() {
        // Cause loading of Constants
        int foo = Constants.HTTP_11_BYTES[0];
    }

======= fetch "private void parseParts() {" 7558546^:"java/org/apache/catalina/connector/Request.java"

                                encoding = Parameters.DEFAULT_ENCODING;
======= fetch "public void testBug49424NoChunking() throws Exception {" 7558546^:"test/org/apache/catalina/connector/TestRequest.java"

        HttpURLConnection conn = getConnection();
======= fetch "public void testBug49424WithChunking() throws Exception {" 7558546^:"test/org/apache/catalina/connector/TestRequest.java"

        HttpURLConnection conn = getConnection();
======= fetch "private Exception doRequest(String method," 7558546^:"test/org/apache/catalina/connector/TestRequest.java"

    @Test
    public void testBug54984() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        Context root = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        root.setAllowCasualMultipartParsing(true);
        Tomcat.addServlet(root, "Bug54984", new Bug54984Servlet());
        root.addServletMapping("/", "Bug54984");
        tomcat.start();
        HttpURLConnection conn = getConnection("http://localhost:" + getPort()
                + "/parseParametersBeforeParseParts");
        prepareRequestBug54984(conn);
        checkResponseBug54984(conn);
        conn.disconnect();
        conn = getConnection("http://localhost:" + getPort() + "/");
        prepareRequestBug54984(conn);
        checkResponseBug54984(conn);
        conn.disconnect();
    }
======= fetch "public boolean isResponseBodyOK() {" 7558546^:"test/org/apache/catalina/connector/TestRequest.java"

    private HttpURLConnection getConnection() throws IOException {
        final String query = "http://localhost:" + getPort() + "/";
======= fetch "private HttpURLConnection getConnection() throws IOException {" 7558546^:"test/org/apache/catalina/connector/TestRequest.java"

    private static class Bug54984Servlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            req.setCharacterEncoding("UTF-8");
            if (req.getRequestURI().endsWith("parseParametersBeforeParseParts")) {
                req.getParameterNames();
            }
            req.getPart("part");
            resp.getWriter().println("Part " + req.getParameter("part"));
        }
    }
    private void prepareRequestBug54984(HttpURLConnection conn)
            throws Exception {
        String boundary = "-----" + System.currentTimeMillis();
        conn.setRequestProperty("Content-Type",
                "multipart/form-data; boundary=" + boundary);
        PrintWriter writer = null;
        try {
            writer = new PrintWriter(new OutputStreamWriter(
                    conn.getOutputStream(), "UTF-8"), true);
            writer.append("--" + boundary).append("\r\n");
            writer.append("Content-Disposition: form-data; name=\"part\"\r\n");
            writer.append("Content-Type: text/plain; charset=UTF-8\r\n");
            writer.append("\r\n");
            writer.append("").append("\r\n");
            writer.flush();
            writer.append("\r\n");
            writer.flush();
            writer.append("--" + boundary + "--").append("\r\n");
        } finally {
            if (writer != null) {
                writer.close();
            }
        }
    }
    private void checkResponseBug54984(HttpURLConnection conn)
            throws Exception {
        List<String> response = new ArrayList<>();
        int status = conn.getResponseCode();
        if (status == HttpURLConnection.HTTP_OK) {
            BufferedReader reader = null;
            try {
                reader = new BufferedReader(new InputStreamReader(
                        conn.getInputStream()));
                String line = null;
                while ((line = reader.readLine()) != null) {
                    response.add(line);
                }
                assertTrue(response.contains("Part "));
            } catch (Exception e) {
                if (reader != null) {
                    reader.close();
                }
            }
        } else {
            fail("OK status was expected: " + status);
        }
    }

======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 3960b22^:"test/org/apache/catalina/connector/TestCoyoteAdapter.java"

    @Test
    public void testBug54928() throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
        AsyncServlet servlet = new AsyncServlet();
        Wrapper w = Tomcat.addServlet(ctx, "async", servlet);
        w.setAsyncSupported(true);
        ctx.addServletMapping("/async", "async");
        tomcat.start();
        SimpleHttpClient client = new SimpleHttpClient() {
            @Override
            public boolean isResponseBodyOK() {
                return true;
            }
        };
        String request = "GET /async HTTP/1.1" + SimpleHttpClient.CRLF +
                "Host: a" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF;
        client.setPort(getPort());
        client.setRequest(new String[] {request});
        client.connect();
        client.sendRequest();
        for (int i = 0; i < 10; i++) {
            System.out.println(client.readLine());
        }
        client.disconnect();
        // Wait for server thread to stop
        while (servlet.getThread().isAlive()) {
            Thread.sleep(250);
        }
    }
    private static class AsyncServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        // This is a hack that won't work generally as servlets are expected to
        // handle more than one request.
        private Thread t;
        public Thread getThread() {
            return t;
        }
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setContentType("text/plain");
            resp.setCharacterEncoding("UTF-8");
            final OutputStream os = resp.getOutputStream();
            final AsyncContext asyncCtxt = req.startAsync();
            asyncCtxt.setTimeout(3000);
            t = new Thread(new Runnable() {
                @Override
                public void run() {
                    while (true) {
                        try {
                            os.write("TEST".getBytes(B2CConverter.UTF_8));
                            os.flush();
                            Thread.sleep(1000);
                        } catch (Exception e) {
                            asyncCtxt.complete();
                            break;
                        }
                    }
                }
            });
            t.setName("testBug54928");
            t.start();
        }
    }

======= fetch "protected void removeWrapper(ContextVersion context, String path) {" cdbf6b0^:"java/org/apache/catalina/mapper/Mapper.java"

                String name = path;

======= fetch "public JspConfigDescriptor getJspConfigDescriptor() {" aabef09^:"java/org/apache/catalina/core/ApplicationContext.java"

        return context.getJspConfigDescriptor();
======= fetch "public void testAddServletWithServletNameEmptyString() {" aabef09^:"test/org/apache/catalina/core/TestApplicationContext.java"

    @Test
    public void testGetJspConfigDescriptor() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp");
        // app dir is relative to server home
        StandardContext standardContext = (StandardContext) tomcat.addWebapp(
                null, "/test", appDir.getAbsolutePath());
        ServletContext servletContext = standardContext.getServletContext();
        Assert.assertNull(servletContext.getJspConfigDescriptor());
        tomcat.start();
        Assert.assertNotNull(servletContext.getJspConfigDescriptor());
    }

======= fetch "public ApplicationContext(StandardContext context) {" 41462ca^:"java/org/apache/catalina/core/ApplicationContext.java"

        this.sessionCookieConfig = new ApplicationSessionCookieConfig(context);
======= fetch "public ApplicationContext(StandardContext context) {" 41462ca^:"java/org/apache/catalina/core/ApplicationContext.java"

    private final SessionCookieConfig sessionCookieConfig =
        new ApplicationSessionCookieConfig();
======= fetch "public void setComment(String comment) {" 41462ca^:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "comment",
                    context.getPath()));
        }
======= fetch "public void setDomain(String domain) {" 41462ca^:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "domain name",
                    context.getPath()));
        }
======= fetch "public void setHttpOnly(boolean httpOnly) {" 41462ca^:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "HttpOnly",
                    context.getPath()));
        }
======= fetch "public void setMaxAge(int maxAge) {" 41462ca^:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "max age",
                    context.getPath()));
        }
======= fetch "public void setName(String name) {" 41462ca^:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "name",
                    context.getPath()));
        }
======= fetch "public void setPath(String path) {" 41462ca^:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "path",
                    context.getPath()));
        }
======= fetch "public void setSecure(boolean secure) {" 41462ca^:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "secure",
                    context.getPath()));
        }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private ApplicationSessionCookieConfig applicationSessionCookieConfig;
    private final CustomContext context = new CustomContext();
    @Before
    public void setUp() throws Exception {
        applicationSessionCookieConfig = new ApplicationSessionCookieConfig(
                context);
    }
    @Test
    public void testSetCommentInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setComment("test");
        assertTrue(applicationSessionCookieConfig.getComment().equals("test"));
    }
    @Test(expected = IllegalStateException.class)
    public void testSetCommentNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setComment("test");
    }
    @Test
    public void testSetDomainInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setDomain("test");
        assertTrue(applicationSessionCookieConfig.getDomain().equals("test"));
    }
    @Test(expected = IllegalStateException.class)
    public void testSetDomainNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setDomain("test");
    }
    @Test
    public void testSetHttpOnlyInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setHttpOnly(true);
        assertTrue(applicationSessionCookieConfig.isHttpOnly());
    }
    @Test(expected = IllegalStateException.class)
    public void testSetHttpOnlyNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setHttpOnly(true);
    }
    @Test
    public void testSetMaxAgeInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setMaxAge(1);
        assertTrue(applicationSessionCookieConfig.getMaxAge() == 1);
    }
    @Test(expected = IllegalStateException.class)
    public void testSetMaxAgeNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setMaxAge(1);
    }
    @Test
    public void testSetNameInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setName("test");
        assertTrue(applicationSessionCookieConfig.getName().equals("test"));
    }
    @Test(expected = IllegalStateException.class)
    public void testSetNameNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setName("test");
    }
    @Test
    public void testSetPathInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setPath("test");
        assertTrue(applicationSessionCookieConfig.getPath().equals("test"));
    }
    @Test(expected = IllegalStateException.class)
    public void testSetPathNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setPath("test");
    }
    @Test
    public void testSetSecureInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setSecure(true);
        assertTrue(applicationSessionCookieConfig.isSecure());
    }
    @Test(expected = IllegalStateException.class)
    public void testSetSecureNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setSecure(true);
    }
    private static class CustomContext extends StandardContext {
        private LifecycleState state;
        @Override
        public LifecycleState getState() {
            return state;
        }
        @Override
        public synchronized void setState(LifecycleState state) {
            this.state = state;
        }
    }

======= fetch "private static boolean isHex(int c) {" 7aeab0e^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

    private static SkipConstantResult skipConstant(StringReader input,
            String constant) throws IOException {
        int len = constant.length();
======= fetch "private static SkipConstantResult skipConstant(StringReader input," 7aeab0e^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        if (withReset) {
            input.mark(1);
        }
======= fetch "private static SkipConstantResult skipConstant(StringReader input," 7aeab0e^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        // Skip lws
        while (c == 32 || c == 9) {
======= fetch "private static SkipConstantResult skipConstant(StringReader input," 7aeab0e^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        if (withReset) {
            input.reset();
        }
        return c;
    }
    private static SkipConstantResult skipConstant(StringReader input,
            String constant) throws IOException {
        int len = constant.length();
        int c = skipLws(input, false);
======= fetch "private static String readToken(StringReader input) throws IOException {" 7aeab0e^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        int c = input.read();
        // Skip lws
        while (c == 32 || c == 9) {
            c = input.read();
        }
======= fetch "private static String readQuotedString(StringReader input," 7aeab0e^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        int c = input.read();
        // Skip lws
        while (c == 32 || c == 9) {
            c = input.read();
        }
======= fetch "private static String readTokenOrQuotedString(StringReader input," 7aeab0e^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        // Use mark/reset as skip(-1) fails when reading the last character of
        // the input
        input.mark(1);
        int c = input.read();
        // Go back so first character is available to be read again
        input.reset();
======= fetch "private static String readQuotedToken(StringReader input)" 7aeab0e^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        int c = input.read();
        // Skip lws
        while (c == 32 || c == 9) {
            c = input.read();
        }
======= fetch "private static String readLhex(StringReader input)" 7aeab0e^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        int c = input.read();
        // Skip lws
        while (c == 32 || c == 9) {
            c = input.read();
        }
======= fetch "private void doTest(Parameter... parameters) throws IOException {" 7aeab0e^:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

        for (String lws : LWS_VALUES) {
            doTest(lws, parameters);
        }
    }
    private void doTest(String lws, Parameter... parameters)
            throws IOException {
======= fetch "private void doTest(Parameter... parameters) throws IOException {" 7aeab0e^:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

            sb.append(p.toString());
======= fetch "public String toString() {" 7aeab0e^:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

            return toString("");
        }
        public String toString(String lws) {
======= fetch "public String toString() {" 7aeab0e^:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

            sb.append(lws);
======= fetch "public String toString() {" 7aeab0e^:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

            sb.append(lws);
======= fetch "public String toString() {" 7aeab0e^:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

            sb.append(lws);
======= fetch "public String toString() {" 7aeab0e^:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

            sb.append(lws);
======= fetch "public String toString() {" 7aeab0e^:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

            sb.append(lws);
======= fetch "public String toString() {" 7aeab0e^:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

    }

======= fetch "private boolean loadedByThisOrChild(Object o) {" c06707c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            while (iter.hasNext()) {
                Object entry = iter.next();
                if (loadedByThisOrChild(entry)) {
                    return true;
======= fetch "private boolean loadedByThisOrChild(Object o) {" c06707c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            } catch (ConcurrentModificationException e) {
                log.warn(sm.getString(
                        "webappClassLoader", clazz.getName(), getContextName()),
                        e);

======= fetch "public void doFilter(ServletRequest request, ServletResponse response," 2df191f^:"java/org/apache/tomcat/websocket/server/WsFilter.java"

        // Validate the rest of the headers and reject the request if that
        // validation fails
======= fetch "public void doFilter(ServletRequest request, ServletResponse response," 2df191f^:"java/org/apache/tomcat/websocket/server/WsFilter.java"

        // Check to see if this WebSocket implementation has a matching mapping
        WsServerContainer sc = WsServerContainer.getServerContainer();
        String path;
        String pathInfo = req.getPathInfo();
        if (pathInfo == null) {
            path = req.getServletPath();
        } else {
            path = req.getServletPath() + pathInfo;
        }
        WsMappingResult mappingResult = sc.findMapping(path);
        if (mappingResult == null) {
            // No endpoint registered for the requested path. Let the
            // application handle it (it might redirect or forward for example)
            chain.doFilter(request, response);
            return;
        }
        // Validate the rest of the headers and reject the request if that
        // validation fails
======= fetch "public void doFilter(ServletRequest request, ServletResponse response," 2df191f^:"java/org/apache/tomcat/websocket/server/WsFilter.java"

        // Need an Endpoint instance to progress this further
        WsServerContainer sc = WsServerContainer.getServerContainer();
        String path;
        String pathInfo = req.getPathInfo();
        if (pathInfo == null) {
            path = req.getServletPath();
        } else {
            path = req.getServletPath() + pathInfo;
        }
        WsMappingResult mappingResult = sc.findMapping(path);
        if (mappingResult == null) {
            // No endpoint registered for the requested path. Let the
            // application handle it (it might redirect or forward for example)
            chain.doFilter(request, response);
            return;
        }
======= fetch "public void doFilter(ServletRequest request, ServletResponse response," 2df191f^:"java/org/apache/tomcat/websocket/server/WsFilter.java"

======= fetch "public void doFilter(ServletRequest request, ServletResponse response," 2df191f^:"java/org/apache/tomcat/websocket/server/WsFilter.java"


======= fetch "private void doCollection(TagPluginContext ctxt) {" d440ae2^:"java/org/apache/jasper/tagplugins/jstl/core/ForEach.java"

        // String
        ctxt.generateJavaSource("else if (" + itemsV + " instanceof String)");
        ctxt.generateJavaSource(iterV + "=toIterator(new StringTokenizer((String)" + itemsV + ", \",\"));");
======= fetch "public void testBug54242() throws Exception {" d440ae2^:"test/org/apache/jasper/tagplugins/jstl/core/TestForEach.java"

    @Test
    public void testBug54888() throws Exception {
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug54888.jsp", res, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        String body = res.toString();
        Assert.assertTrue(body.contains("OK - 1"));
        Assert.assertTrue(body.contains("OK - 2"));
        Assert.assertTrue(body.contains("OK - 3"));
    }
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
         pageEncoding="ISO-8859-1" session="true"
         import="java.io.Reader,java.io.StringReader" %>
  <body>
    <c:forEach items="1,2,3" var="foo">
      <p>OK - ${foo}</p>
    </c:forEach>
  </body>

======= fetch "private void processChars() throws SAXException {" 1631be1^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        if (tagDependentNesting > 0) {
======= fetch "public void testBug47977() throws Exception {" 1631be1^:"test/org/apache/jasper/compiler/TestJspDocumentParser.java"

        assertEquals(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, rc);
======= fetch "public void testBug48827() throws Exception {" 1631be1^:"test/org/apache/jasper/compiler/TestJspDocumentParser.java"

        assertNull(e);
======= fetch "public void testBug48827() throws Exception {" 1631be1^:"test/org/apache/jasper/compiler/TestJspDocumentParser.java"

    @Test
    public void testBug54801() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        // app dir is relative to server home
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug54801a.jspx", bc, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        bc.recycle();
        rc = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug54801b.jspx", bc, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
    }
    @Test
    public void testBug54821() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        // app dir is relative to server home
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug54821a.jspx", bc, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        bc.recycle();
        rc = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug54821b.jspx", bc, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
   }
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  // ${foo}
  out.println("Hello, world!!");
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  // ${foo}
  out.println("Hello, world!!");
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

======= fetch "public void fireOnComplete() {" 4171baf^:"java/org/apache/catalina/core/AsyncContextImpl.java"

                } catch (IOException ioe) {
======= fetch "public void fireOnComplete() {" 4171baf^:"java/org/apache/catalina/core/AsyncContextImpl.java"

                            listener.getClass().getName() + "]", ioe);
======= fetch "public boolean timeout() {" 4171baf^:"java/org/apache/catalina/core/AsyncContextImpl.java"

                    } catch (IOException ioe) {
======= fetch "public boolean timeout() {" 4171baf^:"java/org/apache/catalina/core/AsyncContextImpl.java"

                                listener.getClass().getName() + "]", ioe);
======= fetch "public void setStarted(Context context, ServletRequest request," 4171baf^:"java/org/apache/catalina/core/AsyncContextImpl.java"

            } catch (IOException ioe) {
======= fetch "public void setStarted(Context context, ServletRequest request," 4171baf^:"java/org/apache/catalina/core/AsyncContextImpl.java"

                        listener.getClass().getName() + "]", ioe);
======= fetch "public void setErrorState(Throwable t, boolean fireOnError) {" 4171baf^:"java/org/apache/catalina/core/AsyncContextImpl.java"

                } catch (IOException ioe) {
======= fetch "public void setErrorState(Throwable t, boolean fireOnError) {" 4171baf^:"java/org/apache/catalina/core/AsyncContextImpl.java"

                            listener.getClass().getName() + "]", ioe);
======= fetch "public void testCommitOnComplete() throws Exception {" 4171baf^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        private int status = 200;
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 4171baf^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    @Test
    public void testBug54178() throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        File docBase = new File(System.getProperty("java.io.tmpdir"));
        Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
        Bug54178ServletA bug54178ServletA = new Bug54178ServletA();
        Wrapper wrapper =
            Tomcat.addServlet(ctx, "bug54178ServletA", bug54178ServletA);
        wrapper.setAsyncSupported(true);
        ctx.addServletMapping("/bug54178ServletA", "bug54178ServletA");
        Bug54178ServletB bug54178ServletB = new Bug54178ServletB();
        Tomcat.addServlet(ctx, "bug54178ServletB", bug54178ServletB);
        ctx.addServletMapping("/bug54178ServletB", "bug54178ServletB");
        tomcat.start();
        ByteChunk body = new ByteChunk();
        int rc = -1;
        try {
            rc = getUrl("http://localhost:" + getPort() + "/bug54178ServletA?" +
                    Bug54178ServletA.PARAM_NAME + "=bar",
                    body, null);
        } catch (IOException ioe) {
            // This may happen if test fails. Output the exception in case it is
            // useful and let asserts handle the failure
            ioe.printStackTrace();
        }
        assertEquals(HttpServletResponse.SC_OK, rc);
        body.recycle();
        rc = getUrl("http://localhost:" + getPort() + "/bug54178ServletB",
                body, null);
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertEquals("OK", body.toString());
    }
    private static class Bug54178ServletA extends HttpServlet {
        public static final String PARAM_NAME = "foo";
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            req.getParameter(PARAM_NAME);
            AsyncContext actxt = req.startAsync();
            actxt.addListener(new Bug54178AsyncListener());
            actxt.complete();
        }
    }
    private static class Bug54178ServletB extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setContentType("text/plain");
            PrintWriter pw = resp.getWriter();
            String result = req.getParameter(Bug54178ServletA.PARAM_NAME);
            if (result == null) {
                pw.write("OK");
            } else {
                pw.write("FAIL");
            }
        }
    }
    private static class Bug54178AsyncListener implements AsyncListener {
        @Override
        public void onComplete(AsyncEvent event) throws IOException {
            throw new RuntimeException("Testing Bug54178");
        }
        @Override
        public void onTimeout(AsyncEvent event) throws IOException {
            // NO-OP
        }
        @Override
        public void onError(AsyncEvent event) throws IOException {
            // NO-OP
        }
        @Override
        public void onStartAsync(AsyncEvent event) throws IOException {
            // NO-OP
        }
    }

======= fetch "private void postWorkDirectory() {" 59a0676^:"java/org/apache/catalina/core/StandardContext.java"

            String temp = getName();

======= fetch "public void doFilter(ServletRequest request, ServletResponse response," 67ed3e7^:"java/org/apache/tomcat/websocket/server/WsFilter.java"

            // Note an HTTP request that includes a valid upgrade request to
======= fetch "public void doFilter(ServletRequest request, ServletResponse response," 67ed3e7^:"java/org/apache/tomcat/websocket/server/WsFilter.java"

        if (mappingResult == null) {
            // No endpoint registered for the requested path. Let the
            // application handle it (it might redirect or forward for example)
            chain.doFilter(request, response);
            return;
        }
======= fetch "public void setServletContext(ServletContext servletContext) {" 67ed3e7^:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

        fr.addMappingForUrlPatterns(null, false, "/*");
======= fetch "public WsMappingResult findMapping(String path) {" 67ed3e7^:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

        if (templateMatches == null) {
            // No templates with an equal number of segments so there will be
            // no matches
            return null;
        }

======= fetch "public void end() {" e26d61d^:"webapps/examples/WEB-INF/classes/websocket/chat/ChatAnnotation.java"

        try {
            session.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    private static final AsynchronousChannelGroup asynchronousChannelGroup;
    static {
        AsynchronousChannelGroup result = null;
        // Need to do this with the right thread context class loader else the
        // first web app to call this will trigger a leak
        ClassLoader original = Thread.currentThread().getContextClassLoader();
        try {
            Thread.currentThread().setContextClassLoader(
                    AsyncIOThreadFactory.class.getClassLoader());
            // These are the same settings as the default
            // AsynchronousChannelGroup
            int initialSize = Runtime.getRuntime().availableProcessors();
            ExecutorService executorService = new ThreadPoolExecutor(
                    0,
                    Integer.MAX_VALUE,
                    Long.MAX_VALUE, TimeUnit.MILLISECONDS,
                    new SynchronousQueue<Runnable>(),
                    new AsyncIOThreadFactory());
            try {
                result = AsynchronousChannelGroup.withCachedThreadPool(
                        executorService, initialSize);
            } catch (IOException e) {
                // No good reason for this to happen.
                throw new IllegalStateException(sm.getString(
                        "wsWebSocketContainer.asynchronousChannelGroupFail"));
            }
        } finally {
            Thread.currentThread().setContextClassLoader(original);
        }
        asynchronousChannelGroup = result;
    }
======= fetch "public Session connectToServer(Endpoint endpoint," d2630df^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

            socketChannel = AsynchronousSocketChannel.open();
======= fetch "public Session connectToServer(Endpoint endpoint," d2630df^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

            throw new DeploymentException("TODO", ioe);
======= fetch "private SSLEngine createSSLEngine(Map<String,Object> userProperties)" d2630df^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

            throw new DeploymentException("TODO", e);
======= fetch "public int getProcessPeriod() {" d2630df^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

    /**
     * Create threads for AsyncIO that have the right context class loader to
     * prevent memory leaks.
     */
    private static class AsyncIOThreadFactory implements ThreadFactory {
        private AtomicInteger count = new AtomicInteger(0);
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r);
            t.setName("WebSocketClient-AsyncIO-" + count.incrementAndGet());
            t.setContextClassLoader(this.getClass().getClassLoader());
            t.setDaemon(true);
            return t;
        }
    }

======= fetch "public void addEndpoint(ServerEndpointConfig sec)" 0339fec^:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

                templateMatches = new TreeSet<>();
======= fetch "public void addEndpoint(Class<?> pojo) throws DeploymentException {" 0339fec^:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

                templateMatches =
                        new TreeSet<>(new TemplatePathMatchComparator());
======= fetch "public UriTemplate getUriTemplate() {" 0339fec^:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

    /**
     * This Comparator implementation is thread-safe so only create a single
     * instance.
     */
======= fetch "public UriTemplate getUriTemplate() {" 0339fec^:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

        private static final TemplatePathMatchComparator INSTANCE =
                new TemplatePathMatchComparator();
        public static TemplatePathMatchComparator getInstance() {
            return INSTANCE;
        }
        private TemplatePathMatchComparator() {
            // Hide default constructor
        }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    @Test
    public void testBug54807() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        ctx.addApplicationListener(Bug54807Config.class.getName());
        Tomcat.addServlet(ctx, "default", new DefaultServlet());
        ctx.addServletMapping("/", "default");
        tomcat.start();
        Assert.assertEquals(LifecycleState.STARTED, ctx.getState());
    }
    public static class Bug54807Config extends WsListener {
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            super.contextInitialized(sce);
            WsServerContainer sc = WsServerContainer.getServerContainer();
            ServerEndpointConfig sec = ServerEndpointConfig.Builder.create(
                    TesterEchoServer.Basic.class, "/{param}").build();
            try {
                sc.addEndpoint(sec);
            } catch (DeploymentException e) {
                throw new RuntimeException(e);
            }
        }
    }

======= fetch "public void onSynStream(SpdyStream str) throws IOException {" 3da2133^:"java/org/apache/coyote/spdy/SpdyProcessor.java"

                request.requestURI().setBytes(frame.data, frame.off, valueLen);

======= fetch "public void scan(File file) throws IOException {" e97e158^:"java/org/apache/catalina/startup/ContextConfig.java"

                } else {
                    // If there is no web.xml, normal folder no impact on
                    // distributable
                    fragment.setDistributable(true);

======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" d025179^:"java/org/apache/tomcat/websocket/server/WsServlet.java"

                ep = (Endpoint) sec.getEndpointClass().newInstance();
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" d025179^:"java/org/apache/tomcat/websocket/server/WsServlet.java"

        } catch (InstantiationException | IllegalAccessException e) {

    private boolean closed = false;
======= fetch "protected void processInputBuffer() throws IOException {" cf0c064^:"java/org/apache/tomcat/websocket/WsFrameBase.java"

                if (closed) {
                    throw new IOException(sm.getString("wsFrame.closed"));
                }
======= fetch "protected void processInputBuffer() throws IOException {" cf0c064^:"java/org/apache/tomcat/websocket/WsFrameBase.java"

                // If a close frame has been received, no further data should
                // have seen
                if (!open) {
                    throw new IOException(sm.getString("wsFrame.closed"));
                }
======= fetch "private boolean processDataControl() throws IOException {" cf0c064^:"java/org/apache/tomcat/websocket/WsFrameBase.java"

            closed = true;
======= fetch "protected static long byteArrayToLong(byte[] b, int start, int len)" cf0c064^:"java/org/apache/tomcat/websocket/WsFrameBase.java"

    protected boolean isOpen() {
        return open;
    }
======= fetch "private void processSocketRead() throws IOException {" cf0c064^:"java/org/apache/tomcat/websocket/WsFrameClient.java"

        channel.read(response, null, handler);
======= fetch "public void onDataAvailable() throws IOException {" cf0c064^:"java/org/apache/tomcat/websocket/server/WsFrameServer.java"

            while (sis.isReady()) {

======= fetch "public void closeInvoked() {" 8cf47b4^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java"

            closed = true;
            delegate = null;
======= fetch "public void closeInvoked() {" 8cf47b4^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java"

            closed = true;
            delegate = null;
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Interceptor that counts opened Statements. Is used by tests.
 */
    private final AtomicInteger countOpen = new AtomicInteger();
    private final AtomicInteger countClosed = new AtomicInteger();
    public int getActiveCount() {
        return countOpen.get() - countClosed.get();
    }
    @Override
    protected Object createDecorator(Object proxy, Method method,
            Object[] args, Object statement, Constructor<?> constructor,
            String sql) throws InstantiationException, IllegalAccessException,
            InvocationTargetException {
        Object result;
        StatementProxy statementProxy = new StatementProxy(
                (Statement) statement, sql);
        result = constructor.newInstance(new Object[] { statementProxy });
        statementProxy.setActualProxy(result);
        statementProxy.setConnection(proxy);
        statementProxy.setConstructor(constructor);
        countOpen.incrementAndGet();
        return result;
    }
    private class StatementProxy extends
            StatementDecoratorInterceptor.StatementProxy<Statement> {
        public StatementProxy(Statement delegate, String sql) {
            super(delegate, sql);
        }
        @Override
        public void closeInvoked() {
            countClosed.incrementAndGet();
            super.closeInvoked();
        }
    }
======= fetch "public void testPreparedStatementCache2() throws Exception {" 8cf47b4^:"modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestStatementCache.java"

    public void testStatementClose1() throws Exception {
        init();
        datasource.setJdbcInterceptors(
                TestStatementCacheInterceptor.class.getName()
                + "(prepared=true,callable=false,max=1);"
                + StatementCounterInterceptor.class.getName());
        Connection con = datasource.getConnection();
        StatementCounterInterceptor counter = findInterceptor(con, StatementCounterInterceptor.class);
        PreparedStatement ps1, ps2;
        ps1 = con.prepareStatement("select 1");
        Assert.assertEquals(1, counter.getActiveCount());
        ps1.close();
        Assert.assertEquals("Statement goes into cache, not closed", 1, counter.getActiveCount());
        ps1 = con.prepareStatement("select 1");
        Assert.assertEquals("Reusing statement from cache", 1, counter.getActiveCount());
        ps2 = con.prepareStatement("select 1");
        Assert.assertEquals("Reusing statement from cache", 2, counter.getActiveCount());
        ps2.close();
        Assert.assertEquals("Statement goes into cache, not closed", 2, counter.getActiveCount());
        ps1.close();
        // Cache has "max=1". The following tests BZ 54732.
        Assert.assertEquals("Statement does not go into cache, closed", 1, counter.getActiveCount());
        con.close();
        Assert.assertEquals("Connection returned to the pool. Statement is in cache", 1, counter.getActiveCount());
        datasource.close();
        Assert.assertEquals("Pool cleared. All statements in cache are closed", 0, counter.getActiveCount());
    }
    @Test
    public void testStatementClose2() throws Exception {
        init();
        datasource.setJdbcInterceptors(
                TestStatementCacheInterceptor.class.getName()
                + "(prepared=false,callable=false,max=10);"
                + StatementCounterInterceptor.class.getName());
        Connection con = datasource.getConnection();
        StatementCounterInterceptor counter = findInterceptor(con, StatementCounterInterceptor.class);
        PreparedStatement ps1 = con.prepareStatement("select 1");
        Assert.assertEquals(1, counter.getActiveCount());
        ps1.close();
        Assert.assertEquals("Statement is not pooled, closes immediately", 0, counter.getActiveCount());
    }
    @Test
======= fetch "public TestStatementCacheInterceptor() {" 8cf47b4^:"modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestStatementCache.java"

    /**
     * Helper method that finds interceptor instance in interceptor chain of a
     * proxied class.
     *
     * @param proxy
     *            Proxy class
     * @param clazz
     *            Interceptor class that we are looking for
     * @return Instance of <code>clazz</code>
     */
    private static <T extends JdbcInterceptor> T findInterceptor(Object proxy,
            Class<T> clazz) {
        JdbcInterceptor interceptor = (JdbcInterceptor) Proxy
                .getInvocationHandler(proxy);
        while (interceptor != null) {
            if (clazz.isInstance(interceptor)) {
                return clazz.cast(interceptor);
            }
            interceptor = interceptor.getNext();
        }
        return null;
    }

======= fetch "public String toString() {" 8445d9a^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

            for (int i=0; i<fields.length; i++) {
======= fetch "public String toString() {" 8445d9a^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

                    String name = prefix[j] + fields[i].substring(0, 1).toUpperCase(Locale.ENGLISH) +
                                  fields[i].substring(1);
======= fetch "public String toString() {" 8445d9a^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

                    buf.append(fields[i]);
======= fetch "public String toString() {" 8445d9a^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

                    buf.append(m.invoke(this, new Object[0]));
======= fetch "public String toString() {" 8445d9a^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

            //shouldn;t happen
            x.printStackTrace();

======= fetch "public WebSocketContainer getContainer() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public void addMessageHandler(MessageHandler listener) {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public void addMessageHandler(MessageHandler listener) {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public void removeMessageHandler(MessageHandler listener) {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public String getProtocolVersion() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public String getNegotiatedSubprotocol() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public String getNegotiatedSubprotocol() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public boolean isSecure() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public long getMaxIdleTimeout() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public void setMaxIdleTimeout(long timeout) {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public void setMaxBinaryMessageBufferSize(int max) {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public int getMaxBinaryMessageBufferSize() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public void setMaxTextMessageBufferSize(int max) {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public int getMaxTextMessageBufferSize() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public int getMaxTextMessageBufferSize() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public int getMaxTextMessageBufferSize() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public int getMaxTextMessageBufferSize() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public void close(CloseReason closeReason) throws IOException {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

            fireEndpointOnClose(closeReason);
======= fetch "void onClose(CloseReason closeReason) {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

                fireEndpointOnClose(closeReason);
======= fetch "void onClose(CloseReason closeReason) {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

    private void fireEndpointOnClose(CloseReason closeReason) {
        // Fire the onClose event
        Thread t = Thread.currentThread();
        ClassLoader cl = t.getContextClassLoader();
        t.setContextClassLoader(applicationClassLoader);
        try {
            localEndpoint.onClose(this, closeReason);
        } finally {
            t.setContextClassLoader(cl);
        }
    }
======= fetch "private void sendCloseMessage(CloseReason closeReason) {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

            // Fire the onClose event
            Thread t = Thread.currentThread();
            ClassLoader cl = t.getContextClassLoader();
            t.setContextClassLoader(applicationClassLoader);
            try {
                localEndpoint.onClose(this, closeReason);
            } finally {
                t.setContextClassLoader(cl);
            }
======= fetch "public URI getRequestURI() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public URI getRequestURI() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public String getQueryString() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public Principal getUserPrincipal() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public Principal getUserPrincipal() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "public String getId() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= fetch "protected void expire() {" 12f89ff^:"java/org/apache/tomcat/websocket/WsSession.java"

    private void checkState() {
        if (!isOpen()) {
            throw new IllegalStateException(sm.getString("wsSession.closed"));
        }
    }
======= fetch "public void testSessionExpiryContainer() throws Exception {" 12f89ff^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

        setA = s3a.getOpenSessions();
        while (setA.size() > 0 && count < 8) {
======= fetch "public void testSessionExpiryContainer() throws Exception {" 12f89ff^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

            setA = s3a.getOpenSessions();
======= fetch "public void testSessionExpiryContainer() throws Exception {" 12f89ff^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

        if (setA.size() > 0) {
            Assert.fail("There were [" + setA.size() + "] open sessions");
======= fetch "public void testSessionExpirySession() throws Exception {" 12f89ff^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

            Assert.assertEquals(expected, setA.size());
======= fetch "public void testSessionExpirySession() throws Exception {" 12f89ff^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

            while (setA.size() == expected && count < 5) {
======= fetch "public void testSessionExpirySession() throws Exception {" 12f89ff^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                setA = s3a.getOpenSessions();
======= fetch "public void testSessionExpirySession() throws Exception {" 12f89ff^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

        Assert.assertEquals(0, setA.size());
======= fetch "public void testSessionExpirySession() throws Exception {" 12f89ff^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

    private int getOpenCount(Set<Session> sessions) {
        int result = 0;
        for (Session session : sessions) {
            if (session.isOpen()) {
                result++;
            }
        }
        return result;
    }

======= fetch "public void sendObjectByCompletion(Object obj, SendHandler completion) {" 80ef59a^:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java"

                Writer w = getSendWriter();
                ((Encoder.TextStream) encoder).encode(obj, w);
======= fetch "public void sendObjectByCompletion(Object obj, SendHandler completion) {" 80ef59a^:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java"

                OutputStream os = getSendStream();
                ((Encoder.BinaryStream) encoder).encode(obj, os);

======= fetch "public final void onClose(Session session, CloseReason closeReason) {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoEndpointBase.java"

                        methodMapping.getOnCloseArgs(pathParameters, session));
    protected final boolean unwrap;
======= fetch "public PojoMessageHandlerBase(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerBase.java"

            Session session, Object[] params, int indexPayload, boolean unwrap,
======= fetch "public PojoMessageHandlerBase(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerBase.java"

        this.unwrap = unwrap;
======= fetch "public PojoMessageHandlerPartialBase(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialBase.java"

            boolean unwrap, int indexBoolean, int indexSession) {
        super(pojo, method, session, params, indexPayload, unwrap,
======= fetch "public final void onMessage(T message, boolean last) {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialBase.java"

        if (unwrap) {
======= fetch "public PojoMessageHandlerPartialBinary(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialBinary.java"

            Session session, Object[] params, int indexPayload, boolean unwrap,
======= fetch "public PojoMessageHandlerPartialBinary(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialBinary.java"

        super(pojo, method, session, params, indexPayload, unwrap, indexBoolean,
======= fetch "public PojoMessageHandlerPartialText(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialText.java"

            Session session, Object[] params, int indexPayload, boolean unwrap,
======= fetch "public PojoMessageHandlerPartialText(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialText.java"

        super(pojo, method, session, params, indexPayload, unwrap, indexBoolean,
======= fetch "public PojoMessageHandlerWholeBase(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBase.java"

            boolean unwrap, int indexSession) {
        super(pojo, method, session, params, indexPayload, unwrap,
======= fetch "public final void onMessage(T message) {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBase.java"

            // Not decoded. Unwrap if required. Unwrap only ever applies to
            // ByteBuffers
            if (unwrap) {
                ByteBuffer bb = (ByteBuffer) message;
                byte[] array = new byte[bb.remaining()];
                bb.get(array);
                payload = array;
======= fetch "public final void onMessage(T message) {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBase.java"

    protected Object convert(T message) {
        return message;
    }
    private final boolean isForInputStream;
======= fetch "public PojoMessageHandlerWholeBinary(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBinary.java"

            int indexPayload, boolean unwrap, int indexSession) {
        super(pojo, method, session, params, indexPayload, unwrap, indexSession);
======= fetch "public PojoMessageHandlerWholeBinary(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBinary.java"

                } else if (Decoder.TextStream.class.isAssignableFrom(
                        decoderClazz)) {
======= fetch "public PojoMessageHandlerWholeBinary(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBinary.java"

        this.isForInputStream = isForInputStream;
======= fetch "protected Object decode(ByteBuffer message) throws DecodeException {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBinary.java"

    protected Object convert(ByteBuffer message) {
        byte[] array = new byte[message.remaining()];
        message.get(array);
        if (isForInputStream) {
            return new ByteArrayInputStream(array);
        } else {
            return array;
        }
    }
    @Override
======= fetch "public PojoMessageHandlerWholePong(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholePong.java"

            Session session, Object[] params, int indexPayload, boolean unwrap,
======= fetch "public PojoMessageHandlerWholePong(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholePong.java"

        super(pojo, method, session, params, indexPayload, unwrap, indexSession);
======= fetch "public PojoMessageHandlerWholeText(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeText.java"

            int indexPayload, boolean unwrap, int indexSession) {
        super(pojo, method, session, params, indexPayload, unwrap,
======= fetch "public PojoMessageHandlerWholeText(Object pojo, Method method," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeText.java"

                } else if (Decoder.TextStream.class.isAssignableFrom(
                        decoderClazz)) {
======= fetch "protected Object decode(String message) throws DecodeException {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeText.java"

    protected Object convert(String message) {
        return new StringReader(message);
    }
    @Override
======= fetch "public PojoMethodMapping(Class<?> clazzPojo," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

        onOpenParams = getPathParams(onOpen, false);
        onCloseParams = getPathParams(onClose, false);
        onErrorParams = getPathParams(onError, true);
======= fetch "public Method getOnOpen() {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

        return buildArgs(onOpenParams, pathParameters, session, null);
======= fetch "public Method getOnClose() {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            Session session) {
        return buildArgs(onCloseParams, pathParameters, session, null);
======= fetch "public Method getOnError() {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

        return buildArgs(onErrorParams, pathParameters, session, throwable);
======= fetch "public Method getOnError() {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

    private static PojoPathParam[] getPathParams(Method m, boolean isOnError) {
======= fetch "public Method getOnError() {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            } else if (isClose && type.equals(CloseReason.class)) {
                result[i] = new PojoPathParam(type, null);
======= fetch "public Method getOnError() {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            Throwable throwable) {
======= fetch "public Method getOnError() {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            } else if (type.equals(CloseReason.class)) {
                result[i] = closeReason;
======= fetch "private static Object coerceToType(Class<?> type, String value) {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

======= fetch "private static Object coerceToType(Class<?> type, String value) {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

        private int indexInputStream = -1;
        private int indexReader = -1;
======= fetch "public MessageMethod(Method m, List<DecoderEntry> decoderEntries) {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                } else if (types[i] == Reader.class) {
                    if (indexReader == -1) {
                        indexReader = i;
                    } else {
                        throw new IllegalArgumentException(sm.getString(
                                "pojoMethodMapping.duplicateMessageParam",
                                m.getName(), m.getClass().getName()));
                    }
======= fetch "public MessageMethod(Method m, List<DecoderEntry> decoderEntries) {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                } else if (types[i] == InputStream.class) {
                    if (indexInputStream == -1) {
                        indexInputStream = i;
                    } else {
                        throw new IllegalArgumentException(sm.getString(
                                "pojoMethodMapping.duplicateMessageParam",
                                m.getName(), m.getClass().getName()));
                    }
======= fetch "public MessageMethod(Method m, List<DecoderEntry> decoderEntries) {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            if (indexReader != -1) {
                if (indexPayload != -1) {
                    throw new IllegalArgumentException(sm.getString(
                            "pojoMethodMapping.duplicateMessageParam",
                            m.getName(), m.getClass().getName()));
                } else {
                    indexPayload = indexReader;
                }
            }
======= fetch "public MessageMethod(Method m, List<DecoderEntry> decoderEntries) {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            if (indexInputStream != -1) {
                if (indexPayload != -1) {
                    throw new IllegalArgumentException(sm.getString(
                            "pojoMethodMapping.duplicateMessageParam",
                            m.getName(), m.getClass().getName()));
                } else {
                    indexPayload = indexInputStream;
                }
            }
======= fetch "public MessageMethod(Method m, List<DecoderEntry> decoderEntries) {" 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            if(indexReader != -1 && indexBoolean != -1) {
                throw new IllegalArgumentException(sm.getString(
                        "pojoMethodMapping.partialReader",
                        m.getName(), m.getClass().getName()));
            }
            if(indexInputStream != -1 && indexBoolean != -1) {
                throw new IllegalArgumentException(sm.getString(
                        "pojoMethodMapping.partialInputStream",
                        m.getName(), m.getClass().getName()));
            }
======= fetch "public MessageHandler getMessageHandler(Object pojo," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                            config, params, indexByteArray, true, indexSession);
======= fetch "public MessageHandler getMessageHandler(Object pojo," 06800eb^:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                            indexSession);

======= fetch "public Session connectToServer(Endpoint endpoint," ad148dd^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

        if (!("http".equalsIgnoreCase(scheme) ||
                "https".equalsIgnoreCase(scheme))) {
======= fetch "public Session connectToServer(Endpoint endpoint," ad148dd^:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

            if ("http".equalsIgnoreCase(scheme)) {
======= fetch "private void doTestWriter(Class<?> clazz) throws Exception {" ad148dd^:"test/org/apache/tomcat/websocket/TestWsRemoteEndpoint.java"

        URI uri = new URI("http://localhost:" + getPort() +
======= fetch "public void testConnectToServerEndpoint() throws Exception {" ad148dd^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                new URI("http://localhost:" + getPort() +
======= fetch "public void testConnectToServerEndpointNoHost() throws Exception {" ad148dd^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                new URI("http://" + TesterEchoServer.Config.PATH_ASYNC));
======= fetch "private void doBufferTest(boolean isTextBuffer, boolean isServerBuffer," ad148dd^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                        new URI("http://localhost:" + getPort() +
======= fetch "private void doTestWriteTimeoutClient(boolean setTimeoutOnContainer)" ad148dd^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                new URI("http://localhost:" + getPort() + BlockingConfig.PATH));
======= fetch "private void doTestWriteTimeoutServer(boolean setTimeoutOnContainer)" ad148dd^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                new URI("http://localhost:" + getPort() +
======= fetch "private Session connectToEchoServerBasic(WebSocketContainer wsContainer," ad148dd^:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                new URI("http://localhost:" + getPort() +
======= fetch "public void test() throws Exception {" ad148dd^:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

        URI uri = new URI("http://localhost:" + getPort() + "/");
======= fetch "public void test() throws Exception {" ad148dd^:"test/org/apache/tomcat/websocket/pojo/TestPojoMethodMapping.java"

        URI uri = new URI("http://localhost:" + getPort() + "/" + PARAM_ONE +

======= fetch "public void setURIEncoding(String URIEncoding) {" dc16474^:"java/org/apache/catalina/connector/Connector.java"

             this.URIEncodingLower = URIEncoding.toLowerCase(Locale.US);
                    charset.name().toLowerCase(Locale.US), charset);
                        alias.toLowerCase(Locale.US), charset);
======= fetch "public static Charset getCharset(String enc)" dc16474^:"java/org/apache/tomcat/util/buf/B2CConverter.java"

        String lowerCaseEnc = enc.toLowerCase(Locale.US);
            Integer type = fieldTypes.get(field.toLowerCase(Locale.US));
======= fetch "public static MediaType parseMediaType(StringReader input)" dc16474^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

                parameters.put(attribute.toLowerCase(Locale.US), value);
======= fetch "public static MediaType parseMediaType(StringReader input)" dc16474^:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

                parameters.put(attribute.toLowerCase(Locale.US), "");
======= fetch "public String getParameterValue(String parameter) {" dc16474^:"java/org/apache/tomcat/util/http/parser/MediaType.java"

        return parameters.get(parameter.toLowerCase(Locale.US));
======= fetch "public String toString() {" dc16474^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

                    String name = prefix[j] + fields[i].substring(0, 1).toUpperCase(Locale.US) +
            SESSION_COOKIE_NAME.toLowerCase(Locale.US);

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    private static final String PARAM_ONE = "abcde";
    private static final String PARAM_TWO = "12345";
    private static final String PARAM_THREE = "true";
    @Test
    public void test() throws Exception {
        // Set up utility classes
        Server server = new Server();
        SingletonConfigurator.setInstance(server);
        ServerConfigListener.setPojoClazz(Server.class);
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        ctx.addApplicationListener(ServerConfigListener.class.getName());
        WebSocketContainer wsContainer =
                ContainerProvider.getWebSocketContainer();
        tomcat.start();
        Client client = new Client();
        URI uri = new URI("http://localhost:" + getPort() + "/" + PARAM_ONE +
                "/" + PARAM_TWO + "/" + PARAM_THREE);
        Session session = wsContainer.connectToServer(client, uri);
        session.getBasicRemote().sendText("NO-OP");
        session.close();
        // Give server 5s to close
        int count = 0;
        while (count < 50) {
            if (server.isClosed()) {
                break;
            }
            count++;
            Thread.sleep(100);
        }
        if (count == 50) {
            Assert.fail("Server did not process an onClose event within 5 " +
                    "seconds of the client sending a close message");
        }
        // Check no errors
        List<String> errors = server.getErrors();
        for (String error : errors) {
            System.err.println(error);
        }
        Assert.assertEquals("Found errors", 0, errors.size());
    }
    @ClientEndpoint
    public static final class Client {
    }
    @ServerEndpoint(value="/{one}/{two}/{three}",
            configurator=SingletonConfigurator.class)
    public static final class Server {
        private final List<String> errors = new ArrayList<>();
        private volatile boolean closed;
        @OnOpen
        public void onOpen(@PathParam("one") String p1, @PathParam("two")int p2,
                @PathParam("three")boolean p3) {
            checkParams("onOpen", p1, p2, p3);
        }
        @OnMessage
        public void onMessage(@SuppressWarnings("unused") String msg,
                @PathParam("one") String p1, @PathParam("two")int p2,
                @PathParam("three")boolean p3) {
            checkParams("onMessage", p1, p2, p3);
        }
        @OnClose
        public void onClose(@PathParam("one") String p1,
                @PathParam("two")int p2, @PathParam("three")boolean p3) {
            checkParams("onClose", p1, p2, p3);
            closed = true;
        }
        public List<String> getErrors() {
            return errors;
        }
        public boolean isClosed() {
            return closed;
        }
        private void checkParams(String method, String p1, int p2, boolean p3) {
            checkParam(method, PARAM_ONE, p1);
            checkParam(method, PARAM_TWO, Integer.toString(p2));
            checkParam(method, PARAM_THREE, Boolean.toString(p3));
        }
        private void checkParam(String method, String expected, String actual) {
            if (!expected.equals(actual)) {
                errors.add("Method [" + method + "]. Expected [" + expected +
                        "] was + [" + actual + "]");
            }
        }
    }

======= fetch "protected InputSource getWebXmlSource(String filename, String path) {" 7c88af9^:"java/org/apache/catalina/startup/ContextConfig.java"

    /**
     * Parses the given source and stores the parsed data in the given web.xml
     * representation. The byte stream will be closed at the end of the parse
     * operation.
     *
     * @param source Input source containing the XML data to be parsed
     * @param dest The object representation of common elements of web.xml and
     *             web-fragment.xml
     * @param fragment Specifies whether the source is web-fragment.xml or
     *                 web.xml
     */
======= fetch "protected void parseWebXml(InputSource source, WebXml dest," 7c88af9^:"java/org/apache/catalina/startup/ContextConfig.java"

            InputStream is = source.getByteStream();
            if (is != null) {
                try {
                    is.close();
                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                }
            }
======= fetch "public void scan(JarURLConnection jarConn) throws IOException {" 7c88af9^:"java/org/apache/catalina/startup/ContextConfig.java"

                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }
                }
======= fetch "public void scan(File file) throws IOException {" 7c88af9^:"java/org/apache/catalina/startup/ContextConfig.java"

                if (stream != null) {
                    try {
                        stream.close();
                    } catch (Throwable t) {
                        ExceptionUtils.handleThrowable(t);
                    }
                }

     * If this part represents an uploaded file, gets the file name submitted
     * in the upload. Returns {@code null} if no file name is available or if
     * this part is not a file upload.
     *
     * @return the submitted file name or {@code null}.
     */
    public String getSubmittedFileName();
    /**
======= fetch "private void parseParts() {" ca205c1^:"java/org/apache/catalina/connector/Request.java"

                    if (part.getFilename() == null) {
======= fetch "public String getString(String encoding) throws UnsupportedEncodingException {" ca205c1^:"java/org/apache/catalina/core/ApplicationPart.java"

    /**
     * Calls {@link #getSubmittedFileName()}.
     *
     * @deprecated Use {@link #getSubmittedFileName()} from Servlet 3.1 instead.
     */
    @Deprecated
    public String getFilename() {
        return getSubmittedFileName();
    }
======= fetch "public String getString(String encoding) throws UnsupportedEncodingException {" ca205c1^:"java/org/apache/catalina/core/ApplicationPart.java"

    public String getFilename() {
======= fetch "protected String upload(HttpServletRequest request, StringManager smClient)" ca205c1^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                filename =
                    extractFilename(warPart.getHeader("Content-Disposition"));
======= fetch "protected String upload(HttpServletRequest request, StringManager smClient)" ca205c1^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    /*
     * Adapted from FileUploadBase.getFileName()
     */
    private String extractFilename(String cd) {
        String fileName = null;
        if (cd != null) {
            String cdl = cd.toLowerCase(Locale.ENGLISH);
            if (cdl.startsWith("form-data") || cdl.startsWith("attachment")) {
                ParameterParser parser = new ParameterParser();
                parser.setLowerCaseNames(true);
                // Parameter parser can handle null input
                Map<String,String> params =
                    parser.parse(cd, ';');
                if (params.containsKey("filename")) {
                    fileName = params.get("filename");
                    if (fileName != null) {
                        fileName = fileName.trim();
                    } else {
                        // Even if there is no value, the parameter is present,
                        // so we return an empty file name rather than no file
                        // name.
                        fileName = "";
                    }
                }
            }
        }
        return fileName;
    }

======= fetch "public void setFileDateFormat(String fileDateFormat) {" 2a03ca6^:"java/org/apache/catalina/valves/AccessLogValve.java"

        this.fileDateFormat = fileDateFormat;
======= fetch "public void log(Request request, Response response, long time) {" 2a03ca6^:"java/org/apache/catalina/valves/AccessLogValve.java"

     * Rotate the log file if necessary.
     */
    public void rotate() {
        if (rotatable) {
            // Only do a logfile switch check once a second, max.
            long systime = System.currentTimeMillis();
            if ((systime - rotationLastChecked) > 1000) {
                synchronized(this) {
                    if ((systime - rotationLastChecked) > 1000) {
                        rotationLastChecked = systime;
                        String tsDate;
                        // Check for a change of date
                        tsDate = fileDateFormatter.format(new Date(systime));
                        // If the date has changed, switch log files
                        if (!dateStamp.equals(tsDate)) {
                            close(true);
                            dateStamp = tsDate;
                            open();
                        }
                    }
                }
            }
        }
    }
    /**
======= fetch "public void log(CharArrayWriter message) {" 2a03ca6^:"java/org/apache/catalina/valves/AccessLogValve.java"

        if (rotatable) {
            // Only do a logfile switch check once a second, max.
            long systime = System.currentTimeMillis();
            if ((systime - rotationLastChecked) > 1000) {
                synchronized(this) {
                    if ((systime - rotationLastChecked) > 1000) {
                        rotationLastChecked = systime;
                        String tsDate;
                        // Check for a change of date
                        tsDate = fileDateFormatter.format(new Date(systime));
======= fetch "public void log(CharArrayWriter message) {" 2a03ca6^:"java/org/apache/catalina/valves/AccessLogValve.java"

                        // If the date has changed, switch log files
                        if (!dateStamp.equals(tsDate)) {
                            close(true);
                            dateStamp = tsDate;
                            open();
                        }
                    }
                }
            }
        }
======= fetch "protected synchronized void startInternal() throws LifecycleException {" 2a03ca6^:"java/org/apache/catalina/valves/AccessLogValve.java"

        if (format == null) {
            format = "";
            setFileDateFormat(format);
        }

            String ciphers[] = ssf.getSupportedCipherSuites();
            for (String cipher : ciphers) {
======= fetch "public void handshake(Socket sock) throws IOException {" fedf189^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            return context.getDefaultSSLParameters().getCipherSuites();
======= fetch "public void handshake(Socket sock) throws IOException {" fedf189^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            return context.getDefaultSSLParameters().getCipherSuites();
======= fetch "protected CertPathParameters getParameters(String algorithm," fedf189^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            return context.getDefaultSSLParameters().getProtocols();

    static ServerContainer getServerContainer() {

======= fetch "private void doWriteBytes(ByteBuffer buffer, boolean finalFragment)" e1d16fd^:"java/org/apache/catalina/websocket/WsOutbound.java"

        outputStream.write(buffer.array(), 0, buffer.limit());

======= fetch "protected boolean restoreRequest(Request request, Session session)" c9e056c^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

        // Swallow any request body since we will be replacing it
        // Need to do this before headers are restored as AJP connector uses
        // content length header to determine how much data needs to be read for
        // request body
        byte[] buffer = new byte[4096];
        InputStream is = request.createInputStream();
        while (is.read(buffer) >= 0) {
            // Ignore request body
        }
======= fetch "protected boolean restoreRequest(Request request, Session session)" c9e056c^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

        // Swallow any request body since we will be replacing it
        byte[] buffer = new byte[4096];
        InputStream is = request.createInputStream();
        while (is.read(buffer) >= 0) {
            // Ignore request body
        }

======= fetch "public synchronized void close(int status, ByteBuffer data)" 1255d32^:"java/org/apache/catalina/websocket/WsOutbound.java"

        // Send any partial data we have
        doFlush(false);
======= fetch "private void doWriteBytes(ByteBuffer buffer, boolean finalFragment)" 1255d32^:"java/org/apache/catalina/websocket/WsOutbound.java"

        if (closed) {
            throw new IOException(sm.getString("outbound.closed"));
        }

======= fetch "public static void writeVMState(PrintWriter writer, int mode)" 78b3c10^:"java/org/apache/catalina/manager/StatusTransformer.java"

                writer.write(" usageUsed='" + usage.getInit() + "'/>");

======= fetch "private void setClassPath() {" 9ad4904^:"java/org/apache/catalina/loader/WebappLoader.java"

        if (delegate && loader != null) {
            // Skip the webapp loader for now as delegation is enabled
            loader = loader.getParent();
        }
======= fetch "private void setClassPath() {" 9ad4904^:"java/org/apache/catalina/loader/WebappLoader.java"

        if (delegate) {
            // Delegation was enabled, go back and add the webapp paths
            loader = getClassLoader();
            if (loader != null) {
                buildClassPath(servletContext, classpath, loader);
            }
        }

======= fetch "protected void convertURI(MessageBytes uri, Request request)" b2f0e7c^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                } else {
                    conv.recycle();

 * TODO SERVLET3 - Add comments
     * Obtains the value of the specified mime header for the part.
     * @param name Header name
     * @return The header value or <code>null</code> if the header is not
     *         present

     * Changes the session ID of the session associated with this request. This
     * method does not create a new session object it only changes the ID of the
     * current session.
     *
     * @return the new session ID allocated to the session
     * @see HttpSessionIdListener
     * @since Servlet 3.1
     */
    public String changeSessionId();
    /**
======= fetch "public HttpSession getSession() {" c11952d^:"java/javax/servlet/http/HttpServletRequestWrapper.java"

     * The default behavior of this method is to call changeSessionId() on the
     * wrapped request object.
     */
    @Override
    public String changeSessionId() {
        return this._getHttpServletRequest().changeSessionId();
    }
    /**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Implementations of this interface are notified when an {@link HttpSession}'s
 * ID changes. To receive notification events, the implementation class must be
 * configured in the deployment descriptor for the web application, annotated
 * with {@link javax.servlet.annotation.WebListener} or registered by calling an
 * addListener method on the {@link javax.servlet.ServletContext}.
 *
 * @see HttpSessionEvent
 * @see HttpServletRequest#changeSessionId()
 * @since Servlet 3.1
 */
    /**
     * Notification that a session ID has been changed.
     *
     * @param se the notification event
     * @param oldSessionId the old session ID
     */
    public void sessionIdChanged(HttpSessionEvent se, String oldSessionId);
======= fetch "public void changeSessionId(String newSessionId) {" c11952d^:"java/org/apache/catalina/connector/Request.java"

    /**
     * Changes the session ID of the session associated with this request.
     *
     * @return the old session ID before it was changed
     * @see javax.servlet.http.HttpSessionIdListener
     * @since Servlet 3.1
     */
    @Override
    public String changeSessionId() {
        Session session = this.getSessionInternal(false);
        if (session == null) {
            throw new IllegalStateException(
                sm.getString("coyoteRequest.changeSessionId"));
        }
        Manager manager = this.getContext().getManager();
        manager.changeSessionId(session);
        String newSessionId = session.getId();
        this.changeSessionId(newSessionId);
        return newSessionId;
    }
======= fetch "public HttpSession getSession() {" c11952d^:"java/org/apache/catalina/connector/RequestFacade.java"

    @Override
    public String changeSessionId() {
        if (request == null) {
            throw new IllegalStateException(
                            sm.getString("requestFacade.nullRequest"));
        }
        return request.changeSessionId();
    }
======= fetch "public void addListener(String className) {" c11952d^:"java/org/apache/catalina/core/ApplicationContext.java"

                t instanceof HttpSessionIdListener ||
======= fetch "public void addListener(String className) {" c11952d^:"java/org/apache/catalina/core/ApplicationContext.java"

                    listener instanceof HttpSessionIdListener ||
======= fetch "public boolean listenerStart() {" c11952d^:"java/org/apache/catalina/core/StandardContext.java"

                || (results[i] instanceof HttpSessionIdListener)
======= fetch "protected void handleCHANGE_SESSION_ID(SessionMessage msg,Member sender) throws" c11952d^:"java/org/apache/catalina/ha/session/DeltaManager.java"

            if (notifySessionListenersOnReplication) {
                Object listeners[] = getContext().
                    getApplicationEventListeners();
                if (listeners != null && listeners.length > 0) {
                    HttpSessionEvent event =
                        new HttpSessionEvent(session.getSession());
                    for(Object listener : listeners) {
                        if (!(listener instanceof HttpSessionIdListener))
                            continue;
                        HttpSessionIdListener idListener =
                            (HttpSessionIdListener)listener;
                        try {
                            idListener.
                                sessionIdChanged(event, msg.getSessionID());
                        } catch (Throwable t) {
                            log.error(sm.getString(
                                "standardSession.sessionEvent"), t);
                        }
                    }
                }
            }
======= fetch "public void changeSessionId(Session session) {" c11952d^:"java/org/apache/catalina/session/ManagerBase.java"

        Object listeners[] = context.getApplicationEventListeners();
        if (listeners != null && listeners.length > 0) {
            HttpSessionEvent event =
                new HttpSessionEvent(session.getSession());
            for(Object listener : listeners) {
                if (!(listener instanceof HttpSessionIdListener))
                    continue;
                HttpSessionIdListener idListener =
                    (HttpSessionIdListener)listener;
                try {
                    idListener.sessionIdChanged(event, oldId);
                } catch (Throwable t) {
                    log.error(sm.getString("standardSession.sessionEvent"), t);
                }
            }
        }
======= fetch "public HttpSession getSession() {" c11952d^:"java/org/apache/catalina/websocket/WsHttpServletRequestWrapper.java"

    public String changeSessionId() {
        return getRequest().changeSessionId();
    }
    @Override
      <add>
        <bug>54552</bug>: Servlet 3.1. Implement
        <code>HttpSessionIdListener</code> and
        <code>HttpServletRequest#changeSessionId()</code>. Patch provided by
        Nick Williams. (markt) 
      </add>

======= fetch "protected void report(Request request, Response response," ef9ed07^:"java/org/apache/catalina/valves/ErrorReportValve.java"

        // Do nothing if there is no report for the specified status code
======= fetch "protected void report(Request request, Response response," ef9ed07^:"java/org/apache/catalina/valves/ErrorReportValve.java"

            return;
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" ef9ed07^:"test/org/apache/catalina/valves/TestErrorReportValve.java"

    /**
     * Custom error/status codes should not result in a blank response.
     */
    @Test
    public void testBug54536() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctx, "bug54536", new Bug54536Servlet());
        ctx.addServletMapping("/", "bug54536");
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort(), res, null);
        Assert.assertEquals(Bug54536Servlet.ERROR_STATUS, rc);
        String body = res.toString();
        Assert.assertNotNull(body);
        Assert.assertTrue(body, body.contains(Bug54536Servlet.ERROR_MESSAGE));
    }
    private static final class Bug54536Servlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private static final int ERROR_STATUS = 999;
        private static final String ERROR_MESSAGE = "The sky is falling";
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.sendError(ERROR_STATUS, ERROR_MESSAGE);
        }
    }

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Defines the interface for the expression language interpreter. This allows
 * users to provide custom EL interpreter implementations that can optimise
 * EL processing for an application by , for example, performing code generation
 * for simple expressions.
 */
    /**
     * Returns the string representing the code that will be inserted into the
     * servlet generated for JSP. The default implementation creates a call to
     * {@link org.apache.jasper.runtime.PageContextImpl#proprietaryEvaluate(
     * String, Class, javax.servlet.jsp.PageContext,
     * org.apache.jasper.runtime.ProtectedFunctionMapper, boolean)} but other
     * implementations may produce more optimised code.
     *
     * @param expression a String containing zero or more "${}" expressions
     * @param expectedType the expected type of the interpreted result
     * @param fnmapvar Variable pointing to a function map.
     * @param xmlEscape True if the result should do XML escaping
     * @return a String representing a call to the EL interpreter.
     */
    public String interpreterCall(JspCompilationContext context,
            boolean isTagFile, String expression,
            Class<?> expectedType, String fnmapvar, boolean xmlEscape);
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Provides {@link ELInterpreter} instances for JSP compilation.
 *
 * The search order is as follows:
 * <ol>
 * <li>ELInterpreter instance or implementation class name provided as a
 *     ServletContext attribute</li>
 * <li>Implementation class named in a ServletContext initialisation parameter
 *     </li>
 * <li>Default implementation</li>
 * </ol>
 */
    public static final String EL_INTERPRETER_CLASS_NAME =
            ELInterpreter.class.getName();
    private static final ELInterpreter DEFAULT_INSTANCE =
            new DefaultELInterpreter();
    /**
     * Obtain the correct EL Interpreter for the given web application.
     */
    public static ELInterpreter getELInterpreter(ServletContext context)
            throws Exception {
        ELInterpreter result = null;
        // Search for an implementation
        // 1. ServletContext attribute (set by application or cached by a
        //    previous call to this method).
        Object attribute = context.getAttribute(EL_INTERPRETER_CLASS_NAME);
        if (attribute instanceof ELInterpreter) {
            return (ELInterpreter) attribute;
        } else if (attribute instanceof String) {
            result = createInstance(context, (String) attribute);
        }
        // 2. ServletContext init parameter
        if (result == null) {
            String className =
                    context.getInitParameter(EL_INTERPRETER_CLASS_NAME);
            if (className != null) {
                result = createInstance(context, className);
            }
        }
        // 3. Default
        if (result == null) {
            result = DEFAULT_INSTANCE;
        }
        // Cache the result for next time
        context.setAttribute(EL_INTERPRETER_CLASS_NAME, result);
        return result;
    }
    private static ELInterpreter createInstance(ServletContext context,
            String className) throws Exception {
        return (ELInterpreter) context.getClassLoader().loadClass(
                    className).newInstance();
    }
    private ELInterpreterFactory() {
        // Utility class. Hide default constructor.
    }
    public static class DefaultELInterpreter implements ELInterpreter {
        @Override
        public String interpreterCall(JspCompilationContext context,
                boolean isTagFile, String expression,
                Class<?> expectedType, String fnmapvar, boolean xmlEscape) {
            return JspUtil.interpreterCall(isTagFile, expression, expectedType,
                    fnmapvar, xmlEscape);
        }
    }
    private final ELInterpreter elInterpreter;
======= fetch "private String attributeValue(Node.JspAttribute attr, boolean encode," f8ac6a0^:"java/org/apache/jasper/compiler/Generator.java"

                v = JspUtil.interpreterCall(this.isTagFile, v, expectedType,
                        attr.getEL().getMapName(), false);
======= fetch "public void visit(Node.ELExpression n) throws JasperException {" f8ac6a0^:"java/org/apache/jasper/compiler/Generator.java"

                        + JspUtil.interpreterCall(this.isTagFile, n.getType() +
                                "{" + n.getText() + "}", String.class,
                                n.getEL().getMapName(), false) + ");");
======= fetch "private String evaluateAttribute(TagHandlerInfo handlerInfo," f8ac6a0^:"java/org/apache/jasper/compiler/Generator.java"

                    attrValue = JspUtil.interpreterCall(this.isTagFile, attrValue,
                            c[0], mapName, false);
======= fetch "private void generatePostamble() {" f8ac6a0^:"java/org/apache/jasper/compiler/Generator.java"

    Generator(ServletWriter out, Compiler compiler) {
======= fetch "private void generatePostamble() {" f8ac6a0^:"java/org/apache/jasper/compiler/Generator.java"

        ELInterpreter elInterpreter = null;
        try {
            elInterpreter = ELInterpreterFactory.getELInterpreter(
                    compiler.getCompilationContext().getServletContext());
        } catch (Exception e) {
            err.jspError("jsp.error.el_interpreter_class.instantiation",
                    e.getMessage());
        }
        this.elInterpreter = elInterpreter;
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    public static class SimpleELInterpreter implements ELInterpreter {
        @Override
        public String interpreterCall(JspCompilationContext context,
                boolean isTagFile, String expression, Class<?> expectedType,
                String fnmapvar, boolean xmlEscape) {
            return expression;
        }
    }
    @Test
    public void testBug54239() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        Context ctx = tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ServletContext context = ctx.getServletContext();
        ELInterpreter interpreter =
                ELInterpreterFactory.getELInterpreter(context);
        Assert.assertNotNull(interpreter);
        Assert.assertTrue(interpreter instanceof DefaultELInterpreter);
        context.removeAttribute(ELInterpreter.class.getName());
        context.setAttribute(ELInterpreter.class.getName(),
                SimpleELInterpreter.class.getName());
        interpreter = ELInterpreterFactory.getELInterpreter(context);
        Assert.assertNotNull(interpreter);
        Assert.assertTrue(interpreter instanceof SimpleELInterpreter);
        context.removeAttribute(ELInterpreter.class.getName());
        SimpleELInterpreter simpleInterpreter = new SimpleELInterpreter();
        context.setAttribute(ELInterpreter.class.getName(), simpleInterpreter);
        interpreter = ELInterpreterFactory.getELInterpreter(context);
        Assert.assertNotNull(interpreter);
        Assert.assertTrue(interpreter instanceof SimpleELInterpreter);
        Assert.assertTrue(interpreter == simpleInterpreter);
        context.removeAttribute(ELInterpreter.class.getName());
        context.setInitParameter(ELInterpreter.class.getName(),
                SimpleELInterpreter.class.getName());
        interpreter = ELInterpreterFactory.getELInterpreter(context);
        Assert.assertNotNull(interpreter);
        Assert.assertTrue(interpreter instanceof SimpleELInterpreter);
        context.removeAttribute(ELInterpreter.class.getName());
    }

======= fetch "public int doRead(ByteChunk chunk, Request req)" cc2f8db^:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

            readBytes();
======= fetch "protected void parseEndChunk() throws IOException {" cc2f8db^:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

        // Handle option trailer headers

======= fetch "public DigestAuthenticator() {" b68bbb8^:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

     * The last timestamp used to generate a nonce. Each nonce should get a
     * unique timestamp.
     */
    protected long lastTimestamp = 0;
    protected final Object lastTimestampLock = new Object();
    /**
======= fetch "protected String generateNonce(Request request) {" b68bbb8^:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

        synchronized (lastTimestampLock) {
            if (currentTime > lastTimestamp) {
                lastTimestamp = currentTime;
            } else {
                currentTime = ++lastTimestamp;
            }
        }
    @Test
    public void bug54521() throws LifecycleException {
        DigestAuthenticator digestAuthenticator = new DigestAuthenticator();
        digestAuthenticator.setContainer(new TesterContext());
        digestAuthenticator.start();
        Request request = new TesterRequest();
        final int count = 1000;
        Set<String> nonces = new HashSet<>();
        for (int i = 0; i < count; i++) {
            nonces.add(digestAuthenticator.generateNonce(request));
        }
        Assert.assertEquals(count,  nonces.size());
    }
======= fetch "private static String digest(String input) {" b68bbb8^:"test/org/apache/catalina/authenticator/TestDigestAuthenticator.java"

    private static class TesterRequest extends Request {
        @Override
        public String getRemoteAddr() {
            return "127.0.0.1";
        }
    }

======= fetch "public boolean isSingleThreadModel() {" a993d7c2^:"java/org/apache/catalina/core/StandardWrapper.java"

        // Make sure the Servlet is loaded with the right class loader
        ClassLoader old = Thread.currentThread().getContextClassLoader();
        ClassLoader webappClassLoader =
                ((Context) getParent()).getLoader().getClassLoader();
======= fetch "public boolean isSingleThreadModel() {" a993d7c2^:"java/org/apache/catalina/core/StandardWrapper.java"

            Thread.currentThread().setContextClassLoader(webappClassLoader);
======= fetch "public boolean isSingleThreadModel() {" a993d7c2^:"java/org/apache/catalina/core/StandardWrapper.java"

        } finally {
            Thread.currentThread().setContextClassLoader(old);
======= fetch "public boolean isSingleThreadModel() {" a993d7c2^:"java/org/apache/catalina/core/StandardWrapper.java"

        return (singleThreadModel);

======= fetch "public Poller getPoller() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

     * The socket poller.
     */
    protected AsyncTimeout asyncTimeout = null;
    public AsyncTimeout getAsyncTimeout() {
        return asyncTimeout;
    }
    /**
======= fetch "public void startInternal() throws Exception {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            Thread timeoutThread = new Thread(new AsyncTimeout(),
======= fetch "public void stopInternal() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            poller.stop();
            asyncTimeout.stop();
======= fetch "public void run() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        private volatile boolean asyncTimeoutRunning = true;
======= fetch "public void run() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            while (running) {
======= fetch "public void run() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                while (paused && running) {
======= fetch "public void run() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        protected void stop() {
            asyncTimeoutRunning = false;
        }
======= fetch "public void duplicate(SocketList copy) {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        private volatile boolean pollerRunning = true;
======= fetch "protected void init() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        protected void stop() {
            pollerRunning = false;
        }
======= fetch "protected void destroy() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    this.notify();
======= fetch "protected void destroy() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                            destroySocket(desc[n*2+1]);
======= fetch "public void run() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            while (running) {
======= fetch "public void run() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                while (connectionCount < 1 && addList.size() < 1) {
======= fetch "public void run() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                        if (getSoTimeout() > 0 && running) {
======= fetch "public void run() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    if (getSoTimeout() > 0 && maintain++ > 1000 && running) {
======= fetch "public void run() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        private volatile boolean sendfileRunning = true;
======= fetch "protected void destroy() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            sendfileRunning = false;
======= fetch "public void run() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            while (running) {
======= fetch "public void run() {" bbb13f6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                            maintainTime > 1000000L && running) {

======= fetch "private void checkThreadLocalsForLeaks() {" ea16bda^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        } catch (SecurityException e) {
            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                    getContextName()), e);
        } catch (NoSuchFieldException e) {
            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                    getContextName()), e);
        } catch (ClassNotFoundException e) {
            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                    getContextName()), e);
        } catch (IllegalArgumentException e) {
            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                    getContextName()), e);
        } catch (IllegalAccessException e) {
            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                    getContextName()), e);
        } catch (InvocationTargetException e) {
            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                    getContextName()), e);
        } catch (NoSuchMethodException e) {
            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                    getContextName()), e);

======= fetch "public String toString()  {" e1e4e4e^:"java/org/apache/catalina/tribes/membership/MemberImpl.java"

        StringBuilder buf = new StringBuilder("org.apache.catalina.tribes.membership.MemberImpl[");

    private ServletContext servletContext = null;
    private ELContext elContext = null;
    private PageContext rootJspCtxt;
======= fetch "public JspContextWrapper(JspContext jspContext," ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        if (jspContext instanceof JspContextWrapper) {
            rootJspCtxt = ((JspContextWrapper)jspContext).rootJspCtxt;
        }
        else {
            rootJspCtxt = invokingJspCtxt;
        }
======= fetch "public Object getAttribute(String name, int scope) {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        return invokingJspCtxt.getAttribute(name, scope);
======= fetch "public void setAttribute(String name, Object value, int scope) {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

            invokingJspCtxt.setAttribute(name, value, scope);
======= fetch "public Object findAttribute(String name) {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

            o = invokingJspCtxt.getAttribute(name, REQUEST_SCOPE);
======= fetch "public Object findAttribute(String name) {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

                    o = invokingJspCtxt.getAttribute(name, SESSION_SCOPE);
======= fetch "public Object findAttribute(String name) {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

                    o = invokingJspCtxt.getAttribute(name, APPLICATION_SCOPE);
======= fetch "public void removeAttribute(String name) {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        invokingJspCtxt.removeAttribute(name, REQUEST_SCOPE);
======= fetch "public void removeAttribute(String name) {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

            invokingJspCtxt.removeAttribute(name, SESSION_SCOPE);
======= fetch "public void removeAttribute(String name) {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        invokingJspCtxt.removeAttribute(name, APPLICATION_SCOPE);
======= fetch "public void removeAttribute(String name, int scope) {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

            invokingJspCtxt.removeAttribute(name, scope);
======= fetch "public int getAttributesScope(String name) {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

            return invokingJspCtxt.getAttributesScope(name);
======= fetch "public int getAttributesScope(String name) {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        return invokingJspCtxt.getAttributeNamesInScope(scope);
======= fetch "public JspWriter getOut() {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        return invokingJspCtxt.getOut();
======= fetch "public HttpSession getSession() {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        return invokingJspCtxt.getSession();
======= fetch "public ServletResponse getResponse() {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        return invokingJspCtxt.getResponse();
======= fetch "public ServletContext getServletContext() {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        return invokingJspCtxt.getServletContext();
======= fetch "public ELContext getELContext() {" ce55f25^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        return this.invokingJspCtxt.getELContext();

======= fetch "public void heartbeat() {" 6647531^:"java/org/apache/catalina/tribes/group/GroupChannel.java"

     * @param destination Member[] - destination.length > 1
======= fetch "public UniqueId send(Member[] destination, Serializable msg, int options) throws" 6647531^:"java/org/apache/catalina/tribes/group/GroupChannel.java"

     * @param destination Member[] - destination.length > 1

======= fetch "public void javacError(JavacErrorDetail[] details) throws JasperException {" d7f744c^:"java/org/apache/jasper/compiler/DefaultErrorHandler.java"

                        Integer.valueOf(details[i].getJavaLineNumber()) };

======= fetch "protected String getPassword(Connection dbConnection," 07a930d^:"java/org/apache/catalina/realm/DataSourceRealm.java"

                                 username));
======= fetch "protected String getPassword(Connection dbConnection," 07a930d^:"java/org/apache/catalina/realm/DataSourceRealm.java"

                             username));
======= fetch "protected Principal getPrincipal(String username) {" 07a930d^:"java/org/apache/catalina/realm/DataSourceRealm.java"

                sm.getString("dataSourceRealm.getRoles.exception", username));
======= fetch "protected Principal getPrincipal(String username) {" 07a930d^:"java/org/apache/catalina/realm/DataSourceRealm.java"

                                     username));

======= fetch "protected void populateAnnotationsCache(Class<?> clazz," ac78456^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                                        injections.get(method.getName()),
======= fetch "protected void populateAnnotationsCache(Class<?> clazz," ac78456^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                                break;
======= fetch "public void testBug54379() throws Exception {" ac78456^:"test/org/apache/catalina/startup/TestContextConfig.java"

    public void testBug54448() throws Exception {
======= fetch "public void testBug54448() throws Exception {" ac78456^:"test/org/apache/catalina/startup/TestContextConfig.java"

        assertPageContains("/test/testServlet", "envEntry: 1");
    private int envEntry;
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" ac78456^:"test/org/apache/catalina/startup/TesterServletWithAnnotations.java"

        resp.getWriter().print("envEntry: " + envEntry);
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" ac78456^:"test/org/apache/catalina/startup/TesterServletWithAnnotations.java"

  <env-entry>
    <env-entry-name>envEntry2</env-entry-name>
    <env-entry-type>java.lang.Integer</env-entry-type>
    <env-entry-value>2</env-entry-value>
    <injection-target>
      <injection-target-class>org.apache.catalina.startup.TesterServletWithAnnotations</injection-target-class>
      <injection-target-name>envEntry2</injection-target-name>
    </injection-target>
  </env-entry>
  <env-entry>
    <env-entry-name>envEntry3</env-entry-name>
    <env-entry-type>java.lang.Integer</env-entry-type>
    <env-entry-value>33</env-entry-value>
    <injection-target>
      <injection-target-class>org.apache.catalina.startup.TesterServletWithAnnotations</injection-target-class>
      <injection-target-name>envEntry3</injection-target-name>
    </injection-target>
  </env-entry>

======= fetch "private boolean checkResourceType(ResourceBase resource) {" 74f5b3a^:"java/org/apache/catalina/deploy/NamingResources.java"

            targetType = convertPrimitiveType(targetType);
======= fetch "private boolean checkResourceType(ResourceBase resource) {" 74f5b3a^:"java/org/apache/catalina/deploy/NamingResources.java"

    private Class<?> convertPrimitiveType(Class<?> clazz) {
        if (clazz.equals(char.class)) {
            return Character.class;
        } else if (clazz.equals(int.class)) {
            return Integer.class;
        } else if (clazz.equals(boolean.class)) {
            return Boolean.class;
        } else if (clazz.equals(double.class)) {
            return Double.class;
        } else if (clazz.equals(byte.class)) {
            return Byte.class;
        } else if (clazz.equals(short.class)) {
            return Short.class;
        } else if (clazz.equals(long.class)) {
            return Long.class;
        } else if (clazz.equals(float.class)) {
            return Float.class;
        } else {
            return clazz;
        }
    }
======= fetch "protected static void loadFieldsAnnotation(Context context," 74f5b3a^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

                    String defaultType = field.getType().getCanonicalName();
======= fetch "protected static void loadMethodsAnnotation(Context context," 74f5b3a^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

                    String defaultType =
                            (method.getParameterTypes()[0]).getCanonicalName();
======= fetch "protected static void addResource(Context context, Resource annotation," 74f5b3a^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

            String defaultName, String defaultType) {
======= fetch "protected static void addResource(Context context, Resource annotation," 74f5b3a^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    private static String getType(Resource annotation, String defaultType) {
        String type = annotation.type().getCanonicalName();
        if (type == null || type.equals("java.lang.Object")) {
======= fetch "private static String getType(Resource annotation, String defaultType) {" 74f5b3a^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        return type;
======= fetch "public static boolean isValidLifecycleCallback(Method method) {" 74f5b3a^:"java/org/apache/catalina/util/Introspection.java"

    /**
     * Converts the primitive type to its corresponding wrapper.
     *
     * @param clazz
     *            Class that will be evaluated
     * @return if the parameter is a primitive type returns its wrapper;
     *         otherwise returns the same class
     */
    public static Class<?> convertPrimitiveType(Class<?> clazz) {
        if (clazz.equals(char.class)) {
            return Character.class;
        } else if (clazz.equals(int.class)) {
            return Integer.class;
        } else if (clazz.equals(boolean.class)) {
            return Boolean.class;
        } else if (clazz.equals(double.class)) {
            return Double.class;
        } else if (clazz.equals(byte.class)) {
            return Byte.class;
        } else if (clazz.equals(short.class)) {
            return Short.class;
        } else if (clazz.equals(long.class)) {
            return Long.class;
        } else if (clazz.equals(float.class)) {
            return Float.class;
        } else {
            return clazz;
        }
    }
======= fetch "public void testBug54379() throws Exception {" 74f5b3a^:"test/org/apache/catalina/startup/TestContextConfig.java"

    @Test
    public void testBug54448() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0-fragments");
        Context context = tomcat.addWebapp(null, "/test",
                appDir.getAbsolutePath());
        Tomcat.addServlet(context, "TestServlet",
                "org.apache.catalina.startup.TesterServletWithAnnotations");
        context.addServletMapping("/testServlet", "TestServlet");
        tomcat.enableNaming();
        tomcat.start();
        assertPageContains("/test/testServlet", "envEntry: 1");
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private static final long serialVersionUID = 1L;
    @Resource(mappedName = "1")
    private int envEntry;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        resp.setContentType("text/plain");
        resp.getWriter().print("envEntry: " + envEntry);
    }

======= fetch "public Http11AprProtocol() {" ab44514^:"java/org/apache/coyote/http11/Http11AprProtocol.java"

    /**
     * Disable SSL compression.
     */
    public boolean getSSLDisableCompression() { return ((AprEndpoint)endpoint).getSSLDisableCompression(); }
    public void setSSLDisableCompression(boolean disable) { ((AprEndpoint)endpoint).setSSLDisableCompression(disable); }
    /* Don't use compression even if supported */
    public static final int SSL_OP_NO_COMPRESSION                         = 0x00020000;
======= fetch "public static native long newBIO(long pool, BIOCallback callback)" ab44514^:"java/org/apache/tomcat/jni/SSL.java"

     * Return true if SSL_OP_ if defined.
     * <p>
     * Currently used for testing weather the
     * SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION is supported by OpenSSL.
     * <p>
     * @param op SSL_OP to test.
     * @return true if SSL_OP is supported by OpenSSL library.
======= fetch "public static native long newBIO(long pool, BIOCallback callback)" ab44514^:"java/org/apache/tomcat/jni/SSL.java"

======= fetch "public static native long newBIO(long pool, BIOCallback callback)" ab44514^:"java/org/apache/tomcat/jni/SSL.java"

======= fetch "public Sendfile getSendfile() {" ab44514^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    /**
     * Disables compression of the SSL stream. This thwarts CRIME attack
     * and possibly improves performance by not compressing uncompressible
     * content such as JPEG, etc.
     */
    protected boolean SSLDisableCompression = false;
    /**
     * Set to <code>true</code> to disable SSL compression. This thwarts CRIME
     * attack.
     */
    public void setSSLDisableCompression(boolean SSLDisableCompression) { this.SSLDisableCompression = SSLDisableCompression; }
    public boolean getSSLDisableCompression() { return SSLDisableCompression; }
======= fetch "public void bind() throws Exception {" ab44514^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            // Disable compression if requested
            if (SSLDisableCompression) {
                boolean disableCompressionSupported = false;
                try {
                    disableCompressionSupported = SSL.hasOp(SSL.SSL_OP_NO_COMPRESSION);
                    if (disableCompressionSupported)
                        SSLContext.setOptions(sslContext, SSL.SSL_OP_NO_COMPRESSION);
                } catch (UnsatisfiedLinkError e) {
                    // Ignore
                }
                if (!disableCompressionSupported) {
                    // OpenSSL does not support ciphers ordering.
                    log.warn(sm.getString("endpoint.warn.noDisableCompression",
                                          SSL.versionString()));
                }
            }
    <attribute name="SSLDisableCompression" required="false">
      <p>Disables compression if set to <code>true</code> and OpenSSL supports
      disabling comprssion. Default is <code>false</code> which inherits the
      default compression setting in OpenSSL.</p>
    </attribute>

======= fetch "public Principal authenticate(String username, String clientDigest," c8d5d88^:"java/org/apache/catalina/realm/RealmBase.java"

        String md5a1 = getDigest(username, realm).toLowerCase(Locale.ENGLISH);
======= fetch "public Principal authenticate(String username, String clientDigest," c8d5d88^:"java/org/apache/catalina/realm/RealmBase.java"

        md5a1 = md5a1.toLowerCase(Locale.ENGLISH);

======= fetch "protected void initClassLoader(JspCompilationContext clctxt)" 297b26a^:"java/org/apache/jasper/JspC.java"

    // ----------------------------------------------------------- Constructors
======= fetch "public ClassLoader getClassLoader() {" 297b26a^:"java/org/apache/jasper/servlet/JspCServletContext.java"

        return null;

======= fetch "public void setOomParachuteData(byte[] oomParachuteData) {" 9f657ac^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    private String[] enabledCiphers;
    private String[] enabledProtocols;
======= fetch "public int getLocalPort() {" 9f657ac^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        SSLContext sslContext = getSSLContext();
        if (sslContext != null) {
            SSLEngine engine = getSSLContext().createSSLEngine();
            if (getCiphersArray().length > 0) {
                engine.setEnabledCipherSuites(getCiphersArray());
            }
            return engine.getEnabledCipherSuites();
        } else {
            return new String[0];
        }
======= fetch "public void bind() throws Exception {" 9f657ac^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

            // Determine which cipher suites and protocols to enable
            enabledCiphers = sslUtil.getEnableableCiphers(sslContext);
            enabledProtocols = sslUtil.getEnableableProtocols(sslContext);
======= fetch "protected SSLEngine createSSLEngine() {" 9f657ac^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        if ( getCiphersArray().length > 0 ) engine.setEnabledCipherSuites(getCiphersArray());
        if ( getSslEnabledProtocolsArray().length > 0 ) engine.setEnabledProtocols(getSslEnabledProtocolsArray());
======= fetch "public void handshake(Socket sock) throws IOException {" 9f657ac^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

    /*
     * Determines the SSL cipher suites to be enabled.
     *
     * @param requestedCiphers Comma-separated list of requested ciphers
     * @param supportedCiphers Array of supported ciphers
     *
     * @return Array of SSL cipher suites to be enabled, or null if none of the
     * requested ciphers are supported
     */
    protected String[] getEnabledCiphers(String requestedCiphers,
                                         String[] supportedCiphers) {
        String[] result = null;
        if (ALLOW_ALL_SUPPORTED_CIPHERS.equals(requestedCiphers)) {
            return supportedCiphers;
        }
        if (requestedCiphers != null) {
            Vector<String> vec = null;
            String cipher = requestedCiphers;
            int index = requestedCiphers.indexOf(',');
            if (index != -1) {
                int fromIndex = 0;
                while (index != -1) {
                    cipher =
                        requestedCiphers.substring(fromIndex, index).trim();
                    if (cipher.length() > 0) {
                        /*
                         * Check to see if the requested cipher is among the
                         * supported ciphers, i.e., may be enabled
                         */
                        for (int i=0; supportedCiphers != null
                                     && i<supportedCiphers.length; i++) {
                            if (supportedCiphers[i].equals(cipher)) {
                                if (vec == null) {
                                    vec = new Vector<>();
                                }
                                vec.addElement(cipher);
                                break;
                            }
                        }
                    }
                    fromIndex = index+1;
                    index = requestedCiphers.indexOf(',', fromIndex);
                } // while
                cipher = requestedCiphers.substring(fromIndex);
            }
======= fetch "public void handshake(Socket sock) throws IOException {" 9f657ac^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            if (cipher != null) {
                cipher = cipher.trim();
                if (cipher.length() > 0) {
                    /*
                     * Check to see if the requested cipher is among the
                     * supported ciphers, i.e., may be enabled
                     */
                    for (int i=0; supportedCiphers != null
                                 && i<supportedCiphers.length; i++) {
                        if (supportedCiphers[i].equals(cipher)) {
                            if (vec == null) {
                                vec = new Vector<>();
                            }
                            vec.addElement(cipher);
                            break;
                        }
                    }
                }
======= fetch "public void handshake(Socket sock) throws IOException {" 9f657ac^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

        }
        if (requestedCiphers.isEmpty()) {
            return context.getDefaultSSLParameters().getCipherSuites();
        }
        List<String> ciphers = new ArrayList<String>(requestedCiphers);
        ciphers.retainAll(Arrays.asList(context.getSupportedSSLParameters()
                .getCipherSuites()));
======= fetch "public void handshake(Socket sock) throws IOException {" 9f657ac^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            if (vec != null) {
                result = new String[vec.size()];
                vec.copyInto(result);
======= fetch "public void handshake(Socket sock) throws IOException {" 9f657ac^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

        } else {
            result = sslProxy.getDefaultCipherSuites();
======= fetch "public void handshake(Socket sock) throws IOException {" 9f657ac^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

        return result;
======= fetch "void init() throws IOException {" 9f657ac^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            String requestedCiphers = endpoint.getCiphers();
            enabledCiphers = getEnabledCiphers(requestedCiphers,
                    sslProxy.getSupportedCipherSuites());
======= fetch "protected CertPathParameters getParameters(String algorithm," 9f657ac^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

    /**
     * Set the SSL protocol variants to be enabled.
     * @param socket the SSLServerSocket.
     * @param protocols the protocols to use.
     */
    protected void setEnabledProtocols(SSLServerSocket socket,
            String[] protocols){
        if (protocols != null) {
            socket.setEnabledProtocols(protocols);
        }
    }
    /**
     * Determines the SSL protocol variants to be enabled.
     *
     * @param socket The socket to get supported list from.
     * @param requestedProtocols Array of requested protocol names all of which
     *                           must be non-null and non-zero length
     *
     * @return Array of SSL protocol variants to be enabled, or null if none of
     * the requested protocol variants are supported
     */
    protected String[] getEnabledProtocols(SSLServerSocket socket,
                                           String[] requestedProtocols){
        String[] supportedProtocols = socket.getSupportedProtocols();
        String[] enabledProtocols = null;
        if (requestedProtocols != null && requestedProtocols.length > 0) {
            Vector<String> vec = null;
            for (String protocol : requestedProtocols) {
                /*
                 * Check to see if the requested protocol is among the supported
                 * protocols, i.e., may be enabled
                 */
                for (int i=0; supportedProtocols != null &&
                        i < supportedProtocols.length; i++) {
                    if (supportedProtocols[i].equals(protocol)) {
                        if (vec == null) {
                            vec = new Vector<>();
                        }
                        vec.addElement(protocol);
                        break;
                    }
                }
            }
            if (vec != null) {
                enabledProtocols = new String[vec.size()];
                vec.copyInto(enabledProtocols);
======= fetch "protected void setEnabledProtocols(SSLServerSocket socket," 9f657ac^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

        return enabledProtocols;
======= fetch "private void initServerSocket(ServerSocket ssocket) {" 9f657ac^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

        if (enabledCiphers != null) {
            socket.setEnabledCipherSuites(enabledCiphers);
        }
        String[] requestedProtocols = endpoint.getSslEnabledProtocolsArray();
        setEnabledProtocols(socket, getEnabledProtocols(socket,
                                                         requestedProtocols));
      <p>The comma separated list of encryption ciphers that this socket is
      allowed to use. By default, the default ciphers for the JVM will be used.
      Note that this usually means that the weak export grade ciphers will be
      included in the list of available ciphers. The ciphers are specified using
      the JSSE cipher naming convention. The special value of <code>ALL</code>
      will enable all supported ciphers. This will include many that are not
      secure. <code>ALL</code> is intended for testing purposes only.</p>
      connections. If specified, only the protocols listed will be supported. If
      not specified, the JVM default is used. The permitted values may be
      obtained from the JVM documentation for the allowed values for

======= fetch "public void addServletMapping(String urlPattern, String servletName) {" 334c466^:"java/org/apache/catalina/deploy/WebXml.java"

        servletMappings.put(urlPattern, servletName);
======= fetch "public void testLifecycleMethodsWebFragmentsWithConflicts() {" 334c466^:"test/org/apache/catalina/deploy/TestWebXml.java"

    @Test(expected=IllegalArgumentException.class)
    public void testBug54387a() {
        // Multiple servlets may not be mapped to the same url-pattern
        WebXml webxml = new WebXml();
        webxml.addServletMapping("/foo", "a");
        webxml.addServletMapping("/foo", "b");
    }
    @Test(expected=IllegalArgumentException.class)
    public void testBug54387b() {
        // Multiple servlets may not be mapped to the same url-pattern
        WebXml webxml = new WebXml();
        WebXml f1 = new WebXml();
        WebXml f2 = new WebXml();
        HashSet<WebXml> fragments = new HashSet<>();
        fragments.add(f1);
        fragments.add(f2);
        f1.addServletMapping("/foo", "a");
        f2.addServletMapping("/foo", "b");
        webxml.merge(fragments);
    }
    @Test
    public void testBug54387c() {
        // Multiple servlets may not be mapped to the same url-pattern but main
        // web.xml takes priority
        WebXml webxml = new WebXml();
        WebXml f1 = new WebXml();
        WebXml f2 = new WebXml();
        HashSet<WebXml> fragments = new HashSet<>();
        fragments.add(f1);
        fragments.add(f2);
        f1.addServletMapping("/foo", "a");
        f2.addServletMapping("/foo", "b");
        webxml.addServletMapping("/foo", "main");
        webxml.merge(fragments);
    }

======= fetch "public void addServletContainerInitializer(" 71d075e^:"java/org/apache/catalina/Context.java"

======= fetch "public void addServletContainerInitializer(" 71d075e^:"java/org/apache/catalina/Context.java"

    /**
     * Add a post construct method definition for the given class, if there is
     * an existing definition for the specified class - IllegalArgumentException
     * will be thrown.
     *
     * @param clazz Fully qualified class name
     * @param method
     *            Post construct method name
     * @throws IllegalArgumentException
     *             if the fully qualified class name or method name are
     *             <code>NULL</code>; if there is already post construct method
     *             definition for the given class
     */
    public void addPostConstructMethod(String clazz, String method);
    /**
     * Add a pre destroy method definition for the given class, if there is an
     * existing definition for the specified class - IllegalArgumentException
     * will be thrown.
     *
     * @param clazz Fully qualified class name
     * @param method
     *            Post construct method name
     * @throws IllegalArgumentException
     *             if the fully qualified class name or method name are
     *             <code>NULL</code>; if there is already pre destroy method
     *             definition for the given class
     */
    public void addPreDestroyMethod(String clazz, String method);
    /**
     * Removes the post construct method definition for the given class, if it
     * exists; otherwise, no action is taken.
     *
     * @param clazz
     *            Fully qualified class name
     */
    public void removePostConstructMethod(String clazz);
    /**
     * Removes the pre destroy method definition for the given class, if it
     * exists; otherwise, no action is taken.
     *
     * @param clazz
     *            Fully qualified class name
     */
    public void removePreDestroyMethod(String clazz);
    /**
     * Returns the method name that is specified as post construct method for
     * the given class, if it exists; otherwise <code>NULL</code> will be
     * returned.
     *
     * @param clazz
     *            Fully qualified class name
     *
     * @return the method name that is specified as post construct method for
     *         the given class, if it exists; otherwise <code>NULL</code> will
     *         be returned.
     */
    public String findPostConstructMethod(String clazz);
    /**
     * Returns the method name that is specified as pre destroy method for the
     * given class, if it exists; otherwise <code>NULL</code> will be returned.
     *
     * @param clazz
     *            Fully qualified class name
     *
     * @return the method name that is specified as pre destroy method for the
     *         given class, if it exists; otherwise <code>NULL</code> will be
     *         returned.
     */
    public String findPreDestroyMethod(String clazz);
    /**
     * Returns a map with keys - fully qualified class names of the classes that
     * have post construct methods and the values are the corresponding method
     * names. If there are no such classes an empty map will be returned.
     *
     * @return a map with keys - fully qualified class names of the classes that
     *         have post construct methods and the values are the corresponding
     *         method names.
     */
    public Map<String, String> findPostConstructMethods();
    /**
     * Returns a map with keys - fully qualified class names of the classes that
     * have pre destroy methods and the values are the corresponding method
     * names. If there are no such classes an empty map will be returned.
     *
     * @return a map with keys - fully qualified class names of the classes that
     *         have pre destroy methods and the values are the corresponding
     *         method names.
     */
    public Map<String, String> findPreDestroyMethods();
    private final Map<String, String> postConstructMethods;
    private final Map<String, String> preDestroyMethods;
======= fetch "public DefaultInstanceManager(Context context, Map<String, Map<String, String>>" 71d075e^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

        this.postConstructMethods = catalinaContext.findPostConstructMethods();
        this.preDestroyMethods = catalinaContext.findPreDestroyMethods();
======= fetch "protected void populateAnnotationsCache(Class<?> clazz," 71d075e^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                String postConstructFromXml = postConstructMethods.get(clazz.getName());
======= fetch "protected void populateAnnotationsCache(Class<?> clazz," 71d075e^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                String preDestroyFromXml = preDestroyMethods.get(clazz.getName());
======= fetch "protected void populateAnnotationsCache(Class<?> clazz," 71d075e^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                    if (method.isAnnotationPresent(PostConstruct.class)) {
                        if ((postConstruct != null) ||
                                (method.getParameterTypes().length != 0) ||
                                (Modifier.isStatic(method.getModifiers())) ||
                                (method.getExceptionTypes().length > 0) ||
                                (!method.getReturnType().getName().equals("void"))) {
                            throw new IllegalArgumentException(
                                    "Invalid PostConstruct annotation");
                        }
                        postConstruct = method;
                    }
======= fetch "protected void populateAnnotationsCache(Class<?> clazz," 71d075e^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                    if (method.isAnnotationPresent(PreDestroy.class)) {
                        if ((preDestroy != null ||
                                method.getParameterTypes().length != 0) ||
                                (Modifier.isStatic(method.getModifiers())) ||
                                (method.getExceptionTypes().length > 0) ||
                                (!method.getReturnType().getName().equals("void"))) {
                            throw new IllegalArgumentException(
                                    "Invalid PreDestroy annotation");
                        }
                        preDestroy = method;
                    }
======= fetch "protected void populateAnnotationsCache(Class<?> clazz," 71d075e^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

======= fetch "protected void populateAnnotationsCache(Class<?> clazz," 71d075e^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                } else if (postConstructFromXml != null) {
                    throw new IllegalArgumentException("Post construct method "
                        + postConstructFromXml + " for class " + clazz.getName()
                        + " is declared in deployment descriptor but cannot be found.");
======= fetch "protected void populateAnnotationsCache(Class<?> clazz," 71d075e^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                } else if (preDestroyFromXml != null) {
                    throw new IllegalArgumentException("Pre destroy method "
                        + preDestroyFromXml + " for class " + clazz.getName()
                        + " is declared in deployment descriptor but cannot be found.");
======= fetch "public Field run() {" 71d075e^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

    private static Method findPostConstruct(Method currentPostConstruct,
            String postConstructFromXml, Method method) {
        return findLifecycleCallback(currentPostConstruct,
            postConstructFromXml, method, PostConstruct.class);
    }
    private static Method findPreDestroy(Method currentPreDestroy,
        String preDestroyFromXml, Method method) {
        return findLifecycleCallback(currentPreDestroy,
            preDestroyFromXml, method, PreDestroy.class);
    }
    private static Method findLifecycleCallback(Method currentMethod,
            String methodNameFromXml, Method method,
            Class<? extends Annotation> annotation) {
        Method result = currentMethod;
        if (methodNameFromXml != null) {
            if (method.getName().equals(methodNameFromXml)) {
                if (!Introspection.isValidLifecycleCallback(method)) {
                    throw new IllegalArgumentException(
                        "Invalid " + annotation.getName() + " annotation");
                }
                result = method;
            }
        } else {
            if (method.isAnnotationPresent(annotation)) {
                if (currentMethod != null ||
                    !Introspection.isValidLifecycleCallback(method)) {
                    throw new IllegalArgumentException(
                        "Invalid " + annotation.getName() + " annotation");
                }
                result = method;
            }
        }
        return result;
    }
======= fetch "public StandardContext() {" 71d075e^:"java/org/apache/catalina/core/StandardContext.java"

    private Map<String, String> postConstructMethods = new HashMap<>();
    private Map<String, String> preDestroyMethods = new HashMap<>();
======= fetch "public boolean fireRequestDestroyEvent(ServletRequest request) {" 71d075e^:"java/org/apache/catalina/core/StandardContext.java"

    @Override
    public void addPostConstructMethod(String clazz, String method) {
        if (clazz == null || method == null)
            throw new IllegalArgumentException(
                    sm.getString("standardContext.postconstruct.required"));
        if (postConstructMethods.get(clazz) != null)
            throw new IllegalArgumentException(sm.getString(
                    "standardContext.postconstruct.duplicate", clazz));
        postConstructMethods.put(clazz, method);
        fireContainerEvent("addPostConstructMethod", clazz);
    }
    @Override
    public void removePostConstructMethod(String clazz) {
        postConstructMethods.remove(clazz);
        fireContainerEvent("removePostConstructMethod", clazz);
    }
    @Override
    public void addPreDestroyMethod(String clazz, String method) {
        if (clazz == null || method == null)
            throw new IllegalArgumentException(
                    sm.getString("standardContext.predestroy.required"));
        if (preDestroyMethods.get(clazz) != null)
            throw new IllegalArgumentException(sm.getString(
                    "standardContext.predestroy.duplicate", clazz));
        preDestroyMethods.put(clazz, method);
        fireContainerEvent("addPreDestroyMethod", clazz);
    }
    @Override
    public void removePreDestroyMethod(String clazz) {
        preDestroyMethods.remove(clazz);
        fireContainerEvent("removePreDestroyMethod", clazz);
    }
    @Override
    public String findPostConstructMethod(String clazz) {
        return postConstructMethods.get(clazz);
    }
    @Override
    public String findPreDestroyMethod(String clazz) {
        return preDestroyMethods.get(clazz);
    }
    @Override
    public Map<String, String> findPostConstructMethods() {
        return postConstructMethods;
    }
    @Override
    public Map<String, String> findPreDestroyMethods() {
        return preDestroyMethods;
    }
======= fetch "public void addLocaleEncodingMapping(String locale, String encoding) {" 71d075e^:"java/org/apache/catalina/deploy/WebXml.java"

    // post-construct elements
    private Map<String, String> postConstructMethods = new HashMap<>();
    public void addPostConstructMethods(String clazz, String method) {
        if (!postConstructMethods.containsKey(clazz)) {
            postConstructMethods.put(clazz, method);
        }
    }
    public Map<String, String> getPostConstructMethods() {
        return postConstructMethods;
    }
    // pre-destroy elements
    private Map<String, String> preDestroyMethods = new HashMap<>();
    public void addPreDestroyMethods(String clazz, String method) {
        if (!preDestroyMethods.containsKey(clazz)) {
            preDestroyMethods.put(clazz, method);
        }
    }
    public Map<String, String> getPreDestroyMethods() {
        return preDestroyMethods;
    }
======= fetch "public String toXml() {" 71d075e^:"java/org/apache/catalina/deploy/WebXml.java"

        if (!postConstructMethods.isEmpty()) {
            for (Entry<String, String> entry : postConstructMethods
                    .entrySet()) {
                sb.append("  <post-construct>\n");
                appendElement(sb, INDENT4, "lifecycle-callback-class",
                        entry.getKey());
                appendElement(sb, INDENT4, "lifecycle-callback-method",
                        entry.getValue());
                sb.append("  </post-construct>\n");
            }
            sb.append('\n');
        }
        if (!preDestroyMethods.isEmpty()) {
            for (Entry<String, String> entry : preDestroyMethods
                    .entrySet()) {
                sb.append("  <pre-destroy>\n");
                appendElement(sb, INDENT4, "lifecycle-callback-class",
                        entry.getKey());
                appendElement(sb, INDENT4, "lifecycle-callback-method",
                        entry.getValue());
                sb.append("  </pre-destroy>\n");
            }
            sb.append('\n');
        }
======= fetch "public void configureContext(Context context) {" 71d075e^:"java/org/apache/catalina/deploy/WebXml.java"

        for (Entry<String, String> entry : postConstructMethods.entrySet()) {
            context.addPostConstructMethod(entry.getKey(), entry.getValue());
        }
        for (Entry<String, String> entry : preDestroyMethods.entrySet()) {
            context.addPreDestroyMethod(entry.getKey(), entry.getValue());
        }
======= fetch "public boolean merge(Set<WebXml> fragments) {" 71d075e^:"java/org/apache/catalina/deploy/WebXml.java"

        if (postConstructMethods.isEmpty()) {
            for (WebXml fragment : fragments) {
                if (!mergeLifecycleCallback(fragment.getPostConstructMethods(),
                        temp.getPostConstructMethods(), fragment,
                        "Post Construct Methods")) {
                    return false;
                }
            }
            postConstructMethods.putAll(temp.getPostConstructMethods());
        }
        if (preDestroyMethods.isEmpty()) {
            for (WebXml fragment : fragments) {
                if (!mergeLifecycleCallback(fragment.getPreDestroyMethods(),
                        temp.getPreDestroyMethods(), fragment,
                        "Pre Destroy Methods")) {
                    return false;
                }
            }
            preDestroyMethods.putAll(temp.getPreDestroyMethods());
        }
======= fetch "private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest," 71d075e^:"java/org/apache/catalina/deploy/WebXml.java"

    private static <T> boolean mergeLifecycleCallback(
            Map<String, String> fragmentMap, Map<String, String> tempMap,
            WebXml fragment, String mapName) {
        for (Entry<String, String> entry : fragmentMap.entrySet()) {
            final String key = entry.getKey();
            final String value = entry.getValue();
            if (tempMap.containsKey(key)) {
                if (value != null && !value.equals(tempMap.get(key))) {
                    log.error(sm.getString("webXml.mergeConflictString",
                            mapName, key, fragment.getName(), fragment.getURL()));
                    return false;
                }
            } else {
                tempMap.put(key, value);
            }
        }
        return true;
    }
======= fetch "public void setAddWebinfClassesResources(boolean addWebinfClassesResources) {" 71d075e^:"java/org/apache/catalina/startup/FailedContext.java"

    @Override
    public void addPostConstructMethod(String clazz, String method) { /* NO-OP */ }
    @Override
    public void addPreDestroyMethod(String clazz, String method) { /* NO-OP */ }
    @Override
    public void removePostConstructMethod(String clazz) { /* NO-OP */ }
    @Override
    public void removePreDestroyMethod(String clazz) { /* NO-OP */ }
    @Override
    public String findPostConstructMethod(String clazz) { return null; }
    @Override
    public String findPreDestroyMethod(String clazz) { return null; }
    @Override
    public Map<String, String> findPostConstructMethods() { return null; }
    @Override
    public Map<String, String> findPreDestroyMethods() { return null; }
======= fetch "public void addRuleInstances(Digester digester) {" 71d075e^:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/post-construct",
                new LifecycleCallbackRule("addPostConstructMethods", 2, true));
        digester.addCallParam(fullPrefix + "/post-construct/lifecycle-callback-class", 0);
        digester.addCallParam(fullPrefix + "/post-construct/lifecycle-callback-method", 1);
        digester.addRule(fullPrefix + "/pre-destroy",
                new LifecycleCallbackRule("addPreDestroyMethods", 2, false));
        digester.addCallParam(fullPrefix + "/pre-destroy/lifecycle-callback-class", 0);
        digester.addCallParam(fullPrefix + "/pre-destroy/lifecycle-callback-method", 1);
======= fetch "public void body(String namespace, String name, String text)" 71d075e^:"java/org/apache/catalina/startup/WebRuleSet.java"

 * A rule that fails if more than one post construct or pre destroy methods
 * are configured per class.
 */
    private final boolean postConstruct;
    public LifecycleCallbackRule(String methodName, int paramCount,
            boolean postConstruct) {
        super(methodName, paramCount);
        this.postConstruct = postConstruct;
    }
    @Override
    public void end(String namespace, String name) throws Exception {
        Object[] params = (Object[]) digester.peekParams();
        if (params != null && params.length == 2) {
            WebXml webXml = (WebXml) digester.peek();
            if (postConstruct) {
                if (webXml.getPostConstructMethods().containsKey(params[0])) {
                    throw new IllegalArgumentException(WebRuleSet.sm.getString(
                            "webRuleSet.postconstruct.duplicate", params[0]));
                }
            } else {
                if (webXml.getPreDestroyMethods().containsKey(params[0])) {
                    throw new IllegalArgumentException(WebRuleSet.sm.getString(
                            "webRuleSet.predestroy.duplicate", params[0]));
                }
            }
        }
        super.end(namespace, name);
    }
======= fetch "public static boolean isValidSetter(Method method) {" 71d075e^:"java/org/apache/catalina/util/Introspection.java"

    /**
     * Determines if a method is a valid lifecycle callback method.
     *
     * @param method
     *            The method to test
     *
     * @return <code>true</code> if the method is a valid lifecycle callback
     *         method, else <code>false</code>
     */
    public static boolean isValidLifecycleCallback(Method method) {
        if (method.getParameterTypes().length != 0
                || Modifier.isStatic(method.getModifiers())
                || method.getExceptionTypes().length > 0
                || !method.getReturnType().getName().equals("void")) {
            return false;
        }
        return true;
    }
======= fetch "public boolean isResponseBodyOK() {" 71d075e^:"test/org/apache/catalina/core/TestStandardContext.java"

    @Test(expected = IllegalArgumentException.class)
    public void testAddPostConstructMethodNullClassName() {
        new StandardContext().addPostConstructMethod(null, "");
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddPostConstructMethodNullMethodName() {
        new StandardContext().addPostConstructMethod("", null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddPostConstructMethodConflicts() {
        StandardContext standardContext = new StandardContext();
        standardContext.addPostConstructMethod("a", "a");
        standardContext.addPostConstructMethod("a", "b");
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddPreDestroyMethodNullClassName() {
        new StandardContext().addPreDestroyMethod(null, "");
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddPreDestroyMethodNullMethodName() {
        new StandardContext().addPreDestroyMethod("", null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddPreDestroyMethodConflicts() {
        StandardContext standardContext = new StandardContext();
        standardContext.addPreDestroyMethod("a", "a");
        standardContext.addPreDestroyMethod("a", "b");
    }
======= fetch "public boolean getAddWebinfClassesResources() {" 71d075e^:"test/org/apache/catalina/core/TesterContext.java"

    @Override
    public void addPostConstructMethod(String clazz, String method) {
        // NO-OP
    }
    @Override
    public void addPreDestroyMethod(String clazz, String method) {
        // NO-OP
    }
    @Override
    public void removePostConstructMethod(String clazz) {
        // NO-OP
    }
    @Override
    public void removePreDestroyMethod(String clazz) {
        // NO-OP
    }
    @Override
    public String findPostConstructMethod(String clazz) {
        return null;
    }
    @Override
    public String findPreDestroyMethod(String clazz) {
        return null;
    }
    @Override
    public Map<String,String> findPostConstructMethods() {
        return null;
    }
    @Override
    public Map<String,String> findPreDestroyMethods() {
        return null;
    }
======= fetch "public void testParseVersion() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(3, webxml.getMajorVersion());
        assertEquals(0, webxml.getMinorVersion());
======= fetch "public void testParseVersion() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(2, webxml.getMajorVersion());
        assertEquals(5, webxml.getMinorVersion());
======= fetch "public void testParseVersion() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(0, webxml.getMajorVersion());
        assertEquals(0, webxml.getMinorVersion());
======= fetch "public void testParseVersion() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(0, webxml.getMajorVersion());
        assertEquals(0, webxml.getMinorVersion());
======= fetch "public void testParseVersion() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(3, webxml.getMajorVersion());
        assertEquals(0, webxml.getMinorVersion());
======= fetch "public void testParseVersion() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(3, webxml.getMajorVersion());
        assertEquals(0, webxml.getMinorVersion());
======= fetch "public void testParseVersion() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(0, webxml.getMajorVersion());
        assertEquals(5, webxml.getMinorVersion());
======= fetch "public void testParseVersion() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(2, webxml.getMajorVersion());
        assertEquals(500, webxml.getMinorVersion());
======= fetch "public void testParsePublicIdVersion22() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(2, webxml.getMajorVersion());
        assertEquals(2, webxml.getMinorVersion());
        assertEquals("2.2", webxml.getVersion());
======= fetch "public void testParsePublicIdVersion23() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(2, webxml.getMajorVersion());
        assertEquals(3, webxml.getMinorVersion());
        assertEquals("2.3", webxml.getVersion());
======= fetch "public void testParsePublicIdVersion24() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(2, webxml.getMajorVersion());
        assertEquals(4, webxml.getMinorVersion());
        assertEquals("2.4", webxml.getVersion());
======= fetch "public void testParsePublicIdVersion25() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(2, webxml.getMajorVersion());
        assertEquals(5, webxml.getMinorVersion());
        assertEquals("2.5", webxml.getVersion());
======= fetch "public void testParsePublicIdVersion30() {" 71d075e^:"test/org/apache/catalina/deploy/TestWebXml.java"

        assertEquals(3, webxml.getMajorVersion());
        assertEquals(0, webxml.getMinorVersion());
        assertEquals("3.0", webxml.getVersion());
======= fetch "public void testBug54262() throws Exception {" 71d075e^:"test/org/apache/catalina/startup/TestContextConfig.java"

    @Test
    public void testBug54379() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0-fragments");
        Context context =
                tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        Tomcat.addServlet(context, "TestServlet",
                "org.apache.catalina.startup.TesterServletWithLifeCycleMethods");
        context.addServletMapping("/testServlet", "TestServlet");
        tomcat.enableNaming();
        tomcat.start();
        assertPageContains("/test/testServlet", "postConstruct1()");
    }
======= fetch "public void testRecycle() throws Exception {" 71d075e^:"test/org/apache/catalina/startup/TestWebRuleSet.java"

    @Test
    public void testLifecycleMethodsDefinitions() throws Exception {
        // post-construct and pre-destroy
        parse(new WebXml(), "web-1lifecyclecallback.xml", false, true);
        // conflicting post-construct definitions
        parse(new WebXml(), "web-2lifecyclecallback.xml", false, false);
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private static final long serialVersionUID = 1L;
    private String result;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        resp.setContentType("text/plain");
        resp.getWriter().print(result);
    }
    @PostConstruct
    protected void postConstruct() {
        result = "postConstruct()";
    }
    @PreDestroy
    protected void preDestroy() {
        result = "preDestroy()";
    }
    protected void postConstruct1() {
        result = "postConstruct1()";
    }
    protected void preDestroy1() {
        result = "preDestroy1()";
    }
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
  version="3.0"
  metadata-complete="true">
  <post-construct>
    <lifecycle-callback-class>test.TestServlet</lifecycle-callback-class>
    <lifecycle-callback-method>postConstruct</lifecycle-callback-method>
  </post-construct>
  <pre-destroy>
    <lifecycle-callback-class>test.TestServlet</lifecycle-callback-class>
    <lifecycle-callback-method>preDestroy</lifecycle-callback-method>
  </pre-destroy>
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
  version="3.0"
  metadata-complete="true">
  <post-construct>
    <lifecycle-callback-class>test.TestServlet</lifecycle-callback-class>
    <lifecycle-callback-method>postConstruct1</lifecycle-callback-method>
  </post-construct>
  <post-construct>
    <lifecycle-callback-class>test.TestServlet</lifecycle-callback-class>
    <lifecycle-callback-method>postConstruct2</lifecycle-callback-method>
  </post-construct>
  <post-construct>
    <lifecycle-callback-class>org.apache.catalina.startup.TesterServletWithLifeCycleMethods</lifecycle-callback-class>
    <lifecycle-callback-method>postConstruct1</lifecycle-callback-method>
  </post-construct>
  <pre-destroy>
    <lifecycle-callback-class>org.apache.catalina.startup.TesterServletWithLifeCycleMethods</lifecycle-callback-class>
    <lifecycle-callback-method>preDestroy1</lifecycle-callback-method>
  </pre-destroy>

======= fetch "private String parseCmd(StringBuilder cmd) {" d83a5e5^:"java/org/apache/catalina/ssi/SSIProcessor.java"

        String command = null;
        if (firstLetter != -1) {
            command = cmd.substring(firstLetter, lastLetter + 1);
======= fetch "private String parseCmd(StringBuilder cmd) {" d83a5e5^:"java/org/apache/catalina/ssi/SSIProcessor.java"

        return command;

======= fetch "public final SocketState onData() {" 5f7af1b^:"java/org/apache/catalina/websocket/StreamHandler.java"

                    // NO-OP
======= fetch "private void doOnClose(int status) {" 5f7af1b^:"java/org/apache/catalina/websocket/StreamHandler.java"

    private void doOnPong(ByteBuffer payload) {
        // Need to call onPong using the web application's class loader
        Thread t = Thread.currentThread();
        ClassLoader cl = t.getContextClassLoader();
        t.setContextClassLoader(applicationClassLoader);
        try {
            onPong(payload);
        } finally {
            t.setContextClassLoader(cl);
        }
    }
======= fetch "protected void onClose(int status) {" 5f7af1b^:"java/org/apache/catalina/websocket/StreamHandler.java"

    /**
     * Intended to be overridden by sub-classes that wish to be notified
     * when a pong is received. The default implementation is a NO-OP.
     *
     * @param payload   The payload included in the pong.
     */
    protected void onPong(ByteBuffer payload) {
        // NO-OP
    }

======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 95e6056^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                        request.getRemoteAddr());
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 95e6056^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                        request.getRemoteHost());
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 95e6056^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                        request.getProtocol());
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 95e6056^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                        Integer.valueOf(request.getServerPort()));
======= fetch "public void setAttribute(String name, Object value) {" 95e6056^:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

            // NOOP. Prevents NPE during testing.
======= fetch "private HttpServletRequest testRemoteIpFilter(FilterDef filterDef, Request reque" 95e6056^:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

    @Test
    public void testRequestAttributesForAccessLog() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("protocolHeader", "x-forwarded-proto");
        filterDef.addInitParameter("remoteIpHeader", "x-my-forwarded-for");
        filterDef.addInitParameter("httpServerPort", "8080");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setHeader("x-my-forwarded-for", "140.211.11.130");
        request.setHeader("x-forwarded-proto", "http");
        // TEST
        HttpServletRequest actualRequest =
                testRemoteIpFilter(filterDef, request);
        // VERIFY
        Assert.assertEquals("org.apache.catalina.AccessLog.ServerPort",
                Integer.valueOf(8080),
                actualRequest.getAttribute(AccessLog.SERVER_PORT_ATTRIBUTE));
        Assert.assertEquals("org.apache.catalina.AccessLog.RemoteAddr",
                "140.211.11.130",
                actualRequest.getAttribute(AccessLog.REMOTE_ADDR_ATTRIBUTE));
        Assert.assertEquals("org.apache.catalina.AccessLog.RemoteHost",
                "140.211.11.130",
                actualRequest.getAttribute(AccessLog.REMOTE_HOST_ATTRIBUTE));
    }
======= fetch "public void setAttribute(String name, Object value) {" 95e6056^:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

            // NOOP. Prevents NPE during testing.
======= fetch "public void testCommaDelimitedListToStringArrayMixedSpaceChars() {" 95e6056^:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

    @Test
    public void testRequestAttributesForAccessLog() throws Exception {
        // PREPARE
        RemoteIpValve remoteIpValve = new RemoteIpValve();
        remoteIpValve.setRemoteIpHeader("x-forwarded-for");
        remoteIpValve.setProtocolHeader("x-forwarded-proto");
        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();
        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);
        Request request = new MockRequest();
        request.setCoyoteRequest(new org.apache.coyote.Request());
        // client ip
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("192.168.0.10");
        request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-for").setString("140.211.11.130");
        // protocol
        request.setServerPort(8080);
        request.getCoyoteRequest().scheme().setString("http");
        // TEST
        remoteIpValve.invoke(request, null);
        // VERIFY
        Assert.assertEquals("org.apache.catalina.AccessLog.ServerPort",
                Integer.valueOf(8080),
                request.getAttribute(AccessLog.SERVER_PORT_ATTRIBUTE));
        Assert.assertEquals("org.apache.catalina.AccessLog.RemoteAddr",
                "140.211.11.130",
                request.getAttribute(AccessLog.REMOTE_ADDR_ATTRIBUTE));
        Assert.assertEquals("org.apache.catalina.AccessLog.RemoteHost",
                "140.211.11.130",
                request.getAttribute(AccessLog.REMOTE_HOST_ATTRIBUTE));
    }

======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 3a9990b^:"java/org/apache/catalina/mapper/MapperListener.java"

                registerWrapper((Wrapper) obj);
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 3a9990b^:"java/org/apache/catalina/mapper/MapperListener.java"

                registerContext((Context) obj);

======= fetch "public static Charset getCharsetLower(String lowerCaseEnc)" f7fc27a^:"java/org/apache/tomcat/util/buf/B2CConverter.java"

    private CharsetDecoder decoder;
======= fetch "public  void recycle() {" f7fc27a^:"java/org/apache/tomcat/util/buf/B2CConverter.java"

        decoder.reset();
======= fetch "public void convert( ByteChunk bb, CharChunk cb, int limit)" f7fc27a^:"java/org/apache/tomcat/util/buf/B2CConverter.java"

    public void reset()
        throws IOException
    {
        // destroy the reader/iis
        iis=new IntermediateInputStream();
        conv = new ReadConvertor(iis, getCharset(encoding));
======= fetch "public void reset()" f7fc27a^:"java/org/apache/tomcat/util/buf/B2CConverter.java"

======= fetch "public void reset()" f7fc27a^:"java/org/apache/tomcat/util/buf/B2CConverter.java"

    public ReadConvertor(IntermediateInputStream in, Charset charset) {
        super(in, charset);

======= fetch "public void setAttribute(String name, Object value) {" 113c0bd^:"java/org/apache/catalina/core/ApplicationContext.java"

        if (filterName == null || filterName.equals("")) {
            throw new IllegalArgumentException(sm.getString(
                    "applicationContext.invalidFilterName", filterName));
        }
======= fetch "public FilterRegistration getFilterRegistration(String filterName) {" 113c0bd^:"java/org/apache/catalina/core/ApplicationContext.java"

        if (servletName == null || servletName.equals("")) {
            throw new IllegalArgumentException(sm.getString(
                    "applicationContext.invalidServletName", servletName));
        }
    private static final StringManager sm =
        StringManager.getManager(Constants.Package);
======= fetch "public void setFilterName(String filterName) {" 113c0bd^:"java/org/apache/catalina/deploy/FilterDef.java"

        if (filterName == null || filterName.equals("")) {
            throw new IllegalArgumentException(
                    sm.getString("filterDef.invalidFilterName", filterName));
        }
    private static final StringManager sm =
        StringManager.getManager(Constants.Package);
======= fetch "public void setServletName(String servletName) {" 113c0bd^:"java/org/apache/catalina/deploy/ServletDef.java"

        if (servletName == null || servletName.equals("")) {
            throw new IllegalArgumentException(
                    sm.getString("servletDef.invalidServletName", servletName));
        }
======= fetch "public void testBug53467() throws Exception {" 113c0bd^:"test/org/apache/catalina/core/TestApplicationContext.java"

    @Test(expected = IllegalArgumentException.class)
    public void testAddFilterWithFilterNameNull() {
        getServletContext().addFilter(null, (Filter) null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddFilterWithFilterNameEmptyString() {
        getServletContext().addFilter("", (Filter) null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddServletWithServletNameNull() {
        getServletContext().addServlet(null, (Servlet) null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddServletWithServletNameEmptyString() {
        getServletContext().addServlet("", (Servlet) null);
    }
    private ServletContext getServletContext() {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        // app dir is relative to server home
        StandardContext standardContext = (StandardContext) tomcat.addWebapp(
                null, "/test", appDir.getAbsolutePath());
        return standardContext.getServletContext();
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Test case for {@link FilterDef}.
 */
    @Test(expected = IllegalArgumentException.class)
    public void testSetFilterNameNull() {
        new FilterDef().setFilterName(null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testSetFilterNameEmptyString() {
        new FilterDef().setFilterName("");
    }
    @Test
    public void testSetFilterName() {
        FilterDef filterDef = new FilterDef();
        filterDef.setFilterName("test");
        Assert.assertEquals("'test' is expected as filter name",
            "test", filterDef.getFilterName());
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Test case for {@link ServletDef}
 */
    @Test(expected = IllegalArgumentException.class)
    public void testSetServletNameNull() {
        new ServletDef().setServletName(null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testSetServletNameEmptyString() {
        new ServletDef().setServletName("");
    }
    @Test
    public void testSetServletName() {
        ServletDef servletDef = new ServletDef();
        servletDef.setServletName("test");
        Assert.assertEquals("'test' is expected as servlet name",
            "test", servletDef.getServletName());
    }

======= fetch "public void setOverridable(boolean overridable) {" 5418e2b^:"java/org/apache/catalina/deploy/WebXml.java"

    public void addAbsoluteOrdering(String fragmentName) {
======= fetch "public void addAbsoluteOrdering(String fragmentName) {" 5418e2b^:"java/org/apache/catalina/deploy/WebXml.java"

    }
    public void addAbsoluteOrdering(String fragmentName) {
        createAbsoluteOrdering();
======= fetch "public void addAbsoluteOrderingOthers() {" 5418e2b^:"java/org/apache/catalina/deploy/WebXml.java"

        if (absoluteOrdering == null) {
            absoluteOrdering = new LinkedHashSet<>();
        }
======= fetch "public void begin(String namespace, String name, Attributes attributes)" 5418e2b^:"java/org/apache/catalina/startup/WebRuleSet.java"

            WebXml webXml = (WebXml) digester.peek();
            webXml.createAbsoluteOrdering();
            if (digester.getLogger().isDebugEnabled()) {
                digester.getLogger().debug(
                        webXml.getClass().getName() + ".setAbsoluteOrdering()");
            }
======= fetch "private void doTestOverrideDefaultServletWithSCI(String servletName)" 5418e2b^:"test/org/apache/catalina/startup/TestContextConfig.java"

        ByteChunk res = new ByteChunk();
        int rc =getUrl("http://localhost:" + getPort() + "/test", res, null);
        // Check return code
        assertEquals(HttpServletResponse.SC_OK, rc);
        // Check context
        assertEquals("OK - Custom default Servlet", res.toString());
======= fetch "public void testBug51396() throws Exception {" 5418e2b^:"test/org/apache/catalina/startup/TestContextConfig.java"

        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug51396.jsp", bc, null);
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertTrue(bc.toString().contains("<p>OK</p>"));
======= fetch "public void testBug53574() throws Exception {" 5418e2b^:"test/org/apache/catalina/startup/TestContextConfig.java"

        ByteChunk res = new ByteChunk();
======= fetch "public void testBug53574() throws Exception {" 5418e2b^:"test/org/apache/catalina/startup/TestContextConfig.java"

        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug53574", res, null);
======= fetch "public void testBug53574() throws Exception {" 5418e2b^:"test/org/apache/catalina/startup/TestContextConfig.java"

        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
======= fetch "public void testBug53574() throws Exception {" 5418e2b^:"test/org/apache/catalina/startup/TestContextConfig.java"

        String body = res.toString();
        Assert.assertTrue(body.contains("OK"));
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 5418e2b^:"test/org/apache/catalina/startup/TestContextConfig.java"

    private void assertPageContains(String pageUrl, String expectedBody)
            throws IOException {
        assertPageContains(pageUrl, expectedBody, HttpServletResponse.SC_OK);
    }
    private void assertPageContains(String pageUrl, String expectedBody,
            int expectedStatus) throws IOException {
        ByteChunk res = new ByteChunk();
        int sc = getUrl("http://localhost:" + getPort() + pageUrl, res, null);
        Assert.assertEquals(expectedStatus, sc);
        if (expectedStatus == HttpServletResponse.SC_OK) {
            String result = res.toString();
            Assert.assertTrue(result, result.indexOf(expectedBody) > -1);
        }
    }
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
  version="3.0"
  metadata-complete="false">
  <display-name>Tomcat Test Application</display-name>
  <description>
     Used as part of the Tomcat unit tests when a full web application is
     required.
  </description>
  <absolute-ordering/>

======= fetch "public static Method getMethod(Object base, Object property," 5361e86^:"java/org/apache/el/util/ReflectionUtil.java"

    @SuppressWarnings("null")
======= fetch "private static Method resolveAmbiguousMethod(Set<Method> candidates," 5361e86^:"java/org/apache/el/util/ReflectionUtil.java"

        if (nonMatchClass == null) {
            // Null will always be ambiguous
            return null;
        }
======= fetch "private static boolean isAssignableFrom(Class<?> src, Class<?> target) {" 5361e86^:"java/org/apache/el/util/ReflectionUtil.java"

        // Short-cut. null is always assignable to an object and in EL null
        // can always be coerced to a valid value for a primitive
        if (src == null) {
            return true;
        }
======= fetch "protected static final String paramString(Class<?>[] types) {" 5361e86^:"java/org/apache/el/util/ReflectionUtil.java"

                sb.append(types[i].getName()).append(", ");

======= fetch "public synchronized void remove(final Entry element) {" 94da507^:"java/org/apache/jasper/util/FastRemovalDequeue.java"

        if (!element.getValid()) {

======= fetch "public static synchronized boolean validateApplication(" 0ae2f34^:"java/org/apache/catalina/util/ExtensionValidator.java"

        // Primarily used for error reporting
        String jarName = null;
======= fetch "public static synchronized boolean validateApplication(" 0ae2f34^:"java/org/apache/catalina/util/ExtensionValidator.java"

                if (jar.getName().toLowerCase(Locale.ENGLISH).endsWith(".jar") &&
======= fetch "public static synchronized boolean validateApplication(" 0ae2f34^:"java/org/apache/catalina/util/ExtensionValidator.java"

                        ManifestResource mre = new ManifestResource(
                                                    jar.getName(),
                                                    jmanifest,
                                                    ManifestResource.APPLICATION);
======= fetch "public static synchronized boolean validateApplication(" 0ae2f34^:"java/org/apache/catalina/util/ExtensionValidator.java"

        } catch (IOException ioe) {
            throw new IOException("Jar: " + jarName, ioe);

======= fetch "public static void main(String args[]) {" 29c4a0e^:"java/org/apache/catalina/startup/Bootstrap.java"

        } else {
            // When running as a service the call to stop will be on a new
            // thread so make sure the correct class loader is used to prevent
            // a range of class not found exceptions.
            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);

======= fetch "public void write(String s, int off, int len) throws IOException {" ffc4525^:"java/org/apache/jasper/runtime/JspWriterImpl.java"

    /**
     * Write a string.  This method cannot be inherited from the Writer class
     * because it must suppress I/O exceptions.
     */
    @Override
    public void write(String s) throws IOException {
        // Simple fix for Bugzilla 35410
        // Calling the other write function so as to init the buffer anyways
        if(s == null) {
            write(s, 0, 0);
        } else {
            write(s, 0, s.length());
        }
    }

======= fetch "public ObjectName preRegister(MBeanServer server, ObjectName name) throws Except" 1c61fb1^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java"

            this.oname = createObjectName(name);
            if (oname!=null) registerJmx();

======= fetch "protected void close(boolean force) {" b021a22^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                proxies[i].getInterceptorClass().newInstance().poolClosed(this);

======= fetch "protected void report(Request request, Response response," a2d1441^:"java/org/apache/catalina/valves/ErrorReportValve.java"

        if ((statusCode < 400) || (response.getContentWritten() > 0)) {
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" a2d1441^:"test/org/apache/catalina/valves/TestErrorReportValve.java"

    @Test
    public void testBug54220DoNotSetNotFound() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctx, "bug54220", new Bug54220Servlet(false));
        ctx.addServletMapping("/", "bug54220");
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort(), res, null);
        Assert.assertNull(res.toString());
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
    }
    @Test
    public void testBug54220SetNotFound() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctx, "bug54220", new Bug54220Servlet(true));
        ctx.addServletMapping("/", "bug54220");
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort(), res, null);
        Assert.assertNull(res.toString());
        Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);
    }
    private static final class Bug54220Servlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private boolean setNotFound;
        private Bug54220Servlet(boolean setNotFound) {
            this.setNotFound = setNotFound;
        }
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            if (setNotFound) {
                resp.setStatus(HttpServletResponse.SC_NOT_FOUND);
            }
        }
    }

======= fetch "public static Timer getPoolTimer() {" a81538d^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    protected class PoolCleaner extends TimerTask {
        protected ConnectionPool pool;
======= fetch "public static Timer getPoolTimer() {" a81538d^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        protected volatile boolean run = true;
======= fetch "public static Timer getPoolTimer() {" a81538d^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            this.pool = pool;
======= fetch "public void run() {" a81538d^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            if (pool.isClosed()) {
                if (pool.getSize() <= 0) {
                    run = false;
                }
            } else if ((System.currentTimeMillis() - lastRun) > sleepTime) {
======= fetch "public void run() {" a81538d^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                } // catch
            } // end if
        } // run

 * java.naming.factory.url.pkgs=org.apache.catalina.util.naming property

     * Sends an error response to the client using the specified status. The
     * server defaults to creating the response to look like an HTML-formatted
     * server error page containing the specified message, setting the content
     * type to "text/html", leaving cookies and other headers unmodified. If an
     * error-page declaration has been made for the web application
     * corresponding to the status code passed in, it will be served back in
     * preference to the suggested msg parameter.
     * clearing the buffer.
     * <p>
     * If the response has already been committed, this method throws an
     * IllegalStateException. After using this method, the response should be
     * considered to be committed and should not be written to.

======= fetch "public static String stripSession(String url) {" 7c4a841^:"java/org/apache/jasper/tagplugins/jstl/Util.java"

    @SuppressWarnings("null") // escapedBuffer cannot be null
======= fetch "public static String escapeXml(String buffer) {" 7c4a841^:"java/org/apache/jasper/tagplugins/jstl/Util.java"

        String result = escapeXml(buffer.toCharArray(), buffer.length());
        if (result == null) {
            return buffer;
        } else {
            return result;
        }
    }
    @SuppressWarnings("null") // escapedBuffer cannot be null
    public static String escapeXml(char[] arrayBuffer, int length) {
======= fetch "public static String escapeXml(String buffer) {" 7c4a841^:"java/org/apache/jasper/tagplugins/jstl/Util.java"

        int length = buffer.length();
        char[] arrayBuffer = buffer.toCharArray();
======= fetch "public static String escapeXml(String buffer) {" 7c4a841^:"java/org/apache/jasper/tagplugins/jstl/Util.java"

            return buffer;
======= fetch "public void doTag(TagPluginContext ctxt) {" 7c4a841^:"java/org/apache/jasper/tagplugins/jstl/core/Out.java"

        String strObjectName = ctxt.getTemporaryVariableName();
======= fetch "public void doTag(TagPluginContext ctxt) {" 7c4a841^:"java/org/apache/jasper/tagplugins/jstl/core/Out.java"

        ctxt.generateJavaSource("String " + strValName + " = null;");
        ctxt.generateJavaSource("if(");
======= fetch "public void doTag(TagPluginContext ctxt) {" 7c4a841^:"java/org/apache/jasper/tagplugins/jstl/core/Out.java"

        ctxt.generateJavaSource("!=null){");
        ctxt.generateJavaSource("    " + strValName + " = (");
        ctxt.generateAttribute("value");
        ctxt.generateJavaSource(").toString();");
======= fetch "public void doTag(TagPluginContext ctxt) {" 7c4a841^:"java/org/apache/jasper/tagplugins/jstl/core/Out.java"

        ctxt.generateJavaSource("String " + strDefName + " = null;\n");
======= fetch "public void doTag(TagPluginContext ctxt) {" 7c4a841^:"java/org/apache/jasper/tagplugins/jstl/core/Out.java"

                strValName + ", " + strDefName + ", " + strEscapeXmlName +
                ");");
======= fetch "public void doTag(TagPluginContext ctxt) {" 7c4a841^:"java/org/apache/jasper/tagplugins/jstl/core/Out.java"

    public static boolean output(JspWriter out, String value, String defaultValue,
            boolean escapeXml) throws IOException {
        String v = value != null ? value : defaultValue;
        if (v != null) {
            if(escapeXml){
                v = org.apache.jasper.tagplugins.jstl.Util.escapeXml(v);
======= fetch "public static boolean output(JspWriter out, String value, String defaultValue," 7c4a841^:"java/org/apache/jasper/tagplugins/jstl/core/Out.java"

            out.write(v);
======= fetch "public static boolean output(JspWriter out, String value, String defaultValue," 7c4a841^:"java/org/apache/jasper/tagplugins/jstl/core/Out.java"

            return false;
======= fetch "public void testBug54144() throws Exception {" 7c4a841^:"test/org/apache/jasper/tagplugins/jstl/core/TestOut.java"

         pageEncoding="ISO-8859-1" session="false"%>
    <p><c:out value="${session.doesNotExist}">OK - 1</c:out></p>
    <p><c:out value="${session.doesNotExist}">${'OK - '}${1+1}</c:out></p>

======= fetch "public static void writeVMState(PrintWriter writer, int mode)" 9998c80^:"java/org/apache/catalina/manager/StatusTransformer.java"

        SortedMap<String, MemoryPoolMXBean> memoryPoolMBeans = new TreeMap<>();
        for (MemoryPoolMXBean mbean: ManagementFactory.getMemoryPoolMXBeans()) {
            String sortKey = mbean.getType() + ":" + mbean.getName();
            memoryPoolMBeans.put(sortKey, mbean);
        }
======= fetch "public static void writeVMState(PrintWriter writer, int mode)" 9998c80^:"java/org/apache/catalina/manager/StatusTransformer.java"

            writer.write("<table border=\"0\"><thead><tr><th>Memory Pool</th><th>Type</th><th>Initial</th><th>Total</th><th>Maximum</th><th>Used</th></tr></thead><tbody>");
            for (MemoryPoolMXBean memoryPoolMBean : memoryPoolMBeans.values()) {
                MemoryUsage usage = memoryPoolMBean.getUsage();
                writer.write("<tr><td>");
                writer.print(memoryPoolMBean.getName());
                writer.write("</td><td>");
                writer.print(memoryPoolMBean.getType());
                writer.write("</td><td>");
                writer.print(formatSize(Long.valueOf(usage.getInit()), true));
                writer.write("</td><td>");
                writer.print(formatSize(Long.valueOf(usage.getCommitted()), true));
                writer.write("</td><td>");
                writer.print(formatSize(Long.valueOf(usage.getMax()), true));
                writer.write("</td><td>");
                writer.print(formatSize(Long.valueOf(usage.getUsed()), true));
                if (usage.getMax() > 0) {
                    writer.write(" ("
                            + (usage.getUsed() * 100 / usage.getMax()) + "%)");
                }
                writer.write("</td></tr>");
            }
            writer.write("</tbody></table>");
======= fetch "public static void writeVMState(PrintWriter writer, int mode)" 9998c80^:"java/org/apache/catalina/manager/StatusTransformer.java"

            for (MemoryPoolMXBean memoryPoolMBean : memoryPoolMBeans.values()) {
                MemoryUsage usage = memoryPoolMBean.getUsage();
                writer.write("<memorypool");
                writer.write(" name='" + memoryPoolMBean.getName() + "'");
                writer.write(" type='" + memoryPoolMBean.getType() + "'");
                writer.write(" usageInit='" + usage.getInit() + "'");
                writer.write(" usageCommitted='" + usage.getCommitted() + "'");
                writer.write(" usageMax='" + usage.getMax() + "'");
                writer.write(" usageUsed='" + usage.getInit() + "'/>");
            }
   <b>Memory Pools</b><br />
   <xsl:apply-templates select="memorypool"/>
   <hr />
  <xsl:template match="memorypool">
    <table><tr>
             <td><b>Name:</b> <xsl:value-of select="@name"/></td>
             <td><b>Type:</b> <xsl:value-of select="@type"/></td>
             <td><b>Initial:</b> <xsl:value-of select="@usageInit"/></td>
             <td><b>Committed:</b> <xsl:value-of select="@usageCommitted"/></td>
             <td><b>Maximum:</b> <xsl:value-of select="@usageMax"/></td>
             <td><b>Used:</b> <xsl:value-of select="@usageUsed"/></td>
           </tr>
    </table>
  </xsl:template>

    private static final int MAX_NESTED_REALM_LEVELS = Integer.getInteger(
            "org.apache.catalina.startup.RealmRuleSet.MAX_NESTED_REALM_LEVELS",
            3).intValue();
======= fetch "public void addRuleInstances(Digester digester) {" 2ed3d7d^:"java/org/apache/catalina/startup/RealmRuleSet.java"

        digester.addObjectCreate(prefix + "Realm",
                                 null, // MUST be specified in the element,
                                 "className");
        digester.addSetProperties(prefix + "Realm");
        digester.addSetNext(prefix + "Realm",
                            "setRealm",
                            "org.apache.catalina.Realm");
        digester.addObjectCreate(prefix + "Realm/Realm",
                                 null, // MUST be specified in the element
                                 "className");
        digester.addSetProperties(prefix + "Realm/Realm");
        digester.addSetNext(prefix + "Realm/Realm",
                            "addRealm",
                            "org.apache.catalina.Realm");
======= fetch "public void addRuleInstances(Digester digester) {" 2ed3d7d^:"java/org/apache/catalina/startup/RealmRuleSet.java"

    <property name="org.apache.catalina.startup. RealmRuleSet.MAX_NESTED_REALM_LEVELS">
      <p>The CombinedRealm allows nested Realms. This property controls the
      maximum permitted number of levels of nesting.</p>
      <p>If not specified, the default value of <code>3</code> will be used.</p>
    </property>

======= fetch "protected void service(HttpServletRequest req, HttpServletResponse resp)" 810732d^:"java/javax/servlet/http/HttpServlet.java"

                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);

======= fetch "public void setRequest(String[] theRequest) {" 8f53c89^:"test/org/apache/catalina/startup/SimpleHttpClient.java"

    /*
     * Expect the server to reply with 100 Continue interim response
     */
======= fetch "public String getResponseBody() {" 8f53c89^:"test/org/apache/catalina/startup/SimpleHttpClient.java"

    public List<String> getResponseBodyUriElements() {
        return bodyUriElments;
    }
======= fetch "public void processRequest(boolean wantBody)" 8f53c89^:"test/org/apache/catalina/startup/SimpleHttpClient.java"

    /*
     * Send the component parts of the request
     * (be tolerant and simply skip null entries)
     */
======= fetch "public void sendRequest() throws InterruptedException, IOException {" 8f53c89^:"test/org/apache/catalina/startup/SimpleHttpClient.java"

        // Send the request
======= fetch "public void sendRequest() throws InterruptedException, IOException {" 8f53c89^:"test/org/apache/catalina/startup/SimpleHttpClient.java"

            if (first) {
                first = false;
            } else {
                Thread.sleep(requestPause);
======= fetch "public void sendRequest() throws InterruptedException, IOException {" 8f53c89^:"test/org/apache/catalina/startup/SimpleHttpClient.java"

            writer.write(requestPart);
            writer.flush();

======= fetch "public void dispatch(ServletContext context, String path) {" 76f84eb^:"java/org/apache/catalina/core/AsyncContextImpl.java"

            request.setAttribute(ASYNC_REQUEST_URI, request.getRequestURI()+"?"+request.getQueryString());
======= fetch "public void dispatch(ServletContext context, String path) {" 76f84eb^:"java/org/apache/catalina/core/AsyncContextImpl.java"

            request.setAttribute(ASYNC_PATH_INFO, request.getPathInfo());

======= fetch "public boolean timeout() throws IOException {" 14637ef^:"java/org/apache/catalina/core/AsyncContextImpl.java"

                    // No listeners, container calls complete
                    complete();
======= fetch "public void setErrorState(Throwable t) {" 14637ef^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        // SRV.2.3.3.3 (search for "error dispatch")
        if (servletResponse instanceof HttpServletResponse) {
            ((HttpServletResponse) servletResponse).setStatus(
                    HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
        Host host = (Host) context.getParent();
        Valve stdHostValve = host.getPipeline().getBasic();
        if (stdHostValve instanceof StandardHostValve) {
            ((StandardHostValve) stdHostValve).throwable(request,
                    request.getResponse(), t);
        }
        if (isStarted() && !request.isAsyncDispatching()) {
            complete();
        }
======= fetch "public final void invoke(Request request, Response response)" 14637ef^:"java/org/apache/catalina/core/StandardHostValve.java"

        // An async error page may dispatch to another resource. This flag helps
        // ensure an infinite error handling loop is not entered
        boolean errorAtStart = response.isError();
======= fetch "public final void invoke(Request request, Response response)" 14637ef^:"java/org/apache/catalina/core/StandardHostValve.java"

                request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
                throwable(request, response, t);
======= fetch "public final void invoke(Request request, Response response)" 14637ef^:"java/org/apache/catalina/core/StandardHostValve.java"

            if (!(request.isAsync() || (asyncAtStart && request.getAttribute(
                        RequestDispatcher.ERROR_EXCEPTION) != null))) {
                // Protect against NPEs if context was destroyed during a long
                // running request.
======= fetch "public final void invoke(Request request, Response response)" 14637ef^:"java/org/apache/catalina/core/StandardHostValve.java"

                    // Error page processing
                    response.setSuspended(false);
                    Throwable t = (Throwable) request.getAttribute(
                            RequestDispatcher.ERROR_EXCEPTION);
                    if (t != null) {
                        throwable(request, response, t);
                    } else {
                        status(request, response);
======= fetch "private void status(Request request, Response response) {" 14637ef^:"java/org/apache/catalina/core/StandardHostValve.java"

    private void throwable(Request request, Response response,
======= fetch "public synchronized boolean asyncDispatch() {" 14637ef^:"java/org/apache/coyote/AsyncStateMachine.java"

                state == AsyncState.TIMING_OUT) {
======= fetch "public void testAsyncStartNoComplete() throws Exception {" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        alv.validateAccessLog(2, 200,
======= fetch "public void testTimeoutListenerCompleteNoDispatch() throws Exception {" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        doTestTimeout(true, null);
======= fetch "public void testTimeoutListenerNoCompleteNoDispatch() throws Exception {" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        doTestTimeout(false, null);
======= fetch "public void testTimeoutListenerCompleteDispatch() throws Exception {" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        doTestTimeout(true, "/nonasync");
======= fetch "public void testTimeoutListenerNoCompleteDispatch() throws Exception {" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        doTestTimeout(false, "/nonasync");
======= fetch "public void testTimeoutListenerNoCompleteDispatch() throws Exception {" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    @Test
    public void testTimeoutNoListener() throws Exception {
        // Should work
        doTestTimeout(null, null);
    }
======= fetch "public void testTimeoutListenerNoCompleteDispatch() throws Exception {" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

            new TimeoutServlet(completeOnTimeout, dispatchUrl);
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        expected.append("TimeoutServletGet-onTimeout-");
        if (completeOnTimeout) {
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

            expected.append("onTimeout-");
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        if (completeOnTimeout && dispatchUrl != null) {
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        private final boolean completeOnTimeout;
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        public TimeoutServlet(boolean completeOnTimeout, String dispatchUrl) {
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                ac.addListener(new TrackingListener(
                        false, completeOnTimeout, dispatchUrl));
======= fetch "public void testListeners() throws Exception {" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TimeoutServlet timeout = new TimeoutServlet(true, null);
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 14637ef^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    @Test
    public void testTimeoutErrorDispatchNone() throws Exception {
        doTestTimeoutErrorDispatch(null, null);
    }
    @Test
    public void testTimeoutErrorDispatchNonAsync() throws Exception {
        doTestTimeoutErrorDispatch(Boolean.FALSE, null);
    }
    @Test
    public void testTimeoutErrorDispatchAsyncStart() throws Exception {
        doTestTimeoutErrorDispatch(
                Boolean.TRUE, ErrorPageAsyncMode.NO_COMPLETE);
    }
    @Test
    public void testTimeoutErrorDispatchAsyncComplete() throws Exception {
        doTestTimeoutErrorDispatch(Boolean.TRUE, ErrorPageAsyncMode.COMPLETE);
    }
    @Test
    public void testTimeoutErrorDispatchAsyncDispatch() throws Exception {
        doTestTimeoutErrorDispatch(Boolean.TRUE, ErrorPageAsyncMode.DISPATCH);
    }
    private void doTestTimeoutErrorDispatch(Boolean asyncError,
            ErrorPageAsyncMode mode) throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        File docBase = new File(System.getProperty("java.io.tmpdir"));
        Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
        TimeoutServlet timeout = new TimeoutServlet(null, null);
        Wrapper w1 = Tomcat.addServlet(ctx, "time", timeout);
        w1.setAsyncSupported(true);
        ctx.addServletMapping("/async", "time");
        NonAsyncServlet nonAsync = new NonAsyncServlet();
        Wrapper w2 = Tomcat.addServlet(ctx, "nonAsync", nonAsync);
        w2.setAsyncSupported(true);
        ctx.addServletMapping("/error/nonasync", "nonAsync");
        AsyncErrorPage asyncErrorPage = new AsyncErrorPage(mode);
        Wrapper w3 = Tomcat.addServlet(ctx, "asyncErrorPage", asyncErrorPage);
        w3.setAsyncSupported(true);
        ctx.addServletMapping("/error/async", "asyncErrorPage");
        if (asyncError != null) {
            ErrorPage ep = new ErrorPage();
            ep.setErrorCode(500);
            if (asyncError.booleanValue()) {
                ep.setLocation("/error/async");
            } else {
                ep.setLocation("/error/nonasync");
            }
            ctx.addErrorPage(ep);
        }
        ctx.addApplicationListener(TrackingRequestListener.class.getName());
        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        TesterAccessLogValve alvGlobal = new TesterAccessLogValve();
        tomcat.getHost().getPipeline().addValve(alvGlobal);
        tomcat.start();
        ByteChunk res = new ByteChunk();
        try {
            getUrl("http://localhost:" + getPort() + "/async", res, null);
        } catch (IOException ioe) {
            // Ignore - expected for some error conditions
        }
        StringBuilder expected = new StringBuilder();
        if (asyncError == null) {
            // No error handler - just get the 500 response
            expected.append("requestInitialized-TimeoutServletGet-");
            // Note: With an error handler the response will be reset and these
            //       will be lost
        }
        if (asyncError != null) {
            if (asyncError.booleanValue()) {
                expected.append("AsyncErrorPageGet-");
                if (mode == ErrorPageAsyncMode.NO_COMPLETE){
                    expected.append("NoOp-");
                } else if (mode == ErrorPageAsyncMode.COMPLETE) {
                    expected.append("Complete-");
                } else if (mode == ErrorPageAsyncMode.DISPATCH) {
                    expected.append("Dispatch-NonAsyncServletGet-");
                }
            } else {
                expected.append("NonAsyncServletGet-");
            }
        }
        expected.append("requestDestroyed");
        Assert.assertEquals(expected.toString(), res.toString());
        // Check the access log
        alvGlobal.validateAccessLog(1, 500, TimeoutServlet.ASYNC_TIMEOUT,
                TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN +
                REQUEST_TIME);
        alv.validateAccessLog(1, 500, TimeoutServlet.ASYNC_TIMEOUT,
                TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN +
                REQUEST_TIME);
    }
    private static enum ErrorPageAsyncMode {
        NO_COMPLETE,
        COMPLETE,
        DISPATCH
    }
    private static class AsyncErrorPage extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private final ErrorPageAsyncMode mode;
        public AsyncErrorPage(ErrorPageAsyncMode mode) {
            this.mode = mode;
        }
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            PrintWriter writer = resp.getWriter();
            writer.write("AsyncErrorPageGet-");
            resp.flushBuffer();
            final AsyncContext ctxt = req.getAsyncContext();
            switch(mode) {
                case COMPLETE:
                    writer.write("Complete-");
                    ctxt.complete();
                    break;
                case DISPATCH:
                    writer.write("Dispatch-");
                    ctxt.dispatch("/error/nonasync");
                    break;
                case NO_COMPLETE:
                    writer.write("NoOp-");
                    break;
                default:
                    // Impossible
                    break;
            }
        }
    }

======= fetch "public synchronized void pong(ByteBuffer data) throws IOException {" 8fea85c^:"java/org/apache/catalina/websocket/WsOutbound.java"

        sendControlMessage(data, Constants.OPCODE_PONG);
    }
    /**
     * Send a ping message to the client
     *
     * @param data      Optional message.
     *
     * @throws IOException  If an error occurs writing to the client
     */
    public synchronized void ping(ByteBuffer data) throws IOException {
        sendControlMessage(data, Constants.OPCODE_PING);
    }
    /**
     * Generic function to send either a ping or a pong.
     *
     * @param data      Optional message.
     * @param opcode    The byte to include as the opcode.
     *
     * @throws IOException  If an error occurs writing to the client
     */
    private synchronized void sendControlMessage(ByteBuffer data, byte opcode) throws IOException {
======= fetch "public synchronized void pong(ByteBuffer data) throws IOException {" 8fea85c^:"java/org/apache/catalina/websocket/WsOutbound.java"

        upgradeOutbound.write(0x8A);

======= fetch "public void addEnvironment(ContextEnvironment env) {" 48314f9^:"java/org/apache/catalina/core/NamingContextListener.java"

                logger.error(sm.getString("naming.invalidEnvEntryType", env.getName()));
======= fetch "public void addEnvironment(ContextEnvironment env) {" 48314f9^:"java/org/apache/catalina/core/NamingContextListener.java"

    private static final String JNDI_NAME = "TestName";
    private static final String JNDI_VALUE= "Test Value";
======= fetch "public void testBug49132() throws Exception {" 48314f9^:"test/org/apache/catalina/core/TestNamingContextListener.java"

        environment.setType(JNDI_VALUE.getClass().getName());
        environment.setName(JNDI_NAME);
        environment.setValue(JNDI_VALUE);
======= fetch "public void contextInitialized(ServletContextEvent sce) {" 48314f9^:"test/org/apache/catalina/core/TestNamingContextListener.java"

                String value = (String) envCtx.lookup(JNDI_NAME);
                if (!JNDI_VALUE.equals(value)) {
======= fetch "public void contextInitialized(ServletContextEvent sce) {" 48314f9^:"test/org/apache/catalina/core/TestNamingContextListener.java"

    @Test
    public void testBug54096() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        org.apache.catalina.Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        // Enable JNDI - it is disabled by default
        tomcat.enableNaming();
        ContextEnvironment environmentA = new ContextEnvironment();
        environmentA.setType(Bug54096EnvA.class.getName());
        environmentA.setName(BUG54096_NameA);
        environmentA.setValue(BUG54096_ValueA);
        ctx.getNamingResources().addEnvironment(environmentA);
        ContextEnvironment environmentB = new ContextEnvironment();
        environmentB.setType(Bug54096EnvB.class.getName());
        environmentB.setName(BUG54096_NameB);
        environmentB.setValue(BUG54096_ValueB);
        ctx.getNamingResources().addEnvironment(environmentB);
        ctx.addApplicationListener(Bug54096Listener.class.getName());
        tomcat.start();
        assertEquals(LifecycleState.STARTED, ctx.getState());
    }
    public static class Bug54096EnvA {
        private final String value;
        public Bug54096EnvA(String value) {
            this.value = value;
        }
        public String getValue() {
            return value;
        }
    }
    public static class Bug54096EnvB {
        private final char value;
        public Bug54096EnvB(char value) {
            this.value = value;
        }
        public char getValue() {
            return value;
        }
    }
    public static final class Bug54096Listener implements
            ServletContextListener {
        @Override
        public void contextDestroyed(ServletContextEvent sce) {
            // NOOP
        }
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            javax.naming.Context initCtx;
            try {
                initCtx = new InitialContext();
                javax.naming.Context envCtx =
                    (javax.naming.Context) initCtx.lookup("java:comp/env");
                // Validate entry A
                Bug54096EnvA valueA =
                        (Bug54096EnvA) envCtx.lookup(BUG54096_NameA);
                if (!BUG54096_ValueA.equals(valueA.getValue())) {
                    throw new RuntimeException();
                }
                // Validate entry B
                Bug54096EnvB valueB =
                        (Bug54096EnvB) envCtx.lookup(BUG54096_NameB);
                if (BUG54096_ValueB.charAt(0) != valueB.getValue()) {
                    throw new RuntimeException();
                }
            } catch (NamingException e) {
                throw new RuntimeException(e);
            }
        }
    }

======= fetch "public void setStoreDelegatedCredential(" 9f65875^:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

    private Pattern noKeepAliveUserAgents = null;
    public String getNoKeepAliveUserAgents() {
        Pattern p = noKeepAliveUserAgents;
        if (p == null) {
            return null;
        } else {
            return p.pattern();
        }
    }
    public void setNoKeepAliveUserAgents(String noKeepAliveUserAgents) {
        if (noKeepAliveUserAgents == null ||
                noKeepAliveUserAgents.length() == 0) {
            this.noKeepAliveUserAgents = null;
        } else {
            this.noKeepAliveUserAgents = Pattern.compile(noKeepAliveUserAgents);
        }
    }
======= fetch "public GSSCredential run() throws GSSException {" 9f65875^:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

            Pattern p = noKeepAliveUserAgents;
            if (p != null) {
                MessageBytes ua =
                        request.getCoyoteRequest().getMimeHeaders().getValue(
                                "user-agent");
                if (ua != null && p.matcher(ua.toString()).matches()) {
                    response.setHeader("Connection", "close");
                }
            }
      <attribute name="alwaysUseSession" required="false">
        <p>Should a session always be used once a user is authenticated? This
        may offer some performance benefits since the session can then be used
        to cache the authenticated Principal, hence removing the need to
        authenticate the user on every request. This will also help with clients
        that assume that the server will cache the authenticated user. However
        there will also be the performance cost of creating and GC'ing the
        session. For an alternative solution see
        <code>noKeepAliveUserAgents</code>. If not set, the default value of
        <code>false</code> will be used.</p>
      </attribute>
      <attribute name="noKeepAliveUserAgents" required="false">
        <p>Some clients (not most browsers) expect the server to cache the
        authenticated user information for a connection and do not resend the
        credentials with every request. Tomcat will not do this unless an HTTP
        session is available. A session will be availble if either the
        application creates one or if <code>alwaysUseSession</code> is enabled
        for this Authenticator.</p>
        <p>As an alternative to creating a session, this attribute may be used
        to define the user agents for which HTTP keep-alive is disabled. This
        means that a connection will only used for a single request and hence
        there is no ability to cache authenticated user information per
        connection. There will be a performance cost in disabling HTTP
        keep-alive.</p>
        <p>The attribute should be a regular expression that matches the entire
        user-agent string, e.g. <code>.*Chrome.*</code>. If not specified, no
        regular expression will be defined and no user agents will have HTTP
        keep-alive disabled.</p>
      </attribute>

======= fetch "private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest," 07d343a^:"java/org/apache/catalina/deploy/WebXml.java"

            List<String> order = new LinkedList<>();
            // Start by adding all fragments - order doesn't matter
            order.addAll(fragments.keySet());
            // Now go through and move elements to start/end depending on if
            // they specify others
            for (WebXml fragment : fragments.values()) {
                String name = fragment.getName();
                if (fragment.getBeforeOrdering().contains(WebXml.ORDER_OTHERS)) {
                    // Move to beginning
                    order.remove(name);
                    order.add(0, name);
                } else if (fragment.getAfterOrdering().contains(WebXml.ORDER_OTHERS)) {
                    // Move to end
                    order.remove(name);
                    order.add(name);
                }
            }
            // Now apply remaining ordering
======= fetch "private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest," 07d343a^:"java/org/apache/catalina/deploy/WebXml.java"

                String name = fragment.getName();
======= fetch "private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest," 07d343a^:"java/org/apache/catalina/deploy/WebXml.java"

                    if (!before.equals(WebXml.ORDER_OTHERS) &&
                            order.contains(before) &&
                            order.indexOf(before) < order.indexOf(name)) {
                        order.remove(name);
                        order.add(order.indexOf(before), name);
======= fetch "private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest," 07d343a^:"java/org/apache/catalina/deploy/WebXml.java"

                    if (!after.equals(WebXml.ORDER_OTHERS) &&
                            order.contains(after) &&
                            order.indexOf(after) > order.indexOf(name)) {
                        order.remove(name);
                        order.add(order.indexOf(after) + 1, name);
======= fetch "private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest," 07d343a^:"java/org/apache/catalina/deploy/WebXml.java"

            // Finally check ordering was applied correctly - if there are
            // errors then that indicates circular references
======= fetch "private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest," 07d343a^:"java/org/apache/catalina/deploy/WebXml.java"

                String name = fragment.getName();
                for (String before : fragment.getBeforeOrdering()) {
                    if (!before.equals(WebXml.ORDER_OTHERS) &&
                            order.contains(before) &&
                            order.indexOf(before) < order.indexOf(name)) {
                        throw new IllegalArgumentException(
                                sm.getString("webXml.mergeConflictOrder"));
                    }
======= fetch "private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest," 07d343a^:"java/org/apache/catalina/deploy/WebXml.java"

                for (String after : fragment.getAfterOrdering()) {
                    if (!after.equals(WebXml.ORDER_OTHERS) &&
                            order.contains(after) &&
                            order.indexOf(after) > order.indexOf(name)) {
                        throw new IllegalArgumentException(
                                sm.getString("webXml.mergeConflictOrder"));
                    }
======= fetch "private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest," 07d343a^:"java/org/apache/catalina/deploy/WebXml.java"

            // Build the ordered list
            for (String name : order) {
                orderedFragments.add(fragments.get(name));
======= fetch "private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest," 07d343a^:"java/org/apache/catalina/deploy/WebXml.java"

            // Stage 4. Decouple the groups so the ordering requirements for
            //          each fragment in the group only refer to other fragments
            //          in the group. Ordering requirements outside the group
            //          will be handled by processing the groups in order.
            //          Note: Only after ordering requirements are considered.
            //                This is OK because of the processing in stage 1.
            decoupleOtherGroups(beforeSet);
            decoupleOtherGroups(othersSet);
            decoupleOtherGroups(afterSet);
            // Stage 5. Order each group
            //          Note: Only after ordering requirements are considered.
            //                This is OK because of the processing in stage 1.
            orderFragments(orderedFragments, beforeSet);
            orderFragments(orderedFragments, othersSet);
            orderFragments(orderedFragments, afterSet);
======= fetch "private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest," 07d343a^:"java/org/apache/catalina/deploy/WebXml.java"

    public void setUp() throws Exception {
======= fetch "public void setUp() throws Exception {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

        fragments = new HashMap<>();
======= fetch "public void testOrderWebFragmentsAbsoluteOthersEnd() {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

    private void doRelativeOrderingTest(RelativeOrderingTestRunner runner) {
        // Confirm we have all 720 possible input orders
        // Set<String> orders = new HashSet<>();
        // Test all possible input orders since some bugs were discovered that
        // depended on input order
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 5; j++) {
                for (int k = 0; k < 4; k++) {
                    for (int l = 0; l < 3; l++) {
                        for (int m = 0; m < 2; m++) {
                            setUp();
                            runner.init();
                            ArrayList<WebXml> source = new ArrayList<>();
                            source.addAll(fragments.values());
                            Map<String,WebXml> input =
                                    new LinkedHashMap<>();
                            WebXml one = source.remove(i);
                            input.put(one.getName(), one);
                            WebXml two = source.remove(j);
                            input.put(two.getName(), two);
                            WebXml three = source.remove(k);
                            input.put(three.getName(), three);
                            WebXml four = source.remove(l);
                            input.put(four.getName(), four);
                            WebXml five = source.remove(m);
                            input.put(five.getName(), five);
                            WebXml six = source.remove(0);
                            input.put(six.getName(), six);
                            /*
                            String order = one.getName() + two.getName() +
                                    three.getName() + four.getName() +
                                    five.getName() + six.getName();
                            orders.add(order);
                            */
                            Set<WebXml> ordered =
                                    WebXml.orderWebFragments(app, input);
                            populatePositions(ordered);
                            runner.validate(getOrder(ordered));
                        }
                    }
                }
            }
        }
        // System.out.println(orders.size());
    }
    private String getOrder(Set<WebXml> ordered) {
        StringBuilder sb = new StringBuilder(ordered.size());
        for (WebXml webXml : ordered) {
            sb.append(webXml.getName());
        }
        return sb.toString();
    }
    private void populatePositions(Set<WebXml> ordered) {
        List<WebXml> indexed = new ArrayList<>();
        indexed.addAll(ordered);
        posA = indexed.indexOf(a);
        posB = indexed.indexOf(b);
        posC = indexed.indexOf(c);
        posD = indexed.indexOf(d);
        posE = indexed.indexOf(e);
        posF = indexed.indexOf(f);
    }
======= fetch "public void testOrderWebFragmentsRelative1() {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

        a.addAfterOrderingOthers();
        a.addAfterOrdering("c");
        b.addBeforeOrderingOthers();
        c.addAfterOrderingOthers();
        f.addBeforeOrderingOthers();
        f.addBeforeOrdering("b");
        Set<WebXml> ordered = WebXml.orderWebFragments(app, fragments);
        Iterator<WebXml> iter = ordered.iterator();
        assertEquals(f,iter.next());
        assertEquals(b,iter.next());
        assertEquals(d,iter.next());
        assertEquals(e,iter.next());
        assertEquals(c,iter.next());
        assertEquals(a,iter.next());
======= fetch "public void testOrderWebFragmentsRelative2() {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

        a.addAfterOrderingOthers();
        a.addBeforeOrdering("c");
        b.addBeforeOrderingOthers();
        d.addAfterOrderingOthers();
        e.addBeforeOrderingOthers();
======= fetch "public void testOrderWebFragmentsRelative2() {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

        Set<WebXml> ordered = WebXml.orderWebFragments(app, fragments);
======= fetch "public void testOrderWebFragmentsRelative2() {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

        Iterator<WebXml> iter = ordered.iterator();
        // A number of orders are possible but the algorithm is deterministic
        // and this order is valid. If this fails after a change to the
        // algorithm, then check to see if the new order is also valid.
        assertEquals(b,iter.next());
        assertEquals(e,iter.next());
        assertEquals(f,iter.next());
        assertEquals(a,iter.next());
        assertEquals(c,iter.next());
        assertEquals(d,iter.next());
======= fetch "public void testOrderWebFragmentsRelative2() {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

    public void testOrderWebFragmentsRelative3() {
        // Third example from spec
        a.addAfterOrdering("b");
        c.addBeforeOrderingOthers();
        fragments.remove("e");
        fragments.remove("f");
======= fetch "public void testOrderWebFragmentsRelative3() {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

        Set<WebXml> ordered = WebXml.orderWebFragments(app, fragments);
======= fetch "public void testOrderWebFragmentsRelative3() {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

        Iterator<WebXml> iter = ordered.iterator();
        // A number of orders are possible but the algorithm is deterministic
        // and this order is valid. If this fails after a change to the
        // algorithm, then check to see if the new order is also valid.
        assertEquals(c,iter.next());
        assertEquals(d,iter.next());
        assertEquals(b,iter.next());
        assertEquals(a,iter.next());
======= fetch "public void testOrderWebFragmentsRelative3() {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

    public void testOrderWebFragmentsrelativeCircular() {
======= fetch "public void testOrderWebFragmentsrelativeCircular() {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

        Exception exception = null;
======= fetch "public void testOrderWebFragmentsrelativeCircular() {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

        try {
            WebXml.orderWebFragments(app, fragments);
        } catch (Exception e1) {
            exception = e1;
======= fetch "public void testOrderWebFragmentsrelativeCircular() {" 07d343a^:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

        assertTrue(exception instanceof IllegalArgumentException);

======= fetch "private void prepareResponse() {" 9308b3f^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        if ((statusCode == 204) || (statusCode == 205)
            || (statusCode == 304)) {

======= fetch "private void doHandlePageException(Throwable t) throws IOException," c40ca99^:"java/org/apache/jasper/runtime/PageContextImpl.java"

    private static String XmlEscape(String s) {
        if (s == null)
======= fetch "private static String XmlEscape(String s) {" c40ca99^:"java/org/apache/jasper/runtime/PageContextImpl.java"

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
======= fetch "private static String XmlEscape(String s) {" c40ca99^:"java/org/apache/jasper/runtime/PageContextImpl.java"

            if (c == '<') {
                sb.append("&lt;");
            } else if (c == '>') {
                sb.append("&gt;");
            } else if (c == '\'') {
                sb.append("&#039;"); // &apos;
            } else if (c == '&') {
                sb.append("&amp;");
            } else if (c == '"') {
                sb.append("&#034;"); // &quot;
            } else {
                sb.append(c);
======= fetch "private static String XmlEscape(String s) {" c40ca99^:"java/org/apache/jasper/runtime/PageContextImpl.java"

        return sb.toString();

    private static final Hashtable<String,String> shellEnv = new Hashtable<>();

======= fetch "public SocketState process(SocketWrapper<S> socket," 874c332^:"java/org/apache/coyote/AbstractProtocol.java"

                    if (status == SocketStatus.DISCONNECT) {
                        //do nothing here, just wait for it to get recycled
                    } else if (processor.isAsync() || state == SocketState.ASYNC_END) {

======= fetch "private String convertString(Class<?> c, String s, String attrName," 095a403^:"java/org/apache/jasper/compiler/Generator.java"

                return "new String(" + quoted + ")";

======= fetch "public void init(JspCompilationContext ctxt, JspServletWrapper jsw) {" a0ff3f9^:"java/org/apache/jasper/compiler/Compiler.java"

                errDispatcher), ctxt.getJspFile());
    PageInfo(BeanRepository beanRepository, String jspFile) {
======= fetch "public void generateBody() {" a0ff3f9^:"java/org/apache/jasper/compiler/TagPluginManager.java"

        @Override
        public boolean isTagFile() {
            return pageInfo.isTagFile();
        }
    /**
     * Is the tag being used inside a tag file?
     */
    boolean isTagFile();
======= fetch "public void doTag(TagPluginContext ctxt) {" a0ff3f9^:"java/org/apache/jasper/tagplugins/jstl/core/Set.java"

            String jspCtxt = null;
            if (ctxt.isTagFile()) {
                jspCtxt = "this.getJspContext()";
            } else {
                jspCtxt = "_jspx_page_context";
            }
======= fetch "public void doTag(TagPluginContext ctxt) {" a0ff3f9^:"java/org/apache/jasper/tagplugins/jstl/core/Set.java"

            ctxt.generateJavaSource("    pageContext.setAttribute(\"" + strVar + "\"," + resultName + "," + iScope + ");");
======= fetch "public void doTag(TagPluginContext ctxt) {" a0ff3f9^:"java/org/apache/jasper/tagplugins/jstl/core/Set.java"

                ctxt.generateJavaSource("    pageContext.removeAttribute(\"" + strVar + "\"," + iScope + ");");
======= fetch "public void doTag(TagPluginContext ctxt) {" a0ff3f9^:"java/org/apache/jasper/tagplugins/jstl/core/Set.java"

                ctxt.generateJavaSource("    pageContext.removeAttribute(\"" + strVar + "\");");

======= fetch "public void memberDisappeared(Member member) {" d2b41b5^:"java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java"

                if (member instanceof StaticMember) {
                    addSuspects.put(member, Long.valueOf(System.currentTimeMillis()));
                }
======= fetch "protected void performForcedCheck() {" d2b41b5^:"java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java"

                    if (members[i] instanceof StaticMember) {
                        addSuspects.put(members[i], Long.valueOf(System.currentTimeMillis()));
                    }
======= fetch "protected void performBasicCheck() {" d2b41b5^:"java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java"

            if (addSuspects.containsKey(members[i]) && membership.getMember(members[i]) == null) {
                // avoid temporary adding member.
                continue;
            }

======= fetch "protected void prepareRequest() {" 9f04094^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

                request.scheme().setString("https");
======= fetch "protected void prepareRequest() {" 9f04094^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

                request.scheme().setString("https");
======= fetch "protected void prepareRequest() {" 9f04094^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

                request.scheme().setString("https");

======= fetch "public void addElement(CharArrayWriter buf, Date date, Request request," 39c4270^:"java/org/apache/catalina/valves/AccessLogValve.java"

            if (request != null) {
                if (request.getSession(false) != null) {
                    buf.append(request.getSessionInternal(false)
                            .getIdInternal());
                } else {
======= fetch "public void addElement(CharArrayWriter buf, Date date, Request request," 39c4270^:"java/org/apache/catalina/valves/AccessLogValve.java"

                } else {
                    buf.append(session.getIdInternal());
======= fetch "public void addElement(CharArrayWriter buf, Date date, Request request," 39c4270^:"java/org/apache/catalina/valves/AccessLogValve.java"

            } else {
                buf.append('-');

======= fetch "Mark skipUntil(String limit) throws JasperException {" 88d8dd5^:"java/org/apache/jasper/compiler/JspReader.java"

                       setCurrent(restart);

======= fetch "public abstract void rename(String oldName, String newName)" a3e0f09^:"java/org/apache/naming/resources/BaseDirContext.java"

    public NamingEnumeration<NameClassPair> list(Name name)
======= fetch "public abstract void rename(String oldName, String newName)" a3e0f09^:"java/org/apache/naming/resources/BaseDirContext.java"

    public abstract NamingEnumeration<NameClassPair> list(String name)
        throws NamingException;
======= fetch "public void rename(String oldName, String newName)" a3e0f09^:"java/org/apache/naming/resources/FileDirContext.java"

     * Enumerates the names bound in the named context, along with the class
     * names of objects bound to them. The contents of any subcontexts are
     * not included.
     * <p>
     * If a binding is added to or removed from this context, its effect on
     * an enumeration previously returned is undefined.
     *
     * @param name the name of the context to list
     * @return an enumeration of the names and class names of the bindings in
     * this context. Each element of the enumeration is of type NameClassPair.
     * @exception NamingException if a naming exception is encountered
     */
    @Override
    public NamingEnumeration<NameClassPair> list(String name)
        throws NamingException {
        File file = file(name);
        if (file == null)
            throw new NameNotFoundException
                (sm.getString("resources.notFound", name));
        return new NamingContextEnumeration(list(file).iterator());
    }
    /**
======= fetch "public void rename(String oldName, String newName)" a3e0f09^:"java/org/apache/naming/resources/WARDirContext.java"

     * Enumerates the names bound in the named context, along with the class
     * names of objects bound to them. The contents of any subcontexts are
     * not included.
     * <p>
     * If a binding is added to or removed from this context, its effect on
     * an enumeration previously returned is undefined.
     *
     * @param name the name of the context to list
     * @return an enumeration of the names and class names of the bindings in
     * this context. Each element of the enumeration is of type NameClassPair.
     * @exception NamingException if a naming exception is encountered
     */
    @Override
    public NamingEnumeration<NameClassPair> list(String name)
        throws NamingException {
        return list(getEscapedJndiName(name));
    }
    /**
     * Enumerates the names bound in the named context, along with the class
     * names of objects bound to them. The contents of any subcontexts are
     * not included.
     * <p>
     * If a binding is added to or removed from this context, its effect on
     * an enumeration previously returned is undefined.
     *
     * @param name the name of the context to list
     * @return an enumeration of the names and class names of the bindings in
     * this context. Each element of the enumeration is of type NameClassPair.
     * @exception NamingException if a naming exception is encountered
     */
    @Override
    public NamingEnumeration<NameClassPair> list(Name name)
        throws NamingException {
        if (name.isEmpty())
            return new NamingContextEnumeration(list(entries).iterator());
        Entry entry = treeLookup(name);
        if (entry == null)
            throw new NameNotFoundException
                (sm.getString("resources.notFound", name));
        return new NamingContextEnumeration(list(entry).iterator());
    }
    /**

======= fetch "public static void initWebappDefaults(Context ctx) {" 7f6f99e^:"java/org/apache/catalina/startup/Tomcat.java"

        servlet.setOverridable(true);
======= fetch "public static void initWebappDefaults(Context ctx) {" 7f6f99e^:"java/org/apache/catalina/startup/Tomcat.java"

        servlet.setOverridable(true);

    /**
     * Returns true of the Host is configured to automatically undeploy old
     * versions of applications deployed using parallel deployment. This only
     * takes effect is {@link #getAutoDeploy()} also returns true.
     */
    public boolean getUndeployOldVersions();
    /**
     * Set to true if the Host should automatically undeploy old versions of
     * applications deployed using parallel deployment. This only takes effect
     * if {@link #getAutoDeploy()} returns true.
     */
    public void setUndeployOldVersions(boolean undeployOldVersions);
======= fetch "public StandardHost() {" 97cefcc^:"java/org/apache/catalina/core/StandardHost.java"

    private boolean undeployOldVersions = false;
======= fetch "public StandardHost() {" 97cefcc^:"java/org/apache/catalina/core/StandardHost.java"

    public boolean getUndeployOldVersions() {
        return undeployOldVersions;
    }
    @Override
    public void setUndeployOldVersions(boolean undeployOldVersions) {
        this.undeployOldVersions = undeployOldVersions;
    }
    @Override
    <attribute name="undeployOldVersions"
               description="Determines if old versions of applications deployed using parallel deployment are automatically undeployed when no longer used. Requires autoDeploy to be enabled."
               type="boolean"/>
======= fetch "protected synchronized void checkResources(DeployedApplication app) {" 97cefcc^:"java/org/apache/catalina/startup/HostConfig.java"

                    if (log.isInfoEnabled())
                        log.info(sm.getString("hostConfig.undeploy", app.name));
                    Container context = host.findChild(app.name);
                    try {
                        host.removeChild(context);
                    } catch (Throwable t) {
                        ExceptionUtils.handleThrowable(t);
                        log.warn(sm.getString
                                 ("hostConfig.context.remove", app.name), t);
                    }
                    // Delete other redeploy resources
                    for (int j = i + 1; j < resources.length; j++) {
                        try {
                            File current = new File(resources[j]);
                            current = current.getCanonicalFile();
                            // Never delete per host context.xml defaults
                            if (Constants.HostContextXml.equals(
                                    current.getName())) {
                                continue;
                            }
                            // Only delete resources in the appBase or the
                            // host's configBase
                            if ((current.getAbsolutePath().startsWith(
                                    host.getAppBaseFile().getAbsolutePath() +
                                    File.separator))
                                    || (current.getAbsolutePath().startsWith(
                                            host.getConfigBaseFile().getAbsolutePath()))) {
                                if (log.isDebugEnabled())
                                    log.debug("Delete " + current);
                                ExpandWar.delete(current);
                            }
                        } catch (IOException e) {
                            log.warn(sm.getString
                                    ("hostConfig.canonicalizing", app.name), e);
                        }
                    }
                    deployed.remove(app.name);
======= fetch "protected synchronized void checkResources(DeployedApplication app) {" 97cefcc^:"java/org/apache/catalina/startup/HostConfig.java"

                if (log.isInfoEnabled())
                    log.info(sm.getString("hostConfig.undeploy", app.name));
                Container context = host.findChild(app.name);
                try {
                    host.removeChild(context);
                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                    log.warn(sm.getString
                             ("hostConfig.context.remove", app.name), t);
                }
                // Delete all redeploy resources
                for (int j = i + 1; j < resources.length; j++) {
                    try {
                        File current = new File(resources[j]);
                        current = current.getCanonicalFile();
                        // Never delete per host context.xml defaults
                        if (Constants.HostContextXml.equals(
                                current.getName())) {
                            continue;
                        }
                        // Only delete resources in the appBase or the host's
                        // configBase
                        if ((current.getAbsolutePath().startsWith(
                                host.getAppBaseFile().getAbsolutePath() + File.separator))
                            || (current.getAbsolutePath().startsWith(
                                    host.getConfigBaseFile().getAbsolutePath()))) {
                            if (log.isDebugEnabled())
                                log.debug("Delete " + current);
                            ExpandWar.delete(current);
                        }
                    } catch (IOException e) {
                        log.warn(sm.getString
                                ("hostConfig.canonicalizing", app.name), e);
                    }
                }
                // Delete reload resources as well (to remove any remaining .xml
                // descriptor)
                String[] resources2 =
                    app.reloadResources.keySet().toArray(new String[0]);
                for (int j = 0; j < resources2.length; j++) {
                    try {
                        File current = new File(resources2[j]);
                        current = current.getCanonicalFile();
                        // Never delete per host context.xml defaults
                        if (Constants.HostContextXml.equals(
                                current.getName())) {
                            continue;
                        }
                        // Only delete resources in the appBase or the host's
                        // configBase
                        if ((current.getAbsolutePath().startsWith(
                                host.getAppBaseFile().getAbsolutePath() + File.separator))
                            || ((current.getAbsolutePath().startsWith(
                                    host.getConfigBaseFile().getAbsolutePath())
                                 && (current.getAbsolutePath().endsWith(".xml"))))) {
                            if (log.isDebugEnabled())
                                log.debug("Delete " + current);
                            ExpandWar.delete(current);
                        }
                    } catch (IOException e) {
                        log.warn(sm.getString
                                ("hostConfig.canonicalizing", app.name), e);
                    }
                }
                deployed.remove(app.name);
======= fetch "protected synchronized void checkResources(DeployedApplication app) {" 97cefcc^:"java/org/apache/catalina/startup/HostConfig.java"

    private void deleteRedeployResources(DeployedApplication app,
            String[] resources, int i, boolean deleteReloadResources) {
        // Delete redeploy resources
        if (log.isInfoEnabled())
            log.info(sm.getString("hostConfig.undeploy", app.name));
        Container context = host.findChild(app.name);
        try {
            host.removeChild(context);
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            log.warn(sm.getString
                     ("hostConfig.context.remove", app.name), t);
        }
        // Delete other redeploy resources
        for (int j = i + 1; j < resources.length; j++) {
            try {
                File current = new File(resources[j]);
                current = current.getCanonicalFile();
                // Never delete per host context.xml defaults
                if (Constants.HostContextXml.equals(
                        current.getName())) {
                    continue;
                }
                // Only delete resources in the appBase or the
                // host's configBase
                if ((current.getAbsolutePath().startsWith(
                        host.getAppBaseFile().getAbsolutePath() +
                        File.separator))
                        || (current.getAbsolutePath().startsWith(
                                host.getConfigBaseFile().getAbsolutePath()))) {
                    if (log.isDebugEnabled())
                        log.debug("Delete " + current);
                    ExpandWar.delete(current);
                }
            } catch (IOException e) {
                log.warn(sm.getString
                        ("hostConfig.canonicalizing", app.name), e);
            }
        }
        // Delete reload resources (to remove any remaining .xml descriptor)
        if (deleteReloadResources) {
            String[] resources2 =
                    app.reloadResources.keySet().toArray(new String[0]);
            for (int j = 0; j < resources2.length; j++) {
                try {
                    File current = new File(resources2[j]);
                    current = current.getCanonicalFile();
                    // Never delete per host context.xml defaults
                    if (Constants.HostContextXml.equals(
                            current.getName())) {
                        continue;
                    }
                    // Only delete resources in the appBase or the host's
                    // configBase
                    if ((current.getAbsolutePath().startsWith(
                            host.getAppBaseFile().getAbsolutePath() + File.separator))
                        || ((current.getAbsolutePath().startsWith(
                                host.getConfigBaseFile().getAbsolutePath())
                             && (current.getAbsolutePath().endsWith(".xml"))))) {
                        if (log.isDebugEnabled())
                            log.debug("Delete " + current);
                        ExpandWar.delete(current);
                    }
                } catch (IOException e) {
                    log.warn(sm.getString
                            ("hostConfig.canonicalizing", app.name), e);
                }
            }
        }
        deployed.remove(app.name);
    }
======= fetch "protected void check() {" 97cefcc^:"java/org/apache/catalina/startup/HostConfig.java"

            // Check for old versions of applications that can now be undeployed
            if (host.getUndeployOldVersions()) {
                checkUndeploy();
            }
======= fetch "protected void check() {" 97cefcc^:"java/org/apache/catalina/startup/HostConfig.java"

======= fetch "public void check(String name) {" 97cefcc^:"java/org/apache/catalina/startup/HostConfig.java"

     * Check for old versions of applications using parallel deployment that are
     * now unused (have no active sessions) and undeploy any that are found.
     */
    public void checkUndeploy() {
        // Need ordered set of names
        SortedSet<String> sortedAppNames = new TreeSet<>();
        sortedAppNames.addAll(deployed.keySet());
        if (sortedAppNames.size() < 2) {
            return;
        }
        Iterator<String> iter = sortedAppNames.iterator();
        ContextName previous = new ContextName(iter.next());
        do {
            ContextName current = new ContextName(iter.next());
            if (current.getPath().equals(previous.getPath())) {
                // Current and previous are same version - current will always
                // be a later version
                Context context = (Context) host.findChild(previous.getName());
                if (context != null) {
                    Manager manager = context.getManager();
                    if (manager != null && manager.getActiveSessions() == 0) {
                        if (log.isInfoEnabled()) {
                            log.info(sm.getString("hostConfig.undeployVersion",
                                    previous.getName()));
                        }
                        DeployedApplication app =
                                deployed.get(previous.getName());
                        String[] resources =
                                app.redeployResources.keySet().toArray(
                                        new String[0]);
                        // Version is unused - undeploy it completely
                        // The -1 is a 'trick' to ensure all redeploy resources
                        // are removed
                        deleteRedeployResources(app, resources, -1,
                                true);
                    }
                }
            }
            previous = current;
        } while (iter.hasNext());
    }
    /**
    <operation name="checkUndeploy"
               description="Undeploy any old versions of applications deployed using parallel deployment that have no active sessions"
               impact="ACTION"
               returnType="void">
    </operation>
  <p>The <a href="host.html">Host</a> may be configured (via the
  <code>undeployOldVersions</code>) to remove old versions deployed in this way
  once they are no longer in use.</p>
      <attribute name="undeployOldVersions" required="false">
        <p>This flag determines if Tomcat, as part of the auto deployment
        process, will check for old, unused versions of web applications
        deployed using parallel deployment and, if any are found, remove them.
        This flag only applies if <code>autoDeploy</code> is true. If not
        specified the default value of false will be used.</p>
      </attribute>

======= fetch "int nextChar() throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

     * A faster approach than calling {@link #mark()} & {@link #nextChar()}.
     * However, this approach is only safe if the mark is only used within the
     * JspReader.
     */
    private int nextChar(Mark mark) throws JasperException {
        if (!hasMoreInput()) {
            return -1;
        }
        int ch = current.stream[current.cursor];
        mark.init(current, singleFile);
        current.cursor++;
        if (ch == '\n') {
            current.line++;
            current.col = 0;
        } else {
            current.col++;
        }
        return ch;
    }
    /**
     * Search the given character, If it was found, then mark the current cursor
     * and the cursor point to next character.
     */
    private Boolean indexOf(char c, Mark mark) throws JasperException {
        if (!hasMoreInput())
            return null;
        int end = current.stream.length;
        int ch;
        int line = current.line;
        int col = current.col;
        int i = current.cursor;
        for(; i < end; i ++) {
           ch = current.stream[i];
           if (ch == c) {
               mark.update(i, line, col);
           }
           if (ch == '\n') {
                line++;
                col = 0;
            } else {
                col++;
            }
           if (ch == c) {
               current.update(i+1, line, col);
               return Boolean.TRUE;
           }
        }
        current.update(i, line, col);
        return Boolean.FALSE;
    }
    /**
======= fetch "String getText(Mark start, Mark stop) throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

        while (!stop.equals(mark()))
======= fetch "String getText(Mark start, Mark stop) throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

        }
======= fetch "String getText(Mark start, Mark stop) throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

        reset(oldstart);
======= fetch "Mark mark() {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

    /**
     * This method avoids a call to {@link #mark()} when doing comparison.
     */
    private boolean markEquals(Mark another) {
       return another.equals(current);
    }
======= fetch "void reset(Mark mark) {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

     * Similar to {@link #reset(Mark)} but no new Mark will be created.
     * Therefore, the parameter mark must NOT be used in other places.
     */
    private void setCurrent(Mark mark) {
       current = mark;
    }
    /**
======= fetch "boolean matches(String string) throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

        Mark mark = mark();
        int ch = 0;
        int i = 0;
        do {
            ch = nextChar();
            if (((char) ch) != string.charAt(i++)) {
                reset(mark);
                return false;
            }
        } while (i < string.length());
        return true;
======= fetch "boolean matchesETag(String tagName) throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

        reset(mark);
======= fetch "boolean matchesETagWithoutLessThan(String tagName)" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

       reset(mark);
======= fetch "boolean matchesOptionalSpacesFollowedBy( String s )" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

            reset( mark );
======= fetch "Mark skipUntil(String limit) throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

        Mark ret = null;
======= fetch "Mark skipUntil(String limit) throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

        int ch;
======= fetch "Mark skipUntil(String limit) throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

        for (ret = mark(), ch = nextChar() ; ch != -1 ;
                 ret = mark(), ch = nextChar()) {
            if (ch == limit.charAt(0)) {
                Mark restart = mark();
                for (int i = 1 ; i < limlen ; i++) {
                    if (peekChar() == limit.charAt(i))
                        nextChar();
                    else {
                        reset(restart);
                        continue skip;
                    }
                }
                return ret;
======= fetch "Mark skipUntilIgnoreEsc(String limit) throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

        Mark ret = null;
======= fetch "Mark skipUntilIgnoreEsc(String limit) throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

        char firstChar = limit.charAt(0);
======= fetch "Mark skipUntilIgnoreEsc(String limit) throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

        for (ret = mark(), ch = nextChar() ; ch != -1 ;
                 ret = mark(), prev = ch, ch = nextChar()) {
======= fetch "Mark skipUntilIgnoreEsc(String limit) throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

            }
            else if (ch == limit.charAt(0) && prev != '\\') {
======= fetch "private boolean isDelimiter() throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

                    reset(mark);
======= fetch "private boolean isDelimiter() throws JasperException {" 5fccf68^:"java/org/apache/jasper/compiler/JspReader.java"

                    reset(mark);
        this.reader = other.reader;
        this.ctxt = other.reader.getJspCompilationContext();
        this.stream = other.stream;
        this.fileId = other.fileId;
        this.fileName = other.fileName;
        this.baseDir = other.baseDir;
        this.encoding = other.encoding;
        // clone includeStack without cloning contents
        includeStack = new Stack<>();
        for ( int i=0; i < other.includeStack.size(); i++ ) {
            includeStack.addElement( other.includeStack.elementAt(i) );

======= fetch "private void closeOutboundConnection(WsFrame frame) throws IOException {" a81d941^:"java/org/apache/catalina/websocket/StreamInbound.java"

            doOnClose(Constants.OPCODE_CLOSE);

======= fetch "public void backgroundProcess() {" 95d7a0f^:"java/org/apache/catalina/realm/RealmBase.java"

                    found = true;
======= fetch "public void backgroundProcess() {" 95d7a0f^:"java/org/apache/catalina/realm/RealmBase.java"

                        found = false;
======= fetch "public void backgroundProcess() {" 95d7a0f^:"java/org/apache/catalina/realm/RealmBase.java"

                        found = true;
======= fetch "public void backgroundProcess() {" 95d7a0f^:"java/org/apache/catalina/realm/RealmBase.java"

        if(results == null) {

======= fetch "protected File file(String name) {" 44eabba^:"java/org/apache/naming/resources/FileDirContext.java"

                tempContext.setDocBase(file.getPath());

======= fetch "protected void list(HttpServletRequest request," fcc3d65^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args[0] = "<a href=\"" + URL_ENCODER.encode(displayPath)

======= fetch "protected boolean parseChunkHeader()" cd05aa1^:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

                if (HexUtils.getDec(buf[pos]) != -1) {
======= fetch "protected boolean parseChunkHeader()" cd05aa1^:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

                    result += HexUtils.getDec(buf[pos]);
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
======= fetch "public static int getDec(int index){" cd05aa1^:"java/org/apache/tomcat/util/buf/HexUtils.java"

        return DEC[index];

======= fetch "protected void processResourceJARs(Set<WebXml> fragments) {" 6b934d8^:"java/org/apache/catalina/startup/ContextConfig.java"

                    if (jar.entryExists("META-INF/resources/")) {
                        context.addResourceJarUrl(url);

======= fetch "public void addMappingForServletNames(" 8f169e4^:"java/org/apache/catalina/core/ApplicationFilterRegistration.java"

                context.addFilterMapBefore(filterMap);
            } else {
======= fetch "public void addMappingForServletNames(" 8f169e4^:"java/org/apache/catalina/core/ApplicationFilterRegistration.java"

            } else {
                context.addFilterMapBefore(filterMap);
======= fetch "public void addMappingForUrlPatterns(" 8f169e4^:"java/org/apache/catalina/core/ApplicationFilterRegistration.java"

                context.addFilterMapBefore(filterMap);
            } else {
======= fetch "public void addMappingForUrlPatterns(" 8f169e4^:"java/org/apache/catalina/core/ApplicationFilterRegistration.java"

            } else {
                context.addFilterMapBefore(filterMap);

======= fetch "protected void deflate() throws IOException {" 3dff241^:"java/org/apache/coyote/http11/filters/FlushableGZIPOutputStream.java"

        } while (len != 0);
======= fetch "protected void deflate() throws IOException {" 3dff241^:"java/org/apache/coyote/http11/filters/FlushableGZIPOutputStream.java"


    public static final String DEFAULT_JARS_TO_SKIP =
            "tomcat.util.scan.DefaultJarScanner.jarsToSkip";
    public static final String PLUGGABILITY_JARS_TO_SKIP =
            "org.apache.catalina.startup.ContextConfig.jarsToSkip";
    public static final String TLD_JARS_TO_SKIP =
            "org.apache.catalina.startup.TldConfig.jarsToSkip";
    /**
     * The list of JARs that will be skipped when scanning a web application
     * for JARs. This means the JAR will not be scanned for web fragments, SCIs,
     * annotations or classes that match @HandlesTypes.
     */
    private static final Set<String> pluggabilityJarsToSkip = new HashSet<>();
        // Load the list of JARS to skip
        addJarsToSkip(Constants.DEFAULT_JARS_TO_SKIP);
        addJarsToSkip(Constants.PLUGGABILITY_JARS_TO_SKIP);
    private static void addJarsToSkip(String systemPropertyName) {
        String jarList = System.getProperty(systemPropertyName);
        if (jarList != null) {
            StringTokenizer tokenizer = new StringTokenizer(jarList, ",");
            while (tokenizer.hasMoreElements()) {
                pluggabilityJarsToSkip.add(tokenizer.nextToken());
            }
        }
    }
======= fetch "protected void parseWebXml(InputSource source, WebXml dest," 15e8d8e^:"java/org/apache/catalina/startup/ContextConfig.java"

                context.getLoader().getClassLoader(), callback, null);
======= fetch "private static Digester createTldDigester(boolean namespaceAware," 15e8d8e^:"java/org/apache/catalina/startup/TldConfig.java"

    static {
        // Set the default list of JARs to skip for TLDs
        StringBuilder jarList = new StringBuilder(System.getProperty(
                Constants.DEFAULT_JARS_TO_SKIP, ""));
        String tldJars = System.getProperty(Constants.TLD_JARS_TO_SKIP, "");
        if (tldJars.length() > 0) {
            if (jarList.length() > 0) {
                jarList.append(',');
            }
            jarList.append(tldJars);
        }
        if (jarList.length() > 0) {
            setNoTldJars(jarList.toString());
        }
    }
    /**
     * Sets the list of JARs that are known not to contain any TLDs.
     *
     * @param jarNames List of comma-separated names of JAR files that are
     * known not to contain any TLDs.
     */
    public static synchronized void setNoTldJars(String jarNames) {
        if (jarNames == null) {
            noTldJars = null;
        } else {
            if (noTldJars == null) {
                noTldJars = new HashSet<>();
            } else {
                noTldJars.clear();
            }
            StringTokenizer tokenizer = new StringTokenizer(jarNames, ",");
            while (tokenizer.hasMoreElements()) {
                noTldJars.add(tokenizer.nextToken());
            }
        }
    }
======= fetch "public boolean isKnownWebxmlTaglibUri(String uri) {" 15e8d8e^:"java/org/apache/catalina/startup/TldConfig.java"

    /**
     * Sets the list of JARs that are known not to contain any TLDs.
     *
     * @param jarNames List of comma-separated names of JAR files that are
     * known not to contain any TLDs.
     */
    public static void setNoTldJars(String jarNames) {
        if (jarNames == null) {
            noTldJars = null;
        } else {
            if (noTldJars == null) {
                noTldJars = new HashSet<>();
            } else {
                noTldJars.clear();
            }
            StringTokenizer tokenizer = new StringTokenizer(jarNames, ",");
            while (tokenizer.hasMoreElements()) {
                noTldJars.add(tokenizer.nextToken());
            }
        }
    }
    /**
     * The mapping of the 'global' tag library URI to the location (resource
     * path) of the TLD associated with that tag library. The location is
     * returned as a String array:
     *    [0] The location
     *    [1] If the location is a jar file, this is the location of the tld.
     */
    private Hashtable<String, TldLocation> mappings;
    private volatile boolean initialized;
    private ServletContext ctxt;
    /** Constructor.
     *
     * @param ctxt the servlet context of the web application in which Jasper
     * is running
     */
    public TldLocationsCache(ServletContext ctxt) {
        this.ctxt = ctxt;
        mappings = new Hashtable<String, TldLocation>();
        initialized = false;
======= fetch "public TldLocationsCache(ServletContext ctxt) {" 15e8d8e^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

    public static void setNoTldJars(String jarNames) {
======= fetch "public static void setNoTldJars(String jarNames) {" 15e8d8e^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

                noTldJars = new HashSet<String>();
======= fetch "public static void setNoTldJars(String jarNames) {" 15e8d8e^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

     * The mapping of the 'global' tag library URI to the location (resource
     * path) of the TLD associated with that tag library. The location is
     * returned as a String array:
     *    [0] The location
     *    [1] If the location is a jar file, this is the location of the tld.
     */
    private Hashtable<String, TldLocation> mappings;
    private volatile boolean initialized;
    private ServletContext ctxt;
    /** Constructor.
     *
     * @param ctxt the servlet context of the web application in which Jasper
     * is running
     */
    public TldLocationsCache(ServletContext ctxt) {
        this.ctxt = ctxt;
        mappings = new Hashtable<String, TldLocation>();
        initialized = false;
    }
    /**
    <property name="tomcat.util.scan. DefaultJarScanner.jarsToSkip">
      <p>The comma-separated list of filenames of JARs that Tomcat will not scan
         for configuration information when using the
         <a href="jar-scanner.html">JarScanner</a> functionality. Note that
         there are additional system properties that enable JARs to be excluded
         from specific scans rather than all scans.</p>
      <p>The coded default is that no JARs are skipped however the system
         property is set in a default Tomcat installation via the
         <code>$CATALINA_BASE/catalina.properties</code> file.</p>
    </property>
    <property name="org.apache.catalina.startup. ContextConfig.jarsToSkip">
      <p>The comma-separated list of additional filenames of JARs that Tomcat
         will not scan for Servlet 3.0 pluggability features.</p>
      <p>The coded default is that no JARs are skipped however the system
         property is set in a default Tomcat installation via the
         <code>$CATALINA_BASE/catalina.properties</code> file.</p>
    </property>
    <property name="org.apache.catalina.startup. TldConfig.jarsToSkip">
      <p>The comma-separated list of additional filenames of JARs that Tomcat
         will not scan for TLDs.</p>
      <p>The coded default is that no JARs are skipped however the system
         property is set in a default Tomcat installation via the
         <code>$CATALINA_BASE/catalina.properties</code> file.</p>
    </property>

======= fetch "public final void recycle(boolean isSocketClosing) {" 6c13431^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        comet = false;
======= fetch "public void recycleInternal() {" 6c13431^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

        comet = false;

======= fetch "public String getTrimDirectiveWhitespaces() {" e38a097^:"java/org/apache/catalina/core/ApplicationJspPropertyGroupDescriptor.java"

        Collection<String> result = new HashSet<>();
        if (jspPropertyGroup.getUrlPattern() != null) {
            result.add(jspPropertyGroup.getUrlPattern());
        }
        return result;
======= fetch "public String getTrimDirectiveWhitespaces() {" e38a097^:"java/org/apache/catalina/core/ApplicationJspPropertyGroupDescriptor.java"

======= fetch "public void setTrimWhitespace(String trimWhitespace) {" e38a097^:"java/org/apache/catalina/deploy/JspPropertyGroup.java"

    private String urlPattern = null;
    public void setUrlPattern(String urlPattern) {
        this.urlPattern = urlPattern;
======= fetch "public void setUrlPattern(String urlPattern) {" e38a097^:"java/org/apache/catalina/deploy/JspPropertyGroup.java"

    public String getUrlPattern() { return this.urlPattern; }
======= fetch "public String toXml() {" e38a097^:"java/org/apache/catalina/deploy/WebXml.java"

                appendElement(sb, INDENT6, "url-pattern", jpg.getUrlPattern());
======= fetch "public void configureContext(Context context) {" e38a097^:"java/org/apache/catalina/deploy/WebXml.java"

                context.addServletMapping(jspPropertyGroup.getUrlPattern(),
                        jspServletName, true);
======= fetch "public void configureContext(Context context) {" e38a097^:"java/org/apache/catalina/deploy/WebXml.java"

                if(log.isDebugEnabled())
                    log.debug("Skiping " + jspPropertyGroup.getUrlPattern() +
                            " , no servlet " + jspServletName);
======= fetch "public void addRuleInstances(Digester digester) {" e38a097^:"java/org/apache/catalina/startup/WebRuleSet.java"

                               "setUrlPattern", 0);

======= fetch "public boolean isOutDated(boolean checkClass) {" 1efc23d^:"java/org/apache/jasper/compiler/Compiler.java"

                if (key.startsWith("jar:")) {

======= fetch "private void doDispatch(ServletRequest request, ServletResponse response)" e37b01e^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        State state = new State(request, response, true);
======= fetch "private void doDispatch(ServletRequest request, ServletResponse response)" e37b01e^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        String contextPath = context.getPath();
        if (requestURI != null)
            wrequest.setAttribute(RequestDispatcher.INCLUDE_REQUEST_URI,
                                  requestURI);
        if (contextPath != null)
            wrequest.setAttribute(RequestDispatcher.INCLUDE_CONTEXT_PATH,
                                  contextPath);
        if (servletPath != null)
            wrequest.setAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH,
                                  servletPath);
        if (pathInfo != null)
            wrequest.setAttribute(RequestDispatcher.INCLUDE_PATH_INFO,
                                  pathInfo);
======= fetch "private void doDispatch(ServletRequest request, ServletResponse response)" e37b01e^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

            wrequest.setAttribute(RequestDispatcher.INCLUDE_QUERY_STRING,
                                  queryString);
======= fetch "private void doDispatch(ServletRequest request, ServletResponse response)" e37b01e^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        wrequest.setContextPath(contextPath);

======= fetch "public int readLine(byte[] b, int off, int len) throws IOException {" 2a3b42d^:"java/javax/servlet/ServletInputStream.java"

     * @return
======= fetch "public void println(double d) throws IOException {" 2a3b42d^:"java/javax/servlet/ServletOutputStream.java"

     * @return
======= fetch "public JspException(String msg) {" 2a3b42d^:"java/javax/servlet/jsp/JspException.java"

     * @see <code>java.lang.Exception.Exception(String, Throwable)</code>
======= fetch "public JspException(String message, Throwable cause) {" 2a3b42d^:"java/javax/servlet/jsp/JspException.java"

     * @see <code>java.lang.Exception.Exception(Throwable)</code>
     * @throws org.apache.catalina.util.RejectedExecutionException if this task
     * @deprecated Use {@link #setContext()}. This method will be removed in
     * @param container The newly associated Context
     * @see Channel#send(Member[], Serializable, int, ErrorHandler)
     * @see Channel#send(Member[], Serializable, int, ErrorHandler)
======= fetch "public Object lookup(String name)" 2a3b42d^:"java/org/apache/naming/SelectorContext.java"

     * @exception javax.naming.InvalidAttributesException if object did not
======= fetch "public void bind(Name name, Object obj)" 2a3b42d^:"java/org/apache/naming/SelectorContext.java"

     * @exception javax.naming.InvalidAttributesException if object did not
======= fetch "public void bind(String name, Object obj)" 2a3b42d^:"java/org/apache/naming/SelectorContext.java"

     * @exception javax.naming.InvalidAttributesException if object did not
======= fetch "public void rebind(Name name, Object obj)" 2a3b42d^:"java/org/apache/naming/SelectorContext.java"

     * @exception javax.naming.InvalidAttributesException if object did not
======= fetch "public void destroySubcontext(String name)" 2a3b42d^:"java/org/apache/naming/SelectorContext.java"

     * @exception javax.naming.InvalidAttributesException if creation of the
======= fetch "public Context createSubcontext(Name name)" 2a3b42d^:"java/org/apache/naming/SelectorContext.java"

     * @exception javax.naming.InvalidAttributesException if creation of the
 * #parseRequest(javax.servlet.http.HttpServletRequest)}), you may
     * @param response The associated response
     * @param response
     * @param originalOutput

======= fetch "public void sendAck() throws IOException {" a2ca744^:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

    int total = 0;
======= fetch "private synchronized int writeToSocket(ByteBuffer bytebuffer, boolean block, boo" a2ca744^:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

        total+= written;
        //System.out.println("Successful write("+written+ " / "+total);

======= fetch "protected void webConfig() {" f9b0182^:"java/org/apache/catalina/startup/ContextConfig.java"

            convertJsps(webXml);
======= fetch "public void testBug51396() throws Exception {" f9b0182^:"test/org/apache/catalina/startup/TestContextConfig.java"

    @Test
    public void testBug53574() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug53574", res, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        String body = res.toString();
        Assert.assertTrue(body.contains("OK"));
    }
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <body>
    <p>OK</p>
  </body>
  <servlet>
    <servlet-name>Bug53574</servlet-name>
    <jsp-file>/WEB-INF/jsp/bug53574.jsp</jsp-file>
  </servlet>
  <servlet-mapping>
    <servlet-name>Bug53574</servlet-name>
    <url-pattern>/bug53574</url-pattern>
  </servlet-mapping>

======= fetch "private void doForward(String relativeUrlPath) throws ServletException," 5a6b27b^:"java/org/apache/jasper/runtime/PageContextImpl.java"

            baseOut.clear();
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testDoForward() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug53545.jsp", res, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        String body = res.toString();
        Assert.assertTrue(body.contains("OK"));
        Assert.assertFalse(body.contains("FAIL"));
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    private static final long serialVersionUID = 1L;
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"
    version="2.0">
    <tlib-version>1.0</tlib-version>
    <short-name>bug53545</short-name>
    <tag>
      <name>test</name>
      <tag-class>org.apache.tomcat.unittest.tags.Bug53545</tag-class>
      <body-content>scriptless</body-content>
    </tag>
  <body>
    <p>OK</p>
  </body>
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
         pageEncoding="ISO-8859-1"%>
  <body>
    <p>FAIL</p>
    <bug53545:test>
      <p>FAIL</p>
      <bug53545:test>
        <p>FAIL</p>
        <jsp:forward page="bug53545.html"/>
        <p>FAIL</p>
      </bug53545:test>
      <p>FAIL</p>
    </bug53545:test>
    <p>FAIL</p>
  </body>

======= fetch "protected Object doLookup(String name) {" 432bd0f^:"java/org/apache/naming/resources/VirtualDirContext.java"

    @Override
    protected String doGetRealPath(String path) {
        File file = file(path);
        if (null != file) {
            return file.getAbsolutePath();
        } else {
            return null;
        }
    }

======= fetch "public Http11AprProtocol() {" 82e5dce^:"java/org/apache/coyote/http11/Http11AprProtocol.java"

     * SSL honor cipher order.
     * Set to <code>true</code> to enforce the <i>server's</i> cipher order
     * instead of the default which is to allow the client to choose a
     * preferred cipher.
     */
    public boolean getSSLHonorCipherOrder() { return ((AprEndpoint)endpoint).getSSLHonorCipherOrder(); }
    public void setSSLHonorCipherOrder(boolean SSLHonorCipherOrder) { ((AprEndpoint)endpoint).setSSLHonorCipherOrder(SSLHonorCipherOrder); }
    /**
======= fetch "public Sendfile getSendfile() {" 82e5dce^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    protected boolean SSLHonorCipherOrder = false;
    /**
     * Set to <code>true</code> to enforce the <i>server's</i> cipher order
     * instead of the default which is to allow the client to choose a
     * preferred cipher.
     */
    public void setSSLHonorCipherOrder(boolean SSLHonorCipherOrder) { this.SSLHonorCipherOrder = SSLHonorCipherOrder; }
    public boolean getSSLHonorCipherOrder() { return SSLHonorCipherOrder; }
======= fetch "public void bind() throws Exception {" 82e5dce^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            // Set cipher order: client (default) or server
            if (SSLHonorCipherOrder) {
                boolean orderCiphersSupported = false;
                try {
                    orderCiphersSupported = SSL.hasOp(SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
                    if (orderCiphersSupported)
                        SSLContext.setOptions(sslContext, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
                } catch (UnsatisfiedLinkError e) {
                    // Ignore
                }
                if (!orderCiphersSupported) {
                    // OpenSSL does not support ciphers ordering.
                    log.warn(sm.getString("endpoint.warn.noHonorCipherOrder",
                                          SSL.versionString()));
                }
            }
    <attribute name="SSLHonorCipherOrder" required="false">
      <p>Set to <code>true</code> to enforce the server's cipher order
      (from the <code>SSLCipherSuite</code> setting) instead of allowing
      the client to choose the cipher (which is the default).</p>
    </attribute>

======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" af45441^:"java/org/apache/catalina/websocket/WebSocketServlet.java"

                "Sec-WebSocket-Protocol-Client");

======= fetch "protected void sendPingMessage(Member[] members) {" 57b56f2^:"java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java"

        data.setMessage(new XByteBuffer(TCP_PING_DATA, false));

======= fetch "protected void sendPing() {" eb9f94e^:"java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java"

        if (failureDetector.get() != null) {
======= fetch "protected void sendPing() {" eb9f94e^:"java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java"

            failureDetector.get().checkMembers(true);
======= fetch "protected void sendPing() {" eb9f94e^:"java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java"

            StaticMembershipInterceptor smi = staticMembers.get();
            if (staticOnly && smi != null) {

======= fetch "private void populateSCIsForCacheEntry(JavaClassCacheEntry cacheEntry) {" 7db08d3^:"java/org/apache/catalina/startup/ContextConfig.java"

        JavaClass javaClass = cacheEntry.getJavaClass();
======= fetch "private void populateSCIsForCacheEntry(JavaClassCacheEntry cacheEntry) {" 7db08d3^:"java/org/apache/catalina/startup/ContextConfig.java"

        String superClassName = javaClass.getSuperclassName();
======= fetch "private void populateSCIsForCacheEntry(JavaClassCacheEntry cacheEntry) {" 7db08d3^:"java/org/apache/catalina/startup/ContextConfig.java"

        for (String interfaceName : javaClass.getInterfaceNames()) {
======= fetch "public long getHostTimeStamp() {" 7db08d3^:"java/org/apache/catalina/startup/ContextConfig.java"

        private final JavaClass javaClass;
======= fetch "public JavaClassCacheEntry(JavaClass javaClass) {" 7db08d3^:"java/org/apache/catalina/startup/ContextConfig.java"

            this.javaClass = javaClass;
======= fetch "public JavaClassCacheEntry(JavaClass javaClass) {" 7db08d3^:"java/org/apache/catalina/startup/ContextConfig.java"

        public JavaClass getJavaClass() {
            return javaClass;

======= fetch "public String encodeURL(String url) {" 9a80d06^:"java/org/apache/catalina/connector/Response.java"

        String absolute = toAbsolute(url);
======= fetch "private void normalize(CharChunk cc) {" 9a80d06^:"java/org/apache/catalina/connector/Response.java"

            // Prevent from going outside our context
======= fetch "private void normalize(CharChunk cc) {" 9a80d06^:"java/org/apache/catalina/connector/Response.java"

        // Add the query string (if present) back in
======= fetch "public void testBug53062p() throws Exception {" 9a80d06^:"test/org/apache/catalina/connector/TestResponse.java"

    @Test
    public void testBug53469a() throws Exception {
        Request req = new TesterMockRequest();
        Response resp = new Response();
        resp.setRequest(req);
        String result = resp.encodeURL("../bar.html");
        Assert.assertEquals("../bar.html", result);
    }
    @Test
    public void testBug53469b() throws Exception {
        Request req = new TesterMockRequest();
        Response resp = new Response();
        resp.setRequest(req);
        String result = resp.encodeURL("../../../../bar.html");
        Assert.assertEquals("../../../../bar.html", result);
    }

======= fetch "public void run() {" 3ea8285^:"java/org/apache/catalina/tribes/group/GroupChannel.java"

                    interrupted();
======= fetch "public void startElection(boolean force) throws ChannelException {" 3ea8285^:"java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java"

                }catch ( InterruptedException x ) {
                    Thread.interrupted();
======= fetch "public void startElection(boolean force) throws ChannelException {" 3ea8285^:"java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java"

                if ( suggestedviewId == null && (!coordMsgReceived.get())) {
                    //no message arrived, send the coord msg
                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, waiting timed out."));
======= fetch "public void startElection(boolean force) throws ChannelException {" 3ea8285^:"java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java"

                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, received a message"));
======= fetch "public void startElection(boolean force) throws ChannelException {" 3ea8285^:"java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java"

            }//end if
======= fetch "public void run() {" 3ea8285^:"java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java"

                    interrupted();
======= fetch "public void run() {" 3ea8285^:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

                    if (x instanceof InterruptedException) interrupted();
                    else {
                        if (errorCounter==0 && doRunReceiver) log.warn("Error receiving mcast package. Sleeping 500ms",x);
                        else if (log.isDebugEnabled()) log.debug("Error receiving mcast package"+(doRunReceiver?". Sleeping 500ms":"."),x);
                        if (doRunReceiver) {
                            try { Thread.sleep(500); } catch ( Exception ignore ){}
                            if ( (++errorCounter)>=recoveryCounter ) {
                                errorCounter=0;
                                RecoveryThread.recover(McastServiceImpl.this);
                            }
======= fetch "public void publish(LogRecord record) {" 3ea8285^:"java/org/apache/juli/AsyncFileHandler.java"

            //allow thread to be interrupted and back out of the publish operation
            //after this we clear the flag
            Thread.interrupted();
======= fetch "public void run() {" 3ea8285^:"java/org/apache/juli/AsyncFileHandler.java"

                }catch (InterruptedException x) {
                    Thread.interrupted();
                }catch (Exception x) {
======= fetch "public void run() {" 3ea8285^:"java/org/apache/juli/AsyncFileHandler.java"

            }//while
======= fetch "public void stopInternal() {" 3ea8285^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                        // Ignore and clean the interrupt flag
                        Thread.interrupted();
======= fetch "public int write(ByteBuffer buf, NioChannel socket, long writeTimeout)" 3ea8285^:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"

                }catch (InterruptedException ignore) {
                    Thread.interrupted();
======= fetch "public int read(ByteBuffer buf, NioChannel socket, long readTimeout) throws IOEx" 3ea8285^:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"

                }catch (InterruptedException ignore) {
                    Thread.interrupted();
======= fetch "public void execute(Runnable command, long timeout, TimeUnit unit) {" 3ea8285^:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

                    Thread.interrupted();

======= fetch "protected boolean terminateTransaction(PooledConnection con) {" eac6366^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            if (con.getPoolProperties().getDefaultAutoCommit()==Boolean.FALSE) {

     * This parameter is only looked at if the {@link java.sql.Connection#getAutoCommit()} returns false
     * This parameter is only looked at if the {@link java.sql.Connection#getAutoCommit()} returns false

======= fetch "public void send(ClusterMessage msg, Member dest) {" 4c03dff^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

            int sendOptions = channelSendOptions;
            if (msg instanceof SessionMessage
                    && ((SessionMessage)msg).getEventType() == SessionMessage.EVT_ALL_SESSION_DATA) {
                sendOptions = Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK;
            }
======= fetch "public void send(ClusterMessage msg, Member dest) {" 4c03dff^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

                    channel.send(new Member[] {dest}, msg,channelSendOptions);
======= fetch "public void send(ClusterMessage msg, Member dest) {" 4c03dff^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

                    channel.send(destmembers,msg,channelSendOptions);

======= fetch "public ApplicationContext(StandardContext context) {" 4aef8e3^:"java/org/apache/catalina/core/ApplicationContext.java"

    private Map<String,String> parameters =
======= fetch "public void removeAttribute(String name) {" 4aef8e3^:"java/org/apache/catalina/core/ApplicationContext.java"

        boolean found = false;
======= fetch "public void removeAttribute(String name) {" 4aef8e3^:"java/org/apache/catalina/core/ApplicationContext.java"

        if (readOnlyAttributes.containsKey(name))
======= fetch "public void removeAttribute(String name) {" 4aef8e3^:"java/org/apache/catalina/core/ApplicationContext.java"

        found = attributes.containsKey(name);
        if (found) {
            value = attributes.get(name);
            attributes.remove(name);
        } else {
======= fetch "public boolean setInitParameter(String name, String value) {" 4aef8e3^:"java/org/apache/catalina/core/ApplicationContext.java"

        if (parameters.containsKey(name)) {
            return false;
        }
        parameters.put(name, value);
        return true;
======= fetch "public Object getAttribute(String name) {" 4aef8e3^:"java/org/apache/catalina/ha/context/ReplicatedContext.java"

            if (tomcatAttributes.containsKey(name) )
                return tomcatAttributes.get(name);
            else
======= fetch "public Object getAttribute(String name) {" 4aef8e3^:"java/org/apache/catalina/ha/context/ReplicatedContext.java"

            } else {
                return obj;
            }

  <!-- Note: Extensions are always matched in a case-insensitive manner.    -->
======= fetch "public void addMimeMapping(String extension, String mimeType) {" f8e173b^:"java/org/apache/catalina/core/StandardContext.java"

            mimeMappings.put(extension, mimeType);
======= fetch "public String findMimeMapping(String extension) {" f8e173b^:"java/org/apache/catalina/core/StandardContext.java"

        return (mimeMappings.get(extension));

======= fetch "public StandardContext() {" 6213b38^:"java/org/apache/catalina/core/StandardContext.java"

     * HTTP status code (as an Integer).
======= fetch "private void status(Request request, Response response) {" 6213b38^:"java/org/apache/catalina/core/StandardHostValve.java"

     * The error (status) code for which this error page is active.

======= fetch "public URL getResource(String path)" 4de4325^:"java/org/apache/catalina/core/ApplicationContext.java"

                URI uri = new URI("jndi", getJNDIUri(hostName, fullPath), null);
======= fetch "public void testBug53257() throws Exception {" 4de4325^:"test/org/apache/catalina/core/TestApplicationContext.java"

    @Test
    public void testBug53467() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        // app dir is relative to server home
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug53467].jsp", res, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        Assert.assertTrue(res.toString().contains("<p>OK</p>"));
    }
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <body>
    <p>OK</p>
  </body>

======= fetch "public ObjectName createObjectName(ObjectName original) throws MalformedObjectNa" ff9a272^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java"

        if (original.getKeyProperty("path")!=null) {

======= fetch "protected void configureNamingRules(Digester digester) {" 7ecd402^:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/ejb-local-ref/mapped-name",
                         new MappedNameRule());
======= fetch "protected void configureNamingRules(Digester digester) {" 7ecd402^:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/ejb-ref/mapped-name",
                         new MappedNameRule());
======= fetch "protected void configureNamingRules(Digester digester) {" 7ecd402^:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/env-entry/mapped-name",
                         new MappedNameRule());
======= fetch "protected void configureNamingRules(Digester digester) {" 7ecd402^:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/resource-env-ref/mapped-name",
                         new MappedNameRule());
======= fetch "protected void configureNamingRules(Digester digester) {" 7ecd402^:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/message-destination/mapped-name",
                         new MappedNameRule());
======= fetch "protected void configureNamingRules(Digester digester) {" 7ecd402^:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/message-destination-ref/mapped-name",
                         new MappedNameRule());
======= fetch "protected void configureNamingRules(Digester digester) {" 7ecd402^:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/resource-ref/mapped-name",
                         new MappedNameRule());
======= fetch "protected void configureNamingRules(Digester digester) {" 7ecd402^:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/service-ref/mapped-name",
                         new MappedNameRule());
======= fetch "protected void configureNamingRules(Digester digester) {" 7ecd402^:"java/org/apache/catalina/startup/WebRuleSet.java"

======= fetch "public void begin(String namespace, String name, Attributes attributes)" 7ecd402^:"java/org/apache/catalina/startup/WebRuleSet.java"

 * A Rule that sets mapped name on the ResourceBase.
 */
======= fetch "public void begin(String namespace, String name, Attributes attributes)" 7ecd402^:"java/org/apache/catalina/startup/WebRuleSet.java"

    public MappedNameRule() {
        // NO-OP
    }
======= fetch "public void begin(String namespace, String name, Attributes attributes)" 7ecd402^:"java/org/apache/catalina/startup/WebRuleSet.java"

    /**
     * Process the body text of this element.
     *
     * @param namespace the namespace URI of the matching element, or an
     *   empty string if the parser is not namespace aware or the element has
     *   no namespace
     * @param name the local name if the parser is namespace aware, or just
     *   the element name otherwise
     * @param text The body text of this element
     */
    @Override
    public void body(String namespace, String name, String text)
            throws Exception {
        ResourceBase resourceBase = (ResourceBase) digester.peek();
        resourceBase.setProperty("mappedName", text.trim());
    }
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 7ecd402^:"test/org/apache/naming/resources/TestNamingContext.java"

    @Test
    public void testBug53465() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        tomcat.enableNaming();
        File appDir =
            new File("test/webapp-3.0");
        // app dir is relative to server home
        org.apache.catalina.Context ctxt =
                tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug53465.jsp", bc, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        Assert.assertTrue(bc.toString().contains("<p>10</p>"));
        ContextEnvironment ce =
                ctxt.getNamingResources().findEnvironment("bug53465");
        Assert.assertEquals("Bug53465MappedName", ce.getProperty("mappedName"));
    }
  <env-entry>
    <description>Resource for testing bug 53465</description>
    <env-entry-name>bug53465</env-entry-name>
    <env-entry-value>10</env-entry-value>
    <env-entry-type>java.lang.Integer</env-entry-type>
    <mapped-name>Bug53465MappedName</mapped-name>
  </env-entry>

======= fetch "private void generatePostamble() {" 294c52b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("else log(t.getMessage(), t);");
======= fetch "private PageContext internalGetPageContext(Servlet servlet, ServletRequest reque" 294c52b^:"java/org/apache/jasper/runtime/JspFactoryImpl.java"

            if (ex instanceof RuntimeException) {
                throw (RuntimeException) ex;
            }

    public static final String POOL_JMX_TYPE_PREFIX = "tomcat.jdbc:type=";
======= fetch "public ObjectName createObjectName(ObjectName original) throws MalformedObjectNa" 4e010fc^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java"

        String domain = "tomcat.jdbc";
======= fetch "protected void deregisterJmx() {" 4e010fc^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReportJmx.java"

    public static ObjectName getObjectName(Class<?> clazz, String poolName) throws MalformedObjectNameException {
        ObjectName oname = new ObjectName(ConnectionPool.POOL_JMX_TYPE_PREFIX+clazz.getName()+",name=" + poolName);
======= fetch "public void testSlowSqlJmx() throws Exception {" 4e010fc^:"modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestSlowQueryReport.java"

                SlowQueryReportJmx.getObjectName(SlowQueryReportJmx.class, pool.getName()),

======= fetch "protected void initInternal() throws LifecycleException {" 553259c^:"java/org/apache/catalina/connector/Connector.java"

        if (protocolHandler.isAprRequired() &&
                !AprLifecycleListener.isAprAvailable()) {
            throw new LifecycleException(
                    sm.getString("coyoteConnector.protocolHandlerNoApr",
                            getProtocolHandlerClassName()));
        }
======= fetch "public void setProcessorCache(int processorCache) {" 553259c^:"java/org/apache/coyote/AbstractProtocol.java"

    // ------------------------------------------------------------ Constructor

======= fetch "private Method write(ELContext ctx) {" 8a13b39^:"java/javax/el/BeanELResolver.java"

                                    type.getName(), descriptor.getName() }));
======= fetch "private Method read(ELContext ctx) {" 8a13b39^:"java/javax/el/BeanELResolver.java"

                                    type.getName(), descriptor.getName() }));

======= fetch "public Void run() {" 91a13d2^:"java/org/apache/catalina/core/ContainerBase.java"

     * The container event listeners for this Container.
======= fetch "public Void run() {" 91a13d2^:"java/org/apache/catalina/core/ContainerBase.java"

    protected ArrayList<ContainerListener> listeners =
            new ArrayList<ContainerListener>();
    protected final ReadWriteLock listenersLock = new ReentrantReadWriteLock();
======= fetch "public void addContainerListener(ContainerListener listener) {" 91a13d2^:"java/org/apache/catalina/core/ContainerBase.java"

        Lock write = listenersLock.writeLock();
        write.lock();
        try {
            listeners.add(listener);
        } finally {
            write.unlock();
        }
======= fetch "public Container findChild(String name) {" 91a13d2^:"java/org/apache/catalina/core/ContainerBase.java"

        Lock read = listenersLock.readLock();
        read.lock();
        try {
            ContainerListener[] results =
                new ContainerListener[listeners.size()];
            return listeners.toArray(results);
        } finally {
            read.unlock();
        }
======= fetch "public void removeContainerListener(ContainerListener listener) {" 91a13d2^:"java/org/apache/catalina/core/ContainerBase.java"

        Lock write = listenersLock.writeLock();
        write.lock();
        try {
            listeners.remove(listener);
        } finally {
            write.unlock();
        }
======= fetch "public void fireContainerEvent(String type, Object data) {" 91a13d2^:"java/org/apache/catalina/core/ContainerBase.java"

        /*
         * Implementation note
         * There are two options here.
         * 1) Take a copy of listeners and fire the events outside of the read
         *    lock
         * 2) Don't take a copy and fire the events inside the read lock
         *
         * Approach 2 has been used here since holding the read lock only
         * prevents writes and that is preferable to creating lots of array
         * objects. Since writes occur on start / stop (unless an external
         * management tool is used) then holding the read lock for a relatively
         * long time should not be an issue.
         */
        Lock read = listenersLock.readLock();
        read.lock();
        try {
            if (listeners.size() < 1)
                return;
            ContainerEvent event = new ContainerEvent(this, type, data);
            for (ContainerListener listener : listeners) {
                listener.containerEvent(event);
            }
        } finally {
            read.unlock();

======= fetch "public SocketState event(SocketStatus status)" ce24a10^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        if (error) {
======= fetch "public SocketState event(SocketStatus status)" ce24a10^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

        if (error) {

======= fetch "public boolean validate(Request request, String authorization) {" bf41254^:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

                    return false;
======= fetch "public boolean validate(Request request, String authorization) {" bf41254^:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

                if (nc.length() != 8) {

======= fetch "protected void processServletContainerInitializers(" 37e8c59^:"java/org/apache/catalina/startup/ContextConfig.java"

            HandlesTypes ht =
                sci.getClass().getAnnotation(HandlesTypes.class);

======= fetch "protected static void writeProcessorState(PrintWriter writer," 2bf1556^:"java/org/apache/catalina/manager/StatusTransformer.java"

                writer.write(" requestBytesRecieved=\"0\"");
        is recieved, the next stage will br "Parse and Prepare Requst". If no
        <xs:attribute name="requestBytesRecieved" type="xs:long" use="required"/>

======= fetch "public Void call() throws LifecycleException {" d73c07a^:"java/org/apache/catalina/core/ContainerBase.java"

        private ThreadGroup group;
        private AtomicInteger threadNumber = new AtomicInteger(1);
        private String namePrefix;

        PROP_ALTERNATE_USERNAME_ALLOWED
======= fetch "public static PoolConfiguration parsePoolProperties(Properties properties) {" 0290e57^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        value = properties.getProperty(PROP_COMMITONRETURN);
        if (value != null) {
            poolProperties.setCommitOnReturn(Boolean.parseBoolean(value));
        }
        value = properties.getProperty(PROP_ROLLBACKONRETURN);
        if (value != null) {
            poolProperties.setRollbackOnReturn(Boolean.parseBoolean(value));
        }
        value = properties.getProperty(PROP_USEDISPOSABLECONNECTIONFACADE);
        if (value != null) {
            poolProperties.setUseDisposableConnectionFacade(Boolean.parseBoolean(value));
        }
        value = properties.getProperty(PROP_LOGVALIDATIONERRORS);
        if (value != null) {
            poolProperties.setLogValidationErrors(Boolean.parseBoolean(value));
        }
        value = properties.getProperty(PROP_PROPAGATEINTERRUPTSTATE);
        if (value != null) {
            poolProperties.setPropagateInterruptState(Boolean.parseBoolean(value));
        }

======= fetch "public void setAliases(String theAliases) {" cf703d2^:"java/org/apache/naming/resources/BaseDirContext.java"

            // Skip blanks introduced by regexp split and/or poor input
            kvp = kvp.trim();
            if(0 == kvp.length())
                continue;
======= fetch "public void setAliases(String theAliases) {" cf703d2^:"java/org/apache/naming/resources/BaseDirContext.java"

            if (kv.length != 2 || kv[0].length() == 0 || kv[1].length() == 0)
======= fetch "public void doTestLookup(boolean useSingletonResource) throws Exception {" cf703d2^:"test/org/apache/naming/resources/TestNamingContext.java"

    // Recursively deletes a directory and its contents
    private boolean rmdir(File dir)
    {
        if(!dir.exists()) return false;
        if(!dir.isDirectory()) return false;
        File[] files = dir.listFiles();
        if(null != files) {
            for(int i=0; i<files.length; ++i) {
                if(files[i].isDirectory())
                {
                    if(!rmdir(files[i])) {
                        return false;
                    }
                } else {
                    if(!files[i].delete()) {
                        return false;
                    }
                }
            }
        }
        return dir.delete();
    }
    @Test
    public void testAliases() throws Exception
    {
        // Some sample text
        String foxText = "The quick brown fox jumps over the lazy dog";
        String loremIpsum = "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.";
        // Set up a temporary docBase and some alternates that we can
        // set up as aliases.
        File tmpDir = new File(System.getProperty("java.io.tmpdir"),
                               "tomcat-unit-test." + TestNamingContext.class.getName());
        if(tmpDir.exists())
        {
            // Remove any old test files
            if(tmpDir.isDirectory()) {
                if(!rmdir(tmpDir))
                    throw new IOException("Could not delete old temp directory: " + tmpDir);
            } else {
                if(!tmpDir.delete())
                    throw new IOException("Could not delete old temp file: " + tmpDir);
            }
        }
        File docBase = new File(tmpDir, "docBase");
        File alternate1 = new File(tmpDir, "alternate1");
        File alternate2 = new File(tmpDir, "alternate2");
        
        if(!tmpDir.mkdirs())
            throw new IOException("Could not create temp directory " + tmpDir);
        if(!docBase.mkdir())
            throw new IOException("Could not create temp directory " + docBase);
        if(!alternate1.mkdir())
            throw new IOException("Could not create temp directory " + alternate1);
        if(!alternate2.mkdir())
            throw new IOException("Could not create temp directory " + alternate2);
        // Create a file in each alternate directory that we can attempt to access
        FileOutputStream fos = new FileOutputStream(new File(alternate1, "test1.txt"));
        fos.write(foxText.getBytes("UTF-8"));
        fos.flush(); fos.close();
        fos = new FileOutputStream(new File(alternate2, "test2.txt"));
        fos.write(loremIpsum.getBytes("UTF-8"));
        fos.flush(); fos.close();
        // Finally, create the Context
        FileDirContext ctx = new FileDirContext();
        ctx.setDocBase(docBase.getCanonicalPath());
        ctx.setAliases("/a1=" + alternate1.getCanonicalPath()
                       +",/a2=" + alternate2.getCanonicalPath());
        // Check first alias
        Object file = ctx.lookup("/a1/test1.txt");
        Assert.assertNotNull(file);
        Assert.assertTrue(file instanceof Resource);
        
        byte[] buffer = new byte[4096];
        Resource res = (Resource)file;
        int len = res.streamContent().read(buffer);
        String contents = new String(buffer, 0, len, "UTF-8");
        assertEquals(foxText, contents);
        // Check second alias
        file = ctx.lookup("/a2/test2.txt");
        Assert.assertNotNull(file);
        Assert.assertTrue(file instanceof Resource);
        
        res = (Resource)file;
        len = res.streamContent().read(buffer);
        contents = new String(buffer, 0, len, "UTF-8");
        assertEquals(loremIpsum, contents);
        // Test aliases with spaces around the separators
        ctx.setAliases("   /a1= " + alternate1.getCanonicalPath()
                       + "\n\n"
                       +", /a2 =\n" + alternate2.getCanonicalPath()
                       + ",");
        // Check first alias
        file = ctx.lookup("/a1/test1.txt");
        Assert.assertNotNull(file);
        Assert.assertTrue(file instanceof Resource);
        res = (Resource)file;
        len = res.streamContent().read(buffer);
        contents = new String(buffer, 0, len, "UTF-8");
        assertEquals(foxText, contents);
        // Check second alias
        file = ctx.lookup("/a2/test2.txt");
        Assert.assertNotNull(file);
        Assert.assertTrue(file instanceof Resource);
        
        res = (Resource)file;
        len = res.streamContent().read(buffer);
        contents = new String(buffer, 0, len, "UTF-8");
        assertEquals(loremIpsum, contents);
        // Clean-up
        if(!rmdir(tmpDir))
            throw new IOException("Could not clean-up temp directory" + tmpDir);
    }
        <p>Whitespace is permitted around both the <code>,</code> and
        <code>=</code> delimiters, and will be trimmed. Therefore, an aliases
        attribute with the value <code>"/aliasPath1 = docBase1,<br/>
        /aliasPath2= docBase2"</code> is equivalent to
        <code>"/aliasPath1=docBase1,/aliasPath2=docBase2"</code></p>

======= fetch "protected PooledConnection borrowConnection(long now, PooledConnection con, Stri" 1412935^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                con.connect();
======= fetch "protected void connectUsingDriver() throws SQLException {" 1412935^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            if (driver==null)
======= fetch "protected void connectUsingDriver() throws SQLException {" 1412935^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            }

    protected Project project;
======= fetch "public static void main(String arg[]) {" 957d33b^:"java/org/apache/jasper/JspC.java"

            } catch (BuildException je) {
                System.err.println(je);
                if (jspc.dieLevel != NO_DIE_LEVEL) {
                    System.exit(jspc.dieLevel);
                }
======= fetch "protected void addExtension(final String extension) {" 957d33b^:"java/org/apache/jasper/JspC.java"

     * Sets the Ant project.
     *
     * @param theProject The project
     */
    public void setProject(final Project theProject) {
        project = theProject;
    }
    /**
     * Returns the project: may be <code>null</code> if not running
     * inside an Ant project.
     *
     * @return The project
     */
    public Project getProject() {
        return project;
    }
    /**
======= fetch "public void scanFiles( File base ) throws JasperException {" 957d33b^:"java/org/apache/jasper/JspC.java"

    public void execute() throws JasperException {
======= fetch "public void execute() throws JasperException {" 957d33b^:"java/org/apache/jasper/JspC.java"

            throw new JasperException(ioe);
======= fetch "public void execute() throws JasperException {" 957d33b^:"java/org/apache/jasper/JspC.java"

            throw je;

======= fetch "public Session createSession(String sessionId) {" ea77dfb^:"java/org/apache/catalina/session/ManagerBase.java"

            throw new IllegalStateException(
                    sm.getString("managerBase.createSession.ise"));

======= fetch "protected void processAnnotationWebFilter(String className," b82c47e^:"java/org/apache/catalina/startup/ContextConfig.java"

        boolean servletNamesSet = false;
======= fetch "protected void processAnnotationWebFilter(String className," b82c47e^:"java/org/apache/catalina/startup/ContextConfig.java"

                servletNamesSet = servletNames.length > 0;
======= fetch "protected void processAnnotationWebFilter(String className," b82c47e^:"java/org/apache/catalina/startup/ContextConfig.java"

            filterMap.setFilterName(filterName);
            fragment.addFilterMapping(filterMap);

    private final ClassLoader applicationClassLoader;
    public StreamInbound() {
        applicationClassLoader = Thread.currentThread().getContextClassLoader();
    }
======= fetch "public final SocketState onData() throws IOException {" d713894^:"java/org/apache/catalina/websocket/StreamInbound.java"

                    onBinaryData(wsIs);
======= fetch "public final SocketState onData() throws IOException {" d713894^:"java/org/apache/catalina/websocket/StreamInbound.java"

                    onTextData(r);
======= fetch "public final SocketState onData() throws IOException {" d713894^:"java/org/apache/catalina/websocket/StreamInbound.java"

    private void doOnBinaryData(InputStream is) throws IOException {
        // Need to call onClose using the web application's class loader
        Thread t = Thread.currentThread();
        ClassLoader cl = t.getContextClassLoader();
        t.setContextClassLoader(applicationClassLoader);
        try {
            onBinaryData(is);
        } finally {
            t.setContextClassLoader(cl);
        }
    }
    private void doOnTextData(Reader r) throws IOException {
        // Need to call onClose using the web application's class loader
        Thread t = Thread.currentThread();
        ClassLoader cl = t.getContextClassLoader();
        t.setContextClassLoader(applicationClassLoader);
        try {
            onTextData(r);
        } finally {
            t.setContextClassLoader(cl);
        }
    }
======= fetch "private void closeOutboundConnection(int status, ByteBuffer data) throws IOExcep" d713894^:"java/org/apache/catalina/websocket/StreamInbound.java"

            onClose(status);
======= fetch "private void closeOutboundConnection(WsFrame frame) throws IOException {" d713894^:"java/org/apache/catalina/websocket/StreamInbound.java"

            onClose(Constants.OPCODE_CLOSE);
======= fetch "private void closeOutboundConnection(WsFrame frame) throws IOException {" d713894^:"java/org/apache/catalina/websocket/StreamInbound.java"

    public void onUpgradeComplete() {
        onOpen(outbound);
======= fetch "public void testDetectWrongVersion() throws Exception {" d713894^:"test/org/apache/catalina/websocket/TestWebSocket.java"

        // Swallow the headers
======= fetch "public void testKey() throws Exception {" d713894^:"test/org/apache/catalina/websocket/TestWebSocket.java"

        // Swallow the headers
======= fetch "public void testKey() throws Exception {" d713894^:"test/org/apache/catalina/websocket/TestWebSocket.java"

======= fetch "public void testKey() throws Exception {" d713894^:"test/org/apache/catalina/websocket/TestWebSocket.java"

    @Test
    public void testBug53339() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        tomcat.enableNaming();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctx, "Bug53339", new Bug53339Servlet());
        ctx.addServletMapping("/*", "Bug53339");
        // Create the resource
        ContextEnvironment env = new ContextEnvironment();
        env.setName(Bug53339WsInbound.JNDI_NAME);
        env.setType(String.class.getName());
        env.setValue(Bug53339WsInbound.TEST_MESSAGE);
        ctx.getNamingResources().addEnvironment(env);
        tomcat.start();
        WebSocketClient client= new WebSocketClient(getPort());
        // Send the WebSocket handshake
        client.writer.write("GET / HTTP/1.1" + CRLF);
        client.writer.write("Host: foo" + CRLF);
        client.writer.write("Upgrade: websocket" + CRLF);
        client.writer.write("Connection: upgrade" + CRLF);
        client.writer.write("Sec-WebSocket-Version: 13" + CRLF);
        client.writer.write("Sec-WebSocket-Key: TODO" + CRLF);
        client.writer.write(CRLF);
        client.writer.flush();
        // Make sure we got an upgrade response
        String responseLine = client.reader.readLine();
        assertTrue(responseLine.startsWith("HTTP/1.1 101"));
        // Swallow the headers
        String responseHeaderLine = client.reader.readLine();
        while (!responseHeaderLine.equals("")) {
            responseHeaderLine = client.reader.readLine();
        }
        // Now we can do WebSocket
        String msg = client.readMessage();
        assertEquals(Bug53339WsInbound.TEST_MESSAGE, msg);
        // Finished with the socket
        client.close();
    }
    private static class Bug53339Servlet extends WebSocketServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected StreamInbound createWebSocketInbound(String subProtocol) {
            return new Bug53339WsInbound();
        }
    }
    private static class Bug53339WsInbound extends MessageInbound {
        public static final String TEST_MESSAGE = "Test Message";
        public static final String JNDI_NAME = "Bug53339Message";
        @Override
        protected void onOpen(WsOutbound outbound) {
            String msg = "Error";
            try {
                javax.naming.Context initCtx = new InitialContext();
                msg = (String) initCtx.lookup(
                        "java:comp/env/" + JNDI_NAME);
            } catch (NamingException e) {
                // Ignore - the test checks if the message is sent
                e.printStackTrace(); // for debug purposes if the test fails
            }
            CharBuffer cb = CharBuffer.wrap("" + msg);
            try {
                outbound.writeTextMessage(cb);
            } catch (IOException e) {
                // Ignore - the test checks if the message is sent
            }
        }
        @Override
        protected void onBinaryMessage(ByteBuffer message) throws IOException {
            // Ignore
        }
        @Override
        protected void onTextMessage(CharBuffer message) throws IOException {
            // Ignore
        }
    }

======= fetch "public void testAcceptPublicBasic() throws Exception {" a1c6165^:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                false, 200, false, 200);
======= fetch "public void testAcceptProtectedBasic() throws Exception {" a1c6165^:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                true, 401, false, 200);
======= fetch "public void testBasicLoginSessionTimeout() throws Exception {" a1c6165^:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                true, 401, false, 200);
======= fetch "public void testBasicLoginSessionTimeout() throws Exception {" a1c6165^:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                true, 401, false, 200);
======= fetch "public void testBasicLoginRejectProtected() throws Exception {" a1c6165^:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                true, 401, false, 200);
======= fetch "private void doTestBasic(String user, String pwd, String uri," a1c6165^:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

            boolean verifyAuthSchemeCase,
======= fetch "private void doTestBasic(String user, String pwd, String uri," a1c6165^:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

        String authLine = "Basic " + base64auth;

======= fetch "private void doForward(ServletRequest request, ServletResponse response)" c6b691d^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        if (request.getAsyncContext() != null) {
            // An async request was started during the forward, don't close the
            // response as it may be written to during the async handling
            return;
        }
======= fetch "public void run() {" c6b691d^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    @Test
    public void testBug53337() throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        File docBase = new File(System.getProperty("java.io.tmpdir"));
        Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
        Wrapper a = Tomcat.addServlet(ctx, "ServletA", new Bug53337ServletA());
        a.setAsyncSupported(true);
        Wrapper b = Tomcat.addServlet(ctx, "ServletB", new Bug53337ServletB());
        b.setAsyncSupported(true);
        Tomcat.addServlet(ctx, "ServletC", new Bug53337ServletC());
        ctx.addServletMapping("/ServletA", "ServletA");
        ctx.addServletMapping("/ServletB", "ServletB");
        ctx.addServletMapping("/ServletC", "ServletC");
        tomcat.start();
        StringBuilder url = new StringBuilder(48);
        url.append("http://localhost:");
        url.append(getPort());
        url.append("/ServletA");
        ByteChunk body = new ByteChunk();
        int rc = getUrl(url.toString(), body, null);
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertEquals("OK", body.toString());
    }
    private static class Bug53337ServletA extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            RequestDispatcher rd = req.getRequestDispatcher("/ServletB");
            rd.forward(req, resp);
        }
    }
    private static class Bug53337ServletB extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(final HttpServletRequest req,
                final HttpServletResponse resp)
                throws ServletException, IOException {
            final AsyncContext async = req.startAsync();
            // Just for debugging
            async.setTimeout(100000);
            ExecutorService executor = Executors.newSingleThreadExecutor();
            executor.submit(new Runnable() {
                @Override
                public void run() {
                    async.dispatch("/ServletC");
                }
            });
            executor.shutdown();
        }
    }
    private static class Bug53337ServletC extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setContentType("text/plain");
            resp.getWriter().print("OK");
        }
    }

======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 6ce3128^:"java/org/apache/catalina/startup/Tomcat.java"

        boolean init = false;
======= fetch "public synchronized Servlet loadServlet() throws ServletException {" 6ce3128^:"java/org/apache/catalina/startup/Tomcat.java"

                if (!init) {
======= fetch "public synchronized Servlet loadServlet() throws ServletException {" 6ce3128^:"java/org/apache/catalina/startup/Tomcat.java"

                    init = true;
======= fetch "public void doGet(HttpServletRequest req, HttpServletResponse res)" 6ce3128^:"test/org/apache/catalina/startup/TestTomcat.java"

     * Simple servlet to test initialization of servlet instances.
     */
    private static class InitCount extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private AtomicInteger callCount = new AtomicInteger(0);
        @Override
        public void init() throws ServletException {
            super.init();
            callCount.incrementAndGet();
        }
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setContentType("text/plain");
            resp.getWriter().print("OK");
        }
        public int getCallCount() {
            return callCount.intValue();
        }
    }
    /**
======= fetch "public void testBug50826() throws Exception {" 6ce3128^:"test/org/apache/catalina/startup/TestTomcat.java"

    @Test
    public void testBug53301() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        org.apache.catalina.Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        InitCount initCount = new InitCount();
        Tomcat.addServlet(ctx, "initCount", initCount);
        ctx.addServletMapping("/", "initCount");
        tomcat.start();
        ByteChunk res = getUrl("http://localhost:" + getPort() + "/");
        assertEquals("OK", res.toString());
        assertEquals(1, initCount.getCallCount());
    }

======= fetch "public void addSecurityRoleRef(SecurityRoleRef securityRoleRef) {" ad3b503^:"java/org/apache/catalina/deploy/ServletDef.java"

     * @deprecated
======= fetch "public void addSecurityRoleRef(SecurityRoleRef securityRoleRef) {" ad3b503^:"java/org/apache/catalina/deploy/ServletDef.java"

    @Deprecated
======= fetch "public void addRuleInstances(Digester digester) {" ad3b503^:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addCallMethod(fullPrefix + "/servlet/security-role-ref",
                               "addSecurityRoleRef", 2);
        digester.addCallParam(fullPrefix + "/servlet/security-role-ref/role-link", 1);
        digester.addCallParam(fullPrefix + "/servlet/security-role-ref/role-name", 0);

======= fetch "protected void initInternal() throws LifecycleException {" 84342f5^:"java/org/apache/catalina/core/ContainerBase.java"

                startStopQueue);
======= fetch "public Void call() throws LifecycleException {" 84342f5^:"java/org/apache/catalina/core/ContainerBase.java"

    private static class StartStopThreadFactory implements ThreadFactory {
        private ThreadGroup group;
        private AtomicInteger threadNumber = new AtomicInteger(1);
        private String namePrefix;
        
        public StartStopThreadFactory(String namePrefix) {
            SecurityManager s = System.getSecurityManager();
            group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
            this.namePrefix = namePrefix;
        }
        
        @Override
        public Thread newThread(Runnable r) {
            Thread thread = new Thread(group, r, namePrefix + threadNumber.getAndIncrement());
            thread.setDaemon(true);
            return thread;
        }
    }

======= fetch "public FileUrlJar(URL url) throws IOException {" e90cd4b^:"java/org/apache/tomcat/util/scan/FileUrlJar.java"

        jarConn.setUseCaches(false);

======= fetch "protected void prepareRequest() {" 280beac^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        MessageBytes connectionValueMB = headers.getValue("connection");
======= fetch "private void prepareResponse() {" 280beac^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        boolean connectionClosePresent = false;
======= fetch "private void prepareResponse() {" 280beac^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

            if (entityBody && http11) {
======= fetch "private void prepareResponse() {" 280beac^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

            headers.addValue(Constants.CONNECTION).setString(Constants.CLOSE);
======= fetch "private void prepareResponse() {" 280beac^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

    private boolean isConnectionClose(MimeHeaders headers) {
        MessageBytes connection = headers.getValue(Constants.CONNECTION);
        if (connection == null) {
            return false;
        }
        return connection.equals(Constants.CLOSE);
    }
======= fetch "public void run() {" 280beac^:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

    @Test
    public void testChunking11NoContentLength() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctxt = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctxt, "NoContentLengthFlushingServlet",
                new NoContentLengthFlushingServlet());
        ctxt.addServletMapping("/test", "NoContentLengthFlushingServlet");
        tomcat.start();
        ByteChunk responseBody = new ByteChunk();
        Map<String,List<String>> responseHeaders =
                new HashMap<String,List<String>>();
        int rc = getUrl("http://localhost:" + getPort() + "/test", responseBody,
                responseHeaders);
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertTrue(responseHeaders.containsKey("Transfer-Encoding"));
        List<String> encodings = responseHeaders.get("Transfer-Encoding");
        assertEquals(1, encodings.size());
        assertEquals("chunked", encodings.get(0));
    }
    @Test
    public void testNoChunking11NoContentLengthConnectionClose()
            throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctxt = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctxt, "NoContentLengthConnectionCloseFlushingServlet",
                new NoContentLengthConnectionCloseFlushingServlet());
        ctxt.addServletMapping("/test",
                "NoContentLengthConnectionCloseFlushingServlet");
        tomcat.start();
        ByteChunk responseBody = new ByteChunk();
        Map<String,List<String>> responseHeaders =
                new HashMap<String,List<String>>();
        int rc = getUrl("http://localhost:" + getPort() + "/test", responseBody,
                responseHeaders);
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertTrue(responseHeaders.containsKey("Connection"));
        List<String> connections = responseHeaders.get("Connection");
        assertEquals(1, connections.size());
        assertEquals("close", connections.get(0));
        assertFalse(responseHeaders.containsKey("Transfer-Encoding"));
        assertEquals("OK", responseBody.toString());
    }
    // flushes with no content-length set
    // should result in chunking on HTTP 1.1
    private static final class NoContentLengthFlushingServlet
            extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setStatus(HttpServletResponse.SC_OK);
            resp.setContentType("text/plain");
            resp.getWriter().write("OK");
            resp.flushBuffer();
        }
    }
    // flushes with no content-length set but sets Connection: close header
    // should no result in chunking on HTTP 1.1
    private static final class NoContentLengthConnectionCloseFlushingServlet
            extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setStatus(HttpServletResponse.SC_OK);
            resp.setContentType("text/event-stream");
            resp.addHeader("Connection", "close");
            resp.flushBuffer();
            resp.getWriter().write("OK");
            resp.flushBuffer();
        }
    }

======= fetch "protected void populateAnnotationsCache(Class<?> clazz," 13100e9^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                            String fieldName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);
======= fetch "public static String getName(Method setter) {" 13100e9^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

        StringBuilder name = new StringBuilder(setter.getName());
        // remove 'set'
        name.delete(0, 3);
        // lowercase first char
        name.setCharAt(0, Character.toLowerCase(name.charAt(0)));
        return name.toString();

======= fetch "protected void populateAnnotationsCache(Class<?> clazz," 39c8e18^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                        if (injections != null && methodName.startsWith("set") && methodName.length() > 3) {

======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" 5d12129^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        boolean isClassResource = path.endsWith(".class");
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" 5d12129^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                if (binaryStream != null) {
======= fetch "protected InputStream findLoadedResource(String name) {" 5d12129^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            else {
                try {
                    return entry.source.openStream();
                } catch (IOException ioe) {
                    // Ignore
                }
            }
======= fetch "protected InputStream findLoadedResource(String name) {" 5d12129^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        return (null);

======= fetch "private Object newInstance(Object instance, Class<?> clazz) throws IllegalAccess" de1f763^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

            Map<String, String> injections = injectionMap.get(clazz.getName());
======= fetch "private Object newInstance(Object instance, Class<?> clazz) throws IllegalAccess" de1f763^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

    private Map<String, String> assembleInjectionsFromClassHierarchy(Class<?> clazz) {
        Map<String, String> injections = new HashMap<String, String>();
        Map<String, String> currentInjections = null;
        while (clazz != null) {
            currentInjections = this.injectionMap.get(clazz.getName());
            if (currentInjections != null) {
                injections.putAll(currentInjections);
            }
            clazz = clazz.getSuperclass();
        }
        return injections;
    }

======= fetch "protected void onClose(int status) {" 098a647^:"java/org/apache/catalina/websocket/StreamInbound.java"

    /**
     * This default implementation sets the read timeout to infinite and expects
     * the WebSocket application to close the connection when it is no longer
     * required. Applications wishing to set an explicit timeout may override
     * this method and return a value of their choice.
     *
     * @return  The read timeout in milliseconds or -1 for infinite
     */
    @Override
    public int getReadTimeout() {
        return -1;
    }
======= fetch "public void release(SocketWrapper<Long> socket," 098a647^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

                        socket.getSocket().longValue(), true);
======= fetch "public void release(SocketWrapper<Long> socket," 098a647^:"java/org/apache/coyote/http11/Http11AprProtocol.java"

                        socket.getSocket().longValue(), true);
======= fetch "protected void longPoll(SocketWrapper<Long> socket," 098a647^:"java/org/apache/coyote/http11/Http11AprProtocol.java"

                        socket.getSocket().longValue(), false);
======= fetch "protected void longPoll(SocketWrapper<Long> socket," 098a647^:"java/org/apache/coyote/http11/Http11AprProtocol.java"

                        socket.getSocket().longValue(), false);
======= fetch "public UpgradeAprProcessor(SocketWrapper<Long> wrapper," 098a647^:"java/org/apache/coyote/http11/upgrade/UpgradeAprProcessor.java"

        Socket.timeoutSet(wrapper.getSocket().longValue(),
                upgradeInbound.getReadTimeout());
======= fetch "public UpgradeBioProcessor(SocketWrapper<Socket> wrapper," 098a647^:"java/org/apache/coyote/http11/upgrade/UpgradeBioProcessor.java"

        int timeout = upgradeInbound.getReadTimeout();
        if (timeout < 0) {
            timeout = 0;
        }
        wrapper.getSocket().setSoTimeout(timeout);
    /**
     * Allow the upgraded protocol to define the read timeout to be used with
     * the upgraded connection.
     *
     * @return  The read timeout in milliseconds or -1 for infinite
     */
    int getReadTimeout();
======= fetch "public UpgradeNioProcessor(SocketWrapper<NioChannel> wrapper," 098a647^:"java/org/apache/coyote/http11/upgrade/UpgradeNioProcessor.java"

        wrapper.setTimeout(upgradeInbound.getReadTimeout());
======= fetch "private void closePollset(long pollset) {" 098a647^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

         * Add specified socket and associated pool to the poller. The socket will
         * be added to a temporary array, and polled first after a maximum amount
         * of time equal to pollTime (in most cases, latency will be much lower,
         * however).
======= fetch "private void closePollset(long pollset) {" 098a647^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

         * @param socket to add to the poller
======= fetch "private void closePollset(long pollset) {" 098a647^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        public void add(long socket, boolean keepAlive) {
======= fetch "public void add(long socket, boolean keepAlive) {" 098a647^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                if (keepAlive) {
                    addSocketTimeout[addCount] = getKeepAliveTimeout();
                } else {
                    addSocketTimeout[addCount] = getSoTimeout();
                }
======= fetch "public void run() {" 098a647^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                    int timeout = addSocketTimeout[i];
                                    if (timeout > 0) {
                                        // Convert milliseconds to microseconds
                                        timeout = timeout * 1000;
                                    }
======= fetch "public void run() {" 098a647^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                            Poll.APR_POLLIN,
                                            addSocketTimeout[i] * 1000);
======= fetch "public void run() {" 098a647^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                    getPoller().add(state.socket, true);
======= fetch "public void run() {" 098a647^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                        getPoller().add(socket.getSocket().longValue(), false);

    private AtomicLong poolVersion = new AtomicLong(Long.MIN_VALUE);
======= fetch "protected void init(PoolConfiguration properties) throws SQLException {" f170929^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            //idle = new LinkedTransferQueue<PooledConnection>();
            //idle = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(),false);
======= fetch "protected boolean shouldClose(PooledConnection con, int action) {" f170929^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        if (con.getConnectionVersion() < getPoolVersion()) return true;
======= fetch "public void checkIdle() {" f170929^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        checkIdle(false);
    }
    public void checkIdle(boolean ignoreMinSize) {
======= fetch "public void checkIdle() {" f170929^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            while ( (idle.size()>=getPoolProperties().getMinIdle()) && unlocked.hasNext()) {
======= fetch "public void checkIdle() {" f170929^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                    if ((con.getReleaseTime()>0) && ((now - time) > con.getReleaseTime()) && (getSize()>getPoolProperties().getMinIdle())) {
======= fetch "public void checkIdle() {" f170929^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    protected boolean shouldReleaseIdle(long now, PooledConnection con, long time) {
        if (con.getConnectionVersion() < getPoolVersion()) return true;
        else return (con.getReleaseTime()>0) && ((now - time) > con.getReleaseTime()) && (getSize()>getPoolProperties().getMinIdle());
    }
======= fetch "protected PooledConnection create(boolean incrementCounter) {" f170929^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

     * Purges all connections in the pool.
     * For connections currently in use, these connections will be
     * purged when returned on the pool. This call also
     * purges connections that are idle and in the pool
     * To only purge used/active connections see {@link #purgeOnReturn()}
     */
    public void purge() {
        purgeOnReturn();
        checkIdle(true);
    }
    /**
     * Purges connections when they are returned from the pool.
     * This call does not purge idle connections until they are used.
     * To purge idle connections see {@link #purge()}
     */
    public void purgeOnReturn() {
        poolVersion.incrementAndGet();
    }
    /**
======= fetch "private static synchronized void unregisterCleaner(PoolCleaner cleaner) {" f170929^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    public long getPoolVersion() {
        return poolVersion.get();
    }
======= fetch "public void setPropagateInterruptState(boolean propagateInterruptState) {" f170929^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    /**
     * {@inheritDoc}
     */
    public void purge()  {
        try {
            createPool().purge();
        }catch (SQLException x) {
            log.error("Unable to purge pool.",x);
        }
    }
    /**
     * {@inheritDoc}
     */
    public void purgeOnReturn() {
        try {
            createPool().purgeOnReturn();
        }catch (SQLException x) {
            log.error("Unable to purge pool.",x);
        }
    }
    private volatile long connectionVersion=0;
======= fetch "public PooledConnection(PoolConfiguration prop, ConnectionPool parent) {" f170929^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        connectionVersion = parent.getPoolVersion();
    }
    public long getConnectionVersion() {
        return connectionVersion;
======= fetch "public void setPropagateInterruptState(boolean propagateInterruptState) {" f170929^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public void purge() {
        pool.purge();
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void purgeOnReturn() {
        pool.purgeOnReturn();
    }
    /**
     * Purges all connections in the pool.
     * For connections currently in use, these connections will be
     * purged when returned on the pool. This call also
     * purges connections that are idle and in the pool
     * To only purge used/active connections see {@link #purgeOnReturn()}
     */
    public void purge();
    /**
     * Purges connections when they are returned from the pool.
     * This call does not purge idle connections until they are used.
     * To purge idle connections see {@link #purge()}
     */
    public void purgeOnReturn();
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * @author Filip Hanik
 * @version 1.0
 */
    public PoolPurgeTest(String name) {
        super(name);
    }
    static final int expectedSize = 2;
    @Override
    public org.apache.tomcat.jdbc.pool.DataSource createDefaultDataSource() {
        // TODO Auto-generated method stub
        org.apache.tomcat.jdbc.pool.DataSource ds = super.createDefaultDataSource();
        ds.getPoolProperties().setDriverClassName(Driver.class.getName());
        ds.getPoolProperties().setUrl(Driver.url);
        ds.getPoolProperties().setInitialSize(expectedSize);
        ds.getPoolProperties().setMaxIdle(expectedSize);
        ds.getPoolProperties().setMinIdle(expectedSize);
        ds.getPoolProperties().setMaxActive(expectedSize);
        ds.getPoolProperties().setTimeBetweenEvictionRunsMillis(30000);
        ds.getPoolProperties().setMaxAge(Long.MAX_VALUE);
        return ds;
    }
    @Override
    protected void tearDown() throws Exception {
        Driver.reset();
        super.tearDown();
    }
    public void testPoolPurge() throws Exception {
        init();
        this.datasource.getConnection().close();
        assertEquals("Nr of connections should be "+expectedSize, expectedSize , datasource.getSize());
        this.datasource.purge();
        assertEquals("Nr of connections should be 0", 0 , datasource.getSize());
        tearDown();
    }
    public void testPoolPurgeWithActive() throws Exception {
        init();
        java.sql.Connection con = datasource.getConnection();
        assertEquals("Nr of connections should be "+expectedSize, expectedSize , datasource.getSize());
        this.datasource.purge();
        assertEquals("Nr of connections should be "+(expectedSize-1), (expectedSize-1) , datasource.getSize());
        con.close();
        assertEquals("Nr of connections should be 0", 0 , datasource.getSize());
        tearDown();
    }
    public void testPoolPurgeOnReturn() throws Exception {
        init();
        java.sql.Connection con = datasource.getConnection();
        assertEquals("Nr of connections should be "+expectedSize, expectedSize , datasource.getSize());
        this.datasource.purgeOnReturn();
        assertEquals("Nr of connections should be "+expectedSize, expectedSize , datasource.getSize());
        con.close();
        assertEquals("Nr of connections should be "+(expectedSize-1), (expectedSize-1) , datasource.getSize());
        tearDown();
    }

======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 111dc8e^:"java/org/apache/catalina/websocket/WebSocketServlet.java"

        // Small hack until the Servlet API provides a way to do this.
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 111dc8e^:"java/org/apache/catalina/websocket/WebSocketServlet.java"

        ((RequestFacade) req).doUpgrade(inbound);

======= fetch "public int getMaxThreads() {" be365e5^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

        if (running && executor!=null) {
======= fetch "public void bind() throws Exception {" be365e5^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

            setMaxConnections(getMaxThreads());
      <strong>maxThreads</strong>. For NIO the default is <code>10000</code>.
      <strong>maxThreads</strong>. For NIO the default is <code>10000</code>.

======= fetch "public void setOwner(Object owner) {" 48b9153^:"java/org/apache/catalina/ha/session/DeltaSession.java"

        /**
         * If this returns true, to replicate that an object has been accessed
         * @return boolean
         */
        @Override
        public boolean isAccessReplicate() {
            long replDelta = System.currentTimeMillis() - getLastTimeReplicated();
            if (maxInactiveInterval >=0 && replDelta > (maxInactiveInterval * 1000)) {
                return true;
            }
            return false;
        }
        /**
         * Access to an existing object.
         */
        @Override
        public void accessEntry() {
            this.access();
            this.setPrimarySession(false);
            this.endAccess();
        }
======= fetch "protected void removeAttributeInternal(String name, boolean notify," 48b9153^:"java/org/apache/catalina/ha/session/DeltaSession.java"

    protected long getLastTimeReplicated() {
======= fetch "public long getVersion() {" 48b9153^:"java/org/apache/catalina/ha/session/DeltaSession.java"

    protected void setLastTimeReplicated(long lastTimeReplicated) {
======= fetch "public void replicate(Object key, boolean complete) {" 48b9153^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            //check to see if we need to replicate this object isDirty()||complete
            boolean repl = complete || ( (value instanceof ReplicatedMapEntry) && ( (ReplicatedMapEntry) value).isDirty());
======= fetch "public void replicate(Object key, boolean complete) {" 48b9153^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            boolean diff = ( (value instanceof ReplicatedMapEntry) && ( (ReplicatedMapEntry) value).isDiffable());
======= fetch "public void replicate(Object key, boolean complete) {" 48b9153^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            if (diff) {
======= fetch "public void replicate(Object key, boolean complete) {" 48b9153^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            if (msg == null && isAccess) {
                //construct a access message
                msg = new MapMessage(mapContextName, MapMessage.MSG_ACCESS,
                        false, (Serializable) entry.getKey(), null, null, entry.getPrimary(),
                        entry.getBackupNodes());
            }
======= fetch "public void replicate(Object key, boolean complete) {" 48b9153^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    if ((entry.getValue() instanceof ReplicatedMapEntry)) {
                        ((ReplicatedMapEntry)entry.getValue()).setLastTimeReplicated(System.currentTimeMillis());
                    }
======= fetch "public void messageReceived(Serializable msg, Member sender) {" 48b9153^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        if (mapmsg.getMsgType() == MapMessage.MSG_ACCESS) {
            MapEntry<K, V> entry = innerMap.get(mapmsg.getKey());
            if (entry != null) {
                entry.setBackupNodes(mapmsg.getBackupNodes());
                entry.setPrimary(mapmsg.getPrimary());
                if (entry.getValue() instanceof ReplicatedMapEntry) {
                    ((ReplicatedMapEntry) entry.getValue()).accessEntry();
                }
            }
        }
======= fetch "public String toString() {" 48b9153^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        public static final int MSG_ACCESS = 11;
======= fetch "public String getTypeDesc() {" 48b9153^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                case MSG_ACCESS: return "MSG_ACCESS";
    /**
     * Return the last replicate time.
     * @return
     */
    public long getLastTimeReplicated();
    /**
     * Set the last replicate time.
     * @param lastTimeReplicated
     */
    public void setLastTimeReplicated(long lastTimeReplicated);
    /**
     * If this returns true, to replicate that an object has been accessed
     * @return boolean
     */
    public boolean isAccessReplicate();
    /**
     * Access to an existing object.
     */
    public void accessEntry();

======= fetch "private static void init()" df88ecb^:"java/org/apache/catalina/core/AprLifecycleListener.java"

                    + minor + "." + patch));

======= fetch "protected void init(PoolConfiguration properties) throws SQLException {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        //if the evictor thread is supposed to run, start it now
        if (properties.isPoolSweeperEnabled()) {
            poolCleaner = new PoolCleaner(this, properties.getTimeBetweenEvictionRunsMillis());
            poolCleaner.start();
        } //end if
======= fetch "protected void init(PoolConfiguration properties) throws SQLException {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    protected Properties dbProperties = new Properties();
    protected String url = null;
    protected String driverClassName = null;
    protected Boolean defaultAutoCommit = null;
    protected Boolean defaultReadOnly = null;
    protected int defaultTransactionIsolation = DataSourceFactory.UNKNOWN_TRANSACTIONISOLATION;
    protected String defaultCatalog = null;
    protected String connectionProperties;
    protected int initialSize = 10;
    protected int maxActive = DEFAULT_MAX_ACTIVE;
    protected int maxIdle = maxActive;
    protected int minIdle = initialSize;
    protected int maxWait = 30000;
    protected String validationQuery;
    protected String validatorClassName;
    protected Validator validator;
    protected boolean testOnBorrow = false;
    protected boolean testOnReturn = false;
    protected boolean testWhileIdle = false;
    protected int timeBetweenEvictionRunsMillis = 5000;
    protected int numTestsPerEvictionRun;
    protected int minEvictableIdleTimeMillis = 60000;
    protected final boolean accessToUnderlyingConnectionAllowed = true;
    protected boolean removeAbandoned = false;
    protected int removeAbandonedTimeout = 60;
    protected boolean logAbandoned = false;
    protected String name = "Tomcat Connection Pool["+(poolCounter.addAndGet(1))+"-"+System.identityHashCode(PoolProperties.class)+"]";
    protected String password;
    protected String username;
    protected long validationInterval = 30000;
    protected boolean jmxEnabled = true;
    protected String initSQL;
    protected boolean testOnConnect =false;
    protected String jdbcInterceptors=null;
    protected boolean fairQueue = true;
    protected boolean useEquals = true;
    protected int abandonWhenPercentageFull = 0;
    protected long maxAge = 0;
    protected boolean useLock = false;
    protected InterceptorDefinition[] interceptors = null;
    protected int suspectTimeout = 0;
    protected Object dataSource = null;
    protected String dataSourceJNDI = null;
    protected boolean alternateUsernameAllowed = false;
    protected boolean commitOnReturn = false;
    protected boolean rollbackOnReturn = false;
    protected boolean useDisposableConnectionFacade = true;
    protected boolean logValidationErrors = false;
    protected boolean propagateInterruptState = false;
======= fetch "public void setInitialSize(int initialSize) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setInitSQL(String initSQL) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setJdbcInterceptors(String jdbcInterceptors) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setJmxEnabled(boolean jmxEnabled) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setLogAbandoned(boolean logAbandoned) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setMaxActive(int maxActive) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setMaxIdle(int maxIdle) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setMaxWait(int maxWait) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setMinEvictableIdleTimeMillis(int minEvictableIdleTimeMillis) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setMinIdle(int minIdle) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setPassword(String password) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setRemoveAbandoned(boolean removeAbandoned) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setRemoveAbandonedTimeout(int removeAbandonedTimeout) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setTestOnBorrow(boolean testOnBorrow) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setTestOnConnect(boolean testOnConnect) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setTestOnReturn(boolean testOnReturn) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setTestWhileIdle(boolean testWhileIdle) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setTimeBetweenEvictionRunsMillis(int timeBetweenEvictionRunsMillis)" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setUrl(String url) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setUseEquals(boolean useEquals) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setUseLock(boolean useLock) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setUsername(String username) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setValidationInterval(long validationInterval) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setValidationQuery(String validationQuery) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // TODO Auto-generated method stub
======= fetch "public void setSuspectTimeout(int seconds) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        //no op
======= fetch "public void setDataSourceJNDI(String jndiDS) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        //noop
======= fetch "public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        //noop
======= fetch "public void setValidator(Validator validator) {" 518662f^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        //noop

    private static final CacheValue nullTcclFactory = new CacheValue();
    private static ConcurrentMap<CacheKey, CacheValue> factoryCache
        = new ConcurrentHashMap<CacheKey, CacheValue>();
======= fetch "public static ExpressionFactory newInstance(Properties properties) {" 7da5fa9^:"java/javax/el/ExpressionFactory.java"

        String className = discoverClassName(tccl);
======= fetch "public static ExpressionFactory newInstance(Properties properties) {" 7da5fa9^:"java/javax/el/ExpressionFactory.java"

        CacheValue cacheValue;
        Class<?> clazz;
        if (tccl == null) {
            cacheValue = nullTcclFactory;
        } else {
            CacheKey key = new CacheKey(tccl);
            cacheValue = factoryCache.get(key);
            if (cacheValue == null) {
                CacheValue newCacheValue = new CacheValue();
                cacheValue = factoryCache.putIfAbsent(key, newCacheValue);
                if (cacheValue == null) {
                    cacheValue = newCacheValue;
                }
            }
        }
        final Lock readLock = cacheValue.getLock().readLock();
        readLock.lock();
======= fetch "public static ExpressionFactory newInstance(Properties properties) {" 7da5fa9^:"java/javax/el/ExpressionFactory.java"

            Class<?> clazz = null;
            if (tccl == null) {
                clazz = Class.forName(className);
            } else {
                clazz = tccl.loadClass(className);
======= fetch "public static ExpressionFactory newInstance(Properties properties) {" 7da5fa9^:"java/javax/el/ExpressionFactory.java"

        }
        try {
======= fetch "public static ExpressionFactory newInstance(Properties properties) {" 7da5fa9^:"java/javax/el/ExpressionFactory.java"

        } catch (ClassNotFoundException e) {
            throw new ELException(
                    "Unable to find ExpressionFactory of type: " + className,
                    e);
======= fetch "public static ExpressionFactory newInstance(Properties properties) {" 7da5fa9^:"java/javax/el/ExpressionFactory.java"

                    "Unable to create ExpressionFactory of type: " + className,
======= fetch "public static ExpressionFactory newInstance(Properties properties) {" 7da5fa9^:"java/javax/el/ExpressionFactory.java"

                    "Unable to create ExpressionFactory of type: " + className,
======= fetch "public static ExpressionFactory newInstance(Properties properties) {" 7da5fa9^:"java/javax/el/ExpressionFactory.java"

                    "Unable to create ExpressionFactory of type: " + className,
======= fetch "public static ExpressionFactory newInstance(Properties properties) {" 7da5fa9^:"java/javax/el/ExpressionFactory.java"

                    "Unable to create ExpressionFactory of type: " + className,
======= fetch "public static ExpressionFactory newInstance(Properties properties) {" 7da5fa9^:"java/javax/el/ExpressionFactory.java"

     * Key used to cache ExpressionFactory discovery information per class
     * loader. The class loader reference is never {@code null}, because
     * {@code null} tccl is handled separately.
     */
    private static class CacheKey {
        private final int hash;
        private final WeakReference<ClassLoader> ref;
        public CacheKey(ClassLoader cl) {
            hash = cl.hashCode();
            ref = new WeakReference<ClassLoader>(cl);
        }
        @Override
        public int hashCode() {
            return hash;
        }
        @Override
        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof CacheKey)) {
                return false;
            }
            ClassLoader thisCl = ref.get();
            if (thisCl == null) {
                return false;
            }
            return thisCl == ((CacheKey) obj).ref.get();
        }
    }
    private static class CacheValue {
        private final ReadWriteLock lock = new ReentrantReadWriteLock();
        private String className;
        private WeakReference<Class<?>> ref;
        public CacheValue() {
        }
        public ReadWriteLock getLock() {
            return lock;
        }
        public String getFactoryClassName() {
            return className;
        }
        public void setFactoryClassName(String className) {
            this.className = className;
        }
        public Class<?> getFactoryClass() {
            return ref != null ? ref.get() : null;
        }
        public void setFactoryClass(Class<?> clazz) {
            ref = new WeakReference<Class<?>>(clazz);
        }
    }
    /**

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void bug53001() {
        ExpressionFactory factory = ExpressionFactory.newInstance();
        ELContext context = new ELContextImpl();
        ResourceBundle rb = new TesterResourceBundle();
        ValueExpression var =
            factory.createValueExpression(rb, ResourceBundle.class);
        context.getVariableMapper().setVariable("rb", var);
        ValueExpression ve = factory.createValueExpression(
                context, "${rb.keys}", String.class);
        MethodExpression me = factory.createMethodExpression(
                context, "${rb.getKeys()}", Enumeration.class, null);
        // Ensure we are specification compliant
        String result1 = (String) ve.getValue(context);
        Assert.assertEquals("???keys???", result1);
        // Check that the method expression does return the keys
        Object result2 = me.invoke(context, null);
        Assert.assertTrue(result2 instanceof Enumeration);
        @SuppressWarnings("unchecked")
        Enumeration<String> e = (Enumeration<String>) result2;
        Assert.assertTrue(e.hasMoreElements());
        Assert.assertEquals("key2", e.nextElement());
        Assert.assertTrue(e.hasMoreElements());
        Assert.assertEquals("key1", e.nextElement());
        Assert.assertFalse(e.hasMoreElements());
    }
    private static class TesterResourceBundle extends ListResourceBundle {
        @Override
        protected Object[][] getContents() {
            return contents;
        }
        private static final Object[][] contents = {
            {"key1","value1"},
            {"key2","value2"}
        };
    }

    private static final String SEPARATOR = "/";
======= fetch "protected static void loadApplicationListenerAnnotations(Context context) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        Class<?> classClass = null;
======= fetch "protected static void loadApplicationListenerAnnotations(Context context) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

            loadClassAnnotation(context, applicationListeners[i]);
======= fetch "protected static void loadApplicationFilterAnnotations(Context context) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        Class<?> classClass = null;
======= fetch "protected static void loadApplicationFilterAnnotations(Context context) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

            loadClassAnnotation(context, (filterDefs[i]).getFilterClass());
======= fetch "protected static void loadApplicationServletAnnotations(Context context) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        ClassLoader classLoader = context.getLoader().getClassLoader();
======= fetch "protected static void loadApplicationServletAnnotations(Context context) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

                try {
                    classClass = classLoader.loadClass(wrapper.getServletClass());
                } catch (ClassNotFoundException e) {
                    // We do nothing
                } catch (NoClassDefFoundError e) {
                    // We do nothing
                }
======= fetch "protected static void loadApplicationServletAnnotations(Context context) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

                loadClassAnnotation(context, wrapper.getServletClass());
======= fetch "protected static void loadApplicationServletAnnotations(Context context) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    protected static void loadClassAnnotation(Context context, String fileString) {
        ClassLoader classLoader = context.getLoader().getClassLoader();
        Class<?> classClass = null;
        try {
            classClass = classLoader.loadClass(fileString);
        } catch (ClassNotFoundException e) {
            // We do nothing
        } catch (NoClassDefFoundError e) {
            // We do nothing
        }
        if (classClass == null) {
            return;
        }
======= fetch "protected static void loadClassAnnotation(Context context, String fileString) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

======= fetch "protected static void loadClassAnnotation(Context context, String fileString) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    }
======= fetch "protected static void loadClassAnnotation(Context context, String fileString) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    protected static void loadFieldsAnnotation(Context context,
            Class<?> classClass) {
        // Initialize the annotations
        Field[] fields = getDeclaredFields(classClass);
        if (fields != null && fields.length > 0) {
            for (Field field : fields) {
                if (field.isAnnotationPresent(Resource.class)) {
                    Resource annotation = field.getAnnotation(Resource.class);
                    String defaultName =
                            classClass.getName() + SEPARATOR + field.getName();
                    String defaultType = field.getType().getCanonicalName();
                    addResource(context, annotation, defaultName, defaultType);
                }
            }
        }
======= fetch "protected static void loadClassAnnotation(Context context, String fileString) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    protected static void loadMethodsAnnotation(Context context,
            Class<?> classClass) {
        // Initialize the annotations
        Method[] methods = getDeclaredMethods(classClass);
        if (methods != null && methods.length > 0) {
            for (Method method : methods) {
                if (method.isAnnotationPresent(Resource.class)) {
                    Resource annotation = method.getAnnotation(Resource.class);
                    checkBeanNamingConventions(method);
                    String defaultName = classClass.getName() + SEPARATOR +
                            DefaultInstanceManager.getName(method);
                    String defaultType =
                            (method.getParameterTypes()[0]).getCanonicalName();
                    addResource(context, annotation, defaultName, defaultType);
                }
            }
        }
    }
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        addResource(context, annotation, null, null);
    }
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        if (annotation.type().getCanonicalName().equals("java.lang.String") ||
                annotation.type().getCanonicalName().equals("java.lang.Character") ||
                annotation.type().getCanonicalName().equals("java.lang.Integer") ||
                annotation.type().getCanonicalName().equals("java.lang.Boolean") ||
                annotation.type().getCanonicalName().equals("java.lang.Double") ||
                annotation.type().getCanonicalName().equals("java.lang.Byte") ||
                annotation.type().getCanonicalName().equals("java.lang.Short") ||
                annotation.type().getCanonicalName().equals("java.lang.Long") ||
                annotation.type().getCanonicalName().equals("java.lang.Float")) {
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

            resource.setName(annotation.name());
            resource.setType(annotation.type().getCanonicalName());
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        } else if (annotation.type().getCanonicalName().equals("javax.xml.rpc.Service")) {
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

            service.setName(annotation.name());
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

            service.setType(annotation.type().getCanonicalName());
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        } else if (annotation.type().getCanonicalName().equals("javax.sql.DataSource") ||
                annotation.type().getCanonicalName().equals("javax.jms.ConnectionFactory") ||
                annotation.type().getCanonicalName()
                .equals("javax.jms.QueueConnectionFactory") ||
                annotation.type().getCanonicalName()
                .equals("javax.jms.TopicConnectionFactory") ||
                annotation.type().getCanonicalName().equals("javax.mail.Session") ||
                annotation.type().getCanonicalName().equals("java.net.URL") ||
                annotation.type().getCanonicalName()
                .equals("javax.resource.cci.ConnectionFactory") ||
                annotation.type().getCanonicalName().equals("org.omg.CORBA_2_3.ORB") ||
                annotation.type().getCanonicalName().endsWith("ConnectionFactory")) {
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

            resource.setName(annotation.name());
            resource.setType(annotation.type().getCanonicalName());
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        } else if (annotation.type().getCanonicalName().equals("javax.jms.Queue") ||
                annotation.type().getCanonicalName().equals("javax.jms.Topic")) {
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

            resource.setName(annotation.name());
            resource.setType(annotation.type().getCanonicalName());
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        } else if (annotation.type().getCanonicalName()
                .equals("javax.resource.cci.InteractionSpec") ||
                annotation.type().getCanonicalName()
                .equals("javax.transaction.UserTransaction") ||
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

            resource.setName(annotation.name());
            resource.setType(annotation.type().getCanonicalName());
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    }
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    private static void checkBeanNamingConventions(Method method) {
        if (!method.getName().startsWith("set")
                || method.getName().length() < 4
                || method.getParameterTypes().length != 1
                || !method.getReturnType().getName().equals("void")) {
            throw new IllegalArgumentException("Invalid method resource injection annotation.");
        }
======= fetch "protected static void addResource(Context context, Resource annotation) {" 67a926c^:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    private static String getType(Resource annotation, String defaultType) {
        String type = annotation.type().getCanonicalName();
        if (type == null || type.equals("java.lang.Object")) {
            if (defaultType != null) {
                type = defaultType;
            }
        }
        return type;
    }
    private static String getName(Resource annotation, String defaultName) {
        String name = annotation.name();
        if (name == null || name.equals("")) {
            if (defaultName != null) {
                name = defaultName;
            }
        }
        return name;
    }
    private static Field[] getDeclaredFields(Class<?> classClass) {
        Field[] fields = null;
        if (Globals.IS_SECURITY_ENABLED) {
            final Class<?> clazz = classClass;
            fields = AccessController.doPrivileged(
                    new PrivilegedAction<Field[]>(){
                @Override
                public Field[] run(){
                    return clazz.getDeclaredFields();
                }
            });
        } else {
            fields = classClass.getDeclaredFields();
        }
        return fields;
    }
    private static Method[] getDeclaredMethods(Class<?> classClass) {
        Method[] methods = null;
        if (Globals.IS_SECURITY_ENABLED) {
            final Class<?> clazz = classClass;
            methods = AccessController.doPrivileged(
                    new PrivilegedAction<Method[]>(){
                @Override
                public Method[] run(){
                    return clazz.getDeclaredMethods();
                }
            });
        } else {
            methods = classClass.getDeclaredMethods();
        }
        return methods;
    }
    private static Class<?> loadClass(Context context, String fileString) {
        ClassLoader classLoader = context.getLoader().getClassLoader();
        Class<?> classClass = null;
        try {
            classClass = classLoader.loadClass(fileString);
        } catch (ClassNotFoundException e) {
            // We do nothing
        } catch (NoClassDefFoundError e) {
            // We do nothing
        }
        return classClass;
    }

======= fetch "protected void initInternal() throws LifecycleException {" 6a8e480^:"java/org/apache/catalina/core/StandardServer.java"

            ClassLoader cl =
                    getCatalina().getParentClassLoader();
======= fetch "protected void initInternal() throws LifecycleException {" 6a8e480^:"java/org/apache/catalina/core/StandardServer.java"

            while (cl != ClassLoader.getSystemClassLoader()) {

    <attribute name="propagateInterruptState" required="false">
      <p>(boolean) Set this to true to propagate the interrupt state for a thread that has been interrupted (not clearing the interrupt state). Default value is <code>false</code> for backwards compatibility.
      </p>
    </attribute>
    
======= fetch "protected void close(boolean force) {" fe16ac2^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                Thread.interrupted();
======= fetch "private PooledConnection borrowConnection(int wait, String username, String pass" fe16ac2^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                Thread.interrupted();//clear the flag, and bail out
======= fetch "public boolean getLogValidationErrors() {" fe16ac2^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getPropagateInterruptState() {
        return getPoolProperties().getPropagateInterruptState();
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setPropagateInterruptState(boolean propagateInterruptState) {
        getPoolProperties().setPropagateInterruptState(propagateInterruptState);
    }
    /**
     * Returns true if the pool is configured to propagate interrupt state of a thread.
     * A thread waiting for a connection, can have its wait interrupted, and by default
     * will clear the interrupt flag and throw a {@link PoolExhaustedException}
     * @return true if the pool is configured to propagate and not clear the thread interrupt state
     */
    public boolean getPropagateInterruptState();
    /**
     * Configure the pool to propagate interrupt state for interrupted threads waiting for a connection
     * A thread waiting for a connection, can have its wait interrupted, and by default
     * will clear the interrupt flag and throw a {@link PoolExhaustedException}
     * If set to true, this behavior will change, while the {@link PoolExhaustedException} is still thrown, the threads interrupted state is still set.
     * @param propagateInterruptState - set to true to not clear, but propagate, a threads interrupted state.
     */
    public void setPropagateInterruptState(boolean propagateInterruptState);
    protected boolean propagateInterruptState = false;
======= fetch "public boolean getLogValidationErrors() {" fe16ac2^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getPropagateInterruptState() {
        return propagateInterruptState;
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setPropagateInterruptState(boolean propagateInterruptState) {
        this.propagateInterruptState = propagateInterruptState;
    }
======= fetch "public boolean getLogValidationErrors() {" fe16ac2^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getPropagateInterruptState() {
        return getPoolProperties().getPropagateInterruptState();
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setPropagateInterruptState(boolean propagateInterruptState) {
        getPoolProperties().setPropagateInterruptState(propagateInterruptState);
    }

======= fetch "public void removeValve(Valve valve) {" d5cee34^:"java/org/apache/catalina/core/StandardPipeline.java"

        // Stop this valve if necessary
        if (getState().isAvailable()) {
            if (valve instanceof Lifecycle) {
======= fetch "public void removeValve(Valve valve) {" d5cee34^:"java/org/apache/catalina/core/StandardPipeline.java"

        }
        try {
            ((Lifecycle) valve).destroy();
        } catch (LifecycleException e) {
            log.error("StandardPipeline.removeValve: destroy: ", e);

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Test DigestAuthenticator and NonLoginAuthenticator when a
 * SingleSignOn Valve is active.
 *
 * <p>
 * In the absence of SSO support, a webapp using NonLoginAuthenticator
 * simply cannot access protected resources. These tests exercise the
 * the way successfully authenticating a different webapp under the
 * DigestAuthenticator triggers the additional SSO logic for both webapps.
 *
 * <p>
 * Note: these tests are intended to exercise the SSO logic of the
 * Authenticator, but not to comprehensively test all of its logic paths.
 * That is the responsibility of the non-SSO test suite.
 */
    private static final String USER = "user";
    private static final String PWD = "pwd";
    private static final String ROLE = "role";
    private static final String HTTP_PREFIX = "http://localhost:";
    private static final String CONTEXT_PATH_NOLOGIN = "/nologin";
    private static final String CONTEXT_PATH_DIGEST = "/digest";
    private static final String URI_PROTECTED = "/protected";
    private static final String URI_PUBLIC = "/anyoneCanAccess";
    private static final int SHORT_TIMEOUT_SECS = 4;
    private static final long SHORT_TIMEOUT_DELAY_MSECS =
                                    ((SHORT_TIMEOUT_SECS + 3) * 1000);
    private static final int LONG_TIMEOUT_SECS = 10;
    private static final long LONG_TIMEOUT_DELAY_MSECS =
                                    ((LONG_TIMEOUT_SECS + 2) * 1000);
    private static final String CLIENT_AUTH_HEADER = "authorization";
    private static final String OPAQUE = "opaque";
    private static final String NONCE = "nonce";
    private static final String REALM = "realm";
    private static final String CNONCE = "cnonce";
    private static String NC1 = "00000001";
    private static String NC2 = "00000002";
    private static String QOP = "auth";
    private static String SERVER_COOKIES = "Set-Cookie";
    private static String BROWSER_COOKIES = "Cookie";
    private List<String> cookies;
    /**
     * Try to access an unprotected resource without an
     * established SSO session.
     * This should be permitted.
     */
    @Test
    public void testAcceptPublicNonLogin() throws Exception {
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PUBLIC,
                       true, false, 200);
    }
    /*
     * Try to access a protected resource without an established
     * SSO session.
     * This should be rejected with SC_FORBIDDEN 403 status.
     */
    @Test
    public void testRejectProtectedNonLogin() throws Exception {
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                       false, true, 403);
    }
    /**
     * Logon to access a protected resource using DIGEST authentication,
     * which will establish an SSO session.
     * Wait until the SSO session times-out, then try to re-access
     * the resource.
     * This should be rejected with SC_FORBIDDEN 401 status, which
     * will then be followed by successful re-authentication.
     */
    @Test
    public void testDigestLoginSessionTimeout() throws Exception {
        doTestDigest(USER, PWD, CONTEXT_PATH_DIGEST + URI_PROTECTED,
                     true, 401, true, true, NC1, CNONCE, QOP, true);
        // wait long enough for my session to expire
        Thread.sleep(LONG_TIMEOUT_DELAY_MSECS);
        // must change the client nonce to succeed
        doTestDigest(USER, PWD, CONTEXT_PATH_DIGEST + URI_PROTECTED,
                     true, 401, true, true, NC2, CNONCE, QOP, true);
   }
    /*
     * Logon to access a protected resource using DIGEST authentication,
     * which will establish an SSO session.
     * Immediately try to access a protected resource in the NonLogin
     * webapp, but without sending the SSO session cookie.
     * This should be rejected with SC_FORBIDDEN 403 status.
     */
    @Test
    public void testDigestLoginRejectProtectedWithoutCookies() throws Exception {
        doTestDigest(USER, PWD, CONTEXT_PATH_DIGEST + URI_PROTECTED,
                     true, 401, true, true, NC1, CNONCE, QOP, true);
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                       false, true, 403);
    }
    /*
     * Logon to access a protected resource using DIGEST authentication,
     * which will establish an SSO session.
     * Immediately try to access a protected resource in the NonLogin
     * webapp while sending the SSO session cookie provided by the
     * first webapp.
     * This should be successful with SC_OK 200 status.
     */
    @Test
    public void testDigestLoginAcceptProtectedWithCookies() throws Exception {
        doTestDigest(USER, PWD, CONTEXT_PATH_DIGEST + URI_PROTECTED,
                true, 401, true, true, NC1, CNONCE, QOP, true);
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                        true, false, 200);
    }
    /*
     * Logon to access a protected resource using DIGEST authentication,
     * which will establish an SSO session.
     * Immediately try to access a protected resource in the NonLogin
     * webapp while sending the SSO session cookie provided by the
     * first webapp.
     * This should be successful with SC_OK 200 status.
     *
     * Then, wait long enough for the DIGEST session to expire. (The SSO
     * session should remain active because the NonLogin session has
     * not yet expired).
     *
     * Try to access the protected resource again, before the SSO session
     * has expired.
     * This should be successful with SC_OK 200 status.
     *
     * Finally, wait for the non-login session to expire and try again..
     * This should be rejected with SC_FORBIDDEN 403 status.
     *
     * (see bugfix https://issues.apache.org/bugzilla/show_bug.cgi?id=52303)
     */
    @Test
    public void testDigestExpiredAcceptProtectedWithCookies() throws Exception {
        doTestDigest(USER, PWD, CONTEXT_PATH_DIGEST + URI_PROTECTED,
                true, 401, true, true, NC1, CNONCE, QOP, true);
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                        true, false, 200);
        // wait long enough for the BASIC session to expire,
        // but not long enough for NonLogin session expiry
        Thread.sleep(SHORT_TIMEOUT_DELAY_MSECS);
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                        true, false, 200);
        // wait long enough for my NonLogin session to expire
        // and tear down the SSO session at the same time.
        Thread.sleep(LONG_TIMEOUT_DELAY_MSECS);
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                        false, true, 403);
    }
    public void doTestNonLogin(String uri, boolean addCookies,
            boolean expectedReject, int expectedRC)
            throws Exception {
        Map<String,List<String>> reqHeaders =
                new HashMap<String,List<String>>();
        Map<String,List<String>> respHeaders =
                new HashMap<String,List<String>>();
        ByteChunk bc = new ByteChunk();
        if (addCookies) {
            addCookies(reqHeaders);
        }
        int rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders,
                respHeaders);
        if (expectedReject) {
            assertEquals(expectedRC, rc);
            assertTrue(bc.getLength() > 0);
        }
        else {
            assertEquals(200, rc);
            assertEquals("OK", bc.toString());
            saveCookies(respHeaders);
        }
    public void doTestDigest(String user, String pwd, String uri,
            boolean expectedReject1, int expectedRC1,
            boolean useServerNonce, boolean useServerOpaque,
            String nc1, String cnonce,
            String qop, boolean req2expect200)
            throws Exception {
        String digestUri= uri;
        List<String> auth = new ArrayList<String>();
        Map<String,List<String>> reqHeaders1 =
                new HashMap<String,List<String>>();
        Map<String,List<String>> respHeaders1 =
                new HashMap<String,List<String>>();
        // the first access attempt should be challenged
        auth.add(buildDigestResponse(user, pwd, digestUri, REALM, "null",
                "null", nc1, cnonce, qop));
        reqHeaders1.put(CLIENT_AUTH_HEADER, auth);
        ByteChunk bc = new ByteChunk();
        int rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders1,
                respHeaders1);
        if (expectedReject1) {
            assertEquals(expectedRC1, rc);
            assertTrue(bc.getLength() > 0);
        }
        else {
            assertEquals(200, rc);
            assertEquals("OK", bc.toString());
            saveCookies(respHeaders1);
            return;
        }
        // Second request should succeed (if we use the server nonce)
        Map<String,List<String>> reqHeaders2 =
                new HashMap<String,List<String>>();
        Map<String,List<String>> respHeaders2 =
                new HashMap<String,List<String>>();
        auth.clear();
        if (useServerNonce) {
            if (useServerOpaque) {
                auth.add(buildDigestResponse(user, pwd, digestUri,
                        getAuthToken(respHeaders1, REALM),
                        getAuthToken(respHeaders1, NONCE),
                        getAuthToken(respHeaders1, OPAQUE),
                        nc1, cnonce, qop));
            } else {
                auth.add(buildDigestResponse(user, pwd, digestUri,
                        getAuthToken(respHeaders1, REALM),
                        getAuthToken(respHeaders1, NONCE),
                        "null", nc1, cnonce, qop));
            }
        } else {
            auth.add(buildDigestResponse(user, pwd, digestUri,
                    getAuthToken(respHeaders2, REALM),
                    "null", getAuthToken(respHeaders1, OPAQUE),
                    nc1, cnonce, QOP));
        }
        reqHeaders2.put(CLIENT_AUTH_HEADER, auth);
        bc.recycle();
        rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders2,
                respHeaders2);
        if (req2expect200) {
            assertEquals(200, rc);
            assertEquals("OK", bc.toString());
            saveCookies(respHeaders2);
        } else {
            assertEquals(401, rc);
            assertTrue((bc.getLength() > 0));
        }
    }
    @Override
    public void setUp() throws Exception {
        super.setUp();
        // create a tomcat server using the default in-memory Realm
        Tomcat tomcat = getTomcatInstance();
        // associate the SingeSignOn Valve before the Contexts
        SingleSignOn sso = new SingleSignOn();
        tomcat.getHost().getPipeline().addValve(sso);
        // add the test user and role to the Realm
        tomcat.addUser(USER, PWD);
        tomcat.addRole(USER, ROLE);
        // setup both NonLogin, Login and digest webapps
        setUpNonLogin(tomcat);
        setUpDigest(tomcat);
        tomcat.start();
    }
    private void setUpNonLogin(Tomcat tomcat) throws Exception {
        // Must have a real docBase for webapps - just use temp
        Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN,
                System.getProperty("java.io.tmpdir"));
        ctxt.setSessionTimeout(LONG_TIMEOUT_SECS);
        // Add protected servlet
        Tomcat.addServlet(ctxt, "TesterServlet1", new TesterServlet());
        ctxt.addServletMapping(URI_PROTECTED, "TesterServlet1");
        SecurityCollection collection1 = new SecurityCollection();
        collection1.addPattern(URI_PROTECTED);
        SecurityConstraint sc1 = new SecurityConstraint();
        sc1.addAuthRole(ROLE);
        sc1.addCollection(collection1);
        ctxt.addConstraint(sc1);
        // Add unprotected servlet
        Tomcat.addServlet(ctxt, "TesterServlet2", new TesterServlet());
        ctxt.addServletMapping(URI_PUBLIC, "TesterServlet2");
        SecurityCollection collection2 = new SecurityCollection();
        collection2.addPattern(URI_PUBLIC);
        SecurityConstraint sc2 = new SecurityConstraint();
        // do not add a role - which signals access permitted without one
        sc2.addCollection(collection2);
        ctxt.addConstraint(sc2);
        // Configure the appropriate authenticator
        LoginConfig lc = new LoginConfig();
        lc.setAuthMethod("NONE");
        ctxt.setLoginConfig(lc);
        ctxt.getPipeline().addValve(new NonLoginAuthenticator());
    }
    private void setUpDigest(Tomcat tomcat) throws Exception {
        // Must have a real docBase for webapps - just use temp
        Context ctxt = tomcat.addContext(CONTEXT_PATH_DIGEST,
                System.getProperty("java.io.tmpdir"));
        ctxt.setSessionTimeout(SHORT_TIMEOUT_SECS);
        // Add protected servlet
        Tomcat.addServlet(ctxt, "TesterServlet3", new TesterServlet());
        ctxt.addServletMapping(URI_PROTECTED, "TesterServlet3");
        SecurityCollection collection = new SecurityCollection();
        collection.addPattern(URI_PROTECTED);
        SecurityConstraint sc = new SecurityConstraint();
        sc.addAuthRole(ROLE);
        sc.addCollection(collection);
        ctxt.addConstraint(sc);
        // Configure the appropriate authenticator
        LoginConfig lc = new LoginConfig();
        lc.setAuthMethod("DIGEST");
        ctxt.setLoginConfig(lc);
        ctxt.getPipeline().addValve(new DigestAuthenticator());
    }
    protected static String getAuthToken(
            Map<String,List<String>> respHeaders, String token) {
        final String AUTH_PREFIX = "=\"";
        final String AUTH_SUFFIX = "\"";
        List<String> authHeaders =
            respHeaders.get(AuthenticatorBase.AUTH_HEADER_NAME);
        // Assume there is only one
        String authHeader = authHeaders.iterator().next();
        String searchFor = token + AUTH_PREFIX;
        int start = authHeader.indexOf(searchFor) + searchFor.length();
        int end = authHeader.indexOf(AUTH_SUFFIX, start);
        return authHeader.substring(start, end);
    }
    /*
     * Notes from RFC2617
     * H(data) = MD5(data)
     * KD(secret, data) = H(concat(secret, ":", data))
     * A1 = unq(username-value) ":" unq(realm-value) ":" passwd
     * A2 = Method ":" digest-uri-value
     * request-digest  = <"> < KD ( H(A1),     unq(nonce-value)
                                    ":" nc-value
                                    ":" unq(cnonce-value)
                                    ":" unq(qop-value)
                                    ":" H(A2)
                                   ) <">
     */
    private static String buildDigestResponse(String user, String pwd,
            String uri, String realm, String nonce, String opaque, String nc,
            String cnonce, String qop) throws NoSuchAlgorithmException {
        String a1 = user + ":" + realm + ":" + pwd;
        String a2 = "GET:" + uri;
        String md5a1 = digest(a1);
        String md5a2 = digest(a2);
        String response;
        if (qop == null) {
            response = md5a1 + ":" + nonce + ":" + md5a2;
        } else {
            response = md5a1 + ":" + nonce + ":" + nc + ":" + cnonce + ":" +
                    qop + ":" + md5a2;
        }
        String md5response = digest(response);
        StringBuilder auth = new StringBuilder();
        auth.append("Digest username=\"");
        auth.append(user);
        auth.append("\", realm=\"");
        auth.append(realm);
        auth.append("\", nonce=\"");
        auth.append(nonce);
        auth.append("\", uri=\"");
        auth.append(uri);
        auth.append("\", opaque=\"");
        auth.append(opaque);
        auth.append("\", response=\"");
        auth.append(md5response);
        auth.append("\"");
        if (qop != null) {
            auth.append(", qop=\"");
            auth.append(qop);
            auth.append("\"");
        }
        if (nc != null) {
            auth.append(", nc=\"");
            auth.append(nc);
            auth.append("\"");
        }
        if (cnonce != null) {
            auth.append(", cnonce=\"");
            auth.append(cnonce);
            auth.append("\"");
        }
        return auth.toString();
    }
    private static String digest(String input) throws NoSuchAlgorithmException {
        // This is slow but should be OK as this is only a test
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        MD5Encoder encoder = new MD5Encoder();
        md5.update(input.getBytes());
        return encoder.encode(md5.digest());
    }
    /*
     * extract and save the server cookies from the incoming response
     */
    protected void saveCookies(Map<String,List<String>> respHeaders) {
        // we only save the Cookie values, not header prefix
        cookies = respHeaders.get(SERVER_COOKIES);
    }
    /*
     * add all saved cookies to the outgoing request
     */
    protected void addCookies(Map<String,List<String>> reqHeaders) {
        if ((cookies != null) && (cookies.size() > 0)) {
            reqHeaders.put(BROWSER_COOKIES + ":", cookies);
        }
    }

======= fetch "public boolean getUseDisposableConnectionFacade() {" e092870^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    protected boolean useDisposableConnectionFacade;
======= fetch "public boolean getUseDisposableConnectionFacade() {" e092870^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public void setLogValidationErrors(boolean logValidationErrors) {
        this.logValidationErrors = logValidationErrors;
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getLogValidationErrors() {
        return this.logValidationErrors;
    }
======= fetch "public boolean validate(int validateAction,String sql) {" e092870^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

                if (getPoolProperties().getLogValidationErrors()) {
                    log.error("Custom validation through "+poolProperties.getValidator()+" failed.");
                }
======= fetch "public boolean validate(int validateAction,String sql) {" e092870^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        } catch (Exception ignore) {
            if (log.isDebugEnabled())
                log.debug("Unable to validate object:",ignore);
======= fetch "public boolean getUseDisposableConnectionFacade() {" e092870^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public void setLogValidationErrors(boolean logValidationErrors) {
        getPoolProperties().setLogValidationErrors(logValidationErrors);
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getLogValidationErrors() {
        return getPoolProperties().getLogValidationErrors();
    }

======= fetch "private PooledConnection borrowConnection(int wait, String username, String pass" 9d687eb^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                throw new SQLException("[" + Thread.currentThread().getName()+"] " +
======= fetch "private PooledConnection borrowConnection(int wait, String username, String pass" 9d687eb^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                    throw new SQLException("[" + Thread.currentThread().getName()+"] " +
======= fetch "public PoolConfiguration getPoolProperties() {" 9d687eb^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    public static final String POOL_EMPTY = "POOL EMPTY";

======= fetch "protected String reportFailedQuery(String query, Object[] args, String name, lon" 0eb38b8^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java"

            if (log.isWarnEnabled()) {
                log.warn("Failed Query Report SQL="+sql+"; time="+delta+" ms;");
            }
======= fetch "protected String reportSlowQuery(String query, Object[] args, String name, long" 0eb38b8^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java"

            if (log.isWarnEnabled()) {
                log.warn("Slow Query Report SQL="+sql+"; time="+delta+" ms;");
            }

======= fetch "public boolean processSocket(NioChannel socket, SocketStatus status, boolean dis" dcb8808^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

            if (attachment == null) {
                return false;
            }

======= fetch "protected void doUnload() throws IOException {" 9f8c8d6^:"java/org/apache/catalina/session/StandardManager.java"

        BufferedOutputStream bos = null;
======= fetch "protected void doUnload() throws IOException {" 9f8c8d6^:"java/org/apache/catalina/session/StandardManager.java"

        boolean error = false;
======= fetch "protected void doUnload() throws IOException {" 9f8c8d6^:"java/org/apache/catalina/session/StandardManager.java"

            oos = new ObjectOutputStream(new BufferedOutputStream(fos));
======= fetch "protected void doUnload() throws IOException {" 9f8c8d6^:"java/org/apache/catalina/session/StandardManager.java"

            error = true;
======= fetch "protected void doUnload() throws IOException {" 9f8c8d6^:"java/org/apache/catalina/session/StandardManager.java"

            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException f) {
                    // Ignore
======= fetch "protected void doUnload() throws IOException {" 9f8c8d6^:"java/org/apache/catalina/session/StandardManager.java"

            throw e;

======= fetch "private void clearReferencesThreads() {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                    if (thread.getClass().getName().equals(
                            "java.util.TimerThread") &&
======= fetch "private void clearReferencesThreads() {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                        Field targetField =
                            thread.getClass().getDeclaredField("target");
                        targetField.setAccessible(true);
                        Object target = targetField.get(thread);
                        if (target != null &&
                                target.getClass().getCanonicalName().equals(
                                "java.util.concurrent.ThreadPoolExecutor.Worker")) {
                            Field executorField =
                                target.getClass().getDeclaredField("this$0");
                            executorField.setAccessible(true);
                            Object executor = executorField.get(target);
                            if (executor instanceof ThreadPoolExecutor) {
                                ((ThreadPoolExecutor) executor).shutdownNow();
======= fetch "private void clearReferencesStopTimerThread(Thread thread) {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            Field newTasksMayBeScheduledField =
                thread.getClass().getDeclaredField("newTasksMayBeScheduled");
            newTasksMayBeScheduledField.setAccessible(true);
            Field queueField = thread.getClass().getDeclaredField("queue");
            queueField.setAccessible(true);
======= fetch "private void clearReferencesStopTimerThread(Thread thread) {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            Object queue = queueField.get(thread);
======= fetch "private void clearReferencesStopTimerThread(Thread thread) {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            Method clearMethod = queue.getClass().getDeclaredMethod("clear");
            clearMethod.setAccessible(true);
======= fetch "private void clearReferencesStopTimerThread(Thread thread) {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            synchronized(queue) {
                newTasksMayBeScheduledField.setBoolean(thread, false);
                clearMethod.invoke(queue);
                queue.notify();  // In case queue was already empty.
======= fetch "private void checkThreadLocalsForLeaks() {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            Class<?> tlmClass =
                Class.forName("java.lang.ThreadLocal$ThreadLocalMap");
======= fetch "private void checkThreadLocalsForLeaks() {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            Method expungeStaleEntriesMethod = tlmClass.getDeclaredMethod("expungeStaleEntries");
            expungeStaleEntriesMethod.setAccessible(true);
======= fetch "private void checkThreadLocalsForLeaks() {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

======= fetch "private void checkThreadLocalsForLeaks() {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                    checkThreadLocalMapForLeaks(threadLocalMap, tableField);
======= fetch "private void checkThreadLocalsForLeaks() {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                    threadLocalMap =
                        inheritableThreadLocalsField.get(threads[i]);
                    checkThreadLocalMapForLeaks(threadLocalMap, tableField);
======= fetch "private void checkThreadLocalsForLeaks() {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        } catch (InvocationTargetException e) {
            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                    contextName), e);
        } catch (NoSuchMethodException e) {
            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                    contextName), e);
======= fetch "private boolean loadedByThisOrChild(Object o) {" adbf442^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            if(cl == this) {

======= fetch "public void visit(Node.InvokeAction n) throws JasperException {" faf26da^:"java/org/apache/jasper/compiler/Generator.java"

            // Restore EL context
            out.printil("jspContext.getELContext().putContext(javax.servlet.jsp.JspContext.class,getJspContext());");
======= fetch "public void generatePostamble() {" faf26da^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("Object _jspx_saved_JspContext = this.jspContext.getELContext().getContext(javax.servlet.jsp.JspContext.class);");
======= fetch "public void generatePostamble() {" faf26da^:"java/org/apache/jasper/compiler/Generator.java"

            // restore nested JspContext on ELContext
            out.printil("jspContext.getELContext().putContext(javax.servlet.jsp.JspContext.class,_jspx_saved_JspContext);");

    /**
     * The name of the class to use for retrieving user names from X509
     * certificates.
     */
    protected String x509UsernameRetrieverClassName;
    /**
     * The object that will extract user names from X509 client certificates.
     */
    protected X509UsernameRetriever x509UsernameRetriever;
======= fetch "public void setValidate(boolean validate) {" 401c703^:"java/org/apache/catalina/realm/RealmBase.java"

    /**
     * Gets the name of the class that will be used to extract user names
     * from X509 client certificates.
     * @return The name of the class that will be used to extract user names
     *         from X509 client certificates.
     */
    public String getX509UsernameRetrieverClassName()
    {
        return x509UsernameRetrieverClassName;
    }
    /**
     * Sets the name of the class that will be used to extract user names
     * from X509 client certificates. The class must implement
     * {@see X509UsernameRetriever}.
     *
     * @param className The name of the class that will be used to extract user names
     *                  from X509 client certificates.
     */
    public void setX509UsernameRetrieverClassName(String className)
    {
        this.x509UsernameRetrieverClassName = className;
    }
======= fetch "protected void initInternal() throws LifecycleException {" 401c703^:"java/org/apache/catalina/realm/RealmBase.java"

        
        x509UsernameRetriever = createUsernameRetriever(x509UsernameRetrieverClassName);
======= fetch "protected Principal getPrincipal(X509Certificate usercert) {" 401c703^:"java/org/apache/catalina/realm/RealmBase.java"

        return(getPrincipal(usercert.getSubjectDN().getName()));
======= fetch "public String toString()" 401c703^:"java/org/apache/catalina/realm/RealmBase.java"

    private static X509UsernameRetriever createUsernameRetriever(String className)
        throws LifecycleException {
        if(null == className || "".equals(className.trim()))
            return new X509SubjectDnRetriever();
        try {
            @SuppressWarnings("unchecked")
            Class<? extends X509UsernameRetriever> clazz = (Class<? extends X509UsernameRetriever>)Class.forName(className);
            return (X509UsernameRetriever)clazz.newInstance();
        } catch (ClassNotFoundException e) {
            throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.ClassNotFoundException", className), e);
        } catch (InstantiationException e) {
            throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.InstantiationException", className), e);
        } catch (IllegalAccessException e) {
            throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.IllegalAccessException", className), e);
        } catch (ClassCastException e) {
            throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.ClassCastException", className), e);
        }
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * An X509UsernameRetriever that returns a certificate's entire
 * SubjectDN as the username.
 */
    implements X509UsernameRetriever {
    public String getUsername(X509Certificate clientCert) {
        return clientCert.getSubjectDN().getName();
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Provides an interface for retrieving a user name from an X509Certificate.
 */
    /**
     * Gets a user name from an X509Certificate.
     *
     * @param cert The certificate containing the user name.
     * @return An appropriate user name obtained from one or more fields
     *         in the certificate.
     */
    public String getUsername(X509Certificate clientCert);
      <attribute name="X509UsernameRetrieverClassName" required="false">
        <p>When using X509 client certificates, this specifies the class name
        that will be used to retrieve the user name from the certificate.
        The class must implement the
        <code>org.apache.catalina.realm.X509UsernameRetriever</code>
        interface. The default is to use the certificate's SubjectDN
        as the username.</p>
      </attribute>
      <attribute name="X509UsernameRetrieverClassName" required="false">
        <p>When using X509 client certificates, this specifies the class name
        that will be used to retrieve the user name from the certificate.
        The class must implement the
        <code>org.apache.catalina.realm.X509UsernameRetriever</code>
        interface. The default is to use the certificate's SubjectDN
        as the username.</p>
      </attribute>
      <attribute name="X509UsernameRetrieverClassName" required="false">
        <p>When using X509 client certificates, this specifies the class name
        that will be used to retrieve the user name from the certificate.
        The class must implement the
        <code>org.apache.catalina.realm.X509UsernameRetriever</code>
        interface. The default is to use the certificate's SubjectDN
        as the username.</p>
      </attribute>
      <attribute name="X509UsernameRetrieverClassName" required="false">
        <p>When using X509 client certificates, this specifies the class name
        that will be used to retrieve the user name from the certificate.
        The class must implement the
        <code>org.apache.catalina.realm.X509UsernameRetriever</code>
        interface. The default is to use the certificate's SubjectDN
        as the username.</p>
      </attribute>
      <attribute name="X509UsernameRetrieverClassName" required="false">
        <p>When using X509 client certificates, this specifies the class name
        that will be used to retrieve the user name from the certificate.
        The class must implement the
        <code>org.apache.catalina.realm.X509UsernameRetriever</code>
        interface. The default is to use the certificate's SubjectDN
        as the username.</p>
      </attribute>
      <attribute name="X509UsernameRetrieverClassName" required="false">
        <p>When using X509 client certificates, this specifies the class name
        that will be used to retrieve the user name from the certificate.
        The class must implement the
        <code>org.apache.catalina.realm.X509UsernameRetriever</code>
        interface. The default is to use the certificate's SubjectDN
        as the username.</p>
      </attribute>

======= fetch "protected boolean validate(String name) {" 78c02a7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * @param jarfile The JAR file to be checked
======= fetch "protected boolean validate(String name) {" 78c02a7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

    protected boolean validateJarFile(File jarfile)
======= fetch "protected boolean validateJarFile(File jarfile)" 78c02a7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        JarFile jarFile = new JarFile(jarfile);
        for (int i = 0; i < triggers.length; i++) {
            Class<?> clazz = null;
            try {
                if (parent != null) {
                    clazz = parent.loadClass(triggers[i]);
                } else {
                    clazz = Class.forName(triggers[i]);
======= fetch "protected boolean validateJarFile(File jarfile)" 78c02a7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            } catch (Exception e) {
                clazz = null;
======= fetch "protected boolean validateJarFile(File jarfile)" 78c02a7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            if (clazz == null)
                continue;
            String name = triggers[i].replace('.', '/') + ".class";
            if (log.isDebugEnabled())
                log.debug(" Checking for " + name);
            JarEntry jarEntry = jarFile.getJarEntry(name);
            if (jarEntry != null) {
                log.info("validateJarFile(" + jarfile +
                    ") - jar not loaded. See Servlet Spec 2.3, "
                    + "section 9.7.2. Offending class: " + name);
                jarFile.close();
                return (false);
======= fetch "protected boolean validateJarFile(File jarfile)" 78c02a7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        jarFile.close();
        return (true);

======= fetch "public void unbind(Name name) throws NamingException {" 7cec4ff^:"java/org/apache/naming/NamingContext.java"

                (sm.getString("namingContext.nameNotBound", name.get(0)));
======= fetch "public void rename(String oldName, String newName)" 7cec4ff^:"java/org/apache/naming/NamingContext.java"

                (sm.getString("namingContext.nameNotBound", name.get(0)));
======= fetch "public void rename(String oldName, String newName)" 7cec4ff^:"java/org/apache/naming/NamingContext.java"

                (sm.getString("namingContext.nameNotBound", name.get(0)));
======= fetch "public void destroySubcontext(Name name) throws NamingException {" 7cec4ff^:"java/org/apache/naming/NamingContext.java"

                (sm.getString("namingContext.nameNotBound", name.get(0)));
======= fetch "protected Object lookup(Name name, boolean resolveLinks)" 7cec4ff^:"java/org/apache/naming/NamingContext.java"

                (sm.getString("namingContext.nameNotBound", name.get(0)));
======= fetch "protected void bind(Name name, Object obj, boolean rebind)" 7cec4ff^:"java/org/apache/naming/NamingContext.java"

                throw new NameNotFoundException
                    (sm.getString("namingContext.nameNotBound", name.get(0)));

======= fetch "public void execute() throws JasperException {" 35958df^:"java/org/apache/jasper/JspC.java"

            if( context==null ) {
======= fetch "public void execute() throws JasperException {" 35958df^:"java/org/apache/jasper/JspC.java"

                scanFiles( new File( uriRoot ));
            }
            File uriRootF = new File(uriRoot);
            if (!uriRootF.exists() || !uriRootF.isDirectory()) {
                throw new JasperException(
                    Localizer.getMessage("jsp.error.jspc.uriroot_not_dir"));

======= fetch "public int write(ByteBuffer buf, NioChannel socket, long writeTimeout)" 4f75b2d^:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"

                    att.awaitWriteLatch(writeTimeout,TimeUnit.MILLISECONDS);

 * When Tomcat is started, a database connection (with autoReconnect option)
 * is created and used for all the log activity. When Tomcat is shutdown, the
 * database connection is closed.
======= fetch "protected void open() throws SQLException {" 1f4663d^:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

        props.put("autoReconnect", "true");

======= fetch "public boolean authenticate(Request request, HttpServletResponse response)" a01418d^:"java/org/apache/catalina/authenticator/NonLoginAuthenticator.java"

        Principal principal = request.getUserPrincipal();

======= fetch "private static String getClassNameServices(ClassLoader tccl) {" 6399c83^:"java/javax/el/ExpressionFactory.java"

            InputStreamReader isr = null;
======= fetch "private static String getClassNameServices(ClassLoader tccl) {" 6399c83^:"java/javax/el/ExpressionFactory.java"

                br = new BufferedReader(new InputStreamReader(is, "UTF-8"));
======= fetch "private static String getClassNameServices(ClassLoader tccl) {" 6399c83^:"java/javax/el/ExpressionFactory.java"

                    if (isr != null) {
                        isr.close();
                    }
                } catch (IOException ioe) {/*Ignore*/}
                try {

======= fetch "protected void generateClass(String[] smap)" 2b1d195^:"java/org/apache/jasper/compiler/JDTCompiler.java"

                InputStreamReader isr = null;
======= fetch "protected void generateClass(String[] smap)" 2b1d195^:"java/org/apache/jasper/compiler/JDTCompiler.java"

                    reader = new BufferedReader(new InputStreamReader(is,
                            ctxt.getOptions().getJavaEncoding()));
======= fetch "protected void generateClass(String[] smap)" 2b1d195^:"java/org/apache/jasper/compiler/JDTCompiler.java"

                    if (isr != null) {
                        try {
                            isr.close();
                        } catch (IOException ioe) {/*Ignore*/}
                    }

======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 683d5c1^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                CometEventImpl cometEvent = request.getEvent();
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 683d5c1^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                    CometEventImpl cometEvent = request.getEvent();
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 683d5c1^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                    cometEvent.close();
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 683d5c1^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                } finally {
                    try {
                        cometEvent.close();
                    } catch (IOException e) {
                        container.getLogger().warn(sm.getString(
                                "cometConnectionManagerValve.event"), e);
                    }

======= fetch "protected void deployWAR(ContextName cn, File war) {" 8293a6e^:"java/org/apache/catalina/startup/HostConfig.java"

        FileOutputStream fos = null;
======= fetch "protected void deployWAR(ContextName cn, File war) {" 8293a6e^:"java/org/apache/catalina/startup/HostConfig.java"

                    ostream =
                        new BufferedOutputStream
                        (new FileOutputStream(xml), 1024);
======= fetch "protected void deployWAR(ContextName cn, File war) {" 8293a6e^:"java/org/apache/catalina/startup/HostConfig.java"

                    ostream.close();
                    ostream = null;
                    istream.close();
                    istream = null;
======= fetch "protected void deployWAR(ContextName cn, File war) {" 8293a6e^:"java/org/apache/catalina/startup/HostConfig.java"

                    } catch (Throwable t) {
                        ExceptionUtils.handleThrowable(t);
======= fetch "protected void deployWAR(ContextName cn, File war) {" 8293a6e^:"java/org/apache/catalina/startup/HostConfig.java"

                if (fos != null) {
                    try {
                        fos.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }
                    fos = null;
                }
======= fetch "protected void deployWAR(ContextName cn, File war) {" 8293a6e^:"java/org/apache/catalina/startup/HostConfig.java"

                    } catch (Throwable t) {
                        ExceptionUtils.handleThrowable(t);
======= fetch "protected void deployWAR(ContextName cn, File war) {" 8293a6e^:"java/org/apache/catalina/startup/HostConfig.java"

                    } catch (Throwable t) {
                        ExceptionUtils.handleThrowable(t);

======= fetch "public void open() throws Exception {" a30ce07^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                FileInputStream fis = new FileInputStream(file);
======= fetch "public void open() throws Exception {" a30ce07^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                FileInputStream fis = null;
======= fetch "public void open() throws Exception {" a30ce07^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                    fis =  new FileInputStream(file);
======= fetch "public void open() throws Exception {" a30ce07^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                    fis.close();
                } catch (Exception e) {
                    try {
                        fis.close();
                    } catch (Throwable t) {
                        ExceptionUtils.handleThrowable(t);
======= fetch "public void open() throws Exception {" a30ce07^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                    throw e;

======= fetch "public static String getTagHandlerClassName(String path, String urn," bf0287e^:"java/org/apache/jasper/compiler/JspUtil.java"

            className = "org.apache.jsp.tag.web.";
======= fetch "private static String getClassNameBase(String urn) {" bf0287e^:"java/org/apache/jasper/compiler/JspUtil.java"

        StringBuilder base = new StringBuilder("org.apache.jsp.tag.meta.");

======= fetch "public void stopServer(String[] arguments) {" 7c51f61^:"java/org/apache/catalina/startup/Catalina.java"

            FileInputStream fis = null;
======= fetch "public void stopServer(String[] arguments) {" 7c51f61^:"java/org/apache/catalina/startup/Catalina.java"

                FileInputStream fis = new FileInputStream(file);
======= fetch "public void stopServer(String[] arguments) {" 7c51f61^:"java/org/apache/catalina/startup/Catalina.java"

                fis.close();
======= fetch "public void stopServer(String[] arguments) {" 7c51f61^:"java/org/apache/catalina/startup/Catalina.java"

            } finally {
                if (fis != null) {
                    try {
                        fis.close();
                    } catch (IOException e) {
                        // Ignore
                    }
                }
======= fetch "public void stopServer(String[] arguments) {" 7c51f61^:"java/org/apache/catalina/startup/Catalina.java"

        try {
            if (s.getPort()>0) {
                Socket socket = new Socket(s.getAddress(), s.getPort());
                OutputStream stream = socket.getOutputStream();
======= fetch "public void stopServer(String[] arguments) {" 7c51f61^:"java/org/apache/catalina/startup/Catalina.java"

                stream.close();
                socket.close();
            } else {
                log.error(sm.getString("catalina.stopServer"));
======= fetch "public void stopServer(String[] arguments) {" 7c51f61^:"java/org/apache/catalina/startup/Catalina.java"

            } finally {
                if (stream != null) {
                    try {
                        stream.close();
                    } catch (IOException e) {
                        // Ignore
                    }
                }
                if (socket != null) {
                    try {
                        socket.close();
                    } catch (IOException e) {
                        // Ignore
                    }
                }
======= fetch "public void stopServer(String[] arguments) {" 7c51f61^:"java/org/apache/catalina/startup/Catalina.java"

        } catch (IOException e) {
            log.error("Catalina.stop: ", e);
======= fetch "public void stopServer(String[] arguments) {" 7c51f61^:"java/org/apache/catalina/startup/Catalina.java"

======= fetch "public void load() {" 7c51f61^:"java/org/apache/catalina/startup/Catalina.java"

            inputStream.close();
======= fetch "public void load() {" 7c51f61^:"java/org/apache/catalina/startup/Catalina.java"

        } finally {
            try {
                inputStream.close();
            } catch (IOException e) {
                // Ignore
            }


 *          &lt;param-name&gt;ExpiresByType text/javascript&lt;/param-name&gt;
 *       text/javascript=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]]}]
    &lt;param-name&gt;ExpiresByType text/javascript&lt;/param-name&gt;

======= fetch "protected void generateClass(String[] smap)" 2e7f5ab^:"java/org/apache/jasper/compiler/JDTCompiler.java"

            @SuppressWarnings("unused") // New method added to interface in
                                        // later JDT versions
            public boolean ignoreOptionalProblems() {
                return false;
            }

======= fetch "public static String dumpBeans(MBeanServer mbeanServer, Set<ObjectName> names)" 3fe64a5^:"java/org/apache/catalina/mbeans/MBeanDumper.java"

                        } else if (cause instanceof NullPointerException) {
                            log.debug("Error getting attribute " + oname +
                                    " " + attName, rme);

======= fetch "protected void webConfig() {" 34b1a7e^:"java/org/apache/catalina/startup/ContextConfig.java"

            ServletContext sContext = context.getServletContext();
======= fetch "protected void webConfig() {" 34b1a7e^:"java/org/apache/catalina/startup/ContextConfig.java"

                    // Hack required by Eclipse's "serve modules without
                    // publishing" feature since this backs WEB-INF/classes by
                    // multiple locations rather than one.
======= fetch "protected void webConfig() {" 34b1a7e^:"java/org/apache/catalina/startup/ContextConfig.java"

                                File webInfCLassDir = new File(
======= fetch "protected void webConfig() {" 34b1a7e^:"java/org/apache/catalina/startup/ContextConfig.java"

                                processAnnotationsFile(webInfCLassDir, webXml);
======= fetch "protected void webConfig() {" 34b1a7e^:"java/org/apache/catalina/startup/ContextConfig.java"

                    context.getServletContext().setAttribute(
======= fetch "protected void webConfig() {" 34b1a7e^:"java/org/apache/catalina/startup/ContextConfig.java"

                            mergedWebXml);

======= fetch "public static final boolean equals(final Object obj0, final Object obj1)" bf9bf39^:"java/org/apache/el/lang/ELSupport.java"

        } else if (obj0 instanceof Boolean || obj1 instanceof Boolean) {
            return coerceToBoolean(obj0).equals(coerceToBoolean(obj1));
        } else if (obj0.getClass().isEnum()) {
            return obj0.equals(coerceToEnum(obj1, obj0.getClass()));
        } else if (obj1.getClass().isEnum()) {
            return obj1.equals(coerceToEnum(obj0, obj1.getClass()));
        } else if (obj0 instanceof String || obj1 instanceof String) {
            int lexCompare = coerceToString(obj0).compareTo(coerceToString(obj1));
            return (lexCompare == 0) ? true : false;
        }
        if (isBigDecimalOp(obj0, obj1)) {
======= fetch "public static final boolean equals(final Object obj0, final Object obj1)" bf9bf39^:"java/org/apache/el/lang/ELSupport.java"

        }
        if (isDoubleOp(obj0, obj1)) {
======= fetch "public static final boolean equals(final Object obj0, final Object obj1)" bf9bf39^:"java/org/apache/el/lang/ELSupport.java"

        }
        if (isBigIntegerOp(obj0, obj1)) {
======= fetch "public static final boolean equals(final Object obj0, final Object obj1)" bf9bf39^:"java/org/apache/el/lang/ELSupport.java"

        }
        if (isLongOp(obj0, obj1)) {
======= fetch "public static final boolean equals(final Object obj0, final Object obj1)" bf9bf39^:"java/org/apache/el/lang/ELSupport.java"

        } else if (obj0 instanceof Boolean || obj1 instanceof Boolean) {
            return coerceToBoolean(obj0).equals(coerceToBoolean(obj1));
        } else if (obj0.getClass().isEnum()) {
            return obj0.equals(coerceToEnum(obj1, obj0.getClass()));
        } else if (obj1.getClass().isEnum()) {
            return obj1.equals(coerceToEnum(obj0, obj1.getClass()));
        } else if (obj0 instanceof String || obj1 instanceof String) {
            int lexCompare = coerceToString(obj0).compareTo(coerceToString(obj1));
            return (lexCompare == 0) ? true : false;
    public void testEquals() {
        assertTrue(ELSupport.equals("01", Long.valueOf(1)));
    }
    @Test

======= fetch "protected void initInternal() throws LifecycleException {" 4b6d583^:"java/org/apache/catalina/core/StandardServer.java"

        addFolderList("catalina.ext.dirs");

======= fetch "public final void action(ActionCode actionCode, Object param) {" 6f766be^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

            endOfStream = false;

======= fetch "public static String dumpBeans(MBeanServer mbeanServer, Set<ObjectName> names)" fbf9166^:"java/org/apache/catalina/mbeans/MBeanDumper.java"

                    } catch (JMRuntimeException rme) {
                        Throwable cause = rme.getCause();
                        if (cause instanceof UnsupportedOperationException) {
                            log.debug("Error getting attribute " + oname +
                                    " " + attName, rme);
                        } else {
                            log.error("Error getting attribute " + oname +
                                    " " + attName, rme);
                        }
                        continue;
======= fetch "public static String dumpBeans(MBeanServer mbeanServer, Set<ObjectName> names)" fbf9166^:"java/org/apache/catalina/mbeans/MBeanDumper.java"

                            " " + attName, t);

======= fetch "private boolean custom(Request request, Response response," 660513c^:"java/org/apache/catalina/core/StandardHostValve.java"

        request.setPathInfo(errorPage.getLocation());

======= fetch "public void reset() {" 2fd117b^:"java/org/apache/catalina/connector/OutputBuffer.java"

        reset(false);
    }
    public void reset(boolean resetWriterStreamFlags) {
======= fetch "public void reset() {" 2fd117b^:"java/org/apache/catalina/connector/OutputBuffer.java"

        gotEnc = false;
        enc = null;
======= fetch "public void resetBuffer(boolean resetWriterStreamFlags) {" 2fd117b^:"java/org/apache/catalina/connector/Response.java"

        outputBuffer.reset();
======= fetch "public void testWriteSpeed() throws Exception {" 2fd117b^:"test/org/apache/catalina/connector/TestOutputBuffer.java"

    @Test
    public void testBug52577() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        Context root = tomcat.addContext("", TEMP_DIR);
        Bug52577Servlet bug52577 = new Bug52577Servlet();
        Tomcat.addServlet(root, "bug52577", bug52577);
        root.addServletMapping("/", "bug52577");
        tomcat.start();
        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() + "/", bc, null, null);
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertEquals("OK", bc.toString());
    }
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 2fd117b^:"test/org/apache/catalina/connector/TestOutputBuffer.java"

    private static class Bug52577Servlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            Writer w = resp.getWriter();
            w.write("OK");
            resp.resetBuffer();
            w.write("OK");
        }
    }

======= fetch "public void setParent(Container container) {" 49a52cb^:"java/org/apache/catalina/core/StandardEngine.java"

    @Override
    protected void initInternal() throws LifecycleException {
        // Ensure that a Realm is present before any attempt is made to start
        // one. This will create the default NullRealm if necessary.
        getRealm();
        super.initInternal();
    }

        new LinkedHashMap<ServletContainerInitializer, Set<Class<?>>>();
        new HashMap<Class<?>, Set<ServletContainerInitializer>>();
======= fetch "protected void webConfig() {" f4896de^:"java/org/apache/catalina/startup/ContextConfig.java"

                // Cache, if used, is no longer required so clear it
                javaClassCache.clear();
======= fetch "protected void processServletContainerInitializers(" f4896de^:"java/org/apache/catalina/startup/ContextConfig.java"

                        if (type.isAnnotation()) {
                            handlesTypesAnnotations = true;
                        } else {
                            handlesTypesNonAnnotations = true;
                        }
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" f4896de^:"java/org/apache/catalina/startup/ContextConfig.java"

        // No choice but to load the class
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" f4896de^:"java/org/apache/catalina/startup/ContextConfig.java"

        if (handlesTypesNonAnnotations) {
            // This *might* be match for a HandlesType.
            populateJavaClassCache(className, javaClass);
            JavaClassCacheEntry entry = javaClassCache.get(className);
            if (entry.getSciSet() == null) {
                populateSCIsForCacheEntry(entry);
            }
            if (entry.getSciSet().size() > 0) {
                // Need to try and load the class
                clazz = loadClass(className);
                if (clazz == null) {
                    // Can't load the class so no point continuing
                    return;
                }
                for (ServletContainerInitializer sci :
                        entry.getSciSet()) {
                    Set<Class<?>> classes = initializerClassMap.get(sci);
                    if (classes == null) {
                        classes = new HashSet<Class<?>>();
                        initializerClassMap.put(sci, classes);
                    }
                    classes.add(clazz);
                }
            }
        }
        if (handlesTypesAnnotations) {
            for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry :
                    typeInitializerMap.entrySet()) {
                if (entry.getKey().isAnnotation()) {
                    AnnotationEntry[] annotationEntries =
                            javaClass.getAnnotationEntries();
                    for (AnnotationEntry annotationEntry : annotationEntries) {
                        if (entry.getKey().getName().equals(
                                getClassName(annotationEntry.getAnnotationType()))) {
                            if (clazz == null) {
                                clazz = loadClass(className);
                                if (clazz == null) {
                                    // Can't load the class so no point
                                    // continuing
                                    return;
                                }
                            }
                            for (ServletContainerInitializer sci : entry.getValue()) {
                                initializerClassMap.get(sci).add(clazz);
                            }
                            break;
                        }
                    }
                }
            }
        }
    }
    private void populateJavaClassCache(String className, JavaClass javaClass) {
        if (javaClassCache.containsKey(className)) {
            return;
        }
        // Add this class to the cache
        javaClassCache.put(className, new JavaClassCacheEntry(javaClass));
        populateJavaClassCache(javaClass.getSuperclassName());
        for (String iterface : javaClass.getInterfaceNames()) {
            populateJavaClassCache(iterface);
        }
    }
    private void populateJavaClassCache(String className) {
        if (!javaClassCache.containsKey(className)) {
            String name = className.replace('.', '/') + ".class";
            InputStream is =
                    context.getLoader().getClassLoader().getResourceAsStream(name);
            ClassParser parser = new ClassParser(is, null);
            try {
                JavaClass clazz = parser.parse();
                populateJavaClassCache(clazz.getClassName(), clazz);
            } catch (ClassFormatException e) {
                log.debug(sm.getString("contextConfig.invalidSciHandlesTypes",
                        className), e);
            } catch (IOException e) {
                log.debug(sm.getString("contextConfig.invalidSciHandlesTypes",
                        className), e);
            }
        }
    }
    private void populateSCIsForCacheEntry(JavaClassCacheEntry cacheEntry) {
        Set<ServletContainerInitializer> result =
                new HashSet<ServletContainerInitializer>();
        JavaClass javaClass = cacheEntry.getJavaClass();
        // Super class
        String superClassName = javaClass.getSuperclassName();
        JavaClassCacheEntry superClassCacheEntry =
                javaClassCache.get(superClassName);
        // Avoid an infinite loop with java.lang.Object
        if (cacheEntry.equals(superClassCacheEntry)) {
            cacheEntry.setSciSet(new HashSet<ServletContainerInitializer>());
            return;
        }
        // May be null of the class is not present or could not be loaded.
        if (superClassCacheEntry != null) {
            if (superClassCacheEntry.getSciSet() == null) {
                populateSCIsForCacheEntry(superClassCacheEntry);
            }
            result.addAll(superClassCacheEntry.getSciSet());
        }
        result.addAll(getSCIsForClass(superClassName));
        // Interfaces
        for (String interfaceName : javaClass.getInterfaceNames()) {
            JavaClassCacheEntry interfaceEntry =
                    javaClassCache.get(interfaceName);
            // A null could mean that the class not present in application or
            // that there is nothing of interest. Either way, nothing to do here
            // so move along
            if (interfaceEntry != null) {
                if (interfaceEntry.getSciSet() == null) {
                    populateSCIsForCacheEntry(interfaceEntry);
                }
                result.addAll(interfaceEntry.getSciSet());
            }
            result.addAll(getSCIsForClass(interfaceName));
        }
        cacheEntry.setSciSet(result);
    }
    private Set<ServletContainerInitializer> getSCIsForClass(String className) {
        for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry :
                typeInitializerMap.entrySet()) {
            Class<?> clazz = entry.getKey();
            if (!clazz.isAnnotation()) {
                if (clazz.getName().equals(className)) {
                    return entry.getValue();
                }
            }
        }
        return Collections.emptySet();
    }
    private Class<?> loadClass(String className) {
        Class<?> clazz = null;
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" f4896de^:"java/org/apache/catalina/startup/ContextConfig.java"

            return;
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" f4896de^:"java/org/apache/catalina/startup/ContextConfig.java"

            return;
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" f4896de^:"java/org/apache/catalina/startup/ContextConfig.java"

            return;
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" f4896de^:"java/org/apache/catalina/startup/ContextConfig.java"

            return;
        }
        if (clazz.isAnnotation()) {
            // Skip
            return;
        }
        boolean match = false;
        for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry :
                typeInitializerMap.entrySet()) {
            if (entry.getKey().isAnnotation()) {
                AnnotationEntry[] annotationEntries = javaClass.getAnnotationEntries();
                for (AnnotationEntry annotationEntry : annotationEntries) {
                    if (entry.getKey().getName().equals(
                        getClassName(annotationEntry.getAnnotationType()))) {
                        match = true;
                        break;
                    }
                }
            } else if (entry.getKey().isAssignableFrom(clazz)) {
                match = true;
            }
            if (match) {
                for (ServletContainerInitializer sci : entry.getValue()) {
                    initializerClassMap.get(sci).add(clazz);
                }
                match = false;
            }
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" f4896de^:"java/org/apache/catalina/startup/ContextConfig.java"

        return clazz;
======= fetch "public long getHostTimeStamp() {" f4896de^:"java/org/apache/catalina/startup/ContextConfig.java"

    private static class JavaClassCacheEntry {
        private final JavaClass javaClass;
        private Set<ServletContainerInitializer> sciSet = null;
        public JavaClassCacheEntry(JavaClass javaClass) {
            this.javaClass = javaClass;
        }
        public JavaClass getJavaClass() {
            return javaClass;
        }
        public Set<ServletContainerInitializer> getSciSet() {
            return sciSet;
        }
        public void setSciSet(Set<ServletContainerInitializer> sciSet) {
            this.sciSet = sciSet;
        }
    }
======= fetch "public String getClassName() {" f4896de^:"java/org/apache/tomcat/util/bcel/classfile/JavaClass.java"

     * @return Names of implemented interfaces.
     */
    public String[] getInterfaceNames() {
        return interface_names;
    }
    /**
     * returns the super class name of this class. In the case that this class is
     * java.lang.Object, it will return itself (java.lang.Object). This is probably incorrect
     * but isn't fixed at this time to not break existing clients.
     *
     * @return Superclass name.
     */
    public String getSuperclassName() {
        return superclass_name;
    }
    /**
======= fetch "public void testCheckHandleTypes() throws Exception {" f4896de^:"test/org/apache/catalina/startup/TestContextConfigAnnotation.java"

        config.handlesTypesAnnotations = true;
        config.handlesTypesNonAnnotations = true;

======= fetch "public void recycle() {" f2edc92^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        byteCount = 0;

======= fetch "protected void write(ByteChunk bc) {" ee0562d^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        checkLengthBeforeWrite(length);
======= fetch "protected void write(CharChunk cc) {" ee0562d^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        checkLengthBeforeWrite(end-start);
======= fetch "public void write(byte[] b) {" ee0562d^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        checkLengthBeforeWrite(b.length);
======= fetch "protected void write(String s) {" ee0562d^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        checkLengthBeforeWrite(len);
======= fetch "protected void write(int i) {" ee0562d^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

    /**
     * Checks to see if there is enough space in the buffer to write the
     * requested number of bytes.
     */
    private void checkLengthBeforeWrite(int length)
            throws IllegalStateException {
        if (pos + length > buf.length) {
            throw new IllegalStateException(
                    sm.getString("iob.responseheadertoolarge.error"));
        }
    }

======= fetch "protected void webConfig() {" 3277494^:"java/org/apache/catalina/startup/ContextConfig.java"

                    NamingEnumeration<Binding> listBindings = null;
======= fetch "protected void webConfig() {" 3277494^:"java/org/apache/catalina/startup/ContextConfig.java"

                        NamingEnumeration<Binding> listBindings =
                            context.getResources().listBindings("/WEB-INF/classes");
                        while (listBindings.hasMoreElements()) {
======= fetch "protected void webConfig() {" 3277494^:"java/org/apache/catalina/startup/ContextConfig.java"

                                File webInfCLassDir =
                                    new File(
  metadata-complete="true">

======= fetch "public void body(String namespace, String name, String text)" 2dd8a40^:"java/org/apache/catalina/startup/TldRuleSet.java"

            tldConfig.addApplicationListener(text);

======= fetch "public void execute(String command, InputStream istream," 9722128^:"java/org/apache/catalina/ant/AbstractCatalinaTask.java"

                Base64.encode(input.getBytes(Charset.defaultCharset()));
======= fetch "protected String generateNonce(Request request) {" 9722128^:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

                    ipTimeKey.getBytes(Charset.defaultCharset()));
======= fetch "public boolean validate(Request request, String authorization," 9722128^:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

                        serverIpTimeKey.getBytes(Charset.defaultCharset()));
======= fetch "public Principal authenticate(Realm realm) {" 9722128^:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

                buffer = md5Helper.digest(a2.getBytes(Charset.defaultCharset()));
======= fetch "protected boolean compareCredentials(DirContext context," 9722128^:"java/org/apache/catalina/realm/JNDIRealm.java"

                    md.update(credentials.getBytes(Charset.defaultCharset()));
======= fetch "protected boolean compareCredentials(DirContext context," 9722128^:"java/org/apache/catalina/realm/JNDIRealm.java"

                    md.update(credentials.getBytes(Charset.defaultCharset()));
======= fetch "protected boolean compareCredentials(DirContext context," 9722128^:"java/org/apache/catalina/realm/JNDIRealm.java"

                        pwbc.append(password.getBytes(Charset.defaultCharset()),
======= fetch "protected Charset getDigestCharset() throws UnsupportedEncodingException {" 9722128^:"java/org/apache/catalina/realm/RealmBase.java"

            return Charset.defaultCharset();
======= fetch "protected void doLock(HttpServletRequest req, HttpServletResponse resp)" 9722128^:"java/org/apache/catalina/servlets/WebdavServlet.java"

                    lockTokenStr.getBytes(Charset.defaultCharset())));
======= fetch "public static String URLDecode(String str, String enc, boolean isQuery) {" 9722128^:"java/org/apache/catalina/util/RequestUtil.java"

        // encoding is not specified, let it use platform default
======= fetch "public static String URLDecode(String str, String enc, boolean isQuery) {" 9722128^:"java/org/apache/catalina/util/RequestUtil.java"

                bytes = str.getBytes(Charset.defaultCharset());
======= fetch "protected synchronized void open() {" 9722128^:"java/org/apache/catalina/valves/AccessLogValve.java"

            charset = Charset.defaultCharset();
======= fetch "public void invoke(Request request, Response response)" 9722128^:"java/org/apache/catalina/valves/SSLValve.java"

                    strcerts.getBytes(Charset.defaultCharset()));
        ENCODING.setBytes(ENCODING_NAME.getBytes(Charset.defaultCharset()), 0,
        ENCODING.setBytes(ENCODING_NAME.getBytes(Charset.defaultCharset()), 0,
        ENCODING.setBytes(ENCODING_NAME.getBytes(Charset.defaultCharset()), 0,
        ENCODING.setBytes(ENCODING_NAME.getBytes(Charset.defaultCharset()), 0,
======= fetch "public static void installSmap(String[] smap)" 9722128^:"java/org/apache/jasper/compiler/SmapUtil.java"

                    smap[i+1].getBytes(Charset.defaultCharset()));
======= fetch "public Object lookup(String name)" 9722128^:"java/org/apache/naming/resources/ProxyDirContext.java"

                (object.toString().getBytes(Charset.defaultCharset())));
======= fetch "public CacheEntry lookupCache(String name) {" 9722128^:"java/org/apache/naming/resources/ProxyDirContext.java"

                        (object.toString().getBytes(Charset.defaultCharset())));
======= fetch "protected void cacheLoad(CacheEntry entry) {" 9722128^:"java/org/apache/naming/resources/ProxyDirContext.java"

                        (object.toString().getBytes(Charset.defaultCharset())));
======= fetch "public void toBytes() {" 9722128^:"java/org/apache/tomcat/util/buf/MessageBytes.java"

        byte bb[] = strValue.getBytes(Charset.defaultCharset());

======= fetch "private void setClassPath() {" b553519^:"java/org/apache/catalina/loader/WebappLoader.java"

                    repository = repository.substring(7);
======= fetch "private void setClassPath() {" b553519^:"java/org/apache/catalina/loader/WebappLoader.java"

                    repository = repository.substring(5);
======= fetch "private void setClassPath() {" b553519^:"java/org/apache/catalina/loader/WebappLoader.java"

    private String utf8Decode(String input) {
        String result = null;
        try {
            result = URLDecoder.decode(input, "UTF-8");
        } catch (UnsupportedEncodingException uee) {
            // Impossible. All JVMs are required to support UTF-8.
        }
        return result;
    }

======= fetch "public void doGet(HttpServletRequest request," bd478e5^:"java/org/apache/catalina/manager/JMXProxyServlet.java"

        qry = request.getParameter("invoke");
        if(qry != null) {
            String opName=request.getParameter("op");
            String ps = request.getParameter("ps");
            String[] valuesStr;
            if (ps == null) {
                valuesStr = new String[0];
            } else {
                valuesStr = request.getParameter("ps").split(",");
            }
            invokeOperation( writer, qry, opName,valuesStr );
            return;
        }
======= fetch "public void getAttribute(PrintWriter writer, String onameStr, String att) {" bd478e5^:"java/org/apache/catalina/manager/JMXProxyServlet.java"

            writer.println("Error - " + ex.toString());
======= fetch "public void setAttribute( PrintWriter writer," bd478e5^:"java/org/apache/catalina/manager/JMXProxyServlet.java"

            writer.println("Error - " + ex.toString());
======= fetch "public void listBeans( PrintWriter writer, String qry )" bd478e5^:"java/org/apache/catalina/manager/JMXProxyServlet.java"

        } catch (Exception e) {
            writer.println("Error - " + e.toString());
======= fetch "public boolean isSupported(String type) {" bd478e5^:"java/org/apache/catalina/manager/JMXProxyServlet.java"

    private void invokeOperation(PrintWriter writer, String onameStr, String op,
            String[] valuesStr) {
        try {
            ObjectName oname=new ObjectName( onameStr );
            MBeanOperationInfo methodInfo = registry.getMethodInfo(oname,op);
            MBeanParameterInfo[] signature = methodInfo.getSignature();
            String[] signatureTypes = new String[signature.length];
            Object[] values = new Object[signature.length];
            for (int i = 0; i < signature.length; i++) {
               MBeanParameterInfo pi = signature[i];
               signatureTypes[i] = pi.getType();
               values[i] = registry.convertValue(pi.getType(), valuesStr[i] );
           }
            Object retVal = mBeanServer.invoke(oname,op,values,signatureTypes);
            writer.println("OK - Operation " + op + " returned:");
            output("", writer, retVal);
        } catch( Exception ex ) {
            writer.println("Error");
            ex.printStackTrace(writer);
        }
    }
    private void output(String indent, PrintWriter writer, Object result) {
        if (result instanceof Object[]) {
            for (Object obj : (Object[]) result) {
                output("  " + indent, writer, obj);
            }
        } else {
            writer.println(indent + result.toString());
        }
    }
  <subsection name="JMX Invoke command">
    <p>The <code>invoke</code> command enables methods to be called on MBeans. The
    general form of the command is:</p>
    <p>For exmaple, to call the <code>findConnectors()</code> method of the
    <strong>Service</strong> use:</p>
  </subsection>

    implements LifecycleListener {
======= fetch "private WebXml getDefaultWebXmlFragment() {" 53615e5^:"java/org/apache/catalina/startup/ContextConfig.java"

                File f = new File(new URI(globalWebXml.getSystemId()));
                globalTimeStamp = f.lastModified();
            } catch (URISyntaxException e) {
======= fetch "private WebXml getDefaultWebXmlFragment() {" 53615e5^:"java/org/apache/catalina/startup/ContextConfig.java"

                File f = new File(new URI(hostWebXml.getSystemId()));
                hostTimeStamp = f.lastModified();
            } catch (URISyntaxException e) {

======= fetch "public Object invoke(EvaluationContext ctx," 3c8f40f^:"java/org/apache/el/parser/AstValue.java"

            values = ((AstMethodParameters)
                    this.jjtGetChild(2)).getParameters(ctx);
======= fetch "public boolean isParametersProvided() {" 3c8f40f^:"java/org/apache/el/parser/AstValue.java"

        if (this.children.length > 2
                && this.jjtGetChild(2) instanceof AstMethodParameters) {
            return true;
======= fetch "public void testBug50790b() throws Exception {" 3c8f40f^:"test/org/apache/el/TestMethodExpressionImpl.java"

    @Test
    public void testBug52445a() {
        MethodExpression me = factory.createMethodExpression(context,
                "${beanA.setBean(beanBB)}", null ,
                new Class<?>[] { TesterBeanB.class });
        me.invoke(context, null);
        MethodExpression me1 = factory.createMethodExpression(context,
                "${beanA.bean.sayHello()}", null, null);
        String actual = (String) me1.invoke(context, null);
        assertEquals("Hello from BB", actual);
    }

 * behavior of the <pre>addWebapp</pre> methods, you may want to call three
 * methods of this class: {@link #getDefaultRealm()},
 * {@link #noDefaultWebXmlPath()}, and {@link #getDefaultWebXmlListener()}.
    // Default in-memory realm, will be set by default on
    // created contexts. Can be replaced with setRealm() on
    // the context.
    protected Realm defaultRealm;
======= fetch "public Host getHost() {" c38ed95^:"java/org/apache/catalina/startup/Tomcat.java"

     * Set a custom realm for auth. If not called, a simple
     * default will be used, using an internal map.
     *
     * Must be called before adding a context.
     */
    public void setDefaultRealm(Realm realm) {
        defaultRealm = realm;
    }
    /**
======= fetch "public Engine getEngine() {" c38ed95^:"java/org/apache/catalina/startup/Tomcat.java"

            engine.setRealm(createDefaultRealm());
======= fetch "public Context addWebapp(Host host, String url, String name, String path) {" c38ed95^:"java/org/apache/catalina/startup/Tomcat.java"

        if (defaultRealm == null) {
            initSimpleAuth();
        }
        ctx.setRealm(defaultRealm);
======= fetch "public String noDefaultWebXmlPath() {" c38ed95^:"java/org/apache/catalina/startup/Tomcat.java"

    /**
     * For complex configurations, this accessor allows callers of this class
     * to obtain the simple realm created by default.
     * @return the simple in-memory realm created by default.
     */
    public Realm getDefaultRealm() {
        if (defaultRealm == null) {
            initSimpleAuth();
        }
        return defaultRealm;
    }
======= fetch "public Realm getDefaultRealm() {" c38ed95^:"java/org/apache/catalina/startup/Tomcat.java"

     * Initialize an in-memory realm. You can replace it
     * for contexts with a real one.
======= fetch "public Realm getDefaultRealm() {" c38ed95^:"java/org/apache/catalina/startup/Tomcat.java"

    protected void initSimpleAuth() {
        defaultRealm = new RealmBase() {

======= fetch "public ClassLoader run() {" ee2a461^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        "javax.servlet.Servlet"                     // Servlet API
======= fetch "protected boolean validate(String name) {" ee2a461^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (name.startsWith("javax.el")) {
            // Must never load javax.el.* classes
            return false;
        }

======= fetch "public void setImage(String image) {" f277b14^:"java/org/apache/el/parser/AstIdentifier.java"

    @Override
    public ValueReference getValueReference(EvaluationContext ctx) {
        VariableMapper varMapper = ctx.getVariableMapper();
        if (varMapper == null) {
            return null;
        }
        ValueExpression expr = varMapper.resolveVariable(this.image);
        if (expr == null) {
            return null;
        }
        return expr.getValueReference(ctx);
    }
======= fetch "public void testGetValueReference() {" f277b14^:"test/org/apache/el/TestValueExpressionImpl.java"

    public void testGetValueReferenceVariable() {
        ExpressionFactory factory = ExpressionFactory.newInstance();
        ELContext context = new ELContextImpl();
        TesterBeanB beanB = new TesterBeanB();
        beanB.setName("Tomcat");
        ValueExpression var =
            factory.createValueExpression(beanB, TesterBeanB.class);
        context.getVariableMapper().setVariable("beanB", var);
        ValueExpression var2 = factory.createValueExpression(
                context, "${beanB.name}", String.class);
        context.getVariableMapper().setVariable("foo", var2);
        ValueExpression ve = factory.createValueExpression(
                context, "${foo}", ValueExpression.class);
        // Now check the value reference
        ValueReference vr = ve.getValueReference(context);
        assertNotNull(vr);
        assertEquals(beanB, vr.getBase());
        assertEquals("name", vr.getProperty());
    }
    @Test

======= fetch "protected void doFlush(boolean realFlush)" 9c7ec4c^:"java/org/apache/catalina/connector/OutputBuffer.java"

        // Flush the convertor if one is in use
        if (gotEnc && conv != null) {
            conv.flushBuffer();
        }
======= fetch "public void write(int c)" 9c7ec4c^:"java/org/apache/catalina/connector/OutputBuffer.java"

        conv.flushBuffer();
======= fetch "public void write(char c[], int off, int len)" 9c7ec4c^:"java/org/apache/catalina/connector/OutputBuffer.java"

        conv.flushBuffer();
======= fetch "public void write(String s, int off, int len)" 9c7ec4c^:"java/org/apache/catalina/connector/OutputBuffer.java"

        conv.flushBuffer();
======= fetch "public void write(String s)" 9c7ec4c^:"java/org/apache/catalina/connector/OutputBuffer.java"

        conv.flushBuffer();
======= fetch "public void reset() {" 9c7ec4c^:"java/org/apache/catalina/connector/OutputBuffer.java"

        // If a Writer wasbeing used, there may be unflushed bytes in the
        // convertor
        if (gotEnc && conv != null) {
            conv.recycle();
        }
======= fetch "public void reset() {" 9c7ec4c^:"java/org/apache/catalina/connector/OutputBuffer.java"


======= fetch "public Context addContext(Host host, String contextPath, String contextName," 3787242^:"java/org/apache/catalina/startup/Tomcat.java"

        silence(contextPath);
======= fetch "public Context addWebapp(Host host, String url, String name, String path) {" 3787242^:"java/org/apache/catalina/startup/Tomcat.java"

        silence(url);
======= fetch "public void setSilent(boolean silent) {" 3787242^:"java/org/apache/catalina/startup/Tomcat.java"

    private void silence(String ctx) {
======= fetch "private void silence(String ctx) {" 3787242^:"java/org/apache/catalina/startup/Tomcat.java"

        base += getHost().getName();

======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" addd522^:"java/org/apache/catalina/startup/ContextConfig.java"

            log.warn(sm.getString("contextConfig.invalidSciHandlesTypes",
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" addd522^:"java/org/apache/catalina/startup/ContextConfig.java"

            log.warn(sm.getString("contextConfig.invalidSciHandlesTypes",
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" addd522^:"java/org/apache/catalina/startup/ContextConfig.java"

            log.warn(sm.getString("contextConfig.invalidSciHandlesTypes",

======= fetch "public void addElement(StringBuilder buf, Date date, Request request," 9f52382^:"java/org/apache/catalina/valves/AccessLogValve.java"

            if (length <= 0) {
                // Protect against nulls and unexpected types as these values
                // may be set by untrusted applications
                Object start = request.getAttribute(
                        "org.apache.tomcat.sendfile.start");
                if (start instanceof Long) {
                    Object end = request.getAttribute(
                            "org.apache.tomcat.sendfile.end");
                    if (end instanceof Long) {
                        length = ((Long) end).longValue() -
                                ((Long) start).longValue();
                    }
                }
            }
    <p>If sendfile is used, the response bytes will be written asynchronously
    in a separate thread and the access log valve will not know how many bytes
    were actually written. In this case, the number of bytes that was passed to
    the sendfile thread for writing will be recorded in the access log valve.
    </p>

     * Authenticate the user making this request, based on the specified
     * login configuration.  Return <code>true</code> if any specified
     * constraint has been satisfied, or <code>false</code> if we have
     * created a response challenge already.
     * @param request Request we are processing
     * @param response Response we are populating
     * @param config    Login configuration describing how authentication
     *              should be performed
======= fetch "public boolean authenticate(Request request," 8b6d341^:"java/org/apache/catalina/authenticator/NonLoginAuthenticator.java"

        /*  Associating this request's session with an SSO would allow
            coordinated session invalidation, but should the session for
            a webapp that the user didn't log into be invalidated when
            another session is logged out?
        String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
        if (ssoId != null)
            associate(ssoId, getSession(request, true));
        */
        if (containerLog.isDebugEnabled()) {
            containerLog.debug("User authentication is not required");
======= fetch "public boolean authenticate(Request request," 8b6d341^:"java/org/apache/catalina/authenticator/NonLoginAuthenticator.java"

        return (true);
======= fetch "public boolean authenticate(Request request," 8b6d341^:"java/org/apache/catalina/authenticator/NonLoginAuthenticator.java"

        // No Principal means the user is not already authenticated
        // and so will not be assigned any roles. It is safe to
        // to say the user is now authenticated because access to
        // protected resources will only be allowed with a matching role.
        // i.e. SC_FORBIDDEN (403 status) will be generated later.
======= fetch "public boolean authenticate(Request request," 8b6d341^:"java/org/apache/catalina/authenticator/NonLoginAuthenticator.java"

        if (containerLog.isDebugEnabled())
            containerLog.debug("User authenticated without any roles");
        return true;
======= fetch "public boolean authenticate(Request request," 8b6d341^:"java/org/apache/catalina/authenticator/NonLoginAuthenticator.java"

    /**
     * Return the authentication method, which is vendor-specific and
     * not defined by HttpServletRequest.
     */

======= fetch "private void processParameters(byte bytes[], int start, int len," 34b011b^:"java/org/apache/tomcat/util/http/Parameters.java"

                if (valueStart == -1) {
                    // &&
                    if (log.isDebugEnabled()) {
                        log.debug(sm.getString("parameters.emptyChunk"));
                    }
                    // Do not flag as error
                    continue;
                }
                // &=foo&
======= fetch "private void processParameters(byte bytes[], int start, int len," 34b011b^:"java/org/apache/tomcat/util/http/Parameters.java"

            tmpValue.setBytes(bytes, valueStart, valueEnd - valueStart);
======= fetch "private void processParameters(byte bytes[], int start, int len," 34b011b^:"java/org/apache/tomcat/util/http/Parameters.java"

                    origValue.append(bytes, valueStart, valueEnd - valueStart);
======= fetch "private void processParameters(byte bytes[], int start, int len," 34b011b^:"java/org/apache/tomcat/util/http/Parameters.java"

                if (decodeValue) {
                    urlDecode(tmpValue);
======= fetch "private void processParameters(byte bytes[], int start, int len," 34b011b^:"java/org/apache/tomcat/util/http/Parameters.java"

                tmpValue.setCharset(charset);
                value = tmpValue.toString();

    private int size = 0;

    private boolean checkLock = false;
    private boolean inAdd = false;
    private boolean inRemove = false;
    private boolean inMutex = false;

    private boolean enabled = true;
======= fetch "public void setEnabled(boolean enable) {" d69fb8e^:"java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java"

        if (!enabled) {

======= fetch "protected void antiLocking() {" 33e48db^:"java/org/apache/catalina/startup/ContextConfig.java"

            if (docBase.toLowerCase(Locale.ENGLISH).endsWith(".war")) {
                // TODO - This is never executed. Bug or code to delete?

        new HashSet<JspPropertyGroupDescriptor>();
======= fetch "public void addTaglib(String uri, String location) {" 22e7e15^:"java/org/apache/catalina/deploy/WebXml.java"

        new HashSet<JspPropertyGroup>();

======= fetch "protected void listen() throws Exception {" 9403e4f^:"java/org/apache/catalina/tribes/transport/nio/NioReceiver.java"

        // Avoid NPEs if selector is set to null on stop.
        Selector selector = this.selector;
======= fetch "protected void listen() throws Exception {" 9403e4f^:"java/org/apache/catalina/tribes/transport/nio/NioReceiver.java"

                Iterator<SelectionKey> it = (selector!=null)?selector.selectedKeys().iterator():null;
======= fetch "protected void listen() throws Exception {" 9403e4f^:"java/org/apache/catalina/tribes/transport/nio/NioReceiver.java"

                    if (selector!=null) it.remove();

======= fetch "public Connector(String protocol) {" 63f708a^:"java/org/apache/catalina/connector/Connector.java"

    protected int port = 0;
======= fetch "public Connector(String protocol) {" 63f708a^:"java/org/apache/catalina/connector/Connector.java"

======= fetch "protected boolean isParseBodyMethod(String method) {" 63f708a^:"java/org/apache/catalina/connector/Connector.java"

     * Return the port number on which we listen for requests.
======= fetch "public void setPort(int port) {" 63f708a^:"java/org/apache/catalina/connector/Connector.java"

     * Return the port number on which this connector is listening to requests.
     * If the special value for {@link #port} of zero is used then this method
     * will report the actual port bound.
     */
    public int getLocalPort() {
        return ((Integer) getProperty("localPort")).intValue();
    }
    /**
======= fetch "protected String createObjectNameKeyProperties(String type) {" 63f708a^:"java/org/apache/catalina/connector/Connector.java"

        sb.append(getPort());
======= fetch "protected void startInternal() throws LifecycleException {" 63f708a^:"java/org/apache/catalina/connector/Connector.java"

        if (getPort() < 1) {
======= fetch "public String toString() {" 63f708a^:"java/org/apache/catalina/connector/Connector.java"

        sb.append(getPort());
======= fetch "public String toString() {" 63f708a^:"java/org/apache/catalina/connector/Connector.java"

          description="The port number on which we listen for requests"
======= fetch "public void setPort(int port) {" 63f708a^:"java/org/apache/coyote/AbstractProtocol.java"

    public int getLocalPort() { return endpoint.getLocalPort(); }
======= fetch "public void setSoTimeout(int timeout) {" 63f708a^:"java/org/apache/coyote/AbstractProtocol.java"

    public synchronized int getNameIndex() {
        if (nameIndex == 0) {
            nameIndex = nameCounter.incrementAndGet();
        }
        return nameIndex;
    }
======= fetch "public String getName() {" 63f708a^:"java/org/apache/coyote/AbstractProtocol.java"

        name.append(endpoint.getPort());
======= fetch "private ObjectName createObjectName() throws MalformedObjectNameException {" 63f708a^:"java/org/apache/coyote/AbstractProtocol.java"

        name.append(getPort());
======= fetch "private ObjectName createObjectName() throws MalformedObjectNameException {" 63f708a^:"java/org/apache/coyote/AbstractProtocol.java"

======= fetch "public void setExecutor(Executor executor) {" 63f708a^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    public abstract int getLocalPort();
======= fetch "public Sendfile getSendfile() {" 63f708a^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    // --------------------------------------------------------- Public Methods
======= fetch "public Sendfile getSendfile() {" 63f708a^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    /**
     * Port in use.
     */
    @Override
    public int getLocalPort() {
        long s = serverSock;
        if (s == 0) {
            return -1;
        } else {
            long sa;
            try {
                sa = Address.get(Socket.APR_LOCAL, s);
                Sockaddr addr = Address.getInfo(sa);
                return addr.port;
            } catch (Exception e) {
                return -1;
            }
        }
    }
    // --------------------------------------------------------- Public Methods
======= fetch "public JIoEndpoint() {" 63f708a^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

    /**
     * Port in use.
     */
    @Override
    public int getLocalPort() {
        ServerSocket s = serverSocket;
        if (s == null) {
            return -1;
        } else {
            return s.getLocalPort();
        }
    }
======= fetch "public void setOomParachuteData(byte[] oomParachuteData) {" 63f708a^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    /**
     * Port in use.
     */
    @Override
    public int getLocalPort() {
        ServerSocketChannel ssc = serverSock;
        if (ssc == null) {
            return -1;
        } else {
            ServerSocket s = ssc.socket();
            if (s == null) {
                return -1;
            } else {
                return s.getLocalPort();
            }
        }
    }
======= fetch "private FormAuthClient() throws Exception {" 63f708a^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            setPort(getPort());
======= fetch "private FormAuthClient() throws Exception {" 63f708a^:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            // Port only known after Tomcat starts
            setPort(getPort());
======= fetch "public void testStop() throws Exception {" 63f708a^:"test/org/apache/catalina/connector/TestConnector.java"

    @Test
    public void testPort() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        Connector connector1 = tomcat.getConnector();
        connector1.setPort(0);
        Connector connector2 = new Connector();
        connector2.setPort(0);
        tomcat.getService().addConnector(connector2);
        tomcat.start();
        int localPort1 = connector1.getLocalPort();
        int localPort2 = connector2.getLocalPort();
        assertTrue(localPort1 > 0);
        assertTrue(localPort2 > 0);
    }
======= fetch "public void testBug37794() {" 63f708a^:"test/org/apache/catalina/connector/TestRequest.java"

        client.setPort(getPort());
======= fetch "public void testBug37794withoutFilter() {" 63f708a^:"test/org/apache/catalina/connector/TestRequest.java"

        client.setPort(getPort());
======= fetch "private synchronized void init() throws Exception {" 63f708a^:"test/org/apache/catalina/connector/TestRequest.java"

            setPort(tomcat.getConnector().getLocalPort());
======= fetch "public void testBug48692() {" 63f708a^:"test/org/apache/catalina/connector/TestRequest.java"

        client.setPort(getPort());
======= fetch "private synchronized void init() throws Exception {" 63f708a^:"test/org/apache/catalina/connector/TestRequest.java"

            setPort(tomcat.getConnector().getLocalPort());
======= fetch "public void testBug46243() throws Exception {" 63f708a^:"test/org/apache/catalina/core/TestStandardContext.java"

======= fetch "public void testBug46243() throws Exception {" 63f708a^:"test/org/apache/catalina/core/TestStandardContext.java"

        Bug46243Client client = new Bug46243Client();
        client.setPort(getPort());
======= fetch "public void testBug46243() throws Exception {" 63f708a^:"test/org/apache/catalina/core/TestStandardContext.java"

        public Bug46243Client(int port) {
            setPort(port);
        }
======= fetch "public void testBug49711() {" 63f708a^:"test/org/apache/catalina/core/TestStandardContext.java"

        client.setPort(getPort());
======= fetch "private synchronized void init() throws Exception {" 63f708a^:"test/org/apache/catalina/core/TestStandardContext.java"

            setPort(tomcat.getConnector().getLocalPort());
======= fetch "public Exception doAbortedUploadTest(AbortedUploadClient client, boolean limited" 63f708a^:"test/org/apache/catalina/core/TestSwallowAbortedUploads.java"

        client.setPort(getPort());
======= fetch "public Exception doAbortedPOSTTest(AbortedPOSTClient client, int status," 63f708a^:"test/org/apache/catalina/core/TestSwallowAbortedUploads.java"

        client.setPort(getPort());
======= fetch "private synchronized void init(boolean limited, boolean swallow)" 63f708a^:"test/org/apache/catalina/core/TestSwallowAbortedUploads.java"

            setPort(tomcat.getConnector().getLocalPort());
======= fetch "private synchronized void init(int status, boolean swallow)" 63f708a^:"test/org/apache/catalina/core/TestSwallowAbortedUploads.java"

            setPort(tomcat.getConnector().getLocalPort());
======= fetch "protected void validate(HttpServlet servlet," 63f708a^:"test/org/apache/catalina/filters/TestExpiresFilter.java"

                    "http://localhost:" + tomcat.getConnector().getPort() +
======= fetch "public void testWithTomcatServer() throws Exception {" 63f708a^:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

        HttpURLConnection httpURLConnection = (HttpURLConnection) new URL("http://localhost:" + tomcat.getConnector().getPort() + "/test")
                .openConnection();
======= fetch "public void testMBeanDeregistration() throws Exception {" 63f708a^:"test/org/apache/catalina/mbeans/TestRegistration.java"

        expected.addAll(Arrays.asList(connectorMBeanNames(Integer.toString(getPort()), protocol)));
======= fetch "public void testCustomErrorPage() throws Exception {" 63f708a^:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

        TestCustomErrorClient client = new TestCustomErrorClient();
        client.setPort(getPort());
======= fetch "public void testCustomErrorPageMissing() throws Exception {" 63f708a^:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

        TestCustomErrorClient client = new TestCustomErrorClient();
        client.setPort(getPort());
======= fetch "public static int getUrl(String path, ByteChunk out," 63f708a^:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

    public void setPort(int thePort) {
    private static int port = 8000;
======= fetch "public int getPort() {" 63f708a^:"test/org/apache/catalina/startup/TomcatBaseTest.java"

        return port;
    }
    /**
     * Sub-classes may want to add connectors on a new port
     */
    public int getNextPort() {
        port++;
        return getPort();
======= fetch "public void setUp() throws Exception {" 63f708a^:"test/org/apache/catalina/startup/TomcatBaseTest.java"

        // If each test is running on same port - they
        // may interfere with each other
        connector.setPort(getNextPort());
======= fetch "public void testWithTEVoid() throws Exception {" 63f708a^:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        Client client = new Client();
        client.setPort(getPort());
======= fetch "public void testWithTEBuffered() throws Exception {" 63f708a^:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        Client client = new Client();
        client.setPort(getPort());
======= fetch "public void testWithTEIdentity() throws Exception {" 63f708a^:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        Client client = new Client();
        client.setPort(getPort());
======= fetch "public void testWithTESavedRequest() throws Exception {" 63f708a^:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        Client client = new Client();
        client.setPort(getPort());
======= fetch "public void testWithTEUnsupported() throws Exception {" 63f708a^:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        Client client = new Client();
        client.setPort(getPort());
======= fetch "public void testPipelining() throws Exception {" 63f708a^:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        final Client client = new Client();
        client.setPort(getPort());
======= fetch "public void run() {" 63f708a^:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        public Client(int port) {
            setPort(port);
        }
======= fetch "public void testBug48839() {" 63f708a^:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

        client.setPort(getPort());
======= fetch "private Exception doRequest() {" 63f708a^:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

                setPort(tomcat.getConnector().getLocalPort());
======= fetch "public void testBug51557NoColon() {" 63f708a^:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

        client.setPort(getPort());
======= fetch "public void testBug51557Continuation() {" 63f708a^:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

        client.setPort(getPort());
======= fetch "public void testBug51557BoundaryStart() {" 63f708a^:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

        client.setPort(getPort());
======= fetch "public void testBug51557BoundaryEnd() {" 63f708a^:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

        client.setPort(getPort());
======= fetch "private void doTestBug51557Char(char s) {" 63f708a^:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

        client.setPort(getPort());
======= fetch "private Exception doRequest() {" 63f708a^:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

                setPort(tomcat.getConnector().getLocalPort());
======= fetch "public void testTrailingHeaders() throws Exception {" 63f708a^:"test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java"

        TrailerClient client = new TrailerClient();
        client.setPort(getPort());
======= fetch "public void testTrailingHeadersSizeLimit() throws Exception {" 63f708a^:"test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java"

        TrailerClient client = new TrailerClient();
        client.setPort(getPort());
======= fetch "public void testNoTrailingHeaders() throws Exception {" 63f708a^:"test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java"

        TrailerClient client = new TrailerClient();
        client.setPort(getPort());
======= fetch "protected void doPost(HttpServletRequest req, HttpServletResponse resp)" 63f708a^:"test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java"

        public TrailerClient(int port) {
            setPort(port);
        }
======= fetch "private void doRequest() throws Exception {" 63f708a^:"test/org/apache/tomcat/util/http/TestCookiesAllowEquals.java"

            setPort(tomcat.getConnector().getPort());
======= fetch "private void doRequest() throws Exception {" 63f708a^:"test/org/apache/tomcat/util/http/TestCookiesAllowHttpSeps.java"

            setPort(tomcat.getConnector().getPort());
======= fetch "private void doRequest() throws Exception {" 63f708a^:"test/org/apache/tomcat/util/http/TestCookiesAllowNameOnly.java"

            setPort(tomcat.getConnector().getPort());
======= fetch "private void doRequest() throws Exception {" 63f708a^:"test/org/apache/tomcat/util/http/TestCookiesDisallowEquals.java"

            setPort(tomcat.getConnector().getPort());
======= fetch "public void testStartStopBindOnStart() throws Exception {" 63f708a^:"test/org/apache/tomcat/util/net/TestXxxEndpoint.java"

        int port = getPort();
======= fetch "public void testStartStopBindOnStart() throws Exception {" 63f708a^:"test/org/apache/tomcat/util/net/TestXxxEndpoint.java"

      to a particular port number on a particular IP address.</p>
      to a particular port number on a particular IP address.</p>

======= fetch "public synchronized void addHostAlias(String name, String alias) {" f3a7cd9^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

        newHost.object = realHost;
======= fetch "public void setUp() throws Exception {" f3a7cd9^:"test/org/apache/tomcat/util/http/mapper/TestMapper.java"

        mapper.addHostAlias("iowejoiejfoiew", "iowejoiejfoiew_alias");
======= fetch "public void testAddHost() throws Exception {" f3a7cd9^:"test/org/apache/tomcat/util/http/mapper/TestMapper.java"

        // Check we have the right number (add 16 but one is a duplicate)
        assertEquals(15, mapper.hosts.length);
======= fetch "public void testAddHost() throws Exception {" f3a7cd9^:"test/org/apache/tomcat/util/http/mapper/TestMapper.java"

        assertEquals("blah7", mapper.hosts[3].object);
======= fetch "public void testAddHost() throws Exception {" f3a7cd9^:"test/org/apache/tomcat/util/http/mapper/TestMapper.java"

        // Check that host alias has the same data
        Mapper.Host host = mapper.hosts[iowPos];
        Mapper.Host alias = mapper.hosts[iowPos + 1];
        assertEquals("iowejoiejfoiew", host.name);
        assertEquals("iowejoiejfoiew_alias", alias.name);
        assertEquals(host.contextList, alias.contextList);
        assertEquals(host.object, alias.object);
======= fetch "public void testMap() throws Exception {" f3a7cd9^:"test/org/apache/tomcat/util/http/mapper/TestMapper.java"

        MessageBytes alias = MessageBytes.newInstance();
        alias.setString("iowejoiejfoiew_alias");
======= fetch "public void testMap() throws Exception {" f3a7cd9^:"test/org/apache/tomcat/util/http/mapper/TestMapper.java"

        assertEquals("/foo", mappingData.pathInfo.toString());
        assertTrue(mappingData.redirectPath.isNull());
        mappingData.recycle();
        uri.setString("/foo/bar/bla/bobou/foo");
        uri.toChars();
        uri.getCharChunk().setLimit(-1);
        mapper.map(alias, uri, null, mappingData);
        assertEquals("blah7", mappingData.host);
        assertEquals("context3", mappingData.context);
        assertEquals("wrapper7", mappingData.wrapper);
        assertEquals("/foo/bar/bla", mappingData.contextPath.toString());
        assertEquals("/bobou", mappingData.wrapperPath.toString());

 * <strong>IMPLEMENTATION NOTE</strong> - This class loader faithfully follows
 * the delegation model recommended in the specification. The system class
 * from the webapp repository.
======= fetch "protected boolean removeEldestEntry(" 574af73^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * found locally.
======= fetch "public boolean getDelegate() {" 574af73^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * If this flag is true, this class loader delegates
     * to the parent class loader
     * <strong>before</strong> searching its own repositories, as
     * in an ordinary (non-servlet) chain of of Java class loaders.
     * If set to <code>false</code> (the default),
     * this class loader will search its own repositories first, and
     * delegate to the parent only if the class or resource is not
     * found locally, as per the servlet specification.

    protected static String FIPSMode = "off"; // default off, valid only when SSLEngine="on"
    protected static boolean fipsModeActive = false;
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" c2001ce^:"java/org/apache/catalina/core/AprLifecycleListener.java"

                        log.info(sm.getString("aprListener.sslInit"));
======= fetch "private static void terminateAPR()" c2001ce^:"java/org/apache/catalina/core/AprLifecycleListener.java"

        fipsModeActive = false;
======= fetch "private static void initializeSSL()" c2001ce^:"java/org/apache/catalina/core/AprLifecycleListener.java"

======= fetch "private static void initializeSSL()" c2001ce^:"java/org/apache/catalina/core/AprLifecycleListener.java"

        if("on".equalsIgnoreCase(AprLifecycleListener.FIPSMode)) {
            log.info(sm.getString("aprListener.initializingFIPS"));
            int result = SSL.fipsModeSet(1);
            // success is defined as return value = 1
            if(1 == result) {
                fipsModeActive = true;
                log.info(sm.getString("aprListener.initializeFIPSSuccess"));
            } else {
                // This case should be handled by the native method,
                // but we'll make absolutely sure, here.
                log.error(sm.getString("aprListener.initializeFIPSFailed"));
                throw new IllegalStateException(sm.getString("aprListener.initializeFIPSFailed"));
            }
        }
======= fetch "public void setSSLEngine(String SSLEngine) {" c2001ce^:"java/org/apache/catalina/core/AprLifecycleListener.java"

        // Ensure that the SSLEngine is consistent with that used for SSL init
        if(sslInitialized)
            throw new IllegalStateException(sm.getString("aprListener.tooLateForSSLEngine"));
======= fetch "public void setSSLRandomSeed(String SSLRandomSeed) {" c2001ce^:"java/org/apache/catalina/core/AprLifecycleListener.java"

        // Ensure that the random seed is consistent with that used for SSL init
        if(sslInitialized)
            throw new IllegalStateException(sm.getString("aprListener.tooLateForSSLRandomSeed"));
======= fetch "public void setSSLRandomSeed(String SSLRandomSeed) {" c2001ce^:"java/org/apache/catalina/core/AprLifecycleListener.java"

    public void setFIPSMode(String FIPSMode)
    {
        // Ensure that the FIPS mode is consistent with that used for SSL init
        if(sslInitialized)
            throw new IllegalStateException(sm.getString("aprListener.tooLateForFIPSMode"));
        AprLifecycleListener.FIPSMode = FIPSMode;
    }
    public boolean isFIPSModeActive()
    {
        return fipsModeActive;
    }
     * Enable/Disable FIPS Mode.
     *
     * @param mode 1 - enable, 0 - disable
     *
     * @return FIPS_mode_set return code
     */
    public static native int fipsModeSet(int mode);
    /**

======= fetch "public URL getResource(String path)" b7f5c7e^:"java/org/apache/catalina/core/ApplicationContext.java"

                resources.lookup(path);

======= fetch "public String createStandardContext(String parent," d7af36d^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

            context.setConfigFile(configFile.toURI().toURL());

======= fetch "public void compile() throws JasperException, FileNotFoundException {" 62ff013^:"java/org/apache/jasper/JspCompilationContext.java"

            } catch (FileNotFoundException fnfe) {
                // Re-throw to let caller handle this - will result in a 404
                throw fnfe;
======= fetch "public static InputStream getInputStream(String fname, JarFile jarFile," 62ff013^:"java/org/apache/jasper/compiler/JspUtil.java"

                err.jspError("jsp.error.file.not.found", fname);
======= fetch "public static InputStream getInputStream(String fname, JarFile jarFile," 62ff013^:"java/org/apache/jasper/compiler/JspUtil.java"

            err.jspError("jsp.error.file.not.found", fname);

======= fetch "public boolean event(org.apache.coyote.Request req," b90c0a1^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                ((Context) request.getMappingData().context).logAccess(
                        request, response,
                        System.currentTimeMillis() - req.getStartTime(),
                        false);
======= fetch "public void service(org.apache.coyote.Request req," b90c0a1^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                if (postParseSuccess) {
======= fetch "public void service(org.apache.coyote.Request req," b90c0a1^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                    // If context is null this was the start of a comet request
                    // that failed and has already been logged.
======= fetch "public void testSimpleCometClient() throws Exception {" b90c0a1^:"test/org/apache/catalina/comet/TestCometProcessor.java"

        doSimpleCometTest(null);
    }
    @Test
    public void testSimpleCometClientBeginFail() throws Exception {
        doSimpleCometTest(SimpleCometServlet.FAIL_ON_BEGIN);
    }
======= fetch "public void testSimpleCometClient() throws Exception {" b90c0a1^:"test/org/apache/catalina/comet/TestCometProcessor.java"

    @Test
    public void testSimpleCometClientReadFail() throws Exception {
        doSimpleCometTest(SimpleCometServlet.FAIL_ON_READ);
    }
    @Test
    public void testSimpleCometClientEndFail() throws Exception {
        doSimpleCometTest(SimpleCometServlet.FAIL_ON_END);
    }
    private void doSimpleCometTest(String initParam) throws Exception {
======= fetch "public void testSimpleCometClient() throws Exception {" b90c0a1^:"test/org/apache/catalina/comet/TestCometProcessor.java"

        Tomcat.addServlet(root, "comet", new SimpleCometServlet());
======= fetch "public void testSimpleCometClient() throws Exception {" b90c0a1^:"test/org/apache/catalina/comet/TestCometProcessor.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        root.getPipeline().addValve(alv);
======= fetch "public void testSimpleCometClient() throws Exception {" b90c0a1^:"test/org/apache/catalina/comet/TestCometProcessor.java"

        // Validate response
======= fetch "public void testSimpleCometClient() throws Exception {" b90c0a1^:"test/org/apache/catalina/comet/TestCometProcessor.java"

        assertEquals("HTTP/1.1 200 OK", response[0]);
        assertEquals("Server: Apache-Coyote/1.1", response[1]);
        assertTrue(response[2].startsWith("Set-Cookie: JSESSIONID="));
        assertEquals("Content-Type: text/plain;charset=ISO-8859-1", response[3]);
        assertEquals("Transfer-Encoding: chunked", response[4]);
        assertTrue(response[5].startsWith("Date: "));
        assertEquals("", response[6]);
        assertEquals("7", response[7]);
        assertEquals("BEGIN", response[8]);
        assertEquals("", response[9]);
        assertEquals("17", response[10]);
        assertEquals("Client: READ: 4 bytes", response[11]);
        assertEquals("", response[12]);
        assertEquals("17", response[13]);
        assertEquals("Client: READ: 4 bytes", response[14]);
        assertEquals("", response[15]);
        assertEquals("17", response[16]);
        assertEquals("Client: READ: 4 bytes", response[17]);
        assertEquals("", response[18]);
        assertEquals("17", response[19]);
        assertEquals("Client: READ: 4 bytes", response[20]);
        assertEquals("", response[21]);
        assertEquals("d", response[22]);
        assertEquals("Client: END", response[23]);
        assertEquals("", response[24]);
        assertEquals("0", response[25]);
        // Expect 26 lines
        assertEquals(26, response.length);
======= fetch "private boolean isCometSupported() {" b90c0a1^:"test/org/apache/catalina/comet/TestCometProcessor.java"

        public static final String FAIL_ON_BEGIN = "failOnBegin";
        public static final String FAIL_ON_READ = "failOnRead";
        public static final String FAIL_ON_END = "failOnEnd";
        private boolean failOnBegin = false;
        private boolean failOnRead = false;
        private boolean failOnEnd = false;
        @Override
        public void init() throws ServletException {
            failOnBegin = Boolean.valueOf(getServletConfig().getInitParameter(
                    FAIL_ON_BEGIN)).booleanValue();
            failOnRead = Boolean.valueOf(getServletConfig().getInitParameter(
                    FAIL_ON_READ)).booleanValue();
            failOnEnd = Boolean.valueOf(getServletConfig().getInitParameter(
                    FAIL_ON_END)).booleanValue();
        }
======= fetch "public void event(CometEvent event) throws IOException," b90c0a1^:"test/org/apache/catalina/comet/TestCometProcessor.java"

                if (failOnBegin) {
                    throw new IOException("Fail on begin");
                }
======= fetch "public void event(CometEvent event) throws IOException," b90c0a1^:"test/org/apache/catalina/comet/TestCometProcessor.java"

                if (failOnRead) {
                    throw new IOException("Fail on read");
                }
======= fetch "public void event(CometEvent event) throws IOException," b90c0a1^:"test/org/apache/catalina/comet/TestCometProcessor.java"

                if (failOnEnd) {
                    throw new IOException("Fail on end");
                }

======= fetch "protected String toAbsolute(String location) {" e70797e^:"java/org/apache/catalina/connector/Response.java"

        if (leadingSlash || !hasScheme(location)) {

======= fetch "public void addServletContainerInitializer(" 3ab3757^:"java/org/apache/catalina/Context.java"

    /**
     * Configures if a response body is included when a redirect response is
     * sent to the client.
     */
    public void setSendRedirectBody(boolean enable);
    
    /**
     * Dtermines if the context is configured to included a response body as
     * part of a redirect response.
     */
    public boolean getSendRedirectBody();
======= fetch "public void sendRedirect(String location)" 3ab3757^:"java/org/apache/catalina/connector/Response.java"

            PrintWriter writer = getWriter();
            writer.print(sm.getString("coyoteResponse.sendRedirect.note",
                    RequestUtil.filter(absolute)));
            flushBuffer();
======= fetch "public StandardContext() {" 3ab3757^:"java/org/apache/catalina/core/StandardContext.java"

    private boolean sendRedirectBody = false;
    
======= fetch "public StandardContext() {" 3ab3757^:"java/org/apache/catalina/core/StandardContext.java"

    
    @Override
    public boolean getSendRedirectBody() {
        return sendRedirectBody;
    }
    @Override
    public void setSendRedirectBody(boolean sendRedirectBody) {
        this.sendRedirectBody = sendRedirectBody;
    }
      <attribute name="sendRedirectBody" required="false">
        <p>If <code>true</code>, redirect responses will include a short
        response body that includes details of the redirect as recommended by
        RFC 2616. This is disabled by default since including a response body
        may cause problems for some application component such as compression
        filters.</p>
      </attribute>
      

======= fetch "public void doFilterEvent(CometEvent event, CometFilterChain chain)" d6d1c6f^:"java/org/apache/catalina/filters/RemoteAddrFilter.java"

        processCometEvent(event.getHttpServletRequest().getRemoteHost(),
======= fetch "protected Log getLogger() {" d6d1c6f^:"java/org/apache/catalina/filters/RemoteAddrFilter.java"

    

======= fetch "protected void service(final HttpServletRequest req, final HttpServletResponse r" b080c7e^:"webapps/examples/WEB-INF/classes/async/Async0.java"

            req.getAsyncContext().complete();

======= fetch "public void event(Request request, Response response, CometEvent event)" a450d2c^:"java/org/apache/catalina/core/StandardWrapperValve.java"

        
======= fetch "public void event(Request request, Response response, CometEvent event)" a450d2c^:"java/org/apache/catalina/core/StandardWrapperValve.java"

        if (wrapper == null) {
            // Context has been shutdown. Nothing to do here.
            return;
        }

======= fetch "public void stopInternal() {" 136097e^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                long s = System.currentTimeMillis() + 30000;
                while (acceptors[i].isAlive()) {

======= fetch "public void log(org.apache.coyote.Request req," 18792f4^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        boolean create = false;
======= fetch "public void log(org.apache.coyote.Request req," 18792f4^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            create = true;
======= fetch "public void log(org.apache.coyote.Request req," 18792f4^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        }
        
        if (create) {
======= fetch "protected void prepareRequest() {" 18792f4^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

                        adapter.log(request, response, 0);
======= fetch "protected void prepareRequest() {" 18792f4^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

            adapter.log(request, response, 0);
======= fetch "protected void prepareRequest() {" 18792f4^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        if (error) {
            adapter.log(request, response, 0);
        }
======= fetch "protected void parseHost(MessageBytes valueMB) {" 18792f4^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

                adapter.log(request, response, 0);
======= fetch "protected void parseHost(MessageBytes valueMB) {" 18792f4^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

                    adapter.log(request, response, 0);
======= fetch "public SocketState process(SocketWrapper<Long> socket)" 18792f4^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

            if (!cping && endpoint.isPaused()) {
======= fetch "public SocketState process(SocketWrapper<NioChannel> socket)" 18792f4^:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

            if (!cping && endpoint.isPaused()) {
======= fetch "public SocketState process(SocketWrapper<Socket> socket)" 18792f4^:"java/org/apache/coyote/ajp/AjpProcessor.java"

            if (!cping && endpoint.isPaused()) {
======= fetch "public SocketState process(SocketWrapper<S> socketWrapper)" 18792f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

                    adapter.log(request, response, 0);
======= fetch "protected void prepareRequest() {" 18792f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

            adapter.log(request, response, 0);
======= fetch "protected void prepareRequest() {" 18792f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

                    adapter.log(request, response, 0);
======= fetch "protected void prepareRequest() {" 18792f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

                adapter.log(request, response, 0);
======= fetch "protected void prepareRequest() {" 18792f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

            adapter.log(request, response, 0);
======= fetch "protected void prepareRequest() {" 18792f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        
        if (error) {
            adapter.log(request, response, 0);
        }
======= fetch "protected void parseHost(MessageBytes valueMB) {" 18792f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

                    adapter.log(request, response, 0);
======= fetch "public void endRequest() {" 18792f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

            // Can't add a 500 to the access log since that has already been
            // written in the Adapter.service method.
======= fetch "public void endRequest() {" 18792f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

            adapter.log(request, response, 0);

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private static final long serialVersionUID = 1L;
    private final Random random = new Random();
    @Override
    public String getAlgorithm() {
        return "INSECURE";
    }
    @Override
    public synchronized void setSeed(byte[] seed) {
        // Not implemented
    }
    @Override
    public synchronized void setSeed(long seed) {
        // The super class constructor calls this method earlier than our
        // fields are initialized. Ignore the call.
        if (random == null) {
            return;
        }
        random.setSeed(seed);
    }
    @Override
    public synchronized void nextBytes(byte[] bytes) {
        random.nextBytes(bytes);
    }
    @Override
    public byte[] generateSeed(int numBytes) {
        byte[] value = new byte[numBytes];
        nextBytes(value);
        return value;
    }
======= fetch "public void setUp() throws Exception {" 73a6e56^:"test/org/apache/catalina/startup/TomcatBaseTest.java"

        tomcat = new Tomcat();
======= fetch "public static int postUrl(byte[] body, String path, ByteChunk out," 73a6e56^:"test/org/apache/catalina/startup/TomcatBaseTest.java"

    private static class TomcatWithFastSessionIDs extends Tomcat {
        @Override
        public void start() throws LifecycleException {
            // Use fats, insecure session ID generation for all tests
            Server server = getServer();
            for (Service service : server.findServices()) {
                Container e = service.getContainer();
                for (Container h : e.findChildren()) {
                    for (Container c : h.findChildren()) {
                        StandardManager m = (StandardManager) c.getManager();
                        if (m == null) {
                            m = new StandardManager();
                            m.setSecureRandomClass(
                                    "org.apache.catalina.startup.FastNonSecureRandom");
                            c.setManager(m);
                        }
                    }
                }
            }
            super.start();
        }
    }

======= fetch "public JSSEKeyManager(X509KeyManager mgr, String serverKeyAlias) {" 66f2d5b^:"java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java"

        super();
======= fetch "public String chooseClientAlias(String[] keyType, Principal[] issuers," 66f2d5b^:"java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java"

     * @param keyType The key algorithm type name (ignored)
     * @param issuers The list of acceptable CA issuer subject names, or null
     * if it does not matter which issuers are used (ignored)
     * @param socket The socket to be used for this connection. This parameter
     * can be null, in which case this method will return the most generic
     * alias to use (ignored)
======= fetch "public PrivateKey getPrivateKey(String alias) {" 66f2d5b^:"java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java"

    /**
     * Choose an alias to authenticate the client side of a secure socket,
     * given the public key type and the list of certificate issuer authorities
     * recognized by the peer (if any).
     *
     * @param keyType The key algorithm type name(s), ordered with the
     * most-preferred key type first
     * @param issuers The list of acceptable CA issuer subject names, or null
     * if it does not matter which issuers are used
     * @param engine Ignored
     *
     * @return The alias name for the desired key, or null if there are no
     * matches
     */
    @Override
    public String chooseEngineClientAlias(String[] keyType, Principal[] issuers,
            SSLEngine engine) {
        return delegate.chooseClientAlias(keyType, issuers, null);
    }
    /**
     * Returns this key manager's server key alias that was provided in the
     * constructor.
     *
     * @param keyType Ignored
     * @param issuers Ignored
     * @param engine Ignored
     *
     * @return Alias name for the desired key
     */
    @Override
    public String chooseEngineServerAlias(String keyType, Principal[] issuers,
            SSLEngine engine) {
        return serverKeyAlias;
    }

======= fetch "public Object invoke(ELContext context, Object base, Object method," bfabec5^:"java/javax/el/BeanELResolver.java"

                if (m.isVarArgs()) {
======= fetch "public Object invoke(ELContext context, Object base, Object method," bfabec5^:"java/javax/el/BeanELResolver.java"

                for (int i = 0; (i < varArgIndex - 1); i++) {
======= fetch "public Object invoke(ELContext context, Object base, Object method," bfabec5^:"java/javax/el/BeanELResolver.java"

                // Last parameter is the varags
======= fetch "public Object invoke(ELContext context, Object base, Object method," bfabec5^:"java/javax/el/BeanELResolver.java"

                final Object varargs = Array.newInstance(
                    varArgClass,
                    (paramCount - varArgIndex));
======= fetch "public Object invoke(ELContext context, Object base, Object method," bfabec5^:"java/javax/el/BeanELResolver.java"

                    Object varargs = Array.newInstance(
                            parameterTypes[paramCount],
                            (paramCount - varArgIndex));
                    Array.set(varargs, i,
======= fetch "public Object invoke(ELContext context, Object base, Object method," bfabec5^:"java/javax/el/BeanELResolver.java"

                    parameters[varArgIndex] = varargs;
======= fetch "public Object invoke(ELContext context, Object base, Object method," bfabec5^:"java/javax/el/BeanELResolver.java"

                parameters[varArgIndex] = varargs;
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    public static class Foo {
        public String joinDelimited(String delim, String... strings) {
            StringBuilder result = new StringBuilder();
            if (strings != null) {
                for (String s : strings) {
                    if (delim != null && result.length() > 0) {
                        result.append(delim);
                    }
                    result.append(s);
                }
            }
            return result.toString();
        }
        public String join(String... strings) {
            return joinDelimited(null, strings);
        }
    }
    private Foo foo;
    private ELContext elContext;
    private BeanELResolver beanELResolver;
    @Before
    public void setup() {
        foo = new Foo();
        beanELResolver = new BeanELResolver();
        elContext = new ELContext() {
            private VariableMapper variableMapper = new VariableMapper() {
                private Map<String, ValueExpression> vars =
                    new HashMap<String, ValueExpression>();
                @Override
                public ValueExpression setVariable(String arg0,
                        ValueExpression arg1) {
                    return vars.put(arg0, arg1);
                }
                @Override
                public ValueExpression resolveVariable(String arg0) {
                    return vars.get(arg0);
                }
            };
            private FunctionMapper functionMapper = new FunctionMapper() {
                @Override
                public Method resolveFunction(String arg0, String arg1) {
                    return null;
                }
            };
            @Override
            public VariableMapper getVariableMapper() {
                return variableMapper;
            }
            @Override
            public FunctionMapper getFunctionMapper() {
                return functionMapper;
            }
            @Override
            public ELResolver getELResolver() {
                return beanELResolver;
            }
        };
    }
    /**
     * Tests varargs that come after an opening argument.
     */
    @Test
    public void testJoinDelimited() {
        Assert.assertEquals(foo.joinDelimited("-", "foo", "bar", "baz"),
            beanELResolver.invoke(elContext, foo, "joinDelimited", null,
                    new Object[] { "-", "foo", "bar", "baz" }));
    }
    /**
     * Tests varargs that constitute a method's only parameters, as well as
     * bogus results due to improper matching of ANY vararg method, and
     * depending on the order in which reflected methods are encountered.
     */
    @Test
    public void testJoin() {
        Assert.assertEquals(foo.join("foo", "bar", "baz"),
            beanELResolver.invoke(elContext, foo, "join", null,
                    new Object[] { "foo", "bar", "baz" }));
    }

======= fetch "public static String expand(Host host, URL war, String pathname)" feff880^:"java/org/apache/catalina/startup/ExpandWar.java"

                if(null == input)
                    throw new ZipException(sm.getString("expandWar.missingJarEntry", jarEntry.getName()));

======= fetch "public void setAWTThreadProtection(boolean awtThreadProtection) {" 423fd89^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

     * Protect against the memory leak caused when the
     * <code>sun.java2d.Disposer</code> class is loaded by a web application.
     * Defaults to <code>false</code> because a new Thread is launched.
     */
    private boolean java2dDisposerProtection = false;
    public boolean isJava2DDisposerProtection() {
        return java2dDisposerProtection;
    }
    public void setJava2DDisposerProtection(boolean java2dDisposerProtection) {
        this.java2dDisposerProtection = java2dDisposerProtection;
    }
    /**
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 423fd89^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

                // Trigger the creation of the "Java2D Disposer" thread.
                // See https://issues.apache.org/bugzilla/show_bug.cgi?id=51687
                if(java2dDisposerProtection) {
                    try {
                        Class.forName("sun.java2d.Disposer");
                    }
                    catch (ClassNotFoundException cnfe) {
                        // Ignore this case: we must be running on a
                        // non-Sun-based JRE.
                    }
                }
      <attribute name="java2DDisposerProtection" required="false">
        <p>Enables protection so that loading the
        <code>sun.java2d.Disposer</code> class by a web application does not
        result in a memory leak.
        Defaults to <code>false</code> because a thread is launched.</p>
      </attribute>

======= fetch "public String getAllowUnsafeLegacyRenegotiation() {" 9425437^:"java/org/apache/coyote/http11/AbstractHttp11JsseProtocol.java"

    private String sslImplemenationName = null;
    public String getSslImplemenationName() { return sslImplemenationName; }
    public void setSslImplemenationName(String s) {
        this.sslImplemenationName = s;
======= fetch "public void init() throws Exception {" 9425437^:"java/org/apache/coyote/http11/AbstractHttp11JsseProtocol.java"

        sslImplementation = SSLImplementation.getInstance(sslImplemenationName);
======= fetch "public void testCustomSslImplementation() throws Exception {" 9425437^:"test/org/apache/tomcat/util/net/TestCustomSsl.java"

        connector.setProperty("sslImplemenationName", 
    <attribute name="sslImplemenationName" required="false">

======= fetch "public void run() {" 58429a8^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                            if (wakeupCounter.get()>0) {
======= fetch "public void run() {" 58429a8^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                            }else {
                                keyCount = selector.keys().size();
                                wakeupCounter.set(-1);

======= fetch "protected void finish() throws IOException {" a2538ce^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        // Swallow the unread body packet if present
        if (first && request.getContentLengthLong() > 0) {
            receive();
        }
======= fetch "public SocketState process(SocketWrapper<Long> socket)" a2538ce^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

                    // Usually the servlet didn't read the previous request body
                    if(log.isDebugEnabled()) {
                        log.debug("Unexpected message: "+type);
======= fetch "public SocketState process(SocketWrapper<Long> socket)" a2538ce^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

                    continue;
======= fetch "public SocketState process(SocketWrapper<NioChannel> socket)" a2538ce^:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

                    // Usually the servlet didn't read the previous request body
                    if(log.isDebugEnabled()) {
                        log.debug("Unexpected message: "+type);
======= fetch "public SocketState process(SocketWrapper<NioChannel> socket)" a2538ce^:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

                    error = true;
======= fetch "public SocketState process(SocketWrapper<NioChannel> socket)" a2538ce^:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

                    continue;
======= fetch "public SocketState process(SocketWrapper<Socket> socket)" a2538ce^:"java/org/apache/coyote/ajp/AjpProcessor.java"

                    // Usually the servlet didn't read the previous request body
                    if(log.isDebugEnabled()) {
                        log.debug("Unexpected message: "+type);
======= fetch "public SocketState process(SocketWrapper<Socket> socket)" a2538ce^:"java/org/apache/coyote/ajp/AjpProcessor.java"

                    continue;
======= fetch "public SocketState process(SocketWrapper<Socket> socket)" a2538ce^:"java/org/apache/coyote/ajp/AjpProcessor.java"


======= fetch "public boolean authenticate(Request request," 3513acc^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

                saved.setMethod("GET");
======= fetch "public boolean authenticate(Request request," 3513acc^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

                saved.setMethod("GET");

======= fetch "public void invoke(Request request, Response response)" 196a8f5^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

            !request.isSecure() &&

     * Timeout for RPC messages.
     */
    private long rpcTimeout = DEFAULT_REPL_TIMEOUT;
    /**
======= fetch "protected synchronized void startInternal() throws LifecycleException {" 87a32d6^:"java/org/apache/catalina/ha/session/BackupManager.java"

                                                          DEFAULT_REPL_TIMEOUT,
======= fetch "public int getMapSendOptions() {" 87a32d6^:"java/org/apache/catalina/ha/session/BackupManager.java"

    public void setRpcTimeout(long rpcTimeout) {
        this.rpcTimeout = rpcTimeout;
    }
    public long getRpcTimeout() {
        return rpcTimeout;
    }
======= fetch "public ClusterManager cloneFromTemplate() {" 87a32d6^:"java/org/apache/catalina/ha/session/BackupManager.java"

        result.rpcTimeout = rpcTimeout;
    <attribute
      name="rpcTimeout"
      description="Timeout for RPC messages, how long we will wait for a reply"
      type="long"/>
======= fetch "protected void broadcast(int msgtype, boolean rpc) throws ChannelException {" 87a32d6^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        // No destination.
        if (channel.getMembers().length == 0 ) return;
======= fetch "protected void broadcast(int msgtype, boolean rpc) throws ChannelException {" 87a32d6^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            for (int i = 0; i < resp.length; i++) {
                mapMemberAdded(resp[i].getSource());
                messageReceived(resp[i].getMessage(), resp[i].getSource());

======= fetch "private void postWorkDirectory() {" 4587f13^:"java/org/apache/catalina/core/StandardContext.java"

        if (!dir.exists() && !dir.mkdirs()) {
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" 4587f13^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                        }                                 
                                        resourceFile.getParentFile().mkdirs();
======= fetch "private void setRepositories() throws IOException {" 4587f13^:"java/org/apache/catalina/loader/WebappLoader.java"

                if (!classRepository.isDirectory()) {
                    if (!classRepository.mkdirs())
                        throw new IOException(
                                sm.getString("webappLoader.mkdirFailure"));
======= fetch "private void setRepositories() throws IOException {" 4587f13^:"java/org/apache/catalina/loader/WebappLoader.java"

                if (!destDir.isDirectory()) {
                    if (!destDir.mkdirs())
                        throw new IOException(
                                sm.getString("webappLoader.mkdirFailure"));
======= fetch "protected synchronized void save(PrintWriter writer, String path," 4587f13^:"java/org/apache/catalina/manager/ManagerServlet.java"

            if (!deployedPath.isDirectory() && !deployedPath.mkdirs()) {
======= fetch "protected void deploy(PrintWriter writer, String config, ContextName cn," 4587f13^:"java/org/apache/catalina/manager/ManagerServlet.java"

                        if (!configBase.isDirectory() && !configBase.mkdirs()) {
======= fetch "public void init() throws ServletException {" 4587f13^:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

        if (!appBaseFile.exists()) {
            if (!appBaseFile.mkdirs()) {
                writer.println(smClient.getString(
                        "hostManagerServlet.appBaseCreateFail",
                        appBaseFile.toString(), name));
                return;
            }
======= fetch "protected File getConfigBase(String hostName) {" 4587f13^:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

        if (!configBase.exists()) {
            if (!configBase.mkdirs()) {
                return null;
            }
======= fetch "protected void expandCGIScript() {" 4587f13^:"java/org/apache/catalina/servlets/CGIServlet.java"

            if (!dir.mkdirs() && debug >= 2) {
                log("expandCGIScript: failed to create directories for '" +
                        dir.getAbsolutePath() + "'");
======= fetch "public void save(Session session) throws IOException {" 4587f13^:"java/org/apache/catalina/session/FileStore.java"

    private File directory() {
======= fetch "private File directory() {" 4587f13^:"java/org/apache/catalina/session/FileStore.java"

            file.delete();
            file.mkdirs();
======= fetch "private File directory() {" 4587f13^:"java/org/apache/catalina/session/FileStore.java"

    private File file(String id) {
======= fetch "public static String expand(Host host, URL war, String pathname)" 4587f13^:"java/org/apache/catalina/startup/ExpandWar.java"

                    parent.mkdirs();
======= fetch "public void start() {" 4587f13^:"java/org/apache/catalina/startup/HostConfig.java"

                if ( (!dirs[i].isDirectory()) && (!dirs[i].mkdirs())) {
======= fetch "protected synchronized void open() {" 4587f13^:"java/org/apache/catalina/valves/AccessLogValve.java"

        if (!dir.exists()) {
            if (!dir.mkdirs()) {
                log.error(sm.getString("accessLogValve.openDirFail", dir));
            }
======= fetch "protected synchronized void open() {" 4587f13^:"java/org/apache/catalina/valves/AccessLogValve.java"

        if (!parent.exists()) {
            if (!parent.mkdirs()) {
                log.error(sm.getString("accessLogValve.openDirFail", parent));
            }
======= fetch "protected boolean makeOutputDir() {" 4587f13^:"java/org/apache/jasper/JspCompilationContext.java"

            return (outDirFile.exists() || outDirFile.mkdirs());
======= fetch "protected void openWriter() {" 4587f13^:"java/org/apache/juli/FileHandler.java"

        if (!dir.exists() && !dir.mkdirs()) {
======= fetch "protected void openWriter() {" 4587f13^:"java/org/apache/juli/FileHandler.java"

            if (!parent.exists()) {
                if (!parent.mkdirs()) {
                    reportError("Unable to create [" + parent + "]", null,
                            ErrorManager.OPEN_FAILURE);
                    writer = null;
                    return;
                }
======= fetch "public void testPathParamsRedirect() throws Exception {" 4587f13^:"test/org/apache/catalina/connector/TestCoyoteAdapter.java"

        if (!foo.exists() && !foo.mkdirs()) {
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" 4587f13^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        if (!foo.exists() && !foo.mkdirs()) {
======= fetch "public void testBug46243() throws Exception {" 4587f13^:"test/org/apache/catalina/core/TestStandardContext.java"

        if (!docBase.exists() && !docBase.mkdirs()) {
======= fetch "public void testCustomErrorPage() throws Exception {" 4587f13^:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

        if (!webInf.mkdirs()) {
======= fetch "public void testCustomErrorPageMissing() throws Exception {" 4587f13^:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

        if (!webInf.mkdirs()) {
======= fetch "public void setUp() throws Exception {" 4587f13^:"test/org/apache/catalina/startup/TomcatBaseTest.java"

        if (!tempDir.exists() && !tempDir.mkdirs()) {

======= fetch "public static void initWebappDefaults(Context ctx) {" 25f02b4^:"java/org/apache/catalina/startup/Tomcat.java"

        ctx.setManager( new StandardManager());
     * Simple servlet to test in-line registration 
======= fetch "public void doGet(HttpServletRequest req, HttpServletResponse res)" 25f02b4^:"test/org/apache/catalina/startup/TestTomcat.java"

     * Simple servlet to test the default session manager.
     */
    public static class HelloWorldSession extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        public void doGet(HttpServletRequest req, HttpServletResponse res) 
                throws IOException {
            HttpSession s = req.getSession(true);
            s.getId();
            res.getWriter().write("Hello world");
        }
    }
    /**
======= fetch "public void testJsps() throws Exception {" 25f02b4^:"test/org/apache/catalina/startup/TestTomcat.java"

    public void testSession() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        
        // Must have a real docBase - just use temp
        org.apache.catalina.Context ctx = 
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        // You can customize the context by calling 
        // its API
        
        Tomcat.addServlet(ctx, "myServlet", new HelloWorldSession());
        ctx.addServletMapping("/", "myServlet");
        
        tomcat.start();
        
        ByteChunk res = getUrl("http://localhost:" + getPort() + "/");
        assertEquals("Hello world", res.toString());
    }
    @Test

======= fetch "public Connector(String protocol) {" 517fd9b^:"java/org/apache/catalina/connector/Connector.java"

            log.error
                (sm.getString
                 ("coyoteConnector.protocolHandlerInstantiationFailed", e));

======= fetch "public void setAppContextProtection(boolean appContextProtection) {" 0cdbfa6^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

    
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 0cdbfa6^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

                

======= fetch "public void release(SocketWrapper<Long> socket," bf4a544^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

                        socket.getSocket().longValue());
======= fetch "public void release(SocketWrapper<Long> socket," bf4a544^:"java/org/apache/coyote/http11/Http11AprProtocol.java"

                        socket.getSocket().longValue());
======= fetch "protected void longPoll(SocketWrapper<Long> socket," bf4a544^:"java/org/apache/coyote/http11/Http11AprProtocol.java"

                        socket.getSocket().longValue());
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        protected long serverPollset = 0;
        protected long pool = 0;
        protected long[] desc;
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        protected long[] addS;
        protected volatile int addCount = 0;
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        protected boolean comet = true;
======= fetch "public Poller(boolean comet) {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

         * Create the poller. With some versions of APR, the maximum poller size will
         * be 62 (recompiling APR is necessary to remove this limitation).
======= fetch "protected void init() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            int timeout = getKeepAliveTimeout();
            if (timeout <= 0) {
                timeout = socketProperties.getSoTimeout();
======= fetch "protected void init() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            serverPollset = allocatePoller(size, pool, timeout);
            if (serverPollset == 0 && size > 1024) {
======= fetch "protected void init() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                serverPollset = allocatePoller(size, pool, timeout);
======= fetch "protected void init() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            if (serverPollset == 0) {
======= fetch "protected void init() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                serverPollset = allocatePoller(size, pool, timeout);
======= fetch "protected void init() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            addS = new long[size];
======= fetch "public void destroy() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    processSocket(addS[i], SocketStatus.STOP);
======= fetch "public void destroy() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    destroySocket(addS[i]);
======= fetch "public void destroy() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            // Close all sockets still in the poller
            int rv = Poll.pollset(serverPollset, desc);
            if (rv > 0) {
                for (int n = 0; n < rv; n++) {
                    if (comet) {
                        processSocket(desc[n*2+1], SocketStatus.STOP);
                    } else {
                        destroySocket(desc[n*2+1]);
                    }
                }
======= fetch "public void destroy() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        private void closePollset(long pollset) {
            int rv = Poll.pollset(pollset, desc);
            if (rv > 0) {
                for (int n = 0; n < rv; n++) {
                    if (comet) {
                        processSocket(desc[n*2+1], SocketStatus.STOP);
                    } else {
                        destroySocket(desc[n*2+1]);
                    }
                }
            }
        }
======= fetch "public void destroy() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        public void add(long socket) {
======= fetch "public void add(long socket) {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                if (addCount >= addS.length) {
======= fetch "public void add(long socket) {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                addS[addCount] = socket;
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                    int rv = Poll.add
                                        (serverPollset, addS[i], Poll.APR_POLLIN);
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                            processSocket(addS[i], SocketStatus.ERROR);
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                            destroySocket(addS[i]);
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    // Pool for the specified interval
                    int rv = Poll.poll(serverPollset, pollTime, desc, true);
                    if (rv > 0) {
                        keepAliveCount -= rv;
                        for (int n = 0; n < rv; n++) {
                            // Check for failed sockets and hand this socket off to a worker
                            if (((desc[n*2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP)
                                    || ((desc[n*2] & Poll.APR_POLLERR) == Poll.APR_POLLERR)
                                    || (comet && (!processSocket(desc[n*2+1], SocketStatus.OPEN)))
                                    || (!comet && (!processSocket(desc[n*2+1])))) {
                                // Close socket and clear pool
                                if (comet) {
                                    processSocket(desc[n*2+1], SocketStatus.DISCONNECT);
                                } else {
                                    destroySocket(desc[n*2+1]);
                                }
                                continue;
                            }
                        }
                    } else if (rv < 0) {
                        int errn = -rv;
                        /* Any non timeup or interrupted error is critical */
                        if ((errn != Status.TIMEUP) && (errn != Status.EINTR)) {
                            if (errn >  Status.APR_OS_START_USERERR) {
                                errn -=  Status.APR_OS_START_USERERR;
                            }
                            log.error(sm.getString("endpoint.poll.fail", "" + errn, Error.strerror(errn)));
                            // Handle poll critical failure
                            synchronized (this) {
                                destroy();
                                init();
                            }
                            continue;
                        }
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    if (socketProperties.getSoTimeout() > 0 && maintainTime > 1000000L && running) {
                        rv = Poll.maintain(serverPollset, desc, true);
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                        if (rv > 0) {
                            keepAliveCount -= rv;
                            for (int n = 0; n < rv; n++) {
                                // Close socket and clear pool
                                if (comet) {
                                    processSocket(desc[n], SocketStatus.TIMEOUT);
                                } else {
                                    destroySocket(desc[n]);
                                }
                            }
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    }
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    // ----------------------------------------------------- Worker Inner Class
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                    getPoller().add(state.socket);
======= fetch "public void run() {" bf4a544^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                        getPoller().add(socket.getSocket().longValue());

======= fetch "public void log(org.apache.coyote.Request req," 5d55842^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                    ((Context) request.mappingData.context).logAccess(

======= fetch "public void start() {" c4d1631^:"java/org/apache/catalina/startup/HostConfig.java"

        if (!appBase().isDirectory()) {
            log.error(sm.getString(
                    "hostConfig.appBase", host.getName(), appBase().getPath()));
            host.setDeployOnStartup(false);
            host.setAutoDeploy(false);
        }

======= fetch "public static String normalize(String path, boolean replaceBackSlash) {" 7562fc1^:"java/org/apache/catalina/util/RequestUtil.java"

     * @param encoding The encoding to use; if null, the default encoding is
     * used. If an unsupported encoding is specified the parameters will not be
======= fetch "public static void parseParameters(Map<String,String[]> map, String data," 7562fc1^:"java/org/apache/catalina/util/RequestUtil.java"

            // given string so that the encoding is not lost. If an
            // encoding is not specified, let it use platform default
======= fetch "public static void parseParameters(Map<String,String[]> map, String data," 7562fc1^:"java/org/apache/catalina/util/RequestUtil.java"

                if (encoding == null) {
                    bytes = data.getBytes(Charset.defaultCharset());
                } else {
                    bytes = data.getBytes(B2CConverter.getCharset(encoding));
                }

======= fetch "public void javacError(JavacErrorDetail[] details) throws JasperException {" 841e9fc^:"java/org/apache/jasper/compiler/DefaultErrorHandler.java"

                buf.append("\n\n");
======= fetch "public void javacError(JavacErrorDetail[] details) throws JasperException {" 841e9fc^:"java/org/apache/jasper/compiler/DefaultErrorHandler.java"

                buf.append("\n");
======= fetch "public void javacError(JavacErrorDetail[] details) throws JasperException {" 841e9fc^:"java/org/apache/jasper/compiler/DefaultErrorHandler.java"

                buf.append("\n");
======= fetch "public void javacError(JavacErrorDetail[] details) throws JasperException {" 841e9fc^:"java/org/apache/jasper/compiler/DefaultErrorHandler.java"

                buf.append("\n\n");
======= fetch "public void javacError(JavacErrorDetail[] details) throws JasperException {" 841e9fc^:"java/org/apache/jasper/compiler/DefaultErrorHandler.java"

                buf.append("\n");
======= fetch "public void javacError(JavacErrorDetail[] details) throws JasperException {" 841e9fc^:"java/org/apache/jasper/compiler/DefaultErrorHandler.java"

        buf.append("\n\nStacktrace:");
======= fetch "private void dispatch(Mark where, String errCode, Object[] args," 841e9fc^:"java/org/apache/jasper/compiler/ErrorDispatcher.java"

                errMsgBuf.append("\n");

======= fetch "public Permission getPermission() {" bb7072c^:"java/org/apache/naming/resources/DirContextURLConnection.java"

                // Strip off the hostname and the contextpath
======= fetch "public Permission getPermission() {" bb7072c^:"java/org/apache/naming/resources/DirContextURLConnection.java"

                if(context instanceof ProxyDirContext &&
                        "".equals(((ProxyDirContext)context).getContextPath())){
                    start = file.indexOf('/',1);
                }
                else
======= fetch "public Permission getPermission() {" bb7072c^:"java/org/apache/naming/resources/DirContextURLConnection.java"

                }

======= fetch "public void setXmlParsingProtection(boolean xmlParsingProtection) {" cd2fecd^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

     * <code>com.sun.jndi.ldap.LdapPoolManager</code> class spawns a thread when it
     * is initialized if the system property
======= fetch "public void setLdapPoolProtection(boolean ldapPoolProtection) {" cd2fecd^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

    
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" cd2fecd^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

                 * First call to this loads all drivers in the current class
                 * loader
                 */
                if (driverManagerProtection) {
                    DriverManager.getDrivers();
                }
                /*
      <attribute name="driverManagerProtection" required="false">
        <p>The first use of <code>java.sql.DriverManager</code> will trigger the
        loading of JDBNC Driver in the the current class loader. The web
        application level memory leak protection can take care of this in most
        cases but triggering the loading here has fewer side-effects. The
        default is <code>true</code></p>
      </attribute>

======= fetch "public void release(SocketWrapper<NioChannel> socket) {" 7ffca5b^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

            Http11NioProcessor processor = connections.remove(socket);

======= fetch "protected void connectUsingDriver() throws SQLException {" 8c41e9c^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            connection = connection = driver.connect(driverURL, properties);

======= fetch "public final synchronized void init() throws LifecycleException {" ed0588b^:"java/org/apache/catalina/util/LifecycleBase.java"

        } catch (LifecycleException e) {
======= fetch "public final synchronized void init() throws LifecycleException {" ed0588b^:"java/org/apache/catalina/util/LifecycleBase.java"

            throw e;
======= fetch "public final synchronized void start() throws LifecycleException {" ed0588b^:"java/org/apache/catalina/util/LifecycleBase.java"

        } catch (LifecycleException e) {
======= fetch "public final synchronized void start() throws LifecycleException {" ed0588b^:"java/org/apache/catalina/util/LifecycleBase.java"

            throw e;
======= fetch "public final synchronized void stop() throws LifecycleException {" ed0588b^:"java/org/apache/catalina/util/LifecycleBase.java"

        } catch (LifecycleException e) {
======= fetch "public final synchronized void stop() throws LifecycleException {" ed0588b^:"java/org/apache/catalina/util/LifecycleBase.java"

            throw e;
======= fetch "public final synchronized void destroy() throws LifecycleException {" ed0588b^:"java/org/apache/catalina/util/LifecycleBase.java"

        } catch (LifecycleException e) {
======= fetch "public final synchronized void destroy() throws LifecycleException {" ed0588b^:"java/org/apache/catalina/util/LifecycleBase.java"

            throw e;

======= fetch "public void processExpires() {" 29e9966^:"java/org/apache/catalina/session/StoreBase.java"

                try {
                    if (manager.findSession(keys[i]) != null) {
                        isLoaded = true;
======= fetch "public void processExpires() {" 29e9966^:"java/org/apache/catalina/session/StoreBase.java"

                } catch (IOException ioe) {
                    // Ignore - session will be expired

======= fetch "public void addElement(StringBuilder buf, Date date, Request request," 77213bb^:"java/org/apache/catalina/valves/AccessLogValve.java"

    private AccessLogElement createAccessLogElement(String header, char pattern) {
======= fetch "private AccessLogElement createAccessLogElement(String header, char pattern) {" 77213bb^:"java/org/apache/catalina/valves/AccessLogValve.java"

    private AccessLogElement createAccessLogElement(char pattern) {

======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" 0b340ac^:"java/org/apache/catalina/startup/ContextConfig.java"

        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            log.warn(sm.getString("contextConfig.invalidSciHandlesTypes",
                    className), t);
            return;
      <fix>
        <bug>51586</bug>: Expand error handling to cover anything that is
        recoverable (or might be recoverable) when loading classes during
        HandlesTypes processing. (markt)
      </fix>

    public abstract boolean parseRequestLine(boolean useAvailableDataOnly) throws IOException;
    
    public abstract boolean parseHeaders() throws IOException;
    
    protected abstract boolean fill(boolean block) throws IOException; 
    // -------------------------------------------------------------- Constants
    // ----------------------------------------------------------- Constructors
    // -------------------------------------------------------------- Variables
    // ----------------------------------------------------- Instance Variables
======= fetch "public void setSwallowInput(boolean swallowInput) {" 6200dd9^:"java/org/apache/coyote/http11/AbstractInputBuffer.java"

    public abstract boolean parseRequestLine(boolean useAvailableDataOnly) throws IOException;
    
    public abstract boolean parseHeaders() throws IOException;
    
    protected abstract boolean fill(boolean block) throws IOException; 
======= fetch "public int doRead(ByteChunk chunk, Request req)" 6200dd9^:"java/org/apache/coyote/http11/AbstractInputBuffer.java"

    
    // -------------------------------------------------------------- Constants
======= fetch "public boolean parseHeader()" 6200dd9^:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

            } else if (!HTTP_TOKEN_CHAR[buf[pos]]) {
                // If a non-token header is detected, skip the line and
                // ignore the header
                skipLine(start);
                return true;
======= fetch "public boolean parseHeader()" 6200dd9^:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

    private void skipLine(int start) throws IOException {
        boolean eol = false;
        int lastRealByte = start;
        if (pos - 1 > start) {
            lastRealByte = pos - 1;
        }
        
        while (!eol) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill())
                    throw new EOFException(sm.getString("iib.eof.error"));
            }
            if (buf[pos] == Constants.CR) {
                // Skip
            } else if (buf[pos] == Constants.LF) {
                eol = true;
            } else {
                lastRealByte = pos;
            }
            pos++;
        }
        if (log.isDebugEnabled()) {
            log.debug(sm.getString("iib.invalidheader", new String(buf, start,
                    lastRealByte - start + 1, Charset.forName("ISO-8859-1"))));
        }
    }
    
    
    private static final Log log = LogFactory.getLog(InternalInputBuffer.class);
======= fetch "public boolean parseHeader()" 6200dd9^:"java/org/apache/coyote/http11/InternalInputBuffer.java"

            } else if (!HTTP_TOKEN_CHAR[buf[pos]]) {
                // If a non-token header is detected, skip the line and
                // ignore the header
                skipLine(start);
                return true;
======= fetch "public boolean parseHeader()" 6200dd9^:"java/org/apache/coyote/http11/InternalInputBuffer.java"

======= fetch "public boolean parseHeader()" 6200dd9^:"java/org/apache/coyote/http11/InternalInputBuffer.java"

    /**
     * Logger.
     */
    enum HeaderParsePosition {HEADER_START, HEADER_NAME, HEADER_VALUE, HEADER_MULTI_LINE}
======= fetch "public HeaderParseStatus parseHeader()" 6200dd9^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            } else if (!HTTP_TOKEN_CHAR[buf[pos]]) {
                // If a non-token header is detected, skip the line and
                // ignore the header
                return skipLine();
======= fetch "public HeaderParseStatus parseHeader()" 6200dd9^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

        while (headerParsePos == HeaderParsePosition.HEADER_SKIPLINE) {
            return skipLine();
        }
======= fetch "public HeaderParseStatus parseHeader()" 6200dd9^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

    private HeaderParseStatus skipLine() throws IOException {
        headerParsePos = HeaderParsePosition.HEADER_SKIPLINE;
        boolean eol = false;
        // Reading bytes until the end of the line
        while (!eol) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill(true,false)) {
                    return HeaderParseStatus.NEED_MORE_DATA;
                }
            }
            if (buf[pos] == Constants.CR) {
                // Skip
            } else if (buf[pos] == Constants.LF) {
                eol = true;
            } else {
                headerData.lastSignificantChar = pos;
            }
            pos++;
        }
        if (log.isDebugEnabled()) {
            log.debug(sm.getString("iib.invalidheader", new String(buf,
                    headerData.start,
                    headerData.lastSignificantChar - headerData.start + 1,
                    DEFAULT_CHARSET)));
        }
        headerParsePos = HeaderParsePosition.HEADER_START;
        return HeaderParseStatus.HAVE_MORE_HEADERS;
    }
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 6200dd9^:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

    @Test
    public void testBug51557NoColon() {
        
        Bug51557Client client = new Bug51557Client("X-Bug51557NoColon");
        client.setPort(getPort());
        
        client.doRequest();
        assertTrue(client.isResponse200());
        assertEquals("abcd", client.getResponseBody());
        assertTrue(client.isResponseBodyOK());
    }
    
    @Test
    public void testBug51557Separators() throws Exception {
        char httpSeparators[] = new char[] {
                '\t', ' ', '\"', '(', ')', ',', '/', ':', ';', '<',
                '=', '>', '?', '@', '[', '\\', ']', '{', '}' };
        
        for (char s : httpSeparators) {
            doTestBug51557Char(s);
            tearDown();
            setUp();
        }
    }
    @Test
    public void testBug51557Ctl() throws Exception {
        for (int i = 0; i < 31; i++) {
            doTestBug51557Char((char) i);
            tearDown();
            setUp();
        }
        doTestBug51557Char((char) 127);
    }
    @Test
    public void testBug51557Continuation() {
        
        Bug51557Client client = new Bug51557Client("X-Bug=51557NoColon",
                "foo" + SimpleHttpClient.CRLF + " bar");
        client.setPort(getPort());
        
        client.doRequest();
        assertTrue(client.isResponse200());
        assertEquals("abcd", client.getResponseBody());
        assertTrue(client.isResponseBodyOK());
    }
    
    @Test
    public void testBug51557BoundaryStart() {
        
        Bug51557Client client = new Bug51557Client("=X-Bug51557",
                "invalid");
        client.setPort(getPort());
        
        client.doRequest();
        assertTrue(client.isResponse200());
        assertEquals("abcd", client.getResponseBody());
        assertTrue(client.isResponseBodyOK());
    }
    
    @Test
    public void testBug51557BoundaryEnd() {
        
        Bug51557Client client = new Bug51557Client("X-Bug51557=",
                "invalid");
        client.setPort(getPort());
        
        client.doRequest();
        assertTrue(client.isResponse200());
        assertEquals("abcd", client.getResponseBody());
        assertTrue(client.isResponseBodyOK());
    }
    
    private void doTestBug51557Char(char s) {
        Bug51557Client client =
            new Bug51557Client("X-Bug" + s + "51557", "invalid");
        client.setPort(getPort());
        client.doRequest();
        assertTrue(client.isResponse200());
        assertEquals("abcd", client.getResponseBody());
        assertTrue(client.isResponseBodyOK());
    }
    
    /**
     * Bug 51557 test client.
     */
    private class Bug51557Client extends SimpleHttpClient {
        private String headerName;
        private String headerLine;
        public Bug51557Client(String headerName) {
            this.headerName = headerName;
            this.headerLine = headerName;
        }
        public Bug51557Client(String headerName, String headerValue) {
            this.headerName = headerName;
            this.headerLine = headerName + ": " + headerValue;
        }
        private Exception doRequest() {
        
            Tomcat tomcat = getTomcatInstance();
            
            Context root = tomcat.addContext("", TEMP_DIR);
            Tomcat.addServlet(root, "Bug51557",
                    new Bug51557Servlet(headerName));
            root.addServletMapping("/test", "Bug51557");
            try {
                tomcat.start();
                // Open connection
                connect();
                
                String[] request = new String[1];
                request[0] =
                    "GET http://localhost:8080/test HTTP/1.1" + CRLF +
                    headerLine + CRLF +
                    "X-Bug51557: abcd" + CRLF +
                    "Connection: close" + CRLF +
                    CRLF;
                
                setRequest(request);
                processRequest(); // blocks until response has been read
                
                // Close the connection
                disconnect();
            } catch (Exception e) {
                return e;
            }
            return null;
        }
        @Override
        public boolean isResponseBodyOK() {
            if (getResponseBody() == null) {
                return false;
            }
            if (!getResponseBody().contains("abcd")) {
                return false;
            }
            return true;
        }
        
    }
    private static class Bug51557Servlet extends HttpServlet {
        
        private static final long serialVersionUID = 1L;
        private String invalidHeaderName;
        /**
         * @param invalidHeaderName The header name should be invalid and
         *                          therefore ignored by the header parsing code
         */
        public Bug51557Servlet(String invalidHeaderName) {
            this.invalidHeaderName = invalidHeaderName;
        }
        /**
         * Only interested in the request headers from a GET request
         */
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            // Just echo the header value back as plain text
            resp.setContentType("text/plain");
            
            PrintWriter out = resp.getWriter();
            
            processHeaders(invalidHeaderName, req, out);
            processHeaders("X-Bug51557", req, out);
        }
        
        private void processHeaders(String header, HttpServletRequest req,
                PrintWriter out) {
            Enumeration<String> values = req.getHeaders(header);
            while (values.hasMoreElements()) {
                out.println(values.nextElement());
            }
        }
    }
      <fix>
        <bug>51557</bug>: Ignore HTTP headers that do not comply with RFC 2616
        and use header names that are not tokens. (markt)
      </fix>

 * <li><code>x-threadname</code>: Current request thread name (can compare later with stacktraces)</li>
======= fetch "protected AccessLogElement getXParameterElement(PatternTokenizer tokenizer)" 00a1fdf^:"java/org/apache/catalina/valves/ExtendedAccessLogValve.java"

        Move the SetCharacaterEncoding filter from the examples web application
    <li><b>%I</b> - current request thread name (can compare later with stacktraces)</li>

 *    init()
 * NEW ->-- INITIALIZING
 * |||           |                  --------------------<-----------------------
 * |||           |auto              |                                          |
 * |||          \|/    start()     \|/       auto          auto         stop() |
 * |||      INITIALIZED -->-- STARTING_PREP -->- STARTING -->- STARTED -->---  |
 * |||                              ^                             |         |  |
 * |||        start()               |                             |         |  |
 * ||----------->--------------------                             |         |  |
 * ||                                                             |         |  |
 * |---                auto                    auto               |         |  |
 * |  |          ---------<----- MUST_STOP ---------------------<--         |  |
 * |  |          |                                                          |  |
 * |  |          ---------------------------<--------------------------------  ^
 * |  |          |                                                             |
 * |  |         \|/            auto                 auto              start()  |
 * |  |     STOPPING_PREP ------>----- STOPPING ------>----- STOPPED ---->------
 * |  |                                   ^                  |  |  ^
 * |  |                  stop()           |                  |  |  |
 * |  |          --------------------------                  |  |  |
 * |  |          |                                  auto     |  |  |
 * |  |          |                  MUST_DESTROY------<-------  |  |
 * |  |          |                    |                         |  |
 * |  |          |                    |auto                     |  |
 * |  |          |    destroy()      \|/              destroy() |  |
 * |  |       FAILED ---->------ DESTROYING ---<-----------------  |
 * |  |                           ^     |                          |
 * |  |        destroy()          |     |auto                      |
 * |  -----------------------------    \|/                         |
 * TODO: Not all components may transition from STOPPED to STARTING_PREP
======= fetch "public final synchronized void destroy() throws LifecycleException {" 95d67fe^:"java/org/apache/catalina/util/LifecycleBase.java"

                !state.equals(LifecycleState.NEW)) {

======= fetch "public void setBufferSize(int size) {" 8baaa98^:"java/org/apache/catalina/connector/ResponseFacade.java"

                (/*sm.getString("responseBase.reset.ise")*/);
======= fetch "public void resetBuffer() {" 8baaa98^:"java/org/apache/catalina/connector/ResponseFacade.java"

                (/*sm.getString("responseBase.reset.ise")*/);
======= fetch "public void reset() {" 8baaa98^:"java/org/apache/catalina/connector/ResponseFacade.java"

                (/*sm.getString("responseBase.reset.ise")*/);
======= fetch "public void sendError(int sc, String msg)" 8baaa98^:"java/org/apache/catalina/connector/ResponseFacade.java"

                (/*sm.getString("responseBase.reset.ise")*/);
======= fetch "public void sendError(int sc)" 8baaa98^:"java/org/apache/catalina/connector/ResponseFacade.java"

                (/*sm.getString("responseBase.reset.ise")*/);
======= fetch "public void sendRedirect(String location)" 8baaa98^:"java/org/apache/catalina/connector/ResponseFacade.java"

                (/*sm.getString("responseBase.reset.ise")*/);

    public static final int SSL_PROTOCOL_ALL   = (SSL_PROTOCOL_SSLV2|SSL_PROTOCOL_SSLV3|SSL_PROTOCOL_TLSV1);

======= fetch "public boolean isOutDated(boolean checkClass) {" bcee77d^:"java/org/apache/jasper/compiler/Compiler.java"

                URL includeUrl = ctxt.getResource(include.getKey());

======= fetch "public void add(T key) {" 400745e^:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

            cache.put(key, null);
======= fetch "public void add(T key) {" 400745e^:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

        
======= fetch "public boolean contains(T key) {" 400745e^:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

            return cache.containsKey(key);

======= fetch "public void addRuleInstances(Digester digester) {" 5de2739^:"java/org/apache/catalina/startup/WebRuleSet.java"

            digester.addCallMethod(fullPrefix + "/absolute-ordering/name/others",

======= fetch "protected void flush(boolean explicit) throws IOException {" a3f3379^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

            if (Socket.sendbb(socketRef, 0, outputBuffer.position()) < 0) {
======= fetch "protected void flush(boolean explicit) throws IOException {" a3f3379^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

        if (explicit && !finished) {

======= fetch "protected void startInternal() throws LifecycleException {" 1e79993^:"java/org/apache/catalina/connector/Connector.java"

        // Validate settings before starting
        if (getPort() < 1) {
            throw new LifecycleException(sm.getString(
                    "coyoteConnector.invalidPort", Integer.valueOf(getPort())));
        }
  ${If} $TomcatPortShutdown == ""
    MessageBox MB_ICONEXCLAMATION|MB_OK 'The shutdown port may not be empty'
    Abort "Config not right"
    Goto exit
  ${EndIf}
  ${If} $TomcatPortHttp == ""
    MessageBox MB_ICONEXCLAMATION|MB_OK 'The HTTP port may not be empty'
    Abort "Config not right"
    Goto exit
  ${EndIf}
  ${If} $TomcatPortAjp == ""
    MessageBox MB_ICONEXCLAMATION|MB_OK 'The AJP port may not be empty'
    Abort "Config not right"
    Goto exit
  ${EndIf}
      <fix>
        <bug>51503</bug>: Add additional validation that prevents a connector
        from starting if it does not have a port > 0. (markt)
      </fix>
    </changelog>
  </subsection>
  <subsection>
    <changelog>
      <fix>
        <bug>51503</bug>: Add additional validation to Windows installer that
        ensure that the shutdown port, HTTP port and AJP port are all specified
        during the install process. (markt)
      </fix>

======= fetch "private Library(String libraryName)" 6ee5a22^:"java/org/apache/tomcat/jni/Library.java"

    /* TCN_FULL_VERSION */
    public static int TCN_FULL_VERSION   = 0;
======= fetch "public static boolean initialize(String libraryName)" 6ee5a22^:"java/org/apache/tomcat/jni/Library.java"

            TCN_FULL_VERSION   = TCN_MAJOR_VERSION * 1000 +
                                 TCN_MINOR_VERSION * 100 +
                                 TCN_PATCH_VERSION;
======= fetch "public void bind() throws Exception {" 6ee5a22^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            int value = SSL.SSL_PROTOCOL_ALL;
            if ("SSLv2".equalsIgnoreCase(SSLProtocol)) {
                value = SSL.SSL_PROTOCOL_SSLV2;
            } else if ("SSLv3".equalsIgnoreCase(SSLProtocol)) {
                value = SSL.SSL_PROTOCOL_SSLV3;
            } else if ("TLSv1".equalsIgnoreCase(SSLProtocol)) {
                value = SSL.SSL_PROTOCOL_TLSV1;
            } else if ("SSLv2+SSLv3".equalsIgnoreCase(SSLProtocol)) {
                value = SSL.SSL_PROTOCOL_SSLV2 | SSL.SSL_PROTOCOL_SSLV3;
            } else if ("all".equalsIgnoreCase(SSLProtocol) ||
                    SSLProtocol == null || SSLProtocol.length() == 0) {
                // NOOP, use the default defined above
======= fetch "public void bind() throws Exception {" 6ee5a22^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                // Protocol not recognized, fail to start as it is safer than
                // continuing with the default which might enable more than the
                // is required
                throw new Exception(sm.getString(
                        "endpoint.apr.invalidSslProtocol", SSLProtocol));
        library, the native/APR connector will be used. If the native library
        that the native/APR connector has different settings for HTTPS than the
      is "all", with other acceptable values being "SSLv2", "SSLv3", "TLSv1"
      and "SSLv2+SSLv3".</p>

======= fetch "protected Date initialValue() {" 871dabd^:"java/org/apache/catalina/valves/AccessLogValve.java"

    
======= fetch "public void setLocale(String localeName) {" 871dabd^:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * Return the character set name that is used to write the log file.
     *
     * @return Character set name, or <code>null</code> if the system default
     *  character set is used.
     */
    public String getEncoding() {
        return encoding;
    }
    /**
     * Set the character set that is used to write the log file.
     * 
     * @param encoding The name of the character set.
     */
    public void setEncoding(String encoding) {
        if (encoding != null && encoding.length() > 0) {
            this.encoding = encoding;
        } else {
            this.encoding = null;
        }
    }
======= fetch "protected synchronized void open() {" 871dabd^:"java/org/apache/catalina/valves/AccessLogValve.java"

            writer = new PrintWriter(new BufferedWriter(new FileWriter(
                    pathname, true), 128000), false);
            

======= fetch "public final void invoke(Request request, Response response)" 3a95db4^:"java/org/apache/catalina/core/StandardContextValve.java"

                context.fireRequestDestroyEvent(request);

======= fetch "public void messageReceived(ChannelMessage msg) {" acc5619^:"java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java"

     * TODO Fix to create an automatically growing buffer.
     * @param data byte[]
     * @return byte[]
======= fetch "public void messageReceived(ChannelMessage msg) {" acc5619^:"java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java"

        ByteArrayOutputStream bout = new ByteArrayOutputStream();
======= fetch "public void messageReceived(ChannelMessage msg) {" acc5619^:"java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java"

        int length = gin.read(tmp);
        byte[] result = new byte[length];
        System.arraycopy(tmp,0,result,0,length);
        return result;
    public void testBasic() throws Exception {
        byte[] data = new byte[1024];
        Arrays.fill(data,(byte)1);

    // FIX ME package "javax." was removed to prevent HotSpot
    // fatal internal errors
======= fetch "private final void setSecurityProperty(String properties, String packageList){" ec00abf^:"java/org/apache/catalina/security/SecurityConfig.java"

                definition += ",";
======= fetch "private final void setSecurityProperty(String properties, String packageList){" ec00abf^:"java/org/apache/catalina/security/SecurityConfig.java"

            Security.setProperty(properties,
                // FIX ME package "javax." was removed to prevent HotSpot
                // fatal internal errors
                definition + packageList);      

======= fetch "public void run() {" eb98373^:"java/org/apache/catalina/core/StandardContext.java"

            t.run();

======= fetch "protected void start(PrintWriter writer, String name," 6020bf6^:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

        // Don't start host of already started
======= fetch "protected void start(PrintWriter writer, String name," 6020bf6^:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

     * Start the host with the specified name.
======= fetch "protected void stop(PrintWriter writer, String name," 6020bf6^:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

        // Prevent starting our own host
======= fetch "protected void stop(PrintWriter writer, String name," 6020bf6^:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

        // Don't stop host of already stopped

======= fetch "public void invoke(Request request, Response response)" df9bc17^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

        if (!authRequired) {
======= fetch "public void invoke(Request request, Response response)" df9bc17^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

        if (!authRequired) {

======= fetch "private static final Node createNodeInternal(String expr)" 92af111^:"java/org/apache/el/lang/ExpressionBuilder.java"

            } catch (ParseException pe) {
                throw new ELException("Error Parsing: " + expr, pe);

======= fetch "public final void invoke(Request request, Response response)" 6dffc54^:"java/org/apache/catalina/core/StandardContextValve.java"

            notFound(response);
======= fetch "public final void invoke(Request request, Response response)" 6dffc54^:"java/org/apache/catalina/core/StandardContextValve.java"

            notFound(response);
======= fetch "public final void invoke(Request request, Response response)" 6dffc54^:"java/org/apache/catalina/core/StandardContextValve.java"

                notFound(response);
======= fetch "public final void invoke(Request request, Response response)" 6dffc54^:"java/org/apache/catalina/core/StandardContextValve.java"

        // Acknowledge the request
        try {
            response.sendAcknowledgement();
        } catch (IOException ioe) {
            container.getLogger().error(sm.getString(
                    "standardContextValve.acknowledgeException"), ioe);
            request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, ioe);
            error(response, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            return;
        }
        
======= fetch "public final void event(Request request, Response response, CometEvent event)" 6dffc54^:"java/org/apache/catalina/core/StandardContextValve.java"

     * Report a "not found" error for the specified resource.  FIXME:  We
======= fetch "public final void event(Request request, Response response, CometEvent event)" 6dffc54^:"java/org/apache/catalina/core/StandardContextValve.java"

    private void notFound(HttpServletResponse response) {
======= fetch "private void notFound(HttpServletResponse response) {" 6dffc54^:"java/org/apache/catalina/core/StandardContextValve.java"

            response.sendError(HttpServletResponse.SC_NOT_FOUND);
======= fetch "public final void invoke(Request request, Response response)" 6dffc54^:"java/org/apache/catalina/core/StandardWrapperValve.java"

        // Acknowledge the request
        try {
            response.sendAcknowledgement();
        } catch (IOException e) {
            container.getLogger().warn(sm.getString("standardWrapper.acknowledgeException",
                             wrapper.getName()), e);
            throwable = e;
            exception(request, response, e);
        } catch (Throwable e) {
            ExceptionUtils.handleThrowable(e);
            container.getLogger().error(sm.getString("standardWrapper.acknowledgeException",
                             wrapper.getName()), e);
            throwable = e;
            exception(request, response, e);
            servlet = null;
        }

    protected static final StringManager sm =
        StringManager.getManager(Constants.Package);
======= fetch "public void complete() {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "public void dispatch() {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "public void dispatch(String path) {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "public void dispatch(ServletContext context, String path) {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "public ServletRequest getRequest() {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "public ServletResponse getResponse() {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "public void start(final Runnable run) {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "public void addListener(AsyncListener listener) {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "public void addListener(AsyncListener listener, ServletRequest servletRequest," d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "public void addListener(AsyncListener listener, ServletRequest servletRequest," d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "public void recycle() {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        context = null;
        dispatch = null;
        event = null;
        hasOriginalRequestAndResponse = true;
        instanceManager = null;
        listeners.clear();
        request = null;
======= fetch "public void recycle() {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        hasOriginalRequestAndResponse = true;
        context = null;
======= fetch "public void recycle() {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        event = null;
======= fetch "public boolean hasOriginalRequestAndResponse() {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "public long getTimeout() {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "public void setTimeout(long timeout) {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= fetch "private InstanceManager getInstanceManager() {" d36c5d9^:"java/org/apache/catalina/core/AsyncContextImpl.java"

    private void check() {
        if (request == null) {
            // AsyncContext has been recycled and should not be being used
            throw new IllegalStateException(sm.getString(
                    "asyncContextImpl.requestEnded"));
        }
    }

======= fetch "protected void doSessions(ContextName cn, HttpServletRequest req," 3d85a85^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= fetch "protected Session getSessionForNameAndId(ContextName cn, String id," 3d85a85^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            StringManager smClient) throws IOException {
        if ((cn == null) || !(cn.getPath().startsWith("/") ||
                cn.getPath().equals(""))) {
            String path = null;
            if (cn != null) {
                path = cn.getPath();
======= fetch "protected Session getSessionForNameAndId(ContextName cn, String id," 3d85a85^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            throw new IllegalArgumentException(smClient.getString(
                    "managerServlet.invalidPath",
                    RequestUtil.filter(path)));
        }
        
        Context ctxt = (Context) host.findChild(cn.getName());
        if (null == ctxt) {
            throw new IllegalArgumentException(smClient.getString(
                    "managerServlet.noContext",
                    RequestUtil.filter(cn.getDisplayName())));
======= fetch "protected Session getSessionForNameAndId(ContextName cn, String id," 3d85a85^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        Session session = ctxt.getManager().findSession(id);
        return session;

    private Map<String, List<String>> userRoles = 
            new HashMap<String, List<String>>();
    private Map<String, Principal> userPrincipals = new HashMap<String, Principal>();
======= fetch "public Context addWebapp(Host host, String url, String name, String path) {" f83c07e^:"java/org/apache/catalina/startup/Tomcat.java"

    
    /**
     * Return a listener that provides the required configuration items for JSP
     * processing. From the standard Tomcat global web.xml. Pass this to
     * {@link Context#addLifecycleListener(LifecycleListener)} and then pass the
     * result of {@link #noDefaultWebXmlPath()} to 
     * {@link ContextConfig#setDefaultWebXml(String)}. 
     * @return a listener object that configures default JSP processing.
     */
    public LifecycleListener getDefaultWebXmlListener() {
        return new DefaultWebXmlListener();
    }
    
    /**
     * @return a pathname to pass to
     * {@link ContextConfig#setDefaultWebXml(String)} when using
     * {@link #getDefaultWebXmlListener()}.
     */
    public String noDefaultWebXmlPath() {
        return "org/apache/catalin/startup/NO_DEFAULT_XML";
    }
    
    /**
     * For complex configurations, this accessor allows callers of this class
     * to obtain the simple realm created by default.
     * @return the simple in-memory realm created by default.
     */
    public Realm getDefaultRealm() {
        if (defaultRealm == null) {
            initSimpleAuth();
        }
        return defaultRealm;
    }
      <add>
        <bug>51418</bug>: Provide more control over Context creation when
        embedding Tomcat. Based on a patch by Benson Margulies. (markt)
      </add>

======= fetch "private void configure() {" f2dd57b^:"java/org/apache/juli/FileHandler.java"

                // Ignore

    protected SetSessionConfig sessionConfig;
    protected SetLoginConfig loginConfig;
    protected SetJspConfig jspConfig;
======= fetch "public void addRuleInstances(Digester digester) {" 7c274bb^:"java/org/apache/catalina/startup/WebRuleSet.java"

        sessionConfig = new SetSessionConfig();
        jspConfig = new SetJspConfig();
        loginConfig = new SetLoginConfig();
        

======= fetch "private void convertJsps(WebXml webXml) {" f75418b^:"java/org/apache/catalina/startup/ContextConfig.java"

        Map<String,String> jspInitParams;
======= fetch "private void convertJsps(WebXml webXml) {" f75418b^:"java/org/apache/catalina/startup/ContextConfig.java"

        if (jspServlet == null) {
            jspInitParams = new HashMap<String,String>();
            Wrapper w = (Wrapper) context.findChild("jsp");
            if (w != null) {
                String[] params = w.findInitParameters();
                for (String param : params) {
                    jspInitParams.put(param, w.findInitParameter(param));
                }
            }
        } else {
            jspInitParams = jspServlet.getParameterMap();
        }
======= fetch "private void convertJsps(WebXml webXml) {" f75418b^:"java/org/apache/catalina/startup/ContextConfig.java"

                convertJsp(servletDef, jspServlet);
======= fetch "private void convertJsps(WebXml webXml) {" f75418b^:"java/org/apache/catalina/startup/ContextConfig.java"

    private void convertJsp(ServletDef servletDef, ServletDef jspServletDef) {
======= fetch "private void convertJsp(ServletDef servletDef, ServletDef jspServletDef) {" f75418b^:"java/org/apache/catalina/startup/ContextConfig.java"

        for (Map.Entry<String, String> initParam: jspServletDef.getParameterMap().entrySet()) {
======= fetch "private void doTestOverrideDefaultServletWithSCI(String servletName)" f75418b^:"test/org/apache/catalina/startup/TestContextConfig.java"

    public void testBug51396() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir =  new File("test/webapp-3.0-fragments");
        // app dir is relative to server home
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        
        tomcat.start();
        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug51396.jsp", bc, null);
        
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertTrue(bc.toString().contains("<p>OK</p>"));
    }
  <!-- Bug 51396 -->
  <servlet>
    <servlet-name>bug51396</servlet-name>
    <jsp-file>/bug51396.jsp</jsp-file>
  </servlet>
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <body>
    <p>OK</p>
  </body>
      <fix>
        <bug>51396</bug>: Correctly handle jsp-file entries in web.xml when the
        JSP servlet has been configured via code when embedding Tomcat. (markt)
      </fix>

 * <li><b>%t{format}</b> - Date and time, in any format supported by SimpleDateFormat
======= fetch "public AccessLogValve() {" 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

        "org.apache.catalina.valves.AccessLogValve/2.1";
======= fetch "public AccessLogValve() {" 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * The size of our global date format cache
     */
    private static final int globalCacheSize = 300;
    /**
     * The size of our thread local date format cache
     */
    private static final int localCacheSize = 60;
======= fetch "public AccessLogValve() {" 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

    private static class AccessDateStruct {
        private Date currentDate = new Date();
        private String currentDateString = null;
        private SimpleDateFormat dayFormatter = new SimpleDateFormat("dd");
        private SimpleDateFormat monthFormatter = new SimpleDateFormat("MM");
        private SimpleDateFormat yearFormatter = new SimpleDateFormat("yyyy");
        private SimpleDateFormat timeFormatter = new SimpleDateFormat("HH:mm:ss");
        public AccessDateStruct() {
            TimeZone tz = TimeZone.getDefault();
            dayFormatter.setTimeZone(tz);
            monthFormatter.setTimeZone(tz);
            yearFormatter.setTimeZone(tz);
            timeFormatter.setTimeZone(tz);
======= fetch "public AccessDateStruct() {" 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

    
======= fetch "public AccessDateStruct() {" 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

    private static final ThreadLocal<AccessDateStruct> currentDateStruct =
            new ThreadLocal<AccessDateStruct>() {
======= fetch "public AccessDateStruct() {" 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

        protected AccessDateStruct initialValue() {
            return new AccessDateStruct();
======= fetch "protected AccessDateStruct initialValue() {" 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * The list of our format types.
     */
    private static enum formatType {
        CLF, SEC, MSEC, MSEC_FRAC, SDF
    }
======= fetch "public void log(Request request, Response response, long time) {" 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

        Date date = getDate();
======= fetch "protected synchronized void open() {" 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

    private Date getDate() {
        // Only create a new Date once per second, max.
        long systime = System.currentTimeMillis();
        AccessDateStruct struct = currentDateStruct.get(); 
        if ((systime - struct.currentDate.getTime()) > 1000) {
            struct.currentDate.setTime(systime);
            struct.currentDateString = null;
        }
        return struct.currentDate;
======= fetch "protected synchronized void startInternal() throws LifecycleException {" 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

        dateStamp = fileDateFormatter.format(currentDateStruct.get().currentDate);
======= fetch "public void addElement(StringBuilder buf, Date date, Request request," 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

     * write date and time, in Common Log Format - %t
======= fetch "public void addElement(StringBuilder buf, Date date, Request request," 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

        /**
         * Format prefix specifying request start time
         */
        private static final String requestStartPrefix = "begin";
        /**
         * Format prefix specifying response end time
         */
        private static final String responseEndPrefix = "end";
        /**
         * Separator between optional prefix and rest of format
         */
        private static final String prefixSeparator = ":";
        /**
         * Special format for seconds since epoch
         */
        private static final String secFormat = "sec";
        /**
         * Special format for milliseconds since epoch
         */
        private static final String msecFormat = "msec";
        /**
         * Special format for millisecond part of timestamp
         */
        private static final String msecFractionFormat = "msec_frac";
        /**
         * The pattern we use to replace "S" millisecond formatting
         * of SimpleDateFormat by our own handling
         */
        private static final String msecPattern = "####";
        /* Our format description string, null if CLF */
        private String format = null;
        /* Whether to use begin of request or end of response as the timestamp */
        private boolean usesBegin = false;
        /* The format type */
        private formatType type = formatType.CLF;
        /* Whether we need to postprocess by adding milliseconds */
        private boolean usesMsecs = false;
        protected DateAndTimeElement() {
            this(null);
        }
        /**
         * Replace the millisecond formatting character 'S' by
         * some dummy characters in order to make the resulting
         * formatted time stamps cacheable. We replace the dummy
         * chars later with the actual milliseconds because that's
         * relatively cheap.
         */
        private void tidyFormat() {
            boolean escape = false;
            StringBuilder result = new StringBuilder();
            int len = format.length();
            char x;
            for (int i = 0; i < len; i++) {
                x = format.charAt(i);
                if (escape || x != 'S') {
                    result.append(x);
                } else {
                    result.append(msecPattern);
                    usesMsecs = true;
                }
                if (x == '\'') {
                    escape = !escape;
                }
            }
            format = result.toString();
        }
        protected DateAndTimeElement(String header) {
            format = header;
            if (format != null) {
                if (format.equals(requestStartPrefix)) {
                    usesBegin = true;
                    format = "";
                } else if (format.startsWith(requestStartPrefix + prefixSeparator)) {
                    usesBegin = true;
                    format = format.substring(6);
                } else if (format.equals(responseEndPrefix)) {
                    usesBegin = false;
                    format = "";
                } else if (format.startsWith(responseEndPrefix + prefixSeparator)) {
                    usesBegin = false;
                    format = format.substring(4);
                }
                if (format.length() == 0) {
                    type = formatType.CLF;
                } else if (format.equals(secFormat)) {
                    type = formatType.SEC;
                } else if (format.equals(msecFormat)) {
                    type = formatType.MSEC;
                } else if (format.equals(msecFractionFormat)) {
                    type = formatType.MSEC_FRAC;
                } else {
                    type = formatType.SDF;
                    tidyFormat();
                }
            }
        }
======= fetch "public void addElement(StringBuilder buf, Date date, Request request," 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

            AccessDateStruct struct = currentDateStruct.get();
            if (struct.currentDateString == null) {
                StringBuilder current = new StringBuilder(32);
                current.append('[');
                current.append(struct.dayFormatter.format(date));
                current.append('/');
                current.append(lookup(struct.monthFormatter.format(date)));
                current.append('/');
                current.append(struct.yearFormatter.format(date));
                current.append(':');
                current.append(struct.timeFormatter.format(date));
                current.append(' ');
                current.append(getTimeZone(date));
                current.append(']');
                struct.currentDateString = current.toString();
======= fetch "public void addElement(StringBuilder buf, Date date, Request request," 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

            buf.append(struct.currentDateString);
======= fetch "private AccessLogElement createAccessLogElement(String header, char pattern) {" 7d6c439^:"java/org/apache/catalina/valves/AccessLogValve.java"

        case 't':
            return new DateAndTimeElement(header);
      <fix>
        <bug>49165</bug>: Allow any time stamp formats supported by SimpleDateFormat
        in AccessLogValve. Support logging begin and/or end of request. (rjung)
      </fix>

======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" 9f8b983^:"java/org/apache/catalina/startup/ContextConfig.java"

                match = false;
======= fetch "public void testDuplicateFilterMapping() throws Exception {" 9f8b983^:"test/org/apache/catalina/startup/TestContextConfigAnnotation.java"

    public void testCheckHandleTypes() throws Exception {
        ContextConfig config = new ContextConfig();
        
        // Need a Context, Loader and ClassLoader for checkHandleTypes
        StandardContext context = new StandardContext();
        context.setLoader(new TesterLoader());
        config.context = context;
        // Add an SCI that has no interest in any type
        SCI sciNone = new SCI();
        config.initializerClassMap.put(sciNone, new HashSet<Class<?>>());
        
        // Add an SCI with an interest in Servlets
        SCI sciServlet = new SCI();
        config.initializerClassMap.put(sciServlet, new HashSet<Class<?>>());
        config.typeInitializerMap.put(Servlet.class,
                new HashSet<ServletContainerInitializer>());
        config.typeInitializerMap.get(Servlet.class).add(sciServlet);
        
        // Add an SCI with an interest in Objects - i.e. everything
        SCI sciObject = new SCI();
        config.initializerClassMap.put(sciObject, new HashSet<Class<?>>());
        config.typeInitializerMap.put(Object.class,
                new HashSet<ServletContainerInitializer>());
        config.typeInitializerMap.get(Object.class).add(sciObject);
        // Scan Servlet, Filter, Servlet, Listener
        WebXml ignore = new WebXml();
        File file = paramClassResource(
                "org/apache/catalina/startup/ParamServlet");
        config.processAnnotationsFile(file, ignore);
        file = paramClassResource("org/apache/catalina/startup/ParamFilter");
        config.processAnnotationsFile(file, ignore);
        file = paramClassResource("org/apache/catalina/startup/TesterServlet");
        config.processAnnotationsFile(file, ignore);
        file = paramClassResource("org/apache/catalina/startup/TestListener");
        config.processAnnotationsFile(file, ignore);
        
        // Check right number of classes were noted to be handled
        assertEquals(0, config.initializerClassMap.get(sciNone).size());
        assertEquals(2, config.initializerClassMap.get(sciServlet).size());
        assertEquals(4, config.initializerClassMap.get(sciObject).size());
    }
    private static final class SCI implements ServletContainerInitializer {
        @Override
        public void onStartup(Set<Class<?>> c, ServletContext ctx)
                throws ServletException {
            // NO-OP. Just need a class that implements SCI.
        }
    }
    
    private static final class TesterLoader implements Loader {
        @Override
        public void backgroundProcess() {}
        @Override
        public ClassLoader getClassLoader() {
            return this.getClass().getClassLoader();
        }
        @Override
        public Container getContainer() { return null; }
        @Override
        public void setContainer(Container container) {}
        @Override
        public boolean getDelegate() { return false; }
        @Override
        public void setDelegate(boolean delegate) {}
        @Override
        public String getInfo() { return null; }
        @Override
        public boolean getReloadable() { return false; }
        @Override
        public void setReloadable(boolean reloadable) {}
        @Override
        public void addPropertyChangeListener(PropertyChangeListener l) {
        }
        @Override
        public void addRepository(String repository) {}
        @Override
        public String[] findRepositories() { return null; }
        @Override
        public boolean modified() { return false; }
        @Override
        public void removePropertyChangeListener(PropertyChangeListener l) {}
    }
      <fix>
        <bug>51386</bug>: Correct code for processing @HandlesTypes annotations
        so only types of interest are reported to a ServletContainerInitializer.
        (markt)
      </fix>

======= fetch "protected int compareBranches() {" 874048a^:"java/org/apache/catalina/ssi/ExpressionParseTree.java"

            
            int val2Len = val2.length();
            if (val2Len > 1 && val2.charAt(0) == '/' &&
                    val2.charAt(val2Len - 1) == '/') {
                // Treat as a regular expression
                String expr = val2.substring(1, val2Len - 1);
                Pattern pattern = Pattern.compile(expr);
                // Regular expressions will only ever be used with EqualNode
                // so return zero for equal and non-zero for not equal
                if (pattern.matcher(val1).find()) {
                    return 0;
                } else {
                    return -1;
                }
            }
        <bug>48956</bug>: Add regular expression support for SSI. (markt)
      </add>
      <add>

            " <td colspan=\"6\" class=\"title\">{0}</td>\n" +
======= fetch "protected void list(HttpServletRequest request," 2b8e6cf^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args = new Object[7];
======= fetch "protected void list(HttpServletRequest request," 2b8e6cf^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[7] = sm.getString("htmlManagerServlet.serverHostname");
        args[8] = sm.getString("htmlManagerServlet.serverIPAddress");
======= fetch "protected void list(HttpServletRequest request," 2b8e6cf^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args = new Object[6];
======= fetch "protected void list(HttpServletRequest request," 2b8e6cf^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        try {
            InetAddress address = InetAddress.getLocalHost();
            args[6] = address.getHostName();
            args[7] = address.getHostAddress();
        } catch (UnknownHostException e) {
            args[6] = "-";
            args[7] = "-";
        }
======= fetch "public void doGet(HttpServletRequest request," 2b8e6cf^:"java/org/apache/catalina/manager/StatusManagerServlet.java"

        args = new Object[7];
======= fetch "public void doGet(HttpServletRequest request," 2b8e6cf^:"java/org/apache/catalina/manager/StatusManagerServlet.java"

        args[7] = sm.getString("htmlManagerServlet.serverHostname");
        args[8] = sm.getString("htmlManagerServlet.serverIPAddress");
======= fetch "public void doGet(HttpServletRequest request," 2b8e6cf^:"java/org/apache/catalina/manager/StatusManagerServlet.java"

        args = new Object[6];
======= fetch "public void doGet(HttpServletRequest request," 2b8e6cf^:"java/org/apache/catalina/manager/StatusManagerServlet.java"

        try {
            InetAddress address = InetAddress.getLocalHost();
            args[6] = address.getHostName();
            args[7] = address.getHostAddress();
         } catch (UnknownHostException e) {
            args[6] = "-";
            args[7] = "-";
        }
      <add>
        <bug>43538</bug>: Add host name and IP address to the HTML Manager
        application. Patch by Dennis Lundberg. (markt)
      </add>

======= fetch "protected void handleSESSION_CREATED(SessionMessage msg,Member sender) {" 4e5571f^:"java/org/apache/catalina/ha/session/DeltaManager.java"

        session.setMaxInactiveInterval(getMaxInactiveInterval());
======= fetch "public void expire(boolean notify, boolean notifyCluster) {" 4e5571f^:"java/org/apache/catalina/ha/session/DeltaSession.java"

        if(expiredId != null && manager != null &&

======= fetch "protected void doLock(HttpServletRequest req, HttpServletResponse resp)" 71b18c8^:"java/org/apache/catalina/servlets/WebdavServlet.java"

            // At least one of the tokens of the locks must have been given
            tokenList = toRenew.tokens.elements();
            while (tokenList.hasMoreElements()) {
                String token = tokenList.nextElement();
                if (ifHeader.indexOf(token) != -1) {
                    toRenew.expiresAt = lock.expiresAt;
                    lock = toRenew;

======= fetch "public Embedded(Realm realm) {" 4892b57^:"java/org/apache/catalina/startup/Embedded.java"

     * The lifecycle event support for this component.
     */
    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
    /**
======= fetch "public void addAuthenticator(Authenticator authenticator," 4892b57^:"java/org/apache/catalina/startup/Embedded.java"

     * Add a lifecycle event listener to this component.
     *
     * @param listener The listener to add
     */
    @Override
    public void addLifecycleListener(LifecycleListener listener) {
        lifecycle.addLifecycleListener(listener);
    }
    /**
     * Get the lifecycle listeners associated with this lifecycle. If this 
     * Lifecycle has no listeners registered, a zero-length array is returned.
     */
    @Override
    public LifecycleListener[] findLifecycleListeners() {
        return lifecycle.findLifecycleListeners();
    }
    /**
     * Remove a lifecycle event listener from this component.
     *
     * @param listener The listener to remove
     */
    @Override
    public void removeLifecycleListener(LifecycleListener listener) {
        lifecycle.removeLifecycleListener(listener);
    }
    /**
        <bug>51249</bug>: Further improve system property replacement code
        in ClassLoaderLogManager of Tomcat JULI to cover some corner cases.
        (kkolinko)

======= fetch "protected void parseWebXml(InputSource source, WebXml dest," 1fe28a6^:"java/org/apache/catalina/startup/ContextConfig.java"

        WebRuleSet ruleSet;
======= fetch "protected void parseWebXml(InputSource source, WebXml dest," 1fe28a6^:"java/org/apache/catalina/startup/ContextConfig.java"

            ruleSet = webFragmentRuleSet;
======= fetch "protected void parseWebXml(InputSource source, WebXml dest," 1fe28a6^:"java/org/apache/catalina/startup/ContextConfig.java"

            ruleSet = webRuleSet;
======= fetch "protected void parseWebXml(InputSource source, WebXml dest," 1fe28a6^:"java/org/apache/catalina/startup/ContextConfig.java"

        synchronized(digester) {
======= fetch "protected void parseWebXml(InputSource source, WebXml dest," 1fe28a6^:"java/org/apache/catalina/startup/ContextConfig.java"

                if (fragment) {
                    webFragmentRuleSet.recycle();
                } else {
                    webRuleSet.recycle();
                }

======= fetch "public void recycle() {" 1bbbdb2^:"java/org/apache/catalina/connector/OutputBuffer.java"

        doFlush = false;
======= fetch "protected void doFlush(boolean realFlush)" 1bbbdb2^:"java/org/apache/catalina/connector/OutputBuffer.java"

        doFlush = true;
        if (initial) {
            coyoteResponse.sendHeaders();
            initial = false;
        }
        if (bb.getLength() > 0) {
            bb.flushBuffer();
======= fetch "protected void doFlush(boolean realFlush)" 1bbbdb2^:"java/org/apache/catalina/connector/OutputBuffer.java"

        doFlush = false;

    // ------------------------------------------------------------- Properties
    /**
     * The context path of the web application we are managing.
     */
    protected String path = null;
    public String getPath() {
        return (this.path);
    }
    public void setPath(String path) {
        this.path = path;
    }
    // --------------------------------------------------------- Public Methods
======= fetch "public void execute() throws BuildException {" d19daf5^:"java/org/apache/catalina/ant/ReloadTask.java"

        if (path == null) {
            throw new BuildException
                ("Must specify 'path' attribute");
        }
        try {
            execute("/reload?path=" + URLEncoder.encode(this.path, getCharset()));
        } catch (UnsupportedEncodingException e) {
            throw new BuildException
                ("Invalid 'charset' attribute: " + getCharset());
        }
    // Properties
    /**
     * The context path of the web application we are managing.
     */
    protected String path = null;
    public String getPath() {
        return (this.path);
======= fetch "public String getPath() {" d19daf5^:"java/org/apache/catalina/ant/SessionsTask.java"

    public void setPath(String path) {
        this.path = path;
======= fetch "public void setPath(String path) {" d19daf5^:"java/org/apache/catalina/ant/SessionsTask.java"

    // Public Methods
======= fetch "public void execute() throws BuildException {" d19daf5^:"java/org/apache/catalina/ant/SessionsTask.java"

        if (path == null) {
            throw new BuildException
                ("Must specify 'path' attribute");
        }
        
        try {
            execute("/sessions?path=" + URLEncoder.encode(this.path, getCharset()));
        } catch (UnsupportedEncodingException e) {
            throw new BuildException
                ("Invalid 'charset' attribute: " + getCharset());
        }
    // ------------------------------------------------------------- Properties
    /**
     * The context path of the web application we are managing.
     */
    protected String path = null;
    public String getPath() {
        return (this.path);
    }
    public void setPath(String path) {
        this.path = path;
    }
    // --------------------------------------------------------- Public Methods
======= fetch "public void execute() throws BuildException {" d19daf5^:"java/org/apache/catalina/ant/StartTask.java"

        if (path == null) {
            throw new BuildException
                ("Must specify 'path' attribute");
        }
        try {
            execute("/start?path=" + URLEncoder.encode(this.path, getCharset()));
        } catch (UnsupportedEncodingException e) {
            throw new BuildException
                ("Invalid 'charset' attribute: " + getCharset());
        }
    // ------------------------------------------------------------- Properties
    /**
     * The context path of the web application we are managing.
     */
    protected String path = null;
    public String getPath() {
        return (this.path);
    }
    public void setPath(String path) {
        this.path = path;
    }
    // --------------------------------------------------------- Public Methods
======= fetch "public void execute() throws BuildException {" d19daf5^:"java/org/apache/catalina/ant/StopTask.java"

        if (path == null) {
            throw new BuildException
                ("Must specify 'path' attribute");
        }
        try {
            execute("/stop?path=" + URLEncoder.encode(this.path, getCharset()));
        } catch (UnsupportedEncodingException e) {
            throw new BuildException
                ("Invalid 'charset' attribute: " + getCharset());
        }
======= fetch "public void execute() throws BuildException {" d19daf5^:"java/org/apache/catalina/ant/StopTask.java"

    // ------------------------------------------------------------- Properties
    /**
     * The context path of the web application we are managing.
     */
    protected String path = null;
    public String getPath() {
        return (this.path);
    }
    public void setPath(String path) {
        this.path = path;
    }
    // --------------------------------------------------------- Public Methods
======= fetch "public void execute() throws BuildException {" d19daf5^:"java/org/apache/catalina/ant/UndeployTask.java"

        if (path == null) {
            throw new BuildException
                ("Must specify 'path' attribute");
        }
======= fetch "public void execute() throws BuildException {" d19daf5^:"java/org/apache/catalina/ant/UndeployTask.java"

        try {
            execute("/undeploy?path=" +
                    URLEncoder.encode(this.path, getCharset()));
        } catch (UnsupportedEncodingException e) {
            throw new BuildException
                ("Invalid 'charset' attribute: " + getCharset());
        }

======= fetch "protected void processServletContainerInitializers(" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

            JarInputStream jarInputStream = null;
======= fetch "protected void processServletContainerInitializers(" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                    JarURLConnection jarConn =
                        (JarURLConnection) url.openConnection();
                    URL resourceURL = jarConn.getJarFileURL();
                    URLConnection resourceConn = resourceURL.openConnection();
                    resourceConn.setUseCaches(false);
                    
                    jarInputStream =
                        new JarInputStream(resourceConn.getInputStream());
                    JarEntry entry = jarInputStream.getNextJarEntry();
                    while (entry != null) {
                        if (SCI_LOCATION.equals(entry.getName())) {
                            break;
                        }
                        entry = jarInputStream.getNextJarEntry();
                    }
                    if (entry != null) {
                        is = jarInputStream;
                    }
======= fetch "protected void processServletContainerInitializers(" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                if (jarInputStream != null) {
                    try {
                        jarInputStream.close();
                    } catch (IOException e) {
                        // Ignore
                    }
======= fetch "protected void processResourceJARs(Set<WebXml> fragments) {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

            JarInputStream jarInputStream = null;
======= fetch "protected void processResourceJARs(Set<WebXml> fragments) {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                    JarURLConnection jarConn =
                        (JarURLConnection) url.openConnection();
                    URL resourceURL = jarConn.getJarFileURL();
                    URLConnection resourceConn = resourceURL.openConnection();
                    resourceConn.setUseCaches(false);
                    jarInputStream =
                        new JarInputStream(resourceConn.getInputStream());
                    JarEntry entry = jarInputStream.getNextJarEntry();
                    while (entry != null) {
                        if ("META-INF/resources/".equals(entry.getName())) {
                            break;
                        }
                        entry = jarInputStream.getNextJarEntry();
                    }
                    if (entry != null) {
======= fetch "protected void processResourceJARs(Set<WebXml> fragments) {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                if (jarInputStream != null) {
                    try {
                        jarInputStream.close();
                    } catch (IOException e) {
                        // Ignore
                    }
======= fetch "protected void processAnnotationsJar(URL url, WebXml fragment) {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

        JarInputStream jarInputStream = null;
======= fetch "protected void processAnnotationsJar(URL url, WebXml fragment) {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

            URLConnection urlConn = url.openConnection();
            JarURLConnection jarConn;
            if (!(urlConn instanceof JarURLConnection)) {
                // This should never happen
                sm.getString("contextConfig.jarUrl", url);
                return;
            }
======= fetch "protected void processAnnotationsJar(URL url, WebXml fragment) {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

            jarConn = (JarURLConnection) urlConn;
            jarConn.setUseCaches(false);
            URL resourceURL = jarConn.getJarFileURL();
            URLConnection resourceConn = resourceURL.openConnection();
            jarInputStream = new JarInputStream(resourceConn.getInputStream());
            JarEntry entry = jarInputStream.getNextJarEntry();
            while (entry != null) {
                String entryName = entry.getName();
======= fetch "protected void processAnnotationsJar(URL url, WebXml fragment) {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                    is = null;
======= fetch "protected void processAnnotationsJar(URL url, WebXml fragment) {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                        processAnnotationsStream(jarInputStream, fragment);
======= fetch "protected void processAnnotationsJar(URL url, WebXml fragment) {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                    } finally {
                        if (is != null) {
                            try {
                                is.close();
                            } catch (IOException ioe) {
                                // Ignore
                            }
                        }
======= fetch "protected void processAnnotationsJar(URL url, WebXml fragment) {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                entry = jarInputStream.getNextJarEntry();
======= fetch "protected void processAnnotationsJar(URL url, WebXml fragment) {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

            if (jarInputStream != null) {
                try {
                    jarInputStream.close();
                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                }
======= fetch "public void scan(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

            // JarURLConnection#getJarFile() creates temporary copies of the JAR
            // if the underlying resource is not a file URL. That can be slow so
            // the InputStream for the resource is used
======= fetch "public void scan(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

            JarInputStream jarInputStream = null;
======= fetch "public void scan(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                URLConnection resourceConn = resourceURL.openConnection();
                resourceConn.setUseCaches(false);
                jarInputStream =
                    new JarInputStream(resourceConn.getInputStream());
                JarEntry entry = jarInputStream.getNextJarEntry();
                while (entry != null) {
                    if (FRAGMENT_LOCATION.equals(entry.getName())) {
                        break;
                    }
                    entry = jarInputStream.getNextJarEntry();
                }
======= fetch "public void scan(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                if (entry == null) {
======= fetch "public void scan(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                    source.setByteStream(jarInputStream);
======= fetch "public void scan(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                if (jarInputStream != null) {
======= fetch "public void scan(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                        jarInputStream.close();
                    } catch (Throwable t) {
                        ExceptionUtils.handleThrowable(t);
======= fetch "public void scan(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/catalina/startup/ContextConfig.java"

                fragment.setURL(jarConn.getURL());
======= fetch "private void tldScanJar(JarURLConnection jarConn) {" 5109678^:"java/org/apache/catalina/startup/TldConfig.java"

        // JarURLConnection#getJarFile() creates temporary copies of the JAR if
        // the underlying resource is not a file URL. That can be slow so the
        // InputStream for the resource is used
        URL resourceURL = jarConn.getJarFileURL();
        NonClosingJarInputStream jarInputStream = null;
        String name = null;
======= fetch "private void tldScanJar(JarURLConnection jarConn) {" 5109678^:"java/org/apache/catalina/startup/TldConfig.java"

            URLConnection resourceConn = resourceURL.openConnection();
            resourceConn.setUseCaches(false);
            jarInputStream =
                new NonClosingJarInputStream(resourceConn.getInputStream());
            JarEntry entry = jarInputStream.getNextJarEntry();
            while (entry != null) {
                name = entry.getName();
                if (name.startsWith("META-INF/") && name.endsWith(".tld")) {
                    XmlErrorHandler handler = tldScanStream(jarInputStream);
                    handler.logFindings(log, jarConn.getURL() + name);
======= fetch "private void tldScanJar(JarURLConnection jarConn) {" 5109678^:"java/org/apache/catalina/startup/TldConfig.java"

                entry = jarInputStream.getNextJarEntry();
======= fetch "private void tldScanJar(JarURLConnection jarConn) {" 5109678^:"java/org/apache/catalina/startup/TldConfig.java"

            log.warn(sm.getString("tldConfig.jarFail", jarConn.getURL() + name),
                    ioe);
======= fetch "private void tldScanJar(JarURLConnection jarConn) {" 5109678^:"java/org/apache/catalina/startup/TldConfig.java"

            if (jarInputStream != null) {
                try {
                    jarInputStream.reallyClose();
                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                }
======= fetch "private void tldScanJar(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

        // JarURLConnection#getJarFile() creates temporary copies of the JAR if
        // the underlying resource is not a file URL. That can be slow so the
        // InputStream for the resource is used
======= fetch "private void tldScanJar(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

        NonClosingJarInputStream jarInputStream = null;
        
        boolean foundTld = false;
======= fetch "private void tldScanJar(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

            URLConnection resourceConn = resourceURL.openConnection();
            resourceConn.setUseCaches(false);
            jarInputStream =
                new NonClosingJarInputStream(resourceConn.getInputStream());
            JarEntry entry = jarInputStream.getNextJarEntry();
            while (entry != null) {
                String name = entry.getName();
                if (name.startsWith("META-INF/") && name.endsWith(".tld")) {
                    foundTld = true;
                    tldScanStream(resourcePath, name, jarInputStream);
======= fetch "private void tldScanJar(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

                entry = jarInputStream.getNextJarEntry();
======= fetch "private void tldScanJar(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

            if (jarInputStream != null) {
                try {
                    jarInputStream.reallyClose();
                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                }
======= fetch "private void tldScanJar(JarURLConnection jarConn) throws IOException {" 5109678^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Implementation of {@link Jar} that is optimised for file based JAR URLs (e.g
 * URLs of the form jar:file:...).
 */
    private JarFile jarFile;
    private Enumeration<JarEntry> entries;
    private JarEntry entry = null;
    public FileUrlJar(URL url) throws IOException {
        JarURLConnection jarConn = (JarURLConnection) url.openConnection();
        jarFile = jarConn.getJarFile();
    }
    @Override
    public boolean entryExists(String name) {
        ZipEntry entry = jarFile.getEntry(name);
        return entry != null;
    }
    @Override
    public InputStream getInputStream(String name) throws IOException {
        ZipEntry entry = jarFile.getEntry(name);
        if (entry == null) {
            return null;
        } else {
            return jarFile.getInputStream(entry);
        }
    }
    @Override
    public void close() {
        if (jarFile != null) {
            try {
                jarFile.close();
            } catch (IOException e) {
                // Ignore
            }
        }
    }
    @Override
    public void nextEntry() {
        if (entries == null) {
            entries = jarFile.entries();
        }
        if (entries.hasMoreElements()) {
            entry = entries.nextElement();
        } else {
            entry = null;
        }
    }
    @Override
    public String getEntryName() {
        if (entry == null) {
            return null;
        } else {
            return entry.getName();
        }
    }
    @Override
    public InputStream getEntryInputStream() throws IOException {
        if (entry == null) {
            return null;
        } else {
            return jarFile.getInputStream(entry);
        }
    }
    @Override
    public void reset() throws IOException {
        entries = null;
        entry = null;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Provides an abstraction for use by the various classes that need to scan
 * JARs. The classes provided by the JRE for accessing JARs ({@link JarFile} and
 * {@link JarInputStream}) have significantly different performance
 * characteristics depending on the form of the URL used to access the JAR.
 * For file based JAR {@link URL}s, {@link JarFile} is faster but for non-file
 * based {@link URL}s, {@link JarFile} creates a copy of the JAR in the
 * temporary directory so {@link JarInputStream} is faster.
 */
    /**
     * Determines if a specific entry exists within the JAR.
     * 
     * @param name  Entry to look for
     * @return      <code>true</code> if the specified entry exists else
     *               <code>false</code>
     */
    boolean entryExists(String name) throws IOException;
    
    
    /**
     * Obtain an {@link InputStream} for a given entry in a JAR. The caller is
     * responsible for closing the stream.
     * 
     * @param name  Entry to obtain an {@link InputStream} for
     * @return      An {@link InputStream} for the specified entry or null if
     *              the entry does not exist
     */
    InputStream getInputStream(String name) throws IOException;
    /**
     * Close any resources associated with this JAR.
     */
    void close();
    
    /**
     * Moves the internal pointer to the next entry in the JAR.
     */
    void nextEntry();
    
    /**
     * Obtains the name of the current entry.
     * 
     * @return  The entry name
     */
    String getEntryName();
    
    /**
     * Obtains the input stream for the current entry.
     * 
     * @return  The input stream
     * @throws IOException  If the stream cannot be obtained
     */
    InputStream getEntryInputStream() throws IOException;
    
    /**
     * Resets the internal pointer used to track JAR entries to the beginning of
     * the JAR.
     * 
     * @throws IOException  If the pointer cannot be reset
     */
    void reset() throws IOException;
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Provide a mechanism to obtain objects that implement {@link Jar}.
 */
    private JarFactory() {
        // Factory class. Hide public constructor.
    }
    public static Jar newInstance(URL url) throws IOException {
        String jarUrl = url.toString();
        if (jarUrl.startsWith("jar:file:")) {
            return new FileUrlJar(url);
        } else {
            return new UrlJar(url);
        }
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Implementation of {@link Jar} that is optimised for non-file based JAR URLs
 * (e.g. JNDI based URLs of the form jar:jndi:...).
 */
    private NonClosingJarInputStream jarInputStream = null;
    private URL url = null;
    private JarEntry entry = null;
    public UrlJar(URL url) throws IOException {
        this.url = url;
        this.jarInputStream = createJarInputStream();
    }
    @Override
    public boolean entryExists(String name) throws IOException {
        JarEntry entry = jarInputStream.getNextJarEntry();
        while (entry != null) {
            if (name.equals(entry.getName())) {
                break;
            }
            entry = jarInputStream.getNextJarEntry();
        }
        
        return entry != null;
    }
    @Override
    public InputStream getInputStream(String name) throws IOException {
        JarEntry entry = jarInputStream.getNextJarEntry();
        while (entry != null) {
            if (name.equals(entry.getName())) {
                break;
            }
            entry = jarInputStream.getNextJarEntry();
        }
        
        if (entry == null) {
            return null;
        } else {
            return jarInputStream;
        }
    }
    @Override
    public void close() {
        if (jarInputStream != null) {
            try {
                jarInputStream.reallyClose();
            } catch (IOException ioe) {
                // Ignore
            }
        }
    }
    private NonClosingJarInputStream createJarInputStream() throws IOException {
        JarURLConnection jarConn = (JarURLConnection) url.openConnection();
        URL resourceURL = jarConn.getJarFileURL();
        URLConnection resourceConn = resourceURL.openConnection();
        resourceConn.setUseCaches(false);
        return new NonClosingJarInputStream(resourceConn.getInputStream());
    }
    @Override
    public void nextEntry() {
        try {
            entry = jarInputStream.getNextJarEntry();
        } catch (IOException ioe) {
            entry = null;
        }
    }
    @Override
    public String getEntryName() {
        if (entry == null) {
            return null;
        } else {
            return entry.getName();
        }
    }
    @Override
    public InputStream getEntryInputStream() throws IOException {
        return jarInputStream;
    }
    @Override
    public void reset() throws IOException {
        close();
        jarInputStream = createJarInputStream();
    }
        <bug>51276</bug>: Provide an abstraction for accessing content in JARs
        so the most efficient method can be selected depending on the type of
        URL used to identify the JAR. This improves startup time when JARs are
        located in $CATALINA_BASE/lib. (mark)
      </fix>
      <fix>

======= fetch "protected void forwardToLoginPage(Request request," 5b0919c^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

        
        String loginPage = config.getLoginPage();
        if (loginPage == null || loginPage.length() == 0) {
            String msg = sm.getString("formAuthenticator.noLoginPage",
                    context.getName());
            log.warn(msg);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                    msg);
            return;
        }
        
======= fetch "protected void forwardToLoginPage(Request request," 5b0919c^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

            context.getServletContext().getRequestDispatcher
            (config.getLoginPage());
======= fetch "protected void forwardToErrorPage(Request request," 5b0919c^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

        
        String errorPage = config.getErrorPage();
        if (errorPage == null || errorPage.length() == 0) {
            String msg = sm.getString("formAuthenticator.noErrorPage",
                    context.getName());
            log.warn(msg);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                    msg);
            return;
        }
      <fix>
        <bug>51277</bug>: Improve error message if an application is deployed
        with an incomplete FORM authentication configuration. (markt)
      </fix>

    private volatile CounterLatch connectionCounterLatch = null;
======= fetch "public SocketProperties getSocketProperties() {" 73f9592^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    public void setMaxConnections(int maxCon) { this.maxConnections = maxCon; }
======= fetch "public String adjustRelativePath(String path, String relativeTo) {" 73f9592^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    protected CounterLatch initializeConnectionLatch() {
        if (connectionCounterLatch==null) {
            connectionCounterLatch = new CounterLatch(0,getMaxConnections());
======= fetch "protected CounterLatch initializeConnectionLatch() {" 73f9592^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

        return connectionCounterLatch;
======= fetch "protected void releaseConnectionLatch() {" 73f9592^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

        CounterLatch latch = connectionCounterLatch;
======= fetch "protected void releaseConnectionLatch() {" 73f9592^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

        connectionCounterLatch = null;
    }
    
    protected void awaitConnection() throws InterruptedException {
        CounterLatch latch = connectionCounterLatch;
        if (latch!=null) latch.await();
======= fetch "protected void awaitConnection() throws InterruptedException {" 73f9592^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    protected long countUpConnection() {
        CounterLatch latch = connectionCounterLatch;
        if (latch!=null) return latch.countUp();
        else return -1;
======= fetch "protected long countDownConnection() {" 73f9592^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

        CounterLatch latch = connectionCounterLatch;
======= fetch "public void run() {" 73f9592^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    awaitConnection();
======= fetch "public void run() {" 73f9592^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    //increment socket count
                    countUpConnection();
======= fetch "public void run() {" 73f9592^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

                    awaitConnection();
======= fetch "public void run() {" 73f9592^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

                        } else {
                            countUpConnection();
======= fetch "public void run() {" 73f9592^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                    awaitConnection();
======= fetch "public void run() {" 73f9592^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                        } else {
                            countUpConnection();
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Simple counter latch that allows code to keep an up and down counter, and waits while the latch holds a certain wait value.
 * and threads using the latch to wait if the count has reached a certain value.
 * The counter latch can be used to keep track of an atomic counter, since the operations {@link #countDown()}
 * and {@link #countUp()} are atomic.
 * When the latch reaches the wait value, threads will block. The counter latch can hence act like a 
 * count down latch or a count up latch, while letting you keep track of the counter as well.
 * This counter latch works opposite as the java.util.concurrent.CountDownLatch, since the CounterLatch only blocks on a single value and releases the threads on all other values.
 * @author fhanik
 * @see <a href="http://download.oracle.com/javase/6/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a>
 *
 */
    private class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 1L;
        public Sync() {
        }
        @Override
        protected int tryAcquireShared(int arg) {
            return ((!released) && count.get() == signal) ? -1 : 1;
        }
        @Override
        protected boolean tryReleaseShared(int arg) {
            return true;
        }
    }
    private final Sync sync;
    private final AtomicLong count;
    private volatile long signal;
    private volatile boolean released = false;
    
    /**
     * Instantiates a CounterLatch object with an initial value and a wait value.
     * @param initial - initial value of the counter
     * @param waitValue - when the counter holds this value, 
     * threads calling {@link #await()} or {@link #await(long, TimeUnit)} 
     * will wait until the counter changes value or until they are interrupted.  
     */
    public CounterLatch(long initial, long waitValue) {
        this.signal = waitValue;
        this.count = new AtomicLong(initial);
        this.sync = new Sync();
    }
    /**
     * Causes the calling thread to wait if the counter holds the waitValue.
     * If the counter holds any other value, the thread will return
     * If the thread is interrupted or becomes interrupted an InterruptedException is thrown
     * @throws InterruptedException
     */
    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    /**
     * Causes the calling thread to wait if the counter holds the waitValue.
     * If the counter holds any other value, the thread will return
     * If the thread is interrupted or becomes interrupted an InterruptedException is thrown
     * @return true if the value changed, false if the timeout has elapsed
     * @throws InterruptedException
     */
    public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }
    /**
     * Increments the counter
     * @return the previous counter value
     */
    public long countUp() {
        long previous = count.getAndIncrement();
        if (previous == signal) {
            sync.releaseShared(0);
        }
        return previous;
    }
    /**
     * Decrements the counter
     * @return the previous counter value
     */
    public long countDown() {
        long previous = count.getAndDecrement();
        if (previous == signal) {
            sync.releaseShared(0);
        }
        return previous;
    }
    
    /**
     * Returns the current counter value
     * @return the current counter value
     */
    public long getCount() {
        return count.get();
    }
    
    /**
     * Performs an atomic update of the counter 
     * If the operation is successful and {@code expect==waitValue && expect!=update} waiting threads will be released.  
     * @param expect - the expected counter value
     * @param update - the new counter value
     * @return <code>true</code> if successful, <code>false</code> if the
     *         current value wasn't as expected
     */
    public boolean compareAndSet(long expect, long update) {
        boolean result = count.compareAndSet(expect, update);
        if (result && expect==signal && expect != update) {
            sync.releaseShared(0);
        }
        return result;
    }
    
    /**
     * returns true if there are threads blocked by this latch
     * @return true if there are threads blocked by this latch
     */
    public boolean hasQueuedThreads() {
        return sync.hasQueuedThreads();
    }
    
    /**
     * Returns a collection of the blocked threads
     * @return a collection of the blocked threads
     */
    public Collection<Thread> getQueuedThreads() {
        return sync.getQueuedThreads();
    }
    
    /**
     * releases all waiting threads. This operation is permanent, and no threads will block,
     * even if the counter hits the {@code waitValue} until {@link #reset(long)} has been called.
     * @return <code>true</code> if this release of shared mode may permit a
     *         waiting acquire (shared or exclusive) to succeed; and
     *         <code>false</code> otherwise
     */
    public boolean releaseAll() {
        released = true;
        return sync.releaseShared(0);
    }
    
    /**
     * Resets the latch and initializes the counter with the new value.
     * @param value the new counter value
     * @see #releaseAll()
     */
    public void reset(long value) {
        this.count.set(value);
        released = false;
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    private volatile CounterLatch latch = null;
    @Override
    public void tearDown() {
        CounterLatch temp = latch;
        if (temp!=null) temp.releaseAll();
        latch = null;
    }
    public void testNoThreads() throws Exception {
        latch = new CounterLatch(0,0);
        assertEquals("No threads should be waiting", false, latch.hasQueuedThreads());
    }
    public void testOneThreadNoWait() throws Exception {
        latch = new CounterLatch(0,1);
        assertEquals("No threads should be waiting", false, latch.hasQueuedThreads());
        Thread testThread = new Thread() {
            @Override
            public void run() {
                try {
                    latch.await();
                } catch (InterruptedException x) {
                    x.printStackTrace();
                }
            }
        };
        testThread.start();
        Thread.sleep(50);
        assertEquals("0 threads should be waiting", 0, latch.getQueuedThreads().size());
        latch.countUp();
        Thread.sleep(50);
        assertEquals("No threads should be waiting", false, latch.hasQueuedThreads());
    }
    public void testOneThreadWaitCountUp() throws Exception {
        latch = new CounterLatch(0,1);
        assertEquals("No threads should be waiting", false, latch.hasQueuedThreads());
        Thread testThread = new Thread() {
            @Override
            public void run() {
                try {
                    latch.await();
                } catch (InterruptedException x) {
                    x.printStackTrace();
                }
            }
        };
        latch.countUp();
        testThread.start();
        Thread.sleep(50);
        assertEquals("1 threads should be waiting", 1, latch.getQueuedThreads().size());
        latch.countUp();
        Thread.sleep(50);
        assertEquals("No threads should be waiting", false, latch.hasQueuedThreads());
    }
    public void testOneThreadWaitCountDown() throws Exception {
        latch = new CounterLatch(1,0);
        assertEquals("No threads should be waiting", false, latch.hasQueuedThreads());
        Thread testThread = new Thread() {
            @Override
            public void run() {
                try {
                    //System.out.println("Entering ["+Thread.currentThread().getName()+"]");
                    latch.await();
                } catch (InterruptedException x) {
                    x.printStackTrace();
                }
                //System.out.println("Exiting ["+Thread.currentThread().getName()+"]");
            }
        };
        latch.countDown();
        testThread.start();
        Thread.sleep(50);
        assertEquals("1 threads should be waiting", 1, latch.getQueuedThreads().size());
        latch.countDown();
        Thread.sleep(50);
        assertEquals("No threads should be waiting", false, latch.hasQueuedThreads());
    }
    
    public void testOneRelease() throws Exception {
        latch = new CounterLatch(1,0);
        assertEquals("No threads should be waiting", false, latch.hasQueuedThreads());
        Thread testThread = new Thread() {
            @Override
            public void run() {
                try {
                    latch.await();
                } catch (InterruptedException x) {
                    x.printStackTrace();
                }
            }
        };
        latch.countDown();
        testThread.start();
        Thread.sleep(50);
        assertEquals("1 threads should be waiting", 1, latch.getQueuedThreads().size());
        latch.releaseAll();
        Thread.sleep(50);
        assertEquals("No threads should be waiting", false, latch.hasQueuedThreads());
    }    

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Ant task that implements the <code>/findleaks</code> command, supported by
 * the Tomcat manager application.
 */
    private boolean statusLine = true;
    /**
     * Sets the statusLine parameter that controls if the response includes a
     * status line or not.
     */
    public void setStatusLine(boolean statusLine) {
        this.statusLine = statusLine;
    }
    /**
     * Returns the statusLine parameter that controls if the response includes a
     * status line or not.
     */
    public boolean getStatusLine() {
        return statusLine;
    }
    /**
     * Execute the requested operation.
     *
     * @exception BuildException if an error occurs
     */
    @Override
    public void execute() throws BuildException {
        super.execute();
        execute("/findleaks?statusLine=" + Boolean.toString(statusLine));
    }
======= fetch "protected String findleaks(StringManager smClient) {" 1cd5e7b^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        super.findleaks(printWriter, smClient);
======= fetch "protected String findleaks(StringManager smClient) {" 1cd5e7b^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        if (stringWriter.getBuffer().length() > 0) {
            msg.append(smClient.getString("htmlManagerServlet.findleaksList"));
            msg.append(stringWriter.toString());
======= fetch "public void doGet(HttpServletRequest request," 1cd5e7b^:"java/org/apache/catalina/manager/ManagerServlet.java"

        
        boolean statusLine = false;
        if ("true".equals(request.getParameter("statusLine"))) {
            statusLine = true;
        }
======= fetch "public void doGet(HttpServletRequest request," 1cd5e7b^:"java/org/apache/catalina/manager/ManagerServlet.java"

            findleaks(writer, smClient);
======= fetch "public void init() throws ServletException {" 1cd5e7b^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void findleaks(PrintWriter writer, StringManager smClient) {
======= fetch "protected void findleaks(PrintWriter writer, StringManager smClient) {" 1cd5e7b^:"java/org/apache/catalina/manager/ManagerServlet.java"

        for (String result : results) {
            if ("".equals(result)) {
                result = "/";
======= fetch "protected void findleaks(PrintWriter writer, StringManager smClient) {" 1cd5e7b^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(result);

======= fetch "public AuthenticatorBase() {" 4161179^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

     * with IE 
======= fetch "public AuthenticatorBase() {" 4161179^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

    protected boolean securePagesWithPragma = true;
======= fetch "public void invoke(Request request, Response response)" 4161179^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

            // FIXME: Disabled for Mozilla FORM support over SSL 
            // (improper caching issue)
            //!request.isSecure() &&
======= fetch "public void invoke(Request request, Response response)" 4161179^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

                // FIXME: These cause problems with downloading office docs
                // from IE under SSL and may not be needed for newer Mozilla
                // clients.
        If not set, the default value of <code>true</code> will be used.</p>
        If not set, the default value of <code>true</code> will be used.</p>
        If not set, the default value of <code>true</code> will be used.</p>
        If not set, the default value of <code>true</code> will be used.</p>
        If not set, the default value of <code>true</code> will be used.</p>

======= fetch "public PoolConfiguration getPoolProperties() {" 4bdd8d0^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    public synchronized ConnectionPool createPool() throws SQLException {

======= fetch "public void start() {" 9bb6e4f^:"java/org/apache/catalina/startup/HostConfig.java"

                if ( (!dirs[i].exists()) && (!dirs[i].mkdirs())) {

    private static final boolean POOL_TAGS_WITH_EXTENDS =
        Boolean.getBoolean("org.apache.jasper.compiler.Generator.VAR_EXPRESSIONFACTORY");
======= fetch "private void generatePostamble() {" c46e56c^:"java/org/apache/jasper/compiler/Generator.java"

        if (pageInfo.getExtends(false) == null) {

      <fix>
        <bug>51229</bug>: Fix bugs in the Servlet 3.0 asynchronous examples.
        Patch provided by Eiji Takahashi. (markt)
      </fix>
======= fetch "protected void service(final HttpServletRequest req, final HttpServletResponse r" 55d8b72^:"webapps/examples/WEB-INF/classes/async/Async0.java"

            req.getAsyncContext().complete();
======= fetch "protected void service(final HttpServletRequest req, final HttpServletResponse r" 55d8b72^:"webapps/examples/WEB-INF/classes/async/Async0.java"

   <a href="<%=response.encodeURL("/examples/async/stock")%>"> StockTicker </a>

======= fetch "public void setProperties(Map<String, InterceptorProperty> properties) {" b24b17c^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java"

        private int nrOfInvocations;
        private long maxInvocationTime = Long.MIN_VALUE;
        private long maxInvocationDate;
        private long minInvocationTime = Long.MAX_VALUE;
        private long minInvocationDate;
        private long totalInvocationTime;
        private long failures;
        private int prepareCount;
        private long prepareTime;

======= fetch "public String getJdbcInterceptors() {" 2bb247a^:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

                            definitions[i].addProperty(new InterceptorProperty(propName,propValue));

======= fetch "protected boolean removeSessionAttribute(ContextName cn, String sessionId," de7f0e1^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        " <td class=\"row-left\" bgcolor=\"{13}\" rowspan=\"2\">\n" +
======= fetch "protected boolean removeSessionAttribute(ContextName cn, String sessionId," de7f0e1^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "</tr>\n<tr></tr>\n";

 * @deprecated
 * @deprecated
 * @deprecated
 * @deprecated
 * @deprecated
 * @deprecated

     * @deprecated
     * @deprecated
     * @deprecated
     * @deprecated

======= fetch "public void setAttribute(String name, Object value, boolean notify,boolean addDe" 0559491^:"java/org/apache/catalina/ha/session/DeltaSession.java"

            if (addDeltaRequest && (deltaRequest != null)) deltaRequest.setAttribute(name, value);
======= fetch "protected void removeAttributeInternal(String name, boolean notify," 0559491^:"java/org/apache/catalina/ha/session/DeltaSession.java"

            if (addDeltaRequest && (deltaRequest != null)) deltaRequest.removeAttribute(name);

======= fetch "either the original SSO logon was of DIGEST or SSL (which" 343a609^:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

                lc = new LoginContext(loginConfigName);
======= fetch "either the original SSO logon was of DIGEST or SSL (which" 343a609^:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

            GSSManager manager = GSSManager.getInstance();
            gssContext = manager.createContext(manager.createCredential(null,
                    GSSCredential.DEFAULT_LIFETIME,
                    new Oid("1.3.6.1.5.5.2"),
                    GSSCredential.ACCEPT_ONLY));
======= fetch "either the original SSO logon was of DIGEST or SSL (which" 343a609^:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

                    storeDelegatedCredential);
======= fetch "either the original SSO logon was of DIGEST or SSL (which" 343a609^:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
            return false;
        } catch (PrivilegedActionException e) {
            log.error(sm.getString("spnegoAuthenticator.serviceLoginFail", e));
            response.setHeader("WWW-Authenticate", "Negotiate");
      <fix>
        <bug>51099</bug>: Correctly implement non-default login configurations
        (configured via the loginConfigName attribute) for the the SPNEGO
        authenticator. (fhanik/markt)
      </fix>

    protected String loginModuleName = null;
======= fetch "private void init() {" 2ffa0f7^:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

        
        loginModuleName = System.getProperty(
                "com.sun.management.jmxremote.login.config");
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 2ffa0f7^:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

                env.put("jmx.remote.x.login.config", loginModuleName);
        <bug>51119</bug>: Add JAAS authentication support to the
        JMXRemoteLifecycleListener. Patch provided by Neil Laurance. (markt) 
      </add>
      <add>

======= fetch "public BodyContentImpl(JspWriter enclosingWriter) {" 2cdbcd5^:"java/org/apache/jasper/runtime/BodyContentImpl.java"

        bufferSize = Constants.DEFAULT_TAG_BUFFER_SIZE;
        cb = new char[bufferSize];
======= fetch "public void clear() throws IOException {" 2cdbcd5^:"java/org/apache/jasper/runtime/BodyContentImpl.java"

                bufferSize = Constants.DEFAULT_TAG_BUFFER_SIZE;
                cb = new char[bufferSize];
======= fetch "private void reAllocBuff(int len) {" 2cdbcd5^:"java/org/apache/jasper/runtime/BodyContentImpl.java"

        bufferSize = cb.length + len;
        char[] tmp = new char[bufferSize];
        
======= fetch "private void reAllocBuff(int len) {" 2cdbcd5^:"java/org/apache/jasper/runtime/BodyContentImpl.java"

        tmp = null;
        

======= fetch "public Context addContext(Host host, String contextPath, String dir) {" 2dc54c4^:"java/org/apache/catalina/startup/Tomcat.java"

        return addContext(host, contextPath, contextPath, dir);
    }
    public Context addContext(Host host, String contextPath, String contextName,
            String dir) {
======= fetch "public Context addContext(Host host, String contextPath, String dir) {" 2dc54c4^:"java/org/apache/catalina/startup/Tomcat.java"

        ctx.setPath( contextPath );
======= fetch "public Context addWebapp(Host host, String url, String path) {" 2dc54c4^:"java/org/apache/catalina/startup/Tomcat.java"

        return addWebapp(host, url, url, path);
    }
    public Context addWebapp(Host host, String url, String name, String path) {
======= fetch "public Context addWebapp(Host host, String url, String path) {" 2dc54c4^:"java/org/apache/catalina/startup/Tomcat.java"

        ctx.setPath( url );

======= fetch "public void run() {" 75d28d4^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                        return;
      <fix>
        <bug>51095</bug>: Don&apos;t trigger a NullPointerException when the SSL
        handshake fails with the HTTP-APR connector. Patch provided by Mike
        Glazer. (markt)
      </fix>

======= fetch "public void bind() throws Exception {" 3a847c7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            } else if ("all".equalsIgnoreCase(SSLProtocol) ||
                    SSLProtocol == null || SSLProtocol.length() == 0) {
                // NOOP, use the default defined above
            } else {
                // Protocol not recognized, fail to start as it is safer than
                // continuing with the default which might enable more than the
                // is required
                throw new Exception(sm.getString(
                        "endpoint.apr.invalidSslProtocol", SSLProtocol));
======= fetch "public void bind() throws Exception {" 3a847c7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

      <fix>
        <bug>51073</bug>: Throw an exception and do not start the APR connector
        if it is configured for SSL and an invalid value is provided for
        SSLProtocol. (markt)
      </fix>

     * Set the session identifier for this session.
======= fetch "protected void handleSESSION_CREATED(SessionMessage msg,Member sender) {" dc3758e^:"java/org/apache/catalina/ha/session/DeltaManager.java"

        if(notifySessionListenersOnReplication) {
            session.setId(msg.getSessionID());
        } else {
            session.setIdInternal(msg.getSessionID());
            add(session);
        }
======= fetch "protected void handleCHANGE_SESSION_ID(SessionMessage msg,Member sender) throws" dc3758e^:"java/org/apache/catalina/ha/session/DeltaManager.java"

            if (notifySessionListenersOnReplication) {
                session.setId(newSessionID);
            } else {
                session.setIdInternal(newSessionID);
                add(session);
            }
======= fetch "public void setPrimarySession(boolean primarySession) {" dc3758e^:"java/org/apache/catalina/ha/session/DeltaSession.java"

======= fetch "public void setPrimarySession(boolean primarySession) {" dc3758e^:"java/org/apache/catalina/ha/session/DeltaSession.java"

     * Set the session identifier for this session without notify listeners.
     *
     * @param id
     *            The new session identifier
======= fetch "public void setPrimarySession(boolean primarySession) {" dc3758e^:"java/org/apache/catalina/ha/session/DeltaSession.java"

    public void setIdInternal(String id) {
        this.id = id;
======= fetch "public void setIdInternal(String id) {" dc3758e^:"java/org/apache/catalina/ha/session/DeltaSession.java"

======= fetch "protected void changeSessionID(Request request, String sessionId," dc3758e^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

        // FIXME: setId trigger session Listener, but only chance to register manager with correct id!
        catalinaSession.setId(newSessionID);
======= fetch "public void setId(String id) {" dc3758e^:"java/org/apache/catalina/manager/DummyProxySession.java"

    public void setId(String id, boolean notify) {
        this.sessionId = id;
        // Ignore notify
    }
    @Override
======= fetch "public void changeSessionId(Session session) {" dc3758e^:"java/org/apache/catalina/session/ManagerBase.java"

        session.setId(generateSessionId());
======= fetch "public void setId(String id) {" dc3758e^:"java/org/apache/catalina/session/StandardSession.java"

        setId(id, true);
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setId(String id, boolean notify) {
======= fetch "public void setId(String id) {" dc3758e^:"java/org/apache/catalina/session/StandardSession.java"

        tellNew();

======= fetch "public boolean asyncDispatch(org.apache.coyote.Request req," dc3dff4^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                ((Context) request.getMappingData().context).logAccess(
                        request, response,
                        System.currentTimeMillis() - req.getStartTime(),
                        false);
    // Time for a request to process (need to allow for threads to start etc.)
    private static final long REQUEST_TIME = 500;
    // Timeout thread (where used) checks for timeout every second
    private static final long TIMEOUT_MARGIN = 1000;
======= fetch "public void testBug49528() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= fetch "public void testBug49528() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() >
                Bug49528Servlet.THREAD_SLEEP_TIME);
        assertTrue(entry.toString(), entry.getTime() <
                Bug49528Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);
======= fetch "public void testBug49567() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= fetch "public void testBug49567() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() >
        Bug49567Servlet.THREAD_SLEEP_TIME);
        assertTrue(entry.toString(), entry.getTime() <
                Bug49567Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);
======= fetch "public void testAsyncStartNoComplete() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= fetch "public void testAsyncStartNoComplete() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        
        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(2, entries.size());
        for (Entry entry : entries) {
            assertEquals(200, entry.getStatus());
            assertTrue(entry.toString(), entry.getTime() >
                    AsyncStartNoCompleteServlet.ASYNC_TIMEOUT);
            assertTrue(entry.toString(), entry.getTime() <
                    AsyncStartNoCompleteServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN +
                            REQUEST_TIME);
        }
======= fetch "public void testAsyncStartWithComplete() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= fetch "public void testAsyncStartWithComplete() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() < REQUEST_TIME);
======= fetch "public void testAsyncStartWithComplete() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        public static final long THREAD_SLEEP_TIME = 1000;
======= fetch "public void run() {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                        Thread.sleep(1000);
======= fetch "public void run() {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        public static final long THREAD_SLEEP_TIME = 1000;
======= fetch "public void run() {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                                Thread.sleep(1000);
======= fetch "public void run() {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        public static final long ASYNC_TIMEOUT = 1000;
        
======= fetch "protected void doGet(final HttpServletRequest req," dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

            actxt.setTimeout(1000);
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() >
                TimeoutServlet.ASYNC_TIMEOUT);
        assertTrue(entry.toString(), entry.getTime() <
                TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME);
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        public static final long ASYNC_TIMEOUT = 3000;
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                ac.setTimeout(3000);
======= fetch "private void doTestDispatch(int iter, boolean useThread) throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= fetch "private void doTestDispatch(int iter, boolean useThread) throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        
        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() > 0);
        assertTrue(entry.toString(), entry.getTime() < REQUEST_TIME);
======= fetch "public void testListeners() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= fetch "public void testListeners() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() >
                TimeoutServlet.ASYNC_TIMEOUT);
        assertTrue(entry.toString(), entry.getTime() <
                TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME);
======= fetch "private void doTestDispatchError(int iter, boolean useThread," dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= fetch "private void doTestDispatchError(int iter, boolean useThread," dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        
        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() > 0);
        assertTrue(entry.toString(), entry.getTime() < REQUEST_TIME);
======= fetch "public void testBug50352() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        ErrorServlet error = new ErrorServlet();
        Tomcat.addServlet(ctx, "error", error);
        ctx.addServletMapping("/stage2", "error");
======= fetch "public void testBug50352() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() >
        AsyncStartRunnable.THREAD_SLEEP_TIME);
        assertTrue(entry.toString(), entry.getTime() <
                AsyncStartRunnable.THREAD_SLEEP_TIME + REQUEST_TIME);
======= fetch "public void testBug50352() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        public static final long THREAD_SLEEP_TIME = 3000;
======= fetch "public void run() {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                        Thread.sleep(3 * 1000);
======= fetch "public void testBug50753() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= fetch "public void testBug50753() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        
        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() >
        Bug50753Servlet.THREAD_SLEEP_TIME);
        assertTrue(entry.toString(), entry.getTime() <
                Bug50753Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);
======= fetch "public void testBug50753() throws Exception {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        public static final long THREAD_SLEEP_TIME = 5000;
======= fetch "public void run() {" dc3dff4^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                        Thread.sleep(5000); 

======= fetch "public void scan(File file) throws IOException {" 62ddb9e^:"java/org/apache/catalina/startup/ContextConfig.java"

            WebXml fragment = null;
======= fetch "public void scan(File file) throws IOException {" 62ddb9e^:"java/org/apache/catalina/startup/ContextConfig.java"

                    fragment = new WebXml();
======= fetch "public void scan(File file) throws IOException {" 62ddb9e^:"java/org/apache/catalina/startup/ContextConfig.java"

                if (fragment == null) {
                    fragments.put(file.toURI().toURL().toString(), fragment);
                } else {
                    fragment.setURL(file.toURI().toURL());
                    if (fragment.getName() == null) {
                        fragment.setName(fragment.getURL().toString());
                    }
                    fragments.put(fragment.getName(), fragment);
======= fetch "public void scan(File file) throws IOException {" 62ddb9e^:"java/org/apache/catalina/startup/ContextConfig.java"

                fragments.put(fragment.getName(), fragment);
======= fetch "private String getJarName(URL url) {" 62ddb9e^:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

        } else if (isScanAllDirectories()){
            int start = path.lastIndexOf('/');
            name = path.substring(start + 1);
      <fix>
        <bug>50997</bug>: Relax the requirement that directories must have a
        name ending in <code>.jar</code> to be treated as an expanded JAR file
        by the default JarScanner. Based on patch by Rodion Zhitomirsky. (markt)
      </fix>

======= fetch "public void bind() throws Exception {" e34f848^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            if (SSLCertificateFile == null) {
                // This is required
                throw new Exception(sm.getString("endpoint.apr.noSslCertFile"));
            }
        <bug>50927</bug>: Improve error message when SSLCertificateFile is not
        specified when using APR with SSL. Based on a patch provided by sebb.
        (markt)
      </fix>
      <fix>

======= fetch "public HttpUtils() {" 0c96676^:"java/javax/servlet/http/HttpUtils.java"

            throw new IllegalArgumentException(e.getMessage());
======= fetch "public HttpUtils() {" 0c96676^:"java/javax/servlet/http/HttpUtils.java"

            throw new IllegalArgumentException(e.getMessage());
======= fetch "public Integer run() throws IOException{" 0c96676^:"java/org/apache/catalina/connector/CoyoteInputStream.java"

                    throw new RuntimeException(e.getMessage());
======= fetch "public Integer run() throws IOException{" 0c96676^:"java/org/apache/catalina/connector/CoyoteInputStream.java"

                    throw new RuntimeException(e.getMessage());
======= fetch "public Integer run() throws IOException{" 0c96676^:"java/org/apache/catalina/connector/CoyoteInputStream.java"

                    throw new RuntimeException(e.getMessage());
======= fetch "public Integer run() throws IOException{" 0c96676^:"java/org/apache/catalina/connector/CoyoteInputStream.java"

                    throw new RuntimeException(e.getMessage());
======= fetch "public Void run() throws IOException{" 0c96676^:"java/org/apache/catalina/connector/CoyoteInputStream.java"

                    throw new RuntimeException(e.getMessage());
======= fetch "protected Connection open() throws SQLException {" 0c96676^:"java/org/apache/catalina/realm/JDBCRealm.java"

                throw new SQLException(e.getMessage());
======= fetch "protected void open() throws SQLException {" 0c96676^:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

                throw new SQLException(e.getMessage());
======= fetch "public InputStream streamContent()" 0c96676^:"java/org/apache/naming/resources/WARDirContext.java"

                throw new IOException(e.getMessage());
======= fetch "public void characters(char[] ch, int start, int length)" 0c96676^:"java/org/apache/tomcat/util/digester/NodeCreateRule.java"

                throw new SAXException(e.getMessage());
======= fetch "public void endElement(String namespaceURI, String localName," 0c96676^:"java/org/apache/tomcat/util/digester/NodeCreateRule.java"

                throw new SAXException(e.getMessage());
======= fetch "public void processingInstruction(String target, String data)" 0c96676^:"java/org/apache/tomcat/util/digester/NodeCreateRule.java"

                throw new SAXException(e.getMessage());
======= fetch "public void startElement(String namespaceURI, String localName," 0c96676^:"java/org/apache/tomcat/util/digester/NodeCreateRule.java"

                throw new SAXException(e.getMessage());
      <fix>
        Make root cause exception available if JSSE SSL initialisation fails.
        Patch provided by sebb. (markt) 
      </fix>

======= fetch "public SocketState process(SocketWrapper<Socket> socket)" c8ea62e^:"java/org/apache/coyote/ajp/AjpProcessor.java"

            if (endpoint.isPaused()) {
                // 503 - Service unavailable
                response.setStatus(503);
                adapter.log(request, response, 0);
                error = true;
            }
======= fetch "public SocketState process(SocketWrapper<Long> socket)" c8ea62e^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                    break;
======= fetch "public SocketState process(SocketWrapper<Long> socket)" c8ea62e^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                request.setStartTime(System.currentTimeMillis());
                keptAlive = true;
                if (!disableUploadTimeout) {
                    Socket.timeoutSet(socketRef,
                            connectionUploadTimeout * 1000);
======= fetch "public SocketState process(SocketWrapper<Long> socket)" c8ea62e^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                inputBuffer.parseHeaders();
======= fetch "public SocketState process(NioChannel socket)" c8ea62e^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                    break;
                }
                keptAlive = true;
                if ( !inputBuffer.parseHeaders() ) {
                    //we've read part of the request, don't recycle it
                    //instead associate it with the socket
                    openSocket = true;
                    recycle = false;
                    break;
======= fetch "public SocketState process(NioChannel socket)" c8ea62e^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                request.setStartTime(System.currentTimeMillis());
                if (!disableUploadTimeout) { //only for body, not for request headers
                    socket.getIOChannel().socket().setSoTimeout(
                            connectionUploadTimeout);
======= fetch "public SocketState process(NioChannel socket)" c8ea62e^:"java/org/apache/coyote/http11/Http11Processor.java"

                request.setStartTime(System.currentTimeMillis());
                keptAlive = true;
                if (disableUploadTimeout) {
                    socket.getSocket().setSoTimeout(soTimeout);
======= fetch "public SocketState process(NioChannel socket)" c8ea62e^:"java/org/apache/coyote/http11/Http11Processor.java"

                    socket.getSocket().setSoTimeout(connectionUploadTimeout);
======= fetch "public SocketState process(NioChannel socket)" c8ea62e^:"java/org/apache/coyote/http11/Http11Processor.java"

                inputBuffer.parseHeaders();
======= fetch "public static int getUrl(String path, ByteChunk out," c8ea62e^:"test/org/apache/catalina/startup/TomcatBaseTest.java"

        return getUrl(path, out, 1000000, reqHead, resHead);
    }
    
    public static int getUrl(String path, ByteChunk out, int readTimeout,
            Map<String, List<String>> reqHead,
            Map<String, List<String>> resHead) throws IOException {
======= fetch "public static int getUrl(String path, ByteChunk out," c8ea62e^:"test/org/apache/catalina/startup/TomcatBaseTest.java"

        connection.setReadTimeout(1000000);

    private static final Log log = LogFactory.getLog(SSLValve.class);
======= fetch "public void invoke(Request request, Response response)" 552c4b7^:"java/org/apache/catalina/valves/SSLValve.java"

            String providerName = (String) request.getConnector().getProperty(
                    "clientCertProvider");
======= fetch "public void invoke(Request request, Response response)" 552c4b7^:"java/org/apache/catalina/valves/SSLValve.java"

                CertificateFactory cf = CertificateFactory.getInstance("X.509");
======= fetch "public void invoke(Request request, Response response)" 552c4b7^:"java/org/apache/catalina/valves/SSLValve.java"

            } catch (NoSuchProviderException e) {
                log.error(sm.getString(
                        "sslValve.invalidProvider", providerName), e);
======= fetch "public void setProcessorCache(int processorCache) {" 552c4b7^:"java/org/apache/coyote/AbstractProtocolHandler.java"

    /**
     * When client certificate information is presented in a form other than
     * instances of {@link java.security.cert.X509Certificate} it needs to be
     * converted before it can be used and this property controls which JSSE
     * provider is used to perform the conversion. For example it is used with
     * the AJP connectors, the HTTP APR connector and with the
     * {@link org.apache.catalina.valves.SSLValve}. If not specified, the
     * default provider will be used. 
     */
    protected String clientCertProvider = null;
    public String getClientCertProvider() { return clientCertProvider; }
    public void setClientCertProvider(String s) { this.clientCertProvider = s; }
======= fetch "public void setRequiredSecret(String requiredSecret) {" 552c4b7^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

    /**
     * When client certificate information is presented in a form other than
     * instances of {@link java.security.cert.X509Certificate} it needs to be
     * converted before it can be used and this property controls which JSSE
     * provider is used to perform the conversion. For example it is used with
     * the AJP connectors, the HTTP APR connector and with the
     * {@link org.apache.catalina.valves.SSLValve}. If not specified, the
     * default provider will be used. 
     */
    protected String clientCertProvider = null;
    public String getClientCertProvider() { return clientCertProvider; }
    public void setClientCertProvider(String s) { this.clientCertProvider = s; }
======= fetch "public final void action(ActionCode actionCode, Object param) {" 552c4b7^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

                   CertificateFactory cf =
                       CertificateFactory.getInstance("X.509");
======= fetch "public final void action(ActionCode actionCode, Object param) {" 552c4b7^:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

               } catch (NoSuchProviderException e) {
                   getLog().error(sm.getString("ajpprocessor.certs.fail"), e);
                   return;
======= fetch "protected AjpAprProcessor createProcessor() {" 552c4b7^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

            processor.setClientCertProvider(proto.getClientCertProvider());
======= fetch "protected AjpProcessor createProcessor() {" 552c4b7^:"java/org/apache/coyote/ajp/AjpProtocol.java"

            processor.setClientCertProvider(proto.getClientCertProvider());
======= fetch "protected AbstractEndpoint getEndpoint() {" 552c4b7^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

    /**
     * When client certificate information is presented in a form other than
     * instances of {@link java.security.cert.X509Certificate} it needs to be
     * converted before it can be used and this property controls which JSSE
     * provider is used to perform the conversion. For example it is used with
     * the AJP connectors, the HTTP APR connector and with the
     * {@link org.apache.catalina.valves.SSLValve}. If not specified, the
     * default provider will be used. 
     */
    protected String clientCertProvider = null;
    public String getClientCertProvider() { return clientCertProvider; }
    public void setClientCertProvider(String s) { this.clientCertProvider = s; }
======= fetch "public void actionInternal(ActionCode actionCode, Object param) {" 552c4b7^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                        CertificateFactory cf = CertificateFactory.getInstance("X.509");
======= fetch "protected Http11AprProcessor createProcessor() {" 552c4b7^:"java/org/apache/coyote/http11/Http11AprProtocol.java"

            processor.setClientCertProvider(proto.getClientCertProvider());
  <subsection name="Coyote">
    <changelog>
      <add>
        <bug>50887</bug>: Add support for configuring the JSSE provider used to
        convert client certificates. Based on a patch by pknopp. (markt)
      </add>
    </changelog>
  </subsection>
    <attribute name="clientCertProvider" required="false">
      <p>When client certificate information is presented in a form other than
      instances of <code>java.security.cert.X509Certificate</code> it needs to
      be converted before it can be used and this property controls which JSSE
      provider is used to perform the conversion. For example it is used with
      the AJP connectors, the <a href="http.html">HTTP APR connector</a> and
      with the <a href="valve.html#SSL_Authenticator_Valve">
      org.apache.catalina.valves.SSLValve</a>.If not specified, the default
      provider will be used.</p>
    </attribute>
    <attribute name="clientCertProvider" required="false">
      <p>When client certificate information is presented in a form other than
      instances of <code>java.security.cert.X509Certificate</code> it needs to
      be converted before it can be used and this property controls which JSSE
      provider is used to perform the conversion. For example it is used with
      the <a href="ajp.html">AJP connectors</a>, the HTTP APR connector and
      with the <a href="valve.html#SSL_Authenticator_Valve">
      org.apache.catalina.valves.SSLValve</a>. If not specified, the default
      provider will be used.</p>
    </attribute>

======= fetch "private String getCanonicalName(String className) throws JasperException {" 5d61212^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

                clazz = Class.forName(className, true, tccl);

======= fetch "protected synchronized void stopInternal() throws LifecycleException {" 1211dbe^:"java/org/apache/catalina/core/StandardContext.java"

        // Currently this is effectively a NO-OP but needs to be called to
        // ensure the NamingResources follows the correct lifecycle
======= fetch "protected synchronized void stopInternal() throws LifecycleException {" 1211dbe^:"java/org/apache/catalina/core/StandardContext.java"

        // Binding thread
        ClassLoader oldCCL = bindThread();
======= fetch "protected void stopInternal() throws LifecycleException {" 1211dbe^:"java/org/apache/catalina/deploy/NamingResources.java"

        cleanUp();
======= fetch "protected void stopInternal() throws LifecycleException {" 1211dbe^:"java/org/apache/catalina/deploy/NamingResources.java"

    /**
     * Close those resources that an explicit close may help clean-up faster.
     */
    private void cleanUp() {
        if (resources.size() == 0) {
            return;
        }
        javax.naming.Context ctxt;
        try {
            if (container instanceof Server) {
                ctxt = ((Server) container).getGlobalNamingContext();
            } else {
                ctxt = ContextBindings.getClassLoader();
                ctxt = (javax.naming.Context) ctxt.lookup("comp/env");
            }
        } catch (NamingException e) {
            log.warn(sm.getString("namingResources.cleanupNoContext",
                    container), e);
            return;
        }
        for (ContextResource cr: resources.values()) {
            if (DataSource.class.getName().equals(cr.getType())) {
                String name = cr.getName();
                DataSource ds;
                try {
                     ds = (DataSource) ctxt.lookup(name);
                } catch (NamingException e) {
                    log.warn(sm.getString("namingResources.cleanupNoResource",
                            cr.getName(), container), e);
                    continue;
                }
                cleanUp(ds, name);
            }
        }
    }
======= fetch "protected void stopInternal() throws LifecycleException {" 1211dbe^:"java/org/apache/catalina/deploy/NamingResources.java"

      <fix>
      </fix>
      <fix>
      </fix>

======= fetch "protected void startInternal() throws LifecycleException {" f622e3a^:"java/org/apache/catalina/loader/WebappLoader.java"

            new DirContextURLStreamHandlerFactory();
    public static final String PROTOCOL_HANDLER_VARIABLE = 
        "java.protocol.handler.pkgs";
    // Default namespace name
    public static final String DEFAULT_NAMESPACE = "DAV:";
 * Factory for Stream handlers to a JNDI directory context.
    implements URLStreamHandlerFactory {
    
    // ----------------------------------------------------------- Constructors
    
    
    public DirContextURLStreamHandlerFactory() {
        // NOOP
======= fetch "public DirContextURLStreamHandlerFactory() {" f622e3a^:"java/org/apache/naming/resources/DirContextURLStreamHandlerFactory.java"

    
    
    // ----------------------------------------------------- Instance Variables
    
    
    // ------------------------------------------------------------- Properties
    
    
    // ---------------------------------------- URLStreamHandlerFactory Methods
======= fetch "public URLStreamHandler createURLStreamHandler(String protocol) {" f622e3a^:"java/org/apache/naming/resources/DirContextURLStreamHandlerFactory.java"

            for (URLStreamHandlerFactory factory : userFactories) {
                URLStreamHandler handler =
                    factory.createURLStreamHandler(protocol);
                if (handler != null) {
                    return handler;
                }
            }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    public void testUserSuppliedFactory() throws Exception {
        
        URL url = null;
        
        // Initially unknown
        try {
            url = new URL("foo://www.apache.org");
        } catch (MalformedURLException ignore) {
            // Ignore
        }
        assertNull(url);
        
        // Set the factory
        URL.setURLStreamHandlerFactory(
                DirContextURLStreamHandlerFactory.getInstance());
        // Still unknown
        try {
            url = new URL("foo://www.apache.org");
        } catch (MalformedURLException ignore) {
            // Ignore
        }
        assertNull(url);
        // Register a user factory
        DirContextURLStreamHandlerFactory.addUserFactory(
                new FooURLStreamHandlerFactory());
        
        // Now it works
        try {
            url = new URL("foo://www.apache.org");
        } catch (MalformedURLException ignore) {
            // Ignore
        }
        assertNotNull(url);
    }
    
    public static class FooURLStreamHandlerFactory
            implements URLStreamHandlerFactory {
        @Override
        public URLStreamHandler createURLStreamHandler(String protocol) {
            if ("foo".equals(protocol)) {
                // This is good enough for this test but not for actual use
                return new DirContextURLStreamHandler();
            } else {
                return null;
            }
        }
    }
        <bug>26701</bug>: Provide a mechanism for users to register their own
        <code>URLStreamHandlerFactory</code> objects. (markt)
      </fix>
      <fix>

======= fetch "public void register(Request request, HttpServletResponse response," b24b0c0^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

        if (log.isDebugEnabled())
            log.debug("Authenticated '" + principal.getName() + "' with type '"
                + authType + "'");

======= fetch "public ConnectionPool(PoolConfiguration prop) throws SQLException {" ef547fb^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        PooledConnection pc = this.borrowConnection(0, null, null);
        if (pc!=null) {
            
            return new ConnectionFuture(pc);
        } 

======= fetch "public Object getContent()" 4a4d86e^:"java/org/apache/naming/resources/DirContextURLConnection.java"

        throw new FileNotFoundException();
======= fetch "public InputStream getInputStream()" 4a4d86e^:"java/org/apache/naming/resources/DirContextURLConnection.java"

            throw new FileNotFoundException();
======= fetch "public Permission getPermission() {" 4a4d86e^:"java/org/apache/naming/resources/DirContextURLConnection.java"

            throw new FileNotFoundException();
======= fetch "public Permission getPermission() {" 4a4d86e^:"java/org/apache/naming/resources/DirContextURLConnection.java"

                throw new FileNotFoundException();

======= fetch "public void execute() throws BuildException {" e1bf740^:"java/org/apache/catalina/ant/JMXGetTask.java"

                " in bean " + bean ); 
        execute("/jmxproxy/?get=" + bean 
                + "&att=" + attribute );
======= fetch "public void execute() throws BuildException {" e1bf740^:"java/org/apache/catalina/ant/JMXQueryTask.java"

        String queryString = (query == null) ? "":("?qry="+query);
======= fetch "public void execute() throws BuildException {" e1bf740^:"java/org/apache/catalina/ant/JMXSetTask.java"

        execute("/jmxproxy/?set=" + bean 
                + "&att=" + attribute 
                + "&val=" + value);
======= fetch "public void execute() throws BuildException {" e1bf740^:"java/org/apache/catalina/ant/ResourcesTask.java"

            execute("/resources?type=" + type);
======= fetch "public void execute() throws BuildException {" e1bf740^:"java/org/apache/catalina/ant/UndeployTask.java"

        execute("/undeploy?path=" + this.path);

======= fetch "private static void loadProperties() {" 4b4ef0c^:"java/org/apache/catalina/startup/CatalinaProperties.java"

                System.setProperty(name, value);

 * The valid state transitions for components that support Lifecycle are:
 * |  |          ^                                           |  |  ^
 * |  |          |stop()            MUST_DESTROY------<-------  |  |
     * Get the lifecycle listeners associated with this lifecycle. If this 
     * Lifecycle has no listeners registered, a zero-length array is returned.
     * Prepare for the beginning of active use of the public methods of this
     * component.  This method should be called before any of the public
     * methods of this component are utilized. The following
     * {@link LifecycleEvent}s will be fired in the following order:
     *                    and that the public methods may be used.</li>
     * Gracefully terminate the active use of the public methods of this
     * component. Once the STOP_EVENT is fired, the public methods should not
     * be used. The following {@link LifecycleEvent}s will be fired in the
     * following order:
     *                   and that the public methods may no longer be used.</li>
 * Lifecycle interface.
    MUST_DESTROY(true, null);
======= fetch "private LifecycleState(boolean available, String lifecycleEvent) {" 92ff888^:"java/org/apache/catalina/LifecycleState.java"

     * Is a component in this state available for use?
======= fetch "public final synchronized void stop() throws LifecycleException {" 92ff888^:"java/org/apache/catalina/util/LifecycleBase.java"

        setStateInternal(LifecycleState.STOPPING_PREP, null, false);
======= fetch "private synchronized void setStateInternal(LifecycleState state," 92ff888^:"java/org/apache/catalina/util/LifecycleBase.java"

            // stopInternal() permits STOPPING_PREP to STOPPING
======= fetch "private synchronized void setStateInternal(LifecycleState state," 92ff888^:"java/org/apache/catalina/util/LifecycleBase.java"

                            state == LifecycleState.STOPPING) ||
                    (this.state == LifecycleState.FAILED &&
      <fix>
        <bug>50836</bug>: Better documentation of the meaning of
        <code>Lifecycle.isAvailable()</code> and correct a couple of cases where
        this could incorrectly return true. (markt)
      </fix>

======= fetch "public void actionInternal(ActionCode actionCode, Object param) {" dcda15d^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                SecureNioChannel sslChannel = (SecureNioChannel) socket;
                SSLEngine engine = sslChannel.getSslEngine();
                if (!engine.getNeedClientAuth() && !engine.getWantClientAuth()) {
                    // Need to re-negotiate SSL connection
                    engine.setNeedClientAuth(true);
                    try {
                        sslChannel.rehandshake();
                        sslSupport = (new JSSEFactory()).getSSLSupport(
                                engine.getSession());
                    } catch (IOException ioe) {
                        log.warn(sm.getString("http11processor.socket.sslreneg",
                                ioe));
                    }
                }
======= fetch "public void actionInternal(ActionCode actionCode, Object param) {" dcda15d^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                    Object sslO = sslSupport.getPeerCertificateChain(true);
======= fetch "public boolean isClosing() {" dcda15d^:"java/org/apache/tomcat/util/net/NioChannel.java"

    public boolean isInitHandshakeComplete() {
    protected boolean initHandshakeComplete = false;
    protected HandshakeStatus initHandshakeStatus; //gets set by begin handshake
======= fetch "public void reset() throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

        initHandshakeComplete = false;
======= fetch "public void reset() throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

        initHandshakeStatus = sslEngine.getHandshakeStatus();
======= fetch "public int handshake(boolean read, boolean write) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

        if ( initHandshakeComplete ) return 0; //we have done our initial handshake
======= fetch "public int handshake(boolean read, boolean write) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

        while (!initHandshakeComplete) {
            switch ( initHandshakeStatus ) {
======= fetch "public int handshake(boolean read, boolean write) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

                    initHandshakeComplete = !netOutBuffer.hasRemaining();
======= fetch "public int handshake(boolean read, boolean write) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

                    return initHandshakeComplete?0:SelectionKey.OP_WRITE; 
======= fetch "public int handshake(boolean read, boolean write) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

                        if (initHandshakeStatus == HandshakeStatus.NEED_TASK) 
                            initHandshakeStatus = tasks();
======= fetch "public int handshake(boolean read, boolean write) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

                    if ( initHandshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {
======= fetch "public int handshake(boolean read, boolean write) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

                        if (initHandshakeStatus == HandshakeStatus.NEED_TASK) 
                            initHandshakeStatus = tasks();
======= fetch "public int handshake(boolean read, boolean write) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

                        throw new IOException("Invalid handshake status:"+initHandshakeStatus+" during handshake UNWRAP.");
======= fetch "public int handshake(boolean read, boolean write) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

                    initHandshakeStatus = tasks();
======= fetch "public int handshake(boolean read, boolean write) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

                default: throw new IllegalStateException("Invalid handshake status:"+initHandshakeStatus);
======= fetch "public int handshake(boolean read, boolean write) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

        return initHandshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);
======= fetch "protected SSLEngineResult handshakeWrap(boolean doWrite) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

        initHandshakeStatus = result.getHandshakeStatus();
======= fetch "protected SSLEngineResult handshakeUnwrap(boolean doread) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

            initHandshakeStatus = result.getHandshakeStatus();
======= fetch "protected SSLEngineResult handshakeUnwrap(boolean doread) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

                initHandshakeStatus = tasks();
======= fetch "protected SSLEngineResult handshakeUnwrap(boolean doread) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

                   initHandshakeStatus == HandshakeStatus.NEED_UNWRAP;
======= fetch "protected SSLEngineResult handshakeUnwrap(boolean doread) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

    public void rehandshake() throws IOException {
        int readBufLimit = getBufHandler().getReadBuffer().limit();
        try {
            // Expand read buffer to maximum to allow handshaking to take place
            getBufHandler().getReadBuffer().limit(
                    getBufHandler().getReadBuffer().capacity());
            sslEngine.getSession().invalidate();
            sslEngine.beginHandshake();
            handshakeComplete = false;
            handshakeStatus = sslEngine.getHandshakeStatus();
            while (!handshakeComplete) {
                handshake(true, true);
                if (handshakeStatus == HandshakeStatus.NEED_UNWRAP)  {
                    handshakeUnwrap(true);
                }
            }
        } finally {
            // Restore the pre-handshak value
            getBufHandler().getReadBuffer().limit(readBufLimit);
        }
    }
======= fetch "public int read(ByteBuffer dst) throws IOException {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

        if (!initHandshakeComplete) throw new IllegalStateException("Handshake incomplete, you must complete handshake before reading data.");
======= fetch "public ApplicationBufferHandler getBufHandler() {" dcda15d^:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

    public boolean isInitHandshakeComplete() {
        return initHandshakeComplete;

======= fetch "protected void destroyInternal() throws LifecycleException {" 9d542ed^:"java/org/apache/catalina/core/StandardContext.java"

        // Send j2ee.object.deleted notification 
        Notification notification = 
            new Notification("j2ee.object.deleted", this.getObjectName(), 
                             sequenceNumber.getAndIncrement());
        broadcaster.sendNotification(notification);
======= fetch "public void testGetResource() throws Exception {" 9d542ed^:"test/org/apache/catalina/startup/TestTomcat.java"

        Thw new Crawler Session Manager Valve ensures that crawlers are

     * <code>roleBase</code>.
     */
    protected MessageFormat roleBaseFormat = null;
    /**
     * The MessageFormat object associated with the current
======= fetch "public void setRoleBase(String roleBase) {" f22600c^:"java/org/apache/catalina/realm/JNDIRealm.java"

        if (roleBase == null)
            roleBaseFormat = null;
        else
            roleBaseFormat = new MessageFormat(roleBase);
======= fetch "private void userCredentialsRemove(DirContext context)" f22600c^:"java/org/apache/catalina/realm/JNDIRealm.java"

        String base = null;
        if (roleBaseFormat != null) {
            NameParser np = context.getNameParser("");
            Name name = np.parse(dn);
            String nameParts[] = new String[name.size()];
            for (int i = 0; i < name.size(); i++) {
                nameParts[i] = name.get(i);
            }
            base = roleBaseFormat.format(nameParts);
        }
======= fetch "private void userCredentialsRemove(DirContext context)" f22600c^:"java/org/apache/catalina/realm/JNDIRealm.java"

            results = context.search(roleBase, filter, controls);
        <p>The base directory entry for performing role searches. If
        not specified the top-level element in the directory context
        will be used.</p>

    /**
     * When searching for user roles, should the search be performed as the user
     * currently being authenticated? If false, {@link #connectionName} and
     * {@link #connectionPassword} will be used if specified, else an anonymous
     * connection will be used. 
     */
    protected boolean roleSearchAsUser = false;
    
======= fetch "private void userCredentialsRemove(DirContext context)" a085c4a^:"java/org/apache/catalina/realm/JNDIRealm.java"

        NamingEnumeration<SearchResult> results =
            context.search(roleBase, filter, controls);

======= fetch "public void close()" 514e713^:"java/org/apache/catalina/connector/OutputBuffer.java"

        // The request should have been completely read by the time the response
        // is closed. Further reads of the input a) are pointless and b) really
        // confuse AJP (bug 50189) so close the input buffer to prevent them.
        Request req = (Request) coyoteResponse.getRequest().getNote(
                CoyoteAdapter.ADAPTER_NOTES);
        req.inputBuffer.close();
        
        <bug>50189</bug>: Once the application has finished writing to the
        response, prevent further reads from the request since this causes
        various problems in the connectors which do not expect this. (markt)
      </fix>
      <fix>

======= fetch "public abstract void rename(String oldName, String newName)" a9c3193^:"java/org/apache/naming/resources/BaseDirContext.java"

        NamingEnumeration<Binding> bindings = doListBindings(name);
======= fetch "public abstract void rename(String oldName, String newName)" a9c3193^:"java/org/apache/naming/resources/BaseDirContext.java"

        if (bindings != null)
            return bindings;
        
======= fetch "public abstract void rename(String oldName, String newName)" a9c3193^:"java/org/apache/naming/resources/BaseDirContext.java"

        List<NamingEntry> altBindings = null;
======= fetch "public abstract void rename(String oldName, String newName)" a9c3193^:"java/org/apache/naming/resources/BaseDirContext.java"

            if (altDirContext instanceof BaseDirContext)
                bindings = ((BaseDirContext) altDirContext).doListBindings(
======= fetch "public abstract void rename(String oldName, String newName)" a9c3193^:"java/org/apache/naming/resources/BaseDirContext.java"

            else {
                try {
                    bindings = altDirContext.listBindings(name);
                } catch (NamingException ne) {
                    // Ignore
======= fetch "public abstract void rename(String oldName, String newName)" a9c3193^:"java/org/apache/naming/resources/BaseDirContext.java"

            if (bindings != null)
                return bindings;
======= fetch "protected abstract Attributes doGetAttributes(String name, String[] attrIds)" a9c3193^:"java/org/apache/naming/resources/BaseDirContext.java"

    protected abstract NamingEnumeration<Binding> doListBindings(String name)
======= fetch "public void rename(String oldName, String newName)" a9c3193^:"java/org/apache/naming/resources/FileDirContext.java"

    protected NamingEnumeration<Binding> doListBindings(String name)
======= fetch "public void rename(String oldName, String newName)" a9c3193^:"java/org/apache/naming/resources/FileDirContext.java"

        return new NamingContextBindingsEnumeration(list(file).iterator(),
                this);
======= fetch "protected File file(String name) {" a9c3193^:"java/org/apache/naming/resources/FileDirContext.java"

    protected ArrayList<NamingEntry> list(File file) {
======= fetch "protected File file(String name) {" a9c3193^:"java/org/apache/naming/resources/FileDirContext.java"

        ArrayList<NamingEntry> entries = new ArrayList<NamingEntry>();
======= fetch "public Attributes getAttributes(String name) throws NamingException {" a9c3193^:"java/org/apache/naming/resources/VirtualDirContext.java"

    protected ArrayList<NamingEntry> list(File file) {
        ArrayList<NamingEntry> entries = super.list(file);
======= fetch "public void rename(String oldName, String newName)" a9c3193^:"java/org/apache/naming/resources/WARDirContext.java"

    protected NamingEnumeration<Binding> doListBindings(String strName)
======= fetch "public void rename(String oldName, String newName)" a9c3193^:"java/org/apache/naming/resources/WARDirContext.java"

            return new NamingContextBindingsEnumeration(list(entries).iterator(),
                    this);
======= fetch "public void rename(String oldName, String newName)" a9c3193^:"java/org/apache/naming/resources/WARDirContext.java"

        return new NamingContextBindingsEnumeration(list(entry).iterator(),
                this);

======= fetch "public SocketState process(SocketWrapper<Long> socket) {" b56bf50^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

                    if (state == SocketState.OPEN) {
                        connections.put(socket, processor);
                    }

======= fetch "public void addServletContainerInitializer(" 3810b04^:"java/org/apache/catalina/Context.java"

    
    /**
     * Configure whether or not requests listeners will be fired on forwards for
     * this Context.
     */
    public void setFireRequestListenersOnForwards(boolean enable);
    /**
     * Determine whether or not requests listeners will be fired on forwards for
     * this Context.
     */
    public boolean getFireRequestListenersOnForwards();
    
======= fetch "private void processRequest(ServletRequest request," 3810b04^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

            if (disInt != DispatcherType.ERROR) {
                state.outerRequest.setAttribute
                    (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,
                     getCombinedPath());
                state.outerRequest.setAttribute
                    (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,
                     DispatcherType.FORWARD);
                invoke(state.outerRequest, response, state);
            } else {
                invoke(state.outerRequest, response, state);
======= fetch "private void processRequest(ServletRequest request," 3810b04^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        }
======= fetch "private void processRequest(ServletRequest request," 3810b04^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

            if (doInvoke) {
                if (disInt != DispatcherType.ERROR) {
                    state.outerRequest.setAttribute
                        (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,
                         getCombinedPath());
                    state.outerRequest.setAttribute
                        (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,
                         DispatcherType.FORWARD);
                    invoke(state.outerRequest, response, state);
                } else {
                    invoke(state.outerRequest, response, state);
                }
                
                if (context.getFireRequestListenersOnForwards()) {
                    context.fireRequestDestroyEvent(request);
                }
            }
        }
======= fetch "public StandardContext() {" 3810b04^:"java/org/apache/catalina/core/StandardContext.java"

    
    private boolean fireRequestListenersOnForwards = false;
======= fetch "public StandardContext() {" 3810b04^:"java/org/apache/catalina/core/StandardContext.java"

    @Override
    public void setFireRequestListenersOnForwards(boolean enable) {
        fireRequestListenersOnForwards = enable;
    }
    @Override
    public boolean getFireRequestListenersOnForwards() {
        return fireRequestListenersOnForwards;
    }
        <bug>50789</bug>: Provide an option to enable ServletRequestListeners
        for forwards as required by some CDI frameworks. (markt)
      </fix>
      <fix>
      <attribute name="fireRequestListenersOnForwards" required="false">
        <p>Set to <code>true</code> to fire any configured
        ServletRequestListeners  when Tomcat forwards a request. This is
        primarily of use to users of CDI frameworks that use
        ServletRequestListeners to configure the necessary environment for a
        request. If not specified, the default value of <code>false</code> is
        used.</p>
      </attribute>

======= fetch "public Object invoke(ELContext context, Object base, Object method," cfab791^:"java/javax/el/BeanELResolver.java"

                if (m.getParameterTypes().length == paramCount) {
======= fetch "public Object getValue(EvaluationContext ctx) throws ELException {" cfab791^:"java/org/apache/el/parser/AstValue.java"

                base = resolver.invoke(ctx, base, suffix,
                        mps.getParameterTypes(ctx), mps.getParameters(ctx));
======= fetch "public void testBug50449b() throws Exception {" cfab791^:"test/org/apache/el/TestMethodExpressionImpl.java"

    
    public void testBug50790a() throws Exception {
        ValueExpression ve = factory.createValueExpression(context,
                "#{beanAA.name.contains(beanA.name)}", java.lang.Boolean.class);
        Boolean actual = (Boolean) ve.getValue(context);
        assertEquals(Boolean.TRUE, actual);
    }
    public void testBug50790b() throws Exception {
        ValueExpression ve = factory.createValueExpression(context,
                "#{beanA.name.contains(beanAA.name)}", java.lang.Boolean.class);
        Boolean actual = (Boolean) ve.getValue(context);
        assertEquals(Boolean.FALSE, actual);
    }
      <fix>
        <bug>50790</bug>: Improve method resolution in EL expressions. (markt)
      </fix>

======= fetch "public boolean asyncDispatch(org.apache.coyote.Request req," 72418ba^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            if (!request.isAsync() && !comet) {
                // Error or timeout - need to tell listeners the request is over
                // Have to test this first since state may change while in this
                // method and this is only required if entering this methos in
                // this state 
                Context ctxt = (Context) request.getMappingData().context;
                if (ctxt != null) {
                    ctxt.fireRequestDestroyEvent(request);
                }
            }
======= fetch "public boolean fireRequestInitEvent(ServletRequest request) {" 72418ba^:"java/org/apache/catalina/core/StandardContext.java"

            // Don't fire the listener for async requests
            if (!DispatcherType.ASYNC.equals(request.getDispatcherType())) {
======= fetch "public boolean fireRequestInitEvent(ServletRequest request) {" 72418ba^:"java/org/apache/catalina/core/StandardContext.java"

                ServletRequestEvent event = 
                        new ServletRequestEvent(getServletContext(), request);
    
                for (int i = 0; i < instances.length; i++) {
                    if (instances[i] == null)
                        continue;
                    if (!(instances[i] instanceof ServletRequestListener))
                        continue;
                    ServletRequestListener listener =
                        (ServletRequestListener) instances[i];
                    
                    try {
                        listener.requestInitialized(event);
                    } catch (Throwable t) {
                        ExceptionUtils.handleThrowable(t);
                        getLogger().error(sm.getString(
                                "standardContext.requestListener.requestInit",
                                instances[i].getClass().getName()), t);
                        request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
                        return false;
                    }
======= fetch "public boolean fireRequestDestroyEvent(ServletRequest request) {" 72418ba^:"java/org/apache/catalina/core/StandardContext.java"

            // Don't fire the listener for async requests
            if (!DispatcherType.ASYNC.equals(request.getDispatcherType())) {
======= fetch "public boolean fireRequestDestroyEvent(ServletRequest request) {" 72418ba^:"java/org/apache/catalina/core/StandardContext.java"

                ServletRequestEvent event = 
                    new ServletRequestEvent(getServletContext(), request);
                for (int i = 0; i < instances.length; i++) {
                    int j = (instances.length -1) -i;
                    if (instances[j] == null)
                        continue;
                    if (!(instances[j] instanceof ServletRequestListener))
                        continue;
                    ServletRequestListener listener =
                        (ServletRequestListener) instances[j];
                    
                    try {
                        listener.requestDestroyed(event);
                    } catch (Throwable t) {
                        ExceptionUtils.handleThrowable(t);
                        getLogger().error(sm.getString(
                                "standardContext.requestListener.requestInit",
                                instances[j].getClass().getName()), t);
                        request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
                        return false;
                    }
======= fetch "public final void invoke(Request request, Response response)" 72418ba^:"java/org/apache/catalina/core/StandardContextValve.java"

        // Don't fire listeners during async processing
======= fetch "public final void invoke(Request request, Response response)" 72418ba^:"java/org/apache/catalina/core/StandardContextValve.java"

        if (context.fireRequestInitEvent(request)) {
======= fetch "public final void invoke(Request request, Response response)" 72418ba^:"java/org/apache/catalina/core/StandardContextValve.java"

            context.fireRequestDestroyEvent(request);
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" 72418ba^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        ctx.addApplicationListener(TrackingRequestListener.class.getName());
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" 72418ba^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        StringBuilder expected = new StringBuilder();
======= fetch "private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)" 72418ba^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        expected.append("requestDestroyed");
======= fetch "private void doTestDispatch(int iter, boolean useThread) throws Exception {" 72418ba^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        ctx.addApplicationListener(TrackingRequestListener.class.getName());
======= fetch "private void doTestDispatch(int iter, boolean useThread) throws Exception {" 72418ba^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        StringBuilder expected = new StringBuilder();
======= fetch "private void doTestDispatch(int iter, boolean useThread) throws Exception {" 72418ba^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        expected.append("requestDestroyed");
======= fetch "public void onStartAsync(AsyncEvent event) throws IOException {" 72418ba^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    public static class TrackingRequestListener
            implements ServletRequestListener {
        @Override
        public void requestDestroyed(ServletRequestEvent sre) {
            // Need the response and it isn't available via the Servlet API
            Request r = (Request) sre.getServletRequest();
            try {
                r.getResponse().getWriter().print("requestDestroyed");
            } catch (IOException e) {
                // Test will fail if this happens
                e.printStackTrace();
            }
        }
        @Override
        public void requestInitialized(ServletRequestEvent sre) {
            // Need the response and it isn't available via the Servlet API
            Request r = (Request) sre.getServletRequest();
            try {
                r.getResponse().getWriter().print("requestInitialized-");
            } catch (IOException e) {
                // Test will fail if this happens
                e.printStackTrace();
            }
        }
    }
======= fetch "private void doTestDispatchError(int iter, boolean useThread," 72418ba^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        ctx.addApplicationListener(TrackingRequestListener.class.getName());
======= fetch "private void doTestDispatchError(int iter, boolean useThread," 72418ba^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        StringBuilder expected = new StringBuilder();
======= fetch "private void doTestDispatchError(int iter, boolean useThread," 72418ba^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        expected.append("ErrorServletGet-onError-onComplete-");

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Ant task that implements the <code>/roles</code> command, supported by the
 * Tomcat manager application.
 *
 * @author Craig R. McClanahan
 * @version $Id$
 * @since 4.1
 */
    // ------------------------------------------------------------- Properties
    // --------------------------------------------------------- Public Methods
    /**
     * Execute the requested operation.
     *
     * @exception BuildException if an error occurs
     */
    @Override
    public void execute() throws BuildException {
        super.execute();
        execute("/roles");
    }
        name="roles"
        classname="org.apache.catalina.ant.RolesTask" />
  <typedef
 * <li><b>/roles</b> - Enumerate the available security role names and
 *     descriptions from the user database connected to the <code>users</code>
 *     resource reference.
======= fetch "public void doGet(HttpServletRequest request," 4b21973^:"java/org/apache/catalina/manager/ManagerServlet.java"

        } else if (command.equals("/roles")) {
            roles(writer, smClient);
======= fetch "protected void printResources(PrintWriter writer, String prefix," 4b21973^:"java/org/apache/catalina/manager/ManagerServlet.java"

     * Render a list of security role names (and corresponding descriptions)
     * from the <code>org.apache.catalina.UserDatabase</code> resource that is
     * connected to the <code>users</code> resource reference.  Typically, this
     * will be the global user database, but can be adjusted if you have
     * different user databases for different virtual hosts.
     *
     * @param writer Writer to render to
     */
    protected void roles(PrintWriter writer,  StringManager smClient) {
        if (debug >= 1) {
            log("roles:  List security roles from user database");
        }
        // Look up the UserDatabase instance we should use
        UserDatabase database = null;
        try {
            InitialContext ic = new InitialContext();
            database = (UserDatabase) ic.lookup("java:comp/env/users");
        } catch (NamingException e) {
            writer.println(smClient.getString(
                    "managerServlet.userDatabaseError"));
            log("java:comp/env/users", e);
            return;
        }
        if (database == null) {
            writer.println(smClient.getString(
                    "managerServlet.userDatabaseMissing"));
            return;
        }
        // Enumerate the available roles
        writer.println(smClient.getString("managerServlet.rolesList"));
        Iterator<Role> roles = database.getRoles();
        if (roles != null) {
            while (roles.hasNext()) {
                Role role = roles.next();
                writer.print(role.getRolename());
                writer.print(':');
                if (role.getDescription() != null) {
                    writer.print(role.getDescription());
                }
                writer.println();
            }
        }
    }
    /**
        <rev>1068549</rev> <bug>50667</bug>: Allow RPC callers to get confirmation when sending a reply.
  &lt;!-- Link to the user database we will get roles from --&gt;
  &lt;ResourceLink name="users" global="UserDatabase"
                type="org.apache.catalina.UserDatabase"/&gt;
  &lt;!-- Link to the user database we will get roles from --&gt;
  &lt;ResourceLink name="users" global="UserDatabase"
                type="org.apache.catalina.UserDatabase"/&gt;
  OK - Listed security roles
    in the user database.</li>
    creating user interfaces for selecting roles.</li>
    the successful lookup of the <code>org.apache.catalina.UserDatabase</code>
    resource.  Check the Tomcat log files for a stack trace associated with
    this error.</li>
    reference for the <code>users</code> resource that points at an
    appropriate user database instance.  Check your <code>manager.xml</code>
    file and ensure that you have created an appropriate
    <code>&lt;ResourceLink&gt;</code> or
    <code>&lt;ResourceParams&gt;</code> element for this resource.</li>
  &lt;taskdef name="roles"     classname="org.apache.catalina.ant.RolesTask"/&gt;
  <!-- Define reference to the user database for looking up roles -->
  <resource-env-ref>
    <description>
      Link to the UserDatabase instance from which we request lists of
      defined role names.  Typically, this will be connected to the global
      user database with a ResourceLink element in server.xml or the context
      configuration file for the Manager web application.
    </description>
    <resource-env-ref-name>users</resource-env-ref-name>
    <resource-env-ref-type>
      org.apache.catalina.UserDatabase
    </resource-env-ref-type>
  </resource-env-ref>

======= fetch "private void mergeParameters() {" a073ac8^:"java/org/apache/catalina/core/StandardContext.java"

        ServletContext sc = getServletContext();
======= fetch "private void mergeParameters() {" a073ac8^:"java/org/apache/catalina/core/StandardContext.java"

            sc.setInitParameter(names[i], findParameter(names[i]));
======= fetch "private void mergeParameters() {" a073ac8^:"java/org/apache/catalina/core/StandardContext.java"

                if (sc.getInitParameter(params[i].getName()) == null) {
                    sc.setInitParameter(params[i].getName(),
======= fetch "private void mergeParameters() {" a073ac8^:"java/org/apache/catalina/core/StandardContext.java"

                sc.setInitParameter(params[i].getName(), params[i].getValue());
======= fetch "private void mergeParameters() {" a073ac8^:"java/org/apache/catalina/core/StandardContext.java"

        
        ServletContext sc = getServletContext();
        for (Map.Entry<String,String> entry : mergedParams.entrySet()) {
            sc.setInitParameter(entry.getKey(), entry.getValue());
        }
        <bug>50700</bug>: Ensure that the override attribute of context
        parameters is correctly followed. (markt)
      </fix>
      <fix>

    public static final int TYPE_AUTHTYPE = 4;
    public static final String NAME_AUTHTYPE = "__SET__AUTHTYPE__";
======= fetch "public void setNew(boolean n) {" 877a3df^:"java/org/apache/catalina/ha/session/DeltaRequest.java"

    public void setAuthType(String authType) {
        int action = (authType==null)?ACTION_REMOVE:ACTION_SET;
        addAction(TYPE_AUTHTYPE,action,NAME_AUTHTYPE, authType);
    }
======= fetch "public void execute(DeltaSession session, boolean notifyListeners) {" 877a3df^:"java/org/apache/catalina/ha/session/DeltaRequest.java"

                case TYPE_AUTHTYPE: {
                    String authType = null;
                    if ( info.getAction() == ACTION_SET ) {
                        authType = (String)info.getValue();
                    }
                    session.setAuthType(authType,false);
                    break;
                }//case
======= fetch "public void setPrincipal(Principal principal, boolean addDeltaRequest) {" 877a3df^:"java/org/apache/catalina/ha/session/DeltaSession.java"

     * Set the authentication type used to authenticate our cached
     * Principal, if any.
     *
     * @param authType The new cached authentication type
     */
    @Override
    public void setAuthType(String authType) {
        setAuthType(authType, true);
    }
    public void setAuthType(String authType, boolean addDeltaRequest) {
        try { 
            lock();
            super.setAuthType(authType);
            if (addDeltaRequest && (deltaRequest != null))
                deltaRequest.setAuthType(authType);
        } finally {
            unlock();
        }
    }
    /**
  <subsection name="Cluster">
    <changelog>
      <fix>
        <bug>50771</bug>: Ensure HttpServletRequest#getAuthType() returns the 
        name of the authentication scheme if request has already been 
        authenticated. (kfujino)
      </fix>
    </changelog>
  </subsection>

======= fetch "public void visit(Node.TemplateText n) throws JasperException {" d0f3899^:"java/org/apache/jasper/compiler/Generator.java"

                String charArrayName = textMap.get(text);
                if (charArrayName == null) {
                    charArrayName = "_jspx_char_array_" + charArrayCount++;
                    textMap.put(text, charArrayName);
                    caOut.printin("static char[] ");
                    caOut.print(charArrayName);
                    caOut.print(" = ");
                    caOut.print(quote(text));
                    caOut.println(".toCharArray();");
======= fetch "public void visit(Node.TemplateText n) throws JasperException {" d0f3899^:"java/org/apache/jasper/compiler/Generator.java"

                n.setBeginJavaLine(out.getJavaLine());
                out.printil("out.write(" + charArrayName + ");");
                n.setEndJavaLine(out.getJavaLine());

======= fetch "public boolean validate(int validateAction,String sql) {" 50f16fe^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            return poolProperties.getValidator().validate(connection, validateAction);

======= fetch "protected User getUserByPattern(DirContext context," 0313ded^:"java/org/apache/catalina/realm/JNDIRealm.java"

        // If no attributes are requested, no need to look for them
        if (attrIds == null || attrIds.length > 0) {
            return new User(username, dn, null, null);
        }
        <bug>50751</bug>: When authenticating with the JNDI Realm, only attempt
        to read user attributes from the directory if attributes are required.
        (markt)
      </fix>
      <fix>

======= fetch "protected void initNaming() {" 272e30c^:"java/org/apache/catalina/startup/Embedded.java"

                log.debug( "INITIAL_CONTEXT_FACTORY alread set " + value );

    private InputStream is;
    private InputSource ip;
======= fetch "public WebXml(ServletContext ctxt) throws IOException {" e4bc803^:"java/org/apache/jasper/compiler/WebXml.java"

            is = new ByteArrayInputStream(webXml.getBytes());
======= fetch "public WebXml(ServletContext ctxt) throws IOException {" e4bc803^:"java/org/apache/jasper/compiler/WebXml.java"

        if (is == null) {
======= fetch "public WebXml(ServletContext ctxt) throws IOException {" e4bc803^:"java/org/apache/jasper/compiler/WebXml.java"

                    is = uri.openStream();
======= fetch "public WebXml(ServletContext ctxt) throws IOException {" e4bc803^:"java/org/apache/jasper/compiler/WebXml.java"

        if (is == null) {
======= fetch "public WebXml(ServletContext ctxt) throws IOException {" e4bc803^:"java/org/apache/jasper/compiler/WebXml.java"

                is = uri.openStream();
======= fetch "public WebXml(ServletContext ctxt) throws IOException {" e4bc803^:"java/org/apache/jasper/compiler/WebXml.java"

        if (is == null) {
======= fetch "public WebXml(ServletContext ctxt) throws IOException {" e4bc803^:"java/org/apache/jasper/compiler/WebXml.java"

            ip = new InputSource(is);
            ip.setSystemId(systemId);
======= fetch "public InputSource getInputSource() {" e4bc803^:"java/org/apache/jasper/compiler/WebXml.java"

        return ip;
======= fetch "public void close() {" e4bc803^:"java/org/apache/jasper/compiler/WebXml.java"

        if (is != null) {
======= fetch "public void close() {" e4bc803^:"java/org/apache/jasper/compiler/WebXml.java"

                is.close();

======= fetch "public static String URLDecode(byte[] bytes, String enc, boolean isQuery) {" 5c9e352^:"java/org/apache/catalina/util/RequestUtil.java"

                if (ix + 2 >= len) {
======= fetch "public void testNormalizeString() {" 5c9e352^:"test/org/apache/catalina/util/TestRequestUtil.java"

    public void testURLDecodeString() {
======= fetch "public void testURLDecodeString() {" 5c9e352^:"test/org/apache/catalina/util/TestRequestUtil.java"

        point the response is committed when a writer is beng used. (markt)

    implements ServletContext {

======= fetch "public StandardServer() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

    private boolean stopAwait = false;
======= fetch "public StandardServer() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

    /**
     * Thread that currently is inside our await() method.
     */
    private volatile Thread awaitThread = null;
    /**
     * Server socket that is used to wait for the shutdown command.
     */
    private volatile ServerSocket awaitSocket = null;
======= fetch "public void stopAwait() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

        Thread t = awaitThread;
        if (t != null) {
            ServerSocket s = awaitSocket;
            if (s != null) {
                awaitSocket = null;
                try {
                    s.close();
                } catch (IOException e) {
                    // Ignored
                }
            }
            t.interrupt();
            try {
                t.join(1000);
            } catch (InterruptedException e) {
                // Ignored
            }
        }
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

            while( true ) {
                try {
                    Thread.sleep( 10000 );
                } catch( InterruptedException ex ) {
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

                if( stopAwait ) return;
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

            return;
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

        
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

        ServerSocket serverSocket = null;
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

            serverSocket =
                new ServerSocket(port, 1,
                                 InetAddress.getByName(address));
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

            System.exit(1);
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

        // Loop waiting for a connection and a valid command
        while (true) {
            // Wait for the next connection
            Socket socket = null;
            InputStream stream = null;
            try {
                socket = serverSocket.accept();
                socket.setSoTimeout(10 * 1000);  // Ten seconds
                stream = socket.getInputStream();
            } catch (AccessControlException ace) {
                log.warn("StandardServer.accept security exception: "
                                   + ace.getMessage(), ace);
                continue;
            } catch (IOException e) {
                log.error("StandardServer.await: accept: ", e);
                System.exit(1);
            }
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

            // Read a set of characters from the socket
            StringBuilder command = new StringBuilder();
            int expected = 1024; // Cut off to avoid DoS attack
            while (expected < shutdown.length()) {
                if (random == null)
                    random = new Random();
                expected += (random.nextInt() % 1024);
            }
            while (expected > 0) {
                int ch = -1;
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

                    ch = stream.read();
                } catch (IOException e) {
                    log.warn("StandardServer.await: read: ", e);
                    ch = -1;
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

                if (ch < 32)  // Control character or EOF terminates loop
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

                command.append((char) ch);
                expected--;
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

        } finally {
            ServerSocket serverSocket = awaitSocket;
            awaitThread = null;
            awaitSocket = null;
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

            // Close the socket now that we are done with it
            try {
                socket.close();
            } catch (IOException e) {
                // Ignore
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

            // Match against our command string
            boolean match = command.toString().equals(shutdown);
            if (match) {
                log.info(sm.getString("standardServer.shutdownViaPort"));
                break;
            } else
                log.warn("StandardServer.await: Invalid command '" +
                                   command.toString() + "' received");
======= fetch "public void await() {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

        // Close the server socket and return
        try {
            serverSocket.close();
        } catch (IOException e) {
            // Ignore
        }
======= fetch "protected void stopInternal() throws LifecycleException {" 6ac4a27^:"java/org/apache/catalina/core/StandardServer.java"

        if (port == -1)
======= fetch "public void stopServer(String[] arguments) {" 6ac4a27^:"java/org/apache/catalina/startup/Catalina.java"

        if( getServer() == null ) {
======= fetch "public void stopServer(String[] arguments) {" 6ac4a27^:"java/org/apache/catalina/startup/Catalina.java"

            // Shutdown hook will take care of clean-up
            System.exit(0);
======= fetch "public void stopServer(String[] arguments) {" 6ac4a27^:"java/org/apache/catalina/startup/Catalina.java"

        s = getServer();
======= fetch "public void stopServer(String[] arguments) {" 6ac4a27^:"java/org/apache/catalina/startup/Catalina.java"

            if (getServer().getPort()>0) {
                Socket socket = new Socket(getServer().getAddress(),
                        getServer().getPort());
======= fetch "public void stop() {" 6ac4a27^:"java/org/apache/catalina/startup/Catalina.java"

            getServer().stop();
        <bug>50683</bug>: Ensure annotations are scanned when upackWars is set
        to <code>false</code> in the Host where a web application is deployed.
        (markt)

======= fetch "public InternalNioInputBuffer(Request request, int headerBufferSize) {" 0084470^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

        buf = new byte[headerBufferSize];
======= fetch "public InternalNioInputBuffer(Request request, int headerBufferSize) {" 0084470^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

    /**
     * Maximum allowed size of the HTTP request line plus headers.
     */
    private final int headerBufferSize;
    /**
     * Known size of the NioChannel read buffer.
     */
    private int socketReadBufferSize;
    /**
     * Additional size we allocate to the buffer to be more effective when
     * skipping empty lines that may precede the request.
     */
    private static final int skipBlankLinesSize = 1024;
    /**
     * How many bytes in the buffer are occupied by skipped blank lines that
     * precede the request.
     */
    private int skipBlankLinesBytes;
======= fetch "public void setSocket(NioChannel socket) {" 0084470^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

        socketReadBufferSize = socket.getBufHandler().getReadBuffer().capacity();
        int bufLength = skipBlankLinesSize + headerBufferSize
                + socketReadBufferSize;
        if (buf == null || buf.length < bufLength) {
            buf = new byte[bufLength];
        }
======= fetch "public boolean parseRequestLine(boolean useAvailableDataOnly)" 0084470^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

                    // Ignore bytes that were read
                    pos = lastValid = 0;
======= fetch "public boolean parseRequestLine(boolean useAvailableDataOnly)" 0084470^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            parsingRequestLineStart = pos;
            parsingRequestLinePhase = 1;
        } 
        if ( parsingRequestLinePhase == 1 ) {
            // Mark the current buffer position
            
            if (pos >= lastValid) {
                if (useAvailableDataOnly) {
                    return false;
                }
                // Do a simple read with a short timeout
                if ( readSocket(true, false)==0 ) return false;
======= fetch "public boolean parseRequestLine(boolean useAvailableDataOnly)" 0084470^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            skipBlankLinesBytes = pos;
            parsingRequestLineStart = pos;
======= fetch "private void expand(int newsize) {" 0084470^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            if (parsingHeader) {
                throw new IllegalArgumentException(
                        sm.getString("iib.requestheadertoolarge.error"));
            }
            // Should not happen
            log.warn("Expanding buffer size. Old size: " + buf.length
                    + ", new size: " + newsize, new Exception());
======= fetch "public boolean parseHeaders()" 0084470^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            // Checking that
            // (1) Headers plus request line size does not exceed its limit
            // (2) There are enough bytes to avoid expanding the buffer when
            // reading body
            // Technically, (2) is technical limitation, (1) is logical
            // limitation to enforce the meaning of headerBufferSize
            // From the way how buf is allocated and how blank lines are being
            // read, it should be enough to check (1) only.
            if (end - skipBlankLinesBytes > headerBufferSize
                    || buf.length - end < socketReadBufferSize) {
                throw new IllegalArgumentException(
                        sm.getString("iib.requestheadertoolarge.error"));
            }
======= fetch "protected boolean fill(boolean timeout, boolean block) throws IOException, EOFEx" 0084470^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            if (buf.length - end < 4500) {
                // In this case, the request header was really large, so we allocate a 
                // brand new one; the old one will get GCed when subsequent requests
                // clear all references
                buf = new byte[buf.length];
                end = 0;
            }
            pos = end;
            lastValid = pos;

    static String defaultProtocol = "TLS";
    static String defaultKeystoreType = "JKS";
    static final org.apache.juli.logging.Log log =
        org.apache.juli.logging.LogFactory.getLog(JSSESocketFactory.class);
======= fetch "public void handshake(Socket sock) throws IOException {" b4e9488^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

        if (!allowUnsafeLegacyRenegotiation) {
            // Prevent futher handshakes by removing all cipher suites
      request. If not specified, a default of <code>false</code> is used.</p>

======= fetch "public Attributes getAttributes(Name name, String[] attrIds)" d21437e^:"java/org/apache/naming/resources/WARDirContext.java"

        else
            attrs.setCollection(true);
      <fix>
        <bug>50683</bug>: Ensure annotations are scanned when upackWars is set
        to <code>false</code> in the Host where a web application is deployed.
        (markt)
      </fix>

======= fetch "public static boolean coerceToBoolean(String s) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            return Boolean.valueOf(s).booleanValue();
======= fetch "public static byte coerceToByte(String s) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            return Byte.valueOf(s).byteValue();
======= fetch "public static double coerceToDouble(String s) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            return Double.valueOf(s).doubleValue();
======= fetch "public static float coerceToFloat(String s) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            return Float.valueOf(s).floatValue();
======= fetch "public static int coerceToInt(String s) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            return Integer.valueOf(s).intValue();
======= fetch "public static short coerceToShort(String s) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            return Short.valueOf(s).shortValue();
======= fetch "public static long coerceToLong(String s) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            return Long.valueOf(s).longValue();
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Byte((byte) 0);
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Byte(s);
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Character((char) 0);
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Character(s.charAt(0));
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Double(0);
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Double(s);
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Float(0);
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Float(s);
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Integer(0);
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Integer(s);
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Short((short) 0);
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Short(s);
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Long(0);
======= fetch "public static Object coerce(String s, Class<?> target) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Long(s);
======= fetch "public static Object convert(String propertyName, String s, Class<?> t," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Byte(s);
======= fetch "public static Object convert(String propertyName, String s, Class<?> t," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return s.length() > 0 ? new Character(s.charAt(0)) : null;
======= fetch "public static Object convert(String propertyName, String s, Class<?> t," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Short(s);
======= fetch "public static Object convert(String propertyName, String s, Class<?> t," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Integer(s);
======= fetch "public static Object convert(String propertyName, String s, Class<?> t," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Float(s);
======= fetch "public static Object convert(String propertyName, String s, Class<?> t," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Long(s);
======= fetch "public static Object convert(String propertyName, String s, Class<?> t," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return new Double(s);
======= fetch "public static String toString(byte b) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

        return new Byte(b).toString();
======= fetch "public static String toString(boolean b) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

        return Boolean.valueOf(b).toString();
======= fetch "public static String toString(short s) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

        return new Short(s).toString();
======= fetch "public static String toString(int i) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

        return new Integer(i).toString();
======= fetch "public static String toString(float f) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

        return new Float(f).toString();
======= fetch "public static String toString(long l) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

        return new Long(l).toString();
======= fetch "public static String toString(double d) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

        return new Double(d).toString();
======= fetch "public static String toString(char c) {" 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

        return new Character(c).toString();
======= fetch "public static void createTypedArray(String propertyName," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                    tmpval[i] = new Character(values[i].charAt(0));
======= fetch "public static void handleSetProperty(Object bean, String prop," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { new Integer(value) });
======= fetch "public static void handleSetProperty(Object bean, String prop," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { new Short(value) });
======= fetch "public static void handleSetProperty(Object bean, String prop," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { new Long(value) });
======= fetch "public static void handleSetProperty(Object bean, String prop," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { new Double(value) });
======= fetch "public static void handleSetProperty(Object bean, String prop," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { new Float(value) });
======= fetch "public static void handleSetProperty(Object bean, String prop," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { new Character(value) });
======= fetch "public static void handleSetProperty(Object bean, String prop," 20ace41^:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { new Byte(value) });

======= fetch "public void visit(Node.CustomTag n) throws JasperException {" af4549f^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                    // Add TLD
                    pageInfo.addDependant(jarResource.getEntry(location.getName()).toString());
                    // Add Tag
                    pageInfo.addDependant(jarResource.getEntry(tagFilePath.substring(1)).toString());

     * Sets the deployer for this cluster deployer to use.
     * @param deployer Deployer
     */
    // FIXME
    //public void setDeployer(Deployer deployer);
    /**
     * members of the cluster with the specified context path.
     * A context path of "" (the empty string) should be used for the root
     * application for this container.  Otherwise, the context path must
     * start with a slash.
     * @param contextPath The context path to which this application should
     * @param war A URL of type "jar:" that points to a WAR file, or type
     *  "file:" that points to an unpacked directory structure containing
     *  the web application to be installed
     * @exception IllegalArgumentException if the specified context path
     *  is malformed (it must be "" or start with a slash)
     * @exception IllegalStateException if the specified context path
    public void install(String contextPath, URL war) throws IOException;
     * path.  If this application is successfully removed, a
     * @param contextPath The context path of the application to be removed
     * @exception IllegalArgumentException if the specified context path
     *  is malformed (it must be "" or start with a slash)
     * @exception IllegalArgumentException if the specified context path does
    public void remove(String contextPath, boolean undeploy) throws IOException;
 * applications in WAR form within the cluster.
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                            fmsg.getContextPath(), fmsg.getFileName()));
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                        String path = fmsg.getContextPath();
                        if (!isServiced(path)) {
                            addServiced(path);
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                                remove(path);
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                                check(path);
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                                removeServiced(path);
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                                        "farmWarDeployer.deployEnd", path));
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                                    "farmWarDeployer.servicingDeploy", path,
                                    name));
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                    String path = umsg.getContextPath();
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                                path));
                    if (!isServiced(path)) {
                        addServiced(path);
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                            remove(path);
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                            removeServiced(path);
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                                    "farmWarDeployer.undeployEnd", path));
======= fetch "public void messageReceived(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                                "farmWarDeployer.servicingUneploy", path));
======= fetch "public synchronized FileMessageFactory getFactory(FileMessage msg)" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

        File tmpFile = new File(msg.getFileName());
        File writeToFile = new File(getTempDir(), tmpFile.getName());
======= fetch "public boolean accept(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     * cluster with the specified context path. A context path of "" (the empty
     * string) should be used for the root application for this container.
     * Otherwise, the context path must start with a slash.
======= fetch "public boolean accept(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     * @param contextPath
     *            The context path to which this application should be installed
======= fetch "public boolean accept(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     * @param war
     *            A URL of type "jar:" that points to a WAR file, or type
     *            "file:" that points to an unpacked directory structure
     *            containing the web application to be installed
======= fetch "public boolean accept(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     *                if the specified context path is malformed (it must be ""
     *                or start with a slash)
======= fetch "public boolean accept(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     *                if the specified context path is already attached to an
     *                existing web application
======= fetch "public boolean accept(ClusterMessage msg) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

    public void install(String contextPath, URL war) throws IOException {
======= fetch "public void install(String contextPath, URL war) throws IOException {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

        FileMessageFactory factory = FileMessageFactory.getInstance(new File(
                war.getFile()), false);
        FileMessage msg = new FileMessage(localMember, war.getFile(),
                contextPath);
======= fetch "public void install(String contextPath, URL war) throws IOException {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            log.debug(sm.getString("farmWarDeployer.sendStart", contextPath,
                    war));
======= fetch "public void install(String contextPath, URL war) throws IOException {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                            contextPath, war, members[i]));
======= fetch "public void install(String contextPath, URL war) throws IOException {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                    "farmWarDeployer.sendEnd", contextPath, war));
======= fetch "public void install(String contextPath, URL war) throws IOException {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     * path. If this application is successfully removed, a ContainerEvent of
======= fetch "public void install(String contextPath, URL war) throws IOException {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     * @param contextPath
     *            The context path of the application to be removed
======= fetch "public void install(String contextPath, URL war) throws IOException {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     *                if the specified context path is malformed (it must be ""
     *                or start with a slash)
======= fetch "public void install(String contextPath, URL war) throws IOException {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     *                if the specified context path does not identify a
======= fetch "public void install(String contextPath, URL war) throws IOException {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

    public void remove(String contextPath, boolean undeploy)
======= fetch "public void remove(String contextPath, boolean undeploy)" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            log.info(sm.getString("farmWarDeployer.removeStart", contextPath));
======= fetch "public void remove(String contextPath, boolean undeploy)" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                .currentTimeMillis(), "Undeploy:" + contextPath + ":"
                + System.currentTimeMillis(), contextPath, undeploy);
======= fetch "public void remove(String contextPath, boolean undeploy)" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            log.debug(sm.getString("farmWarDeployer.removeTxMsg", contextPath));
======= fetch "public void remove(String contextPath, boolean undeploy)" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                if (!isServiced(contextPath)) {
                    addServiced(contextPath);
======= fetch "public void remove(String contextPath, boolean undeploy)" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                        remove(contextPath);
======= fetch "public void remove(String contextPath, boolean undeploy)" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                        removeServiced(contextPath);
======= fetch "public void remove(String contextPath, boolean undeploy)" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                            contextPath));
======= fetch "public void remove(String contextPath, boolean undeploy)" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                        contextPath), ex);
======= fetch "public void fileModified(File newWar) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            String contextName = getContextName(deployWar);
======= fetch "public void fileModified(File newWar) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                log.info(sm.getString("farmWarDeployer.modInstall", contextName,
                        deployWar.getAbsolutePath()));
======= fetch "public void fileModified(File newWar) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                remove(contextName, false);
======= fetch "public void fileModified(File newWar) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            install(contextName, deployWar.toURI().toURL());
======= fetch "public void fileRemoved(File removeWar) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            String contextName = getContextName(removeWar);
======= fetch "public void fileRemoved(File removeWar) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                        contextName));
            remove(contextName, true);
======= fetch "public void fileRemoved(File removeWar) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     * Create a context path from war
     * @param war War filename
     * @return '/filename' or if war name is ROOT.war context name is empty
     *         string '' 
     */
    protected String getContextName(File war) {
        String contextName = "/"
        + war.getName().substring(0,
                war.getName().lastIndexOf(".war"));
        if("/ROOT".equals(contextName))
            contextName= "" ;
        return contextName ;
    }
    
    /**
======= fetch "protected File getAppBase() {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

    protected void remove(String path) throws Exception {
======= fetch "protected void remove(String path) throws Exception {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

        Context context = (Context) host.findChild(path);
======= fetch "protected void remove(String path) throws Exception {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                log.debug(sm.getString("farmWarDeployer.undeployLocal", path));
======= fetch "protected void remove(String path) throws Exception {" 2377f51^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            check(path);
    private String contextPath;
======= fetch "public FileMessage(Member source," 2377f51^:"java/org/apache/catalina/ha/deploy/FileMessage.java"

                       String contextPath) {
======= fetch "public FileMessage(Member source," 2377f51^:"java/org/apache/catalina/ha/deploy/FileMessage.java"

        this.contextPath=contextPath;
======= fetch "public void setFileName(String fileName) {" 2377f51^:"java/org/apache/catalina/ha/deploy/FileMessage.java"

    public String getContextPath() {
        return contextPath;
======= fetch "public boolean writeMessage(FileMessage msg)" 2377f51^:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

            log.warn("Receive Message again -- Sender ActTimeout too short [ path: "
                    + msg.getContextPath()
======= fetch "public boolean writeMessage(FileMessage msg)" 2377f51^:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

            log.warn("Receive Message again -- Sender ActTimeout too short [ path: "
                    + msg.getContextPath()
    private String contextPath;
======= fetch "public UndeployMessage(Member address," 2377f51^:"java/org/apache/catalina/ha/deploy/UndeployMessage.java"

                           String contextPath,
======= fetch "public UndeployMessage(Member address," 2377f51^:"java/org/apache/catalina/ha/deploy/UndeployMessage.java"

        this.contextPath = contextPath;
======= fetch "public void setUniqueId(String uniqueId) {" 2377f51^:"java/org/apache/catalina/ha/deploy/UndeployMessage.java"

    public String getContextPath() {
        return contextPath;
======= fetch "public String getContextPath() {" 2377f51^:"java/org/apache/catalina/ha/deploy/UndeployMessage.java"

    public void setContextPath(String contextPath) {
        this.contextPath = contextPath;

======= fetch "public void setGcDaemonProtection(boolean gcDaemonProtection) {" 5c13d8c^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

      * <code>sun.net.www.http.HttpClient</code> is triggered by a web
      * application. This first call will start a KeepAlive thread with the
      * thread's context class loader configured to be the web application class
      * loader. Defaults to <code>true</code>.
      */
     private boolean keepAliveProtection = true;
     public boolean isKeepAliveProtection() { return keepAliveProtection; }
     public void setKeepAliveProtection(boolean keepAliveProtection) {
         this.keepAliveProtection = keepAliveProtection;
     }
    
     /**
      * Protect against the memory leak caused when the first call to
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 5c13d8c^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

                 * When a servlet opens a connection using a URL it will use
                 * sun.net.www.http.HttpClient which keeps a static reference to
                 * a keep-alive cache which is loaded using the web application
                 * class loader.
                 */
                if (keepAliveProtection) {
                    try {
                        Class.forName("sun.net.www.http.HttpClient");
                    } catch (ClassNotFoundException e) {
                        if (System.getProperty("java.vendor").startsWith(
                                "Sun")) {
                            log.error(sm.getString(
                                    "jreLeakListener.keepAliveFail"), e);
                        } else {
                            log.debug(sm.getString(
                                    "jreLeakListener.keepAliveFail"), e);
                        }
                    }
                }
                
                /*
======= fetch "public StandardContext() {" 5c13d8c^:"java/org/apache/catalina/core/StandardContext.java"

     * If an HttpClient keep-alive timer thread has been started by this web
     * application and is still running, should Tomcat change the context class
     * loader from the current {@link WebappClassLoader} to
     * {@link WebappClassLoader#parent} to prevent a memory leak? Note that the
     * keep-alive timer thread will stop on its own once the keep-alives all
     * expire however, on a busy system that might not happen for some time.
     */
    private boolean clearReferencesHttpClientKeepAliveThread = true;
    /**
======= fetch "public void setClearReferencesStopTimerThreads(" 5c13d8c^:"java/org/apache/catalina/core/StandardContext.java"

        JVM_THREAD_GROUP_NAMES.add("system");
======= fetch "protected boolean removeEldestEntry(" 5c13d8c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

    /**
     * If an HttpClient keep-alive timer thread has been started by this web
     * application and is still running, should Tomcat change the context class
     * loader from the current {@link WebappClassLoader} to
     * {@link WebappClassLoader#parent} to prevent a memory leak? Note that the
     * keep-alive timer thread will stop on its own once the keep-alives all
     * expire however, on a busy system that might not happen for some time.
     */
    private boolean clearReferencesHttpClientKeepAliveThread = true;
======= fetch "public void setClearReferencesLogFactoryRelease(" 5c13d8c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     /**
      * Return the clearReferencesHttpClientKeepAliveThread flag for this
      * Context.
      */
     public boolean getClearReferencesHttpClientKeepAliveThread() {
         return (this.clearReferencesHttpClientKeepAliveThread);
     }
     /**
      * Set the clearReferencesHttpClientKeepAliveThread feature for this
      * Context.
      *
      * @param clearReferencesHttpClientKeepAliveThread The new flag value
      */
     public void setClearReferencesHttpClientKeepAliveThread(
             boolean clearReferencesHttpClientKeepAliveThread) {
         this.clearReferencesHttpClientKeepAliveThread =
             clearReferencesHttpClientKeepAliveThread;
     }
     
======= fetch "private void clearReferencesThreads() {" 5c13d8c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                    // Don't warn about JVM controlled threads
======= fetch "private void clearReferencesThreads() {" 5c13d8c^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                        // HttpClient keep-alive threads
                        if (clearReferencesHttpClientKeepAliveThread &&
                                thread.getName().equals("Keep-Alive-Timer")) {
                            thread.setContextClassLoader(parent);
                            log.debug(sm.getString(
                                    "webappClassLoader.checkThreadsHttpClient"));
                        }
                    
                        // Don't warn about remaining JVM controlled threads
======= fetch "protected void startInternal() throws LifecycleException {" 5c13d8c^:"java/org/apache/catalina/loader/WebappLoader.java"

      <attribute name="keepAliveProtection" required="false">
        <p>Enables protection so that the KeepAlive thread started by
        <code>sun.net.www.http.HttpClient</code> does not result in a memory
        leak. The thread is started the first time the <code>HttpClient</code>
        class is used. Without this protection, if a web application uses this
        class the KeepAlive thread will be configured with the thread's context
        class loader set to the web application class loader which in turn will
        trigger a memory leak on reload. Defaults to <code>true</code>.</p>
      </attribute>

======= fetch "public void readExternal(ObjectInput in ) throws IOException {" 0119483^:"java/org/apache/catalina/tribes/ByteMessage.java"

        in.read(message,0,length);

======= fetch "protected File engineBase() {" 3898ed0^:"java/org/apache/catalina/core/StandardContext.java"

    // -------------------------------------------------------- Private Methods
======= fetch "protected File engineBase() {" 3898ed0^:"java/org/apache/catalina/core/StandardContext.java"

    private ClassLoader bindThread() {
======= fetch "private ClassLoader bindThread() {" 3898ed0^:"java/org/apache/catalina/core/StandardContext.java"

    private void unbindThread(ClassLoader oldContextClassLoader) {

    private static final Log log = LogFactory.getLog(Connector.class);
    
======= fetch "public void recycle() {" fbd0110^:"java/org/apache/catalina/connector/Request.java"

            session.endAccess();

    
======= fetch "public void init(ServletConfig config) throws ServletException {" c0cd721^:"java/org/apache/catalina/servlets/CGIServlet.java"

        if (getServletConfig().getInitParameter("executable-arg-1") != null) {
            List<String> args = new ArrayList<String>();
            for (int i = 1;; i++) {
                String arg = getServletConfig().getInitParameter(
                        "executable-arg-" + i);
                if (arg == null) {
                    break;
                }
                args.add(arg);
            }
            cgiExecutableArgs = args;
        }
======= fetch "protected void run() throws IOException {" c0cd721^:"java/org/apache/catalina/servlets/CGIServlet.java"

            String[] cmdAndArgs = new String[params.size() + 2];
            
            cmdAndArgs[0] = cgiExecutable;
            
            cmdAndArgs[1] = command;
            //create query arguments
            for (int i=0; i < params.size(); i++) {
                cmdAndArgs[i + 2] = params.get(i);
======= fetch "protected void run() throws IOException {" c0cd721^:"java/org/apache/catalina/servlets/CGIServlet.java"

            cmdAndArgs.add(command);
            cmdAndArgs.addAll(params);
======= fetch "protected void run() throws IOException {" c0cd721^:"java/org/apache/catalina/servlets/CGIServlet.java"

                proc = rt.exec(cmdAndArgs, hashToStringArray(env), wd);

======= fetch "protected void release(PooledConnection con) {" 5cb0b7a^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            idle.offer(new PooledConnection(poolProperties, this));
======= fetch "protected PooledConnection createConnection(long now, PooledConnection notUsed," 5cb0b7a^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        PooledConnection con = create();
======= fetch "public static String getStackTrace(Throwable x) {" 5cb0b7a^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    protected PooledConnection create() {

======= fetch "public boolean equals(Object obj) {" d95db3f^:"java/org/apache/catalina/core/ApplicationTaglibDescriptor.java"

        if (obj == null) {
            return false;
        }
======= fetch "public boolean equals(Object obj) {" d95db3f^:"java/org/apache/catalina/deploy/LoginConfig.java"

        if (obj == null)
            return false;
======= fetch "public boolean equals(Object o) {" d95db3f^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        if ( o == null ) return false;
======= fetch "public boolean equals(Object obj) {" d95db3f^:"java/org/apache/el/parser/SimpleNode.java"

        if (obj == null) {
            return false;
        }
======= fetch "public boolean equals(Object obj) {" d95db3f^:"java/org/apache/naming/NamingEntry.java"

        if ((obj != null) && (obj instanceof NamingEntry)) {
======= fetch "public boolean equals(Object obj) {" d95db3f^:"java/org/apache/tomcat/util/net/URL.java"

        if (obj == null)
            return (false);

======= fetch "public void setPassword(String password) {" de188ad^:"java/org/apache/catalina/ant/AbstractCatalinaTask.java"

    protected String url = "http://localhost:8080/manager";
      <code>http://localhost:8080/manager</code> (which corresponds
      to a standard installation of Tomcat 5).
  <property name="url"      value="http://localhost:8080/manager"/>
  <property name="manager.url"   value="http://localhost:8080/manager"/>
                <code>http://localhost:8080/manager</code>.

======= fetch "void setFilterDef(FilterDef filterDef)" 30468b7^:"java/org/apache/catalina/core/ApplicationFilterConfig.java"

            // Allocate a new filter instance
            getFilter();

======= fetch "public void check() {" d269ce3^:"java/org/apache/catalina/ha/deploy/WarWatcher.java"

                currentStatus.remove(info.getWar().getAbsolutePath());

======= fetch "public void service(org.apache.coyote.Request req," 35a84d1^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                ((Context) request.getMappingData().context).logAccess(request,
                        response,
                        System.currentTimeMillis() - req.getStartTime(), false);
======= fetch "public void log(org.apache.coyote.Request req," 35a84d1^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        boolean create = false;
        
======= fetch "public void log(org.apache.coyote.Request req," 35a84d1^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            create = true;
======= fetch "public void log(org.apache.coyote.Request req," 35a84d1^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        request.recycle();
        response.recycle();
======= fetch "public void invoke(Request request, Response response) throws IOException," 35a84d1^:"java/org/apache/catalina/valves/AccessLogValve.java"

        if (getState().isAvailable() && getEnabled()) {                
            final String t1Name = AccessLogValve.class.getName()+".t1";
            // Pass this request on to the next valve in our pipeline
            long t1 = System.currentTimeMillis();
            boolean asyncdispatch = request.isAsyncDispatching();
            if (!asyncdispatch) {
                request.setAttribute(t1Name, Long.valueOf(t1));
            }
    
            getNext().invoke(request, response);
    
            //we're not done with the request
            if (request.isAsyncDispatching()) {
                return;
            } else if (asyncdispatch && request.getAttribute(t1Name)!=null) {
                t1 = ((Long)request.getAttribute(t1Name)).longValue();
            }
            
            long t2 = System.currentTimeMillis();
            long time = t2 - t1;
            log(request,response, time);
        } else
            getNext().invoke(request, response);       
======= fetch "public void log(Request request, Response response, long time) {" 35a84d1^:"java/org/apache/catalina/valves/AccessLogValve.java"

        if (logElements == null || condition != null
======= fetch "public void addElement(StringBuilder buf, Date date, Request request," 35a84d1^:"java/org/apache/catalina/valves/AccessLogValve.java"

            long length = response.getBytesWritten(true);
======= fetch "public void setUseLongContentLength(boolean useLongContentLength) {" 35a84d1^:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

    public void invoke(Request request, Response response) 
        throws IOException, ServletException {
        
======= fetch "public void invoke(Request request, Response response)" 35a84d1^:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

        log (request, response, 0);
======= fetch "public void log(Request request, Response response, long time) {" 35a84d1^:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

        if (!getState().isAvailable()) {
            return;
        }
======= fetch "public void nextRequest() {" 35a84d1^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        byteCount = 0;
======= fetch "public void endRequest()" 35a84d1^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        byteCount = 0;

======= fetch "protected boolean isRequestWithoutSessionChange(String uri) {" d8f8be1^:"java/org/apache/catalina/ha/tcp/ReplicationValve.java"

        return filter.matcher(uri).matches();

======= fetch "public Group createGroup(String groupname, String description) {" 51650a1^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

        if (groupname == null || groupname.length() == 0) {
            String msg = sm.getString("memoryUserDatabase.nullGroup");
            log.warn(msg);
            throw new IllegalArgumentException(msg);
        }
======= fetch "public Role createRole(String rolename, String description) {" 51650a1^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

        if (rolename == null || rolename.length() == 0) {
            String msg = sm.getString("memoryUserDatabase.nullRole");
            log.warn(msg);
            throw new IllegalArgumentException(msg);
        }
======= fetch "public User createUser(String username, String password," 51650a1^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

        if (username == null || username.length() == 0) {
            String msg = sm.getString("memoryUserDatabase.nullUser");
            log.warn(msg);
            throw new IllegalArgumentException(msg);
        }
======= fetch "public User createUser(String username, String password," 51650a1^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

======= fetch "public void open() throws Exception {" 51650a1^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                     new MemoryGroupCreationFactory(this));
======= fetch "public void open() throws Exception {" 51650a1^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                     new MemoryRoleCreationFactory(this));
======= fetch "public void open() throws Exception {" 51650a1^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                     new MemoryUserCreationFactory(this));

======= fetch "protected void initStreams() {" 164fd40^:"java/org/apache/catalina/startup/Catalina.java"

        SystemLogHandler systemlog = new SystemLogHandler(System.out);
        System.setOut(systemlog);
        System.setErr(systemlog);
======= fetch "protected void initStreams() {" 164fd40^:"java/org/apache/catalina/startup/Embedded.java"

            SystemLogHandler systemlog = new SystemLogHandler(System.out);
            System.setOut(systemlog);
            System.setErr(systemlog);

======= fetch "public void visit(Node.PageDirective n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                out.printil("public String getServletInfo() {");
======= fetch "private void generateInit() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("private void _jspInit(ServletConfig config) {");
======= fetch "private void genPreambleStaticInitializers() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();");
======= fetch "private void genPreambleStaticInitializers() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("private static java.util.List<String> _jspx_dependants;");
======= fetch "private void genPreambleStaticInitializers() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printin("_jspx_dependants = new java.util.ArrayList<String>(");
======= fetch "private void genPreambleMethods() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("public java.util.List<String> getDependants() {");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printin("                 SingleThreadModel");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.println("(final HttpServletRequest request, final HttpServletResponse response)");
        out.println("        throws java.io.IOException, ServletException {");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("final PageContext pageContext;");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("HttpSession session = null;");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("final ServletContext application;");
        out.printil("final ServletConfig config;");
        out.printil("JspWriter out = null;");
        out.printil("final Object page = this;");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("JspWriter _jspx_out = null;");
        out.printil("PageContext _jspx_page_context = null;");
======= fetch "public void visit(Node.ForwardAction n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                out.printil("throw new SkipPageException();");
======= fetch "public void visit(Node.UseBean n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            String scopename = "PageContext.PAGE_SCOPE"; // Default to page
======= fetch "public void visit(Node.UseBean n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                scopename = "PageContext.REQUEST_SCOPE";
======= fetch "public void visit(Node.UseBean n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                scopename = "PageContext.SESSION_SCOPE";
======= fetch "public void visit(Node.UseBean n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                scopename = "PageContext.APPLICATION_SCOPE";
======= fetch "public void visit(Node.UseBean n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                    out.printil("} catch (ClassNotFoundException exc) {");
======= fetch "public void visit(Node.UseBean n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                    out.printil("} catch (Exception exc) {");
======= fetch "public void visit(Node.UseBean n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                    out.printin("throw new ServletException(");
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                out.print("PageContext _jspx_page_context");
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                out.printil("        throws Throwable {");
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                    out.printil("PageContext pageContext = _jspx_page_context;");
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                out.printil("JspWriter out = _jspx_page_context.getOut();");
======= fetch "public void visit(Node.JspElement n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                        nvp = " + (Boolean.valueOf(" + omit + ")?\"\":\" " +
======= fetch "public void visit(Node.InvokeAction n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("jspContext.getELContext().putContext(JspContext.class,getJspContext());");
======= fetch "public void visit(Node.DoBodyAction n) throws JasperException {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("jspContext.getELContext().putContext(JspContext.class,getJspContext());");
======= fetch "private void generateCustomEnd(Node.CustomTag n, String tagHandlerVar," e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                out.printil("throw new SkipPageException();");
======= fetch "private void generateCustomEnd(Node.CustomTag n, String tagHandlerVar," e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                out.printil("} catch (Throwable _jspx_exception) {");
======= fetch "private String evaluateAttribute(TagHandlerInfo handlerInfo," e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                    sb.append("new Class[] {");
======= fetch "private String getScopeConstant(String scope) {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            String scopeName = "PageContext.PAGE_SCOPE"; // Default to page
======= fetch "private String getScopeConstant(String scope) {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                scopeName = "PageContext.REQUEST_SCOPE";
======= fetch "private String getScopeConstant(String scope) {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                scopeName = "PageContext.SESSION_SCOPE";
======= fetch "private String getScopeConstant(String scope) {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                scopeName = "PageContext.APPLICATION_SCOPE";
======= fetch "public String generateNamedAttributeValue(Node.NamedAttribute n)" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                        out.printil("String "
======= fetch "public String generateNamedAttributeValue(Node.NamedAttribute n)" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                    out.printil("String " + varName + " = "
======= fetch "public String generateNamedAttributeValue(Node.NamedAttribute n)" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                out.printil("String " + varName + " = \"\";");
======= fetch "private static void generateLocalVariables(ServletWriter out, Node n)" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("HttpSession session = _jspx_page_context.getSession();");
            out.printil("ServletContext application = _jspx_page_context.getServletContext();");
======= fetch "private static void generateLocalVariables(ServletWriter out, Node n)" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("HttpServletRequest request = (HttpServletRequest)_jspx_page_context.getRequest();");
======= fetch "private static void generateLocalVariables(ServletWriter out, Node n)" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("HttpServletResponse response = (HttpServletResponse)_jspx_page_context.getResponse();");
======= fetch "private void generatePostamble() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("} catch (Throwable t) {");
======= fetch "private void generatePostamble() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("if (!(t instanceof SkipPageException)){");
======= fetch "private void generateTagHandlerPreamble(JasperTagInfo tagInfo," e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("private JspContext jspContext;");
======= fetch "private void generateTagHandlerPreamble(JasperTagInfo tagInfo," e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("public void doTag() throws JspException, java.io.IOException {");
======= fetch "private void generateTagHandlerPreamble(JasperTagInfo tagInfo," e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("PageContext _jspx_page_context = (PageContext)jspContext;");
======= fetch "private void generateTagHandlerPreamble(JasperTagInfo tagInfo," e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("HttpServletRequest request = "
                + "(HttpServletRequest) _jspx_page_context.getRequest();");
        out.printil("HttpServletResponse response = "
                + "(HttpServletResponse) _jspx_page_context.getResponse();");
        out.printil("HttpSession session = _jspx_page_context.getSession();");
        out.printil("ServletContext application = _jspx_page_context.getServletContext();");
        out.printil("ServletConfig config = _jspx_page_context.getServletConfig();");
        out.printil("JspWriter out = jspContext.getOut();");
======= fetch "private void generateTagHandlerPreamble(JasperTagInfo tagInfo," e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("jspContext.getELContext().putContext(JspContext.class,jspContext);");
======= fetch "private void generateTagHandlerPostamble(TagInfo tagInfo) {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("} catch( Throwable t ) {");
======= fetch "private void generateTagHandlerPostamble(TagInfo tagInfo) {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("if( t instanceof SkipPageException )");
        out.printil("    throw (SkipPageException) t;");
======= fetch "private void generateTagHandlerPostamble(TagInfo tagInfo) {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("if( t instanceof IllegalStateException )");
        out.printil("    throw (IllegalStateException) t;");
        out.printil("if( t instanceof JspException )");
        out.printil("    throw (JspException) t;");
        out.printil("throw new JspException(t);");
======= fetch "private void generateTagHandlerPostamble(TagInfo tagInfo) {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("jspContext.getELContext().putContext(JspContext.class,super.getJspContext());");
======= fetch "private void generateSetJspContext(TagInfo tagInfo) {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("public void setJspContext(JspContext ctx, java.util.Map aliasMap) {");
======= fetch "private void generateSetJspContext(TagInfo tagInfo) {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("public void setJspContext(JspContext ctx) {");
======= fetch "private void generateSetJspContext(TagInfo tagInfo) {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("public JspContext getJspContext() {");
======= fetch "public void generateSetDynamicAttribute() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("public void setDynamicAttribute(String uri, String localName, Object value) throws JspException {");
======= fetch "public void generatePreamble() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

                    + "( int discriminator, JspContext jspContext, "
======= fetch "public Fragment openFragment(Node parent, int methodNesting)" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.println(result.getId() + "( " + "JspWriter out ) ");
======= fetch "public Fragment openFragment(Node parent, int methodNesting)" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("throws Throwable");
======= fetch "public void generatePostamble() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("throws JspException");
======= fetch "public void generatePostamble() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("JspWriter out = null;");
======= fetch "public void generatePostamble() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("this.jspContext.getELContext().putContext(JspContext.class,this.jspContext);");
======= fetch "public void generatePostamble() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("catch( Throwable e ) {");
======= fetch "public void generatePostamble() {" e69347b^:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("if (e instanceof SkipPageException)");
            out.printil("    throw (SkipPageException) e;");
            out.printil("throw new JspException( e );");
======= fetch "public static String interpreterCall(boolean isTagFile, String expression," e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                        + ".class, " + "(PageContext)" + jspCtxt + ", "
======= fetch "public static String coerceToBoolean(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(Boolean) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", Boolean.class)";
======= fetch "public static String coerceToBoolean(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Boolean(false)";
======= fetch "public static String coerceToBoolean(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Boolean(" + Boolean.valueOf(s).toString() + ")";
======= fetch "public static String coerceToByte(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(Byte) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", Byte.class)";
======= fetch "public static String coerceToByte(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Byte((byte) 0)";
======= fetch "public static String coerceToByte(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Byte((byte)" + Byte.valueOf(s).toString() + ")";
======= fetch "public static String coerceToCharacter(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(Character) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", Character.class)";
======= fetch "public static String coerceToCharacter(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Character((char) 0)";
======= fetch "public static String coerceToCharacter(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Character((char) " + (int) ch + ")";
======= fetch "public static String coerceToDouble(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(Double) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
======= fetch "public static String coerceToDouble(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Double(0)";
======= fetch "public static String coerceToDouble(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Double(" + Double.valueOf(s).toString() + ")";
======= fetch "public static String coerceToFloat(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(Float) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", Float.class)";
======= fetch "public static String coerceToFloat(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Float(0)";
======= fetch "public static String coerceToFloat(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Float(" + Float.valueOf(s).toString() + "f)";
======= fetch "public static String coerceToInteger(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(Integer) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", Integer.class)";
======= fetch "public static String coerceToInteger(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Integer(0)";
======= fetch "public static String coerceToInteger(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Integer(" + Integer.valueOf(s).toString() + ")";
======= fetch "public static String coerceToShort(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(Short) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", Short.class)";
======= fetch "public static String coerceToShort(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Short((short) 0)";
======= fetch "public static String coerceToShort(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Short(\"" + Short.valueOf(s).toString() + "\")";
======= fetch "public static String coerceToLong(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(Long) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", Long.class)";
======= fetch "public static String coerceToLong(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Long(0)";
======= fetch "public static String coerceToLong(String s, boolean isNamedAttribute) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

                return "new Long(" + Long.valueOf(s).toString() + "l)";
======= fetch "public static String toJavaSourceTypeFromTld(String type) {" e69347b^:"java/org/apache/jasper/compiler/JspUtil.java"

            return "Void.TYPE";

======= fetch "protected void init(PoolConfiguration properties) throws SQLException {" 0ccff07^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    protected int maxActive = 100;

======= fetch "public AtomicInteger getCacheSize() {" fd990a4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java"

    @Override
======= fetch "public void setProperties(Map<String, InterceptorProperty> properties) {" fd990a4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java"

    @Override
======= fetch "public void poolStarted(ConnectionPool pool) {" fd990a4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java"

    @Override
======= fetch "protected Object createDecorator(Object proxy, Method method, Object[] args," fd990a4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java"

    @Override
======= fetch "public PoolConfiguration getPoolProperties() {" fd990a4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    @Override

      <fix>
        <bug>21157</bug>: Ensure cookies are written before the response is
        commited in the Cookie example. Patch provided by Stefan Radzom. (markt)
      </fix>
======= fetch "public void doGet(HttpServletRequest request," 4ce656a^:"webapps/examples/WEB-INF/classes/CookieExample.java"

        
        String cookieName = request.getParameter("cookiename");
        String cookieValue = request.getParameter("cookievalue");
        Cookie aCookie = null;
        if (cookieName != null && cookieValue != null) {
            aCookie = new Cookie(cookieName, cookieValue);
            response.addCookie(aCookie);
        }
======= fetch "public void doGet(HttpServletRequest request," 4ce656a^:"webapps/examples/WEB-INF/classes/CookieExample.java"

        String cookieName = request.getParameter("cookiename");
        String cookieValue = request.getParameter("cookievalue");
        if (cookieName != null && cookieValue != null) {
            Cookie cookie = new Cookie(cookieName, cookieValue);
            response.addCookie(cookie);

======= fetch "protected void closeRedirector() {" a6b37af^:"java/org/apache/catalina/ant/BaseRedirectorHelperTask.java"

            if (redirectOutput) {

    @SuppressWarnings("unchecked")
    @Override
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 06b8609^:"java/org/apache/naming/java/javaURLContextFactory.java"

    @SuppressWarnings("unchecked")
    @Override
======= fetch "public Context getInitialContext(Hashtable<?,?> environment)" 06b8609^:"java/org/apache/naming/java/javaURLContextFactory.java"

            synchronized(getClass()) {

======= fetch "public ConnectionPool(PoolConfiguration prop) throws SQLException {" 869c6f4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        PooledConnection pc = this.borrowConnection(0, null, null);
        if (pc!=null) {
            return new ConnectionFuture(pc);
        } 
======= fetch "protected void createMBean() {" 869c6f4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        volatile PooledConnection pc = null;
======= fetch "public ConnectionFuture(Future<PooledConnection> pcf) {" 869c6f4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        public ConnectionFuture(PooledConnection pc) {
            this.pc = pc;
        }
======= fetch "public boolean cancel(boolean mayInterruptIfRunning) {" 869c6f4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            if ((!cancelled.get()) && cancelled.compareAndSet(false, true)) {
======= fetch "public Connection get(long timeout, TimeUnit unit) throws InterruptedException," 869c6f4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            PooledConnection pc = pcFuture.get(timeout,unit);
======= fetch "public boolean isCancelled() {" 869c6f4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            return pcFuture.isCancelled() || cancelled.get();
======= fetch "public boolean isDone() {" 869c6f4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            return pcFuture.isDone();

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ 
 * <p>Object factory for resource links for shared data sources.</p>
 * 
 * @author Filip Hanik
 * @version $Id: ResourceLinkFactory.java 939311 2010-04-29 14:01:02Z kkolinko $
 */
    implements ObjectFactory {
    // -------------------------------------------------- ObjectFactory Methods
    /**
     * Create a new DataSource instance.
     * 
     * @param obj The reference object describing the DataSource
     */
    public Object getObjectInstance(Object obj, Name name, Context nameCtx,
                                    Hashtable<?,?> environment)
        throws NamingException {
        Object result = super.getObjectInstance(obj, name, nameCtx, environment);
        // Can we process this request?
        if (result!=null) {
            Reference ref = (Reference) obj;
    
            RefAddr userAttr = ref.get("username");
            RefAddr passAttr = ref.get("password");
            if (userAttr.getContent()!=null && passAttr.getContent()!=null) {
                result = wrapDataSource(result,userAttr.getContent().toString(), passAttr.getContent().toString());
            }
        }
        return result;
    }
    
    protected Object wrapDataSource(Object datasource, String username, String password) throws NamingException {
        try {
            Class<?> proxyClass = Proxy.getProxyClass(datasource.getClass().getClassLoader(), datasource.getClass().getInterfaces());
            Constructor<?> proxyConstructor = proxyClass.getConstructor(new Class[] { InvocationHandler.class });
            DataSourceHandler handler = new DataSourceHandler((DataSource)datasource, username, password);
            return proxyConstructor.newInstance(handler);    
        }catch (Exception x) {
            if (x instanceof NamingException) throw (NamingException)x;
            else {
                NamingException nx = new NamingException(x.getMessage());
                nx.initCause(x);
                throw nx;
            }
        }
    }
    
    /**
     * Simple wrapper class that will allow a user to configure a ResourceLink for a data source
     * so that when {@link javax.sql.DataSource#getConnection()} is called, it will invoke 
     * {@link javax.sql.DataSource#getConnection(String, String)} with the preconfigured username and password.
     */
    public static class DataSourceHandler implements InvocationHandler {
        DataSource ds; 
        String username; 
        String password;
        public DataSourceHandler(DataSource ds, String username, String password) {
            this.ds = ds;
            this.username = username;
            this.password = password;
        }
        
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            
            if ("getConnection".equals(method.getName()) && args.length==0) {
                args = new String[] {username,password};
            } else if ("unwrap".equals(method.getName())) {
                return unwrap((Class<?>)args[0]);
            }
            try {
                return method.invoke(ds,args);
            }catch (Throwable t) {
                if (t instanceof InvocationTargetException) {
                    InvocationTargetException it = (InvocationTargetException)t;
                    throw it.getCause()!=null?it.getCause():it;
                } else {
                    throw t;
                }
            }
        }
        
        public Object unwrap(Class<?> iface) throws SQLException {
            if (iface == DataSource.class) {
                return ds;
            } else {
                throw new SQLException("Not a wrapper of "+iface.getName());
            }
        }
        
    }
    
    
      <fix><bug>49543</bug> Allow Tomcat to use shared data sources with 
       per application credentials. (fhanik)
      </fix>
      <attribute name="factory" required="false">
        <p>The fully qualified Java class name for the class creating these objects.
        This class should implement the <code>javax.naming.spi.ObjectFactory</code> interface.</p>
      </attribute>
    
    <p>When the attribute <code>factory=&quot;org.apache.naming.factory.DataSourceLinkFactory&quot;</code> the resource link can be used with
       two additional attributes to allow a shared data source to be used with different credentials.
       When these two additional attributes are used in combination with the <code>javax.sql.DataSource</code>
       type, different contexts can share a global data source with different credentials.
       Under the hood, what happens is that a call to <a href="http://download.oracle.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection()"><code>getConnection()</code></a>
       is simply translated to a call <a href="http://download.oracle.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection(java.lang.String,%20java.lang.String)">
       <code>getConnection(username, password)</code></a> on the global data source. This is an easy way to get code to be transparent to what schemas are being used,
       yet be able to control connections (or pools) in the global configuration. 
    </p>
    <attributes>
      <attribute name="username" required="false">
        <p></p>
      </attribute>
      <attribute name="password" required="false">
        <p></p>
      </attribute>
    </attributes>
    <p>Shared Data Source Example</p>
  ...
  &lt;Resource name=&quot;sharedDataSource&quot;
            global=&quot;sharedDataSource&quot;
            type=&quot;javax.sql.DataSource&quot;
            username=&quot;bar&quot;
            password=&quot;barpass&quot;
            
            ...
  ...
  ...
  &lt;ResourceLink 
            name=&quot;appDataSource&quot;
            global=&quot;sharedDataSource&quot;
            type=&quot;javax.sql.DataSource&quot;
            factory=&quot;org.apache.naming.factory.DataSourceLinkFactory&quot;
            username=&quot;foo&quot;
            password=&quot;foopass&quot;
  ...
  ...
  &lt;ResourceLink 
            name=&quot;appDataSource&quot;
            global=&quot;sharedDataSource&quot;
            type=&quot;javax.sql.DataSource&quot;
  ...
    <p>When a request for <code>getConnection()</code> is made in the <code>/foo</code> context, the request is translated into
       <code>getConnection(&quot;foo&quot;,&quot;foopass&quot;)</code>, while a request in the <code>/bar</code> gets passed straight through.</p>

======= fetch "protected boolean cacheUnload(String name) {" 5c2742c^:"java/org/apache/naming/resources/ProxyDirContext.java"

            return cache.unload(name);
======= fetch "protected boolean cacheUnload(String name) {" 5c2742c^:"java/org/apache/naming/resources/ProxyDirContext.java"

      <fix>
        <bug>50550</bug>: When a new directory is created (e.g. via WebDAV)
        ensure that a subsequent request for that directory does not result in a
        404 response. (markt)
      </fix>

======= fetch "public void actionInternal(ActionCode actionCode, Object param) {" ce64f9b^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                    if (remoteHost == null) {
                        remoteHost = Address.getip(sa);
                    }
      <fix>
        <bug>47319</bug>: Return the client&apos;s IP address rather than null
        for calls to <code>getRemoteHost()</code> when the APR connector is
        used with <code>enableLookups=&quot;true&quot;</code> but the IP address
        is not resolveable. (markt)
      </fix>

======= fetch "public void changeSessionId(Session session, boolean notify) {" a0ef3e6^:"java/org/apache/catalina/ha/session/DeltaManager.java"

                msg.setTimestamp(System.currentTimeMillis());
======= fetch "protected void sessionExpired(String id) {" a0ef3e6^:"java/org/apache/catalina/ha/session/DeltaManager.java"

        msg.setTimestamp(System.currentTimeMillis());
      <fix>
        <bug>50547</bug>: Add time stamp for CHANGE_SESSION_ID message and 
        SESSION_EXPIRED message. (kfujino)
      </fix>

======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 3541fc6^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            StringBuffer concatRemoteIpHeaderValue = new StringBuffer();
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 3541fc6^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            String[] remoteIpHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIpHeader));
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 3541fc6^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                        + request.getHeader(remoteIpHeader) + ", original[" + protocolHeader + "]='"
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 3541fc6^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                        + xRequest.getHeader(remoteIpHeader) + ", new[" + proxiesHeader + "]='" + xRequest.getHeader(proxiesHeader) + "'");
======= fetch "public void invoke(Request request, Response response) throws IOException, Servl" 3541fc6^:"java/org/apache/catalina/valves/RemoteIpValve.java"

            StringBuffer concatRemoteIpHeaderValue = new StringBuffer();
======= fetch "public void invoke(Request request, Response response) throws IOException, Servl" 3541fc6^:"java/org/apache/catalina/valves/RemoteIpValve.java"

            String[] remoteIpHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIpHeader));
======= fetch "public void setHeader(String name, String value) {" 3541fc6^:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

        public void addHeader(String name, String value) {
            getCoyoteRequest().getMimeHeaders().addValue(name).setString(value);
        }
======= fetch "public void testInvokeAllProxiesAreInternal() throws Exception {" 3541fc6^:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

        request.setHeader("x-forwarded-for", "140.211.11.130, 192.168.0.10, 192.168.0.11");
======= fetch "public void testInvokeAllProxiesAreTrustedAndRemoteAddrMatchRegexp() throws Exce" 3541fc6^:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

        request.setHeader("x-forwarded-for", "140.211.11.130, proxy1, proxy2");
======= fetch "public void testInvokeAllProxiesAreTrustedAndRemoteAddrMatchRegexp() throws Exce" 3541fc6^:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

        request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-for").setString("140.211.11.130, proxy1, proxy2");

======= fetch "public void run() {" 688e61e^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                        attachment.access();
                        iterator.remove();
                        processKey(sk, attachment);

    /**
     * The sizeLimit (also known as the countLimit) to use when the realm is
     * configured with {@link #userSearch}. Zero for no limit.
     */
    protected long sizeLimit = 0;
    /**
     * The timeLimit (in milliseconds) to use when the realm is configured with
     * {@link #userSearch}. Zero for no limit.
     */
    protected int timeLimit = 0;
======= fetch "public void setConnectionTimeout(String timeout) {" 76b6415^:"java/org/apache/catalina/realm/JNDIRealm.java"

    public long getSizeLimit() {
        return sizeLimit;
    }
    public void setSizeLimit(long sizeLimit) {
        this.sizeLimit = sizeLimit;
    }
    public int getTimeLimit() {
        return timeLimit;
    }
    public void setTimeLimit(int timeLimit) {
        this.timeLimit = timeLimit;
    }
======= fetch "protected User getUserBySearch(DirContext context," 76b6415^:"java/org/apache/catalina/realm/JNDIRealm.java"

        constraints.setCountLimit(sizeLimit);
        constraints.setTimeLimit(timeLimit);
      <add>
        <bug>50541</bug>: Add support for setting the size limit and time limit
        for LDAP seaches when using the JNDI Realm with <code>userSearch</code>.
        (markt)
      </add>
      <attribute name="sizeLimit" required="false">
        <p>Specifies the maximum number of records to return when using the
        <code>userSearch</code> attribute. If not specified, the default of
        <code>0</code> is used which indicates no limit.</p>
      </attribute>
      <attribute name="timeLimit" required="false">
        <p>Specifies the time (in milliseconds) to wait for records to be
        returned when using the <code>userSearch</code> attribute. If not
        specified, the default of <code>0</code> is used which indicates no
        limit.</p>
      </attribute>

======= fetch "public static final Number add(final Object obj0, final Object obj1) {" b19fb3b^:"java/org/apache/el/lang/ELArithmetic.java"

        else if (DOUBLE.matches(obj0, obj1))
            delegate = DOUBLE;
        else if (BIGINTEGER.matches(obj0, obj1))
======= fetch "public static final Number mod(final Object obj0, final Object obj1) {" b19fb3b^:"java/org/apache/el/lang/ELArithmetic.java"

            delegate = BIGDECIMAL;
======= fetch "public static final Number subtract(final Object obj0, final Object obj1) {" b19fb3b^:"java/org/apache/el/lang/ELArithmetic.java"

        else if (DOUBLE.matches(obj0, obj1))
            delegate = DOUBLE;
        else if (BIGINTEGER.matches(obj0, obj1))
======= fetch "public static final Number multiply(final Object obj0, final Object obj1) {" b19fb3b^:"java/org/apache/el/lang/ELArithmetic.java"

        else if (DOUBLE.matches(obj0, obj1))
            delegate = DOUBLE;
        else if (BIGINTEGER.matches(obj0, obj1))

    <attribute name="alternateUsernameAllowed" required="false">
      <p>(boolean) By default, the jdbc-pool will ignore the 
         <a href="http://download.oracle.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection(java.lang.String,%20java.lang.String)"><code>DataSource.getConnection(username,password)</code></a>
         call, and simply return a previously pooled connection under the globally configured properties <code>username</code> and <code>password</code>, for performance reasons.
         The pool can however be used with different credentials each time a connection is used. Should you request a connection with the credentials user1/password1 and the connection
         was previously connected using user2/password2, the connection will be closed, and reopened with the requested credentials. This way, the pool size is still managed
         on a global level, and not on a per schema level. To enable the functionality described in the 
         <a href="http://download.oracle.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection(java.lang.String,%20java.lang.String)"><code>DataSource.getConnection(username,password)</code></a>
         call, simply set the property <code>alternateUsernameAllowed</code> to true. <br/>
         The default value is <code>false</code>.<br/>
         This property was added as an enhancement to <a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=50025">bug 50025</a>.
      </p>
    </attribute>
======= fetch "public Connection getConnection() throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        PooledConnection con = borrowConnection(-1);
======= fetch "public Connection getConnection() throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

       
    /**
     * Borrows a connection from the pool. If a connection is available (in the
     * idle queue) or the pool has not reached {@link PoolProperties#maxActive
     * maxActive} connections a connection is returned immediately. If no
     * connection is available, the pool will attempt to fetch a connection for
     * {@link PoolProperties#maxWait maxWait} milliseconds.
     * 
     * @return Connection - a java.sql.Connection/javax.sql.PooledConnection
     *         reflection proxy, wrapping the underlying object.
     * @throws SQLException
     *             - if the wait times out or a failure occurs creating a
     *             connection
     */
    public Connection getConnection(String username, String password) throws SQLException {
        // check out a connection
        PooledConnection con = borrowConnection(-1, username, password);
        return setupConnection(con);
    }
======= fetch "protected void init(PoolConfiguration properties) throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                initialPool[i] = this.borrowConnection(0); //don't wait, should be no contention
======= fetch "protected void release(PooledConnection con) {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    private PooledConnection borrowConnection(int wait) throws SQLException {
======= fetch "private PooledConnection borrowConnection(int wait) throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                PooledConnection result = borrowConnection(now, con);
======= fetch "private PooledConnection borrowConnection(int wait) throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                    return createConnection(now, con);
======= fetch "private PooledConnection borrowConnection(int wait) throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    protected PooledConnection createConnection(long now,
            PooledConnection notUsed) throws SQLException {
======= fetch "protected PooledConnection createConnection(long now," 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        if (username!=null) con.getAttributes().put(con.PROP_USER, username);
        if (password!=null) con.getAttributes().put(con.PROP_PASSWORD, password);
======= fetch "protected PooledConnection createConnection(long now," 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    protected PooledConnection borrowConnection(long now, PooledConnection con) throws SQLException {
======= fetch "protected PooledConnection borrowConnection(long now, PooledConnection con) thro" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            boolean usercheck = con.checkUser(username, password);
======= fetch "protected PooledConnection borrowConnection(long now, PooledConnection con) thro" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            if ((!con.isDiscarded()) && con.validate(PooledConnection.VALIDATE_BORROW)) {
                //set the timestamp
                con.setTimestamp(now);
                if (getPoolProperties().isLogAbandoned()) {
                    //set the stack trace for this pool
                    con.setStackTrace(getThreadDump());
                }
                if (!busy.offer(con)) {
                    log.debug("Connection doesn't fit into busy array, connection will not be traceable.");
======= fetch "protected PooledConnection borrowConnection(long now, PooledConnection con) thro" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                return con;
======= fetch "protected PooledConnection borrowConnection(long now, PooledConnection con) thro" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            //is either discarded or validation failed.
======= fetch "public Connection get(long timeout, TimeUnit unit) throws InterruptedException," 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                        pc = borrowConnection(System.currentTimeMillis(),pc);
======= fetch "public static PoolConfiguration parsePoolProperties(Properties properties) throw" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        
        value = properties.getProperty(PROP_ALTERNATE_USERNAME_ALLOWED);
        if (value != null) {
            poolProperties.setAlternateUsernameAllowed(Boolean.parseBoolean(value));
        }
        
======= fetch "public Connection getConnection(String username, String password) throws SQLExce" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

        return getConnection();
======= fetch "public String getDataSourceJNDI() {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    /** 
     * {@inheritDoc}
     */
    public boolean isAlternateUsernameAllowed() {
        return getPoolProperties().isAlternateUsernameAllowed();
    }
    /** 
     * {@inheritDoc}
     */
    public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed) {
        getPoolProperties().setAlternateUsernameAllowed(alternateUsernameAllowed);
    }
    /**
     * Returns true if the call {@link DataSource#getConnection(String, String) getConnection(username,password)} is 
     * allowed. This is used for when the pool is used by an application accessing multiple schemas.
     * There is a performance impact turning this option on.
     * @return true if {@link DataSource#getConnection(String, String) getConnection(username,password)} is honored, false if it is ignored.
     */
    public boolean isAlternateUsernameAllowed();
    
    /**
     * Set to true if the call {@link DataSource#getConnection(String, String) getConnection(username,password)} is 
     * allowed and honored.. This is used for when the pool is used by an application accessing multiple schemas.
     * There is a performance impact turning this option on, even when not used due to username checks.
     * @param alternateUsernameAllowed - set true if {@link DataSource#getConnection(String, String) getConnection(username,password)} is honored, 
     * false if it is to be ignored.
     */
    public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed);
    
    protected boolean alternateUsernameAllowed = false;
======= fetch "public static Properties getProperties(String propText, Properties props) {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    
    /** 
     * {@inheritDoc}
     */
    public boolean isAlternateUsernameAllowed() {
        return alternateUsernameAllowed;
    }
    
    /** 
     * {@inheritDoc}
     */
    public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed) {
        this.alternateUsernameAllowed = alternateUsernameAllowed;
    }
    
    public static final String PROP_USER = "user";
    
    public static final String PROP_PASSWORD = "password";
    
======= fetch "public PooledConnection(PoolConfiguration prop, ConnectionPool parent) {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

    public boolean checkUser(String username, String password) {
        if (!getPoolProperties().isAlternateUsernameAllowed()) return true;
        
        if (username==null) username = poolProperties.getUsername();
        if (password==null) password = poolProperties.getPassword();
        
        String storedUsr = (String)getAttributes().get(PROP_USER);
        String storedPwd = (String)getAttributes().get(PROP_PASSWORD);
        
        boolean result = (username==null && storedUsr==null);
        result = (result || (username!=null && username.equals(storedUsr)));
                
        result = result && ((password==null && storedPwd==null) || (password!=null && password.equals(storedPwd)));
        
        if (username==null)  getAttributes().remove(PROP_USER); else getAttributes().put(PROP_USER, username);
        if (password==null)  getAttributes().remove(PROP_PASSWORD); else getAttributes().put(PROP_PASSWORD, password);
        
        return result;
    }
    
======= fetch "protected void connectUsingDataSource() throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        String usr = null;
        String pwd = null;
        if (getAttributes().containsKey(PROP_USER)) {
            usr = (String) getAttributes().get(PROP_USER);
        } else {
            usr = poolProperties.getUsername();
            getAttributes().put(PROP_USER, usr);
        }
        if (getAttributes().containsKey(PROP_PASSWORD)) {
            pwd = (String) getAttributes().get(PROP_PASSWORD);
        } else {
            pwd = poolProperties.getPassword();
            getAttributes().put(PROP_PASSWORD, pwd);
        }
======= fetch "protected void connectUsingDataSource() throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            if (poolProperties.getUsername()!=null && poolProperties.getPassword()!=null) {
                xaConnection = xds.getXAConnection(poolProperties.getUsername(), poolProperties.getPassword());
======= fetch "protected void connectUsingDataSource() throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            if (poolProperties.getUsername()!=null && poolProperties.getPassword()!=null) {
                connection = ds.getConnection(poolProperties.getUsername(), poolProperties.getPassword());
======= fetch "protected void connectUsingDataSource() throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            if (poolProperties.getUsername()!=null && poolProperties.getPassword()!=null) {
                connection = ds.getPooledConnection(poolProperties.getUsername(), poolProperties.getPassword()).getConnection();
======= fetch "protected void connectUsingDriver() throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        String usr = poolProperties.getUsername();
        String pwd = poolProperties.getPassword();
        if (usr != null) {
            poolProperties.getDbProperties().setProperty("user", usr);
======= fetch "protected void connectUsingDriver() throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        if (pwd != null) {
            poolProperties.getDbProperties().setProperty("password", pwd);
======= fetch "protected void connectUsingDriver() throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        
======= fetch "protected void connectUsingDriver() throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            connection = driver.connect(driverURL, poolProperties.getDbProperties());
======= fetch "protected void connectUsingDriver() throws SQLException {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

    private Properties clone(Properties p) {
        Properties c = new Properties();
        c.putAll(p);
        return c;
    }
    
======= fetch "public String getDataSourceJNDI() {" 59b17c1^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    
    /** 
     * {@inheritDoc}
     */
    public boolean isAlternateUsernameAllowed() {
        return getPoolProperties().isAlternateUsernameAllowed();
    }
    
    /** 
     * {@inheritDoc}
     */
    public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed) {
        //noop
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    private static final int iterations = (new Random(System.currentTimeMillis())).nextInt(100000)+1000;
    public AlternateUsernameTest(String name) {
        super(name);
    }
    
    public void testGeneric() throws Exception {
        
        this.init();
        this.datasource.setDriverClassName(Driver.class.getName());
        this.datasource.setUrl("jdbc:tomcat:test");
        this.datasource.setAlternateUsernameAllowed(true);
        this.datasource.getConnection().close();
        int withoutuser =10;
        int withuser = withoutuser;
        TestRunner[] runners = new TestRunner[withuser+withoutuser];
        for (int i=0; i<withuser; i++) {
            TestRunner with = new TestRunner("foo","bar",datasource.getPoolProperties().getUsername(),datasource.getPoolProperties().getPassword());
            TestRunner without = new TestRunner(null,null,datasource.getPoolProperties().getUsername(),datasource.getPoolProperties().getPassword());
            runners[i] = with;
            runners[i+withuser] = without;
        }
        ExecutorService svc = Executors.newFixedThreadPool(withuser+withoutuser);
        List<Future<TestResult>> results =  svc.invokeAll(Arrays.asList(runners));
        int failures = 0;
        int total = 0;
        for (int i=0; i<withuser; i++) {
            failures += results.get(i).get().failures;
            total+=results.get(i).get().iterations;
            failures += results.get(i+withuser).get().failures;
            total+=results.get(i+withuser).get().iterations;
        }
        assertEquals("Nr of failures was:"+failures,0, failures);
        svc.shutdownNow();
        this.datasource.close();
        System.out.println("Nr of connect() calls:"+Driver.connectCount.get());
        System.out.println("Nr of disconnect() calls:"+Driver.disconnectCount.get());
        System.out.println("Nr of iterations:"+total);
    }
    
    public static class TestResult {
        public int iterations;
        public int failures;
        public String lastMessage;
    }
    
    public class TestRunner implements Callable<TestResult> {
        String username;
        String password;
        volatile boolean done = false;
        TestResult result = null;
        boolean useuser = true;
        
        public TestRunner(String user, String pass, String guser, String gpass) {
            username = user==null?guser : user;
            password = pass==null?gpass : pass;
            useuser = user!=null;
        }
        
        public TestResult call() {
            TestResult test = new TestResult();
            PooledConnection pcon = null;
            for (int i=0; (!done) && (i<iterations); i++) {
                test.iterations = i+1;
                try {
                    
                    
                    pcon = useuser ? (PooledConnection)AlternateUsernameTest.this.datasource.getConnection(username, password) :
                                     (PooledConnection)AlternateUsernameTest.this.datasource.getConnection();
                    
                    Connection con = (Connection)pcon.getConnection();
                    
                    assertTrue("Username mismatch: Requested User:"+username+" Actual user:"+con.getUsername(), con.getUsername().equals(username));
                    assertTrue("Password mismatch: Requested Password:"+password+" Actual password:"+con.getPassword(), con.getPassword().equals(password));
                }catch (SQLException x) {
                    test.failures++;
                    test.lastMessage = x.getMessage();
                    done = true;
                    x.printStackTrace();
                }catch (Exception x) {
                    test.failures++;
                    test.lastMessage = x.getMessage();
                    x.printStackTrace();
                } finally {
                    if (pcon!=null) {
                        try {pcon.close(); }catch (Exception ignore) {}
                        pcon = null;
                    }
                }
            }
            done = true;
            result = test;
            return result;
        }
    }
    Properties info;
    
    public Connection(Properties info) {
        this.info = info;
    }
    
    public String getUsername() {
        return info.getProperty(PooledConnection.PROP_USER);
    }
    
    public String getPassword() {
        return info.getProperty(PooledConnection.PROP_PASSWORD);
    }
    
======= fetch "public Connection connect(String url, Properties info) throws SQLException {" 59b17c1^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/driver/Driver.java"

        return new org.apache.tomcat.jdbc.test.driver.Connection();

======= fetch "public String getManagerName(String name, Manager manager) {" 701d5dc^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

                if(host != null && host instanceof Host && clusterName!=null && !(clusterName.indexOf("#")>=0))
======= fetch "public String getManagerName(String name, Manager manager) {" 701d5dc^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

                }
      <fix>
        <bug>50503</bug>: When web application has a version, Engine level 
        Clustering works correctly. (kfujino)
      </fix>

======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" 73531cb^:"java/org/apache/jasper/compiler/Generator.java"

        // Constructor
        // generateConstructor(className);
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" 73531cb^:"java/org/apache/jasper/compiler/Generator.java"

        out.println("(HttpServletRequest request, HttpServletResponse response)");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" 73531cb^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("PageContext pageContext = null;");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" 73531cb^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("ServletContext application = null;");
        out.printil("ServletConfig config = null;");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" 73531cb^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("Object page = this;");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" 73531cb^:"java/org/apache/jasper/compiler/Generator.java"

        out
                .printil("pageContext = _jspxFactory.getPageContext(this, request, response,");

======= fetch "public void load() {" 71ad1bd^:"java/org/apache/catalina/startup/Catalina.java"

        } catch (SAXParseException spe) {
            log.warn("Catalina.start using " + getConfigFile() + ": " +
                    spe.getMessage());
            return;
======= fetch "public void load() {" 71ad1bd^:"java/org/apache/catalina/startup/Catalina.java"

            log.warn("Catalina.start using "
                               + getConfigFile() + ": " , e);
======= fetch "public SAXException createSAXException(String message, Exception e) {" 71ad1bd^:"java/org/apache/tomcat/util/digester/Digester.java"

                    locator.getColumnNumber() + ": " + message;
======= fetch "public void begin(String namespace, String name, Attributes attributes)" 71ad1bd^:"java/org/apache/tomcat/util/digester/ObjectCreateRule.java"

        if (realClassName == null) {
            throw new NullPointerException("No class name specified for " +
                    namespace + " " + name);
        }
======= fetch "public void begin(String namespace, String name, Attributes attributes)" 71ad1bd^:"java/org/apache/tomcat/util/digester/ObjectCreateRule.java"

        <bug>10972</bug>: Improve error message if the className attribute is
        missing on an element in server.xml where it is required. (markt)
      </update>
      <update>

======= fetch "public AuthenticatorBase() {" ca34a30^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

     * Should a session always be used once a user is authenticated? This may
     * offer some performance benefits since the session can then be used to
     * cache the authenticated Principal, hence removing the need to
     * authenticate the user via the Realm on every request. This may be of help
     * for combinations such as BASIC authentication used with the JNDIRealm or
     * DataSourceRealms. However there will also be the performance cost of
     * creating and GC'ing the session. By default, a session will not be
     * created. 
     */
    protected boolean alwaysUseSession = false;
    /**
======= fetch "public void register(Request request, HttpServletResponse response," ca34a30^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

        if (session != null && changeSessionIdOnAuthentication) {
            Manager manager = request.getContext().getManager();
            manager.changeSessionId(session);
            request.changeSessionId(session.getId());

======= fetch "public boolean writeMessage(FileMessage msg)" 5614817^:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

            log.debug("Message " + msg + " data " + msg.getData()
======= fetch "public void dump(String msg) {" 5614817^:"java/org/apache/coyote/ajp/AjpMessage.java"

            log.debug(msg + ": " + buf + " " + pos +"/" + (len + 4));
======= fetch "public static byte getHex(int index){" 5614817^:"java/org/apache/tomcat/util/buf/HexUtils.java"

    public static String toHexString(byte[] bytes)
    {
        if(null == bytes) return null;
        StringBuilder sb = new StringBuilder(bytes.length << 1);
        for(int i=0; i<bytes.length; ++i)
            sb.append(hex[(bytes[i] & 0xf0) >> 4])
                .append(hex[(bytes[i] & 0x0f)])
                ;
        return sb.toString();
    }

    private static final EnableDTDValidationException ENABLE_DTD_VALIDATION_EXCEPTION =
        new EnableDTDValidationException(
            "jsp.error.enable_dtd_validation",
            null);
======= fetch "public void startDTD(String name, String publicId, String systemId)" 345e6b5^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

            fatalError(ENABLE_DTD_VALIDATION_EXCEPTION);
======= fetch "private static SAXParser getSAXParser(" 345e6b5^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        @Override
        public synchronized Throwable fillInStackTrace() {
            // This class does not provide a stack trace
            return this;
        }
======= fetch "public void setRootCause(Throwable e) {/*NOOP*/}" 345e6b5^:"java/org/apache/naming/resources/ImmutableNameNotFoundException.java"

    @Override
    public synchronized Throwable fillInStackTrace() {
        // This class does not provide a stack trace
        return this;
    }

     * Return the creation time for this session, bypassing the session validity
     * checks.
     */
    public long getCreationTimeInternal();
    /**
======= fetch "public long getCreationTime() {" 4117b78^:"java/org/apache/catalina/manager/DummyProxySession.java"

    public long getCreationTimeInternal() {
        return 0;
    }
    @Override
======= fetch "public void remove(Session session, boolean update) {" 4117b78^:"java/org/apache/catalina/session/ManagerBase.java"

            int timeAlive = (int) ((timeNow - session.getCreationTime())/1000);
======= fetch "public long getCreationTime() {" 4117b78^:"java/org/apache/catalina/session/StandardSession.java"

     * Return the time when this session was created, in milliseconds since
     * midnight, January 1, 1970 GMT, bypassing the session validation checks.
     */
    @Override
    public long getCreationTimeInternal() {
        return this.creationTime;
    }
    /**
      <fix>
        <bug>50448</bug>: Fix possible <code>IllegalStateException</code>
        caused by recent session management refactoring. (markt)
      </fix>

======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" 4ed7b7e^:"java/javax/el/CompositeELResolver.java"

                if (resolvers[i] instanceof ScopedAttributeELResolver) {
                    // Special case since this will always return Object.class
                    Object value =
                        resolvers[i].getValue(context, base, property);
                    if (value != null) {
                        return value.getClass();
                    }
                }
    public void testBug50408() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir =  new File("test/webapp-3.0");
        // app dir is relative to server home
        StandardContext ctxt = (StandardContext) tomcat.addWebapp(null,
                "/test", appDir.getAbsolutePath());
        
        // This test needs the JSTL libraries
        File lib = new File("webapps/examples/WEB-INF/lib");
        ctxt.setAliases("/WEB-INF/lib=" + lib.getCanonicalPath());
        
        tomcat.start();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug50408.jsp", new ByteChunk(), null);
        
        assertEquals(HttpServletResponse.SC_OK, rc);
    }
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <body>
    <c:forEach items="${pageContext.response.headerNames}" var="name">
      <c:forEach items="${pageContext.response.getHeaders(name)}" var="value">
        <p>${name} : ${value}</p>
      </c:forEach>
    </c:forEach>
  </body>
  <subsection name="Jasper">
    <changelog>
      <fix>
        <bug>50408</bug>: Fix <code>NoSuchMethodException</code> when using
        scoped variables with EL method invocation. (markt)
      </fix>
    </changelog>
  </subsection>

 * Implementation of a Coyote connector for Tomcat 5.x.
======= fetch "public Connector(String protocol) {" e34b164^:"java/org/apache/catalina/connector/Connector.java"

    protected String parseBodyMethods = "POST";
    protected HashSet parseBodyMethodsSet;
======= fetch "public void setMaxSavePostSize(int maxSavePostSize) {" e34b164^:"java/org/apache/catalina/connector/Connector.java"

    public String getParseBodyMethods()
    {
        return (this.parseBodyMethods);
    }
    public void setParseBodyMethods(String methods)
    {
        HashSet methodSet = new HashSet();
        if(null != methods)
            methodSet.addAll(Arrays.asList(methods.split("\\s*,\\s*")));
        if(methodSet.contains("TRACE"))
            throw new IllegalArgumentException("TRACE method MUST NOT include an entity (see RFC 2616 Section 9.6)");
        this.parseBodyMethods = methods;
        this.parseBodyMethodsSet = methodSet;
    }
    public boolean isParseBodyMethod(String method)
    {
        return parseBodyMethodsSet.contains(method);
    }
======= fetch "protected void initInternal() throws LifecycleException {" e34b164^:"java/org/apache/catalina/connector/Connector.java"

        // Make sure parseBodyMethodsSet has a default
        if(null == parseBodyMethodsSet)
            setParseBodyMethods(getParseBodyMethods());
======= fetch "protected void parseParameters() {" e34b164^:"java/org/apache/catalina/connector/Request.java"

        if (!getMethod().equalsIgnoreCase("POST"))
======= fetch "public void testBug49424WithChunking() throws Exception {" e34b164^:"test/org/apache/catalina/connector/TestRequest.java"

    /**
     * Test case for https://issues.apache.org/bugzilla/show_bug.cgi?id=48692
     * PUT requests should be able to fetch request parameters coming from
     * the request body (when properly configured using the new parseBodyMethod
     * setting).
     */
    public void testBug48692() {
        Bug48692Client client = new Bug48692Client();
        client.setPort(getPort());
        // Make sure GET works properly
        client.doRequest("GET", "foo=bar", null, null, false);
        assertTrue("Non-200 response for GET request",
                   client.isResponse200());
        assertEquals("Incorrect response for GET request",
                     "foo=bar",
                     client.getResponseBody());
        client.reset();
        //
        // Make sure POST works properly
        //
        // POST with separate GET and POST parameters
        client.doRequest("POST", "foo=bar", "application/x-www-form-urlencoded", "bar=baz", true);
        assertTrue("Non-200 response for POST request",
                   client.isResponse200());
        assertEquals("Incorrect response for POST request",
                     "bar=baz,foo=bar",
                     client.getResponseBody());
        client.reset();
        // POST with overlapping GET and POST parameters
        client.doRequest("POST", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", true);
        assertTrue("Non-200 response for POST request",
                   client.isResponse200());
        assertEquals("Incorrect response for POST request",
                     "bar=baz,bar=foo,foo=bar,foo=baz",
                     client.getResponseBody());
        client.reset();
        // PUT without POST-style parsing
        client.doRequest("PUT", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", false);
        assertTrue("Non-200 response for PUT/noparse request",
                   client.isResponse200());
        assertEquals("Incorrect response for PUT request",
                     "bar=foo,foo=bar",
                     client.getResponseBody());
        client.reset();
        // PUT with POST-style parsing
        client.doRequest("PUT", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", true);
        assertTrue("Non-200 response for PUT request",
                   client.isResponse200());
        assertEquals("Incorrect response for PUT/parse request",
                     "bar=baz,bar=foo,foo=bar,foo=baz",
                     client.getResponseBody());
        client.reset();
        /*
        private Exception doRequest(String method,
                                    String queryString,
                                    String contentType,
                                    String requestBody,
                                    boolean allowBody) {
        */
    }
    /**
     *
     */
    private static class EchoParametersServlet extends HttpServlet {
        
        private static final long serialVersionUID = 1L;
        /**
         * Only interested in the parameters and values for requests.
         * Note: echos parameters in alphabetical order.
         */
        @Override
        protected void service(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
            // Just echo the parameters and values back as plain text
            resp.setContentType("text/plain");
            resp.setCharacterEncoding("UTF-8");
            PrintWriter out = resp.getWriter();
            
            TreeMap<String,String[]> parameters = new TreeMap<String,String[]>(req.getParameterMap());
            boolean first = true;
            
            for(String name: parameters.keySet()) {
                String[] values = req.getParameterValues(name);
                java.util.Arrays.sort(values);
                for(int i=0; i<values.length; ++i)
                {
                    if(first)
                        first = false;
                    else
                        out.print(",");
                    out.print(name + "=" + values[i]);
                }
            }
        }
    }
    /**
     * Bug 48692 test client: test for allowing PUT request bodies.
     */
    private class Bug48692Client extends SimpleHttpClient {
        private boolean init;
        
        private synchronized void init() throws Exception {
            if (init) return;
            
            Tomcat tomcat = getTomcatInstance();
            Context root = tomcat.addContext("", TEMP_DIR);
            Tomcat.addServlet(root, "EchoParameters", new EchoParametersServlet());
            root.addServletMapping("/echo", "EchoParameters");
            tomcat.start();
            
            init = true;
        }
        
        private Exception doRequest(String method,
                                    String queryString,
                                    String contentType,
                                    String requestBody,
                                    boolean allowBody) {
            Tomcat tomcat = getTomcatInstance();
            
            try {
                init();
                if(allowBody)
                    tomcat.getConnector().setParseBodyMethods(method);
                else
                    tomcat.getConnector().setParseBodyMethods(""); // never parse
                // Open connection
                connect();
                // Re-encode the request body so that bytes = characters
                if(null != requestBody)
                    requestBody = new String(requestBody.getBytes("UTF-8"), "ASCII");
                // Send specified request body using method
                String[] request = {
                    (
                     method + " http://localhost:" + getPort() + "/echo"
                     + (null == queryString ? "" : ("?" + queryString))
                     + " HTTP/1.1" + CRLF
                     + "Host: localhost" + CRLF
                     + (null == contentType ? ""
                        : ("Content-Type: " + contentType + CRLF))
                     + "Connection: close" + CRLF
                     + (null == requestBody ? "" : "Content-Length: " + requestBody.length() + CRLF)
                     + CRLF
                     + (null == requestBody ? "" : requestBody)
                     )
                };
                setRequest(request);
                processRequest(); // blocks until response has been read
                
                // Close the connection
                disconnect();
            } catch (Exception e) {
                return e;
            }
            return null;
        }
        @Override
        public boolean isResponseBodyOK() {
            return false; // Don't care
        }
    }
    <author email="schultz@apache.org">Christopher Schultz</author>
      <update>
        <bug>48692</bug>: Provide option to parse
        <code>application/x-www-form-urlencoded</code> PUT requests. (schultz)
      </update>
    <attribute name="parseBodyMethods" required="false">
      <p>A comma-separated list of HTTP methods for which request
      bodies will be parsed for request parameters identically
      to POST. This is useful in RESTful applications that want to
      support POST-style semantics for PUT requests.
      Note that any setting other than <code>POST</code> causes Tomcat
      to behave in a way that violates the servlet specification.
      The HTTP method TRACE is specifically forbidden here in accordance
      with the HTTP specification.
      The default is <code>POST</code></p>
    </attribute>
    <attribute name="parseBodyMethods" required="false">
      <p>A comma-separated list of HTTP methods for which request
      bodies will be parsed for request parameters identically
      to POST. This is useful in RESTful applications that want to
      support POST-style semantics for PUT requests.
      Note that any setting other than <code>POST</code> causes Tomcat
      to behave in a way that violates the servlet specification.
      The HTTP method TRACE is specifically forbidden here in accordance
      with the HTTP specification.
      The default is <code>POST</code></p>
    </attribute>

======= fetch "protected void stopInternal() throws LifecycleException {" 07b72f1^:"java/org/apache/catalina/startup/Embedded.java"

        setState(LifecycleState.STARTING);

    /* The name to which the object is being bound or unbound */
 //-------------------------------------
    implements HttpSession, Session, Serializable {
======= fetch "public String toString() {" 4cbb52f^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        private static final long serialVersionUID = 1L;
    private static final long serialVersionUID = 1L;
    private static final long serialVersionUID = 1L;
    //--------------------------------------------------------------------------
    //              CONSTRUCTORS / DESTRUCTORS
    //--------------------------------------------------------------------------
======= fetch "public static ExecutorService newThreadPool(int minThreads, int maxThreads, long" 4cbb52f^:"java/org/apache/catalina/tribes/util/ExecutorFactory.java"

    // ----------------------------------------------------------- Constructors
======= fetch "private static SAXParser getSAXParser(" 4cbb52f^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        extends SAXParseException {
    extends Reference {
    extends Reference {
    extends Reference {
    extends Reference {
    extends Reference {
    extends Reference {
======= fetch "public void run() {" 4cbb52f^:"test/org/apache/catalina/tribes/demos/MapDemo.java"

    public static class SimpleTableDemo
        extends JPanel implements ActionListener{
======= fetch "public void run() {" 4cbb52f^:"test/org/apache/catalina/tribes/demos/MapDemo.java"

            private static final long serialVersionUID = 1L;
======= fetch "public static SimpleTableDemo createAndShowGUI(LazyReplicatedMap map, String tit" 4cbb52f^:"test/org/apache/catalina/tribes/demos/MapDemo.java"

        private static final long serialVersionUID = 1L;
    private static final long serialVersionUID = 1L;

======= fetch "private void clearReferencesThreads() {" ddbbfc1^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                if (ccl != null && ccl == this) {
======= fetch "private void clearThreadLocalMap(Object map, Field internalTableField)" ddbbfc1^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                        if (this.equals(key) || (key != null &&
                                this == key.getClass().getClassLoader())) {
======= fetch "private void clearThreadLocalMap(Object map, Field internalTableField)" ddbbfc1^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                        if (this.equals(value) || (value != null &&
                                this == value.getClass().getClassLoader())) {
======= fetch "private void clearThreadLocalMap(Object map, Field internalTableField)" ddbbfc1^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                args[1] = key.getClass().getCanonicalName();
======= fetch "private void clearThreadLocalMap(Object map, Field internalTableField)" ddbbfc1^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                args[3] = value.getClass().getCanonicalName();
======= fetch "private void clearThreadLocalMap(Object map, Field internalTableField)" ddbbfc1^:"java/org/apache/catalina/loader/WebappClassLoader.java"

    private String getPrettyClassName(Class<?> clazz) {
        String name = clazz.getCanonicalName();
        if (name==null){
            name = clazz.getName();
        }
        return name;
    }
    
    /**
     * @param o object to test
     * @return <code>true</code> if o has been loaded by the current classloader
     * or one of its descendants.
     */
    private boolean isLoadedByThisWebAppClassLoader(Object o) {
        if (o == null) {
            return false;
        }
        ClassLoader cl = o.getClass().getClassLoader();
        while (cl != null) {
            if(cl == this) {
                return true;
            }
            cl = cl.getParent();
        }
        return false;
    }
        
      <add>
        <bug>48837</bug>: Extend thread local memory leak detection to include
        classes loaded by subordinate class loaders to the web
        application&apos;s class loader such as the Jasper class loader. Based
        on a patch by Sylvain Laurent. (markt)
      </add>

======= fetch "public String getName() {" 5a84fdb^:"java/org/apache/coyote/ajp/AbstractAjpProtocol.java"

    public int getMinSpareThreads() { return endpoint.getMinSpareThreads(); }
    public void setMinSpareThreads(int minSpareThreads) { endpoint.setMinSpareThreads(minSpareThreads); }
======= fetch "public void setMaxTrailerSize(int maxTrailerSize) {" 5a84fdb^:"java/org/apache/coyote/http11/AbstractHttp11Protocol.java"

    public int getMinSpareThreads() { return endpoint.getMinSpareThreads(); }
    public void setMinSpareThreads(int minSpareThreads) { endpoint.setMinSpareThreads(minSpareThreads); }
  <subsection name="Coyote">
    <changelog>
      <add>
        <bug>50108</bug>: Add get/set methods for Connector property
        minSpareThreads. Patch provided by Eiji Takahashi. (markt)
      </add>
    </changelog>
  </subsection>

======= fetch "public SocketState event(NioChannel socket, SocketStatus status) {" 46e7d1e^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

                    if (state != SocketState.LONG && state != SocketState.ASYNC_END) {
======= fetch "public SocketState event(NioChannel socket, SocketStatus status) {" 46e7d1e^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

                    } else if (state == SocketState.ASYNC_END) {
                        // No further work required
======= fetch "public SocketState event(NioChannel socket, SocketStatus status) {" 46e7d1e^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

                        att.setAsync(true); // Re-enable timeouts
======= fetch "public SocketState event(NioChannel socket, SocketStatus status) {" 46e7d1e^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

                        if (log.isDebugEnabled()) log.debug("Keeping processor["+processor);
                        //add correct poller events here based on Comet stuff
                        socket.getPoller().add(socket,att.getCometOps());
======= fetch "protected void timeout(int keyCount, boolean hasEvents) {" 46e7d1e^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                    }else if ((ka.interestOps()&SelectionKey.OP_READ) == SelectionKey.OP_READ ||
======= fetch "protected void timeout(int keyCount, boolean hasEvents) {" 46e7d1e^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                    }else if (ka.isAsync()) {

======= fetch "public static String secondsToTimeString(long in_seconds) {" 278a36a^:"java/org/apache/catalina/manager/JspHelper.java"

        if (in_seconds < 0) {
            buff.append('-');
            in_seconds = -in_seconds;
        }
======= fetch "public static String formatSize(Object obj, boolean mb) {" 278a36a^:"java/org/apache/catalina/manager/StatusTransformer.java"

            StringBuilder buff = new StringBuilder();
            if (bytes < 0) {
                buff.append('-');
                bytes = -bytes;
            }
======= fetch "public static String formatSize(Object obj, boolean mb) {" 278a36a^:"java/org/apache/catalina/manager/StatusTransformer.java"

            return (mbytes + "." + ((rest < 10) ? "0" : "") + rest + " MB");

======= fetch "public synchronized boolean asyncDispatch() {" 991702c^:"java/org/apache/coyote/AsyncStateMachine.java"

        } else if (state == AsyncState.STARTED) {
======= fetch "public void testTimeoutListenerComplete() throws Exception {" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        doTestTimeout(true);
======= fetch "public void testTimeoutListenerNoComplete() throws Exception {" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        doTestTimeout(false);
======= fetch "public void testTimeoutListenerNoComplete() throws Exception {" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    private void doTestTimeout(boolean completeOnTimeout) throws Exception {
======= fetch "private void doTestTimeout(boolean completeOnTimeout) throws Exception {" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TimeoutServlet timeout = new TimeoutServlet(completeOnTimeout);
======= fetch "private void doTestTimeout(boolean completeOnTimeout) throws Exception {" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        if (dispatchUrl != null) {
            NonAsyncServlet nonAsync = new NonAsyncServlet();
            Tomcat.addServlet(ctx, "nonasync", nonAsync);
            ctx.addServletMapping(dispatchUrl, "nonasync");
        }
======= fetch "private void doTestTimeout(boolean completeOnTimeout) throws Exception {" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        expected.append("onComplete-");
======= fetch "private void doTestTimeout(boolean completeOnTimeout) throws Exception {" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        
        public TimeoutServlet(boolean completeOnTimeout) {
======= fetch "public TimeoutServlet(boolean completeOnTimeout) {" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

            this.dispatchUrl = dispatchUrl;
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                ac.addListener(new TrackingListener(false, completeOnTimeout));
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                    new TrackingListener(completeOnError, true); 
======= fetch "public void testListeners() throws Exception {" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TimeoutServlet timeout = new TimeoutServlet(true);
======= fetch "protected void doGet(HttpServletRequest req, HttpServletResponse resp)" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

            TrackingListener listener = new TrackingListener(false, true); 
======= fetch "public void run() {" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        private String dispatchUrl;
======= fetch "public TrackingListener(boolean completeOnError," 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                boolean completeOnTimeout) {
======= fetch "public TrackingListener(boolean completeOnError," 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

            this.dispatchUrl = dispatchUrl;
======= fetch "public void onTimeout(AsyncEvent event) throws IOException {" 991702c^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                event.getAsyncContext().complete();

======= fetch "private String getWebModuleKeyProperties() {" ade20d2^:"java/org/apache/catalina/core/StandardWrapper.java"

        StringBuilder keyProperties = new StringBuilder(",WebModule=");

======= fetch "public CompositeELResolver() {" 7b89af8^:"java/javax/el/CompositeELResolver.java"

        this.resolvers = new ELResolver[2];

======= fetch "public ValueExpression setVariable(String variable," e075c4b^:"java/org/apache/jasper/el/ELContextImpl.java"

    private FunctionMapper functionMapper;
======= fetch "public ELContextImpl() {" e075c4b^:"java/org/apache/jasper/el/ELContextImpl.java"

        if (Constants.IS_SECURITY_ENABLED) {
            functionMapper = new FunctionMapper() {
                @Override
                public Method resolveFunction(String prefix, String localName) {
                    return null;
                }
            };
        } else {
            functionMapper = NullFunctionMapper;
        }
    private final static ELResolver DefaultResolver = new CompositeELResolver();
        ((CompositeELResolver) DefaultResolver).add(new MapELResolver());
        ((CompositeELResolver) DefaultResolver).add(new ResourceBundleELResolver());
        ((CompositeELResolver) DefaultResolver).add(new ListELResolver());
        ((CompositeELResolver) DefaultResolver).add(new ArrayELResolver());
        ((CompositeELResolver) DefaultResolver).add(new BeanELResolver());
======= fetch "public ELResolverImpl(VariableResolver variableResolver) {" e075c4b^:"java/org/apache/jasper/el/ELResolverImpl.java"

        this.elResolver = getDefaultResolver();
======= fetch "public Object getValue(ELContext context, Object base, Object property)" e075c4b^:"java/org/apache/jasper/el/ELResolverImpl.java"

            return getDefaultResolver().getValue(context, base, property);
======= fetch "public Object getValue(ELContext context, Object base, Object property)" e075c4b^:"java/org/apache/jasper/el/ELResolverImpl.java"

            return getDefaultResolver().getType(context, base, property);
======= fetch "public void setValue(ELContext context, Object base, Object property," e075c4b^:"java/org/apache/jasper/el/ELResolverImpl.java"

            getDefaultResolver().setValue(context, base, property, value);
======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" e075c4b^:"java/org/apache/jasper/el/ELResolverImpl.java"

        return getDefaultResolver().isReadOnly(context, base, property);
======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" e075c4b^:"java/org/apache/jasper/el/ELResolverImpl.java"

        return getDefaultResolver().getFeatureDescriptors(context, base);
======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" e075c4b^:"java/org/apache/jasper/el/ELResolverImpl.java"

        return getDefaultResolver().getCommonPropertyType(context, base);

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Interface implemented by session managers that do not keep a complete copy
 * of all sessions on the local node but do know where every session is. The
 * BackupManager is an example of such a Manager. Sessions can be primary
 * (master copy on this node), backup (backup copy on this node) or proxy (only
 * the session ID on this node). The identity of the primary and backup nodes
 * are known for all sessions, including proxy sessions.
 */
    /**
     * Returns the total session count for primary, backup and proxy.
     * 
     * @return  The total session count across the cluster.
     */
    public int getActiveSessionsFull();
    /**
     * Returns the list of all sessions IDS (primary, backup and proxy).
     * 
     * @return  The complete set of sessions IDs across the cluster.
     */
    public Set<String> getSessionIdsFull();
        implements MapOwner, DistributedManager {
======= fetch "public ClusterManager cloneFromTemplate() {" 96020cb^:"java/org/apache/catalina/ha/session/BackupManager.java"

    @Override
======= fetch "public int getActiveSessionsFull() {" 96020cb^:"java/org/apache/catalina/ha/session/BackupManager.java"

    public String listSessionIdsFull() {
        StringBuilder sb=new StringBuilder();
        LazyReplicatedMap map = (LazyReplicatedMap)sessions;
        @SuppressWarnings("unchecked") // sessions is of type Map<String, Session>
        Iterator<String> keys = map.keySetFull().iterator();
        while (keys.hasNext()) {
            sb.append(keys.next()).append(" ");
        }
        return sb.toString();
    }
    
======= fetch "public void list(HttpServletRequest request," 96020cb^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                if (manager instanceof BackupManager && showProxySessions) {
======= fetch "public void list(HttpServletRequest request," 96020cb^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                            ((BackupManager)manager).getActiveSessionsFull());
======= fetch "protected void doSessions(String path, HttpServletRequest req," 96020cb^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        if (manager instanceof BackupManager && showProxySessions) {
======= fetch "protected void doSessions(String path, HttpServletRequest req," 96020cb^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                ((BackupManager) manager).getSessionIdsFull();

======= fetch "protected Object lookup(Name name, boolean resolveLinks)" 7e7283d^:"java/org/apache/naming/NamingContext.java"

                    boolean singleton = Boolean.parseBoolean(
                            (String) ((ResourceRef) entry.value).get(
                                    "singleton").getContent());
                    if (singleton) {
                        entry.type = NamingEntry.ENTRY;
                        entry.value = obj;

======= fetch "public void listen() throws Exception {" 84efb0a^:"java/org/apache/catalina/tribes/transport/bio/BioReceiver.java"

            getExecutor().execute(task);
======= fetch "public synchronized void run()" 84efb0a^:"java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java"

            log.error("Unable to service bio socket");
======= fetch "public synchronized void serviceSocket(Socket socket, ObjectReader reader) {" 84efb0a^:"java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java"

        this.notify();      // awaken the thread
        (markt))

======= fetch "public void addWelcomeFile(String name) {" 476921f^:"java/org/apache/catalina/core/StandardContext.java"

        fireContainerEvent(ADD_WELCOME_FILE_EVENT, name);
======= fetch "public void removeWelcomeFile(String name) {" 476921f^:"java/org/apache/catalina/core/StandardContext.java"

        fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name);
======= fetch "public void addMapping(String mapping) {" 476921f^:"java/org/apache/catalina/core/StandardWrapper.java"

        fireContainerEvent(ADD_MAPPING_EVENT, mapping);
======= fetch "public void removeMapping(String mapping) {" 476921f^:"java/org/apache/catalina/core/StandardWrapper.java"

        fireContainerEvent(REMOVE_MAPPING_EVENT, mapping);

======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 4ca3db3^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

            /*
             * Several components end up calling:
             * sun.awt.AppContext.getAppContext()
             * 
             * Those libraries / components known to trigger memory leaks due to
             * eventual calls to getAppContext() are:
             * - Google Web Toolkit via its use of javax.imageio
             * - Tomcat via its use of java.beans.Introspector.flushCaches() in
             *   1.6.0_15 onwards
             * - others TBD
             */
            
            // Trigger a call to sun.awt.AppContext.getAppContext(). This will
            // pin the common class loader in memory but that shouldn't be an
            // issue.
            if (appContextProtection) {
                ImageIO.getCacheDirectory();
            }
            
            /*
             * Several components end up calling:
             * sun.misc.GC.requestLatency(long)
             * 
             * Those libraries / components known to trigger memory leaks due to
             * eventual calls to requestLatency(long) are:
             * - javax.management.remote.rmi.RMIConnectorServer.start()
             */
            if (gcDaemonProtection) {
                try {
                    Class<?> clazz = Class.forName("sun.misc.GC");
                    Method method = clazz.getDeclaredMethod("requestLatency",
                            new Class[] {long.class});
                    method.invoke(null, Long.valueOf(3600000));
                } catch (ClassNotFoundException e) {
                    if (System.getProperty("java.vendor").startsWith("Sun")) {
                        log.error(sm.getString(
                                "jreLeakListener.gcDaemonFail"), e);
                    } else {
                        log.debug(sm.getString(
                                "jreLeakListener.gcDaemonFail"), e);
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 4ca3db3^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

                } catch (SecurityException e) {
                    log.error(sm.getString("jreLeakListener.gcDaemonFail"), e);
                } catch (NoSuchMethodException e) {
                    log.error(sm.getString("jreLeakListener.gcDaemonFail"), e);
                } catch (IllegalArgumentException e) {
                    log.error(sm.getString("jreLeakListener.gcDaemonFail"), e);
                } catch (IllegalAccessException e) {
                    log.error(sm.getString("jreLeakListener.gcDaemonFail"), e);
                } catch (InvocationTargetException e) {
                    log.error(sm.getString("jreLeakListener.gcDaemonFail"), e);
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 4ca3db3^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

            }
            /*
             * When a servlet opens a connection using a URL it will use
             * sun.net.www.http.HttpClient which keeps a static reference to a
             * keep-alive cache which is loaded using the web application class
             * loader.
             */
            if (keepAliveProtection) {
                try {
                    Class.forName("sun.net.www.http.HttpClient");
                } catch (ClassNotFoundException e) {
                    if (System.getProperty("java.vendor").startsWith("Sun")) {
                        log.error(sm.getString(
                                "jreLeakListener.keepAliveFail"), e);
                    } else {
                        log.debug(sm.getString(
                                "jreLeakListener.keepAliveFail"), e);
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 4ca3db3^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

            }
            
            /*
             * Calling getPolicy retains a static reference to the context class
             * loader.
             */
            if (securityPolicyProtection) {
                try {
                    // Policy.getPolicy();
                    Class<?> policyClass = Class
                            .forName("javax.security.auth.Policy");
                    Method method = policyClass.getMethod("getPolicy");
                    method.invoke(null);
                } catch(ClassNotFoundException e) {
                    // Ignore. The class is deprecated.
                } catch(SecurityException e) {
                    // Ignore. Don't need call to getPolicy() to be successful,
                    // just need to trigger static initializer.
                } catch (NoSuchMethodException e) {
                    log.warn(sm.getString("jreLeakListener.authPolicyFail"), e);
                } catch (IllegalArgumentException e) {
                    log.warn(sm.getString("jreLeakListener.authPolicyFail"), e);
                } catch (IllegalAccessException e) {
                    log.warn(sm.getString("jreLeakListener.authPolicyFail"), e);
                } catch (InvocationTargetException e) {
                    log.warn(sm.getString("jreLeakListener.authPolicyFail"), e);
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 4ca3db3^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

            }
            /*
             * Creating a MessageDigest during web application startup
             * initializes the Java Cryptography Architecture. Under certain
             * conditions this starts a Token poller thread with TCCL equal
             * to the web application class loader.
             * 
             * Instead we initialize JCA right now.
             */
            if (tokenPollerProtection) {
                java.security.Security.getProviders();
            }
            
            /*
             * Several components end up opening JarURLConnections without first
             * disabling caching. This effectively locks the file. Whilst more
             * noticeable and harder to ignore on Windows, it affects all
             * operating systems.
             * 
             * Those libraries/components known to trigger this issue include:
             * - log4j versions 1.2.15 and earlier
             * - javax.xml.bind.JAXBContext.newInstance()
             */
            
            // Set the default URL caching policy to not to cache
            if (urlCacheProtection) {
                try {
                    // Doesn't matter that this JAR doesn't exist - just as long as
                    // the URL is well-formed
                    URL url = new URL("jar:file://dummy.jar!/");
                    URLConnection uConn = url.openConnection();
                    uConn.setDefaultUseCaches(false);
                } catch (MalformedURLException e) {
                    log.error(sm.getString(
                            "jreLeakListener.jarUrlConnCacheFail"), e);
                } catch (IOException e) {
                    log.error(sm.getString(
                            "jreLeakListener.jarUrlConnCacheFail"), e);
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 4ca3db3^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

            }
            
            /*
             * Haven't got to the root of what is going on with this leak but if
             * a web app is the first to make the calls below the web
             * application class loader will be pinned in memory.
             */
            if (xmlParsingProtection) {
                DocumentBuilderFactory factory =
                    DocumentBuilderFactory.newInstance();
                try {
                    factory.newDocumentBuilder();
                } catch (ParserConfigurationException e) {
                    log.error(sm.getString("jreLeakListener.xmlParseFail"), e);
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 4ca3db3^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

                
                /*
                 * Haven't got to the root of what is going on with this leak
                 * but if a web app is the first to make the calls below the web
                 * application class loader will be pinned in memory.
                 */
                if (xmlParsingProtection) {
                    DocumentBuilderFactory factory =
                        DocumentBuilderFactory.newInstance();
                    try {
                        factory.newDocumentBuilder();
                    } catch (ParserConfigurationException e) {
                        log.error(sm.getString("jreLeakListener.xmlParseFail"),
                                e);
                    }
                }
            } finally {
                Thread.currentThread().setContextClassLoader(loader);
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 4ca3db3^:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

      <add>
        <bug>50222</bug>: Modify memory leak prevention code so it pins the
        system class loader in memory rather than than the common class loader,
        which is better for embedded systems. Patch provided by Christopher
        Schultz. (markt) 
      </add>

    
======= fetch "public void messageReceived(Serializable msg, Member sender) {" afdc055^:"java/org/apache/catalina/tribes/group/RpcChannel.java"

                channel.send(new Member[] {sender}, rmsg,0);
======= fetch "public void setRpcId(byte[] rpcId) {" afdc055^:"java/org/apache/catalina/tribes/group/RpcChannel.java"

    public int getReplyMessageOptions() {
        return replyMessageOptions;
    }
======= fetch "public void setRpcId(byte[] rpcId) {" afdc055^:"java/org/apache/catalina/tribes/group/RpcChannel.java"

    public void setReplyMessageOptions(int replyMessageOptions) {
        this.replyMessageOptions = replyMessageOptions;
    }
        
      <fix>
        <bug>50184</bug>: Add an option to the RpcChannel to enable the Channel
        send options to be set for the reply message. Based on a patch by Ariel.
        (markt))
      </fix>

======= fetch "public void processExpires() {" b5c24f9^:"java/org/apache/catalina/session/StoreBase.java"

                if ( ( (PersistentManagerBase) manager).isLoaded( keys[i] )) {

 * |  |       FAILED ---->------ DESTROYED ----<-----------------  |
 * |  |                             ^                              |
 * |  |        destroy()            |                              |
 * |  -------------------------------                              |
     * The LifecycleEvent type for the "component destroy" event.
    public static final String DESTROY_EVENT = "destroy";
    DESTROYED(false, Lifecycle.DESTROY_EVENT),
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 6eae969^:"java/org/apache/catalina/core/AprLifecycleListener.java"

        } else if (Lifecycle.DESTROY_EVENT.equals(event.getType())) {
======= fetch "public void removeChild(Container child) {" 6eae969^:"java/org/apache/catalina/core/ContainerBase.java"

            child.destroy();
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 6eae969^:"java/org/apache/catalina/startup/ContextConfig.java"

        } else if (event.getType().equals(Lifecycle.DESTROY_EVENT)) {
======= fetch "public synchronized final void destroy() throws LifecycleException {" 6eae969^:"java/org/apache/catalina/util/LifecycleBase.java"

        if (LifecycleState.DESTROYED.equals(state)) {
======= fetch "public synchronized final void destroy() throws LifecycleException {" 6eae969^:"java/org/apache/catalina/util/LifecycleBase.java"

            invalidTransition(Lifecycle.DESTROY_EVENT);
======= fetch "public synchronized final void destroy() throws LifecycleException {" 6eae969^:"java/org/apache/catalina/util/LifecycleBase.java"

        setState(LifecycleState.DESTROYING);
        
      <fix>
        <bug>50168</bug>: Separate the <code>Lifecycle.DESTROY_EVENT</code> into
        <code>Lifecycle.BEFORE_DESTROY_EVENT</code> and
        <code>Lifecycle.AFTER_DESTROY_EVENT</code>. Use the additional state to
        ensure that <code>Context</code> objects are only destroyed once.
        (markt)
      </fix>

======= fetch "public SimpleTcpCluster() {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

        // NO-OP
======= fetch "public SimpleTcpCluster() {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void setHeartbeatBackgroundEnabled(boolean heartbeatBackgroundEnabled) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void setClusterName(String clusterName) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public String getClusterName() {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void setContainer(Container container) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public String getManagerClassName() {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    public void setManagerClassName(String managerClassName) {
        log.warn("setManagerClassName is deprecated, use nested <Manager> element inside the <Cluster> element instead, this request will be ignored.");
======= fetch "public void setManagerClassName(String managerClassName) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void addValve(Valve valve) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void addValve(Valve valve) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void addClusterListener(ClusterListener listener) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void removeClusterListener(ClusterListener listener) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void removeClusterListener(ClusterListener listener) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void setClusterDeployer(" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void setChannelSendOptions(int channelSendOptions) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public boolean hasMembers() {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public boolean hasMembers() {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public boolean setProperty(String name, String value) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public boolean setProperty(String name, Object value) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public Object getProperty(String key) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public Object getProperty(String key) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "protected void transferProperty(String prefix, Object bean) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "protected void transferProperty(String prefix, Object bean) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public int getChannelSendOptions() {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public synchronized Manager createManager(String name) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void removeManager(Manager manager) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public String getManagerName(String name, Manager manager) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public Manager getManager(String name) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void backgroundProcess() {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "protected void registerClusterValve() throws Exception {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

                    valve.setCluster(this);
======= fetch "protected void registerClusterValve() throws Exception {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

                valve.setCluster(this);
======= fetch "protected void unregisterClusterValve() throws Exception {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

                    IntrospectionUtils.callMethodN(getContainer(), "removeValve",
                        new Object[] { valve }, new Class[] { org.apache.catalina.Valve.class });
======= fetch "protected void unregisterClusterValve() throws Exception {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

            valve.setCluster(this);
======= fetch "public String toString() {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void send(ClusterMessage msg) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void send(ClusterMessage msg) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void memberAdded(Member member) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void memberDisappeared(Member member) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public boolean accept(Serializable msg, Member sender) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void messageReceived(ClusterMessage message) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

            for (Iterator<ClusterListener> iter = clusterListeners.iterator(); iter.hasNext();) {
======= fetch "public void messageReceived(ClusterMessage message) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

        }
        if (!accepted && log.isDebugEnabled()) {
            if (notifyLifecycleListenerOnFailure) {
======= fetch "public void messageReceived(ClusterMessage message) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

                if (log.isDebugEnabled()) {
                    log.debug("Message " + message.toString() + " from type "
                            + message.getClass().getName()
                            + " transfered but no listener registered");
                }
======= fetch "public void messageReceived(ClusterMessage message) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

            log.debug("Message " + message.toString() + " from type "
                    + message.getClass().getName()
                    + " transfered but no listener registered");
======= fetch "public void messageReceived(ClusterMessage message) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public Log getLogger() {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= fetch "public void setProtocol(String protocol) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

        // NO-OP
======= fetch "public void setProtocol(String protocol) {" f77368f^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override

======= fetch "public FileHandler(String directory, String prefix, String suffix) {" 7184011^:"java/org/apache/juli/FileHandler.java"

     * Determines whether the logfile is rotatable
     */
    private boolean rotatable = true;
    /**
======= fetch "public void publish(LogRecord record) {" 7184011^:"java/org/apache/juli/FileHandler.java"

        if (!date.equals(tsDate)) {
======= fetch "private void configure() {" 7184011^:"java/org/apache/juli/FileHandler.java"

        rotatable = Boolean.parseBoolean(getProperty(className + ".rotatable", "true"));
======= fetch "protected void openWriter() {" 7184011^:"java/org/apache/juli/FileHandler.java"

                prefix + date + suffix;

======= fetch "public void init() {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

        engine.addContainerListener(this);
======= fetch "public void init() {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

                host.addLifecycleListener(this);
======= fetch "public void destroy() {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

    @Override
======= fetch "public void containerEvent(ContainerEvent event) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

            child.addLifecycleListener(this);
            child.addContainerListener(this);
            if (child instanceof Host) {
                registerHost((Host) child);
            } else if (child instanceof Context) {
                registerContext((Context) child);
            } else if (child instanceof Wrapper) {
                registerWrapper((Wrapper) child);
======= fetch "public void containerEvent(ContainerEvent event) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

            if (child instanceof Host) {
                unregisterHost((Host) child);
            } else if (child instanceof Context) {
                unregisterContext((Context) child);
            } else if (child instanceof Wrapper) {
                unregisterWrapper((Wrapper) child);
            }
======= fetch "private void findDefaultHost() {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

                    defaultHost));
======= fetch "private void registerHost(Host host) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

        host.addContainerListener(this);
        
======= fetch "private void registerHost(Host host) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

            log.debug(sm.getString
                 ("mapperListener.registerHost", host.getName(), domain));
======= fetch "private void unregisterHost(Host host) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

                    domain));
======= fetch "private void unregisterWrapper(Wrapper wrapper) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

        String wrapperName = wrapper.getName();
======= fetch "private void unregisterWrapper(Wrapper wrapper) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

        
        if(log.isDebugEnabled()) {
            log.debug(sm.getString("mapperListener.unregisterWrapper",
                    wrapperName, contextName, connector));
        }
======= fetch "private void registerContext(Context context) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

        context.addContainerListener(this);
       
======= fetch "private void registerContext(Context context) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

            log.debug(sm.getString
                 ("mapperListener.registerContext", contextName));
======= fetch "private void unregisterContext(Context context) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

            log.debug(sm.getString
                  ("mapperListener.unregisterContext", contextName));
======= fetch "private void registerWrapper(Wrapper wrapper) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

        wrapper.addContainerListener(this);
======= fetch "private void registerWrapper(Wrapper wrapper) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

                    wrapperName, contextName));
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 53c5d85^:"java/org/apache/catalina/connector/MapperListener.java"

    /**
     * Add this mapper to the container and all child containers
     * 
     * @param container
     */
    private void addListeners(Container container) {
        container.addContainerListener(this);
        container.addLifecycleListener(this);
        for (Container child : container.findChildren()) {
            addListeners(child);
        }
    }
    <operation name="findContainerListenerNames"
               description="Return the set of container listener class names configured for this application."
               impact="INFO"
               returnType="[Ljava.lang.String;">    
    </operation>
    
    <operation name="findLifecycleListenerNames"
               description="Return the set of lifecycle listener class names configured for this application."
               impact="INFO"
               returnType="[Ljava.lang.String;">    
    </operation>
    
======= fetch "public void removeLifeCycleListeners(String type) throws MBeanException{" 53c5d85^:"java/org/apache/catalina/mbeans/ContainerMBean.java"

    
    /**
     * List the class name of each of the lifecycle listeners added to this
     * container.
     */
    public String[] findLifecycleListenerNames() throws MBeanException {
        ContainerBase container = null;
        List<String> result = new ArrayList<String>();
        try {
            container = (ContainerBase) getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        LifecycleListener[] listeners = container.findLifecycleListeners();
        for(LifecycleListener listener: listeners){
            result.add(listener.getClass().getName());
        }
        return result.toArray(new String[result.size()]);
    }
    
    /**
     * List the class name of each of the container listeners added to this
     * container.
     */
    public String[] findContainerListenerNames() throws MBeanException {
        ContainerBase container = null;
        List<String> result = new ArrayList<String>();
        try {
            container = (ContainerBase) getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        ContainerListener[] listeners = container.findContainerListeners();
        for(ContainerListener listener: listeners){
            result.add(listener.getClass().getName());
        }
        return result.toArray(new String[result.size()]);
    }
      <fix>
        <bug>50157</bug>: Ensure MapperListener is only added to a container
        object once. (markt)
      </fix>
      <add>
        Improve debug logging for MapperListener registration. (markt)
      </add>
      <add>
        Expose names of LifecycleListeners and ContainerListers for
        StandardContext via JMX. (markt)
      </add>

======= fetch "protected void processAnnotationWebServlet(String className," 509ab5d^:"java/org/apache/catalina/startup/ContextConfig.java"

        boolean isWebXMLservletDef = servletDef != null;
        if (!isWebXMLservletDef) {
======= fetch "protected void processAnnotationWebServlet(String className," 509ab5d^:"java/org/apache/catalina/startup/ContextConfig.java"

            isWebXMLservletDef = false;
        } else {
            isWebXMLservletDef = true;
======= fetch "protected void processAnnotationWebServlet(String className," 509ab5d^:"java/org/apache/catalina/startup/ContextConfig.java"

======= fetch "protected void processAnnotationWebServlet(String className," 509ab5d^:"java/org/apache/catalina/startup/ContextConfig.java"

        if (urlPatternsSet) {
======= fetch "protected void processAnnotationWebFilter(String className," 509ab5d^:"java/org/apache/catalina/startup/ContextConfig.java"

        boolean isWebXMLfilterDef = filterDef != null;
        if (!isWebXMLfilterDef) {
======= fetch "protected void processAnnotationWebFilter(String className," 509ab5d^:"java/org/apache/catalina/startup/ContextConfig.java"

            isWebXMLfilterDef = false;
        } else {
            isWebXMLfilterDef = true;
======= fetch "protected void processAnnotationWebFilter(String className," 509ab5d^:"java/org/apache/catalina/startup/ContextConfig.java"

                urlPatternsSet = urlPatterns != null && urlPatterns.length > 0;
======= fetch "protected void processAnnotationWebFilter(String className," 509ab5d^:"java/org/apache/catalina/startup/ContextConfig.java"

                dispatchTypesSet = dispatcherTypes != null
                        && dispatcherTypes.length > 0;

    private static HashMap<Object,Method[]> objectCache =
        new HashMap<Object,Method[]>();
======= fetch "public static void doAsPrivilege(final String methodName," 9d955f4^:"java/org/apache/catalina/security/SecurityUtil.java"

        Method[] methodsCache = null;
        if(objectCache.containsKey(targetObject)){
            methodsCache = objectCache.get(targetObject);
======= fetch "public static void doAsPrivilege(final String methodName," 9d955f4^:"java/org/apache/catalina/security/SecurityUtil.java"

            if (method == null){
======= fetch "public static void doAsPrivilege(final String methodName," 9d955f4^:"java/org/apache/catalina/security/SecurityUtil.java"

        } else {
            method = createMethodAndCacheIt(methodsCache,
                                            methodName,
                                            targetObject,
                                            targetType);                     
======= fetch "public static void doAsPrivilege(final String methodName," 9d955f4^:"java/org/apache/catalina/security/SecurityUtil.java"

        
======= fetch "public static void doAsPrivilege(final String methodName," 9d955f4^:"java/org/apache/catalina/security/SecurityUtil.java"

        Method[] methodsCache = null;
        if(objectCache.containsKey(targetObject)){
            methodsCache = objectCache.get(targetObject);
======= fetch "public static void doAsPrivilege(final String methodName," 9d955f4^:"java/org/apache/catalina/security/SecurityUtil.java"

            if (method == null){
======= fetch "public static void doAsPrivilege(final String methodName," 9d955f4^:"java/org/apache/catalina/security/SecurityUtil.java"

        } else {
            method = createMethodAndCacheIt(methodsCache,
                                            methodName,
                                            targetObject,
                                            targetType);                     
======= fetch "private static void execute(final Method method," 9d955f4^:"java/org/apache/catalina/security/SecurityUtil.java"

                    @Override
      <fix>
        <bug>50138</bug>: Fix threading issues in
        <code>org.apache.catalina.security.SecurityUtil</code>. (markt)
      </fix>

======= fetch "public void removeHost(String name) throws Exception {" 44f568f^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

            if(host instanceof StandardHost)
                ((StandardHost)host).destroy();
            else
                engine.removeChild(host);
======= fetch "public void removeHost(String name) throws Exception {" 44f568f^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

      <bug>50105</bug>: When processing composite EL expressions use
      <code>Enum.name()</code> rather than <code>Enum.toString()</code> as
      required by the EL specification. (markt)

======= fetch "public Object getValue(EvaluationContext ctx)" e6c1d55^:"java/org/apache/el/parser/AstCompositeExpression.java"

                    sb.append(obj);
======= fetch "public void testBug49345() {" e6c1d55^:"test/org/apache/el/TestValueExpressionImpl.java"

    public void testBug50105() {
        ExpressionFactory factory = ExpressionFactory.newInstance();
        ELContext context = new ELContextImpl();
        
        TesterEnum testEnum = TesterEnum.APPLE;
        
        ValueExpression var =
            factory.createValueExpression(testEnum, TesterEnum.class);
        context.getVariableMapper().setVariable("testEnum", var);
        // When coercing an Enum to a String, name() should always be used.
        ValueExpression ve1 = factory.createValueExpression(
                context, "${testEnum}", String.class);
        String result1 = (String) ve1.getValue(context);
        assertEquals("APPLE", result1);
        
        ValueExpression ve2 = factory.createValueExpression(
                context, "foo${testEnum}bar", String.class);
        String result2 = (String) ve2.getValue(context);
        assertEquals("fooAPPLEbar", result2);
    }
    APPLE, ORANGE;
    
    @Override
    public String toString() {
        return "This is a " + this.name();
    }
  <subsection name="Jasper">
    <changelog>
      <bug>50105</bug>: When processing composite EL expressions use
      <code>Enum.name()</code> rather than <code>Enum.toString()</code> as
      required by the EL specification. (markt)
    </changelog>
  </subsection>

======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        StringManager smClient = getStringManager(request);
        
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                doSessions(path, request, response);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                message = sm.getString("managerServlet.exception",
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                sm.getString("managerServlet.postCommand", command);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                sm.getString("managerServlet.unknownCommand", command);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        list(request, response, message);
======= fetch "public void doPost(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        StringManager smClient = getStringManager(request);
======= fetch "public void doPost(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            message = upload(request);
======= fetch "public void doPost(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            message = deployInternal(deployConfig, deployPath, deployWar);
======= fetch "public void doPost(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            message = reload(path);
======= fetch "public void doPost(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            message = undeploy(path);
======= fetch "public void doPost(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            message = expireSessions(path, request);
======= fetch "public void doPost(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            message = start(path);
======= fetch "public void doPost(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            message = stop(path);
======= fetch "public void doPost(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            message = findleaks();
======= fetch "public void doPost(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        list(request, response, message);
======= fetch "protected String generateNonce() {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String upload(HttpServletRequest request)
======= fetch "protected String upload(HttpServletRequest request)" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                    message =
                        sm.getString("htmlManagerServlet.deployUploadNoFile");
======= fetch "protected String upload(HttpServletRequest request)" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                    message = sm.getString(
======= fetch "protected String upload(HttpServletRequest request)" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                    message = sm.getString(
======= fetch "protected String upload(HttpServletRequest request)" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                    message = sm.getString(
======= fetch "protected String upload(HttpServletRequest request)" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            message = sm.getString
======= fetch "private String extractFilename(String cd) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String deployInternal(String config, String path, String war) {
======= fetch "protected String deployInternal(String config, String path, String war) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        super.deploy(printWriter, config, path, war, false);
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                     String message) throws IOException {
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[1] = sm.getString("htmlManagerServlet.title");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[0] = sm.getString("htmlManagerServlet.messageLabel");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[0] = sm.getString("htmlManagerServlet.manager");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[2] = sm.getString("htmlManagerServlet.list");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

             sm.getString("htmlManagerServlet.helpHtmlManagerFile"));
        args[4] = sm.getString("htmlManagerServlet.helpHtmlManager");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

             sm.getString("htmlManagerServlet.helpManagerFile"));
        args[6] = sm.getString("htmlManagerServlet.helpManager");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[8] = sm.getString("statusServlet.title");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[0] = sm.getString("htmlManagerServlet.appsTitle");
        args[1] = sm.getString("htmlManagerServlet.appsPath");
        args[2] = sm.getString("htmlManagerServlet.appsName");
        args[3] = sm.getString("htmlManagerServlet.appsAvailable");
        args[4] = sm.getString("htmlManagerServlet.appsSessions");
        args[5] = sm.getString("htmlManagerServlet.appsTasks");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        String appsStart = sm.getString("htmlManagerServlet.appsStart");
        String appsStop = sm.getString("htmlManagerServlet.appsStop");
        String appsReload = sm.getString("htmlManagerServlet.appsReload");
        String appsUndeploy = sm.getString("htmlManagerServlet.appsUndeploy");
        String appsExpire = sm.getString("htmlManagerServlet.appsExpire");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args[10] = sm.getString("htmlManagerServlet.expire.explain");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                    args[11] = sm.getString("htmlManagerServlet.noManager");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args[12] = sm.getString("htmlManagerServlet.expire.unit");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[0] = sm.getString("htmlManagerServlet.deployTitle");
        args[1] = sm.getString("htmlManagerServlet.deployServer");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[3] = sm.getString("htmlManagerServlet.deployPath");
        args[4] = sm.getString("htmlManagerServlet.deployConfig");
        args[5] = sm.getString("htmlManagerServlet.deployWar");
        args[6] = sm.getString("htmlManagerServlet.deployButton");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[0] = sm.getString("htmlManagerServlet.deployUpload");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[2] = sm.getString("htmlManagerServlet.deployUploadFile");
        args[3] = sm.getString("htmlManagerServlet.deployButton");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[0] = sm.getString("htmlManagerServlet.diagnosticsTitle");
        args[1] = sm.getString("htmlManagerServlet.diagnosticsLeak");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[3] = sm.getString("htmlManagerServlet.diagnosticsLeakWarning");
        args[4] = sm.getString("htmlManagerServlet.diagnosticsLeakButton");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[0] = sm.getString("htmlManagerServlet.serverTitle");
        args[1] = sm.getString("htmlManagerServlet.serverVersion");
        args[2] = sm.getString("htmlManagerServlet.serverJVMVersion");
        args[3] = sm.getString("htmlManagerServlet.serverJVMVendor");
        args[4] = sm.getString("htmlManagerServlet.serverOSName");
        args[5] = sm.getString("htmlManagerServlet.serverOSVersion");
        args[6] = sm.getString("htmlManagerServlet.serverOSArch");
======= fetch "public void list(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String reload(String path) {
======= fetch "protected String reload(String path) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        super.reload(printWriter, path);
======= fetch "protected String reload(String path) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String undeploy(String path) {
======= fetch "protected String undeploy(String path) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        super.undeploy(printWriter, path);
======= fetch "protected String undeploy(String path) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    public String sessions(String path, int idle) {
======= fetch "public String sessions(String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        super.sessions(printWriter, path, idle);
======= fetch "public String sessions(String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    public String sessions(String path) {
======= fetch "public String sessions(String path) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        return sessions(path, -1);
======= fetch "public String sessions(String path) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    public String start(String path) {
======= fetch "public String start(String path) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        super.start(printWriter, path);
======= fetch "public String start(String path) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String stop(String path) {
======= fetch "protected String stop(String path) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        super.stop(printWriter, path);
======= fetch "protected String stop(String path) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String findleaks() {
======= fetch "protected String findleaks() {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        super.findleaks(printWriter);
======= fetch "protected String findleaks() {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            msg.append(sm.getString("htmlManagerServlet.findleaksList"));
======= fetch "protected String findleaks() {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            msg.append(sm.getString("htmlManagerServlet.findleaksNone"));
======= fetch "public void init() throws ServletException {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String expireSessions(String path, HttpServletRequest req) {
======= fetch "protected String expireSessions(String path, HttpServletRequest req) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        return sessions(path, idle);
======= fetch "protected String expireSessions(String path, HttpServletRequest req) {" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected void doSessions(String path, HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
======= fetch "protected void doSessions(String path, HttpServletRequest req, HttpServletRespon" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            displaySessionDetailPage(req, resp, path, sessionId);
======= fetch "protected void doSessions(String path, HttpServletRequest req, HttpServletRespon" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            int i = invalidateSessions(path, sessionIds);
======= fetch "protected void doSessions(String path, HttpServletRequest req, HttpServletRespon" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            boolean removed = removeSessionAttribute(path, sessionId, name);
======= fetch "protected void doSessions(String path, HttpServletRequest req, HttpServletRespon" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        displaySessionsListPage(path, req, resp);
======= fetch "protected void doSessions(String path, HttpServletRequest req, HttpServletRespon" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected List<Session> getSessionsForPath(String path) {
======= fetch "protected void doSessions(String path, HttpServletRequest req, HttpServletRespon" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            throw new IllegalArgumentException(sm.getString("managerServlet.invalidPath",
                                        RequestUtil.filter(path)));
======= fetch "protected void doSessions(String path, HttpServletRequest req, HttpServletRespon" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            throw new IllegalArgumentException(sm.getString("managerServlet.noContext",
                                        RequestUtil.filter(path)));
======= fetch "protected void doSessions(String path, HttpServletRequest req, HttpServletRespon" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected Session getSessionForPathAndId(String path, String id) throws IOException {
======= fetch "protected Session getSessionForPathAndId(String path, String id) throws IOExcept" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            throw new IllegalArgumentException(sm.getString("managerServlet.invalidPath",
                                        RequestUtil.filter(path)));
======= fetch "protected Session getSessionForPathAndId(String path, String id) throws IOExcept" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            throw new IllegalArgumentException(sm.getString("managerServlet.noContext",
                                        RequestUtil.filter(path)));
======= fetch "protected Session getSessionForPathAndId(String path, String id) throws IOExcept" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected void displaySessionsListPage(String path, HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        List<Session> sessions = getSessionsForPath(path);
======= fetch "protected void displaySessionsListPage(String path, HttpServletRequest req, Http" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected void displaySessionDetailPage(HttpServletRequest req, HttpServletResponse resp, String path, String sessionId) throws ServletException, IOException {
        Session session = getSessionForPathAndId(path, sessionId);
======= fetch "protected void displaySessionDetailPage(HttpServletRequest req, HttpServletRespo" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    public int invalidateSessions(String path, String[] sessionIds) throws IOException {
======= fetch "public int invalidateSessions(String path, String[] sessionIds) throws IOExcepti" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            HttpSession session = getSessionForPathAndId(path, sessionId).getSession();
======= fetch "public int invalidateSessions(String path, String[] sessionIds) throws IOExcepti" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    public boolean removeSessionAttribute(String path, String sessionId, String attributeName) throws IOException {
        HttpSession session = getSessionForPathAndId(path, sessionId).getSession();
======= fetch "public boolean removeSessionAttribute(String path, String sessionId, String attr" 7357867^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    public int setSessionMaxInactiveInterval(String path, String sessionId, int maxInactiveInterval) throws IOException {
        HttpSession session = getSessionForPathAndId(path, sessionId).getSession();
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

        StringManager smClient = getStringManager(request);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.noCommand"));
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                deploy(writer, config, path, war, update);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                deploy(writer, path, tag);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            list(writer);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            reload(writer, path);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            resources(writer, type);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            roles(writer);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            save(writer, path);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            serverinfo(writer);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            expireSessions(writer, path, request);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            expireSessions(writer, path, request);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            start(writer, path);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            stop(writer, path);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            undeploy(writer, path);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            findleaks(writer);
======= fetch "public void doGet(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.unknownCommand",
                                        command));
======= fetch "public void doPut(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

        StringManager smClient = getStringManager(request);
======= fetch "public void doPut(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.noCommand"));
======= fetch "public void doPut(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            deploy(writer, path, tag, update, request);
======= fetch "public void doPut(HttpServletRequest request," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.unknownCommand",
                                        command));
======= fetch "public void init() throws ServletException {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            throw new UnavailableException
                (sm.getString("managerServlet.noWrapper"));
======= fetch "public void init() throws ServletException {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void findleaks(PrintWriter writer) {
======= fetch "protected void findleaks(PrintWriter writer) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.findleaksFail"));
======= fetch "protected void findleaks(PrintWriter writer) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected synchronized void save(PrintWriter writer, String path) {
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.saveFail", server));
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.saved"));
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.exception",
                                            e.toString()));
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.noContext", path));
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.savedContext", 
                               path));
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.exception",
                                            e.toString()));
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

         String tag, boolean update, HttpServletRequest request) {
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.invalidPath", path));
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                undeploy(writer, displayPath);
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println
                (sm.getString("managerServlet.alreadyContext",
                              displayPath));
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.exception",
                                        e.toString()));
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.deployed", displayPath));
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.deployFailed", displayPath));
======= fetch "protected synchronized void save(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void deploy(PrintWriter writer, String path, String tag) {
======= fetch "protected void deploy(PrintWriter writer, String path, String tag) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.invalidPath", path));
======= fetch "protected void deploy(PrintWriter writer, String path, String tag) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            undeploy(writer, displayPath);
======= fetch "protected void deploy(PrintWriter writer, String path, String tag) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.exception",
                                        e.toString()));
======= fetch "protected void deploy(PrintWriter writer, String path, String tag) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.deployed", displayPath));
======= fetch "protected void deploy(PrintWriter writer, String path, String tag) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.deployFailed", displayPath));
======= fetch "protected void deploy(PrintWriter writer, String config," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            String path, String war, boolean update) {
======= fetch "protected void deploy(PrintWriter writer, String config," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.invalidPath",
                                        RequestUtil.filter(path)));
======= fetch "protected void deploy(PrintWriter writer, String config," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                undeploy(writer, displayPath);
======= fetch "protected void deploy(PrintWriter writer, String config," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println
            (sm.getString("managerServlet.alreadyContext",
======= fetch "protected void deploy(PrintWriter writer, String config," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.deployed", displayPath));
======= fetch "protected void deploy(PrintWriter writer, String config," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.deployedButNotStarted", displayPath));
======= fetch "protected void deploy(PrintWriter writer, String config," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.deployFailed", displayPath));
======= fetch "protected void deploy(PrintWriter writer, String config," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.exception",
======= fetch "protected void deploy(PrintWriter writer, String config," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void list(PrintWriter writer) {
======= fetch "protected void list(PrintWriter writer) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

        writer.println(sm.getString("managerServlet.listed",
======= fetch "protected void list(PrintWriter writer) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                    writer.println(sm.getString("managerServlet.listitem",
                                                displayPath,
                                                "running",
                                      "" + context.getManager().findSessions().length,
                                                context.getDocBase()));
======= fetch "protected void list(PrintWriter writer) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                    writer.println(sm.getString("managerServlet.listitem",
                                                displayPath,
                                                "stopped",
                                                "0",
                                                context.getDocBase()));
======= fetch "protected void list(PrintWriter writer) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void reload(PrintWriter writer, String path) {
======= fetch "protected void reload(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.invalidPath",
                                        RequestUtil.filter(path)));
======= fetch "protected void reload(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString
                               ("managerServlet.noContext",
                                   RequestUtil.filter(displayPath)));
======= fetch "protected void reload(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.noSelf"));
======= fetch "protected void reload(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                (sm.getString("managerServlet.reloaded", displayPath));
======= fetch "protected void reload(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.exception",
                                        t.toString()));
======= fetch "protected void reload(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void resources(PrintWriter writer, String type) {
======= fetch "protected void resources(PrintWriter writer, String type) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.noGlobal"));
======= fetch "protected void resources(PrintWriter writer, String type) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.resourcesType",
                                        type));
======= fetch "protected void resources(PrintWriter writer, String type) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.resourcesAll"));
======= fetch "protected void resources(PrintWriter writer, String type) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.exception",
                                        t.toString()));
======= fetch "protected void resources(PrintWriter writer, String type) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

        printResources(writer, "", global, type, clazz);
======= fetch "protected void printResources(PrintWriter writer, String prefix," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                                  String type, Class<?> clazz) {
======= fetch "protected void printResources(PrintWriter writer, String prefix," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                         (javax.naming.Context) item.getObject(), type, clazz);
======= fetch "protected void printResources(PrintWriter writer, String prefix," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.exception",
                                        t.toString()));
======= fetch "protected void printResources(PrintWriter writer, String prefix," 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void roles(PrintWriter writer) {
======= fetch "protected void roles(PrintWriter writer) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.userDatabaseError"));
======= fetch "protected void roles(PrintWriter writer) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.userDatabaseMissing"));
======= fetch "protected void roles(PrintWriter writer) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

        writer.println(sm.getString("managerServlet.rolesList"));
======= fetch "protected void roles(PrintWriter writer) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void serverinfo(PrintWriter writer) {
======= fetch "protected void serverinfo(PrintWriter writer) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.exception",
                                        t.toString()));
======= fetch "protected void serverinfo(PrintWriter writer) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void sessions(PrintWriter writer, String path, int idle) {
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.invalidPath",
                                        RequestUtil.filter(path)));
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.noContext",
                                            RequestUtil.filter(displayPath)));
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.noManager",
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.sessions", displayPath));
            writer.println(sm.getString("managerServlet.sessiondefaultmax",
                                "" + maxInactiveInterval));
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.sessiontimeout",
                                            "<" + histoInterval, "" + timeout[0]));
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                    writer.println(sm.getString("managerServlet.sessiontimeout",
                                     "" + (i)*histoInterval + " - <" + (i+1)*histoInterval,
                                                "" + timeout[i]));
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.sessiontimeout",
                                            ">=" + maxCount*histoInterval,
                                            "" + timeout[maxCount-1]));
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.sessiontimeout.unlimited",
                                            "" + notimeout));
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.sessiontimeout.expired",
                                            "" + idle,"" + expired));
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.exception",
                                        t.toString()));
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void sessions(PrintWriter writer, String path) {
        sessions(writer, path, -1);
======= fetch "protected void sessions(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void expireSessions(PrintWriter writer, String path, HttpServletRequest req) {
======= fetch "protected void expireSessions(PrintWriter writer, String path, HttpServletReques" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

        sessions(writer, path, idle);
======= fetch "protected void expireSessions(PrintWriter writer, String path, HttpServletReques" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void start(PrintWriter writer, String path) {
======= fetch "protected void start(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.invalidPath",
                                        RequestUtil.filter(path)));
======= fetch "protected void start(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.noContext", 
                                            RequestUtil.filter(displayPath)));
======= fetch "protected void start(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println
                    (sm.getString("managerServlet.started", displayPath));
======= fetch "protected void start(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println
                    (sm.getString("managerServlet.startFailed", displayPath));
======= fetch "protected void start(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            getServletContext().log
                (sm.getString("managerServlet.startFailed", displayPath), t);
            writer.println
                (sm.getString("managerServlet.startFailed", displayPath));
            writer.println(sm.getString("managerServlet.exception",
                                        t.toString()));
======= fetch "protected void start(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void stop(PrintWriter writer, String path) {
======= fetch "protected void stop(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.invalidPath",
                                        RequestUtil.filter(path)));
======= fetch "protected void stop(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.noContext", 
                                            RequestUtil.filter(displayPath)));
======= fetch "protected void stop(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.noSelf"));
======= fetch "protected void stop(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.stopped", displayPath));
======= fetch "protected void stop(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.exception",
                                        t.toString()));
======= fetch "protected void stop(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void undeploy(PrintWriter writer, String path) {
======= fetch "protected void undeploy(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.invalidPath",
                                        RequestUtil.filter(path)));
======= fetch "protected void undeploy(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.noContext",
                                            RequestUtil.filter(displayPath)));
======= fetch "protected void undeploy(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.notDeployed",
======= fetch "protected void undeploy(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.undeployed",
                                        displayPath));
======= fetch "protected void undeploy(PrintWriter writer, String path) {" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(sm.getString("managerServlet.exception",
                                        t.toString()));
======= fetch "protected void uploadWar(HttpServletRequest request, File war)" 7357867^:"java/org/apache/catalina/manager/ManagerServlet.java"

    private StringManager(String packageName) {
======= fetch "private StringManager(String packageName) {" 7357867^:"java/org/apache/tomcat/util/res/StringManager.java"

            bnd = ResourceBundle.getBundle(bundleName, Locale.getDefault());
======= fetch "private StringManager(String packageName) {" 7357867^:"java/org/apache/tomcat/util/res/StringManager.java"

                    bnd = ResourceBundle.getBundle(
                            bundleName, Locale.getDefault(), cl);
======= fetch "private StringManager(String packageName) {" 7357867^:"java/org/apache/tomcat/util/res/StringManager.java"

            locale = bundle.getLocale();
======= fetch "private StringManager(String packageName) {" 7357867^:"java/org/apache/tomcat/util/res/StringManager.java"

            locale = null;
======= fetch "public String getString(String key) {" 7357867^:"java/org/apache/tomcat/util/res/StringManager.java"

            //   str = "[cannot find message associated with key '" + key + "' due to " + mre + "]";
======= fetch "public String getString(final String key, final Object... args) {" 7357867^:"java/org/apache/tomcat/util/res/StringManager.java"

    /**
     * Identify the Locale this StringManager is associated with
     */
    public Locale getLocale() {
        return locale;
    }
======= fetch "public String getString(final String key, final Object... args) {" 7357867^:"java/org/apache/tomcat/util/res/StringManager.java"

    private static final Hashtable<String, StringManager> managers =
        new Hashtable<String, StringManager>();
======= fetch "public String getString(final String key, final Object... args) {" 7357867^:"java/org/apache/tomcat/util/res/StringManager.java"

    public synchronized static final StringManager getManager(String packageName) {
        StringManager mgr = managers.get(packageName);
======= fetch "public synchronized static final StringManager getManager(String packageName) {" 7357867^:"java/org/apache/tomcat/util/res/StringManager.java"

            mgr = new StringManager(packageName);
            managers.put(packageName, mgr);
======= fetch "public synchronized static final StringManager getManager(String packageName) {" 7357867^:"java/org/apache/tomcat/util/res/StringManager.java"


======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" 9e7ce59^:"java/org/apache/catalina/startup/ContextConfig.java"

        } catch (ClassFormatError e) {
            log.warn(sm.getString("contextConfig.invalidSciHandlesTypes",
                    className), e);
            return;
      <fix>
        <bug>50087</bug>: Catch ClassFormatErrors when scanning for annotations.
        (markt)
      </fix>

======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," 79cf689^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                    // Use same classloader and classpath for compiling tag files
                    tempWrapper.getJspEngineContext().setClassLoader(
                            ctxt.getClassLoader());
                    tempWrapper.getJspEngineContext().setClassPath(ctxt.getClassPath());
      <fix>
        <bug>50066</bug>: Fix building of recursive tag files when the file
        depends on a JAR file. Patch provided by Sylvain Laurent. (markt)
      </fix>

======= fetch "protected void webConfig() {" 4d7f111^:"java/org/apache/catalina/startup/ContextConfig.java"

                webXml.configureContext(context);
      <fix>
        <bug>500063</bug>: Correct regression in fix for <bug>50059</bug> that
        causes applications marked as meta-data complete to return 404s for all
        requests. Patch provided by heyoulin. (markt)
      </fix>

======= fetch "public void setNamingResources(NamingResources namingResources) {" 6ce21f4^:"java/org/apache/catalina/core/StandardContext.java"

        unregister(onameNamingResources);
        onameNamingResources = register(namingResources,
                "type=NamingResources," + getObjectKeyPropertiesNameOnly());

======= fetch "protected void webConfig() {" da36bd1^:"java/org/apache/catalina/startup/ContextConfig.java"

        if (webXmlVersion >= 3 && !webXml.isMetadataComplete()) {
======= fetch "protected void webConfig() {" da36bd1^:"java/org/apache/catalina/startup/ContextConfig.java"

            // Step 2. Order the fragments.
            Set<WebXml> orderedFragments =
                WebXml.orderWebFragments(webXml, fragments);
            // Step 3. Look for ServletContainerInitializer implementations
            ok = processServletContainerInitializers(orderedFragments);
            // Step 4. Process /WEB-INF/classes for annotations
            // This will add any matching classes to the typeInitializerMap
            if (ok) {
                URL webinfClasses;
                try {
                    webinfClasses =
                        context.getServletContext().getResource("/WEB-INF/classes");
                    processAnnotationsUrl(webinfClasses, webXml);
                } catch (MalformedURLException e) {
                    log.error(sm.getString("contextConfig.webinfClassesUrl"), e);
======= fetch "protected void webConfig() {" da36bd1^:"java/org/apache/catalina/startup/ContextConfig.java"

            }
            // Step 5. Process JARs for annotations - only need to process those
            // fragments we are going to use
            // This will add any matching classes to the typeInitializerMap
            if (ok) {
                processAnnotations(orderedFragments);
            }
            // Step 6. Merge web-fragment.xml files into the main web.xml file.
            if (ok) {
                ok = webXml.merge(orderedFragments);
            }
            // Step 6.5 Convert explicitly mentioned jsps to servlets
            if (!false) {
                convertJsps(webXml);
            }
            // Step 7. Apply merged web.xml to Context
            if (ok) {
                webXml.configureContext(context);
                // Step 7a. Make the merged web.xml available to other
                // components, specifically Jasper, to save those components
                // from having to re-generate it.
                // TODO Use a ServletContainerInitializer for Jasper
                String mergedWebXml = webXml.toXml();
                context.getServletContext().setAttribute(
                       org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML,
                        mergedWebXml);
                if (context.getLogEffectiveWebXml()) {
                    log.info("web.xml:\n" + mergedWebXml);
======= fetch "protected void webConfig() {" da36bd1^:"java/org/apache/catalina/startup/ContextConfig.java"

    
                // Step 6. Merge web-fragment.xml files into the main web.xml
                // file.
                if (ok) {
                    ok = webXml.merge(orderedFragments);
                }
    
                // Step 6.5 Convert explicitly mentioned jsps to servlets
                if (!false) {
                    convertJsps(webXml);
                }
    
                // Step 7. Apply merged web.xml to Context
                if (ok) {
                    webXml.configureContext(context);
    
                    // Step 7a. Make the merged web.xml available to other
                    // components, specifically Jasper, to save those components
                    // from having to re-generate it.
                    // TODO Use a ServletContainerInitializer for Jasper
                    String mergedWebXml = webXml.toXml();
                    context.getServletContext().setAttribute(
                           org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML,
                            mergedWebXml);
                    if (context.getLogEffectiveWebXml()) {
                        log.info("web.xml:\n" + mergedWebXml);
                    }
                }
            } else {
                ok = true;
======= fetch "protected void webConfig() {" da36bd1^:"java/org/apache/catalina/startup/ContextConfig.java"

            // Always need to look for static resources
======= fetch "protected void webConfig() {" da36bd1^:"java/org/apache/catalina/startup/ContextConfig.java"

                for (WebXml fragment : orderedFragments) {
                    resourceJars.add(fragment);
======= fetch "protected void webConfig() {" da36bd1^:"java/org/apache/catalina/startup/ContextConfig.java"

            // Step 9. Apply the ServletContainerInitializer config to the
            // context
            if (ok) {
                for (Map.Entry<ServletContainerInitializer,Set<Class<?>>> entry :
                        initializerClassMap.entrySet()) {
                    if (entry.getValue().isEmpty()) {
                        context.addServletContainerInitializer(entry.getKey(),
                                null);
                    } else {
                        context.addServletContainerInitializer(entry.getKey(),
                                entry.getValue());

    private Object base;
    private Object property;
    private AsyncContext context;
    private ServletRequest request;
    private ServletResponse response;
    private Throwable throwable;
======= fetch "public AsyncEvent(AsyncContext context) {" c4a3427^:"java/javax/servlet/AsyncEvent.java"

        this.request = null;
        this.response = null;
        this.throwable = null;
======= fetch "public AsyncEvent(AsyncContext context, ServletRequest request," c4a3427^:"java/javax/servlet/AsyncEvent.java"

        this.throwable = null;
======= fetch "public AsyncEvent(AsyncContext context, Throwable throwable) {" c4a3427^:"java/javax/servlet/AsyncEvent.java"

    private EmptyRoleSemantic emptyRoleSemantic = EmptyRoleSemantic.PERMIT;
    private TransportGuarantee transportGuarantee = TransportGuarantee.NONE;
    private String[] rolesAllowed = new String[0];
======= fetch "public HttpConstraintElement() {" c4a3427^:"java/javax/servlet/HttpConstraintElement.java"

        this.emptyRoleSemantic = EmptyRoleSemantic.PERMIT;
        this.transportGuarantee = TransportGuarantee.NONE;
        this.rolesAllowed = new String[0];
======= fetch "public HttpConstraintElement(EmptyRoleSemantic emptyRoleSemantic) {" c4a3427^:"java/javax/servlet/HttpConstraintElement.java"

        this.transportGuarantee = TransportGuarantee.NONE;
        this.rolesAllowed = new String[0];
======= fetch "public HttpConstraintElement(TransportGuarantee transportGuarantee," c4a3427^:"java/javax/servlet/HttpConstraintElement.java"

    private String methodName;
    private String location = "";
    private long maxFileSize = -1;
    private long maxRequestSize = -1;
    private int fileSizeThreshold = 0;
======= fetch "public MultipartConfigElement(String location) {" c4a3427^:"java/javax/servlet/MultipartConfigElement.java"

        } else {
            this.location = "";
======= fetch "public MultipartConfigElement(String location) {" c4a3427^:"java/javax/servlet/MultipartConfigElement.java"

        this.maxFileSize = -1;
        this.maxRequestSize = -1;
        this.fileSizeThreshold = 0;
======= fetch "public MultipartConfigElement(String location, long maxFileSize," c4a3427^:"java/javax/servlet/MultipartConfigElement.java"

    private String name;
    private Object value;
    private String name;
    private Object value;
    private ServletRequest request;
    private Map<String,HttpMethodConstraintElement> methodConstraints =
    private Servlet servlet; // what's unavailable
    private boolean permanent; // needs admin action?
    private int seconds; // unavailability estimate
======= fetch "public UnavailableException(Servlet servlet, String msg) {" c4a3427^:"java/javax/servlet/UnavailableException.java"

        this.seconds = 0;
======= fetch "public UnavailableException(String msg) {" c4a3427^:"java/javax/servlet/UnavailableException.java"

        seconds = 0;
        servlet = null;
======= fetch "public UnavailableException(String msg, int seconds) {" c4a3427^:"java/javax/servlet/UnavailableException.java"

    private String name;
    private Object value;
======= fetch "public HttpSessionBindingEvent(HttpSession session, String name) {" c4a3427^:"java/javax/servlet/http/HttpSessionBindingEvent.java"

    private Throwable throwable;
    private int statusCode;
    private String uri;
    private String servletName;
======= fetch "public JspWriter getEnclosingWriter() {" c4a3427^:"java/javax/servlet/jsp/tagext/BodyContent.java"

    private JspWriter enclosingWriter;
======= fetch "public String getFunctionSignature() {" c4a3427^:"java/javax/servlet/jsp/tagext/FunctionInfo.java"

    private String name;
    private String functionClass;
    private String functionSignature;
======= fetch "public TagAttributeInfo(String name, boolean required, String type," c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

        this.name = name;
        this.required = required;
        this.type = type;
        this.reqTime = reqTime;
======= fetch "public TagAttributeInfo(String name, boolean required, String type," c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

        this(name, required, type, reqTime);
        this.fragment = fragment;
======= fetch "public TagAttributeInfo(String name, boolean required, String type," c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

        this(name, required, type, reqTime, fragment);
======= fetch "public String toString() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

    private String name;
======= fetch "public String toString() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

    private String type;
======= fetch "public String toString() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

    private boolean reqTime;
======= fetch "public String toString() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

    private boolean required;
======= fetch "public String toString() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

    private boolean fragment;
======= fetch "public String toString() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

    private String description;
======= fetch "public String toString() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

    private boolean deferredValue;
======= fetch "public String toString() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

    private boolean deferredMethod;
======= fetch "public String toString() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

    private String expectedTypeName;
======= fetch "public String toString() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

    private String methodSignature;
======= fetch "public String getAttributeString(String attName) {" c4a3427^:"java/javax/servlet/jsp/tagext/TagData.java"

    private Hashtable<String, Object> attributes;        // the tagname/value map
======= fetch "public final TagInfo getTagInfo() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagExtraInfo.java"

    private TagInfo tagInfo;
======= fetch "public TagInfo getTagInfo() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagFileInfo.java"

    private String name;
    private String path;
    private TagInfo tagInfo;
======= fetch "public int getScope() {" c4a3427^:"java/javax/servlet/jsp/tagext/TagVariableInfo.java"

    private String nameGiven; // <name-given>
    private String nameFromAttribute; // <name-from-attribute>
    private String className; // <class>
    private boolean declare; // <declare>
    private int scope; // <scope>
======= fetch "public String getMessage() {" c4a3427^:"java/javax/servlet/jsp/tagext/ValidationMessage.java"

    private String id;
    private String message;
======= fetch "public int getScope() {" c4a3427^:"java/javax/servlet/jsp/tagext/VariableInfo.java"

    private String varName;
    private String className;
    private boolean declare;
    private int scope;

======= fetch "public boolean authenticate(Request request, HttpServletResponse response," 469a916^:"java/org/apache/catalina/Authenticator.java"

    /**
     * Register an authenticated Principal and authentication type in our
     * request, in the current session (if there is one), and with our
     * SingleSignOn valve, if there is one.  Set the appropriate cookie
     * to be returned. Passing in a null principal will de-register any
     * SSO sessions.
     *
     * @param request The servlet request we are processing
     * @param response The servlet response we are populating
     * @param principal The authenticated Principal to be registered
     * @param authType The authentication type to be registered
     * @param username Username used to authenticate (if any)
     * @param password Password used to authenticate (if any)
     */
    public void register(Request request, HttpServletResponse response,
            Principal principal, String authType,
            String username, String password);
======= fetch "public boolean hasResourcePermission(Request request," 469a916^:"java/org/apache/catalina/Realm.java"

     * @param wrapper wrapper context for evaluating role
======= fetch "public boolean hasResourcePermission(Request request," 469a916^:"java/org/apache/catalina/Realm.java"

    public boolean hasRole(Principal principal, String role);
======= fetch "public void register(Request request, HttpServletResponse response," 469a916^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

    public void login(String username, String password, Request request)
            throws ServletException {
        Principal principal = doLogin(request, username, password);
        register(request, request.getResponse(), principal,
                    getAuthMethod(), username, password);
    }
    protected abstract String getAuthMethod();
    protected Principal doLogin(Request request, String username,
            String password) throws ServletException {
        Principal p = context.getRealm().authenticate(username, password);
        if (p == null) {
            throw new ServletException(sm.getString("authenticator.loginFail"));
        }
        return p;
    }
    public void logout(Request request) throws ServletException {
        register(request, request.getResponse(), null,
                null, null, null);
    }
======= fetch "either the original SSO logon was of DIGEST or SSL (which" 469a916^:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

    @Override
    protected String getAuthMethod() {
        return Constants.BASIC_METHOD;
    }
======= fetch "public boolean authenticate(Request request," 469a916^:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

    @Override
    protected String getAuthMethod() {
        return Constants.DIGEST_METHOD;
    }
======= fetch "public boolean authenticate(Request request," 469a916^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

    @Override
    protected String getAuthMethod() {
        return Constants.FORM_METHOD;
    }
======= fetch "public boolean authenticate(Request request," 469a916^:"java/org/apache/catalina/authenticator/NonLoginAuthenticator.java"

    @Override
    protected String getAuthMethod() {
        return "NONE";
    }
======= fetch "public boolean authenticate(Request request," 469a916^:"java/org/apache/catalina/authenticator/SSLAuthenticator.java"

    @Override
    protected String getAuthMethod() {
        return Constants.CERT_METHOD;
    }
======= fetch "public boolean isUserInRole(String role) {" 469a916^:"java/org/apache/catalina/connector/Request.java"

        // Check for a role alias defined in a <security-role-ref> element
        if (wrapper != null) {
            String realRole = wrapper.findSecurityReference(role);
            if ((realRole != null) && realm.hasRole(userPrincipal, realRole))
                return true;
        }
======= fetch "public boolean isUserInRole(String role) {" 469a916^:"java/org/apache/catalina/connector/Request.java"

        return (realm.hasRole(userPrincipal, role));
======= fetch "public void login(String username, String password)" 469a916^:"java/org/apache/catalina/connector/Request.java"

        LoginConfig config = context.getLoginConfig();
        if (config == null) {
            throw new ServletException(
                    sm.getString("coyoteRequest.noLoginConfig"));
======= fetch "public void login(String username, String password)" 469a916^:"java/org/apache/catalina/connector/Request.java"

        String authMethod = config.getAuthMethod();
        if (BASIC_AUTH.equals(authMethod) || FORM_AUTH.equals(authMethod) ||
                DIGEST_AUTH.equals(authMethod)) {
            // Methods support user name and password authentication
            Realm realm = context.getRealm();
            
            Principal principal = realm.authenticate(username, password);
            if (principal == null) {
                throw new ServletException(
                        sm.getString("coyoteRequest.authFail", username));
            }
            // Assume if we have a non-null LoginConfig then we must have an
            // authenticator
            context.getAuthenticator().register(this, getResponse(), principal,
                    authMethod, username, password);
        } else {
            throw new ServletException("coyoteRequest.noPasswordLogin");
        }
======= fetch "public void logout() throws ServletException {" 469a916^:"java/org/apache/catalina/connector/Request.java"

        context.getAuthenticator().register(this, getResponse(), null,
                null, null, null);
======= fetch "public boolean hasResourcePermission(Request request," 469a916^:"java/org/apache/catalina/realm/RealmBase.java"

                    if (hasRole(principal, roles[j])) {
======= fetch "public boolean hasResourcePermission(Request request," 469a916^:"java/org/apache/catalina/realm/RealmBase.java"

    public boolean hasRole(Principal principal, String role) {
======= fetch "public void setResourceName(String resourceName) {" 469a916^:"java/org/apache/catalina/realm/UserDatabaseRealm.java"

    public boolean hasRole(Principal principal, String role) {
======= fetch "public boolean hasRole(Principal principal, String role) {" 469a916^:"java/org/apache/catalina/realm/UserDatabaseRealm.java"

            return super.hasRole(principal, role);

======= fetch "public ApplicationContext(StandardContext context) {" 2db864e^:"java/org/apache/catalina/core/ApplicationContext.java"

    private Map<String,String> parameters = null;
======= fetch "public String getInitParameter(final String name) {" 2db864e^:"java/org/apache/catalina/core/ApplicationContext.java"

        mergeParameters();
======= fetch "public String getInitParameter(final String name) {" 2db864e^:"java/org/apache/catalina/core/ApplicationContext.java"

======= fetch "public String getInitParameter(final String name) {" 2db864e^:"java/org/apache/catalina/core/ApplicationContext.java"

        mergeParameters();
======= fetch "public String getInitParameter(final String name) {" 2db864e^:"java/org/apache/catalina/core/ApplicationContext.java"

======= fetch "public boolean setInitParameter(String name, String value) {" 2db864e^:"java/org/apache/catalina/core/ApplicationContext.java"

        
        mergeParameters();
        
======= fetch "protected void setNewServletContextListenerAllowed(boolean allowed) {" 2db864e^:"java/org/apache/catalina/core/ApplicationContext.java"

    // -------------------------------------------------------- Private Methods
    /**
     * Merge the context initialization parameters specified in the application
     * deployment descriptor with the application parameters described in the
     * server configuration, respecting the <code>override</code> property of
     * the application parameters appropriately.
     */
    private void mergeParameters() {
        if (parameters != null)
            return;
        Map<String,String> results = new ConcurrentHashMap<String,String>();
        String names[] = context.findParameters();
        for (int i = 0; i < names.length; i++)
            results.put(names[i], context.findParameter(names[i]));
        ApplicationParameter params[] =
            context.findApplicationParameters();
        for (int i = 0; i < params.length; i++) {
            if (params[i].getOverride()) {
                if (results.get(params[i].getName()) == null)
                    results.put(params[i].getName(), params[i].getValue());
            } else {
                results.put(params[i].getName(), params[i].getValue());
            }
        }
        parameters = results;
    }
======= fetch "protected synchronized void startInternal() throws LifecycleException {" 2db864e^:"java/org/apache/catalina/core/StandardContext.java"

            // Set up the context init params
            mergeParameters();
======= fetch "private void addInjectionTarget(Injectable resource, Map<String, Map<String, Str" 2db864e^:"java/org/apache/catalina/core/StandardContext.java"

    
    /**
     * Merge the context initialization parameters specified in the application
     * deployment descriptor with the application parameters described in the
     * server configuration, respecting the <code>override</code> property of
     * the application parameters appropriately.
     */
    private void mergeParameters() {
        ServletContext sc = getServletContext();
        
        String names[] = findParameters();
        for (int i = 0; i < names.length; i++) {
            sc.setInitParameter(names[i], findParameter(names[i]));
        }
        ApplicationParameter params[] = findApplicationParameters();
        for (int i = 0; i < params.length; i++) {
            if (params[i].getOverride()) {
                if (sc.getInitParameter(params[i].getName()) == null) {
                    sc.setInitParameter(params[i].getName(),
                            params[i].getValue());
                }
            } else {
                sc.setInitParameter(params[i].getName(), params[i].getValue());
            }
        }
    }
      <fix>
        <bug>49987</bug>: Fix thread safety issue with population of servlet
        context initialization parameters. (markt)
      </fix>

    private boolean reload = true;
    private long servletClassLastModifiedTime;
======= fetch "public Servlet getServlet() throws ServletException {" 2570d6ff^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        // DCL on 'reload' requires that 'reload' be volatile
        // (this also forces a read memory barrier, ensuring the 
        // new servlet object is read consistently)
======= fetch "public Servlet getServlet() throws ServletException {" 2570d6ff^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                    Servlet servlet = null;
======= fetch "public Servlet getServlet() throws ServletException {" 2570d6ff^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                    // Volatile 'reload' forces in order write of 'theServlet' and new servlet object
======= fetch "public void setServletClassLastModifiedTime(long lastModified) {" 2570d6ff^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        // DCL requires servletClassLastModifiedTime be volatile
        // to force read and write barriers on access/set
        // (and to get atomic write of long)

    protected static final int CACHE_SIZE = 
    protected static final SimpleDateFormat format = 
    protected static final SimpleDateFormat formats[] = {
    protected final static TimeZone gmtZone = TimeZone.getTimeZone("GMT");
    protected static long currentDateGenerated = 0L;
    protected static String currentDate = null;
    protected static final ConcurrentHashMap<Long, String> formatCache = 
    protected static final ConcurrentHashMap<String, Long> parseCache = 
======= fetch "public static final String getCurrentDate() {" 0ae33cb^:"java/org/apache/tomcat/util/http/FastHttpDateFormat.java"

                    currentDateGenerated = now;
======= fetch "public static final String getCurrentDate() {" 0ae33cb^:"java/org/apache/tomcat/util/http/FastHttpDateFormat.java"

                    currentDateGenerated = now;

    implements ProtocolHandler, MBeanRegistration {
    /**
     * The string manager for this package.
     */
    protected static final StringManager sm =
        StringManager.getManager(Constants.Package);
======= fetch "public AjpAprProtocol() {" 654c964^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

        endpoint = new AprEndpoint();
======= fetch "public AjpAprProtocol() {" 654c964^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    protected ObjectName tpOname;
    
    
    protected ObjectName rgOname;
    /**
     * Associated APR endpoint.
     */
    protected AprEndpoint endpoint = new AprEndpoint();
    /**
     * Configuration attributes.
     */
    protected Hashtable<String,Object> attributes =
        new Hashtable<String,Object>();
    /**
     * Adapter which will process the requests received by this endpoint.
     */
    private Adapter adapter;
    
    
======= fetch "public AjpAprProtocol() {" 654c964^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    /** 
     * Pass config info
     */
    @Override
    public void setAttribute(String name, Object value) {
        if (log.isTraceEnabled()) {
            log.trace(sm.getString("ajpprotocol.setattribute", name, value));
        }
        attributes.put(name, value);
    }
    @Override
    public Object getAttribute(String key) {
        if (log.isTraceEnabled()) {
            log.trace(sm.getString("ajpprotocol.getattribute", key));
        }
        return attributes.get(key);
    }
    @Override
    public Iterator<String> getAttributeNames() {
        return attributes.keySet().iterator();
    }
    /**
     * The adapter, used to call the connector
     */
    @Override
    public void setAdapter(Adapter adapter) {
        this.adapter = adapter;
    }
    @Override
    public Adapter getAdapter() {
        return adapter;
    }
======= fetch "public void init() throws Exception {" 654c964^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

        endpoint.setHandler(cHandler);
        endpoint.setUseSendfile(false);
======= fetch "public void start() throws Exception {" 654c964^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    @Override
    public void pause() throws Exception {
        try {
            endpoint.pause();
        } catch (Exception ex) {
            log.error(sm.getString("ajpprotocol.endpoint.pauseerror"), ex);
            throw ex;
        }
        if (log.isInfoEnabled())
            log.info(sm.getString("ajpprotocol.pause", getName()));
    }
    @Override
    public void resume() throws Exception {
        try {
            endpoint.resume();
        } catch (Exception ex) {
            log.error(sm.getString("ajpprotocol.endpoint.resumeerror"), ex);
            throw ex;
        }
        if (log.isInfoEnabled())
            log.info(sm.getString("ajpprotocol.resume", getName()));
    }
    @Override
    public void stop() throws Exception {
        try {
            endpoint.stop();
        } catch (Exception ex) {
            log.error(sm.getString("ajpprotocol.endpoint.stoperror"), ex);
            throw ex;
        }
        if (log.isInfoEnabled())
            log.info(sm.getString("ajpprotocol.stop", getName()));
    }
    @Override
    public void destroy() throws Exception {
        if (log.isInfoEnabled())
            log.info(sm.getString("ajpprotocol.destroy", getName()));
        endpoint.destroy();
        if (tpOname!=null)
            Registry.getRegistry(null, null).unregisterComponent(tpOname);
        if (rgOname != null)
            Registry.getRegistry(null, null).unregisterComponent(rgOname);
    }
    // *
    public String getName() {
        String encodedAddr = "";
        if (getAddress() != null) {
            encodedAddr = "" + getAddress();
            if (encodedAddr.startsWith("/"))
                encodedAddr = encodedAddr.substring(1);
            encodedAddr = URLEncoder.encode(encodedAddr) + "-";
        }
        return ("ajp-" + encodedAddr + endpoint.getPort());
    }
    /**
     * Processor cache.
     */
    protected int processorCache = -1;
    public int getProcessorCache() { return this.processorCache; }
    public void setProcessorCache(int processorCache) { this.processorCache = processorCache; }
    @Override
    public Executor getExecutor() { return endpoint.getExecutor(); }
    public void setExecutor(Executor executor) { endpoint.setExecutor(executor); }
    
    public int getMaxThreads() { return endpoint.getMaxThreads(); }
    public void setMaxThreads(int maxThreads) { endpoint.setMaxThreads(maxThreads); }
    public int getThreadPriority() { return endpoint.getThreadPriority(); }
    public void setThreadPriority(int threadPriority) { endpoint.setThreadPriority(threadPriority); }
    public int getBacklog() { return endpoint.getBacklog(); }
    public void setBacklog(int backlog) { endpoint.setBacklog(backlog); }
    public int getPort() { return endpoint.getPort(); }
    public void setPort(int port) { endpoint.setPort(port); }
    public InetAddress getAddress() { return endpoint.getAddress(); }
    public void setAddress(InetAddress ia) { endpoint.setAddress(ia); }
    public boolean getTcpNoDelay() { return endpoint.getTcpNoDelay(); }
    public void setTcpNoDelay(boolean tcpNoDelay) { endpoint.setTcpNoDelay(tcpNoDelay); }
    public int getSoLinger() { return endpoint.getSoLinger(); }
    public void setSoLinger(int soLinger) { endpoint.setSoLinger(soLinger); }
    public int getSoTimeout() { return endpoint.getSoTimeout(); }
    public void setSoTimeout(int soTimeout) { endpoint.setSoTimeout(soTimeout); }
    /**
     * Should authentication be done in the native webserver layer, 
     * or in the Servlet container ?
     */
    protected boolean tomcatAuthentication = true;
    public boolean getTomcatAuthentication() { return tomcatAuthentication; }
    public void setTomcatAuthentication(boolean tomcatAuthentication) { this.tomcatAuthentication = tomcatAuthentication; }
    /**
     * Required secret.
     */
    protected String requiredSecret = null;
    public void setRequiredSecret(String requiredSecret) { this.requiredSecret = requiredSecret; }
    
    /**
     * AJP packet size.
     */
    protected int packetSize = Constants.MAX_PACKET_SIZE;
    public int getPacketSize() { return packetSize; }
    public void setPacketSize(int packetSize) {
        if(packetSize < Constants.MAX_PACKET_SIZE) {
            this.packetSize = Constants.MAX_PACKET_SIZE;
        } else {
            this.packetSize = packetSize;
        }
    }
    /**
     * The number of seconds Tomcat will wait for a subsequent request
     * before closing the connection.
     */
    public int getKeepAliveTimeout() { return endpoint.getKeepAliveTimeout(); }
    public void setKeepAliveTimeout(int timeout) { endpoint.setKeepAliveTimeout(timeout); }
======= fetch "public void setUseSendfile(@SuppressWarnings("unused") boolean useSendfile) {" 654c964^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    public int getPollTime() { return endpoint.getPollTime(); }
    public void setPollTime(int pollTime) { endpoint.setPollTime(pollTime); }
======= fetch "public void setUseSendfile(@SuppressWarnings("unused") boolean useSendfile) {" 654c964^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    public void setPollerSize(int pollerSize) { endpoint.setPollerSize(pollerSize); }
    public int getPollerSize() { return endpoint.getPollerSize(); }
======= fetch "public SocketState asyncDispatch(SocketWrapper<Long> socket, SocketStatus status" 654c964^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

                            proto.endpoint.getPoller().add(socket.getSocket().longValue());
======= fetch "protected AjpAprProcessor createProcessor() {" 654c964^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

            AjpAprProcessor processor = new AjpAprProcessor(proto.packetSize, proto.endpoint);
======= fetch "protected void unregister(AjpAprProcessor processor) {" 654c964^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    // -------------------- Various implementation classes --------------------
    protected String domain;
    protected ObjectName oname;
    protected MBeanServer mserver;
    public ObjectName getObjectName() {
        return oname;
    }
    public String getDomain() {
        return domain;
    }
    @Override
    public ObjectName preRegister(MBeanServer server,
                                  ObjectName name) throws Exception {
        oname=name;
        mserver=server;
        domain=name.getDomain();
        return name;
    }
    @Override
    public void postRegister(Boolean registrationDone) {
        // NOOP
    }
    @Override
    public void preDeregister() throws Exception {
        // NOOP
    }
    @Override
    public void postDeregister() {
        // NOOP
    }
    implements ProtocolHandler, MBeanRegistration {
    /**
     * The string manager for this package.
     */
    protected static final StringManager sm =
        StringManager.getManager(Constants.Package);
======= fetch "public AjpProtocol() {" 654c964^:"java/org/apache/coyote/ajp/AjpProtocol.java"

        endpoint = new JIoEndpoint();
======= fetch "public AjpProtocol() {" 654c964^:"java/org/apache/coyote/ajp/AjpProtocol.java"

    protected ObjectName tpOname;
    
    
    protected ObjectName rgOname;
    /**
     * Associated java.io endpoint.
     */
    protected JIoEndpoint endpoint = new JIoEndpoint();
    /**
     * Configuration attributes.
     */
    protected Hashtable<String,Object> attributes =
        new Hashtable<String,Object>();
    /**
     * Adapter which will process the requests received by this endpoint.
     */
    private Adapter adapter;
    
======= fetch "public AjpProtocol() {" 654c964^:"java/org/apache/coyote/ajp/AjpProtocol.java"

    /** 
     * Pass config info
     */
    @Override
    public void setAttribute(String name, Object value) {
        if (log.isTraceEnabled()) {
            log.trace(sm.getString("ajpprotocol.setattribute", name, value));
        }
        attributes.put(name, value);
    }
    @Override
    public Object getAttribute(String key) {
        if (log.isTraceEnabled()) {
            log.trace(sm.getString("ajpprotocol.getattribute", key));
        }
        return attributes.get(key);
    }
    @Override
    public Iterator<String> getAttributeNames() {
        return attributes.keySet().iterator();
    }
    /**
     * The adapter, used to call the connector
     */
    @Override
    public void setAdapter(Adapter adapter) {
        this.adapter = adapter;
    }
    @Override
    public Adapter getAdapter() {
        return adapter;
    }
======= fetch "public void init() throws Exception {" 654c964^:"java/org/apache/coyote/ajp/AjpProtocol.java"

        endpoint.setHandler(cHandler);
======= fetch "public void start() throws Exception {" 654c964^:"java/org/apache/coyote/ajp/AjpProtocol.java"

    @Override
    public void pause() throws Exception {
        try {
            endpoint.pause();
        } catch (Exception ex) {
            log.error(sm.getString("ajpprotocol.endpoint.pauseerror"), ex);
            throw ex;
        }
        if (log.isInfoEnabled())
            log.info(sm.getString("ajpprotocol.pause", getName()));
    }
    @Override
    public void resume() throws Exception {
        try {
            endpoint.resume();
        } catch (Exception ex) {
            log.error(sm.getString("ajpprotocol.endpoint.resumeerror"), ex);
            throw ex;
        }
        if (log.isInfoEnabled())
            log.info(sm.getString("ajpprotocol.resume", getName()));
    }
    @Override
    public void stop() throws Exception {
        try {
            endpoint.stop();
        } catch (Exception ex) {
            log.error(sm.getString("ajpprotocol.endpoint.stoperror"), ex);
            throw ex;
        }
        if (log.isInfoEnabled())
            log.info(sm.getString("ajpprotocol.stop", getName()));
    }
    @Override
    public void destroy() throws Exception {
        if (log.isInfoEnabled())
            log.info(sm.getString("ajpprotocol.destroy", getName()));
        endpoint.destroy();
        if (tpOname!=null)
            Registry.getRegistry(null, null).unregisterComponent(tpOname);
        if (rgOname != null)
            Registry.getRegistry(null, null).unregisterComponent(rgOname);
    }
    // *
    public String getName() {
        String encodedAddr = "";
        if (getAddress() != null) {
            encodedAddr = "" + getAddress();
            if (encodedAddr.startsWith("/"))
                encodedAddr = encodedAddr.substring(1);
            encodedAddr = URLEncoder.encode(encodedAddr) + "-";
        }
        return ("ajp-" + encodedAddr + endpoint.getPort());
    }
    /**
     * Processor cache.
     */
    protected int processorCache = -1;
    public int getProcessorCache() { return this.processorCache; }
    public void setProcessorCache(int processorCache) { this.processorCache = processorCache; }
    @Override
    public Executor getExecutor() { return endpoint.getExecutor(); }
    public void setExecutor(Executor executor) { endpoint.setExecutor(executor); }
    
    public int getMaxThreads() { return endpoint.getMaxThreads(); }
    public void setMaxThreads(int maxThreads) { endpoint.setMaxThreads(maxThreads); }
    public int getThreadPriority() { return endpoint.getThreadPriority(); }
    public void setThreadPriority(int threadPriority) { endpoint.setThreadPriority(threadPriority); }
    public int getBacklog() { return endpoint.getBacklog(); }
    public void setBacklog(int backlog) { endpoint.setBacklog(backlog); }
    public int getPort() { return endpoint.getPort(); }
    public void setPort(int port) { endpoint.setPort(port); }
    public InetAddress getAddress() { return endpoint.getAddress(); }
    public void setAddress(InetAddress ia) { endpoint.setAddress(ia); }
    public boolean getTcpNoDelay() { return endpoint.getTcpNoDelay(); }
    public void setTcpNoDelay(boolean tcpNoDelay) { endpoint.setTcpNoDelay(tcpNoDelay); }
    public int getSoLinger() { return endpoint.getSoLinger(); }
    public void setSoLinger(int soLinger) { endpoint.setSoLinger(soLinger); }
    public int getSoTimeout() { return endpoint.getSoTimeout(); }
    public void setSoTimeout(int soTimeout) { endpoint.setSoTimeout(soTimeout); }
    /**
     * Should authentication be done in the native webserver layer, 
     * or in the Servlet container ?
     */
    protected boolean tomcatAuthentication = true;
    public boolean getTomcatAuthentication() { return tomcatAuthentication; }
    public void setTomcatAuthentication(boolean tomcatAuthentication) { this.tomcatAuthentication = tomcatAuthentication; }
    /**
     * Required secret.
     */
    protected String requiredSecret = null;
    public void setRequiredSecret(String requiredSecret) { this.requiredSecret = requiredSecret; }
    
    /**
     * AJP packet size.
     */
    protected int packetSize = Constants.MAX_PACKET_SIZE;
    public int getPacketSize() { return packetSize; }
    public void setPacketSize(int packetSize) {
        if(packetSize < Constants.MAX_PACKET_SIZE) {
            this.packetSize = Constants.MAX_PACKET_SIZE;
        } else {
            this.packetSize = packetSize;
        }
    }
    
    /**
     * The number of seconds Tomcat will wait for a subsequent request
     * before closing the connection.
     */
    protected int keepAliveTimeout = -1;
    public int getKeepAliveTimeout() { return keepAliveTimeout; }
    public void setKeepAliveTimeout(int timeout) { keepAliveTimeout = timeout; }
======= fetch "protected AjpProcessor createProcessor() {" 654c964^:"java/org/apache/coyote/ajp/AjpProtocol.java"

            AjpProcessor processor = new AjpProcessor(proto.packetSize, proto.endpoint);
======= fetch "protected void unregister(AjpProcessor processor) {" 654c964^:"java/org/apache/coyote/ajp/AjpProtocol.java"

    // -------------------- Various implementation classes --------------------
    protected String domain;
    protected ObjectName oname;
    protected MBeanServer mserver;
    public ObjectName getObjectName() {
        return oname;
    }
    public String getDomain() {
        return domain;
    }
    @Override
    public ObjectName preRegister(MBeanServer server,
                                  ObjectName name) throws Exception {
        oname=name;
        mserver=server;
        domain=name.getDomain();
        return name;
    }
    @Override
    public void postRegister(Boolean registrationDone) {
        // NOOP
    }
    @Override
    public void preDeregister() throws Exception {
        // NOOP
    }
    @Override
    public void postDeregister() {
        // NOOP
    }

======= fetch "protected static void lookupFieldResource(Context context," 0e71157^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

        if ((name != null) &&
                (name.length() > 0)) {
            lookedupResource = context.lookup(name);
======= fetch "protected static void lookupMethodResource(Context context," 0e71157^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

        if ((name != null) &&
                (name.length() > 0)) {
            lookedupResource = context.lookup(name);
======= fetch "public static String getName(Method setter) {" 0e71157^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

    
    private static String normalize(String jndiName){
        if(jndiName != null && jndiName.startsWith("java:comp/env/")){
            return jndiName.substring(14);
        }
        return jndiName;
    }
      <fix>
        <bug>49956</bug>: Handle case when @Resource annotation uses the full
        JNDI name for a resource. Based on a patch by Gurkan Erdogdu. (markt) 
      </fix>

======= fetch "public boolean listenerStart() {" 937227a^:"java/org/apache/catalina/core/StandardContext.java"

        //Listeners may have been added by ServletContextInitializers.  Put them after the ones we know about.
        for (Object eventListener: getApplicationEventListeners()) {
            eventListeners.add(eventListener);
        }
======= fetch "public boolean listenerStart() {" 937227a^:"java/org/apache/catalina/core/StandardContext.java"

        for (Object lifecycleListener: getApplicationLifecycleListeners()) {
            lifecycleListeners.add(lifecycleListener);
        }
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
    /**
     * Check that a ServletContainerInitializer can install a
     * {@link ServletContextListener} and that it gets initialized.
     * @throws Exception
     */
    public void testServletContainerInitializer() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        Context context = tomcat.addContext("/",
                System.getProperty("java.io.tmpdir"));
        context.addServletContainerInitializer(new SCI(), null);
        tomcat.start();
        assertTrue(SCL.initialized);
    }
    /**
     * Check that a {@link ServletContextListener} cannot install a
     * {@link ServletContextInitializer}.
     * @throws Exception
     */
    public void testServletContextListener() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        Context context = tomcat.addContext("/",
                System.getProperty("java.io.tmpdir"));
        // SCL2 pretends to be in web.xml, and tries to install a
        // ServletContextInitializer.
        context.addApplicationListener(SCL2.class.getName());
        tomcat.start();
        //check that the ServletContextInitializer wasn't initialized.
        assertFalse(SCL3.initialized);
    }
    public static class SCI implements ServletContainerInitializer {
        @Override
        public void onStartup(Set<Class<?>> c, ServletContext ctx)
                throws ServletException {
            ctx.addListener(new SCL());
        }
    }
    public static class SCL implements ServletContextListener {
        static boolean initialized = false;
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            initialized = true;
        }
        @Override
        public void contextDestroyed(ServletContextEvent sce) {
            // NOOP
        }
    }
    
    public static class SCL2 implements ServletContextListener {
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            ServletContext sc = sce.getServletContext();
            sc.addListener(SCL3.class.getName());
        }
        @Override
        public void contextDestroyed(ServletContextEvent sce) {
            // NOOP
        }
    }
    public static class SCL3 implements ServletContextListener {
        static boolean initialized = false;
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            initialized = true;
        }
        @Override
        public void contextDestroyed(ServletContextEvent sce) {
            // NOOP
        }
    }
      <fix>
        <bug>49952</bug>: Allow ServletContainerInitializers to add listeners to
        a web application. Patch provided by David Jencks. (markt)
      </fix>

    
======= fetch "public void addListener(AsyncListener listener, ServletRequest servletRequest," cf4e575^:"java/org/apache/catalina/core/AsyncContextImpl.java"

    @SuppressWarnings("unchecked")
======= fetch "public void addListener(AsyncListener listener, ServletRequest servletRequest," cf4e575^:"java/org/apache/catalina/core/AsyncContextImpl.java"

             listener = clazz.newInstance();
======= fetch "public void addListener(AsyncListener listener, ServletRequest servletRequest," cf4e575^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        } catch (InvocationTargetException e) {
            ServletException se = new ServletException(e);
            throw se;
        } catch (NamingException e) {
            ServletException se = new ServletException(e);
            throw se;
        } catch (ClassNotFoundException e) {
            ServletException se = new ServletException(e);
            throw se;
======= fetch "private void logDebug(String method) {" cf4e575^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        filter matches more than one URL pattern and/or Servlet name.

======= fetch "public AstFloatingPoint(int id) {" b893eee^:"java/org/apache/el/parser/AstFloatingPoint.java"

    private Number number;
======= fetch "public AstInteger(int id) {" b893eee^:"java/org/apache/el/parser/AstInteger.java"

    private Number number;
======= fetch "public AstString(int id) {" b893eee^:"java/org/apache/el/parser/AstString.java"

    private String string;

======= fetch "public String toString() {" 5eb3851^:"java/org/apache/catalina/core/StandardServer.java"

     * @exception javax.management.InstanceNotFoundException if the managed resource object
     *  cannot be found
     * @exception javax.management.MBeanException if the initializer of the object throws
     *  an exception, or persistence is not supported
     * @exception javax.management.RuntimeOperationsException if an exception is reported
     *  by the persistence mechanism
======= fetch "public synchronized void storeConfig() throws Exception {" 5eb3851^:"java/org/apache/catalina/core/StandardServer.java"

        ObjectName sname = null;    
        try {
           sname = new ObjectName("Catalina:type=StoreConfig");
           if(mserver.isRegistered(sname)) {
               mserver.invoke(sname, "storeConfig", null, null);            
           } else
               log.error("StoreConfig mbean not registered" + sname);
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            log.error(t);
        }

======= fetch "public void startQueue() {" 2c858be^:"java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java"

        executor = new ThreadPoolExecutor(maxSpareThreads,maxThreads,keepAliveTime,TimeUnit.MILLISECONDS,runnablequeue);

======= fetch "public String toString() {" f4de5ab^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        private static final int JVM_BUG_THRESHOLD = 16;
        private volatile int jvmBugCount = 0; 
        
======= fetch "public void run() {" f4de5ab^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                                long before = System.currentTimeMillis();
======= fetch "public void run() {" f4de5ab^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        Sylvain Laurent.

======= fetch "private JMXConnectorServer createServer(String serverName," 00cc8c6^:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

                    Integer.valueOf(theRmiRegistryPort),
                    Integer.valueOf(theRmiServerPort), serverName));

        // This will list all drivers visible to this class loader
            driverNames.add(driver.getClass().getCanonicalName());

======= fetch "public boolean getUseIPVHosts() {" 167829c^:"java/org/apache/catalina/connector/Connector.java"

    public String getExecutorName() {
        Object obj = protocolHandler.getExecutor();
        if (obj instanceof org.apache.catalina.Executor) {
            return ((org.apache.catalina.Executor) obj).getName();
        }
        return "Internal";
    }
    <attribute   name="executorName"
          description="The name of the executor - if any - associated with this Connector"
                 type="java.lang.String"
            writeable="false"/>
        <bug>49856</bug>: Add an executorName attribute to Connectors so it is
        possible to trace ThreadPool to Connector to Executor via the JMX
        interface. (markt)
      </fix>
      <fix>

======= fetch "public boolean offer(Runnable o) {" 2bfc300^:"java/org/apache/tomcat/util/threads/TaskQueue.java"

        if (parent.getActiveCount()<(parent.getPoolSize())) return super.offer(o);
 * getActiveCount method, to be used to properly handle the work queue
    private final AtomicInteger activeCount = new AtomicInteger(0);
======= fetch "protected void afterExecute(Runnable r, Throwable t) {" 2bfc300^:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

        activeCount.decrementAndGet();
    }
    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        activeCount.incrementAndGet();
======= fetch "protected void beforeExecute(Thread t, Runnable r) {" 2bfc300^:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

    @Override
    public int getActiveCount() {
        return activeCount.get();
======= fetch "public void execute(Runnable command, long timeout, TimeUnit unit) {" 2bfc300^:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

        submittedCount.incrementAndGet();
======= fetch "public void execute(Runnable command, long timeout, TimeUnit unit) {" 2bfc300^:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

                        submittedCount.decrementAndGet();
======= fetch "public void execute(Runnable command, long timeout, TimeUnit unit) {" 2bfc300^:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

                    submittedCount.decrementAndGet();
======= fetch "public void execute(Runnable command, long timeout, TimeUnit unit) {" 2bfc300^:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

                submittedCount.decrementAndGet();
        <bug>49730</bug>: Fix a race condition in StandardThreadExector that can
        cause requests to experience large delays. Patch provided by Sylvain
        Laurent. (markt)
      </fix>
      <fix>

======= fetch "private void initClassLoaders() {" 6c22816^:"java/org/apache/catalina/startup/Bootstrap.java"

            ExceptionUtils.handleThrowable(t);
======= fetch "public static void main(String args[]) {" 6c22816^:"java/org/apache/catalina/startup/Bootstrap.java"

                ExceptionUtils.handleThrowable(t);
======= fetch "public static void main(String args[]) {" 6c22816^:"java/org/apache/catalina/startup/Bootstrap.java"

            ExceptionUtils.handleThrowable(t);
======= fetch "public static String getCatalinaBase() {" 6c22816^:"java/org/apache/catalina/startup/Bootstrap.java"

    // Copied from ExceptionUtils since that class is not visible during start
    private static void handleThrowable(Throwable t) {
        if (t instanceof ThreadDeath) {
            throw (ThreadDeath) t;
        }
        if (t instanceof VirtualMachineError) {
            throw (VirtualMachineError) t;
        }
        // All other instances of Throwable will be silently swallowed
    }
      <fix>
        <bug>50021</bug>: Correct a regression in the fix for <bug>46844</bug>
        that may have caused additional problems during a failure at start up.
        (markt) 
      </fix>

======= fetch "public Compiler getCompiler () {" 2f8a27c^:"java/org/apache/jasper/compiler/ParserController.java"

     * @param jarFileUrl The JAR file from which to read the included resource,
======= fetch "public Compiler getCompiler () {" 2f8a27c^:"java/org/apache/jasper/compiler/ParserController.java"

     * @param tagFileJarUrl The location of the tag file.
======= fetch "public Compiler getCompiler () {" 2f8a27c^:"java/org/apache/jasper/compiler/ParserController.java"

     * @param jarFile The JAR file from which to read the JSP page or tag file,
======= fetch "void postCheck() throws JasperException {" 2f8a27c^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

     * @param tagFileJarUrl
     *            the url for the Jar containing the tag file 

======= fetch "public void stopServer(String[] arguments) {" 7c6b1a5^:"java/org/apache/catalina/startup/Catalina.java"

        } else {
            // Server object already present. Must be running as a service
            // Shutdown hook will take care of clean-up
            System.exit(0);
        <bug>49195</bug>: Don't report an error when shutting down a Windows
        service for a Tomcat instance that has a disabled shutdown port. (markt)
      </fix>
      <fix>

======= fetch "public void visit(Node.GetProperty n) throws JasperException {" 7b24ed5^:"java/org/apache/jasper/compiler/Generator.java"

                StringBuilder msg =
                    new StringBuilder("jsp:getProperty for bean with name '");
======= fetch "private TagLibraryInfo getTaglibInfo(String prefix, String uri)" 7b24ed5^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

                            err);
======= fetch "private void parseTaglibDirective(Node parent) throws JasperException {" 7b24ed5^:"java/org/apache/jasper/compiler/Parser.java"

                                pageInfo, prefix, uri, location, err);
======= fetch "private InputStream getResourceAsStream(String uri)" 7b24ed5^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

    public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageInfo pi,
            String prefix, String uriIn, TldLocation location, ErrorDispatcher err)
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" 7b24ed5^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                    err.jspError("jsp.error.file.not.found", tldName);
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" 7b24ed5^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                    err.jspError("jsp.error.tld.unable_to_read", jarResource.getUrl(),

======= fetch "public Adapter getAdapter() {" 7435fa9^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

     * Check for compression
======= fetch "public Adapter getAdapter() {" 7435fa9^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

    protected boolean isCompressable() {
======= fetch "protected boolean isCompressable() {" 7435fa9^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        // Nope Compression could works in HTTP 1.0 also
        // cf: mod_deflate
======= fetch "protected boolean isCompressable() {" 7435fa9^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        // Compression only since HTTP 1.1
        // if (! http11)
        //    return false;
======= fetch "protected boolean isCompressable() {" 7435fa9^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        // Check if content is not already gzipped
        MessageBytes contentEncodingMB =
            response.getMimeHeaders().getValue("Content-Encoding");
        if ((contentEncodingMB != null)
            && (contentEncodingMB.indexOf("gzip") != -1))
            return false;
======= fetch "protected boolean isCompressable() {" 7435fa9^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        // Check if sufficient length to trigger the compression
        long contentLength = response.getContentLengthLong();
        if ((contentLength == -1)
            || (contentLength > compressionMinSize)) {
            // Check for compatible MIME-TYPE
            if (compressableMimeTypes != null) {
                return (startsWithStringArray(compressableMimeTypes,
                                              response.getContentType()));
            }
        }
        return false;
======= fetch "private void prepareResponse() {" 7435fa9^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        boolean isCompressable = false;
======= fetch "private void prepareResponse() {" 7435fa9^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

            useCompression = isCompressable();
======= fetch "private void prepareResponse() {" 7435fa9^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        }
        // If it might be compressed, set the Vary header
        if (isCompressable) {
        <bug>49625</bug>: Ensure Vary header is set if response may be
        compressed rather than only setting it if it is compressed. (markt)
      </fix>
      <fix>

======= fetch "private final void clearReferencesJdbc() {" d0d4c75^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                    classBytes, 0, offset);

======= fetch "protected void prepareRequest() {" fb5a3e7^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

            String methodName = Constants.methodTransArray[methodCode - 1];
======= fetch "protected void prepareRequest() {" fb5a3e7^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

                hName = Constants.headerTransArray[hId - 1];
======= fetch "protected void prepareRequest() {" fb5a3e7^:"java/org/apache/coyote/ajp/AjpProcessor.java"

            String methodName = Constants.methodTransArray[methodCode - 1];
======= fetch "protected void prepareRequest() {" fb5a3e7^:"java/org/apache/coyote/ajp/AjpProcessor.java"

                hName = Constants.headerTransArray[hId - 1];
    public static final String []methodTransArray = {
    public static final String []headerTransArray = {
    public static final String []responseTransArray = {
                responseTransHash.put(responseTransArray[i],

======= fetch "protected boolean filter(String name) {" 8dc0306^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * classes from J2SE (java.*) and classes of the servlet API 
======= fetch "protected boolean validate(String name) {" 8dc0306^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (name == null)
======= fetch "protected boolean validate(String name) {" 8dc0306^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (name.startsWith("java."))
======= fetch "protected boolean validate(String name) {" 8dc0306^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (name.startsWith("javax.servlet."))
======= fetch "protected boolean validate(String name) {" 8dc0306^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        }
======= fetch "protected boolean validate(String name) {" 8dc0306^:"java/org/apache/catalina/loader/WebappClassLoader.java"

      

======= fetch "public void objectMadePrimay(Object key, Object value) {" b255697^:"java/org/apache/catalina/ha/session/BackupManager.java"

                session.setPrimarySession(true);
======= fetch "public Object get(Object key) {" b255697^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    if ( entry.getValue() != null && entry.getValue() instanceof ReplicatedMapEntry ) {
                        ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();
                        val.setOwner(getMapOwner());   
                    }
======= fetch "public Object get(Object key) {" b255697^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                getMapOwner().objectMadePrimay(key, entry.getValue());
======= fetch "public Object get(Object key) {" b255697^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        if ( entry.getValue() != null && entry.getValue() instanceof ReplicatedMapEntry ) {
            ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();
            //hack, somehow this is not being set above
            val.setOwner(getMapOwner());
            
        }

    
    /**
     * Return the parent class loader.
     */
    public ClassLoader getParentClassLoader();
    
    /**
     * Return the outer Catalina startup/shutdown component if present.
     */
    public Catalina getCatalina();
    
    /**
     * Set the outer Catalina startup/shutdown component if present.
     */
    public void setCatalina(Catalina catalina);
    
    /**
     * Return the parent class loader.
     */
    public ClassLoader getParentClassLoader();
    
======= fetch "public void logAccess(Request request, Response response, long time," e0182ef^:"java/org/apache/catalina/core/StandardEngine.java"

    /**
     * Return the parent class loader for this component.
     */
    @Override
    public ClassLoader getParentClassLoader() {
        if (parentClassLoader != null)
            return (parentClassLoader);
        if (service != null) {
            return (service.getParentClassLoader());
        }
        return (ClassLoader.getSystemClassLoader());
    }
======= fetch "public StandardServer() {" e0182ef^:"java/org/apache/catalina/core/StandardServer.java"

    
    private Catalina catalina = null;
======= fetch "public void setShutdown(String shutdown) {" e0182ef^:"java/org/apache/catalina/core/StandardServer.java"

    /**
     * Return the outer Catalina startup/shutdown component if present.
     */
    @Override
    public Catalina getCatalina() {
        return catalina;
    }
    
    
    /**
     * Set the outer Catalina startup/shutdown component if present.
     */
    @Override
    public void setCatalina(Catalina catalina) {
        this.catalina = catalina;
    }
    
======= fetch "protected void destroyInternal() throws LifecycleException {" e0182ef^:"java/org/apache/catalina/core/StandardServer.java"

    /**
     * Return the parent class loader for this component.
     */
    @Override
    public ClassLoader getParentClassLoader() {
        if (catalina != null) {
            return (catalina.getParentClassLoader());
        }
        return (ClassLoader.getSystemClassLoader());
    }
======= fetch "protected void destroyInternal() throws LifecycleException {" e0182ef^:"java/org/apache/catalina/core/StandardService.java"

         type="org.apache.catalina.core.StandardContext">
      <parameter name="valve"
                 description="New valve to be added"
                 type="org.apache.catalina.Valve"/>
    <operation name="removeValve"
               description="Remove a valve from this Context"
      <parameter name="valve"
                 description="New valve to be removed"
                 type="org.apache.catalina.Valve"/>
    <operation name="addLifecycleListener"
               description="Add a lifecycle listener to this Context"
                 description="New lifecycle listener to be added"
                 type="org.apache.catalina.LifecycleListener"/>
    <operation name="removeLifecycleListener"
               description="Remove a lifecycle listener from this Context"
                 description="New lifecycle listener to be removed"
                 type="org.apache.catalina.LifecycleListener"/>
    <operation name="reload"
               description="Reload the webapplication"
    <operation name="destroy"
               description="Destroy the context"
    <operation name="findMappingObject"
               description="Return an object which may be utilized for mapping to this component"
               impact="INFO"
               returnType="org.apache.catalina.Context">    
    </operation>    
    <operation name="findStaticResources"
               description="Return the naming resources associated with this web application"
               impact="INFO"
               returnType="javax.naming.directory.DirContext">    
         group="Engine">
               writeable="false"/>           
      <parameter name="child"
                 description="Host object"
                 type="org.apache.catalina.Container"/>
    <operation name="start" description="Start" impact="ACTION" returnType="void" />
    <operation name="stop" description="Stop" impact="ACTION" returnType="void" />
         type="org.apache.catalina.core.StandardHost">
               type="boolean"/>   
      
    <operation name="addChild"
               description="Add a context"
               impact="ACTION">
      <parameter name="child"
                 description="Context to be added"
                 type="org.apache.catalina.Container"/>
    </operation>
      
    <operation name="start" description="Start" impact="ACTION" returnType="void" />
    <operation name="stop" description="Stop" impact="ACTION" returnType="void" />
    <operation name="init" description="Init" impact="ACTION" returnType="void" />
    <operation name="destroy" description="Destroy" impact="ACTION" returnType="void" />
    <operation name="findReloadedContextMemoryLeaks"
               description="Provide a list of contexts that have leaked memory on reload. This will attempt to force a full garbage collection. Use with extreme caution on production systems."
               returnType="[Ljava.lang.String;" />
         type="org.apache.catalina.core.StandardService">
    <attribute name="managedResource"
               description="The managed resource this MBean is associated with"
               type="java.lang.Object"/>
      
    <attribute name="name"
               description="Unique name of this Service"
               type="java.lang.String"/>
      
    <attribute name="container"
               description="Servlet engine that will process the requests"
               type="org.apache.catalina.Container" />
      <parameter name="connector"
                 description="Connector object"
                 type="org.apache.catalina.connector.Connector"/>
    <operation name="start" description="Start" impact="ACTION" returnType="void" />
    <operation name="stop" description="Stop" impact="ACTION" returnType="void" />
         type="org.apache.catalina.core.StandardWrapper">
        <operation name="addLifecycleListener"
               description="Add a lifecycle listener to this Context"
      <parameter name="listener"
                 description="New lifecycle listener to be added"
                 type="org.apache.catalina.LifecycleListener"/>
    <operation name="removeLifecycleListener"
               description="Remove a lifecycle listener from this Context"
                 description="New lifecycle listener to be removed"
                 type="org.apache.catalina.LifecycleListener"/>
======= fetch "public void setParentClassLoader(ClassLoader parentClassLoader) {" e0182ef^:"java/org/apache/catalina/startup/Catalina.java"

======= fetch "public void setParentClassLoader(ClassLoader parentClassLoader) {" e0182ef^:"java/org/apache/catalina/startup/Catalina.java"

======= fetch "public void setParentClassLoader(ClassLoader parentClassLoader) {" e0182ef^:"java/org/apache/catalina/startup/Catalina.java"

    public ClassLoader getParentClassLoader() {
        return parentClassLoader;
    }
======= fetch "public void load() {" e0182ef^:"java/org/apache/catalina/startup/Catalina.java"

        getServer().setCatalina(this);
      <fix>
        GSOC 2010. Enable the creation of Services, Engines, Connectors, Hosts
        and Contexts via JMX from a minimal server.xml that contains only a
        Server element. Based on a patch by Chamith Buddhika. (markt)
      </fix>
      

======= fetch "protected static void lookupMethodResource(Context context," 94147b2^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                || method.getName().length() < 4
======= fetch "protected static void lookupMethodResource(Context context," 94147b2^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                    clazz.getName() + "/" + method.getName().substring(3));
======= fetch "protected static void lookupMethodResource(Context context," 94147b2^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

        public static String getName(Method setter) {
            StringBuilder name = new StringBuilder(setter.getName());
            // remove 'set'
            name.delete(0, 3);
            // lowercase first char
            name.setCharAt(0, Character.toLowerCase(name.charAt(0)));
            return name.toString();
        }

======= fetch "private void disconnect(boolean finalize) {" 64a8346^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

                connection.close();

    /**
     * Descriptive information about this Realm implementation.
     */
    protected static final String name = "CombinedRealm";
======= fetch "protected String getName() {" a9f0fd5^:"java/org/apache/catalina/realm/CombinedRealm.java"

        // This method should never be called
        // Stack trace will show where this was called from
        UnsupportedOperationException uoe =
            new UnsupportedOperationException(
                    sm.getString("combinedRealm.getName"));
        log.error(sm.getString("combinedRealm.unexpectedMethod"), uoe);
        throw uoe;

======= fetch "protected void stopInternal() throws LifecycleException {" cd7263e^:"java/org/apache/catalina/connector/Connector.java"

        try {
            protocolHandler.stop();
        } catch (Exception e) {
            throw new LifecycleException
                (sm.getString
                 ("coyoteConnector.protocolHandlerStopFailed", e));
        }
======= fetch "public void addExecutor(Executor ex) {" cd7263e^:"java/org/apache/catalina/core/StandardService.java"

     * @param name String
======= fetch "public void addExecutor(Executor ex) {" cd7263e^:"java/org/apache/catalina/core/StandardService.java"

    public Executor getExecutor(String name) {
======= fetch "public Executor getExecutor(String name) {" cd7263e^:"java/org/apache/catalina/core/StandardService.java"

                if (name.equals(executor.getName()))
======= fetch "protected void stopInternal() throws LifecycleException {" cd7263e^:"java/org/apache/catalina/core/StandardService.java"

        // Stop our defined Connectors first
======= fetch "protected void stopInternal() throws LifecycleException {" cd7263e^:"java/org/apache/catalina/core/StandardService.java"

        // Heuristic: Sleep for a while to ensure pause of the connector
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            // Ignore
        }
======= fetch "protected void stopInternal() throws LifecycleException {" cd7263e^:"java/org/apache/catalina/core/StandardService.java"

        // FIXME pero -- Why container stop first? KeepAlive connections can send request! 
        // Stop our defined Connectors first
======= fetch "protected void stopInternal() throws LifecycleException {" cd7263e^:"java/org/apache/catalina/core/StandardService.java"

                if (LifecycleState.INITIALIZED.equals(
======= fetch "protected void stopInternal() throws LifecycleException {" cd7263e^:"java/org/apache/catalina/core/StandardService.java"

                    // If Service fails to start, connectors may not have been
                    // started
======= fetch "public boolean process(long socket)" cd7263e^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

        while (started && !error) {
======= fetch "public boolean process(long socket)" cd7263e^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

        if (!error) {
======= fetch "public boolean process(long socket)" cd7263e^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

        if (!async || error)
======= fetch "public void resume() throws Exception {" cd7263e^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    public void destroy() throws Exception {
======= fetch "public void destroy() throws Exception {" cd7263e^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    }
    public void destroy() throws Exception {
        if (log.isInfoEnabled())
            log.info(sm.getString("ajpprotocol.destroy", getName()));
======= fetch "public SocketState process(SocketWrapper<Socket> socket)" cd7263e^:"java/org/apache/coyote/ajp/AjpProcessor.java"

        while (started && !error) {
======= fetch "public SocketState process(SocketWrapper<Socket> socket)" cd7263e^:"java/org/apache/coyote/ajp/AjpProcessor.java"

        if (async && !error) {
======= fetch "public void resume() throws Exception {" cd7263e^:"java/org/apache/coyote/ajp/AjpProtocol.java"

    public void destroy() throws Exception {
======= fetch "public void destroy() throws Exception {" cd7263e^:"java/org/apache/coyote/ajp/AjpProtocol.java"

    }
    public void destroy() throws Exception {
        if (log.isInfoEnabled())
            log.info(sm.getString("ajpprotocol.destroy", getName()));
======= fetch "public void resume() throws Exception {" cd7263e^:"java/org/apache/coyote/http11/AbstractHttp11Protocol.java"

    public void destroy() throws Exception {
======= fetch "public void destroy() throws Exception {" cd7263e^:"java/org/apache/coyote/http11/AbstractHttp11Protocol.java"

    }
    @Override
    public void destroy() throws Exception {
        if(getLog().isInfoEnabled())
            getLog().info(sm.getString("http11protocol.destroy", getName()));
======= fetch "public SocketState process(long socket)" cd7263e^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        while (!error && keepAlive && !comet && !async) {
======= fetch "public SocketState process(long socket)" cd7263e^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        if (comet  || async) {
            if (error) {
                inputBuffer.nextRequest();
                outputBuffer.nextRequest();
                recycle();
                return SocketState.CLOSED;
            } else {
                return SocketState.LONG;
            }
======= fetch "public SocketState process(NioChannel socket)" cd7263e^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

        while (!error && keepAlive && !comet && !async) {
======= fetch "public SocketState process(NioChannel socket)" cd7263e^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

        if (comet || async) {
            if (error) {
                recycle();
                return SocketState.CLOSED;
            } else {
                return SocketState.LONG;
            }
======= fetch "public SocketState process(NioChannel socket)" cd7263e^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            if ( recycle ) {
======= fetch "public SocketState process(SocketWrapper<Socket> socketWrapper)" cd7263e^:"java/org/apache/coyote/http11/Http11Processor.java"

        while (started && !error && keepAlive) {
======= fetch "public SocketState process(SocketWrapper<Socket> socketWrapper)" cd7263e^:"java/org/apache/coyote/http11/Http11Processor.java"

        if (error) {
======= fetch "protected void unlockAccept() {" cd7263e^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    public abstract void pause();
    public abstract void resume();
======= fetch "protected void unlockAccept() {" cd7263e^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    
    /**
     * Pause the endpoint, which will stop it accepting new connections.
     */
    public void pause() {
        if (running && !paused) {
            paused = true;
            unlockAccept();
            // Heuristic: Sleep for a while to ensure pause of the endpoint
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // Ignore
            }
        }
    }
    
    /**
     * Resume the endpoint, which will make it start accepting new connections
     * again.
     */
    public void resume() {
        if (running) {
            paused = false;
        }
    }
    
    public abstract void stop() throws Exception;
======= fetch "protected void unlockAccept() {" cd7263e^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    public abstract void init() throws Exception;
======= fetch "protected void unlockAccept() {" cd7263e^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

     * Pause the endpoint, which will make it stop accepting new sockets.
     */
    @Override
    public void pause() {
        if (running && !paused) {
            paused = true;
            unlockAccept();
        }
    }
    /**
     * Resume the endpoint, which will make it start accepting new sockets
     * again.
     */
    @Override
    public void resume() {
        if (running) {
            paused = false;
        }
    }
    /**
======= fetch "public void stop() {" cd7263e^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        if (!paused) {
            pause();
        }
======= fetch "protected boolean processSocketWithOptions(long socket) {" cd7263e^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            getExecutor().execute(new SocketWithOptionsProcessor(socket));
======= fetch "public void start() throws Exception {" cd7263e^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

    public void pause() {
        if (running && !paused) {
            paused = true;
            unlockAccept();
        }
    }
    @Override
    public void resume() {
        if (running) {
            paused = false;
        }
    }
======= fetch "public void stop() {" cd7263e^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

        if (!paused) {
            pause();
        }
======= fetch "protected boolean processSocket(Socket socket) {" cd7263e^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

            getExecutor().execute(new SocketProcessor(wrapper));
======= fetch "public int getKeepAliveCount() {" cd7263e^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    /**
     * Return the state of the endpoint.
     *
     * @return true if the endpoint is running, false otherwise
     */
    @Override
    public boolean isRunning() {
        return running;
    }
    /**
     * Return the state of the endpoint.
     *
     * @return true if the endpoint is paused, false otherwise
     */
    @Override
    public boolean isPaused() {
        return paused;
    }
======= fetch "public void start()" cd7263e^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

     * Pause the endpoint, which will make it stop accepting new sockets.
     */
    @Override
    public void pause() {
        if (running && !paused) {
            paused = true;
            unlockAccept();
        }
    }
    /**
     * Resume the endpoint, which will make it start accepting new sockets
     * again.
     */
    @Override
    public void resume() {
        if (running) {
            paused = false;
        }
    }
    /**
======= fetch "public void stop() {" cd7263e^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        if (!paused) {
            pause();
        }
      <fix>
        <bug>49802</bug>: Re-factor connector pause, stop and destroy methods so
        that calling any of those methods has the expected results. (markt)
      </fix>

    private List element_value_pairs;
======= fetch "public static AnnotationEntry read(DataInputStream file, ConstantPool constant_p" 6155a8b^:"java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java"

        annotationEntry.element_value_pairs = new ArrayList();
======= fetch "public String getAnnotationType() {" 6155a8b^:"java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java"

        return (ElementValuePair[]) element_value_pairs.toArray(new ElementValuePair[element_value_pairs.size()]);
======= fetch "public void dump(DataOutputStream dos) throws IOException" 6155a8b^:"java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java"

            ElementValuePair envp = (ElementValuePair) element_value_pairs.get(i);
======= fetch "public void dump(DataOutputStream file) throws IOException" 6155a8b^:"java/org/apache/tomcat/util/bcel/classfile/Attribute.java"

    private static final Map readers = new HashMap();
======= fetch "public static final Attribute readAttribute(DataInputStream file," 6155a8b^:"java/org/apache/tomcat/util/bcel/classfile/Attribute.java"

            AttributeReader r = (AttributeReader) readers.get(name);
======= fetch "public JavaClass(int class_name_index, int superclass_name_index, String file_na" 6155a8b^:"java/org/apache/tomcat/util/bcel/classfile/JavaClass.java"

            List accumulatedAnnotations = new ArrayList();
======= fetch "public JavaClass(int class_name_index, int superclass_name_index, String file_na" 6155a8b^:"java/org/apache/tomcat/util/bcel/classfile/JavaClass.java"

            annotations = (AnnotationEntry[])accumulatedAnnotations.toArray(new AnnotationEntry[accumulatedAnnotations.size()]);
======= fetch "public boolean equals( Object obj ) {" 6155a8b^:"java/org/apache/tomcat/util/bcel/classfile/JavaClass.java"

    public int compareTo( Object obj ) {
        return getClassName().compareTo(((JavaClass) obj).getClassName());
    private static final Map unknown_attributes = new HashMap();
    private static int unwrap( ThreadLocal tl ) {
        return ((Integer) tl.get()).intValue();
======= fetch "private static int unwrap( ThreadLocal tl ) {" 6155a8b^:"java/org/apache/tomcat/util/bcel/classfile/Utility.java"

    private static void wrap( ThreadLocal tl, int value ) {
======= fetch "private static void wrap( ThreadLocal tl, int value ) {" 6155a8b^:"java/org/apache/tomcat/util/bcel/classfile/Utility.java"

    private static ThreadLocal consumed_chars = new ThreadLocal() {
======= fetch "private static void wrap( ThreadLocal tl, int value ) {" 6155a8b^:"java/org/apache/tomcat/util/bcel/classfile/Utility.java"

        protected Object initialValue() {

======= fetch "public WebappClassLoader() {" a6620cb^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * Construct a new ClassLoader with no defined repositories and no
======= fetch "public WebappClassLoader() {" a6620cb^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     *
     * @param parent Our parent class loader

    /**
     * Name of the system property containing
     * the tomcat product installation path
     */
    public static final String CATALINA_HOME_PROP = "catalina.home";
    /**
     * Name of the system property containing
     * the tomcat instance installation path
     */
    public static final String CATALINA_BASE_PROP = "catalina.base";
======= fetch "protected void initInternal() throws LifecycleException {" bcb994c^:"java/org/apache/catalina/connector/Connector.java"

                                       System.getProperty("catalina.base"));
======= fetch "protected File engineBase() {" bcb994c^:"java/org/apache/catalina/core/StandardContext.java"

        String base=System.getProperty("catalina.base");
======= fetch "public File getConfigBase() {" bcb994c^:"java/org/apache/catalina/core/StandardContext.java"

            new File(System.getProperty("catalina.base"), "conf");
======= fetch "public void start() throws Exception {" bcb994c^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

        configBase = new File(System.getProperty("catalina.base"), "conf");
======= fetch "protected File getAppBase() {" bcb994c^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            file = new File(System.getProperty("catalina.base"), host
======= fetch "public void init() throws ServletException {" bcb994c^:"java/org/apache/catalina/manager/ManagerServlet.java"

            deployed = new File(System.getProperty("catalina.base"),
======= fetch "public void init() throws ServletException {" bcb994c^:"java/org/apache/catalina/manager/ManagerServlet.java"

        configBase = new File(System.getProperty("catalina.base"), "conf");
======= fetch "protected File getAppBase() {" bcb994c^:"java/org/apache/catalina/manager/ManagerServlet.java"

            file = new File(System.getProperty("catalina.base"),
======= fetch "public void init() throws ServletException {" bcb994c^:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

            file = new File(System.getProperty("catalina.base"), file.getPath());
======= fetch "protected File getConfigBase(String hostName) {" bcb994c^:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

            new File(System.getProperty("catalina.base"), "conf");
======= fetch "protected void load() {" bcb994c^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

            file = new File(System.getProperty("catalina.base"), pathname);
======= fetch "protected void startInternal() throws LifecycleException {" bcb994c^:"java/org/apache/catalina/realm/MemoryRealm.java"

            file = new File(System.getProperty("catalina.base"), pathname);
    protected static final String CATALINA_HOME_TOKEN = "${catalina.home}";
    protected static final String CATALINA_BASE_TOKEN = "${catalina.base}";
======= fetch "public void setCatalinaHome(String s) {" bcb994c^:"java/org/apache/catalina/startup/Bootstrap.java"

        System.setProperty( "catalina.home", s );
======= fetch "public void setCatalinaBase(String s) {" bcb994c^:"java/org/apache/catalina/startup/Bootstrap.java"

        System.setProperty( "catalina.base", s );
======= fetch "private void setCatalinaBase() {" bcb994c^:"java/org/apache/catalina/startup/Bootstrap.java"

        if (System.getProperty("catalina.base") != null)
======= fetch "private void setCatalinaBase() {" bcb994c^:"java/org/apache/catalina/startup/Bootstrap.java"

        if (System.getProperty("catalina.home") != null)
            System.setProperty("catalina.base",
                               System.getProperty("catalina.home"));
======= fetch "private void setCatalinaBase() {" bcb994c^:"java/org/apache/catalina/startup/Bootstrap.java"

            System.setProperty("catalina.base",
======= fetch "private void setCatalinaHome() {" bcb994c^:"java/org/apache/catalina/startup/Bootstrap.java"

        if (System.getProperty("catalina.home") != null)
======= fetch "private void setCatalinaHome() {" bcb994c^:"java/org/apache/catalina/startup/Bootstrap.java"

                    ("catalina.home", 
======= fetch "private void setCatalinaHome() {" bcb994c^:"java/org/apache/catalina/startup/Bootstrap.java"

                System.setProperty("catalina.home",
======= fetch "private void setCatalinaHome() {" bcb994c^:"java/org/apache/catalina/startup/Bootstrap.java"

            System.setProperty("catalina.home",
======= fetch "public static String getCatalinaHome() {" bcb994c^:"java/org/apache/catalina/startup/Bootstrap.java"

        return System.getProperty("catalina.home",
======= fetch "public static String getCatalinaBase() {" bcb994c^:"java/org/apache/catalina/startup/Bootstrap.java"

        return System.getProperty("catalina.base", getCatalinaHome());
======= fetch "protected File configFile() {" bcb994c^:"java/org/apache/catalina/startup/Catalina.java"

            file = new File(System.getProperty("catalina.base"), configFile);
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Catalina.java"

        String catalinaHome = System.getProperty("catalina.home");
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Catalina.java"

            } else if (System.getProperty("catalina.base") != null) {
                catalinaHome = System.getProperty("catalina.base");
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Catalina.java"

                    ("catalina.home", "catalina.base", "catalina.jar");
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Catalina.java"

                        ("tomcat.install", "catalina.home", "tomcat.jar");
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Catalina.java"

            System.setProperty("catalina.home", catalinaHome);
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Catalina.java"

        if (System.getProperty("catalina.base") == null) {
            System.setProperty("catalina.base",
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Catalina.java"

            String catalinaBase = System.getProperty("catalina.base");
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Catalina.java"

            System.setProperty("catalina.base", catalinaBase);
======= fetch "private static void loadProperties() {" bcb994c^:"java/org/apache/catalina/startup/CatalinaProperties.java"

        ClassLoader cl = CatalinaProperties.class.getClassLoader();
        System.err.println("CatalinaProprties: cl=" + cl.toString());
        if ((cl = cl.getParent()) != null) {
            System.err.println("CatalinaProprties: parent cl=" + cl.toString());
        }
======= fetch "private static String getCatalinaHome() {" bcb994c^:"java/org/apache/catalina/startup/CatalinaProperties.java"

        return System.getProperty("catalina.home",
======= fetch "private static String getCatalinaBase() {" bcb994c^:"java/org/apache/catalina/startup/CatalinaProperties.java"

        return System.getProperty("catalina.base", getCatalinaHome());
======= fetch "public boolean isAwait() {" bcb994c^:"java/org/apache/catalina/startup/Embedded.java"

    public void setCatalinaHome( String s ) {
        System.setProperty( "catalina.home", s);
======= fetch "public void setCatalinaHome( String s ) {" bcb994c^:"java/org/apache/catalina/startup/Embedded.java"

    public void setCatalinaBase( String s ) {
        System.setProperty( "catalina.base", s);
======= fetch "public String getCatalinaHome() {" bcb994c^:"java/org/apache/catalina/startup/Embedded.java"

        return System.getProperty("catalina.home");
======= fetch "public String getCatalinaBase() {" bcb994c^:"java/org/apache/catalina/startup/Embedded.java"

        return System.getProperty("catalina.base");
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Embedded.java"

        String catalinaHome = System.getProperty("catalina.home");
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Embedded.java"

            } else if (System.getProperty("catalina.base") != null) {
                catalinaHome = System.getProperty("catalina.base");
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Embedded.java"

                    ("catalina.home", "catalina.base", "catalina.jar");
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Embedded.java"

                        ("tomcat.install", "catalina.home", "tomcat.jar");
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Embedded.java"

            System.setProperty("catalina.home", catalinaHome);
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Embedded.java"

        if (System.getProperty("catalina.base") == null) {
            System.setProperty("catalina.base",
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Embedded.java"

            String catalinaBase = System.getProperty("catalina.base");
======= fetch "protected void initDirs() {" bcb994c^:"java/org/apache/catalina/startup/Embedded.java"

            System.setProperty("catalina.base", catalinaBase);
======= fetch "public static String expand(Host host, URL war, String pathname)" bcb994c^:"java/org/apache/catalina/startup/ExpandWar.java"

            appBase = new File(System.getProperty("catalina.base"),
======= fetch "public static void validate(Host host, URL war, String pathname)" bcb994c^:"java/org/apache/catalina/startup/ExpandWar.java"

            appBase = new File(System.getProperty("catalina.base"),
======= fetch "protected File returnCanonicalPath(String path) {" bcb994c^:"java/org/apache/catalina/startup/HostConfig.java"

        File base = new File(System.getProperty("catalina.base"));
======= fetch "protected void initBaseDir() {" bcb994c^:"java/org/apache/catalina/startup/Tomcat.java"

            basedir = System.getProperty("catalina.base");
======= fetch "protected void initBaseDir() {" bcb994c^:"java/org/apache/catalina/startup/Tomcat.java"

            basedir = System.getProperty("catalina.home");
======= fetch "protected void initBaseDir() {" bcb994c^:"java/org/apache/catalina/startup/Tomcat.java"

        System.setProperty("catalina.home", basedir);
        System.setProperty("catalina.base", basedir);
    private static String catalinaHome = System.getProperty("catalina.home");
======= fetch "public static void main(String args[]) {" bcb994c^:"java/org/apache/catalina/startup/Tool.java"

            log.error("Must set 'catalina.home' system property");
======= fetch "public void open() throws Exception {" bcb994c^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                    file = new File(System.getProperty("catalina.base"),
======= fetch "public boolean isWriteable() {" bcb994c^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

            file = new File(System.getProperty("catalina.base"),
======= fetch "public void save() throws Exception {" bcb994c^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                new File(System.getProperty("catalina.base"), pathnameNew);
======= fetch "public void save() throws Exception {" bcb994c^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                new File(System.getProperty("catalina.base"), pathnameOld);
======= fetch "public void save() throws Exception {" bcb994c^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                new File(System.getProperty("catalina.base"), pathname);
======= fetch "protected synchronized void open() {" bcb994c^:"java/org/apache/catalina/valves/AccessLogValve.java"

            dir = new File(System.getProperty("catalina.base"), directory);
======= fetch "protected Project getProject() {" bcb994c^:"java/org/apache/jasper/compiler/AntCompiler.java"

        if (System.getProperty("catalina.home") != null) {
            project.setBasedir( System.getProperty("catalina.home"));
======= fetch "public void setKeystoreFile(String s ) {" bcb994c^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

        String file = adjustRelativePath(s,System.getProperty("catalina.base"));
======= fetch "public void setTruststoreFile(String s) {" bcb994c^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

        String file = adjustRelativePath(s,System.getProperty("catalina.base"));
======= fetch "private KeyStore getStore(String type, String provider, String path," bcb994c^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

                    keyStoreFile = new File(System.getProperty("catalina.base"),
======= fetch "protected CertPathParameters getParameters(String algorithm," bcb994c^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            crlFile = new File(System.getProperty("catalina.base"), crlf);

======= fetch "public void register(Request request, HttpServletResponse response," e641f20^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

        <bug>47950</bug>: Align <code>WebappClassLoader.validate()</code>

    
    /**
     * Logger.
     */
    protected static org.apache.juli.logging.Log log
        = org.apache.juli.logging.LogFactory.getLog(AbstractOutputBuffer.class);
======= fetch "public void flush()" 526f4ac^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        
        // go through the filters and if there is gzip filter
        // invoke it to flush
        for (int i = 0; i <= lastActiveFilter; i++) {
            if (activeFilters[i] instanceof GzipOutputFilter) {
                if (log.isDebugEnabled()) {
                    log.debug("Flushing the gzip filter at position " + i +
                            " of the filter chain...");
                }
                ((GzipOutputFilter) activeFilters[i]).flush();
                break;
            }
        }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Extension of {@link GZIPOutputStream} to workaround for a couple of long
 * standing JDK bugs
 * (<a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4255743">Bug
 * 4255743</a> and
 * <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4813885">Bug
 * 4813885</a>) so the GZIP'd output can be flushed. 
 */
    public FlushableGZIPOutputStream(OutputStream os) throws IOException {
        super(os);
    }
    private static final byte[] EMPTYBYTEARRAY = new byte[0];
    private boolean hasData = false;
    /**
     * Here we make sure we have received data, so that the header has been for
     * sure written to the output stream already.
     */
    @Override
    public synchronized void write(byte[] bytes, int i, int i1)
            throws IOException {
        super.write(bytes, i, i1);
        hasData = true;
    }
    @Override
    public synchronized void write(int i) throws IOException {
        super.write(i);
        hasData = true;
    }
    @Override
    public synchronized void write(byte[] bytes) throws IOException {
        super.write(bytes);
        hasData = true;
    }
    @Override
    public synchronized void flush() throws IOException {
        if (!hasData) {
            return; // do not allow the gzip header to be flushed on its own
        }
        // trick the deflater to flush
        /**
         * Now this is tricky: We force the Deflater to flush its data by
         * switching compression level. As yet, a perplexingly simple workaround
         * for
         * http://developer.java.sun.com/developer/bugParade/bugs/4255743.html
         */
        if (!def.finished()) {
            def.setInput(EMPTYBYTEARRAY, 0, 0);
            def.setLevel(Deflater.NO_COMPRESSION);
            deflate();
            def.setLevel(Deflater.DEFAULT_COMPRESSION);
            deflate();
            out.flush();
        }
        hasData = false; // no more data to flush
    }
    /*
     * Keep on calling deflate until it runs dry. The default implementation
     * only does it once and can therefore hold onto data when they need to be
     * flushed out.
     */
    @Override
    protected void deflate() throws IOException {
        int len;
        do {
            len = def.deflate(buf, 0, buf.length);
            if (len > 0) {
                out.write(buf, 0, len);
            }
        } while (len != 0);
    }
    /**
     * Logger.
     */
    protected static org.apache.juli.logging.Log log =
        org.apache.juli.logging.LogFactory.getLog(GzipOutputFilter.class);
======= fetch "public int doWrite(ByteChunk chunk, Response res)" 526f4ac^:"java/org/apache/coyote/http11/filters/GzipOutputFilter.java"

            compressionStream = new GZIPOutputStream(fakeOutputStream);
======= fetch "public int doWrite(ByteChunk chunk, Response res)" 526f4ac^:"java/org/apache/coyote/http11/filters/GzipOutputFilter.java"

    /**
     * Added to allow flushing to happen for the gzip'ed outputstream
     */
    public void flush() {
        if (compressionStream != null) {
            try {
                if (log.isDebugEnabled()) {
                    log.debug("Flushing the compression stream!");
                }
                compressionStream.flush();
            } catch (IOException e) {
                if (log.isDebugEnabled()) {
                    log.debug("Ignored exception while flushing gzip filter", e);
                }
            }
        }
    }
======= fetch "public long end()" 526f4ac^:"java/org/apache/coyote/http11/filters/GzipOutputFilter.java"

            compressionStream = new GZIPOutputStream(fakeOutputStream);

======= fetch "protected synchronized void startInternal() throws LifecycleException {" e2f0b9b^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

            if (!(parent instanceof Pipeline)) {
                parent = parent.getParent();
                continue;
            }
            Valve valves[] = ((Pipeline) parent).getValves();

======= fetch "protected void webConfig() {" 187eed8^:"java/org/apache/catalina/startup/ContextConfig.java"

                processResourceJARs(orderedFragments);

======= fetch "public void init(JspCompilationContext ctxt, JspServletWrapper jsw) {" 42c226f^:"java/org/apache/jasper/compiler/Compiler.java"

        if (jspProperty.getDefaultContentType() != null) {
            pageInfo.setContentType(jspProperty.getDefaultContentType());
        }
======= fetch "public void init(JspCompilationContext ctxt, JspServletWrapper jsw) {" 42c226f^:"java/org/apache/jasper/compiler/Compiler.java"

            // Leave this until now since it can only be set once - bug 49726
            if (pageInfo.getContentType() == null &&
                    jspProperty.getDefaultContentType() != null) {
                pageInfo.setContentType(jspProperty.getDefaultContentType());
            }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    
    public void testBug49726a() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = new ByteChunk();
        Map<String,List<String>> headers = new HashMap<String,List<String>>();
        
        getUrl("http://localhost:" + getPort() + "/test/bug49726a.jsp", res,
                headers);
        // Check request completed
        String result = res.toString();
        assertEcho(result, "OK");
        
        // Check content type
        assertTrue(headers.get("Content-Type").get(0).startsWith("text/html"));
    }
    public void testBug49726b() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = new ByteChunk();
        Map<String,List<String>> headers = new HashMap<String,List<String>>();
        
        getUrl("http://localhost:" + getPort() + "/test/bug49726b.jsp", res,
                headers);
        // Check request completed
        String result = res.toString();
        assertEcho(result, "OK");
        
        // Check content type
        assertTrue(headers.get("Content-Type").get(0).startsWith("text/plain"));
    }
    /** Assertion for text printed by tags:echo */
    private static void assertEcho(String result, String expected) {
        assertTrue(result.indexOf("<p>" + expected + "</p>") > 0);
    }
  <jsp-config>
    <jsp-property-group>
      <default-content-type>text/plain</default-content-type>
      <url-pattern>/bug49726a.jsp</url-pattern>
      <url-pattern>/bug49726b.jsp</url-pattern>
    </jsp-property-group>
  </jsp-config>
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <head><title>Bug 49726 test case</title></head>
  <body>
    <p>OK</p>
  </body>
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <head><title>Bug 49726 test case</title></head>
  <body>
    <p>OK</p>
  </body>
  <subsection name="Jasper">
    <changelog>
      <fix>
        <bug>49726</bug>: Specifying a default content type via a JSP property
        group should not prevent a page from setting some other content type.
        (markt)
      </fix>
    </changelog>
  </subsection>

======= fetch "protected boolean validate(String name) {" 6fce7d7^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (name.startsWith("javax.servlet."))
            return false;
        <bug>47950</bug>: Align <code>WebappClassLoader.validate()</code>
        implementation with Javadoc and ensure that <code>javax.servlet.*</code>
        classes can not be loaded by a <code>WebappClassLoader</code> instance.
        Patch provided by pid. (markt)
      </fix>
      <fix>

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
   @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
======= fetch "public BeanProperty(Class<?> owner, PropertyDescriptor descriptor) {" c05cb94^:"java/javax/el/BeanELResolver.java"

        public @SuppressWarnings("unchecked") Class getPropertyType() {
======= fetch "public ELContext() {" c05cb94^:"java/javax/el/ELContext.java"

    public Object getContext(@SuppressWarnings("unchecked") Class key) {
======= fetch "public Object getContext(@SuppressWarnings("unchecked") Class key) {" c05cb94^:"java/javax/el/ELContext.java"

    public void putContext(@SuppressWarnings("unchecked") Class key,
======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" c05cb94^:"java/javax/el/ResourceBundleELResolver.java"

    public @SuppressWarnings("unchecked") Iterator getFeatureDescriptors(
======= fetch "public boolean isWrapperFor(ServletRequest wrapped) {" c05cb94^:"java/javax/servlet/ServletRequestWrapper.java"

    public boolean isWrapperFor(Class wrappedType) {
======= fetch "public boolean isWrapperFor(ServletResponse wrapped) {" c05cb94^:"java/javax/servlet/ServletResponseWrapper.java"

    public boolean isWrapperFor(Class wrappedType) {
======= fetch "public abstract Expression parseExpression(String expression," c05cb94^:"java/javax/servlet/jsp/el/ExpressionEvaluator.java"

            @SuppressWarnings("unchecked")// TCK signature fails with generics
======= fetch "public abstract Object evaluate(" c05cb94^:"java/javax/servlet/jsp/el/ExpressionEvaluator.java"

            @SuppressWarnings("unchecked")// TCK signature fails with generics
======= fetch "public Object getValue(ELContext context, Object base, Object property)" c05cb94^:"java/javax/servlet/jsp/el/ImplicitObjectELResolver.java"

    @SuppressWarnings("unchecked") // TCK signature test fails with generics
======= fetch "public static final Tag findAncestorWithClass(Tag from," c05cb94^:"java/javax/servlet/jsp/tagext/TagSupport.java"

            @SuppressWarnings("unchecked")
    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
======= fetch "public VariableMapper getVariableMapper() {" c05cb94^:"java/org/apache/el/lang/EvaluationContext.java"

    public Object getContext(@SuppressWarnings("unchecked") Class key) {
======= fetch "public boolean isPropertyResolved() {" c05cb94^:"java/org/apache/el/lang/EvaluationContext.java"

    public void putContext(@SuppressWarnings("unchecked") Class key,
======= fetch "public MethodInfo getMethodInfo(EvaluationContext ctx," c05cb94^:"java/org/apache/el/parser/AstValue.java"

            @SuppressWarnings("unchecked") Class[] paramTypes)
======= fetch "public Object invoke(EvaluationContext ctx," c05cb94^:"java/org/apache/el/parser/AstValue.java"

            @SuppressWarnings("unchecked") Class[] paramTypes,
======= fetch "public VariableMapper getVariableMapper() {" c05cb94^:"java/org/apache/jasper/el/ELContextWrapper.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match super-class specification
======= fetch "public boolean isPropertyResolved() {" c05cb94^:"java/org/apache/jasper/el/ELContextWrapper.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match super-class specification
======= fetch "public Expression parseExpression(String expression," c05cb94^:"java/org/apache/jasper/el/ExpressionEvaluatorImpl.java"

            @SuppressWarnings("unchecked") // API does not use generics
======= fetch "public Object evaluate(String expression," c05cb94^:"java/org/apache/jasper/el/ExpressionEvaluatorImpl.java"

            @SuppressWarnings("unchecked") // API does not use generics
======= fetch "public Object getContent()" c05cb94^:"java/org/apache/naming/resources/DirContextURLConnection.java"

    @SuppressWarnings("unchecked") // overridden method uses raw type Class[]

    // ----------------------------------------------------- Instance Variables
    // --------------------------------------------------------- Public Methods
======= fetch "public void listBeans( PrintWriter writer, String qry )" d446678^:"java/org/apache/catalina/manager/JMXProxyServlet.java"

                        Class c = value.getClass();
======= fetch "public void transferState() {" d446678^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
======= fetch "public Serializable replyRequest(Serializable msg, final Member sender) {" d446678^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
======= fetch "public void leftOver(Serializable msg, Member sender) {" d446678^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
======= fetch "public void messageReceived(Serializable msg, Member sender) {" d446678^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
======= fetch "public boolean inSet(Member m, Member[] set) {" d446678^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
======= fetch "public void memberAdded(Member member) {" d446678^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
======= fetch "public Member getNextBackupNode() {" d446678^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
======= fetch "public boolean isEmpty() {" d446678^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    public static class MapEntry implements Map.Entry {
======= fetch "public Member getPrimary() {" d446678^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        @Override
======= fetch "public Object getValue() {" d446678^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        @Override
======= fetch "public Object setValue(Object value) {" d446678^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        @Override
      <fix>
        <bug>49757</bug>: Correct some generics warnings. Based on a patch
        provided by Gbor. (markt)
      </fix>

======= fetch "protected void processAnnotations(Set<WebXml> fragments) {" f4a10ec^:"java/org/apache/catalina/startup/ContextConfig.java"

                // no impact on distributable
                annotations.setDistributable(true);
      <fix>
        <bug>49714</bug>: The annotation process of Jar doesn't influence 
        distributable element of web.xml. (kfujino)
      </fix>

======= fetch "public void testInvokeWithVarArgsAAABBB() throws Exception {" 96a99ce^:"test/org/apache/el/TestMethodExpressionImpl.java"

    
    /*
     * This is also tested implicitly in numerous places elsewhere in this
     * class.
     */
    public void testBug49655() throws Exception {
        // This is the call the failed
        MethodExpression me = factory.createMethodExpression(context,
                "#{beanA.setName('New value')}", null, null);
        // The rest is to check it worked correctly
        me.invoke(context, null);
        ValueExpression ve = factory.createValueExpression(context,
                "#{beanA.name}", java.lang.String.class);
        assertEquals("New value", ve.getValue(context));
    }

======= fetch "public void add(Session session) {" d21b105^:"java/org/apache/catalina/session/ManagerBase.java"

        int size = sessions.size();
======= fetch "public Session createSession(String sessionId) {" d21b105^:"java/org/apache/catalina/session/ManagerBase.java"

                (sessions.size() >= maxActiveSessions)) {
======= fetch "public boolean containsValue(Object value) {" d21b105^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    if (entry!=null && entry.isPrimary() && value.equals(entry.getValue())) return true;
======= fetch "public int sizeFull() {" d21b105^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                if ( entry != null && entry.isPrimary() ) {
======= fetch "public int sizeFull() {" d21b105^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                if ( entry!=null && entry.isPrimary() ) set.add(key);
======= fetch "public int size() {" d21b105^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    if (entry!=null && entry.isPrimary() && entry.getValue() != null) counter++;
======= fetch "public boolean isEmpty() {" d21b105^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                if (entry!=null && entry.isPrimary() && entry.getValue()!=null) values.add(entry.getValue());
======= fetch "public boolean isPrimary() {" d21b105^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            return ( (!proxy) && (!backup));
======= fetch "public boolean isPrimary() {" d21b105^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        public boolean isActive() {
            return !proxy;
        }
        
        <bug>49407</bug>: Change the BackupManager so it is consistent with
        DeltaManager and reports both primary and backup sessions when active
        sessions are requested. (markt)
      </fix>
      <fix>

======= fetch "public void setCoyoteRequest(org.apache.coyote.Request coyoteRequest) {" 5f1ad13^:"java/org/apache/catalina/connector/Request.java"

     * Flag that indicates if SSL attributes have been parsed to improve
     * performance for applications (usually frameworks) that make multiple
     * calls to {@link Request#getAttributeNames()}.
     */
    protected boolean sslAttributesParsed = false;
    /**
======= fetch "public void recycle() {" 5f1ad13^:"java/org/apache/catalina/connector/Request.java"

        sslAttributesParsed = false;
======= fetch "public Object getAttribute(String name) {" 5f1ad13^:"java/org/apache/catalina/connector/Request.java"

            sslAttributesParsed = true;
======= fetch "static boolean isSSLAttribute(String name) {" 5f1ad13^:"java/org/apache/catalina/connector/Request.java"

        if (isSecure()) {

======= fetch "public boolean asyncDispatch(org.apache.coyote.Request req,org.apache.coyote.Res" 2357fb5^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            if (status==SocketStatus.ERROR || status==SocketStatus.STOP || status==SocketStatus.DISCONNECT) {
======= fetch "public boolean isAsyncDispatching() {" 2357fb5^:"java/org/apache/catalina/connector/Request.java"

                asyncContext.getState()==AsyncContextImpl.AsyncState.DISPATCHING_RUNNABLE  ||
        NOT_STARTED, STARTED, DISPATCHING, DISPATCHING_RUNNABLE, DISPATCHED,
        COMPLETING, COMPLETING_RUNNABLE, TIMING_OUT, ERROR_DISPATCHING
======= fetch "public void complete() {" 2357fb5^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        } else if (state.compareAndSet(AsyncState.DISPATCHING_RUNNABLE,
                AsyncState.COMPLETING_RUNNABLE)) {
            // do nothing
======= fetch "public void start(final Runnable run) {" 2357fb5^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        if (state.compareAndSet(AsyncState.STARTED, AsyncState.DISPATCHING_RUNNABLE) ||
            state.compareAndSet(AsyncState.DISPATCHED, AsyncState.DISPATCHING_RUNNABLE)) {
            // TODO SERVLET3 - async
            final ServletContext sctx = getServletRequest().getServletContext();
            Runnable r = new Runnable() {
                public void run() {
                    //TODO SERVLET3 - async - set context class loader when running the task.
                    try {
                        
                        run.run();
                    }catch (Exception x) {
                        log.error("Unable to run async task.",x);
                    }
                }
            };
            this.dispatch = r;
            AtomicBoolean dispatched = new AtomicBoolean(false);
            request.getCoyoteRequest().action(ActionCode.ACTION_ASYNC_DISPATCH, dispatched );
            if (!dispatched.get()) {
                try {
                    doInternalDispatch();
                }catch (ServletException sx) {
                    throw new RuntimeException(sx);
                }catch (IOException ix) {
                    throw new RuntimeException(ix);
                }
            }
======= fetch "public boolean isStarted() {" 2357fb5^:"java/org/apache/catalina/core/AsyncContextImpl.java"

                state.get() == AsyncState.DISPATCHING ||
                state.get() == AsyncState.DISPATCHING_RUNNABLE);
======= fetch "public void doInternalDispatch() throws ServletException, IOException {" 2357fb5^:"java/org/apache/catalina/core/AsyncContextImpl.java"

            if (!listenerInvoked) {
                ((HttpServletResponse)servletResponse).setStatus(500);
======= fetch "public void doInternalDispatch() throws ServletException, IOException {" 2357fb5^:"java/org/apache/catalina/core/AsyncContextImpl.java"

            doInternalComplete(true);
======= fetch "public void doInternalDispatch() throws ServletException, IOException {" 2357fb5^:"java/org/apache/catalina/core/AsyncContextImpl.java"

        } else if (this.state.get() == AsyncState.DISPATCHING_RUNNABLE) {
            if (this.dispatch!=null) {
                try {
                    dispatch.run();
                } catch (RuntimeException x) {
                    doInternalComplete(true);
                    if (x.getCause() instanceof ServletException) throw (ServletException)x.getCause();
                    if (x.getCause() instanceof IOException) throw (IOException)x.getCause();
                    else throw new ServletException(x);
                } finally {
                    dispatch = null;
                }
                if (this.state.compareAndSet(AsyncState.COMPLETING_RUNNABLE,
                        AsyncState.COMPLETING)) {
                    doInternalComplete(false);
                } else if (this.state.get() == AsyncState.DISPATCHING_RUNNABLE) {
                    doInternalComplete(true);
                    throw new IllegalStateException(
                            "Failed to call dispatch() or complete() after start()");
                }
            }
======= fetch "public SocketState asyncDispatch(SocketStatus status) throws IOException {" 2357fb5^:"java/org/apache/coyote/http11/Http11Processor.java"

            recycle();
======= fetch "public SocketState asyncDispatch(SocketStatus status) throws IOException {" 2357fb5^:"java/org/apache/coyote/http11/Http11Processor.java"

                recycle();
======= fetch "public void testBug49528() throws Exception {" 2357fb5^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        getUrl("http://localhost:" + getPort() + "/");
======= fetch "public void testBug49528() throws Exception {" 2357fb5^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    public void testAsyncStartNoComplete() throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        
        // Minimise pauses during test
        tomcat.getConnector().setAttribute(
                "connectionTimeout", Integer.valueOf(3000));
        
        // Must have a real docBase - just use temp
        Context ctx = 
            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
        AsyncStartNoCompleteServlet servlet =
            new AsyncStartNoCompleteServlet();
        
        Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet);
        wrapper.setAsyncSupported(true);
        ctx.addServletMapping("/", "servlet");
        
        tomcat.start();
        
        // Call the servlet the first time
        ByteChunk bc1 = getUrl("http://localhost:" + getPort() +
                "/?echo=run1");
        assertEquals("OK-run1", bc1.toString());
        // Call the servlet the second time with a request parameter
        ByteChunk bc2 = getUrl("http://localhost:" + getPort() +
                "/?echo=run2");
        assertEquals("OK-run2", bc2.toString());
    }
    
    public void testAsyncStartWithComplete() throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        
        // Must have a real docBase - just use temp
        Context ctx = 
            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
        AsyncStartWithCompleteServlet servlet =
            new AsyncStartWithCompleteServlet();
        
        Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet);
        wrapper.setAsyncSupported(true);
        ctx.addServletMapping("/", "servlet");
        
        tomcat.start();
        
        // Call the servlet once
        ByteChunk bc = getUrl("http://localhost:" + getPort() + "/");
        assertEquals("OK", bc.toString());
    }
    
======= fetch "public void run() {" 2357fb5^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                        resp.setContentType("text/plain");
                        resp.getWriter().print("OK");
======= fetch "public void run() {" 2357fb5^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                        // TODO Auto-generated catch block
                        e.printStackTrace();
======= fetch "public void run() {" 2357fb5^:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        <bug>49528</bug>: Ensure AsyncContext.isAsyncStarted() returns the
        correct value after AsyncContext.start(). Tomcat implements this
        using an internal dispatch that requires slightly different treatment
        from a standard dispatch to ensure the correct value is returned.
        (markt)

 * <h2>Configuration Parameters</h2><h3>
 * <tt>ExpiresActive</tt></h3>
 * <p>
 * This directive enables or disables the generation of the <tt>Expires</tt> and
 * <tt>Cache-Control</tt> headers by this <tt>ExpiresFilter</tt>. If set to
 * <tt>Off</tt>, the headers will not be generated for any HTTP response. If set
 * to <tt>On</tt> or <tt>true</tt>, the headers will be added to served HTTP
 * responses according to the criteria defined by the
 * <tt>ExpiresByType &lt;content-type&gt;</tt> and <tt>ExpiresDefault</tt>
 * directives. Note that this directive does not guarantee that an
 * <tt>Expires</tt> or <tt>Cache-Control</tt> header will be generated. If the
 * criteria aren&#x27;t met, no header will be sent, and the effect will be as
 * though this directive wasn&#x27;t even specified.
 * </p>
 * <p>
 * This parameter is optional, default value is <tt>true</tt>.
 * </p>
 * <p>
 * <i>Enable filter</i>
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;!-- supports case insensitive &#x27;On&#x27; or &#x27;true&#x27; --&gt;
 *    &lt;param-name&gt;ExpiresActive&lt;/param-name&gt;&lt;param-value&gt;On&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * <p>
 * <i>Disable filter</i>
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;!-- supports anything different from case insensitive &#x27;On&#x27; and &#x27;true&#x27; --&gt;
 *    &lt;param-name&gt;ExpiresActive&lt;/param-name&gt;&lt;param-value&gt;Off&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * <li>The <tt>Content-Type</tt> of the response matches one of the types
 *    active=true, 
======= fetch "public void testConfiguration() throws Exception {" dfbd8aa^:"test/org/apache/catalina/filters/TestExpiresFilter.java"

        filterDef.addInitParameter("ExpiresActive", "Off");
        <bug>48998</bug>: Add the ExpiresFilter, a port of the httpd mod_expires
        module. Patch provided by Cyrille Le Clerc. (markt)
    <li>The <tt>Content-Type</tt> of the response matches one of the types
         Note that this directive only has effect if <tt>ExpiresActive On</tt> has
         been specified. It overrides, for the specified MIME type <i>only</i>, any
    Sample of initialization log message :
 active=true, 
    expiration date
    an expiration date

 * Copyright 2008-2009 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * <p>
 * ExpiresFilter is a Java Servlet API port of <a
 * href="http://httpd.apache.org/docs/2.2/mod/mod_expires.html">Apache
 * mod_expires</a> to add ' <tt>Expires</tt>' and '
 * <tt>Cache-Control: max-age=</tt>' headers to HTTP response according to its '
 * <tt>Content-Type</tt>'.
 * </p>
 * 
 * <p>
 * Following documentation is inspired by <tt>mod_expires</tt> .
 * </p>
 * <h1>Summary</h1>
 * <p>
 * This filter controls the setting of the <tt>Expires</tt> HTTP header and the
 * <tt>max-age</tt> directive of the <tt>Cache-Control</tt> HTTP header in
 * server responses. The expiration date can set to be relative to either the
 * time the source file was last modified, or to the time of the client access.
 * </p>
 * <p>
 * These HTTP headers are an instruction to the client about the document&#x27;s
 * validity and persistence. If cached, the document may be fetched from the
 * cache rather than from the source until this time has passed. After that, the
 * cache copy is considered &quot;expired&quot; and invalid, and a new copy must
 * be obtained from the source.
 * </p>
 * <p>
 * To modify <tt>Cache-Control</tt> directives other than <tt>max-age</tt> (see
 * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9" >RFC
 * 2616 section 14.9</a>), you can use other servlet filters or <a
 * href="http://httpd.apache.org/docs/2.2/mod/mod_headers.html" >Apache Httpd
 * mod_headers</a> module.
 * </p>
 * <h1>Filter Configuration</h1><h2>Basic configuration to add &#x27;
 * <tt>Expires</tt>&#x27; and &#x27; <tt>Cache-Control: max-age=</tt>&#x27;
 * headers to images, css and javascript</h2>
 * 
 * <code><pre>
 * &lt;web-app ...&gt;
 *    ...
 *    &lt;filter&gt;
 *       &lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt;
 *       &lt;filter-class&gt;org.apache.catalina.filters.ExpiresFilter&lt;/filter-class&gt;
 *       &lt;init-param&gt;
 *          &lt;param-name&gt;ExpiresByType image&lt;/param-name&gt;
 *          &lt;param-value&gt;access plus 10 minutes&lt;/param-value&gt;
 *       &lt;/init-param&gt;
 *       &lt;init-param&gt;
 *          &lt;param-name&gt;ExpiresByType text/css&lt;/param-name&gt;
 *          &lt;param-value&gt;access plus 10 minutes&lt;/param-value&gt;
 *       &lt;/init-param&gt;
 *       &lt;init-param&gt;
 *          &lt;param-name&gt;ExpiresByType text/javascript&lt;/param-name&gt;
 *          &lt;param-value&gt;access plus 10 minutes&lt;/param-value&gt;
 *       &lt;/init-param&gt;
 *    &lt;/filter&gt;
 *    ...
 *    &lt;filter-mapping&gt;
 *       &lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt;
 *       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
 *       &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
 *    &lt;/filter-mapping&gt;
 *    ...
 * &lt;/web-app&gt;
 * </pre></code>
 * 
 * <h2>Configuration Parameters</h2><h3>
 * <tt>ExpiresActive</tt></h3>
 * <p>
 * This directive enables or disables the generation of the <tt>Expires</tt> and
 * <tt>Cache-Control</tt> headers by this <tt>ExpiresFilter</tt>. If set to
 * <tt>Off</tt>, the headers will not be generated for any HTTP response. If set
 * to <tt>On</tt> or <tt>true</tt>, the headers will be added to served HTTP
 * responses according to the criteria defined by the
 * <tt>ExpiresByType &lt;content-type&gt;</tt> and <tt>ExpiresDefault</tt>
 * directives. Note that this directive does not guarantee that an
 * <tt>Expires</tt> or <tt>Cache-Control</tt> header will be generated. If the
 * criteria aren&#x27;t met, no header will be sent, and the effect will be as
 * though this directive wasn&#x27;t even specified.
 * </p>
 * <p>
 * This parameter is optional, default value is <tt>true</tt>.
 * </p>
 * <p>
 * <i>Enable filter</i>
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;!-- supports case insensitive &#x27;On&#x27; or &#x27;true&#x27; --&gt;
 *    &lt;param-name&gt;ExpiresActive&lt;/param-name&gt;&lt;param-value&gt;On&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * <p>
 * <i>Disable filter</i>
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;!-- supports anything different from case insensitive &#x27;On&#x27; and &#x27;true&#x27; --&gt;
 *    &lt;param-name&gt;ExpiresActive&lt;/param-name&gt;&lt;param-value&gt;Off&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * 
 * <h3>
 * <tt>ExpiresByType &lt;content-type&gt;</tt></h3>
 * <p>
 * This directive defines the value of the <tt>Expires</tt> header and the
 * <tt>max-age</tt> directive of the <tt>Cache-Control</tt> header generated for
 * documents of the specified type (<i>e.g.</i>, <tt>text/html</tt>). The second
 * argument sets the number of seconds that will be added to a base time to
 * construct the expiration date. The <tt>Cache-Control: max-age</tt> is
 * calculated by subtracting the request time from the expiration date and
 * expressing the result in seconds.
 * </p>
 * <p>
 * The base time is either the last modification time of the file, or the time
 * of the client&#x27;s access to the document. Which should be used is
 * specified by the <tt>&lt;code&gt;</tt> field; <tt>M</tt> means that the
 * file&#x27;s last modification time should be used as the base time, and
 * <tt>A</tt> means the client&#x27;s access time should be used. The duration
 * is expressed in seconds. <tt>A2592000</tt> stands for
 * <tt>access plus 30 days</tt> in alternate syntax.
 * </p>
 * <p>
 * The difference in effect is subtle. If <tt>M</tt> (<tt>modification</tt> in
 * alternate syntax) is used, all current copies of the document in all caches
 * will expire at the same time, which can be good for something like a weekly
 * notice that&#x27;s always found at the same URL. If <tt>A</tt> (
 * <tt>access</tt> or <tt>now</tt> in alternate syntax) is used, the date of
 * expiration is different for each client; this can be good for image files
 * that don&#x27;t change very often, particularly for a set of related
 * documents that all refer to the same images (<i>i.e.</i>, the images will be
 * accessed repeatedly within a relatively short timespan).
 * </p>
 * <p>
 * <strong>Example:</strong>
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresByType text/html&lt;/param-name&gt;&lt;param-value&gt;access plus 1 month 15   days 2 hours&lt;/param-value&gt;
 * &lt;/init-param&gt;
 *  
 * &lt;init-param&gt;
 *    &lt;!-- 2592000 seconds = 30 days --&gt;
 *    &lt;param-name&gt;ExpiresByType image/gif&lt;/param-name&gt;&lt;param-value&gt;A2592000&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * <p>
 * Note that this directive only has effect if <tt>ExpiresActive On</tt> has
 * been specified. It overrides, for the specified MIME type <i>only</i>, any
 * expiration date set by the <tt>ExpiresDefault</tt> directive.
 * </p>
 * <p>
 * You can also specify the expiration time calculation using an alternate
 * syntax, described earlier in this document.
 * </p>
 * <h3>
 * <tt>ExpiresExcludedResponseStatusCodes</tt></h3>
 * <p>
 * This directive defines the http response status codes for which the
 * <tt>ExpiresFilter</tt> will not generate expiration headers. By default, the
 * <tt>304</tt> status code (&quot;<tt>Not modified</tt>&quot;) is skipped. The
 * value is a comma separated list of http status codes.
 * </p>
 * <p>
 * This directive is useful to ease usage of <tt>ExpiresDefault</tt> directive.
 * Indeed, the behavior of <tt>304 Not modified</tt> (which does specify a
 * <tt>Content-Type</tt> header) combined with <tt>Expires</tt> and
 * <tt>Cache-Control:max-age=</tt> headers can be unnecessarily tricky to
 * understand.
 * </p>
 * <p>
 * Configuration sample :
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresExcludedResponseStatusCodes&lt;/param-name&gt;&lt;param-value&gt;302, 500, 503&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * 
 * <h3>ExpiresDefault</h3>
 * <p>
 * This directive sets the default algorithm for calculating the expiration time
 * for all documents in the affected realm. It can be overridden on a
 * type-by-type basis by the <tt>ExpiresByType</tt> directive. See the
 * description of that directive for details about the syntax of the argument,
 * and the "alternate syntax" description as well.
 * </p>
 * <h1>Alternate Syntax</h1>
 * <p>
 * The <tt>ExpiresDefault</tt> and <tt>ExpiresByType</tt> directives can also be
 * defined in a more readable syntax of the form:
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;&lt;param-value&gt;&lt;base&gt; [plus] {&lt;num&gt;   &lt;type&gt;}*&lt;/param-value&gt;
 * &lt;/init-param&gt;
 *  
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresByType type/encoding&lt;/param-name&gt;&lt;param-value&gt;&lt;base&gt; [plus]   {&lt;num&gt; &lt;type&gt;}*&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * <p>
 * where <tt>&lt;base&gt;</tt> is one of:
 * <ul>
 * <li><tt>access</tt></li>
 * <li><tt>now</tt> (equivalent to &#x27;<tt>access</tt>&#x27;)</li>
 * <li><tt>modification</tt></li>
 * </ul>
 * </p>
 * <p>
 * The <tt>plus</tt> keyword is optional. <tt>&lt;num&gt;</tt> should be an
 * integer value (acceptable to <tt>Integer.parseInt()</tt>), and
 * <tt>&lt;type&gt;</tt> is one of:
 * <ul>
 * <li><tt>years</tt></li>
 * <li><tt>months</tt></li>
 * <li><tt>weeks</tt></li>
 * <li><tt>days</tt></li>
 * <li><tt>hours</tt></li>
 * <li><tt>minutes</tt></li>
 * <li><tt>seconds</tt></li>
 * </ul>
 * For example, any of the following directives can be used to make documents
 * expire 1 month after being accessed, by default:
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;&lt;param-value&gt;access plus 1 month&lt;/param-value&gt;
 * &lt;/init-param&gt;
 *  
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;&lt;param-value&gt;access plus 4 weeks&lt;/param-value&gt;
 * &lt;/init-param&gt;
 *  
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;&lt;param-value&gt;access plus 30 days&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * <p>
 * The expiry time can be fine-tuned by adding several &#x27;
 * <tt>&lt;num&gt; &lt;type&gt;</tt>&#x27; clauses:
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresByType text/html&lt;/param-name&gt;&lt;param-value&gt;access plus 1 month 15   days 2 hours&lt;/param-value&gt;
 * &lt;/init-param&gt;
 *  
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresByType image/gif&lt;/param-name&gt;&lt;param-value&gt;modification plus 5 hours 3   minutes&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * <p>
 * Note that if you use a modification date based setting, the <tt>Expires</tt>
 * header will <strong>not</strong> be added to content that does not come from
 * a file on disk. This is due to the fact that there is no modification time
 * for such content.
 * </p>
 * <h1>Expiration headers generation eligibility</h1>
 * <p>
 * A response is eligible to be enriched by <tt>ExpiresFilter</tt> if :
 * <ol>
 * <li>no expiration header is defined (<tt>Expires</tt> header or the
 * <tt>max-age</tt> directive of the <tt>Cache-Control</tt> header),</li>
 * <li>the response status code is not excluded by the directive
 * <tt>ExpiresExcludedResponseStatusCodes</tt>,</li>
 * <li>The <tt>Content-Type</tt> of the response matches one of the types
 * defined the in <tt>ExpiresByType</tt> directives or the
 * <tt>ExpiresDefault</tt> directive is defined.</li>
 * </ol>
 * </p>
 * <p>
 * Note :
 * <ul>
 * <li>If <tt>Cache-Control</tt> header contains other directives than
 * <tt>max-age</tt>, they are concatenated with the <tt>max-age</tt> directive
 * that is added by the <tt>ExpiresFilter</tt>.</li>
 * </ul>
 * </p>
 * <h1>Expiration configuration selection</h1>
 * <p>
 * The expiration configuration if elected according to the following algorithm:
 * <ol>
 * <li><tt>ExpiresByType</tt> matching the exact content-type returned by
 * <tt>HttpServletResponse.getContentType()</tt> possibly including the charset
 * (e.g. &#x27;<tt>text/xml;charset=UTF-8</tt>&#x27;),</li>
 * <li><tt>ExpiresByType</tt> matching the content-type without the charset if
 * <tt>HttpServletResponse.getContentType()</tt> contains a charset (e.g. &#x27;
 * <tt>text/xml;charset=UTF-8</tt>&#x27; -&gt; &#x27;<tt>text/xml</tt>&#x27;),</li>
 * <li><tt>ExpiresByType</tt> matching the major type (e.g. substring before
 * &#x27;<tt>/</tt>&#x27;) of <tt>HttpServletResponse.getContentType()</tt>
 * (e.g. &#x27;<tt>text/xml;charset=UTF-8</tt>&#x27; -&gt; &#x27;<tt>text</tt>
 * &#x27;),</li>
 * <li><tt>ExpiresDefault</tt></li>
 * </ol>
 * </p>
 * <h1>Implementation Details</h1><h2>When to write the expiration headers ?</h2>
 * <p>
 * The <tt>ExpiresFilter</tt> traps the &#x27;on before write response
 * body&#x27; event to decide whether it should generate expiration headers or
 * not.
 * </p>
 * <p>
 * To trap the &#x27;before write response body&#x27; event, the
 * <tt>ExpiresFilter</tt> wraps the http servlet response&#x27;s writer and
 * outputStream to intercept calls to the methods <tt>write()</tt>,
 * <tt>print()</tt>, <tt>close()</tt> and <tt>flush()</tt>. For empty response
 * body (e.g. empty files), the <tt>write()</tt>, <tt>print()</tt>,
 * <tt>close()</tt> and <tt>flush()</tt> methods are not called; to handle this
 * case, the <tt>ExpiresFilter</tt>, at the end of its <tt>doFilter()</tt>
 * method, manually triggers the <tt>onBeforeWriteResponseBody()</tt> method.
 * </p>
 * <h2>Configuration syntax</h2>
 * <p>
 * The <tt>ExpiresFilter</tt> supports the same configuration syntax as Apache
 * Httpd mod_expires.
 * </p>
 * <p>
 * A challenge has been to choose the name of the <tt>&lt;param-name&gt;</tt>
 * associated with <tt>ExpiresByType</tt> in the <tt>&lt;filter&gt;</tt>
 * declaration. Indeed, Several <tt>ExpiresByType</tt> directives can be
 * declared when <tt>web.xml</tt> syntax does not allow to declare several
 * <tt>&lt;init-param&gt;</tt> with the same name.
 * </p>
 * <p>
 * The workaround has been to declare the content type in the
 * <tt>&lt;param-name&gt;</tt> rather than in the <tt>&lt;param-value&gt;</tt>.
 * </p>
 * <h2>Designed for extension : the open/close principle</h2>
 * <p>
 * The <tt>ExpiresFilter</tt> has been designed for extension following the
 * open/close principle.
 * </p>
 * <p>
 * Key methods to override for extension are :
 * <ul>
 * <li>
 * {@link #isEligibleToExpirationHeaderGeneration(HttpServletRequest, XHttpServletResponse)}
 * </li>
 * <li>
 * {@link #getExpirationDate(HttpServletRequest, XHttpServletResponse)}</li>
 * </ul>
 * </p>
 * <h1>Troubleshooting</h1>
 * <p>
 * To troubleshoot, enable logging on the
 * <tt>org.apache.catalina.filters.ExpiresFilter</tt>.
 * </p>
 * <p>
 * Extract of logging.properties
 * </p>
 * 
 * <code><pre>
 * org.apache.catalina.filters.ExpiresFilter.level = FINE
 * </pre></code>
 * <p>
 * Sample of initialization log message :
 * </p>
 * 
 * <code><pre>
 * Mar 26, 2010 2:01:41 PM org.apache.catalina.filters.ExpiresFilter init
 * FINE: Filter initialized with configuration ExpiresFilter[
 *    active=true, 
 *    excludedResponseStatusCode=[304], 
 *    default=null, 
 *    byType={
 *       image=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]], 
 *       text/css=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]], 
 *       text/javascript=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]]}]
 * </pre></code>
 * <p>
 * Sample of per-request log message where <tt>ExpiresFilter</tt> adds an
 * expiration date
 * </p>
 * 
 * <code><pre>
 * Mar 26, 2010 2:09:47 PM org.apache.catalina.filters.ExpiresFilter onBeforeWriteResponseBody
 * FINE: Request "/tomcat.gif" with response status "200" content-type "image/gif", set expiration date 3/26/10 2:19 PM
 * </pre></code>
 * <p>
 * Sample of per-request log message where <tt>ExpiresFilter</tt> does not add
 * an expiration date
 * </p>
 * 
 * <code><pre>
 * Mar 26, 2010 2:10:27 PM org.apache.catalina.filters.ExpiresFilter onBeforeWriteResponseBody
 * FINE: Request "/docs/config/manager.html" with response status "200" content-type "text/html", no expiration configured
 * </pre></code>
 * 
 */
    /**
     * Duration composed of an {@link #amount} and a {@link #unit}
     */
    protected static class Duration {
        public static Duration minutes(int amount) {
            return new Duration(amount, DurationUnit.MINUTE);
        }
        public static Duration seconds(int amount) {
            return new Duration(amount, DurationUnit.SECOND);
        }
        final protected int amount;
        final protected DurationUnit unit;
        public Duration(int amount, DurationUnit unit) {
            super();
            this.amount = amount;
            this.unit = unit;
        }
        public int getAmount() {
            return amount;
        }
        public DurationUnit getUnit() {
            return unit;
        }
        @Override
        public String toString() {
            return amount + " " + unit;
        }
    }
    /**
     * Duration unit
     */
    protected enum DurationUnit {
        DAY(Calendar.DAY_OF_YEAR), HOUR(Calendar.HOUR), MINUTE(Calendar.MINUTE), MONTH(
                Calendar.MONTH), SECOND(Calendar.SECOND), WEEK(
                Calendar.WEEK_OF_YEAR), YEAR(Calendar.YEAR);
        private final int calendardField;
        private DurationUnit(int calendardField) {
            this.calendardField = calendardField;
        }
        public int getCalendardField() {
            return calendardField;
        }
    }
    /**
     * <p>
     * Main piece of configuration of the filter.
     * </p>
     * <p>
     * Can be expressed like '<tt>access plus 1 month 15   days 2 hours</tt>'.
     * </p>
     */
    protected static class ExpiresConfiguration {
        /**
         * List of duration elements.
         */
        private List<Duration> durations;
        /**
         * Starting point of the elaspse to set in the response.
         */
        private StartingPoint startingPoint;
        public ExpiresConfiguration(StartingPoint startingPoint,
                Duration... durations) {
            this(startingPoint, Arrays.asList(durations));
        }
        public ExpiresConfiguration(StartingPoint startingPoint,
                List<Duration> durations) {
            super();
            this.startingPoint = startingPoint;
            this.durations = durations;
        }
        public List<Duration> getDurations() {
            return durations;
        }
        public StartingPoint getStartingPoint() {
            return startingPoint;
        }
        @Override
        public String toString() {
            return "ExpiresConfiguration[startingPoint=" + startingPoint +
                    ", duration=" + durations + "]";
        }
    }
    /**
     * Expiration configuration starting point. Either the time the
     * html-page/servlet-response was served ({@link StartingPoint#ACCESS_TIME})
     * or the last time the html-page/servlet-response was modified (
     * {@link StartingPoint#LAST_MODIFICATION_TIME}).
     */
    protected enum StartingPoint {
        ACCESS_TIME, LAST_MODIFICATION_TIME
    }
    /**
     * <p>
     * Wrapping extension of the {@link HttpServletResponse} to yrap the
     * "Start Write Response Body" event.
     * </p>
     * <p>
     * For performance optimization : this extended response holds the
     * {@link #lastModifiedHeader} and {@link #cacheControlHeader} values access
     * to the slow {@link #getHeader(String)} and to spare the <tt>string</tt>
     * to <tt>date</tt> to <tt>long</tt> conversion.
     * </p>
     */
    public class XHttpServletResponse extends HttpServletResponseWrapper {
        /**
         * Value of the <tt>Cache-Control/tt> http response header if it has
         * been set.
         */
        private String cacheControlHeader;
        /**
         * Value of the <tt>Last-Modified</tt> http response header if it has
         * been set.
         */
        private long lastModifiedHeader;
        private boolean lastModifiedHeaderSet;
        private PrintWriter printWriter;
        private HttpServletRequest request;
        private ServletOutputStream servletOutputStream;
        /**
         * Indicates whether calls to write methods (<tt>write(...)</tt>,
         * <tt>print(...)</tt>, etc) of the response body have been called or
         * not.
         */
        private boolean writeResponseBodyStarted;
        public XHttpServletResponse(HttpServletRequest request,
                HttpServletResponse response) {
            super(response);
            this.request = request;
        }
        @Override
        public void addDateHeader(String name, long date) {
            super.addDateHeader(name, date);
            if (!lastModifiedHeaderSet) {
                this.lastModifiedHeader = date;
                this.lastModifiedHeaderSet = true;
            }
        }
        @Override
        public void addHeader(String name, String value) {
            super.addHeader(name, value);
            if (HEADER_CACHE_CONTROL.equalsIgnoreCase(name) &&
                    cacheControlHeader == null) {
                cacheControlHeader = value;
            }
        }
        public String getCacheControlHeader() {
            return cacheControlHeader;
        }
        public long getLastModifiedHeader() {
            return lastModifiedHeader;
        }
        @Override
        public ServletOutputStream getOutputStream() throws IOException {
            if (servletOutputStream == null) {
                servletOutputStream = new XServletOutputStream(
                        super.getOutputStream(), request, this);
            }
            return servletOutputStream;
        }
        @Override
        public PrintWriter getWriter() throws IOException {
            if (printWriter == null) {
                printWriter = new XPrintWriter(super.getWriter(), request, this);
            }
            return printWriter;
        }
        public boolean isLastModifiedHeaderSet() {
            return lastModifiedHeaderSet;
        }
        public boolean isWriteResponseBodyStarted() {
            return writeResponseBodyStarted;
        }
        @Override
        public void reset() {
            super.reset();
            this.lastModifiedHeader = 0;
            this.lastModifiedHeaderSet = false;
            this.cacheControlHeader = null;
        }
        @Override
        public void setDateHeader(String name, long date) {
            super.setDateHeader(name, date);
            if (HEADER_LAST_MODIFIED.equalsIgnoreCase(name)) {
                this.lastModifiedHeader = date;
                this.lastModifiedHeaderSet = true;
            }
        }
        @Override
        public void setHeader(String name, String value) {
            super.setHeader(name, value);
            if (HEADER_CACHE_CONTROL.equalsIgnoreCase(name)) {
                this.cacheControlHeader = value;
            }
        }
        public void setWriteResponseBodyStarted(boolean writeResponseBodyStarted) {
            this.writeResponseBodyStarted = writeResponseBodyStarted;
        }
    }
    /**
     * Wrapping extension of {@link PrintWriter} to trap the
     * "Start Write Response Body" event.
     */
    public class XPrintWriter extends PrintWriter {
        private PrintWriter out;
        private HttpServletRequest request;
        private XHttpServletResponse response;
        public XPrintWriter(PrintWriter out, HttpServletRequest request,
                XHttpServletResponse response) {
            super(out);
            this.out = out;
            this.request = request;
            this.response = response;
        }
        @Override
        public PrintWriter append(char c) {
            fireBeforeWriteResponseBodyEvent();
            return out.append(c);
        }
        @Override
        public PrintWriter append(CharSequence csq) {
            fireBeforeWriteResponseBodyEvent();
            return out.append(csq);
        }
        @Override
        public PrintWriter append(CharSequence csq, int start, int end) {
            fireBeforeWriteResponseBodyEvent();
            return out.append(csq, start, end);
        }
        @Override
        public void close() {
            fireBeforeWriteResponseBodyEvent();
            out.close();
        }
        private void fireBeforeWriteResponseBodyEvent() {
            if (!this.response.isWriteResponseBodyStarted()) {
                this.response.setWriteResponseBodyStarted(true);
                onBeforeWriteResponseBody(request, response);
            }
        }
        @Override
        public void flush() {
            fireBeforeWriteResponseBodyEvent();
            out.flush();
        }
        @Override
        public void print(boolean b) {
            fireBeforeWriteResponseBodyEvent();
            out.print(b);
        }
        @Override
        public void print(char c) {
            fireBeforeWriteResponseBodyEvent();
            out.print(c);
        }
        @Override
        public void print(char[] s) {
            fireBeforeWriteResponseBodyEvent();
            out.print(s);
        }
        @Override
        public void print(double d) {
            fireBeforeWriteResponseBodyEvent();
            out.print(d);
        }
        @Override
        public void print(float f) {
            fireBeforeWriteResponseBodyEvent();
            out.print(f);
        }
        @Override
        public void print(int i) {
            fireBeforeWriteResponseBodyEvent();
            out.print(i);
        }
        @Override
        public void print(long l) {
            fireBeforeWriteResponseBodyEvent();
            out.print(l);
        }
        @Override
        public void print(Object obj) {
            fireBeforeWriteResponseBodyEvent();
            out.print(obj);
        }
        @Override
        public void print(String s) {
            fireBeforeWriteResponseBodyEvent();
            out.print(s);
        }
        @Override
        public PrintWriter printf(Locale l, String format, Object... args) {
            fireBeforeWriteResponseBodyEvent();
            return out.printf(l, format, args);
        }
        @Override
        public PrintWriter printf(String format, Object... args) {
            fireBeforeWriteResponseBodyEvent();
            return out.printf(format, args);
        }
        @Override
        public void println() {
            fireBeforeWriteResponseBodyEvent();
            out.println();
        }
        @Override
        public void println(boolean x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(char x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(char[] x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(double x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(float x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(int x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(long x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(Object x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(String x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void write(char[] buf) {
            fireBeforeWriteResponseBodyEvent();
            out.write(buf);
        }
        @Override
        public void write(char[] buf, int off, int len) {
            fireBeforeWriteResponseBodyEvent();
            out.write(buf, off, len);
        }
        @Override
        public void write(int c) {
            fireBeforeWriteResponseBodyEvent();
            out.write(c);
        }
        @Override
        public void write(String s) {
            fireBeforeWriteResponseBodyEvent();
            out.write(s);
        }
        @Override
        public void write(String s, int off, int len) {
            fireBeforeWriteResponseBodyEvent();
            out.write(s, off, len);
        }
    }
    /**
     * Wrapping extension of {@link ServletOutputStream} to trap the
     * "Start Write Response Body" event.
     */
    public class XServletOutputStream extends ServletOutputStream {
        private HttpServletRequest request;
        private XHttpServletResponse response;
        private ServletOutputStream servletOutputStream;
        public XServletOutputStream(ServletOutputStream servletOutputStream,
                HttpServletRequest request, XHttpServletResponse response) {
            super();
            this.servletOutputStream = servletOutputStream;
            this.response = response;
            this.request = request;
        }
        @Override
        public void close() throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.close();
        }
        private void fireOnBeforeWriteResponseBodyEvent() {
            if (!this.response.isWriteResponseBodyStarted()) {
                this.response.setWriteResponseBodyStarted(true);
                onBeforeWriteResponseBody(request, response);
            }
        }
        @Override
        public void flush() throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.flush();
        }
        @Override
        public void print(boolean b) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(b);
        }
        @Override
        public void print(char c) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(c);
        }
        @Override
        public void print(double d) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(d);
        }
        @Override
        public void print(float f) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(f);
        }
        @Override
        public void print(int i) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(i);
        }
        @Override
        public void print(long l) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(l);
        }
        @Override
        public void print(String s) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(s);
        }
        @Override
        public void println() throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println();
        }
        @Override
        public void println(boolean b) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(b);
        }
        @Override
        public void println(char c) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(c);
        }
        @Override
        public void println(double d) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(d);
        }
        @Override
        public void println(float f) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(f);
        }
        @Override
        public void println(int i) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(i);
        }
        @Override
        public void println(long l) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(l);
        }
        @Override
        public void println(String s) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(s);
        }
        @Override
        public void write(byte[] b) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.write(b);
        }
        @Override
        public void write(byte[] b, int off, int len) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.write(b, off, len);
        }
        @Override
        public void write(int b) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.write(b);
        }
    }
    /**
     * {@link Pattern} for a comma delimited string that support whitespace
     * characters
     */
    private static final Pattern commaSeparatedValuesPattern = Pattern.compile("\\s*,\\s*");
    private static final String HEADER_CACHE_CONTROL = "Cache-Control";
    private static final String HEADER_EXPIRES = "Expires";
    private static final String HEADER_LAST_MODIFIED = "Last-Modified";
    private static final Log log = LogFactory.getLog(ExpiresFilter.class);
    private static final String PARAMETER_EXPIRES_ACTIVE = "ExpiresActive";
    private static final String PARAMETER_EXPIRES_BY_TYPE = "ExpiresByType";
    private static final String PARAMETER_EXPIRES_DEFAULT = "ExpiresDefault";
    private static final String PARAMETER_EXPIRES_EXCLUDED_RESPONSE_STATUS_CODES = "ExpiresExcludedResponseStatusCodes";
    /**
     * Convert a comma delimited list of numbers into an <tt>int[]</tt>.
     * 
     * @param commaDelimitedInts
     *            can be <code>null</code>
     * @return never <code>null</code> array
     */
    protected static int[] commaDelimitedListToIntArray(
            String commaDelimitedInts) {
        String[] intsAsStrings = commaDelimitedListToStringArray(commaDelimitedInts);
        int[] ints = new int[intsAsStrings.length];
        for (int i = 0; i < intsAsStrings.length; i++) {
            String intAsString = intsAsStrings[i];
            try {
                ints[i] = Integer.parseInt(intAsString);
            } catch (NumberFormatException e) {
                throw new RuntimeException("Exception parsing number '" + i +
                        "' (zero based) of comma delimited list '" +
                        commaDelimitedInts + "'");
            }
        }
        return ints;
    }
    /**
     * Convert a given comma delimited list of strings into an array of String
     * 
     * @return array of patterns (non <code>null</code>)
     */
    protected static String[] commaDelimitedListToStringArray(
            String commaDelimitedStrings) {
        return (commaDelimitedStrings == null || commaDelimitedStrings.length() == 0) ? new String[0]
                : commaSeparatedValuesPattern.split(commaDelimitedStrings);
    }
    /**
     * Return <code>true</code> if the given <code>str</code> contains the given
     * <code>searchStr</code>.
     */
    protected static boolean contains(String str, String searchStr) {
        if (str == null || searchStr == null) {
            return false;
        }
        return str.indexOf(searchStr) >= 0;
    }
    /**
     * Convert an array of ints into a comma delimited string
     */
    protected static String intsToCommaDelimitedString(int[] ints) {
        if (ints == null) {
            return "";
        }
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < ints.length; i++) {
            result.append(ints[i]);
            if (i < (ints.length - 1)) {
                result.append(", ");
            }
        }
        return result.toString();
    }
    /**
     * Return <code>true</code> if the given <code>str</code> is
     * <code>null</code> or has a zero characters length.
     */
    protected static boolean isEmpty(String str) {
        return str == null || str.length() == 0;
    }
    /**
     * Return <code>true</code> if the given <code>str</code> has at least one
     * character (can be a withespace).
     */
    protected static boolean isNotEmpty(String str) {
        return !isEmpty(str);
    }
    /**
     * Return <code>true</code> if the given <code>string</code> starts with the
     * given <code>prefix</code> ignoring case.
     * 
     * @param string
     *            can be <code>null</code>
     * @param prefix
     *            can be <code>null</code>
     */
    protected static boolean startsWithIgnoreCase(String string, String prefix) {
        if (string == null || prefix == null) {
            return string == null && prefix == null;
        }
        if (prefix.length() > string.length()) {
            return false;
        }
        return string.regionMatches(true, 0, prefix, 0, prefix.length());
    }
    /**
     * Return the subset of the given <code>str</code> that is before the first
     * occurence of the given <code>separator</code>. Return <code>null</code>
     * if the given <code>str</code> or the given <code>separator</code> is
     * null. Return and empty string if the <code>separator</code> is empty.
     * 
     * @param str
     *            can be <code>null</code>
     * @param separator
     *            can be <code>null</code>
     * @return
     */
    protected static String substringBefore(String str, String separator) {
        if (str == null || str.isEmpty() || separator == null) {
            return null;
        }
        if (separator.isEmpty()) {
            return "";
        }
        int separatorIndex = str.indexOf(separator);
        if (separatorIndex == -1) {
            return str;
        }
        return str.substring(0, separatorIndex);
    }
    /**
     * @see #isActive()
     */
    private boolean active = true;
    /**
     * Default Expires configuration.
     */
    private ExpiresConfiguration defaultExpiresConfiguration;
    /**
     * list of response status code for which the {@link ExpiresFilter} will not
     * generate expiration headers.
     */
    private int[] excludedResponseStatusCodes = new int[] { HttpServletResponse.SC_NOT_MODIFIED };
    /**
     * Expires configuration by content type. Visible for test.
     */
    private Map<String, ExpiresConfiguration> expiresConfigurationByContentType = new LinkedHashMap<String, ExpiresConfiguration>();
    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {
        if (request instanceof HttpServletRequest &&
                response instanceof HttpServletResponse) {
            HttpServletRequest httpRequest = (HttpServletRequest) request;
            HttpServletResponse httpResponse = (HttpServletResponse) response;
            if (response.isCommitted()) {
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString(
                            "expiresFilter.responseAlreadyCommited",
                            httpRequest.getRequestURL()));
                }
                chain.doFilter(request, response);
            } else if (active) {
                XHttpServletResponse xResponse = new XHttpServletResponse(
                        httpRequest, httpResponse);
                chain.doFilter(request, xResponse);
                if (!xResponse.isWriteResponseBodyStarted()) {
                    // Empty response, manually trigger
                    // onBeforeWriteResponseBody()
                    onBeforeWriteResponseBody(httpRequest, xResponse);
                }
            } else {
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("expiresFilter.filterNotActive",
                            httpRequest.getRequestURL()));
                }
                chain.doFilter(request, response);
            }
        } else {
            chain.doFilter(request, response);
        }
    }
    public ExpiresConfiguration getDefaultExpiresConfiguration() {
        return defaultExpiresConfiguration;
    }
    public String getExcludedResponseStatusCodes() {
        return intsToCommaDelimitedString(excludedResponseStatusCodes);
    }
    public int[] getExcludedResponseStatusCodesAsInts() {
        return excludedResponseStatusCodes;
    }
    /**
     * <p>
     * Returns the expiration date of the given {@link XHttpServletResponse} or
     * <code>null</code> if no expiration date has been configured for the
     * declared content type.
     * </p>
     * <p>
     * <code>protected</code> for extension.
     * </p>
     * 
     * @see HttpServletResponse#getContentType()
     */
    protected Date getExpirationDate(XHttpServletResponse response) {
        String contentType = response.getContentType();
        // lookup exact content-type match (e.g.
        // "text/html; charset=iso-8859-1")
        ExpiresConfiguration configuration = expiresConfigurationByContentType.get(contentType);
        if (configuration != null) {
            Date result = getExpirationDate(configuration, response);
            if (log.isErrorEnabled()) {
                log.error(sm.getString(
                        "expiresFilter.useMatchingConfiguration",
                        configuration, contentType, contentType, result));
            }
            return result;
        }
        if (contains(contentType, ";")) {
            // lookup content-type without charset match (e.g. "text/html")
            String contentTypeWithoutCharset = substringBefore(contentType, ";").trim();
            configuration = expiresConfigurationByContentType.get(contentTypeWithoutCharset);
            if (configuration != null) {
                Date result = getExpirationDate(configuration, response);
                if (log.isErrorEnabled()) {
                    log.error(sm.getString(
                            "expiresFilter.useMatchingConfiguration",
                            configuration, contentTypeWithoutCharset,
                            contentType, result));
                }
                return result;
            }
        }
        if (contains(contentType, "/")) {
            // lookup major type match (e.g. "text")
            String majorType = substringBefore(contentType, "/");
            configuration = expiresConfigurationByContentType.get(majorType);
            if (configuration != null) {
                Date result = getExpirationDate(configuration, response);
                if (log.isErrorEnabled()) {
                    log.error(sm.getString(
                            "expiresFilter.useMatchingConfiguration",
                            configuration, majorType, contentType, result));
                }
                return result;
            }
        }
        if (defaultExpiresConfiguration != null) {
            Date result = getExpirationDate(defaultExpiresConfiguration,
                    response);
            if (log.isErrorEnabled()) {
                log.error(sm.getString("expiresFilter.useDefaultConfiguration",
                        defaultExpiresConfiguration, contentType, result));
            }
            return result;
        }
        if (log.isErrorEnabled()) {
            log.error(sm.getString(
                    "expiresFilter.noExpirationConfiguredForContentType",
                    contentType));
        }
        return null;
    }
    /**
     * <p>
     * Returns the expiration date of the given {@link ExpiresConfiguration},
     * {@link HttpServletRequest} and {@link XHttpServletResponse}.
     * </p>
     * <p>
     * <code>protected</code> for extension.
     * </p>
     */
    protected Date getExpirationDate(ExpiresConfiguration configuration,
            XHttpServletResponse response) {
        Calendar calendar;
        switch (configuration.getStartingPoint()) {
        case ACCESS_TIME:
            calendar = Calendar.getInstance();
            break;
        case LAST_MODIFICATION_TIME:
            if (response.isLastModifiedHeaderSet()) {
                try {
                    long lastModified = response.getLastModifiedHeader();
                    calendar = Calendar.getInstance();
                    calendar.setTimeInMillis(lastModified);
                } catch (NumberFormatException e) {
                    // default to now
                    calendar = Calendar.getInstance();
                }
            } else {
                // Last-Modified header not found, use now
                calendar = Calendar.getInstance();
            }
            break;
        default:
            throw new IllegalStateException(sm.getString(
                    "expiresFilter.unsupportedStartingPoint",
                    configuration.getStartingPoint()));
        }
        for (Duration duration : configuration.getDurations()) {
            calendar.add(duration.getUnit().getCalendardField(),
                    duration.getAmount());
        }
        return calendar.getTime();
    }
    public Map<String, ExpiresConfiguration> getExpiresConfigurationByContentType() {
        return expiresConfigurationByContentType;
    }
    @Override
    protected Log getLogger() {
        return log;
    }
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        for (Enumeration<String> names = filterConfig.getInitParameterNames(); names.hasMoreElements();) {
            String name = names.nextElement();
            String value = filterConfig.getInitParameter(name);
            try {
                if (name.startsWith(PARAMETER_EXPIRES_BY_TYPE)) {
                    String contentType = name.substring(
                            PARAMETER_EXPIRES_BY_TYPE.length()).trim();
                    ExpiresConfiguration expiresConfiguration = parseExpiresConfiguration(value);
                    this.expiresConfigurationByContentType.put(contentType,
                            expiresConfiguration);
                } else if (name.equalsIgnoreCase(PARAMETER_EXPIRES_DEFAULT)) {
                    ExpiresConfiguration expiresConfiguration = parseExpiresConfiguration(value);
                    this.defaultExpiresConfiguration = expiresConfiguration;
                } else if (name.equalsIgnoreCase(PARAMETER_EXPIRES_ACTIVE)) {
                    this.active = "On".equalsIgnoreCase(value) ||
                            Boolean.valueOf(value).booleanValue();
                } else if (name.equalsIgnoreCase(PARAMETER_EXPIRES_EXCLUDED_RESPONSE_STATUS_CODES)) {
                    this.excludedResponseStatusCodes = commaDelimitedListToIntArray(value);
                } else {
                    log.warn(sm.getString(
                            "expiresFilter.unknownParameterIgnored", name,
                            value));
                }
            } catch (RuntimeException e) {
                throw new ServletException(sm.getString(
                        "expiresFilter.exceptionProcessingParameter", name,
                        value), e);
            }
        }
        log.debug(sm.getString("expiresFilter.filterInitialized",
                this.toString()));
    }
    /**
     * Indicates that the filter is active. If <code>false</code>, the filter is
     * pass-through. Default is <code>true</code>.
     */
    public boolean isActive() {
        return active;
    }
    /**
     * 
     * <p>
     * <code>protected</code> for extension.
     * </p>
     */
    protected boolean isEligibleToExpirationHeaderGeneration(
            HttpServletRequest request, XHttpServletResponse response) {
        boolean expirationHeaderHasBeenSet = response.containsHeader(HEADER_EXPIRES) ||
                contains(response.getCacheControlHeader(), "max-age");
        if (expirationHeaderHasBeenSet) {
            if (log.isDebugEnabled()) {
                log.debug(sm.getString(
                        "expiresFilter.expirationHeaderAlreadyDefined",
                        request.getRequestURI(),
                        Integer.valueOf(response.getStatus()),
                        response.getContentType()));
            }
            return false;
        }
        for (int skippedStatusCode : this.excludedResponseStatusCodes) {
            if (response.getStatus() == skippedStatusCode) {
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("expiresFilter.skippedStatusCode",
                            request.getRequestURI(),
                            Integer.valueOf(response.getStatus()),
                            response.getContentType()));
                }
                return false;
            }
        }
        return true;
    }
    /**
     * <p>
     * If no expiration header has been set by the servlet and an expiration has
     * been defined in the {@link ExpiresFilter} configuration, sets the '
     * <tt>Expires</tt>' header and the attribute '<tt>max-age</tt>' of the '
     * <tt>Cache-Control</tt>' header.
     * </p>
     * <p>
     * Must be called on the "Start Write Response Body" event.
     * </p>
     * <p>
     * Invocations to <tt>Logger.debug(...)</tt> are guarded by
     * {@link Logger#isDebugEnabled()} because
     * {@link HttpServletRequest#getRequestURI()} and
     * {@link HttpServletResponse#getContentType()} costs <tt>String</tt>
     * objects instantiations (as of Tomcat 7).
     * </p>
     */
    public void onBeforeWriteResponseBody(HttpServletRequest request,
            XHttpServletResponse response) {
        if (!isEligibleToExpirationHeaderGeneration(request, response)) {
            return;
        }
        Date expirationDate = getExpirationDate(response);
        if (expirationDate == null) {
            if (log.isDebugEnabled()) {
                log.debug(sm.getString("expiresFilter.noExpirationConfigured",
                        request.getRequestURI(),
                        Integer.valueOf(response.getStatus()),
                        response.getContentType()));
            }
        } else {
            if (log.isDebugEnabled()) {
                log.debug(sm.getString("expiresFilter.setExpirationDate",
                        request.getRequestURI(),
                        Integer.valueOf(response.getStatus()),
                        response.getContentType(), expirationDate));
            }
            String maxAgeDirective = "max-age=" +
                    ((expirationDate.getTime() - System.currentTimeMillis()) / 1000);
            String cacheControlHeader = response.getCacheControlHeader();
            String newCacheControlHeader = (cacheControlHeader == null) ? maxAgeDirective
                    : cacheControlHeader + ", " + maxAgeDirective;
            response.setHeader(HEADER_CACHE_CONTROL, newCacheControlHeader);
            response.setDateHeader(HEADER_EXPIRES, expirationDate.getTime());
        }
    }
    /**
     * Parse configuration lines like '
     * <tt>access plus 1 month 15 days 2 hours</tt>' or '
     * <tt>modification 1 day 2 hours 5 seconds</tt>'
     * 
     * @param inputLine
     */
    protected ExpiresConfiguration parseExpiresConfiguration(String inputLine) {
        String line = inputLine.trim();
        StringTokenizer tokenizer = new StringTokenizer(line, " ");
        String currentToken;
        try {
            currentToken = tokenizer.nextToken();
        } catch (NoSuchElementException e) {
            throw new IllegalStateException(sm.getString(
                    "expiresFilter.startingPointNotFound", line));
        }
        StartingPoint startingPoint;
        if ("access".equalsIgnoreCase(currentToken) ||
                "now".equalsIgnoreCase(currentToken)) {
            startingPoint = StartingPoint.ACCESS_TIME;
        } else if ("modification".equalsIgnoreCase(currentToken)) {
            startingPoint = StartingPoint.LAST_MODIFICATION_TIME;
        } else if (!tokenizer.hasMoreTokens() &&
                startsWithIgnoreCase(currentToken, "a")) {
            startingPoint = StartingPoint.ACCESS_TIME;
            // trick : convert duration configuration from old to new style
            tokenizer = new StringTokenizer(currentToken.substring(1) +
                    " seconds", " ");
        } else if (!tokenizer.hasMoreTokens() &&
                startsWithIgnoreCase(currentToken, "m")) {
            startingPoint = StartingPoint.LAST_MODIFICATION_TIME;
            // trick : convert duration configuration from old to new style
            tokenizer = new StringTokenizer(currentToken.substring(1) +
                    " seconds", " ");
        } else {
            throw new IllegalStateException(sm.getString(
                    "expiresFilter.startingPointInvalid", currentToken, line));
        }
        try {
            currentToken = tokenizer.nextToken();
        } catch (NoSuchElementException e) {
            throw new IllegalStateException(sm.getString(
                    "Duration not found in directive '{}'", line));
        }
        if ("plus".equalsIgnoreCase(currentToken)) {
            // skip
            try {
                currentToken = tokenizer.nextToken();
            } catch (NoSuchElementException e) {
                throw new IllegalStateException(sm.getString(
                        "Duration not found in directive '{}'", line));
            }
        }
        List<Duration> durations = new ArrayList<Duration>();
        while (currentToken != null) {
            int amount;
            try {
                amount = Integer.parseInt(currentToken);
            } catch (NumberFormatException e) {
                throw new IllegalStateException(sm.getString(
                        "Invalid duration (number) '{}' in directive '{}'",
                        currentToken, line));
            }
            try {
                currentToken = tokenizer.nextToken();
            } catch (NoSuchElementException e) {
                throw new IllegalStateException(
                        sm.getString(
                                "Duration unit not found after amount {} in directive '{}'",
                                Integer.valueOf(amount), line));
            }
            DurationUnit durationUnit;
            if ("years".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.YEAR;
            } else if ("month".equalsIgnoreCase(currentToken) ||
                    "months".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.MONTH;
            } else if ("week".equalsIgnoreCase(currentToken) ||
                    "weeks".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.WEEK;
            } else if ("day".equalsIgnoreCase(currentToken) ||
                    "days".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.DAY;
            } else if ("hour".equalsIgnoreCase(currentToken) ||
                    "hours".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.HOUR;
            } else if ("minute".equalsIgnoreCase(currentToken) ||
                    "minutes".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.MINUTE;
            } else if ("second".equalsIgnoreCase(currentToken) ||
                    "seconds".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.SECOND;
            } else {
                throw new IllegalStateException(
                        sm.getString(
                                "Invalid duration unit (years|months|weeks|days|hours|minutes|seconds) '{}' in directive '{}'",
                                currentToken, line));
            }
            Duration duration = new Duration(amount, durationUnit);
            durations.add(duration);
            if (tokenizer.hasMoreTokens()) {
                currentToken = tokenizer.nextToken();
            } else {
                currentToken = null;
            }
        }
        return new ExpiresConfiguration(startingPoint, durations);
    }
    public void setActive(boolean active) {
        this.active = active;
    }
    public void setDefaultExpiresConfiguration(
            ExpiresConfiguration defaultExpiresConfiguration) {
        this.defaultExpiresConfiguration = defaultExpiresConfiguration;
    }
    public void setExcludedResponseStatusCodes(int[] excludedResponseStatusCodes) {
        this.excludedResponseStatusCodes = excludedResponseStatusCodes;
    }
    public void setExpiresConfigurationByContentType(
            Map<String, ExpiresConfiguration> expiresConfigurationByContentType) {
        this.expiresConfigurationByContentType = expiresConfigurationByContentType;
    }
    @Override
    public String toString() {
        return getClass().getSimpleName() + "[active=" + this.active +
                ", excludedResponseStatusCode=[" +
                intsToCommaDelimitedString(this.excludedResponseStatusCodes) +
                "], default=" + this.defaultExpiresConfiguration + ", byType=" +
                this.expiresConfigurationByContentType + "]";
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    public static final String TEMP_DIR = System.getProperty("java.io.tmpdir");
    public void testConfiguration() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        Context root = tomcat.addContext("", TEMP_DIR);
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("ExpiresDefault", "access plus 1 month");
        filterDef.addInitParameter("ExpiresByType text/html",
                "access plus 1 month 15 days 2 hours");
        filterDef.addInitParameter("ExpiresByType image/gif",
                "modification plus 5 hours 3 minutes");
        filterDef.addInitParameter("ExpiresByType image/jpg", "A10000");
        filterDef.addInitParameter("ExpiresByType video/mpeg", "M20000");
        filterDef.addInitParameter("ExpiresActive", "Off");
        filterDef.addInitParameter("ExpiresExcludedResponseStatusCodes",
                "304, 503");
        ExpiresFilter expiresFilter = new ExpiresFilter();
        filterDef.setFilter(expiresFilter);
        filterDef.setFilterClass(ExpiresFilter.class.getName());
        filterDef.setFilterName(ExpiresFilter.class.getName());
        root.addFilterDef(filterDef);
        FilterMap filterMap = new FilterMap();
        filterMap.setFilterName(ExpiresFilter.class.getName());
        filterMap.addURLPattern("*");
        tomcat.start();
        try {
            Assert.assertEquals(false, expiresFilter.isActive());
            // VERIFY EXCLUDED RESPONSE STATUS CODES
            {
                int[] excludedResponseStatusCodes = expiresFilter.getExcludedResponseStatusCodesAsInts();
                Assert.assertEquals(2, excludedResponseStatusCodes.length);
                Assert.assertEquals(304, excludedResponseStatusCodes[0]);
                Assert.assertEquals(503, excludedResponseStatusCodes[1]);
            }
            // VERIFY DEFAULT CONFIGURATION
            {
                ExpiresConfiguration expiresConfiguration = expiresFilter.getDefaultExpiresConfiguration();
                Assert.assertEquals(StartingPoint.ACCESS_TIME,
                        expiresConfiguration.getStartingPoint());
                Assert.assertEquals(1,
                        expiresConfiguration.getDurations().size());
                Assert.assertEquals(DurationUnit.MONTH,
                        expiresConfiguration.getDurations().get(0).getUnit());
                Assert.assertEquals(1, expiresConfiguration.getDurations().get(
                        0).getAmount());
            }
            // VERIFY TEXT/HTML
            {
                ExpiresConfiguration expiresConfiguration = expiresFilter.getExpiresConfigurationByContentType().get(
                        "text/html");
                Assert.assertEquals(StartingPoint.ACCESS_TIME,
                        expiresConfiguration.getStartingPoint());
                Assert.assertEquals(3,
                        expiresConfiguration.getDurations().size());
                Duration oneMonth = expiresConfiguration.getDurations().get(0);
                Assert.assertEquals(DurationUnit.MONTH, oneMonth.getUnit());
                Assert.assertEquals(1, oneMonth.getAmount());
                Duration fifteenDays = expiresConfiguration.getDurations().get(
                        1);
                Assert.assertEquals(DurationUnit.DAY, fifteenDays.getUnit());
                Assert.assertEquals(15, fifteenDays.getAmount());
                Duration twoHours = expiresConfiguration.getDurations().get(2);
                Assert.assertEquals(DurationUnit.HOUR, twoHours.getUnit());
                Assert.assertEquals(2, twoHours.getAmount());
            }
            // VERIFY IMAGE/GIF
            {
                ExpiresConfiguration expiresConfiguration = expiresFilter.getExpiresConfigurationByContentType().get(
                        "image/gif");
                Assert.assertEquals(StartingPoint.LAST_MODIFICATION_TIME,
                        expiresConfiguration.getStartingPoint());
                Assert.assertEquals(2,
                        expiresConfiguration.getDurations().size());
                Duration fiveHours = expiresConfiguration.getDurations().get(0);
                Assert.assertEquals(DurationUnit.HOUR, fiveHours.getUnit());
                Assert.assertEquals(5, fiveHours.getAmount());
                Duration threeMinutes = expiresConfiguration.getDurations().get(
                        1);
                Assert.assertEquals(DurationUnit.MINUTE, threeMinutes.getUnit());
                Assert.assertEquals(3, threeMinutes.getAmount());
            }
            // VERIFY IMAGE/JPG
            {
                ExpiresConfiguration expiresConfiguration = expiresFilter.getExpiresConfigurationByContentType().get(
                        "image/jpg");
                Assert.assertEquals(StartingPoint.ACCESS_TIME,
                        expiresConfiguration.getStartingPoint());
                Assert.assertEquals(1,
                        expiresConfiguration.getDurations().size());
                Duration tenThousandSeconds = expiresConfiguration.getDurations().get(
                        0);
                Assert.assertEquals(DurationUnit.SECOND,
                        tenThousandSeconds.getUnit());
                Assert.assertEquals(10000, tenThousandSeconds.getAmount());
            }
            // VERIFY VIDEO/MPEG
            {
                ExpiresConfiguration expiresConfiguration = expiresFilter.getExpiresConfigurationByContentType().get(
                        "video/mpeg");
                Assert.assertEquals(StartingPoint.LAST_MODIFICATION_TIME,
                        expiresConfiguration.getStartingPoint());
                Assert.assertEquals(1,
                        expiresConfiguration.getDurations().size());
                Duration twentyThousandSeconds = expiresConfiguration.getDurations().get(
                        0);
                Assert.assertEquals(DurationUnit.SECOND,
                        twentyThousandSeconds.getUnit());
                Assert.assertEquals(20000, twentyThousandSeconds.getAmount());
            }
        } finally {
            tomcat.stop();
        }
    }
    /**
     * Test that a resource with empty content is also processed
     */
    public void testEmptyContent() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("text/plain");
                // no content is written in the response
            }
        };
        validate(servlet, Integer.valueOf(7 * 60));
    }
    public void testParseExpiresConfigurationCombinedDuration() {
        ExpiresFilter expiresFilter = new ExpiresFilter();
        ExpiresConfiguration actualConfiguration = expiresFilter.parseExpiresConfiguration("access plus 1 month 15 days 2 hours");
        Assert.assertEquals(StartingPoint.ACCESS_TIME,
                actualConfiguration.getStartingPoint());
        Assert.assertEquals(3, actualConfiguration.getDurations().size());
    }
    public void testParseExpiresConfigurationMonoDuration() {
        ExpiresFilter expiresFilter = new ExpiresFilter();
        ExpiresConfiguration actualConfiguration = expiresFilter.parseExpiresConfiguration("access plus 2 hours");
        Assert.assertEquals(StartingPoint.ACCESS_TIME,
                actualConfiguration.getStartingPoint());
        Assert.assertEquals(1, actualConfiguration.getDurations().size());
        Assert.assertEquals(2,
                actualConfiguration.getDurations().get(0).getAmount());
        Assert.assertEquals(DurationUnit.HOUR,
                actualConfiguration.getDurations().get(0).getUnit());
    }
    public void testSkipBecauseCacheControlMaxAgeIsDefined() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("text/xml; charset=utf-8");
                response.addHeader("Cache-Control", "private, max-age=232");
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, Integer.valueOf(232));
    }
    public void testExcludedResponseStatusCode() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                response.addHeader("ETag", "W/\"1934-1269208821000\"");
                response.addDateHeader("Date", System.currentTimeMillis());
            }
        };
        validate(servlet, null, HttpServletResponse.SC_NOT_MODIFIED);
    }
    public void testNullContentType() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType(null);
            }
        };
        validate(servlet, Integer.valueOf(1 * 60));
    }
    public void testSkipBecauseExpiresIsDefined() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("text/xml; charset=utf-8");
                response.addDateHeader("Expires", System.currentTimeMillis());
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, null);
    }
    public void testUseContentTypeExpiresConfiguration() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("text/xml; charset=utf-8");
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, Integer.valueOf(3 * 60));
    }
    public void testUseContentTypeWithoutCharsetExpiresConfiguration()
            throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("text/xml; charset=iso-8859-1");
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, Integer.valueOf(5 * 60));
    }
    public void testUseDefaultConfiguration1() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("image/jpeg");
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, Integer.valueOf(1 * 60));
    }
    public void testUseDefaultConfiguration2() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("image/jpeg");
                response.addHeader("Cache-Control", "private");
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, Integer.valueOf(1 * 60));
    }
    public void testUseMajorTypeExpiresConfiguration() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("text/json; charset=iso-8859-1");
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, Integer.valueOf(7 * 60));
    }
    protected void validate(HttpServlet servlet, Integer expectedMaxAgeInSeconds)
            throws Exception {
        validate(servlet, expectedMaxAgeInSeconds, HttpURLConnection.HTTP_OK);
    }
    protected void validate(HttpServlet servlet,
            Integer expectedMaxAgeInSeconds, int expectedResponseStatusCode)
            throws Exception {
        // SETUP
        Tomcat tomcat = getTomcatInstance();
        Context root = tomcat.addContext("", TEMP_DIR);
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("ExpiresDefault", "access plus 1 minute");
        filterDef.addInitParameter("ExpiresByType text/xml;charset=utf-8",
                "access plus 3 minutes");
        filterDef.addInitParameter("ExpiresByType text/xml",
                "access plus 5 minutes");
        filterDef.addInitParameter("ExpiresByType text",
                "access plus 7 minutes");
        filterDef.addInitParameter("ExpiresExcludedResponseStatusCodes",
                "304, 503");
        filterDef.setFilterClass(ExpiresFilter.class.getName());
        filterDef.setFilterName(ExpiresFilter.class.getName());
        root.addFilterDef(filterDef);
        FilterMap filterMap = new FilterMap();
        filterMap.setFilterName(ExpiresFilter.class.getName());
        filterMap.addURLPattern("*");
        root.addFilterMap(filterMap);
        Tomcat.addServlet(root, servlet.getClass().getName(), servlet);
        root.addServletMapping("/test", servlet.getClass().getName());
        tomcat.start();
        try {
            Calendar.getInstance(TimeZone.getTimeZone("GMT"));
            long timeBeforeInMillis = System.currentTimeMillis();
            // TEST
            HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(
                    "http://localhost:" + tomcat.getConnector().getPort() +
                            "/test").openConnection();
            // VALIDATE
            Assert.assertEquals(expectedResponseStatusCode,
                    httpURLConnection.getResponseCode());
            StringBuilder msg = new StringBuilder();
            for (Entry<String, List<String>> field : httpURLConnection.getHeaderFields().entrySet()) {
                for (String value : field.getValue()) {
                    msg.append((field.getKey() == null ? "" : field.getKey() +
                            ": ") +
                            value + "\n");
                }
            }
            System.out.println(msg);
            Integer actualMaxAgeInSeconds;
            String cacheControlHeader = httpURLConnection.getHeaderField("Cache-Control");
            if (cacheControlHeader == null) {
                actualMaxAgeInSeconds = null;
            } else {
                actualMaxAgeInSeconds = null;
                StringTokenizer cacheControlTokenizer = new StringTokenizer(
                        cacheControlHeader, ",");
                while (cacheControlTokenizer.hasMoreTokens() &&
                        actualMaxAgeInSeconds == null) {
                    String cacheDirective = cacheControlTokenizer.nextToken();
                    StringTokenizer cacheDirectiveTokenizer = new StringTokenizer(
                            cacheDirective, "=");
                    if (cacheDirectiveTokenizer.countTokens() == 2) {
                        String key = cacheDirectiveTokenizer.nextToken().trim();
                        String value = cacheDirectiveTokenizer.nextToken().trim();
                        if (key.equalsIgnoreCase("max-age")) {
                            actualMaxAgeInSeconds = Integer.valueOf(value);
                        }
                    }
                }
            }
            if (expectedMaxAgeInSeconds == null) {
                Assert.assertNull("actualMaxAgeInSeconds '" +
                        actualMaxAgeInSeconds + "' should be null",
                        actualMaxAgeInSeconds);
                return;
            }
            Assert.assertNotNull(actualMaxAgeInSeconds);
            @SuppressWarnings("null")
            int deltaInSeconds = Math.abs(actualMaxAgeInSeconds.intValue() -
                    expectedMaxAgeInSeconds.intValue());
            Assert.assertTrue("actualMaxAgeInSeconds: " +
                    actualMaxAgeInSeconds + ", expectedMaxAgeInSeconds: " +
                    expectedMaxAgeInSeconds + ", request time: " +
                    timeBeforeInMillis + " for content type " +
                    httpURLConnection.getContentType(), deltaInSeconds < 3);
        } finally {
            tomcat.stop();
        }
    }
    public void testIntsToCommaDelimitedString() {
        String actual = ExpiresFilter.intsToCommaDelimitedString(new int[] {
                500, 503 });
        String expected = "500, 503";
        Assert.assertEquals(expected, actual);
    }
      <add>
        <bug>48998</bug>: Add the ExpiresFilter, a port of the httpd mod_expires
        module. Patch provided by Cyrille Le Clerc. (markt)
      </add>
  <subsection name="Introduction">
    <p>
    ExpiresFilter is a Java Servlet API port of <a
    href="http://httpd.apache.org/docs/2.2/mod/mod_expires.html">Apache
    mod_expires</a>.
    This filter controls the setting of the <tt>Expires</tt> HTTP header and the
    <tt>max-age</tt> directive of the <tt>Cache-Control</tt> HTTP header in
    server responses. The expiration date can set to be relative to either the
    time the source file was last modified, or to the time of the client access.
    </p>
    
    <p>
    These HTTP headers are an instruction to the client about the document&#x27;s
    validity and persistence. If cached, the document may be fetched from the
    cache rather than from the source until this time has passed. After that, the
    cache copy is considered &quot;expired&quot; and invalid, and a new copy must
    be obtained from the source.
    </p>
    <p>
    To modify <tt>Cache-Control</tt> directives other than <tt>max-age</tt> (see
    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9" >RFC
    2616 section 14.9</a>), you can use other servlet filters or <a
    href="http://httpd.apache.org/docs/2.2/mod/mod_headers.html" >Apache Httpd
    mod_headers</a> module.
    </p>
        
  </subsection>
  <subsection name="Basic configuration sample">
    <p>
    Basic configuration to add '<tt>Expires</tt>' and '<tt>Cache-Control: max-age=</tt>' 
    headers to images, css and javascript.
    </p>
    <source>
 &lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt;
 &lt;filter-class&gt;org.apache.catalina.filters.ExpiresFilter&lt;/filter-class&gt;
 &lt;init-param&gt;
    &lt;param-name&gt;ExpiresByType image&lt;/param-name&gt;
    &lt;param-value&gt;access plus 10 minutes&lt;/param-value&gt;
 &lt;/init-param&gt;
 &lt;init-param&gt;
    &lt;param-name&gt;ExpiresByType text/css&lt;/param-name&gt;
    &lt;param-value&gt;access plus 10 minutes&lt;/param-value&gt;
 &lt;/init-param&gt;
 &lt;init-param&gt;
    &lt;param-name&gt;ExpiresByType text/javascript&lt;/param-name&gt;
    &lt;param-value&gt;access plus 10 minutes&lt;/param-value&gt;
 &lt;/init-param&gt;
 &lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt;
 &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
 &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
    </source>
    
  </subsection>
  
  <subsection name="Alternate Syntax">
    <p>
    The <tt>ExpiresDefault</tt> and <tt>ExpiresByType</tt> directives can also be
    defined in a more readable syntax of the form:
    </p>
    
    <source>
 &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;
 &lt;param-value&gt;&lt;base&gt; [plus] {&lt;num&gt;   &lt;type&gt;}*&lt;/param-value&gt;
 &lt;param-name&gt;ExpiresByType type&lt;/param-name&gt;
 &lt;param-value&gt;&lt;base&gt; [plus]   {&lt;num&gt; &lt;type&gt;}*&lt;/param-value&gt;
 &lt;param-name&gt;ExpiresByType type;encoding&lt;/param-name&gt;
 &lt;param-value&gt;&lt;base&gt; [plus]   {&lt;num&gt; &lt;type&gt;}*&lt;/param-value&gt;
    </source>
    <p>
    where <tt>&lt;base&gt;</tt> is one of:
    <ul>
    <li><tt>access</tt></li>
    <li><tt>now</tt> (equivalent to &#x27;<tt>access</tt>&#x27;)</li>
    <li><tt>modification</tt></li>
    </ul>
    </p>
    <p>
    The <tt>plus</tt> keyword is optional. <tt>&lt;num&gt;</tt> should be an
    integer value (acceptable to <tt>Integer.parseInt()</tt>), and
    <tt>&lt;type&gt;</tt> is one of:
    <ul>
    <li><tt>years</tt></li>
    <li><tt>months</tt></li>
    <li><tt>weeks</tt></li>
    <li><tt>days</tt></li>
    <li><tt>hours</tt></li>
    <li><tt>minutes</tt></li>
    <li><tt>seconds</tt></li>
    </ul>
    For example, any of the following directives can be used to make documents
    expire 1 month after being accessed, by default:
    </p>
    
    <source>
 &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;
 &lt;param-value&gt;access plus 1 month&lt;/param-value&gt;
 &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;
 &lt;param-value&gt;access plus 4 weeks&lt;/param-value&gt;
 &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;
 &lt;param-value&gt;access plus 30 days&lt;/param-value&gt;
 &lt;param-name&gt;ExpiresByType text/html&lt;/param-name&gt;
 &lt;param-value&gt;access plus 1 month 15   days 2 hours&lt;/param-value&gt;
 &lt;param-name&gt;ExpiresByType image/gif&lt;/param-name&gt;
 &lt;param-value&gt;modification plus 5 hours 3   minutes&lt;/param-value&gt;
    </source>
    <p>
    Note that if you use a modification date based setting, the <tt>Expires</tt>
    header will <strong>not</strong> be added to content that does not come from
    a file on disk. This is due to the fact that there is no modification time
    for such content.
    </p>  
  </subsection>
  
  <subsection name="Expiration headers generation eligibility">
    <p>
    A response is eligible to be enriched by <tt>ExpiresFilter</tt> if :
    <ol>
    <li>no expiration header is defined (<tt>Expires</tt> header or the
    <tt>max-age</tt> directive of the <tt>Cache-Control</tt> header),</li>
    <li>the response status code is not excluded by the directive
    <tt>ExpiresExcludedResponseStatusCodes</tt>,</li>
    <li>The <tt>Content-Type</tt> of the response matches one of the types
    defined the in <tt>ExpiresByType</tt> directives or the
    <tt>ExpiresDefault</tt> directive is defined.</li>
    </ol>
    </p>
    <p>
    Note : If <tt>Cache-Control</tt> header contains other directives than
    <tt>max-age</tt>, they are concatenated with the <tt>max-age</tt> directive
    that is added by the <tt>ExpiresFilter</tt>.
    </p>
  </subsection>
  
  <subsection name="Expiration configuration selection">
    <p>
    The expiration configuration if elected according to the following algorithm:
    <ol>
    <li><tt>ExpiresByType</tt> matching the exact content-type returned by
    <tt>HttpServletResponse.getContentType()</tt> possibly including the charset
    (e.g. &#x27;<tt>text/xml;charset=UTF-8</tt>&#x27;),</li>
    <li><tt>ExpiresByType</tt> matching the content-type without the charset if
    <tt>HttpServletResponse.getContentType()</tt> contains a charset (e.g. &#x27;
    <tt>text/xml;charset=UTF-8</tt>&#x27; -&gt; &#x27;<tt>text/xml</tt>&#x27;),</li>
    <li><tt>ExpiresByType</tt> matching the major type (e.g. substring before
    &#x27;<tt>/</tt>&#x27;) of <tt>HttpServletResponse.getContentType()</tt>
    (e.g. &#x27;<tt>text/xml;charset=UTF-8</tt>&#x27; -&gt; &#x27;<tt>text</tt>
    &#x27;),</li>
    <li><tt>ExpiresDefault</tt></li>
    </ol>
    </p>
  </subsection>
  <subsection name="Filter Class Name">
    <p>The filter class name for the Expires Filter is
    <strong><code>org.apache.catalina.filters.ExpiresFilter</code>
    </strong>.</p>
  </subsection>
  
  <subsection name="Initialisation parameters">
    <p>The <strong>Expires Filter</strong> supports the following
    initialisation parameters:</p>
    <attributes>
      <attribute name="ExpiresActive" required="false">
        <p>
        This directive enables or disables the generation of the <tt>Expires</tt> and
        <tt>Cache-Control</tt> headers by this <tt>ExpiresFilter</tt>. If set to
        <tt>Off</tt>, the headers will not be generated for any HTTP response. If set
        to <tt>On</tt> or <tt>true</tt>, the headers will be added to served HTTP
        responses according to the criteria defined by the
        <tt>ExpiresByType &lt;content-type&gt;</tt> and <tt>ExpiresDefault</tt>
        directives. Note that this directive does not guarantee that an
        <tt>Expires</tt> or <tt>Cache-Control</tt> header will be generated. If the
        criteria aren&#x27;t met, no header will be sent, and the effect will be as
        though this directive wasn&#x27;t even specified.
        </p>
        <p>
        Default value is <tt>true</tt>.
        </p>
        
        <p>
        <i>Sample: enable filter</i>
        </p>
    
        <source>
 &lt;!-- supports case insensitive &#x27;On&#x27; or &#x27;true&#x27; --&gt;
 &lt;param-name&gt;ExpiresActive&lt;/param-name&gt;
 &lt;param-value&gt;On&lt;/param-value&gt;
         </source>
         <p>
         <i>Sample: disable filter</i>
         </p>
    
         <source>
 &lt;!-- supports anything different from case insensitive &#x27;On&#x27; and &#x27;true&#x27; --&gt;
 &lt;param-name&gt;ExpiresActive&lt;/param-name&gt;
 &lt;param-value&gt;Off&lt;/param-value&gt;
         </source>
      </attribute>
      <attribute name="ExpiresExcludedResponseStatusCodes" required="false">
         <p>
         This directive defines the http response status codes for which the
         <tt>ExpiresFilter</tt> will not generate expiration headers. By default, the
         <tt>304</tt> status code (&quot;<tt>Not modified</tt>&quot;) is skipped. The
         value is a comma separated list of http status codes.
         </p>
         <p>
         This directive is useful to ease usage of <tt>ExpiresDefault</tt> directive.
         Indeed, the behavior of <tt>304 Not modified</tt> (which does specify a
         <tt>Content-Type</tt> header) combined with <tt>Expires</tt> and
         <tt>Cache-Control:max-age=</tt> headers can be unnecessarily tricky to
         understand.
         </p>
         <p>
         <i>Sample : exclude response status codes 302, 500 and 503</i>
         </p>
         
         <source>
 &lt;param-name&gt;ExpiresExcludedResponseStatusCodes&lt;/param-name&gt;
 &lt;param-value&gt;302, 500, 503&lt;/param-value&gt;
         </source>
      </attribute>
      <attribute name="ExpiresByType &lt;content-type&gt;" required="false">
         <p>
         This directive defines the value of the <tt>Expires</tt> header and the
         <tt>max-age</tt> directive of the <tt>Cache-Control</tt> header generated for
         documents of the specified type (<i>e.g.</i>, <tt>text/html</tt>). The second
         argument sets the number of seconds that will be added to a base time to
         construct the expiration date. The <tt>Cache-Control: max-age</tt> is
         calculated by subtracting the request time from the expiration date and
         expressing the result in seconds.
         </p>
         <p>
         The base time is either the last modification time of the file, or the time
         of the client&#x27;s access to the document. Which should be used is
         specified by the <tt>&lt;code&gt;</tt> field; <tt>M</tt> means that the
         file&#x27;s last modification time should be used as the base time, and
         <tt>A</tt> means the client&#x27;s access time should be used. The duration
         is expressed in seconds. <tt>A2592000</tt> stands for
         <tt>access plus 30 days</tt> in alternate syntax.
         </p>
         <p>
         The difference in effect is subtle. If <tt>M</tt> (<tt>modification</tt> in
         alternate syntax) is used, all current copies of the document in all caches
         will expire at the same time, which can be good for something like a weekly
         notice that&#x27;s always found at the same URL. If <tt>A</tt> (
         <tt>access</tt> or <tt>now</tt> in alternate syntax) is used, the date of
         expiration is different for each client; this can be good for image files
         that don&#x27;t change very often, particularly for a set of related
         documents that all refer to the same images (<i>i.e.</i>, the images will be
         accessed repeatedly within a relatively short timespan).
         </p>
         <p>
         <strong>Note:</strong> When the content type includes a charset (e.g. 
         <tt>'ExpiresByType text/xml;charset=utf-8'</tt>), Tomcat removes blank chars 
         between the '<tt>;</tt>' and the '<tt>charset</tt>' keyword. Due to this, 
         configuration of an expiration with a charset must <strong>not</strong> include 
         such a space character. 
         </p>
         <p>
         <i>Sample:</i>
         </p>
         
         <source>
   &lt;param-name&gt;ExpiresByType text/html&lt;/param-name&gt;
   &lt;param-value&gt;access plus 1 month 15   days 2 hours&lt;/param-value&gt;
 
   &lt;!-- 2592000 seconds = 30 days --&gt;
   &lt;param-name&gt;ExpiresByType image/gif&lt;/param-name&gt;
   &lt;param-value&gt;A2592000&lt;/param-value&gt;
         </source>
         <p>
         Note that this directive only has effect if <tt>ExpiresActive On</tt> has
         been specified. It overrides, for the specified MIME type <i>only</i>, any
         expiration date set by the <tt>ExpiresDefault</tt> directive.
         </p>
         <p>
         You can also specify the expiration time calculation using an alternate
         syntax, described earlier in this document.
         </p>
      </attribute>
      <attribute name="ExpiresDefault" required="false">
         <p>
         This directive sets the default algorithm for calculating the
         expiration time for all documents in the affected realm. It can be
         overridden on a type-by-type basis by the <tt>ExpiresByType</tt> directive. See the
         description of that directive for details about the syntax of the
         argument, and the "alternate syntax"
         description as well.
         </p>
      </attribute>
    </attributes>
  </subsection>
  
  <subsection name="Troubleshooting">
    <p>
    To troubleshoot, enable logging on the
    <tt>org.apache.catalina.filters.ExpiresFilter</tt>.
    </p>
    <p>
    Extract of logging.properties
    </p>
    
    <source>
    </source>
    <p>
    Sample of initialization log message :
    </p>
    
    <source>
 active=true, 
 excludedResponseStatusCode=[304], 
 default=null, 
 byType={
    image=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]], 
    text/css=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]], 
    text/javascript=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]]}]
    </source>
    <p>
    Sample of per-request log message where <tt>ExpiresFilter</tt> adds an
    expiration date
    </p>
    
    <source>
    </source>
    <p>
    Sample of per-request log message where <tt>ExpiresFilter</tt> does not add
    an expiration date
    </p>
    
    <source>
    </source>
  </subsection>

======= fetch "protected synchronized void startInternal() throws LifecycleException {" eca4ed9^:"java/org/apache/catalina/ha/session/SimpleTcpReplicationManager.java"

                    }catch ( Exception sleep) {}

======= fetch "public void start() throws LifecycleException {" e8245ef^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        } catch (Exception e) {

  <!--                                                                      -->
  <!--   allowExec           Is use of the exec command enabled? [false]    -->
  <!--                                                                      -->
  <!--   allowExec           Is use of the exec command enabled? [false]    -->
======= fetch "public void init(FilterConfig config) throws ServletException {" a36b0c0^:"java/org/apache/catalina/ssi/SSIFilter.java"

        allowExec = Boolean.parseBoolean(config.getInitParameter("allowExec"));
======= fetch "public void doFilter(ServletRequest request, ServletResponse response," a36b0c0^:"java/org/apache/catalina/ssi/SSIFilter.java"

                    debug);
    public SSIProcessor(SSIExternalResolver ssiExternalResolver, int debug) {
======= fetch "public SSIProcessor(SSIExternalResolver ssiExternalResolver, int debug) {" a36b0c0^:"java/org/apache/catalina/ssi/SSIProcessor.java"

        this.allowExec = allowExec;
======= fetch "protected void addBuiltinCommands() {" a36b0c0^:"java/org/apache/catalina/ssi/SSIProcessor.java"

        addCommand("exec", new SSIExec());
======= fetch "public void init() throws ServletException {" a36b0c0^:"java/org/apache/catalina/ssi/SSIServlet.java"

        allowExec = Boolean.parseBoolean(
                getServletConfig().getInitParameter("allowExec"));
======= fetch "protected void processSSI(HttpServletRequest req, HttpServletResponse res," a36b0c0^:"java/org/apache/catalina/ssi/SSIServlet.java"

                debug);

    private ResourceBundle bundle;
    private Locale locale;
======= fetch "private StringManager(String packageName) {" 4159093^:"java/org/apache/tomcat/util/res/StringManager.java"

        ResourceBundle bnd = null;
======= fetch "private StringManager(String packageName) {" 4159093^:"java/org/apache/tomcat/util/res/StringManager.java"

            bundle = ResourceBundle.getBundle(bundleName, Locale.getDefault());
======= fetch "private StringManager(String packageName) {" 4159093^:"java/org/apache/tomcat/util/res/StringManager.java"

                    bundle = ResourceBundle.getBundle(
======= fetch "private StringManager(String packageName) {" 4159093^:"java/org/apache/tomcat/util/res/StringManager.java"

        bundle = bnd;
======= fetch "private StringManager(String packageName) {" 4159093^:"java/org/apache/tomcat/util/res/StringManager.java"

        } else {
            locale = null;
======= fetch "public String getString(final String key, final Object... args) {" 4159093^:"java/org/apache/tomcat/util/res/StringManager.java"

    private static Hashtable<String, StringManager> managers =

 * the "text" type to ISO-8859-1. RFC2616 explicitly states that browsers must
 * use ISO-8859-1 in these circumstances. However, browsers may attempt to
 * browsers have an option to enable it.
    public void destroy() {
        // NOOP
======= fetch "public void doFilter(ServletRequest request, ServletResponse response," d6766f1^:"java/org/apache/catalina/filters/AddDefaultCharsetFilter.java"

                new ResponseWrapper((HttpServletResponse)response);
======= fetch "public void doFilter(ServletRequest request, ServletResponse response," d6766f1^:"java/org/apache/catalina/filters/AddDefaultCharsetFilter.java"

    public void init(FilterConfig filterConfig) throws ServletException {
        // NOOP
    }
======= fetch "public void init(FilterConfig filterConfig) throws ServletException {" d6766f1^:"java/org/apache/catalina/filters/AddDefaultCharsetFilter.java"

     * Wrapper that adds the default character set for text media types if no
     * character set is specified.
======= fetch "public void init(FilterConfig filterConfig) throws ServletException {" d6766f1^:"java/org/apache/catalina/filters/AddDefaultCharsetFilter.java"

    public class ResponseWrapper extends HttpServletResponseWrapper {
======= fetch "public void setContentType(String ct) {" d6766f1^:"java/org/apache/catalina/filters/AddDefaultCharsetFilter.java"

            if (ct != null && ct.startsWith("text/") &&
                    ct.indexOf("charset=") < 0) {
                // Use getCharacterEncoding() in case the charset has already
                // been set by a separate call.
                super.setContentType(ct + ";charset=" + getCharacterEncoding());
======= fetch "public void setContentType(String ct) {" d6766f1^:"java/org/apache/catalina/filters/AddDefaultCharsetFilter.java"

        public ResponseWrapper(HttpServletResponse response) {
            super(response);
======= fetch "public ResponseWrapper(HttpServletResponse response) {" d6766f1^:"java/org/apache/catalina/filters/AddDefaultCharsetFilter.java"

        
    <p>The Add Default Character Set Filter does not support any initialization
    parameters.</p>

      <fix>
        <bug>49570</bug>: When using the example compression filter, set the
        Vary header on compressed responses. (markt)
      </fix>
======= fetch "public void writeToGZip(byte b[], int off, int len) throws IOException {" c191152^:"webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java"

                String vary = response.getHeader("Vary");
                if (vary == null) {
                    // Add a new Vary header
                    response.setHeader("Vary", "Accept-Encoding");
                } else if (vary.equals("*")) {
                    // No action required
                } else {
                    // Merge into current header
                    response.setHeader("Vary", vary + ",Accept-Encoding");
                }

======= fetch "protected void initInternal() throws LifecycleException {" a90b576^:"java/org/apache/catalina/connector/Connector.java"

        try {
            protocolHandler.init();
        } catch (Exception e) {
            throw new LifecycleException
                (sm.getString
                 ("coyoteConnector.protocolHandlerInitializationFailed", e));
        }
======= fetch "protected void startInternal() throws LifecycleException {" a90b576^:"java/org/apache/catalina/connector/Connector.java"

        // Protocol handlers do not follow Lifecycle conventions.
        // protocolHandler.init() needs to wait until the connector.start()
        try {
            protocolHandler.init();
        } catch (Exception e) {
            throw new LifecycleException
                (sm.getString
                 ("coyoteConnector.protocolHandlerInitializationFailed", e));
        }
======= fetch "protected void startInternal() throws LifecycleException {" a90b576^:"java/org/apache/catalina/connector/Connector.java"

        // MapperListener doesn't follow Lifecycle conventions either
======= fetch "protected void stopInternal() throws LifecycleException {" a90b576^:"java/org/apache/catalina/connector/Connector.java"

        // Protocol handlers do not follow Lifecycle conventions.
        // protocolHandler.destroy() needs to be called in connector.stop()
        try {
            protocolHandler.destroy();
        } catch (Exception e) {
            throw new LifecycleException
                (sm.getString
                 ("coyoteConnector.protocolHandlerDestroyFailed", e));
        }
        // MapperListener doesn't follow Lifecycle conventions either
======= fetch "protected void destroyInternal() throws LifecycleException {" a90b576^:"java/org/apache/catalina/connector/Connector.java"

        try {
            protocolHandler.destroy();
        } catch (Exception e) {
            throw new LifecycleException
                (sm.getString
                 ("coyoteConnector.protocolHandlerDestroyFailed", e));
        }
        <bug>49503</bug>: Make sure connectors bind to their associated ports
        sufficiently early to allow jsvc and the
        org.apache.catalina.startup.EXIT_ON_INIT_FAILURE system property to
        operate correctly. (markt)
      </fix>
      <fix>

======= fetch "protected void contextConfig() {" dca6dd1^:"java/org/apache/catalina/startup/ContextConfig.java"

        // Open the default web.xml file, if it exists
======= fetch "protected void contextConfig() {" dca6dd1^:"java/org/apache/catalina/startup/ContextConfig.java"

            File defaultContextFile = new File(getBaseDir(), defaultContextXml);

======= fetch "public void setContentLength(int length) {" 7b9630b^:"java/org/apache/catalina/connector/Response.java"

    @SuppressWarnings("deprecation") // isSpace (deprecated) cannot be replaced by isWhiteSpace
======= fetch "public void setContentType(String type) {" 7b9630b^:"java/org/apache/catalina/connector/Response.java"

                // N.B. isSpace (deprecated) cannot be replaced by isWhiteSpace
      <fix>
        <bug>49550</bug>: Supress deprecation warning where deprecated code is
        required to be used. No functional change. Patch provided by Sebb.
        (markt)
      </fix>

======= fetch "public void removeChild(Container child) {" 3bd4bcb^:"java/org/apache/catalina/core/ContainerBase.java"

        if (getState().isAvailable()) {
            try {
                if (child.getState().isAvailable()) {
                    child.stop();
                }
            } catch (LifecycleException e) {
                log.error("ContainerBase.removeChild: stop: ", e);
======= fetch "public void removeChild(Container child) {" 3bd4bcb^:"java/org/apache/catalina/core/ContainerBase.java"

        } catch (LifecycleException e) {
            log.error("ContainerBase.removeChild: stop: ", e);
        <bug>49530</bug>: Contexts and Servlets not stopped when Tomcat is shut
        down. (markt)
      </fix>
      <fix>

======= fetch "protected boolean postParseRequest(org.apache.coyote.Request req," 4e34898^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        // If there is no context at this point, it is likely no ROOT context
        // has been deployed
        if (request.getContext() == null) {
            res.setStatus(404);
            res.setMessage("Not found");
            // No context, so use host
            request.getHost().logAccess(request, response, 0, true);
            return false;
        }
        
======= fetch "private void registerHost(Host host) {" 4e34898^:"java/org/apache/catalina/connector/MapperListener.java"

        mapper.addHost(host.getName(), aliases, host.getObjectName());
======= fetch "private void registerContext(Context context) {" 4e34898^:"java/org/apache/catalina/connector/MapperListener.java"

        String hostName = context.getParent().getName();
======= fetch "private void registerContext(Context context) {" 4e34898^:"java/org/apache/catalina/connector/MapperListener.java"

        mapper.addContext(hostName, contextName, context, welcomeFiles,
                resources);
======= fetch "public Host getHost() {" 4e34898^:"java/org/apache/catalina/connector/Request.java"

        if (getContext() == null)
            return null;
        return (Host) getContext().getParent();
        //return ((Host) mappingData.host);
======= fetch "public void setContext(String path, String[] welcomeResources," 4e34898^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

     * @param host Host object
======= fetch "public void setContext(String path, String[] welcomeResources," 4e34898^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

        (String hostName, String path, Object context,
======= fetch "public void setContext(String path, String[] welcomeResources," 4e34898^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

            addHost(hostName, new String[0], "");
======= fetch "public void setContext(String path, String[] welcomeResources," 4e34898^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

        Host host = hosts[pos];
        if (host.name.equals(hostName)) {
======= fetch "public void setContext(String path, String[] welcomeResources," 4e34898^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

            synchronized (host) {
                Context[] contexts = host.contextList.contexts;
======= fetch "public void setContext(String path, String[] welcomeResources," 4e34898^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

                if (slashCount > host.contextList.nesting) {
                    host.contextList.nesting = slashCount;
======= fetch "public void setContext(String path, String[] welcomeResources," 4e34898^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

                    host.contextList.contexts = newContexts;

======= fetch "public static Cookie createSessionCookie(Context context," 0b8a9a8^:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        // Handle special case of ROOT context where cookies require a path of
        // '/' but the servlet spec uses an empty string
        if (contextPath.length() == 0) {
            contextPath = "/";
        }
      <fix>
        <bug>49525</bug>: Ensure cookies for the ROOT context have a path of /
        rather than an empty string. (markt)
      </fix>

======= fetch "public void setNamingResources(NamingResources namingResources) {" 3c88f07^:"java/org/apache/catalina/core/StandardContext.java"

                "type=NamingResources," + getObjectNameKeyProperties());
======= fetch "protected String getObjectNameKeyProperties() {" 3c88f07^:"java/org/apache/catalina/core/StandardContext.java"

            new StringBuilder("j2eeType=WebModule,name=");
        
        String hostName = getParent().getName();
        if (hostName == null) {
            keyProperties.append("DEFAULT");
======= fetch "protected String getObjectNameKeyProperties() {" 3c88f07^:"java/org/apache/catalina/core/StandardContext.java"

            keyProperties.append(hostName);
======= fetch "protected String getObjectNameKeyProperties() {" 3c88f07^:"java/org/apache/catalina/core/StandardContext.java"

            keyProperties.append('/');
======= fetch "protected String getObjectNameKeyProperties() {" 3c88f07^:"java/org/apache/catalina/core/StandardContext.java"

            keyProperties.append(pathName);
======= fetch "protected String getObjectNameKeyProperties() {" 3c88f07^:"java/org/apache/catalina/core/StandardContext.java"

        keyProperties.append(",J2EEApplication=");
        keyProperties.append(getJ2EEApplication());
        keyProperties.append(",J2EEServer=");
        keyProperties.append(getJ2EEServer());
        return keyProperties.toString();
======= fetch "protected String getObjectNameKeyProperties() {" 3c88f07^:"java/org/apache/catalina/core/StandardContext.java"

    

    
    private final int nonceCacheSize = 5;
======= fetch "public void doFilter(ServletRequest request, ServletResponse response," a0159a3^:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

            @SuppressWarnings("unchecked")
            LruCache<String> nonceCache =
                (LruCache<String>) req.getSession(true).getAttribute(
                    Constants.CSRF_NONCE_SESSION_ATTR_NAME);
            
======= fetch "public void doFilter(ServletRequest request, ServletResponse response," a0159a3^:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

                String expectedNonce =
                    (String) req.getSession(true).getAttribute(
                        Constants.CSRF_NONCE_SESSION_ATTR_NAME);
                
                if (expectedNonce != null &&
                        !expectedNonce.equals(previousNonce)) {
======= fetch "public void doFilter(ServletRequest request, ServletResponse response," a0159a3^:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

            if (nonceCache == null) {
                nonceCache = new LruCache<String>(nonceCacheSize);
                req.getSession().setAttribute(
                        Constants.CSRF_NONCE_SESSION_ATTR_NAME, nonceCache);
            }
            
======= fetch "public void doFilter(ServletRequest request, ServletResponse response," a0159a3^:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

            req.getSession(true).setAttribute(
                    Constants.CSRF_NONCE_SESSION_ATTR_NAME, newNonce);
======= fetch "private String addNonce(String url) {" a0159a3^:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

    protected static final String NONCE_SESSION =
        "org.apache.catalina.manager.NONCE";
    protected static final String NONCE_REQUEST = "nonce";
        
======= fetch "public void doPost(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        String requestNonce = request.getParameter(NONCE_REQUEST);
======= fetch "public void doPost(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        // Check nonce
        // There *must* be a nonce in the session before any POST is processed
        HttpSession session = request.getSession();
        String sessionNonce = (String) session.getAttribute(NONCE_SESSION);
        if (sessionNonce == null) {
            message = sm.getString("htmlManagerServlet.noNonce", command);
            // Reset the command
            command = null;
        } else {
            if (!sessionNonce.equals(requestNonce)) {
                // Nonce mis-match.
                message =
                    sm.getString("htmlManagerServlet.nonceMismatch", command);
                // Reset the command
                command = null;
            }
        }
        
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        String newNonce = generateNonce();
        request.getSession().setAttribute(NONCE_SESSION, newNonce);
        
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            Context context = (Context) host.findChild(contextPath);
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            if (context != null ) {
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args[2] = context.getDisplayName();
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args[3] = new Boolean(context.getAvailable());
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                if (context.getManager() != null) {
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                        (context.getManager().getActiveSessions());
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args = new Object[15];
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                Manager manager = context.getManager();
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                            context.getManager().getMaxInactiveInterval()/60);
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args[14] = newNonce;
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                if (context.getPath().equals(this.context.getPath())) {
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                } else if (context.getAvailable() && isDeployed) {
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                } else if (context.getAvailable() && !isDeployed) {
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                } else if (!context.getAvailable() && isDeployed) {
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args = new Object[8];
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[7] = newNonce;
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args = new Object[5];
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[4] = newNonce;
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args = new Object[6];
======= fetch "public void list(HttpServletRequest request," a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[3] = newNonce;
        args[4] = sm.getString("htmlManagerServlet.diagnosticsLeakWarning");
        args[5] = sm.getString("htmlManagerServlet.diagnosticsLeakButton");
======= fetch "protected void doSessions(String path, HttpServletRequest req, HttpServletRespon" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        Context context = (Context) host.findChild(searchPath);
        if (null == context) {
======= fetch "protected void doSessions(String path, HttpServletRequest req, HttpServletRespon" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        Session[] sessions = context.getManager().findSessions();
======= fetch "protected Session getSessionForPathAndId(String path, String id) throws IOExcept" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        Context context = (Context) host.findChild(searchPath);
        if (null == context) {
======= fetch "protected Session getSessionForPathAndId(String path, String id) throws IOExcept" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        Session session = context.getManager().findSession(id);
======= fetch "protected void displaySessionDetailPage(HttpServletRequest req, HttpServletRespo" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        getServletContext().getRequestDispatcher(sessionDetailJspPath).include(req, resp);
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "<small><a href=\"{4}\" target=\"_blank\">{5}</a></small></td>\n";
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{14}\">" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{14}\">" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{14}\">" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{14}\"" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{14}\">" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{14}\">" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{14}\">" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{14}\">" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{14}\">" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{14}\">" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "<input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{7}\" >" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "<input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{4}\" >" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "<input type=\"hidden\" name=\"" + NONCE_REQUEST + "\" value=\"{3}\" >" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <input type=\"submit\" value=\"{5}\">\n" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" a0159a3^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <small>{4}</small>\n" +
    You are not authorized to view this page. If you have not changed
   String submitUrl = ((HttpServletRequest)pageContext.getRequest()).getRequestURL().toString();
   	String attributeName = (String) attributeNamesEnumeration.nextElement();
   String submitUrl = ((HttpServletRequest)pageContext.getRequest()).getRequestURI() + "?path=" + path;

 * header named <code>$remoteIPHeader</code> (default value <code>x-forwarded-for</code>). Values are processed in right-to-left order.</li>
 * <td>remoteIPHeader</td>
 * <code>remoteIPHeader</code></td>
 *       &lt;param-name&gt;remoteIPHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-for&lt;/param-value&gt;
 *       &lt;param-name&gt;remoteIPProxiesHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-by&lt;/param-value&gt;
 *       &lt;param-name&gt;remoteIPHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-for&lt;/param-value&gt;
 *       &lt;param-name&gt;remoteIPProxiesHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-by&lt;/param-value&gt;
 *       &lt;param-name&gt;remoteIPHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-for&lt;/param-value&gt;
 *       &lt;param-name&gt;remoteIPProxiesHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-by&lt;/param-value&gt;
 *       &lt;param-name&gt;remoteIPHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-for&lt;/param-value&gt;
 *       &lt;param-name&gt;remoteIPProxiesHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-by&lt;/param-value&gt;
======= fetch "public void setServerPort(int serverPort) {" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    protected static final String REMOTE_IP_HEADER_PARAMETER = "remoteIPHeader";
======= fetch "protected static boolean matchesOne(String str, Pattern... patterns) {" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

     * @see #setRemoteIPHeader(String)
======= fetch "protected static boolean matchesOne(String str, Pattern... patterns) {" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    private String remoteIPHeader = "X-Forwarded-For";
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            String[] remoteIPHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIPHeader));
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            // loop on remoteIPHeaderValue to find the first trusted remote ip and to build the proxies chain
            for (idx = remoteIPHeaderValue.length - 1; idx >= 0; idx--) {
                String currentRemoteIp = remoteIPHeaderValue[idx];
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            // continue to loop on remoteIPHeaderValue to build the new value of the remoteIPHeader
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                String currentRemoteIp = remoteIPHeaderValue[idx];
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                    xRequest.removeHeader(remoteIPHeader);
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                    xRequest.setHeader(remoteIPHeader, commaDelimitedRemoteIpHeaderValue);
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                        + "', originalScheme='" + request.getScheme() + "', original[" + remoteIPHeader + "]='"
                        + request.getHeader(remoteIPHeader) + ", original[" + protocolHeader + "]='"
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                        + xRequest.getScheme() + "', newSecure='" + xRequest.isSecure() + "', new[" + remoteIPHeader + "]='"
                        + xRequest.getHeader(remoteIPHeader) + ", new[" + proxiesHeader + "]='" + xRequest.getHeader(proxiesHeader) + "'");
======= fetch "public String getProxiesHeader() {" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    public String getRemoteIPHeader() {
        return remoteIPHeader;
======= fetch "public void init(FilterConfig filterConfig) throws ServletException {" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            setRemoteIPHeader(filterConfig.getInitParameter(REMOTE_IP_HEADER_PARAMETER));
======= fetch "public void setProxiesHeader(String proxiesHeader) {" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    public void setRemoteIPHeader(String remoteIPHeader) {
        this.remoteIPHeader = remoteIPHeader;
======= fetch "public void setRemoteIPHeader(String remoteIPHeader) {" 27091e7^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

     * Comma delimited list of proxies that are trusted when they appear in the {@link #remoteIPHeader} header. Can be expressed as a
 * header named <code>$remoteIPHeader</code> (default value <code>x-forwarded-for</code>). Values are processed in right-to-left order.</li>
 * <td>remoteIPHeader</td>
 * <code>remoteIPHeader</code></td>
 *   remoteIPHeader="x-forwarded-for"
 *   remoteIPProxiesHeader="x-forwarded-by"
 *   remoteIPHeader="x-forwarded-for"
 *   remoteIPProxiesHeader="x-forwarded-by"
 *   remoteIPHeader="x-forwarded-for"
 *   remoteIPProxiesHeader="x-forwarded-by"
 *   remoteIPHeader="x-forwarded-for"
 *   remoteIPProxiesHeader="x-forwarded-by"
======= fetch "public void invoke(Request request, Response response) throws IOException, Servl" 27091e7^:"java/org/apache/catalina/valves/RemoteIpValve.java"

            String[] remoteIPHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIpHeader));
======= fetch "public void invoke(Request request, Response response) throws IOException, Servl" 27091e7^:"java/org/apache/catalina/valves/RemoteIpValve.java"

            // loop on remoteIPHeaderValue to find the first trusted remote ip and to build the proxies chain
            for (idx = remoteIPHeaderValue.length - 1; idx >= 0; idx--) {
                String currentRemoteIp = remoteIPHeaderValue[idx];
======= fetch "public void invoke(Request request, Response response) throws IOException, Servl" 27091e7^:"java/org/apache/catalina/valves/RemoteIpValve.java"

            // continue to loop on remoteIPHeaderValue to build the new value of the remoteIPHeader
======= fetch "public void invoke(Request request, Response response) throws IOException, Servl" 27091e7^:"java/org/apache/catalina/valves/RemoteIpValve.java"

                String currentRemoteIp = remoteIPHeaderValue[idx];
         &lt;param-name&gt;remoteIPHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIPProxiesHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIPHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIPProxiesHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIPHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIPProxiesHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIPHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIPProxiesHeader&lt;/param-name&gt;
      <attribute name="remoteIPHeader" required="false">
      <attribute name="remoteIPHeader" required="false">

    private long counterSend_EVT_ALL_SESSION_DATA = 0 ;
    private int counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0 ;
======= fetch "public int getCounterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE() {" 4f990f1^:"java/org/apache/catalina/ha/session/DeltaManager.java"

 
======= fetch "public int getCounterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE() {" 4f990f1^:"java/org/apache/catalina/ha/session/DeltaManager.java"

    /**
     * @return Returns the counterReceive_EVT_CHANGE_SESSION_ID.
     */
    public long getCounterReceive_EVT_CHANGE_SESSION_ID() {
        return counterReceive_EVT_CHANGE_SESSION_ID;
    }
======= fetch "protected DeltaSession getNewDeltaSession() {" 4f990f1^:"java/org/apache/catalina/ha/session/DeltaManager.java"

     * Change the session ID of the current session to a new randomly generated
     * session ID.
     * 
     * @param session   The session to change the session ID for
     */
    @Override
    public void changeSessionId(Session session) {
        changeSessionId(session, true);
    }
    public void changeSessionId(Session session, boolean notify) {
        // original sessionID
        String orgSessionID = session.getId();
        super.changeSessionId(session);
        if (notify) {
            // changed sessionID
            String newSessionID = session.getId();
            try {
                // serialize sessionID
                byte[] data = serializeSessionId(newSessionID);
                // notify change sessionID
                SessionMessage msg = new SessionMessageImpl(getName(),
                        SessionMessage.EVT_CHANGE_SESSION_ID, data,
                        orgSessionID, orgSessionID + "-"
                                + System.currentTimeMillis());
                counterSend_EVT_CHANGE_SESSION_ID++;
                send(msg);
            } catch (IOException e) {
                log.error(sm.getString("deltaManager.unableSerializeSessionID",
                        newSessionID), e);
            }
        }
    }
    /**
     * serialize sessionID
     * @throws IOException if an input/output error occurs
     */
    protected byte[] serializeSessionId(String sessionId) throws IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeUTF(sessionId);
        oos.flush();
        oos.close();
        return bos.toByteArray();
    }
    /**
     * Load sessionID
     * @throws IOException if an input/output error occurs
     */
    protected String deserializeSessionId(byte[] data) throws IOException {
        ReplicationStream ois = getReplicationStream(data);
        String sessionId = ois.readUTF();
        ois.close();
        return sessionId;
    }
    /**
======= fetch "public void messageDataReceived(ClusterMessage cmsg) {" 4f990f1^:"java/org/apache/catalina/ha/session/DeltaManager.java"

                case SessionMessage.EVT_SESSION_DELTA: {
======= fetch "public synchronized void resetStatistics() {" 4f990f1^:"java/org/apache/catalina/ha/session/DeltaManager.java"

        counterReceive_EVT_CHANGE_SESSION_ID = 0;
======= fetch "public synchronized void resetStatistics() {" 4f990f1^:"java/org/apache/catalina/ha/session/DeltaManager.java"

        counterSend_EVT_CHANGE_SESSION_ID = 0;
======= fetch "protected void messageReceived(SessionMessage msg, Member sender) {" 4f990f1^:"java/org/apache/catalina/ha/session/DeltaManager.java"

                case SessionMessage.EVT_CHANGE_SESSION_ID: {
                    handleCHANGE_SESSION_ID(msg,sender);
                    break;
                 }
======= fetch "protected void handleGET_ALL_SESSIONS(SessionMessage msg, Member sender) throws" 4f990f1^:"java/org/apache/catalina/ha/session/DeltaManager.java"

 *   <li><pre>public static final int EVT_ATTRIBUTE_ADDED</pre><li>
 *   <li><pre>public static final int EVT_ATTRIBUTE_REMOVED</pre><li>
 *   <li><pre>public static final int EVT_SESSION_EXPIRED_WONOTIFY</pre><li>
 *   <li><pre>public static final int EVT_SESSION_EXPIRED_WNOTIFY</pre><li>
 *   <li><pre>public static final int EVT_SET_USER_PRINCIPAL</pre><li>
 *   <li><pre>public static final int EVT_SET_SESSION_NOTE</pre><li>
 *   <li><pre>public static final int EVT_REMOVE_SESSION_NOTE</pre><li>
    
======= fetch "private SessionMessageImpl( String contextName," 4f990f1^:"java/org/apache/catalina/ha/session/SessionMessageImpl.java"

     * <B>EVT_SESSION_EXPIRED_XXXX</B><BR>
     *    The parameters: sessionID must be set.<BR>
======= fetch "private SessionMessageImpl( String contextName," 4f990f1^:"java/org/apache/catalina/ha/session/SessionMessageImpl.java"

     * <B>EVT_CHANGE_SESSION_ID</B><BR>
     *    send original sessionID and new sessionID.<BR>
======= fetch "public String getEventTypeString()" 4f990f1^:"java/org/apache/catalina/ha/session/SessionMessageImpl.java"

            case EVT_CHANGE_SESSION_ID : return "SESSION-ID-CHANGED";
      name="counterReceive_EVT_CHANGE_SESSION_ID"
      description="Count receive EVT_CHANGE_SESSION_ID messages"
      type="long"
      writeable="false"/>
    <attribute
      name="counterSend_EVT_CHANGE_SESSION_ID"
      description="Count send EVT_CHANGE_SESSION_ID messages"
      type="long"
      writeable="false"/>
    <attribute

        "org.apache.catalina.cluster.authenticator.ClusterSingleSignOn";
    protected static final String info = "org.apache.catalina.session.ClusterSingleSignOnListener/1.0";
    protected static final String info = "org.apache.catalina.session.ClusterSessionListener/1.1";

======= fetch "public StandardContext() {" ac8a5ba^:"java/org/apache/catalina/core/StandardContext.java"

     * <code>false</code> will be used. 
======= fetch "public StandardContext() {" ac8a5ba^:"java/org/apache/catalina/core/StandardContext.java"

    /**
     * Should Tomcat attempt to terminate any {@link java.util.TimerThread}s
     * that have been started by the web application? If not specified, the
     * default value of <code>false</code> will be used.
     */
    private boolean clearReferencesStopTimerThreads = false;
======= fetch "public void setClearReferencesStopThreads(" ac8a5ba^:"java/org/apache/catalina/core/StandardContext.java"

     * Return the clearReferencesStopTimerThreads flag for this Context.
     */
    public boolean getClearReferencesStopTimerThreads() {
        return (this.clearReferencesStopTimerThreads);
    }
    /**
     * Set the clearReferencesStopTimerThreads feature for this Context.
     *
     * @param clearReferencesStopTimerThreads The new flag value
     */
    public void setClearReferencesStopTimerThreads(
            boolean clearReferencesStopTimerThreads) {
        boolean oldClearReferencesStopTimerThreads =
            this.clearReferencesStopTimerThreads;
        this.clearReferencesStopTimerThreads = clearReferencesStopTimerThreads;
        support.firePropertyChange("clearReferencesStopTimerThreads",
                                   oldClearReferencesStopTimerThreads,
                                   this.clearReferencesStopTimerThreads);
    }
    /**
======= fetch "protected boolean removeEldestEntry(" ac8a5ba^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * <code>false</code> will be used. Note that instances of
     * java.util.TimerThread will always be terminate since a safe method exists
     * to do so.
======= fetch "protected boolean removeEldestEntry(" ac8a5ba^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * Should Tomcat attempt to terminate any {@link java.util.TimerThread}s
     * that have been started by the web application? If not specified, the
     * default value of <code>false</code> will be used.
     */
    private boolean clearReferencesStopTimerThreads = false;
    /**
======= fetch "public void setClearReferencesStopThreads(" ac8a5ba^:"java/org/apache/catalina/loader/WebappClassLoader.java"

      * Return the clearReferencesStopTimerThreads flag for this Context.
      */
     public boolean getClearReferencesStopTimerThreads() {
         return (this.clearReferencesStopTimerThreads);
     }
     /**
      * Set the clearReferencesStopTimerThreads feature for this Context.
      *
      * @param clearReferencesStopTimerThreads The new flag value
      */
     public void setClearReferencesStopTimerThreads(
             boolean clearReferencesStopTimerThreads) {
         this.clearReferencesStopTimerThreads = clearReferencesStopTimerThreads;
     }
     /**
======= fetch "public boolean getClearReferencesLogFactoryRelease() {" ac8a5ba^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     /**
      * Set the clearReferencesLogFactoryRelease feature for this Context.
      *
      * @param clearReferencesLogFactoryRelease The new flag value
      */
     public void setClearReferencesLogFactoryRelease(
             boolean clearReferencesLogFactoryRelease) {
         this.clearReferencesLogFactoryRelease =
             clearReferencesLogFactoryRelease;
     }
======= fetch "public void setClearReferencesThreadLocals(" ac8a5ba^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     /**
      * Set the clearReferencesLogFactoryRelease feature for this Context.
      *
      * @param clearReferencesLogFactoryRelease The new flag value
      */
     public void setClearReferencesLogFactoryRelease(
             boolean clearReferencesLogFactoryRelease) {
         this.clearReferencesLogFactoryRelease =
             clearReferencesLogFactoryRelease;
     }
======= fetch "private void clearReferencesThreads() {" ac8a5ba^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                    // TimerThread is not normally visible
======= fetch "private void clearReferencesThreads() {" ac8a5ba^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                            "java.util.TimerThread")) {
======= fetch "protected void startInternal() throws LifecycleException {" ac8a5ba^:"java/org/apache/catalina/loader/WebappLoader.java"

                classLoader.setClearReferencesStopTimerThreads(
                        ((StandardContext) container).getClearReferencesStopTimerThreads());
      <attribute name="clearReferencesStopTimerThreads" required = "false">
        <p>If <code>true</code>, Tomcat attempts to terminate
        <code>java.util.Timer</code>threads that have been started by the web
        application. Unlike standard threads, timer threads can be stopped
        safely although there may still be side-effects for the application. If
        not specified, the default value of <code>false</code> will be used.</p>
      </attribute>

======= fetch "protected synchronized void stopInternal() throws LifecycleException {" ac22dd8^:"java/org/apache/catalina/ha/session/BackupManager.java"

        setState(LifecycleState.MUST_DESTROY);
======= fetch "protected synchronized void stopInternal() throws LifecycleException {" ac22dd8^:"java/org/apache/catalina/ha/session/DeltaManager.java"

        
        setState(LifecycleState.MUST_DESTROY);
======= fetch "protected synchronized void stopInternal() throws LifecycleException {" ac22dd8^:"java/org/apache/catalina/session/PersistentManagerBase.java"

        setState(LifecycleState.MUST_DESTROY);

======= fetch "public void containerEvent(ContainerEvent event) {" 0f669e3^:"java/org/apache/catalina/connector/MapperListener.java"

            child.addContainerListener(this);
======= fetch "public void containerEvent(ContainerEvent event) {" 0f669e3^:"java/org/apache/catalina/connector/MapperListener.java"

            child.removeLifecycleListener(this);
======= fetch "private void unregisterHost(Host host) {" 0f669e3^:"java/org/apache/catalina/connector/MapperListener.java"

        removeListeners(host);
        
======= fetch "private void unregisterWrapper(Wrapper wrapper) {" 0f669e3^:"java/org/apache/catalina/connector/MapperListener.java"

        removeListeners(wrapper);
        
======= fetch "private void unregisterContext(Context context) {" 0f669e3^:"java/org/apache/catalina/connector/MapperListener.java"

        removeListeners(context);
        

     * The name of the cookie used to pass the session identifier back
     * and forth with the client.
     */
    public static final String SESSION_COOKIE_NAME = "JSESSIONID";
    /**
     * The name of the path parameter used to pass the session identifier
     * back and forth with the client.
     */
    public static final String SESSION_PARAMETER_NAME =
        System.getProperty("org.apache.catalina.SESSION_PARAMETER_NAME",
                "jsessionid");
    /**
======= fetch "public CoyoteAdapter(Connector connector) {" 9369636^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

     * The match string for identifying a session ID parameter.
     */
    private static final String match =
        ";" + Globals.SESSION_PARAMETER_NAME + "=";
    /**
======= fetch "protected boolean postParseRequest(org.apache.coyote.Request req," 9369636^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        // Parse session Id before decoding / removal of path params
        parseSessionId(req, request);
        // URI decoding
======= fetch "protected boolean postParseRequest(org.apache.coyote.Request req," 9369636^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        if (decodedURI.getType() == MessageBytes.T_BYTES) {
            // Remove any path parameters
            ByteChunk uriBB = decodedURI.getByteChunk();
            int semicolon = uriBB.indexOf(';', 0);
            if (semicolon > 0) {
                decodedURI.setBytes
                    (uriBB.getBuffer(), uriBB.getStart(), semicolon);
            }
            // %xx decoding of the URL
            try {
                req.getURLDecoder().convert(decodedURI, false);
            } catch (IOException ioe) {
                res.setStatus(400);
                res.setMessage("Invalid URI: " + ioe.getMessage());
                return false;
            }
            // Normalization
            if (!normalize(req.decodedURI())) {
                res.setStatus(400);
                res.setMessage("Invalid URI");
                return false;
            }
            // Character decoding
            convertURI(decodedURI, request);
            // Check that the URI is still normalized
            if (!checkNormalize(req.decodedURI())) {
                res.setStatus(400);
                res.setMessage("Invalid URI character encoding");
                return false;
            }
        } else {
            // The URL is chars or String, and has been sent using an in-memory
            // protocol handler, we have to assume the URL has been properly
            // decoded already
            decodedURI.toChars();
            // Remove any path parameters
            CharChunk uriCC = decodedURI.getCharChunk();
            int semicolon = uriCC.indexOf(';');
            if (semicolon > 0) {
                decodedURI.setChars
                    (uriCC.getBuffer(), uriCC.getStart(), semicolon);
            }
======= fetch "protected boolean postParseRequest(org.apache.coyote.Request req," 9369636^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                redirectPath = redirectPath + ";" + Globals.SESSION_PARAMETER_NAME + "=" 
                    + request.getRequestedSessionId();
======= fetch "protected boolean postParseRequest(org.apache.coyote.Request req," 9369636^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        if (!request.getServletContext().getEffectiveSessionTrackingModes()
======= fetch "protected boolean postParseRequest(org.apache.coyote.Request req," 9369636^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            /* 
             * If we saw an ID in the URL but this is disabled - remove it
             * Can't handle it when we parse the URL as we don't have the
             * context at that point
             */
            request.setRequestedSessionId(null);
            request.setRequestedSessionURL(false);
======= fetch "protected boolean postParseRequest(org.apache.coyote.Request req," 9369636^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

     * Extract the path parameters from the request. This assumes parameters are
     * of the form /path;name=value;name2=value2/ etc. Currently only really
     * interested in the session ID that will be in this form. Other parameters
     * can safely be ignored.
     * 
     * @param req
     * @param request
     */
    protected void parsePathParameters(org.apache.coyote.Request req,
            Request request) {
        
        // Process in bytes (this is default format so this is normally a NO-OP
        req.decodedURI().toBytes();
        
        ByteChunk uriBC = req.decodedURI().getByteChunk();
        int semicolon = uriBC.indexOf(';', 0);
        String enc = null;
        
        while (semicolon > -1) {
            if (enc == null) {
                // What encoding to use? Some platforms, eg z/os, use a default
                // encoding that doesn't give the expected result so be explicit
                enc = connector.getURIEncoding();
                if (enc == null) {
                    enc = "ISO-8859-1";
                }
            }
            
            // Parse path param, and extract it from the decoded request URI
            int start = uriBC.getStart();
            int end = uriBC.getEnd();
            int pathParamStart = semicolon + 1;
            int pathParamEnd = ByteChunk.findChars(uriBC.getBuffer(),
                    uriBC.getStart() + pathParamStart, uriBC.getEnd(),
                    new byte[] {';', '/'});
            
            String pv = null;
            boolean warnedEncoding = false;
            
            if (pathParamEnd >= 0) {
                try {
                    pv = (new String(uriBC.getBuffer(), start + pathParamStart,
                                pathParamEnd - pathParamStart, enc));
                } catch (UnsupportedEncodingException e) {
                    if (!warnedEncoding) {
                        log.warn(sm.getString("coyoteAdapter.parsePathParam",
                                enc));
                        warnedEncoding = true;
                    }
                }
                // Extract path param from decoded request URI
                byte[] buf = uriBC.getBuffer();
                for (int i = 0; i < end - start - pathParamEnd; i++) {
                    buf[start + semicolon + i] 
                        = buf[start + i + pathParamEnd];
                }
                uriBC.setBytes(buf, start,
                        end - start - pathParamEnd + semicolon);
            } else {
                try {
                    pv = (new String(uriBC.getBuffer(), start + pathParamStart, 
                                (end - start) - pathParamStart, enc));
                } catch (UnsupportedEncodingException e) {
                    if (!warnedEncoding) {
                        log.warn(sm.getString("coyoteAdapter.parsePathParam",
                                enc));
                        warnedEncoding = true;
                    }
                }
                uriBC.setEnd(start + semicolon);
            }
            
            if (pv != null) {
                int equals = pv.indexOf('=');
                if (equals > -1) {
                    request.addPathParameter(pv.substring(0, equals),
                            pv.substring(equals + 1));
                }
            }
            
            semicolon = uriBC.indexOf(';', semicolon);
        }
    }
    
    
    /**
======= fetch "protected void parseSessionSslId(Request request) {" 9369636^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

    protected void parseSessionId(org.apache.coyote.Request req, Request request) {
        ByteChunk uriBC = req.requestURI().getByteChunk();
        int semicolon = uriBC.indexOf(match, 0, match.length(), 0);
        if (semicolon > 0) {
            // What encoding to use? Some platforms, eg z/os, use a default
            // encoding that doesn't give the expected result so be explicit 
            String enc = connector.getURIEncoding();
            if (enc == null) {
                enc = "ISO-8859-1";
            }
            // Parse session ID, and extract it from the decoded request URI
            int start = uriBC.getStart();
            int end = uriBC.getEnd();
            int sessionIdStart = semicolon + match.length();
            int semicolon2 = uriBC.indexOf(';', sessionIdStart);
            try {
                if (semicolon2 >= 0) {
                    request.setRequestedSessionId
                        (new String(uriBC.getBuffer(), start + sessionIdStart,
                                semicolon2 - sessionIdStart, enc));
                    // Extract session ID from request URI
                    byte[] buf = uriBC.getBuffer();
                    for (int i = 0; i < end - start - semicolon2; i++) {
                        buf[start + semicolon + i] 
                            = buf[start + i + semicolon2];
                    }
                    uriBC.setBytes(buf, start,
                            end - start - semicolon2 + semicolon);
                } else {
                    request.setRequestedSessionId
                        (new String(uriBC.getBuffer(), start + sessionIdStart, 
                                (end - start) - sessionIdStart, enc));
                    uriBC.setEnd(start + semicolon);
                }
                request.setRequestedSessionURL(true);
            } catch (UnsupportedEncodingException uee) {
                // Make sure no session ID is returned
                request.setRequestedSessionId(null);
                request.setRequestedSessionURL(false);
                log.warn(sm.getString("coyoteAdapter.parseSession", enc), uee);
            }
        } else {
            request.setRequestedSessionId(null);
            request.setRequestedSessionURL(false);
        }
    }
    /**
     * Parse session id in URL.
     */
======= fetch "public void setCoyoteRequest(org.apache.coyote.Request coyoteRequest) {" 9369636^:"java/org/apache/catalina/connector/Request.java"

    /**
     * Path parameters
     */
    protected Map<String,String> pathParameters = new HashMap<String, String>();
======= fetch "public void setCoyoteRequest(org.apache.coyote.Request coyoteRequest) {" 9369636^:"java/org/apache/catalina/connector/Request.java"

    protected void addPathParameter(String name, String value) {
        pathParameters.put(name, value);
    }
    protected String getPathParameter(String name) {
        return pathParameters.get(name);
    }
======= fetch "public void recycle() {" 9369636^:"java/org/apache/catalina/connector/Request.java"

        pathParameters.clear();
======= fetch "private boolean doIsEncodeable(Request hreq, Session session," 9369636^:"java/org/apache/catalina/connector/Response.java"

            String tok = ";" + Globals.SESSION_PARAMETER_NAME + "=" + session.getIdInternal();
======= fetch "protected String toEncoded(String url, String sessionId) {" 9369636^:"java/org/apache/catalina/connector/Response.java"

            sb.append(Globals.SESSION_PARAMETER_NAME);
======= fetch "public static Cookie createSessionCookie(Context context," 9369636^:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

    /**
     * Determine the name to use for the session cookie for the provided
     * context.
     * @param context
     */
    public static String getSessionCookieName(Context context) {
======= fetch "public static String getSessionCookieName(Context context) {" 9369636^:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        return null;
    }
    
    
    /**
     * Determine the name to use for the session cookie for the provided
     * context.
     * @param context
     */
    public static String getSessionCookieName(Context context) {
    
        String result = getConfiguredSessionCookieName(context);
        
        if (result == null) {
            result = DEFAULT_SESSION_COOKIE_NAME; 
        }
        
        return result; 
    }
    
    /**
     * Determine the name to use for the session cookie for the provided
     * context.
     * @param context
     */
    public static String getSessionUriParamName(Context context) {
        
        String result = getConfiguredSessionCookieName(context);
        
        if (result == null) {
            result = DEFAULT_SESSION_PARAMETER_NAME; 
        }
======= fetch "public static String getSessionCookieName(Context context) {" 9369636^:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        return Globals.SESSION_COOKIE_NAME;
======= fetch "public Principal authenticate(String username, String clientDigest," 9369636^:"java/org/apache/catalina/realm/RealmBase.java"

        if (serverDigest.equals(clientDigest))
======= fetch "public Principal authenticate(String username, String clientDigest," 9369636^:"java/org/apache/catalina/realm/RealmBase.java"

        else
            return null;
======= fetch "public boolean hasResourcePermission(Request request," 9369636^:"java/org/apache/catalina/realm/RealmBase.java"

                } else {
                    if(log.isDebugEnabled())
                        log.debug("Passing all access");
                    status = true;
======= fetch "public boolean hasResourcePermission(Request request," 9369636^:"java/org/apache/catalina/realm/RealmBase.java"

                
                if(log.isDebugEnabled())
                    log.debug("Passing all access");
                status = true;
======= fetch "public boolean hasUserDataPermission(Request request," 9369636^:"java/org/apache/catalina/realm/RealmBase.java"

            file.append(Globals.SESSION_PARAMETER_NAME);
    <property name="org.apache.catalina.SESSION_PARAMETER_NAME">
      <p>An alternative name for the session path parameter. Defaults to
      <code>jsessionid</code>. Note that the Servlet specification requires
      this to be <code>jsessionid</code>. You should not rely on being able to
      change this.</p>
    </property>

    
    private static final String SCI_LOCATION =
        "META-INF/services/javax.servlet.ServletContainerInitializer";
======= fetch "protected boolean processServletContainerInitializers(" a7b96d0^:"java/org/apache/catalina/startup/ContextConfig.java"

            URL jarUrl = fragment.getURL();
======= fetch "protected boolean processServletContainerInitializers(" a7b96d0^:"java/org/apache/catalina/startup/ContextConfig.java"

                JarURLConnection conn =
                    (JarURLConnection) jarUrl.openConnection();
                jarFile = conn.getJarFile();   
                ZipEntry entry = jarFile.getEntry(
                        "META-INF/services/javax.servlet.ServletContainerInitializer");
                if (entry != null) {
                    is = jarFile.getInputStream(entry);
======= fetch "protected boolean processServletContainerInitializers(" a7b96d0^:"java/org/apache/catalina/startup/ContextConfig.java"

                        "contextConfig.servletContainerInitializerFail", jarUrl,
======= fetch "protected void processResourceJARs(Set<WebXml> fragments) {" a7b96d0^:"java/org/apache/catalina/startup/ContextConfig.java"

            URL jarUrl = fragment.getURL();
======= fetch "protected void processResourceJARs(Set<WebXml> fragments) {" a7b96d0^:"java/org/apache/catalina/startup/ContextConfig.java"

                JarURLConnection conn =
                    (JarURLConnection) jarUrl.openConnection();
                jarFile = conn.getJarFile();   
                ZipEntry entry = jarFile.getEntry("META-INF/resources/");
                if (entry != null) {
                    context.addResourceJarUrl(jarUrl);
======= fetch "protected void processResourceJARs(Set<WebXml> fragments) {" a7b96d0^:"java/org/apache/catalina/startup/ContextConfig.java"

                log.error(sm.getString("contextConfig.resourceJarFail", jarUrl,

======= fetch "public void setDomain(String pattern) {" 05810ee^:"java/javax/servlet/http/Cookie.java"


======= fetch "protected void connectUsingDriver() throws SQLException {" 4fff6c0^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        poolProperties.getDbProperties().setProperty("user", usr);
        poolProperties.getDbProperties().setProperty("password", pwd);

======= fetch "public String getFilename() {" 5ad9ecd^:"java/org/apache/catalina/core/ApplicationPart.java"

            String cdl = cd.toLowerCase();
======= fetch "public void setDefaultHost(String host) {" 5ad9ecd^:"java/org/apache/catalina/core/StandardEngine.java"

            this.defaultHost = host.toLowerCase();
======= fetch "public void setName(String name) {" 5ad9ecd^:"java/org/apache/catalina/core/StandardHost.java"

        name = name.toLowerCase();      // Internally all names are lower case
======= fetch "public void addAlias(String alias) {" 5ad9ecd^:"java/org/apache/catalina/core/StandardHost.java"

        alias = alias.toLowerCase();
======= fetch "public void removeAlias(String alias) {" 5ad9ecd^:"java/org/apache/catalina/core/StandardHost.java"

        alias = alias.toLowerCase();
======= fetch "public void setDispatcher(String dispatcherString) {" 5ad9ecd^:"java/org/apache/catalina/deploy/FilterMap.java"

        String dispatcher = dispatcherString.toUpperCase();
======= fetch "protected String upload(HttpServletRequest request)" 5ad9ecd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                if (!filename.toLowerCase().endsWith(".war")) {
======= fetch "protected String upload(HttpServletRequest request)" 5ad9ecd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                        filename.toLowerCase().indexOf(".war"));
======= fetch "private String extractFilename(String cd) {" 5ad9ecd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            String cdl = cd.toLowerCase();
======= fetch "public static Locale guessLocaleFromSession(final HttpSession in_session) {" 5ad9ecd^:"java/org/apache/catalina/manager/util/SessionUtils.java"

                obj = in_session.getAttribute(LOCALE_TEST_ATTRIBUTES[i].toLowerCase());
======= fetch "public static Locale guessLocaleFromSession(final HttpSession in_session) {" 5ad9ecd^:"java/org/apache/catalina/manager/util/SessionUtils.java"

                obj = in_session.getAttribute(LOCALE_TEST_ATTRIBUTES[i].toUpperCase());
======= fetch "public static Object guessUserFromSession(final Session in_session) {" 5ad9ecd^:"java/org/apache/catalina/manager/util/SessionUtils.java"

                obj = httpSession.getAttribute(USER_TEST_ATTRIBUTES[i].toLowerCase());
======= fetch "public static Object guessUserFromSession(final Session in_session) {" 5ad9ecd^:"java/org/apache/catalina/manager/util/SessionUtils.java"

                obj = httpSession.getAttribute(USER_TEST_ATTRIBUTES[i].toUpperCase());
======= fetch "protected boolean setCGIEnvironment(HttpServletRequest req) throws IOException {" 5ad9ecd^:"java/org/apache/catalina/servlets/CGIServlet.java"

                header = headers.nextElement().toUpperCase();
======= fetch "protected void doPropfind(HttpServletRequest req, HttpServletResponse resp)" 5ad9ecd^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if ((path.toUpperCase().startsWith("/WEB-INF")) ||
            (path.toUpperCase().startsWith("/META-INF"))) {
======= fetch "protected void doMkcol(HttpServletRequest req, HttpServletResponse resp)" 5ad9ecd^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if ((path.toUpperCase().startsWith("/WEB-INF")) ||
            (path.toUpperCase().startsWith("/META-INF"))) {
======= fetch "private boolean copyResource(HttpServletRequest req," 5ad9ecd^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if ((destinationPath.toUpperCase().startsWith("/WEB-INF")) ||
            (destinationPath.toUpperCase().startsWith("/META-INF"))) {
======= fetch "private boolean copyResource(HttpServletRequest req," 5ad9ecd^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if ((path.toUpperCase().startsWith("/WEB-INF")) ||
            (path.toUpperCase().startsWith("/META-INF"))) {
======= fetch "private boolean deleteResource(String path, HttpServletRequest req," 5ad9ecd^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if ((path.toUpperCase().startsWith("/WEB-INF")) ||
            (path.toUpperCase().startsWith("/META-INF"))) {
======= fetch "private void deleteCollection(HttpServletRequest req," 5ad9ecd^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if ((path.toUpperCase().startsWith("/WEB-INF")) ||
            (path.toUpperCase().startsWith("/META-INF"))) {
======= fetch "private void parseProperties(HttpServletRequest req," 5ad9ecd^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if (path.toUpperCase().startsWith("/WEB-INF") ||
            path.toUpperCase().startsWith("/META-INF"))
======= fetch "private void parseLockNullProperties(HttpServletRequest req," 5ad9ecd^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if (path.toUpperCase().startsWith("/WEB-INF") ||
            path.toUpperCase().startsWith("/META-INF"))
======= fetch "public void addDateHeader(String name, long value) {" 5ad9ecd^:"java/org/apache/catalina/ssi/ResponseIncludeWrapper.java"

        String lname = name.toLowerCase();
======= fetch "public void addHeader(String name, String value) {" 5ad9ecd^:"java/org/apache/catalina/ssi/ResponseIncludeWrapper.java"

        String lname = name.toLowerCase();
======= fetch "public void setDateHeader(String name, long value) {" 5ad9ecd^:"java/org/apache/catalina/ssi/ResponseIncludeWrapper.java"

        String lname = name.toLowerCase();
======= fetch "public void setHeader(String name, String value) {" 5ad9ecd^:"java/org/apache/catalina/ssi/ResponseIncludeWrapper.java"

        String lname = name.toLowerCase();
======= fetch "public String getVariableValue(String variableName, String encoding) {" 5ad9ecd^:"java/org/apache/catalina/ssi/SSIMediator.java"

        String lowerCaseVariableName = variableName.toLowerCase();
======= fetch "public String getVariableValue(String variableName, String encoding) {" 5ad9ecd^:"java/org/apache/catalina/ssi/SSIMediator.java"

                variableName = variableName.toUpperCase();
======= fetch "public long process(Reader reader, long lastModifiedDate," 5ad9ecd^:"java/org/apache/catalina/ssi/SSIProcessor.java"

                            commands.get(strCmd.toLowerCase());
======= fetch "protected void requestHandler(HttpServletRequest req," 5ad9ecd^:"java/org/apache/catalina/ssi/SSIServlet.java"

        if (path == null || path.toUpperCase().startsWith("/WEB-INF")
                || path.toUpperCase().startsWith("/META-INF")) {
======= fetch "protected String getCGIVariable(String name) {" 5ad9ecd^:"java/org/apache/catalina/ssi/SSIServletExternalResolver.java"

        String[] nameParts = name.toUpperCase().split("_");
======= fetch "public static ClassLoader createClassLoader(File unpacked[]," 5ad9ecd^:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                    String filename = filenames[j].toLowerCase();
======= fetch "public static ClassLoader createClassLoader(String locations[]," 5ad9ecd^:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                        String filename = filenames[j].toLowerCase();
======= fetch "protected void fixDocBase()" 5ad9ecd^:"java/org/apache/catalina/startup/ContextConfig.java"

        if (docBase.toLowerCase().endsWith(".war") && !file.isDirectory() && unpackWARs) {
======= fetch "protected void fixDocBase()" 5ad9ecd^:"java/org/apache/catalina/startup/ContextConfig.java"

        } else if (docBase.toLowerCase().endsWith(".war") &&
======= fetch "protected void antiLocking() {" 5ad9ecd^:"java/org/apache/catalina/startup/ContextConfig.java"

            if (docBase.toLowerCase().endsWith(".war")) {
======= fetch "protected void deployDescriptors(File configBase, String[] files) {" 5ad9ecd^:"java/org/apache/catalina/startup/HostConfig.java"

            if (files[i].toLowerCase().endsWith(".xml")) {
======= fetch "protected void deployDescriptor(String contextPath, File contextXml, String file" 5ad9ecd^:"java/org/apache/catalina/startup/HostConfig.java"

                    if (docBase.getAbsolutePath().toLowerCase().endsWith(".war")) {
======= fetch "protected void deployWARs(File appBase, String[] files) {" 5ad9ecd^:"java/org/apache/catalina/startup/HostConfig.java"

            if (files[i].toLowerCase().endsWith(".war") && dir.isFile()
======= fetch "public void manageApp(Context context)  {" 5ad9ecd^:"java/org/apache/catalina/startup/HostConfig.java"

            if (docBase.getAbsolutePath().toLowerCase().endsWith(".war")) {
            if (classpathItem.toLowerCase().endsWith(".jar")) {
======= fetch "public static synchronized boolean validateApplication(" 5ad9ecd^:"java/org/apache/catalina/util/ExtensionValidator.java"

            if (binding.getName().toUpperCase().equals("MANIFEST.MF")) {
======= fetch "public static synchronized boolean validateApplication(" 5ad9ecd^:"java/org/apache/catalina/util/ExtensionValidator.java"

                if (!binding.getName().toLowerCase().endsWith(".jar")) {
======= fetch "private static void addFolderList(String property) {" 5ad9ecd^:"java/org/apache/catalina/util/ExtensionValidator.java"

                    if (files[i].getName().toLowerCase().endsWith(".jar") &&
======= fetch "public static String convert(String mimeCharsetName) {" 5ad9ecd^:"java/org/apache/catalina/util/MIME2Java.java"

        return s_enchash.get(mimeCharsetName.toUpperCase());
======= fetch "public static String reverse(String encoding) {" 5ad9ecd^:"java/org/apache/catalina/util/MIME2Java.java"

        return s_revhash.get(encoding.toUpperCase());
======= fetch "public int indexOfIgnoreCase(String s, int starting) {" 5ad9ecd^:"java/org/apache/tomcat/util/buf/MessageBytes.java"

======= fetch "private static void processAcceptLanguage( String acceptLanguage," 5ad9ecd^:"java/org/apache/tomcat/util/http/AcceptLanguage.java"

                qValueStr = qValueStr.trim().toLowerCase();
======= fetch "public String getHeader(String name) {" 5ad9ecd^:"java/org/apache/tomcat/util/http/fileupload/FileItemHeadersImpl.java"

        String nameLower = name.toLowerCase();
======= fetch "public String getHeader(String name) {" 5ad9ecd^:"java/org/apache/tomcat/util/http/fileupload/FileItemHeadersImpl.java"

        String nameLower = name.toLowerCase();
======= fetch "public static final boolean isMultipartContent(RequestContext ctx) {" 5ad9ecd^:"java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java"

        if (contentType.toLowerCase().startsWith(MULTIPART)) {
======= fetch "private String getFileName(String pContentDisposition) {" 5ad9ecd^:"java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java"

            String cdl = pContentDisposition.toLowerCase();
======= fetch "private String getFieldName(String pContentDisposition) {" 5ad9ecd^:"java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java"

                && pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
======= fetch "public void setHeaders(FileItemHeaders pHeaders) {" 5ad9ecd^:"java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java"

                    || (!contentType.toLowerCase().startsWith(MULTIPART))) {
======= fetch "private boolean findNextItem() throws IOException {" 5ad9ecd^:"java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java"

                                &&  subContentType.toLowerCase()
======= fetch "public void setLowerCaseNames(boolean b) {" 5ad9ecd^:"java/org/apache/tomcat/util/http/fileupload/ParameterParser.java"

                    paramName = paramName.toLowerCase();
======= fetch "public static final boolean isMultipartContent(" 5ad9ecd^:"java/org/apache/tomcat/util/http/fileupload/ServletFileUpload.java"

        if (!"post".equals(request.getMethod().toLowerCase())) {
======= fetch "public static final boolean isMultipartContent(" 5ad9ecd^:"java/org/apache/tomcat/util/http/fileupload/ServletFileUpload.java"

        if (contentType.toLowerCase().startsWith(MULTIPART)) {
======= fetch "public void setImpact(String impact) {" 5ad9ecd^:"java/org/apache/tomcat/util/modeler/OperationInfo.java"

            this.impact = impact.toUpperCase();
======= fetch "public URL(URL context, String spec) throws MalformedURLException {" 5ad9ecd^:"java/org/apache/tomcat/util/net/URL.java"

                    String s = spec.substring(start, i).toLowerCase();
======= fetch "void init() throws IOException {" 5ad9ecd^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

                alias = alias.toLowerCase();
======= fetch "public int doEndTag() throws JspException {" 5ad9ecd^:"webapps/examples/WEB-INF/classes/examples/ShowSource.java"

            (jspFile.toUpperCase().indexOf("/WEB-INF/") != 0) ||
            (jspFile.toUpperCase().indexOf("/META-INF/") != 0))
======= fetch "public static String caps( String text ) {" 5ad9ecd^:"webapps/examples/WEB-INF/classes/jsp2/examples/el/Functions.java"

        return text.toUpperCase();

======= fetch "protected void prepareRequest() {" 09abffb^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                    (startPos, commaPos).toLowerCase().trim();
======= fetch "protected void prepareRequest() {" 09abffb^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                .toLowerCase().trim();
======= fetch "protected void prepareRequest() {" 09abffb^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                    (startPos, commaPos).toLowerCase().trim();
======= fetch "protected void prepareRequest() {" 09abffb^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                .toLowerCase().trim();
======= fetch "protected void prepareRequest() {" 09abffb^:"java/org/apache/coyote/http11/Http11Processor.java"

                    (startPos, commaPos).toLowerCase().trim();
======= fetch "protected void prepareRequest() {" 09abffb^:"java/org/apache/coyote/http11/Http11Processor.java"

                .toLowerCase().trim();

======= fetch "private String comparePageEncodings(String thePageDirEnc," a954806^:"java/org/apache/jasper/compiler/Validator.java"

            String pageDirEnc = thePageDirEnc.toUpperCase();
======= fetch "private String comparePageEncodings(String thePageDirEnc," a954806^:"java/org/apache/jasper/compiler/Validator.java"

                configEnc = configEnc.toUpperCase();
======= fetch "private String comparePageEncodings(String thePageDirEnc," a954806^:"java/org/apache/jasper/compiler/Validator.java"

                String pageEnc = root.getPageEncoding().toUpperCase();
======= fetch "private void compareTagEncodings(String thePageDirEnc," a954806^:"java/org/apache/jasper/compiler/Validator.java"

            String pageDirEnc = thePageDirEnc.toUpperCase();
======= fetch "private void compareTagEncodings(String thePageDirEnc," a954806^:"java/org/apache/jasper/compiler/Validator.java"

                String pageEnc = root.getPageEncoding().toUpperCase();
======= fetch "public static String getContentTypeAttribute(String input, String name) {" a954806^:"java/org/apache/jasper/tagplugins/jstl/Util.java"

        int index = input.toUpperCase().indexOf(name.toUpperCase());

======= fetch "protected void processAnnotationsStream(InputStream is, WebXml fragment)" 4a581aa^:"java/org/apache/catalina/startup/ContextConfig.java"

     * super class needs to be checked for a match with {@Link HandlesTypes}.
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" 4a581aa^:"java/org/apache/catalina/startup/ContextConfig.java"

        if (clazz.isAnnotation()) {
            // Skip
            return;
        }
        
        boolean match = false;
        
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" 4a581aa^:"java/org/apache/catalina/startup/ContextConfig.java"

            if (entry.getKey().isAssignableFrom(clazz)) {
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" 4a581aa^:"java/org/apache/catalina/startup/ContextConfig.java"

    private static final String getClassName(String internalForm) {
        if (!internalForm.startsWith("L")) {
            return internalForm;
        }
        
        // Assume starts with L, ends with ; and uses / rather than .
        return internalForm.substring(1,
                internalForm.length() - 1).replace('/', '.');
    }

======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" f24ed2d^:"java/org/apache/catalina/startup/ContextConfig.java"

            clazz = Class.forName(className, true,
                    context.getLoader().getClassLoader());
======= fetch "protected void checkHandlesTypes(JavaClass javaClass) {" f24ed2d^:"java/org/apache/catalina/startup/ContextConfig.java"

            return;

    protected int maxIdle = Integer.MAX_VALUE;

    protected static final String PROP_SUSPECT_TIMEOUT = "suspectTimeout";
    
======= fetch "public static PoolConfiguration parsePoolProperties(Properties properties) throw" b75b021^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        value = properties.getProperty(PROP_SUSPECT_TIMEOUT);
        if (value != null) {
            poolProperties.setSuspectTimeout(Integer.parseInt(value));
        }

======= fetch "public static void displayClassPath(String msg, URL[] cp) {" 616bd68^:"test/org/apache/catalina/tribes/demos/IntrospectionUtils.java"

    public static String PATH_SEPARATOR = System.getProperty("path.separator");

======= fetch "public void addMappingForUrlPatterns(" 3396917^:"java/org/apache/catalina/core/ApplicationFilterRegistration.java"

        

======= fetch "public void addFilterMapBefore(FilterMap filterMap) {" 3f4a241^:"java/org/apache/catalina/core/StandardContext.java"

                    filterMaps.length - filterMapInsertPoint + 1,

    protected Map<String, URL> tagFileJarUrls;
    protected URL tagFileJarUrl;
======= fetch "public JspCompilationContext(String jspUri," efd418b^:"java/org/apache/jasper/JspCompilationContext.java"

        this.tagFileJarUrls = new HashMap<String, URL>();
======= fetch "public JspCompilationContext(String tagfile," efd418b^:"java/org/apache/jasper/JspCompilationContext.java"

                                 URL tagFileJarUrl) {
======= fetch "public JspCompilationContext(String tagfile," efd418b^:"java/org/apache/jasper/JspCompilationContext.java"

        this.tagFileJarUrl = tagFileJarUrl;
        if (tagFileJarUrl != null) {
======= fetch "public URL getResource(String res) throws MalformedURLException {" efd418b^:"java/org/apache/jasper/JspCompilationContext.java"

            URL jarUrl = tagFileJarUrls.get(res);
            if (jarUrl == null) {
                jarUrl = tagFileJarUrl;
======= fetch "public URL getResource(String res) throws MalformedURLException {" efd418b^:"java/org/apache/jasper/JspCompilationContext.java"

            if (jarUrl != null) {
                result = new URL(jarUrl.toExternalForm() + res.substring(1));
======= fetch "public String getRealPath(String path) {" efd418b^:"java/org/apache/jasper/JspCompilationContext.java"

    public URL getTagFileJarUrl(String tagFile) {
======= fetch "public URL getTagFileJarUrl(String tagFile) {" efd418b^:"java/org/apache/jasper/JspCompilationContext.java"

    public void setTagFileJarUrl(String tagFile, URL tagFileURL) {
        this.tagFileJarUrls.put(tagFile, tagFileURL);
======= fetch "public void setTagFileJarUrl(String tagFile, URL tagFileURL) {" efd418b^:"java/org/apache/jasper/JspCompilationContext.java"

    public URL getTagFileJarUrl() {
        return this.tagFileJarUrl;
======= fetch "public void setWriter(ServletWriter writer) {" efd418b^:"java/org/apache/jasper/JspCompilationContext.java"

    public String[] getTldLocation(String uri) throws JasperException {
        String[] location = 
======= fetch "public TagFileInfo getTagFile(String shortName) {" efd418b^:"java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java"

                        pc.getJspCompilationContext().getTagFileJarUrl(path),
======= fetch "private TagLibraryInfo getTaglibInfo(String prefix, String uri)" efd418b^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

            String[] location = ctxt.getTldLocation(uri);
    private URL jarFileUrl;
======= fetch "private Parser(ParserController pc, JspReader reader, boolean isTagFile," efd418b^:"java/org/apache/jasper/compiler/Parser.java"

            boolean directivesOnly, URL jarFileUrl) {
======= fetch "private Parser(ParserController pc, JspReader reader, boolean isTagFile," efd418b^:"java/org/apache/jasper/compiler/Parser.java"

        this.jarFileUrl = jarFileUrl;
======= fetch "private Parser(ParserController pc, JspReader reader, boolean isTagFile," efd418b^:"java/org/apache/jasper/compiler/Parser.java"

            URL jarFileUrl, String pageEnc, String jspConfigPageEnc,
======= fetch "private Parser(ParserController pc, JspReader reader, boolean isTagFile," efd418b^:"java/org/apache/jasper/compiler/Parser.java"

                jarFileUrl);
======= fetch "private void processIncludeDirective(String file, Node parent)" efd418b^:"java/org/apache/jasper/compiler/Parser.java"

            parserController.parse(file, parent, jarFileUrl);
======= fetch "private void parseTaglibDirective(Node parent) throws JasperException {" efd418b^:"java/org/apache/jasper/compiler/Parser.java"

                        String[] location = ctxt.getTldLocation(uri);
======= fetch "private void parseTaglibDirective(Node parent) throws JasperException {" efd418b^:"java/org/apache/jasper/compiler/Parser.java"

                            ctxt.setTagFileJarUrl(info.getPath(),
                                    ctxt.getTagFileJarUrl());
======= fetch "public Compiler getCompiler () {" efd418b^:"java/org/apache/jasper/compiler/ParserController.java"

        return doParse(inFileName, null, ctxt.getTagFileJarUrl());
======= fetch "public Compiler getCompiler () {" efd418b^:"java/org/apache/jasper/compiler/ParserController.java"

        return doParse(inFileName, null, ctxt.getTagFileJarUrl());
======= fetch "public Compiler getCompiler () {" efd418b^:"java/org/apache/jasper/compiler/ParserController.java"

            URL jarFileUrl)
======= fetch "public Compiler getCompiler () {" efd418b^:"java/org/apache/jasper/compiler/ParserController.java"

        return doParse(inFileName, parent, jarFileUrl);
======= fetch "public Compiler getCompiler () {" efd418b^:"java/org/apache/jasper/compiler/ParserController.java"

            URL tagFileJarUrl)
======= fetch "public Compiler getCompiler () {" efd418b^:"java/org/apache/jasper/compiler/ParserController.java"

        Node.Nodes page = doParse(inFileName, null, tagFileJarUrl);
======= fetch "public Compiler getCompiler () {" efd418b^:"java/org/apache/jasper/compiler/ParserController.java"

            URL jarFileUrl)
======= fetch "public Compiler getCompiler () {" efd418b^:"java/org/apache/jasper/compiler/ParserController.java"

        JarFile jarFile = getJarFile(jarFileUrl);
======= fetch "public Compiler getCompiler () {" efd418b^:"java/org/apache/jasper/compiler/ParserController.java"

                        jarFileUrl.toExternalForm() + absFileName.substring(1));
======= fetch "public Compiler getCompiler () {" efd418b^:"java/org/apache/jasper/compiler/ParserController.java"

                        directiveOnly, jarFileUrl,
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            String name, String path, URL tagFileJarUrl, TagLibraryInfo tagLibInfo)
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            page = pc.parseTagFileDirectives(path, tagFileJarUrl);
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

        URL tagFileJarUrl = null;
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            try { 
                tagFileJarUrl = new URL("jar:" +
                        compiler.getCompilationContext().getTldLocation(
                        tagInfo.getTagLibrary().getURI())[0] + "!/");
            } catch (MalformedURLException e) {
                // Ignore - tagFileJarUrl will be null
            }
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

        String tagFileJarPath;
        if (tagFileJarUrl == null) {
            tagFileJarPath = "";
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            tagFileJarPath = tagFileJarUrl.toString();
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

        String wrapperUri = tagFileJarPath + tagFilePath;
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                        .getRuntimeContext(), tagFileJarUrl);
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                            ctxt.getTagFileJarUrl(tagFilePath));
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                    String[] location =
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                    JarResource jarResource = location.getJarResource();
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                    pageInfo.addDependant("jar:" + location[0] + "!/" +
                            location[1]);
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" efd418b^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                    pageInfo.addDependant("jar:" + location[0] + "!" +
                            tagFilePath);
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

            String prefix, String uriIn, String[] location, ErrorDispatcher err)
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

        JarFile jarFile = null;
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

        String tldName = location.getName();
        JarResource jarResource = location.getJarResource();
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

            if (location[1] == null) {
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                    in = getResourceAsStream(location[0]);
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                        throw new FileNotFoundException(location[0]);
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                    err.jspError("jsp.error.file.not.found", location[0]);
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                parseTLD(location[0], in, null);
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                    pageInfo.addDependant(location[0]);
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                    URL jarFileUrl = new URL("jar:" + location[0] + "!/");
                    JarURLConnection conn = (JarURLConnection) jarFileUrl
                            .openConnection();
                    conn.setUseCaches(false);
                    conn.connect();
                    jarFile = conn.getJarFile();
                    ZipEntry jarEntry = jarFile.getEntry(location[1]);
                    in = jarFile.getInputStream(jarEntry);
                    parseTLD(location[0], in, jarFileUrl);
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                    err.jspError("jsp.error.tld.unable_to_read", location[0],
                            location[1], ex.toString());
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (Throwable t) {
                }
            }
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

    private void parseTLD(String uri, InputStream in, URL jarFileUrl)
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                        jarFileUrl);
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

    private String[] generateTLDLocation(String uri, JspCompilationContext ctxt)
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

        String[] location = new String[2];
        location[0] = uri;
        if (location[0].endsWith(".jar")) {
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                url = ctxt.getResource(location[0]);
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                err.jspError("jsp.error.tld.unable_to_get_jar", location[0], ex
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                err.jspError("jsp.error.tld.missing_jar", location[0]);
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

            location[0] = url.toString();
            location[1] = "META-INF/taglib.tld";
======= fetch "public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc, PageI" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

        return location;
======= fetch "private TagInfo createTagInfo(TreeNode elem, String jspVersion)" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

    private TagFileInfo createTagFileInfo(TreeNode elem, URL jarFileUrl)
======= fetch "private TagFileInfo createTagFileInfo(TreeNode elem, URL jarFileUrl)" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

            ctxt.setTagFileJarUrl(path, jarFileUrl);
======= fetch "private TagFileInfo createTagFileInfo(TreeNode elem, URL jarFileUrl)" efd418b^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                parserController, name, path, jarFileUrl, this);
    private Hashtable<String, String[]> mappings;
======= fetch "public TldLocationsCache(ServletContext ctxt) {" efd418b^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

        mappings = new Hashtable<String, String[]>();
======= fetch "public static void setNoTldJars(String jarNames) {" efd418b^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

    public String[] getLocation(String uri) throws JasperException {
======= fetch "private void tldScanWebXml() throws Exception {" efd418b^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

                String tagLoc2 = null;
======= fetch "private void tldScanWebXml() throws Exception {" efd418b^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

                    tagLoc = ctxt.getResource(tagLoc).toString();
                    tagLoc2 = "META-INF/taglib.tld";
======= fetch "private void tldScanWebXml() throws Exception {" efd418b^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

                mappings.put(tagUri, new String[] { tagLoc, tagLoc2 });
======= fetch "private void tldScanStream(String resourcePath, String entryName," efd418b^:"java/org/apache/jasper/compiler/TldLocationsCache.java"

                mappings.put(uri, new String[]{ resourcePath, entryName });
======= fetch "public JspServletWrapper(ServletContext servletContext," efd418b^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                             URL tagFileJarUrl) {
======= fetch "public JspServletWrapper(ServletContext servletContext," efd418b^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                                         tagFileJarUrl);

======= fetch "protected void parseLocalesHeader(String value) {" b30fc95^:"java/org/apache/catalina/connector/Request.java"

        Iterator<Double> keys = locales.keySet().iterator();
        while (keys.hasNext()) {
            Double key = keys.next();
            ArrayList<Locale> list = locales.get(key);
            Iterator<Locale> values = list.iterator();
            while (values.hasNext()) {
                Locale locale = values.next();
======= fetch "public String getInfo() {" b30fc95^:"java/org/apache/catalina/core/ApplicationHttpRequest.java"

        Iterator<String> keys = orig.keySet().iterator();
        while (keys.hasNext()) {
            String key = keys.next();
            dest.put(key, orig.get(key));
======= fetch "public String getInfo() {" b30fc95^:"java/org/apache/catalina/core/ApplicationHttpRequest.java"

======= fetch "public void loadOnStartup(Container children[]) {" b30fc95^:"java/org/apache/catalina/core/StandardContext.java"

        Iterator<Integer> keys = map.keySet().iterator();
        while (keys.hasNext()) {
            Integer key = keys.next();
            ArrayList<Wrapper> list = map.get(key);
            Iterator<Wrapper> wrappers = list.iterator();
            while (wrappers.hasNext()) {
                Wrapper wrapper = wrappers.next();
======= fetch "private Session getSession(String sessionId, String ctxname) {" b30fc95^:"java/org/apache/catalina/ha/authenticator/ClusterSingleSignOnListener.java"

            java.util.Iterator<String> i = managers.keySet().iterator();
            while (i.hasNext()) {
                String key = i.next();
                ClusterManager mgr = managers.get(key);
                if (mgr != null) {
======= fetch "private Session getSession(String sessionId, String ctxname) {" b30fc95^:"java/org/apache/catalina/ha/authenticator/ClusterSingleSignOnListener.java"

                        session = mgr.findSession(sessionId);
======= fetch "private Session getSession(String sessionId, String ctxname) {" b30fc95^:"java/org/apache/catalina/ha/authenticator/ClusterSingleSignOnListener.java"

                                  + key);
======= fetch "public void messageReceived(ClusterMessage myobj) {" b30fc95^:"java/org/apache/catalina/ha/session/ClusterSessionListener.java"

                Iterator<String> i = managers.keySet().iterator();
                while (i.hasNext()) {
                    String key = i.next();
                    ClusterManager mgr = managers.get(key);
                    if (mgr != null)
                        mgr.messageDataReceived(msg);
======= fetch "public void messageReceived(ClusterMessage myobj) {" b30fc95^:"java/org/apache/catalina/ha/session/ClusterSessionListener.java"

                                    + key);
======= fetch "protected void processAnnotationWebServlet(String className," b30fc95^:"java/org/apache/catalina/startup/ContextConfig.java"

                for (String paramName : initParams.keySet()) {
                    servletDef.addInitParameter(paramName,
                            initParams.get(paramName));
======= fetch "protected void processAnnotationWebFilter(String className," b30fc95^:"java/org/apache/catalina/startup/ContextConfig.java"

                for (String paramName : initParams.keySet()) {
                    filterDef.addInitParameter(paramName,
                            initParams.get(paramName));

    protected static MessageDigest md5Helper;
======= fetch "public StandardSession(Manager manager) {" a6092d7^:"java/org/apache/catalina/session/StandardSession.java"

    protected static HttpSessionContext sessionContext = null;
======= fetch "protected void writeObject(ObjectOutputStream stream) throws IOException {" a6092d7^:"java/org/apache/catalina/session/StandardSession.java"

        stream.writeObject(new Long(creationTime));
        stream.writeObject(new Long(lastAccessedTime));
        stream.writeObject(new Integer(maxInactiveInterval));
        stream.writeObject(new Boolean(isNew));
        stream.writeObject(new Boolean(isValid));
        stream.writeObject(new Long(thisAccessedTime));
======= fetch "protected void writeObject(ObjectOutputStream stream) throws IOException {" a6092d7^:"java/org/apache/catalina/session/StandardSession.java"

        stream.writeObject(new Integer(n));
    private static Set<String> noTldJars = null;
    private static ArrayList<Extension> containerAvailableExtensions = null;
    protected static Digester digester = null;

======= fetch "public void setAwait(boolean await)" fd7ed83^:"java/org/apache/catalina/startup/Bootstrap.java"

        paramValues[0] = new Boolean(await);
======= fetch "public static void main(String args[]) {" fd7ed83^:"java/org/apache/catalina/startup/Bootstrap.java"

            daemon = new Bootstrap();
======= fetch "public static void main(String args[]) {" fd7ed83^:"java/org/apache/catalina/startup/Bootstrap.java"

                daemon.init();
======= fetch "public static void main(String args[]) {" fd7ed83^:"java/org/apache/catalina/startup/Bootstrap.java"

            daemon = bootstrap;

======= fetch "public void testOrder2() throws Exception {" aa758d8^:"test/org/apache/catalina/tribes/test/interceptors/TestOrderInterceptor.java"

        final Queue<Exception> exceptionQueue = new ConcurrentLinkedQueue<Exception>();
======= fetch "public void run() {" aa758d8^:"test/org/apache/catalina/tribes/test/interceptors/TestOrderInterceptor.java"

                        x.printStackTrace();
                        assertEquals(true,false);
======= fetch "public void run() {" aa758d8^:"test/org/apache/catalina/tribes/test/interceptors/TestOrderInterceptor.java"

        if (!exceptionQueue.isEmpty()) {
        	fail("Exception while sending in threads: " 
        			+ exceptionQueue.remove().toString());
        }

======= fetch "public static final Tag findAncestorWithClass(Tag from," 8bd4d7a^:"java/javax/servlet/jsp/tagext/TagSupport.java"

                klass.isAssignableFrom(tag.getClass())) {

======= fetch "protected void handleGET_ALL_SESSIONS(SessionMessage msg, Member sender) throws" f61100d^:"java/org/apache/catalina/ha/session/DeltaManager.java"

            int len = currentSessions.length < getSendAllSessionsSize() ? currentSessions.length : getSendAllSessionsSize();
            Session[] sendSessions = new Session[len];
======= fetch "protected void handleGET_ALL_SESSIONS(SessionMessage msg, Member sender) throws" f61100d^:"java/org/apache/catalina/ha/session/DeltaManager.java"

                len = i + getSendAllSessionsSize() > currentSessions.length ? currentSessions.length - i : getSendAllSessionsSize();

     * prestart threads?
     */
    protected boolean prestartminSpareThreads = false;
    /**
======= fetch "protected void startInternal() throws LifecycleException {" e7fb8fa^:"java/org/apache/catalina/core/StandardThreadExecutor.java"

        if (prestartminSpareThreads) {
            executor.prestartAllCoreThreads();
        }
======= fetch "public String getName() {" e7fb8fa^:"java/org/apache/catalina/core/StandardThreadExecutor.java"

    public boolean isPrestartminSpareThreads() {
        return prestartminSpareThreads;
    }
======= fetch "public void setMinSpareThreads(int minSpareThreads) {" e7fb8fa^:"java/org/apache/catalina/core/StandardThreadExecutor.java"

    public void setPrestartminSpareThreads(boolean prestartminSpareThreads) {
        this.prestartminSpareThreads = prestartminSpareThreads;
    }
      <add>
        <bug>43642</bug>: Add prestartminSpareThreads attribute for Executor. (jfclere)
      </add>
    <attribute name="prestartminSpareThreads" required="false">
      <p>(boolean) Whether minSpareThreads should be started when starting the Executor or not,
          the default is <code>false</code></p>
    </attribute>


======= fetch "protected synchronized void stopInternal() throws LifecycleException {" fcb9861^:"java/org/apache/catalina/ha/session/BackupManager.java"

        LazyReplicatedMap map = (LazyReplicatedMap)sessions;
        if ( map!=null ) {
            map.breakdown();

======= fetch "protected synchronized void startInternal() throws LifecycleException {" 09f4e25^:"java/org/apache/catalina/ha/session/BackupManager.java"

        
        if (!initialized) init();
        // Force initialization of the random number generator
        generateSessionId();
======= fetch "protected synchronized void startInternal() throws LifecycleException {" 09f4e25^:"java/org/apache/catalina/ha/session/BackupManager.java"

        super.startInternal();
======= fetch "protected synchronized void stopInternal() throws LifecycleException {" 09f4e25^:"java/org/apache/catalina/ha/session/BackupManager.java"

        super.stopInternal();
        
======= fetch "protected synchronized void stopInternal() throws LifecycleException {" 09f4e25^:"java/org/apache/catalina/ha/session/BackupManager.java"

        this.random = null;
        if( initialized ) {
            destroy();
        }

======= fetch "public DigestAuthenticator() {" 867605f^:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

    protected static MessageDigest md5Helper;

======= fetch "protected void doTrace(HttpServletRequest req, HttpServletResponse resp)" 95a2eb8^:"java/javax/servlet/http/HttpServlet.java"

        String responseString = "TRACE "+ req.getRequestURI()+
            " " + req.getProtocol();
======= fetch "protected void doTrace(HttpServletRequest req, HttpServletResponse resp)" 95a2eb8^:"java/javax/servlet/http/HttpServlet.java"

            responseString += CRLF + headerName + ": " +
                req.getHeader(headerName); 
======= fetch "protected void doTrace(HttpServletRequest req, HttpServletResponse resp)" 95a2eb8^:"java/javax/servlet/http/HttpServlet.java"

        responseString += CRLF;
======= fetch "protected void doTrace(HttpServletRequest req, HttpServletResponse resp)" 95a2eb8^:"java/javax/servlet/http/HttpServlet.java"

        responseLength = responseString.length();
======= fetch "protected void doTrace(HttpServletRequest req, HttpServletResponse resp)" 95a2eb8^:"java/javax/servlet/http/HttpServlet.java"

        out.print(responseString);        

======= fetch "public Void run() {" b027259^:"java/org/apache/jasper/runtime/JspFactoryImpl.java"

    protected final class PageContextPool  {

     * Return the Principal associated with the specified username and
     * credentials, if there is one; otherwise return <code>null</code>.
     *
     * @param username Username of the Principal to look up
     * @param credentials Password or other credentials to use in
     *  authenticating this username
     */
    public Principal authenticate(String username, byte[] credentials);
    /**
======= fetch "public void addRealm(Realm theRealm) {" bcf0a01^:"java/org/apache/catalina/realm/CombinedRealm.java"

     * Return the Principal associated with the specified username and
     * credentials, if there is one; otherwise return <code>null</code>.
     *
     * @param username Username of the Principal to look up
     * @param credentials Password or other credentials to use in
     *  authenticating this username
     */
    @Override
    public Principal authenticate(String username, byte[] credentials) {
        Principal authenticatedUser = null;
        
        for (Realm realm : realms) {
            if (log.isDebugEnabled()) {
                log.debug(sm.getString("combinedRealm.authStart", username, realm.getInfo()));
            }
            
            authenticatedUser = realm.authenticate(username, credentials);
            
            if (authenticatedUser == null) {
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("combinedRealm.authFail", username, realm.getInfo()));
                }
            } else {
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("combinedRealm.authSucess", username, realm.getInfo()));
                }
                break;
            }
        }
        return authenticatedUser;
    }
    /**
======= fetch "protected boolean removeEldestEntry(" bcf0a01^:"java/org/apache/catalina/realm/LockOutRealm.java"

     * Return the Principal associated with the specified username and
     * credentials, if there is one; otherwise return <code>null</code>.
     *
     * @param username Username of the Principal to look up
     * @param credentials Password or other credentials to use in
     *  authenticating this username
     */
    @Override
    public Principal authenticate(String username, byte[] credentials) {
        if (isLocked(username)) {
            // Trying to authenticate a locked user is an automatic failure
            registerAuthFailure(username);
            
            log.warn(sm.getString("lockOutRealm.authLockedUser", username));
            return null;
        }
        Principal authenticatedUser = super.authenticate(username, credentials);
        
        if (authenticatedUser == null) {
            registerAuthFailure(username);
        } else {
            registerAuthSuccess(username);
        }
        return authenticatedUser;
    }
    /**
======= fetch "public Principal authenticate(String username, String credentials) {" bcf0a01^:"java/org/apache/catalina/realm/RealmBase.java"

     * Return the Principal associated with the specified username and
     * credentials, if there is one; otherwise return <code>null</code>.
     *
     * @param username Username of the Principal to look up
     * @param credentials Password or other credentials to use in
     *  authenticating this username
     */
    public Principal authenticate(String username, byte[] credentials) {
        return (authenticate(username, credentials.toString()));
    }
    /**


======= fetch "public abstract MethodExpression createMethodExpression(ELContext context," ead3997^:"java/javax/el/ExpressionFactory.java"

     * @return
======= fetch "public static ExpressionFactory newInstance() {" ead3997^:"java/javax/el/ExpressionFactory.java"

     * @param properties
     * @return
======= fetch "public HttpConstraintElement() {" ead3997^:"java/javax/servlet/HttpConstraintElement.java"

     * Convenience constructor for {@link EmptyRoleSemantic.DENY}.
     *                                  {@link SessionTrackingMode.SSL} in
     * @param jspWildCard true if name identifies the JspServlet
     * @return
 * the component as soon as {@link start()} exits.
     * @see #getThisAccessedTime().
     * @see #getLastAccessedTime().
======= fetch "public boolean authenticate(Request request," ead3997^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

     *                      to {@link HttpServletResponse#sendError(int, String)
======= fetch "protected void forwardToLoginPage(Request request," ead3997^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

     *                      to {@link HttpServletResponse#sendError(int, String)
======= fetch "public Session getSessionInternal() {" ead3997^:"java/org/apache/catalina/connector/Request.java"

     * @param session   The session to change the session ID for
======= fetch "public void setSecure(boolean secure) {" ead3997^:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

     * @param conetxt     The Context for the web application
======= fetch "public void destroy() throws Exception {" ead3997^:"java/org/apache/catalina/core/ContainerBase.java"

     * the digester should use {@link #getPipeline()#addValve(Valve)} in case a
======= fetch "public boolean getClearReferencesThreadLocals() {" ead3997^:"java/org/apache/catalina/core/StandardContext.java"

     * Set the clearReferencesStopThreads feature for this Context.
======= fetch "public boolean getClearReferencesThreadLocals() {" ead3997^:"java/org/apache/catalina/core/StandardContext.java"

     * @param clearReferencesStopThreads The new flag value
======= fetch "public long getThisAccessedTime() {" ead3997^:"java/org/apache/catalina/session/StandardSession.java"

     * @see #getThisAccessedTime().
======= fetch "public long getLastAccessedTime() {" ead3997^:"java/org/apache/catalina/session/StandardSession.java"

     * @see #getLastAccessedTime().
     * @see Object#hashCode(int)
======= fetch "public RpcChannel(byte[] rpcId, Channel channel, RpcCallback callback) {" ead3997^:"java/org/apache/catalina/tribes/group/RpcChannel.java"

     * @param options int - FIRST_REPLY, MAJORITY_REPLY or ALL_REPLY
======= fetch "public ValueReference getValueReference(EvaluationContext ctx) {" ead3997^:"java/org/apache/el/parser/AstValue.java"

     * @ since EL 2.2
======= fetch "public boolean isNamedAttribute() {" ead3997^:"java/org/apache/jasper/compiler/Node.java"

         * @return false for string literals or rtexprvalues that should not be
======= fetch "public void stop() {" ead3997^:"webapps/examples/WEB-INF/classes/chat/ChatServlet.java"

        /**
         * Add specified socket and associated pool to the poller. The socket will
         * be added to a temporary array, and polled first after a maximum amount
         * of time equal to pollTime (in most cases, latency will be much lower,
         * however).
         *
         * @param socket to add to the poller
         */
======= fetch "public void destroy() {" ead3997^:"webapps/examples/WEB-INF/classes/filters/ExampleFilter.java"

     * @param result The servlet response we are creating
======= fetch "public void destroy() {" ead3997^:"webapps/examples/WEB-INF/classes/filters/SetCharacterEncodingFilter.java"

     * @param result The servlet response we are creating

======= fetch "public void setPacketSize(int packetSize) {" 5be4f29^:"java/org/apache/coyote/ajp/AjpProtocol.java"

        protected ConcurrentHashMap<SocketWrapper, AjpProcessor> connections =
            new ConcurrentHashMap<SocketWrapper, AjpProcessor>();
======= fetch "public void setSSLImplementation( String valueS) {" 5be4f29^:"java/org/apache/coyote/http11/Http11Protocol.java"

        protected ConcurrentHashMap<SocketWrapper, Http11Processor> connections =
            new ConcurrentHashMap<SocketWrapper, Http11Processor>();
======= fetch "public void run() {" 5be4f29^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

                Iterator<SocketWrapper> sockets = waitingRequests.iterator();
======= fetch "public void run() {" 5be4f29^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

                    SocketWrapper socket = sockets.next();
======= fetch "public boolean processSocket(SocketWrapper<Socket> socket, SocketStatus status)" 5be4f29^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

    protected ConcurrentLinkedQueue<SocketWrapper> waitingRequests = new ConcurrentLinkedQueue<SocketWrapper>();

    @Override
    @Override
======= fetch "public int getSendfileCount() {" 1018cd7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    @Override
======= fetch "public void init()" 1018cd7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    @Override
======= fetch "public void start()" 1018cd7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    @Override
======= fetch "public void pause() {" 1018cd7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    @Override
======= fetch "public void stop() {" 1018cd7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    @Override
======= fetch "public boolean isPaused() {" 1018cd7^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    @Override
======= fetch "public void init()" 1018cd7^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    @Override
======= fetch "public void start()" 1018cd7^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    @Override
======= fetch "public void pause() {" 1018cd7^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    @Override
======= fetch "public void stop() {" 1018cd7^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    @Override
======= fetch "public SSLSupport getSSLSupport(Socket s) {" 1018cd7^:"java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java"

    @Override

======= fetch "public String createStandardContext(String parent," 32046eb^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

        // XXX for backward compatibility. Remove it once supported by the admin
        return 
            createStandardContext(parent,path,docBase,false,false,false,false);                                  
======= fetch "public String createStandardHost(String parent, String name," 32046eb^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * Creates a new StandardService and StandardEngine.
     *
     * @param domain       Domain name for the container instance
     * @param defaultHost  Name of the default host to be used in the Engine
     * @param baseDir      Base directory value for Engine 
     *
     * @exception Exception if an MBean cannot be created or registered
     */
    public String createStandardServiceEngine(String domain,
            String defaultHost, String baseDir) throws Exception{
        if (!(container instanceof Server)) {
            throw new Exception();
        }
        
        StandardEngine engine = new StandardEngine();
        engine.setDomain(domain);
        engine.setName(domain);
        engine.setDefaultHost(defaultHost);
        engine.setBaseDir(baseDir);
        Service service = new StandardService();
        service.setContainer(engine);
        service.setName(domain);
        
        ((Server) container).addService(service);
        
        return engine.getJmxName().toString();
    }
    
    
    /**
======= fetch "public void removeRealm(String name) throws Exception {" 32046eb^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

            className="org.apache.catalina.mbeans.MBeanFactory"
    <operation   name="createFileLogger"
          description="Create a new FileLogger"
               impact="ACTION"
           returnType="java.lang.String">
      <parameter name="parent"
          description="MBean Name of the associated parent component"
                 type="java.lang.String"/>
    </operation>
    <operation   name="createStandardEngine"
          description="Create a new StandardEngine"
      <parameter name="parent"
          description="MBean Name of the associated parent component"
                 type="java.lang.String"/>
      <parameter name="name"
          description="Unique name of this Engine"
                 type="java.lang.String"/>
      <parameter name="defaultHost"
          description="Default host name for this Engine"
                 type="java.lang.String"/>
    </operation>
    <operation   name="createStandardEngineService"
          description="Create a new StandardEngine and StandardService"
               impact="ACTION"
           returnType="java.lang.String">
      <parameter name="parent"
          description="MBean Name of the associated parent Service"
                 type="java.lang.String"/>
      <parameter name="engineName"
          description="Unique name of this Engine"
          description="Default host name for this Engine"
      <parameter name="serviceName"
          description="Unique name of this Service"
    <operation   name="createStandardService"
          description="Create a new StandardService"
               impact="ACTION"
           returnType="java.lang.String">
      <parameter name="parent"
          description="MBean Name of the associated parent component"
                 type="java.lang.String"/>
      <parameter name="name"
          description="Unique name of this Service"
                 type="java.lang.String"/>
      <parameter name="domain"
          description="The domain of this Service"
                 type="java.lang.String"/>
    </operation>
    <operation   name="createSystemErrLogger"
          description="Create a new System Error Logger"
               impact="ACTION"
           returnType="java.lang.String">
      <parameter name="parent"
          description="MBean Name of the associated parent component"
                 type="java.lang.String"/>
    </operation>
    <operation   name="createSystemOutLogger"
          description="Create a new System Output Logger"
               impact="ACTION"
           returnType="java.lang.String">
      <parameter name="parent"
          description="MBean Name of the associated parent component"
                 type="java.lang.String"/>
    </operation>
    <operation   name="removeLogger"
          description="Remove an existing Logger"
               impact="ACTION"
           returnType="void">
      <parameter name="name"
          description="MBean Name of the component to be removed"
                 type="java.lang.String"/>
    </operation>

    public static final boolean USE_SECURE_RANDOM_FOR_UUID = false;

======= fetch "protected void doLoad() throws ClassNotFoundException, IOException {" bddfc0a^:"java/org/apache/catalina/session/StandardManager.java"

                    if (!session.isValidInternal()) {
                        // If session is already invalid,
                        // expire session to prevent memory leak.
                        session.setValid(true);
                        session.expire();
                    }

 * TODO SERVLET3 - Add comments
 * TODO SERVLET3 - Add comments
 * TODO SERVLET3 - Add comments
 * TODO SERVLET3 - Add comments
 * TODO SERVLET3 - Add comments
 * @since Servlet 3.0
 * TODO SERVLET3 - Add comments
 * TODO SERVLET3 - Add comments
 * TODO SERVLET3 - Add comments
 * @since Servlet 3.0
 * TODO SERVLET3 - Add comments

    public static char[][] specialCharactersRepresentation = new char[HIGHEST_SPECIAL + 1][];

======= fetch "protected String getDistinguishedName(DirContext context, String base," e59ba8f^:"java/org/apache/catalina/realm/JNDIRealm.java"

         final private List<String> roles;
======= fetch "public User(String username, String dn, String password," e59ba8f^:"java/org/apache/catalina/realm/JNDIRealm.java"

             this.roles = Collections.unmodifiableList(roles);

======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 155e3f8^:"java/org/apache/catalina/manager/ManagerServlet.java"

                    idle++;
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 155e3f8^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.sessiontimeout",
                                            "unlimited","" + notimeout));
======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 155e3f8^:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.sessiontimeout",
                                            "" + idle,"expired " + expired));

======= fetch "protected void init() {" 216352a^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            if (timeout < 0) {

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    /**
     * Mock {@link FilterChain} to keep a handle on the passed
     * {@link ServletRequest}.
     */
    public static class MockFilterChain implements FilterChain {
        private HttpServletRequest request;
        @Override
        public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {
            this.request = (HttpServletRequest) request;
        }
        public HttpServletRequest getRequest() {
            return request;
        }
    }
    public static class MockHttpServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        HttpServletRequest request;
        public HttpServletRequest getRequest() {
            return request;
        }
        @Override
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            this.request = request;
            PrintWriter writer = response.getWriter();
            writer.println("request.remoteAddr=" + request.getRemoteAddr());
            writer.println("request.remoteHost=" + request.getRemoteHost());
            writer.println("request.secure=" + request.isSecure());
            writer.println("request.scheme=" + request.getScheme());
            writer.println("request.serverPort=" + request.getServerPort());
            writer.println();
            for (Enumeration<String> headers = request.getHeaderNames(); headers.hasMoreElements();) {
                String name = headers.nextElement().toString();
                writer.println("request.header['" + name + "']=" + Collections.list(request.getHeaders(name)));
            }
        }
    }
    /**
     * Enhanced {@link Request} to ease testing.
     */
    public static class MockHttpServletRequest extends Request {
        public MockHttpServletRequest() {
            super();
            setCoyoteRequest(new org.apache.coyote.Request());
            setConnector(new Connector());
        }
        public void setHeader(String name, String value) {
            getCoyoteRequest().getMimeHeaders().setValue(name).setString(value);
        }
        public void setScheme(String scheme) {
            getCoyoteRequest().scheme().setString(scheme);
        }
    }
    public static final String TEMP_DIR = System.getProperty("java.io.tmpdir");
    public void testCommaDelimitedListToStringArray() {
        List<String> elements = Arrays.asList("element1", "element2", "element3");
        String actual = RemoteIpFilter.listToCommaDelimitedString(elements);
        assertEquals("element1, element2, element3", actual);
    }
    public void testCommaDelimitedListToStringArrayEmptyList() {
        List<String> elements = new ArrayList<String>();
        String actual = RemoteIpFilter.listToCommaDelimitedString(elements);
        assertEquals("", actual);
    }
    public void testCommaDelimitedListToStringArrayNullList() {
        String actual = RemoteIpFilter.listToCommaDelimitedString(null);
        assertEquals("", actual);
    }
    public void testHeaderNamesCaseInsensitivity() {
        RemoteIpFilter.XForwardedRequest request = new RemoteIpFilter.XForwardedRequest(new MockHttpServletRequest());
        request.setHeader("myheader", "lower Case");
        request.setHeader("MYHEADER", "UPPER CASE");
        request.setHeader("MyHeader", "Camel Case");
        assertEquals(1, request.headers.size());
        assertEquals("Camel Case", request.getHeader("myheader"));
    }
    public void testIncomingRequestIsSecuredButProtocolHeaderSaysItIsNotWithCustomValues() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("protocolHeader", "x-forwarded-proto");
        filterDef.addInitParameter("remoteIPHeader", "x-my-forwarded-for");
        filterDef.addInitParameter("httpServerPort", "8080");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setSecure(true);
        request.setScheme("https");
        request.setHeader("x-my-forwarded-for", "140.211.11.130");
        request.setHeader("x-forwarded-proto", "http");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        boolean actualSecure = actualRequest.isSecure();
        assertEquals("request must be unsecured as header x-forwarded-proto said it is http", false, actualSecure);
        String actualScheme = actualRequest.getScheme();
        assertEquals("scheme must be http as header x-forwarded-proto said it is http", "http", actualScheme);
        int actualServerPort = actualRequest.getServerPort();
        assertEquals("wrong http server port", 8080, actualServerPort);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
    }
    public void testIncomingRequestIsSecuredButProtocolHeaderSaysItIsNotWithDefaultValues() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("protocolHeader", "x-forwarded-proto");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setSecure(true);
        request.setScheme("https");
        request.setHeader("x-forwarded-for", "140.211.11.130");
        request.setHeader("x-forwarded-proto", "http");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        boolean actualSecure = actualRequest.isSecure();
        assertEquals("request must be unsecured as header x-forwarded-proto said it is http", false, actualSecure);
        String actualScheme = actualRequest.getScheme();
        assertEquals("scheme must be http as header x-forwarded-proto said it is http", "http", actualScheme);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
    }
    public void testInvokeAllowedRemoteAddrWithNullRemoteIpHeader() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("remote-host-original-value");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = request.getHeader("x-forwarded-for");
        assertNull("x-forwarded-for must be null", actualXForwardedFor);
        String actualXForwardedBy = request.getHeader("x-forwarded-by");
        assertNull("x-forwarded-by must be null", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "192.168.0.10", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "remote-host-original-value", actualRemoteHost);
    }
    public void testInvokeAllProxiesAreInternal() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("remote-host-original-value");
        request.setHeader("x-forwarded-for", "140.211.11.130, 192.168.0.10, 192.168.0.11");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for");
        assertNull("all proxies are internal, x-forwarded-for must be null", actualXForwardedFor);
        String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by");
        assertNull("all proxies are internal, x-forwarded-by must be null", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
    }
    public void testInvokeAllProxiesAreTrusted() throws Exception {
        // PREPARE
        RemoteIpFilter remoteIpFilter = new RemoteIpFilter();
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        filterDef.setFilter(remoteIpFilter);
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("remote-host-original-value");
        request.setHeader("x-forwarded-for", "140.211.11.130, proxy1, proxy2");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for");
        assertNull("all proxies are trusted, x-forwarded-for must be null", actualXForwardedFor);
        String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by");
        assertEquals("all proxies are trusted, they must appear in x-forwarded-by", "proxy1, proxy2", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
    }
    public void testInvokeAllProxiesAreTrustedAndRemoteAddrMatchRegexp() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "127\\.0\\.0\\.1, 192\\.168\\..*, another-internal-proxy");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("remote-host-original-value");
        request.setHeader("x-forwarded-for", "140.211.11.130, proxy1, proxy2");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for");
        assertNull("all proxies are trusted, x-forwarded-for must be null", actualXForwardedFor);
        String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by");
        assertEquals("all proxies are trusted, they must appear in x-forwarded-by", "proxy1, proxy2", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
    }
    public void testInvokeAllProxiesAreTrustedOrInternal() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("remote-host-original-value");
        request.setHeader("x-forwarded-for", "140.211.11.130, proxy1, proxy2, 192.168.0.10, 192.168.0.11");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for");
        assertNull("all proxies are trusted, x-forwarded-for must be null", actualXForwardedFor);
        String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by");
        assertEquals("all proxies are trusted, they must appear in x-forwarded-by", "proxy1, proxy2", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
    }
    public void testInvokeNotAllowedRemoteAddr() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("not-allowed-internal-proxy");
        request.setRemoteHost("not-allowed-internal-proxy-host");
        request.setHeader("x-forwarded-for", "140.211.11.130, proxy1, proxy2");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for");
        assertEquals("x-forwarded-for must be unchanged", "140.211.11.130, proxy1, proxy2", actualXForwardedFor);
        String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by");
        assertNull("x-forwarded-by must be null", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "not-allowed-internal-proxy", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "not-allowed-internal-proxy-host", actualRemoteHost);
    }
    public void testInvokeUntrustedProxyInTheChain() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("remote-host-original-value");
        request.setHeader("x-forwarded-for", "140.211.11.130, proxy1, untrusted-proxy, proxy2");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for");
        assertEquals("ip/host before untrusted-proxy must appear in x-forwarded-for", "140.211.11.130, proxy1", actualXForwardedFor);
        String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by");
        assertEquals("ip/host after untrusted-proxy must appear in  x-forwarded-by", "proxy2", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "untrusted-proxy", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "untrusted-proxy", actualRemoteHost);
    }
    public void testListToCommaDelimitedString() {
        String[] actual = RemoteIpFilter.commaDelimitedListToStringArray("element1, element2, element3");
        String[] expected = new String[] { "element1", "element2", "element3" };
        assertEquals(expected.length, actual.length);
        for (int i = 0; i < actual.length; i++) {
            assertEquals(expected[i], actual[i]);
        }
    }
    public void testListToCommaDelimitedStringMixedSpaceChars() {
        String[] actual = RemoteIpFilter.commaDelimitedListToStringArray("element1  , element2,\t element3");
        String[] expected = new String[] { "element1", "element2", "element3" };
        assertEquals(expected.length, actual.length);
        for (int i = 0; i < actual.length; i++) {
            assertEquals(expected[i], actual[i]);
        }
    }
    private HttpServletRequest testRemoteIpFilter(FilterDef filterDef, Request request) throws LifecycleException, IOException,
            ServletException {
        Tomcat tomcat = getTomcatInstance();
        Context root = tomcat.addContext("", TEMP_DIR);
        RemoteIpFilter remoteIpFilter = new RemoteIpFilter();
        filterDef.setFilterClass(RemoteIpFilter.class.getName());
        filterDef.setFilter(remoteIpFilter);
        filterDef.setFilterName(RemoteIpFilter.class.getName());
        root.addFilterDef(filterDef);
        FilterMap filterMap = new FilterMap();
        filterMap.setFilterName(RemoteIpFilter.class.getName());
        filterMap.addURLPattern("*");
        root.addFilterMap(filterMap);
        getTomcatInstance().start();
        MockFilterChain filterChain = new MockFilterChain();
        // TEST
        remoteIpFilter.doFilter(request, new Response(), filterChain);
        return filterChain.getRequest();
    }
    /**
     * Test {@link RemoteIpFilter} in Tomcat standalone server
     */
    public void testWithTomcatServer() throws Exception {
        // mostly default configuration : enable "x-forwarded-proto"
        Map<String, String> remoteIpFilterParameter = new HashMap<String, String>();
        remoteIpFilterParameter.put("protocolHeader", "x-forwarded-proto");
        // SETUP
        Tomcat tomcat = getTomcatInstance();
        Context root = tomcat.addContext("", TEMP_DIR);
        FilterDef filterDef = new FilterDef();
        filterDef.getParameterMap().putAll(remoteIpFilterParameter);
        filterDef.setFilterClass(RemoteIpFilter.class.getName());
        filterDef.setFilterName(RemoteIpFilter.class.getName());
        root.addFilterDef(filterDef);
        FilterMap filterMap = new FilterMap();
        filterMap.setFilterName(RemoteIpFilter.class.getName());
        filterMap.addURLPattern("*");
        root.addFilterMap(filterMap);
        MockHttpServlet mockServlet = new MockHttpServlet();
        Tomcat.addServlet(root, mockServlet.getClass().getName(), mockServlet);
        root.addServletMapping("/test", mockServlet.getClass().getName());
        getTomcatInstance().start();
        // TEST
        HttpURLConnection httpURLConnection = (HttpURLConnection) new URL("http://localhost:" + tomcat.getConnector().getPort() + "/test")
                .openConnection();
        String expectedRemoteAddr = "my-remote-addr";
        httpURLConnection.addRequestProperty("x-forwarded-for", expectedRemoteAddr);
        httpURLConnection.addRequestProperty("x-forwarded-proto", "https");
        // VALIDATE
        Assert.assertEquals(HttpURLConnection.HTTP_OK, httpURLConnection.getResponseCode());
        HttpServletRequest request = mockServlet.getRequest();
        Assert.assertNotNull(request);
        // VALIDATE X-FOWARDED-FOR
        Assert.assertEquals(expectedRemoteAddr, request.getRemoteAddr());
        Assert.assertEquals(expectedRemoteAddr, request.getRemoteHost());
        // VALIDATE X-FORWARDED-PROTO
        Assert.assertTrue(request.isSecure());
        Assert.assertEquals("https", request.getScheme());
        Assert.assertEquals(443, request.getServerPort());
    }

======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 9a42719^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            if (log.isDebugEnabled()) {
                log.debug("Skip RemoteIpFilter for request " + request.getRequestURI() + " with originalRemoteAddr '"
                        + request.getRemoteAddr() + "'");
            }
======= fetch "public void invoke(Request request, Response response) throws IOException, Servl" 9a42719^:"java/org/apache/catalina/valves/RemoteIpValve.java"

        } else {
            if (log.isDebugEnabled()) {
                log.debug("Skip RemoteIpValve for request " + request.getRequestURI() + " with originalRemoteAddr '"
                        + request.getRemoteAddr() + "'");
            }

======= fetch "public StandardContext() {" ae6fcf5^:"java/org/apache/catalina/core/StandardContext.java"

    
    /**
     * Should Tomcat attempt to clear any ThreadLocal objects that are instances
     * of classes loaded by this class loader. Failure to remove any such
     * objects will result in a memory leak on web application stop, undeploy or
     * reload. It is disabled by default since the clearing of the ThreadLocal
     * objects is not performed in a thread-safe manner.
     */
    private boolean clearReferencesThreadLocals = false;
    
======= fetch "public void setClearReferencesStopThreads(" ae6fcf5^:"java/org/apache/catalina/core/StandardContext.java"

     * Return the clearReferencesThreadLocals flag for this Context.
     */
    public boolean getClearReferencesThreadLocals() {
        return (this.clearReferencesThreadLocals);
    }
    /**
     * Set the clearReferencesStopThreads feature for this Context.
     *
     * @param clearReferencesStopThreads The new flag value
     */
    public void setClearReferencesThreadLocals(
            boolean clearReferencesThreadLocals) {
        boolean oldClearReferencesThreadLocals =
            this.clearReferencesThreadLocals;
        this.clearReferencesThreadLocals = clearReferencesThreadLocals;
        support.firePropertyChange("clearReferencesStopThreads",
                                   oldClearReferencesThreadLocals,
                                   this.clearReferencesThreadLocals);
    }
    /**
======= fetch "protected boolean removeEldestEntry(" ae6fcf5^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * Should Tomcat attempt to clear any ThreadLocal objects that are instances
     * of classes loaded by this class loader. Failure to remove any such
     * objects will result in a memory leak on web application stop, undeploy or
     * reload. It is disabled by default since the clearing of the ThreadLocal
     * objects is not performed in a thread-safe manner.
     */
    private boolean clearReferencesThreadLocals = false;
    
    /**
======= fetch "public boolean getClearReferencesLogFactoryRelease() {" ae6fcf5^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     /**
      * Return the clearReferencesThreadLocals flag for this Context.
      */
     public boolean getClearReferencesThreadLocals() {
         return (this.clearReferencesThreadLocals);
     }
     /**
      * Set the clearReferencesThreadLocals feature for this Context.
      *
      * @param clearReferencesThreadLocals The new flag value
      */
     public void setClearReferencesThreadLocals(
             boolean clearReferencesThreadLocals) {
         this.clearReferencesThreadLocals = clearReferencesThreadLocals;
     }
======= fetch "private void clearThreadLocalMap(Object map, Field internalTableField)" ae6fcf5^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                    if (clearReferencesThreadLocals) {
                                        log.debug(sm.getString(
                                                "webappClassLoader.clearThreadLocalDebugClear"));
                                    }
======= fetch "private void clearThreadLocalMap(Object map, Field internalTableField)" ae6fcf5^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                if (clearReferencesThreadLocals) {
                                    log.info(sm.getString(
                                            "webappClassLoader.clearThreadLocalClear"));
                                }
======= fetch "private void clearThreadLocalMap(Object map, Field internalTableField)" ae6fcf5^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                            if (key == null) {
                              staleEntriesCount++;
                            } else {
                              mapRemove.invoke(map, key);
======= fetch "protected void startInternal() throws LifecycleException {" ae6fcf5^:"java/org/apache/catalina/loader/WebappLoader.java"

                classLoader.setClearReferencesThreadLocals(
                        ((StandardContext) container).getClearReferencesThreadLocals());
      <attribute name="clearReferencesThreadLocals" required="false">
        <p>If <code>true</code>, Tomcat attempts to clear any ThreadLocal
        objects that are instances of classes loaded by this class loader.
        Failure to remove any such objects will result in a memory leak on web
        application stop, undeploy or reload.  If not specified, the default
        value of <code>false</code> will be used since the clearing of the
        ThreadLocal objects is not performed in a thread-safe manner.</p>
      </attribute>

======= fetch "protected void deserializeSessions(byte[] data) throws ClassNotFoundException,IO" 39d3082^:"java/org/apache/catalina/ha/session/DeltaManager.java"

                if (notifySessionListenersOnReplication) {
                    session.tellNew();
                }

     * Return the path to a file to save this Context information.
    public String getConfigFile();
     * Set the path to a file to save this Context information.
     * @param configFile The path to a file to save this Context information.
    public void setConfigFile(String configFile);
======= fetch "public StandardContext() {" 83226d9^:"java/org/apache/catalina/core/StandardContext.java"

     * The path to a file to save this Context information.
======= fetch "public StandardContext() {" 83226d9^:"java/org/apache/catalina/core/StandardContext.java"

    private String configFile = null;
======= fetch "public void setCharsetMapper(CharsetMapper mapper) {" 83226d9^:"java/org/apache/catalina/core/StandardContext.java"

     * Return the path to a file to save this Context information.
======= fetch "public void setCharsetMapper(CharsetMapper mapper) {" 83226d9^:"java/org/apache/catalina/core/StandardContext.java"

    public String getConfigFile() {
======= fetch "public String getConfigFile() {" 83226d9^:"java/org/apache/catalina/core/StandardContext.java"

     * Set the path to a file to save this Context information.
======= fetch "public String getConfigFile() {" 83226d9^:"java/org/apache/catalina/core/StandardContext.java"

     * @param configFile The path to a file to save this Context information.
======= fetch "public String getConfigFile() {" 83226d9^:"java/org/apache/catalina/core/StandardContext.java"

    public void setConfigFile(String configFile) {
======= fetch "public StandardHost() {" 83226d9^:"java/org/apache/catalina/core/StandardHost.java"

     * Should XML files be copied to $CATALINA_BASE/conf/<engine>/<host> by
     * default when a web application is deployed?
     */
    private boolean copyXML = false;
    /**
======= fetch "public void setDeployXML(boolean deployXML) {" 83226d9^:"java/org/apache/catalina/core/StandardHost.java"

     * Return the copy XML config file flag for this component.
     */
    public boolean isCopyXML() {
        return (this.copyXML);
    }
    /**
     * Set the copy XML config file flag for this component.
     *
     * @param copyXML The new copy XML flag
     */
    public void setCopyXML(boolean copyXML) {
        this.copyXML= copyXML;
    }
    
    
    /**
======= fetch "public String createStandardContext(String parent," 83226d9^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

            context.setConfigFile(configFile.getAbsolutePath());
======= fetch "protected void contextConfig() {" 83226d9^:"java/org/apache/catalina/startup/ContextConfig.java"

            processContextConfig(new File(getBaseDir()), defaultContextXml);
            processContextConfig(getConfigBase(), getHostConfigPath(Constants.HostContextXml));
======= fetch "protected void contextConfig() {" 83226d9^:"java/org/apache/catalina/startup/ContextConfig.java"

            processContextConfig(new File(context.getConfigFile()), null);
======= fetch "protected void contextConfig() {" 83226d9^:"java/org/apache/catalina/startup/ContextConfig.java"

    protected void processContextConfig(File baseDir, String resourceName) {
======= fetch "protected void processContextConfig(File baseDir, String resourceName) {" 83226d9^:"java/org/apache/catalina/startup/ContextConfig.java"

                    + "] configuration file " + baseDir + " " + resourceName);
======= fetch "protected void processContextConfig(File baseDir, String resourceName) {" 83226d9^:"java/org/apache/catalina/startup/ContextConfig.java"

        File file = baseDir;
        if (resourceName != null) {
            file = new File(baseDir, resourceName);
        }
        
======= fetch "protected void processContextConfig(File baseDir, String resourceName) {" 83226d9^:"java/org/apache/catalina/startup/ContextConfig.java"

            if ( !file.exists() ) {
                if (resourceName != null) {
                    // Use getResource and getResourceAsStream
                    stream = getClass().getClassLoader()
                        .getResourceAsStream(resourceName);
                    if( stream != null ) {
                        source = new InputSource
                            (getClass().getClassLoader()
                            .getResource(resourceName).toString());
                    }
                }
            } else {
                source =
                    new InputSource("file://" + file.getAbsolutePath());
                stream = new FileInputStream(file);
                // Add as watched resource so that cascade reload occurs if a default
                // config file is modified/added/removed
                context.addWatchedResource(file.getAbsolutePath());
======= fetch "protected void processContextConfig(File baseDir, String resourceName) {" 83226d9^:"java/org/apache/catalina/startup/ContextConfig.java"

                      resourceName + " " + file) , e);
======= fetch "protected void processContextConfig(File baseDir, String resourceName) {" 83226d9^:"java/org/apache/catalina/startup/ContextConfig.java"

                            + "] configuration file " + baseDir + " " + resourceName);
======= fetch "public void setDeployXML(boolean deployXML) {" 83226d9^:"java/org/apache/catalina/startup/HostConfig.java"

     * Return the copy XML config file flag for this component.
     */
    public boolean isCopyXML() {
        return (this.copyXML);
    }
    /**
     * Set the copy XML config file flag for this component.
     *
     * @param copyXML The new copy XML flag
     */
    public void setCopyXML(boolean copyXML) {
        this.copyXML= copyXML;
    }
    /**
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 83226d9^:"java/org/apache/catalina/startup/HostConfig.java"

                setCopyXML(((StandardHost) host).isCopyXML());
======= fetch "protected void deployDescriptor(String contextPath, File contextXml, String file" 83226d9^:"java/org/apache/catalina/startup/HostConfig.java"

            context.setConfigFile(contextXml.getAbsolutePath());
======= fetch "protected void deployWAR(String contextPath, File war, String file) {" 83226d9^:"java/org/apache/catalina/startup/HostConfig.java"

        boolean xmlInWar = false;
        
======= fetch "protected void deployWAR(String contextPath, File war, String file) {" 83226d9^:"java/org/apache/catalina/startup/HostConfig.java"

                    xmlInWar = true;
                }
                if (copyXML) {
======= fetch "protected void deployWAR(String contextPath, File war, String file) {" 83226d9^:"java/org/apache/catalina/startup/HostConfig.java"

                context.setConfigFile(xml.getAbsolutePath());
======= fetch "protected void deployDirectory(String contextPath, File dir, String file) {" 83226d9^:"java/org/apache/catalina/startup/HostConfig.java"

                // Will only do this on initial deployment. On subsequent
                // deployments the copied xml file means we'll use
                // deployDescriptor() instead
======= fetch "protected void deployDirectory(String contextPath, File dir, String file) {" 83226d9^:"java/org/apache/catalina/startup/HostConfig.java"

                xmlCopy = new File(configBase(), file + ".xml");
                InputStream is = null;
                OutputStream os = null;
                try {
                    is = new FileInputStream(xml);
                    os = new FileOutputStream(xmlCopy);
                    IOTools.flow(is, os);
                    // Don't catch IOE - let the outer try/catch handle it
                } finally {
                    try {
                        if (is != null) is.close();
                    } catch (IOException e){
                        // Ignore
                    }
======= fetch "protected void deployDirectory(String contextPath, File dir, String file) {" 83226d9^:"java/org/apache/catalina/startup/HostConfig.java"

                        if (os != null) os.close();
                    } catch (IOException e){
                        // Ignore
======= fetch "protected void deployDirectory(String contextPath, File dir, String file) {" 83226d9^:"java/org/apache/catalina/startup/HostConfig.java"

                    context.setConfigFile(xmlCopy.toURI().toURL());
                } else {
                    context.setConfigFile(xml.toURI().toURL());
======= fetch "protected void deployDirectory(String contextPath, File dir, String file) {" 83226d9^:"java/org/apache/catalina/startup/HostConfig.java"

                context.setConfigFile(xmlCopy.getAbsolutePath());
        absolute pathname for this directory, or a pathname that is relative
        to the <code>$CATALINA_BASE</code> directory.  See
        deployment of web applications to be deployed automatically. If not
        specified, the default of <code>webapps</code> will be used.</p>
        This is the pathname of a directory that may contain context XML descriptors
        to be deployed on this virtual host.  You may specify an
        deployment of web applications to be deployed automatically.</p>
        <p>If set to true, Tomcat will attempt to create the directories defined by the 
        attributes <code>appBase</code> and <code>xmlBase</code> during the startup phase.
        The default value is <code>true</code>.
        If set to true, and directory creation fails, an error message will be printed out but will not halt 
        the startup sequence.</p>
        <p>This flag value indicates if new web applications, dropped in to
        the <code>appBase</code> directory while Tomcat is running, should
        be automatically deployed.  The flag's value defaults to true.  See
        be automatically deployed by the host configurator.
        The flag's value defaults to true.  See
        <p>Set to <code>false</code> if you want to disable parsing the context.xml
        file embedded inside the application (located at <code>/META-INF/context.xml</code>). 
        Security conscious environments should set this to <code>false</code> to prevent
        applications from interacting with the container's configuration. The 
        administrator will then be responsible for providing an external context 
        configuration file, and put it in 
        <code>$CATALINA_BASE/conf/[enginename]/[hostname]/</code> unless the attribute <code>xmlBase</code> is specified.
        The flag's value defaults to <code>true</code>.</p>
        from a WAR file.  See
       <code>org.apache.catalina.core.ContainerBase.[enginename].[hostname]</code>
    <li>Any XML file in the 
        <code>$CATALINA_BASE/conf/[engine_name]/[host_name]</code> directory is
        assumed to contain a
        subelements) for a single web application.  The <code>docBase</code>
        attribute of this <code>&lt;Context&gt;</code> element will typically
        be the absolute pathname to a web application directory, or the
        absolute pathname of a web application archive (WAR) file (which
        will not be expanded). The path attribute will be automatically set
        as defined in the <a href="context.html">Context</a> documentation.</li>
    <li>Any web application archive file within the application base (appBase)
        directory that does not have a corresponding
        directory of the same name (without the ".war" extension) will be
        automatically expanded, unless the <code>unpackWARs</code> property
        is set to <code>false</code>.  If you redeploy an updated WAR file,
        be sure to delete the expanded directory when restarting Tomcat, so
        that the updated WAR file will be re-expanded (note that the auto
        deployer, if enabled, will automatically expand the updated WAR file
        once the previously expanded directory is removed). Multi-level contexts
        may be defined by using #, e.g. use a WAR named <code>foo#bar.war</code>
        for a context path of <code>/foo/bar</code>.</li>
    <li>Any subdirectory within the <em>application base directory</em>
        will receive an automatically generated <a href="context.html">
        Context</a> element, even if this directory is not mentioned in the
        <code>conf/server.xml</code> file. The context path for this
        deployed Context will be a slash character ("/") followed by the
        directory name, unless the directory name is ROOT, in which case
        the context path will be an empty string (""). Multi-level contexts
        may be defined by using #, e.g. use a directory named <code>foo#bar</code>
        for a context path of <code>/foo/bar</code>.</li>
    subdirectories that are dropped in to the <code>appBase</code> (or 
    <code>$CATALINA_BASE/conf/[engine_name]/[host_name]</code> in the case of
    an XML configuration file) directory while Tomcat is running will be
    automatically deployed, according to the rules described above. The 
    auto deployer will also track web applications for the following changes:
    <p>Finally, note that if you are defining contexts explicitly, you should
    probably turn off automatic application deployment.  Otherwise, your context
    will be deployed twice each, and that may cause problems for your app.

======= fetch "public void sendMessage(ChannelMessage message, Member[] destination) throws Cha" fc66705^:"java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java"

        try {
            sender.sendMessage(destination,message);
        }catch (ChannelException x) {
            sender.disconnect();
            throw x;
        }
======= fetch "public void sendMessage(Member[] destination, ChannelMessage message) throws Cha" fc66705^:"java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java"

            } catch (ChannelException x) {
                sender.disconnect();
                throw x;
======= fetch "public void sendMessage(Member[] destination, ChannelMessage message) throws Cha" fc66705^:"java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java"

                if (!connected) disconnect();
======= fetch "public void sendMessage(Member[] destination, ChannelMessage message) throws Cha" fc66705^:"java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java"

                if (!connected) disconnect();

======= fetch "public void write(int c) throws IOException {" 9113574^:"java/org/apache/jasper/runtime/JspWriterImpl.java"

    private int min(int a, int b) {

======= fetch "protected File file(String name) {" f1760d8^:"java/org/apache/naming/resources/FileDirContext.java"

     * This specialized resource implementation avoids opening the IputStream
======= fetch "public InputStream streamContent()" f1760d8^:"java/org/apache/naming/resources/FileDirContext.java"

                inputStream = new FileInputStream(file);
======= fetch "public InputStream streamContent()" f1760d8^:"java/org/apache/naming/resources/WARDirContext.java"

                    inputStream = base.getInputStream(entry);

======= fetch "public URL getResource(String res) throws MalformedURLException {" 6ac5036^:"java/org/apache/jasper/JspCompilationContext.java"

            } else {
                // May not be in a JAR in some IDE environments
                result = context.getResource(canonicalURI(res));

======= fetch "protected boolean bindAsUser(DirContext context," 4cf35b8^:"java/org/apache/catalina/realm/JNDIRealm.java"

        return new ArrayList<String>(groupMap.values());

======= fetch "protected boolean custom(Request request, Response response," 1ec5ca7^:"java/org/apache/catalina/core/StandardHostValve.java"

            // Reset the response (keeping the real error code and message)
            response.resetBuffer(true);
======= fetch "protected boolean custom(Request request, Response response," 1ec5ca7^:"java/org/apache/catalina/core/StandardHostValve.java"

            rd.forward(request.getRequest(), response.getResponse());
======= fetch "protected boolean custom(Request request, Response response," 1ec5ca7^:"java/org/apache/catalina/core/StandardHostValve.java"

            // If we forward, the response is suspended again
            response.setSuspended(false);

======= fetch "public ServletContext getServletContext() {" 7301a10^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        return config.getServletContext();

======= fetch "public static void securityClassLoad(ClassLoader loader){" 9e55819^:"java/org/apache/jasper/security/SecurityClassLoad.java"

            // Trigger loading of class and reading of property
            SecurityUtil.isPackageProtectionEnabled();
            

======= fetch "public JavacErrorDetail(String javaFileName," 789ac1e^:"java/org/apache/jasper/compiler/JavacErrorDetail.java"

                if (jspLines.length < jspBeginLineNum) {
                    // Avoid ArrayIndexOutOfBoundsException
                    // Probably bug 48494 but could be some other cause
                    jspExtract = Localizer.getMessage("jsp.error.bug48494");
                    return;
                }
                

  <!--                        globalXsltFile[null]                          -->
    protected String  localXsltFile = null;
    protected String  globalXsltFile = null;
======= fetch "public void init() throws ServletException {" 0e595cf^:"java/org/apache/catalina/servlets/DefaultServlet.java"

        contextXsltFile = getServletConfig().getInitParameter("contextXsltFile");
======= fetch "protected InputStream renderXml(String contextPath," 0e595cf^:"java/org/apache/catalina/servlets/DefaultServlet.java"

                if ((cacheEntry.name + trimmed).equals(contextXsltFile))
                    continue;
======= fetch "protected InputStream findXsltInputStream(DirContext directory)" 0e595cf^:"java/org/apache/catalina/servlets/DefaultServlet.java"

                return null;
======= fetch "protected InputStream findXsltInputStream(DirContext directory)" 0e595cf^:"java/org/apache/catalina/servlets/DefaultServlet.java"

        This can be disabled by per webapp by also declaring the
        default servlet in your local webapp's web.xml. The format
        of the xml is shown below.
        This overrides <code>globalXsltFile</code>. If this value
        is present but a file does not exist, then

    protected static final String[] insertBefore =
    { "</web-app>", "<servlet-mapping>", "<session-config>",
      "<mime-mapping>", "<welcome-file-list>", "<error-page>", "<taglib>",
      "<resource-env-ref>", "<resource-ref>", "<security-constraint>",
      "<login-config>", "<security-role>", "<env-entry>", "<ejb-ref>",
      "<ejb-local-ref>" };
======= fetch "protected void mergeIntoWebXml() throws IOException {" 563e315^:"java/org/apache/jasper/JspC.java"

        int pos = -1;
        String line = null;
        while (true) {
            line = reader.readLine();
            if (line == null) {
                break;
            }
            // Skip anything previously generated by JSPC
            if (line.indexOf(insertStartMarker) >= 0) {
                while (true) {
                    line = reader.readLine();
                    if (line == null) {
                        return;
                    }
                    if (line.indexOf(insertEndMarker) >= 0) {
                        line = reader.readLine();
                        line = reader.readLine();
======= fetch "protected void mergeIntoWebXml() throws IOException {" 563e315^:"java/org/apache/jasper/JspC.java"

                            return;
======= fetch "protected void mergeIntoWebXml() throws IOException {" 563e315^:"java/org/apache/jasper/JspC.java"

                        break;
======= fetch "protected void mergeIntoWebXml() throws IOException {" 563e315^:"java/org/apache/jasper/JspC.java"

                    writer.println(insertEndMarker);
                    writer.println();
                    writer.write(element);
                } else if (element.contains(insertStartMarker)) {
                    // Skip the previous auto-generated content
                    while (!element.contains(insertEndMarker)) {
                        element = getElement(reader);
                    }
                } else {
                    writer.write(element);
======= fetch "protected void mergeIntoWebXml() throws IOException {" 563e315^:"java/org/apache/jasper/JspC.java"

            }
            for (int i = 0; i < insertBefore.length; i++) {
                pos = line.indexOf(insertBefore[i]);
                if (pos >= 0)
                    break;
            }
            if (pos >= 0) {
                writer.print(line.substring(0, pos));
                break;
======= fetch "protected void mergeIntoWebXml() throws IOException {" 563e315^:"java/org/apache/jasper/JspC.java"

                writer.println(line);
======= fetch "protected void mergeIntoWebXml() throws IOException {" 563e315^:"java/org/apache/jasper/JspC.java"

        }
        writer.println(insertStartMarker);
        while (true) {
            String line2 = fragmentReader.readLine();
            if (line2 == null) {
                writer.println();
                break;
            }
            writer.println(line2);
        }
        writer.println(insertEndMarker);
        writer.println();
        for (int i = 0; i < pos; i++) {
            writer.print(" ");
        }
        writer.println(line.substring(pos));
        while (true) {
            line = reader.readLine();
            if (line == null) {
                break;
            }
            writer.println(line);
======= fetch "protected void mergeIntoWebXml() throws IOException {" 563e315^:"java/org/apache/jasper/JspC.java"

    
    /*
     * Assumes valid xml
     */
    private String getElement(Reader reader) throws IOException {
        StringBuilder result = new StringBuilder();
        result.append('<');
        
        boolean done = false;
        
        while (!done) {
            int current = reader.read();
            while (current != '>') {
                result.append((char) current);
                current = reader.read();
            }
            result.append((char) current);
            
            int len = result.length();
            if (len > 7 && result.substring(0, 4).equals("<!--")) {
                // This is a comment - make sure we are at the end
                if (result.substring(len - 3, len).equals("-->")) {
                    done = true;
                }
            } else {
                done = true;
            }
        }
        
        
        return result.toString();
    }

======= fetch "private void parseProperties(HttpServletRequest req," da42e44^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if (!cacheEntry.exists) {
        	// File is in directory listing but doesn't appear to exist
        	// Broken symlink or odd permission settings?
        	return;
        }

======= fetch "public void execute(String command, InputStream istream," 53e0674^:"java/org/apache/catalina/ant/AbstractCatalinaTask.java"

                    
                    hconn.setFixedLengthStreamingMode(contentLength);
======= fetch "public void execute() throws BuildException {" 53e0674^:"java/org/apache/catalina/ant/DeployTask.java"

                    stream = new BufferedInputStream
                        (new FileInputStream(war), 1024);

    private static JspFactory deflt = null;
======= fetch "public JspFactory() {" c09753b^:"java/javax/servlet/jsp/JspFactory.java"

    public static synchronized void setDefaultFactory(JspFactory deflt) {
======= fetch "public static synchronized void setDefaultFactory(JspFactory deflt) {" c09753b^:"java/javax/servlet/jsp/JspFactory.java"

    public static synchronized JspFactory getDefaultFactory() {

======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            if (!openJARs()) {
                return null;
            }
            for (i = 0; (entry == null) && (i < jarFilesLength); i++) {
                jarEntry = jarFiles[i].getJarEntry(path);
                if (jarEntry != null) {
                    entry = new ResourceEntry();
                    try {
                        entry.codeBase = getURL(jarRealFiles[i], false);
                        String jarFakeUrl = getURI(jarRealFiles[i]).toString();
                        jarFakeUrl = "jar:" + jarFakeUrl + "!/" + path;
                        entry.source = new URL(jarFakeUrl);
                        entry.lastModified = jarRealFiles[i].lastModified();
                    } catch (MalformedURLException e) {
                        return null;
                    }
                    contentLength = (int) jarEntry.getSize();
                    try {
                        entry.manifest = jarFiles[i].getManifest();
                        binaryStream = jarFiles[i].getInputStream(jarEntry);
                    } catch (IOException e) {
                        return null;
                    }
                    // Extract resources contained in JAR to the workdir
                    if (antiJARLocking && !(path.endsWith(".class"))) {
                        byte[] buf = new byte[1024];
                        File resourceFile = new File
                            (loaderDir, jarEntry.getName());
                        if (!resourceFile.exists()) {
                            Enumeration<JarEntry> entries =
                                jarFiles[i].entries();
                            while (entries.hasMoreElements()) {
                                JarEntry jarEntry2 =  entries.nextElement();
                                if (!(jarEntry2.isDirectory()) 
                                    && (!jarEntry2.getName().endsWith
                                        (".class"))) {
                                    resourceFile = new File
                                        (loaderDir, jarEntry2.getName());
                                    try {
                                        if (!resourceFile.getCanonicalPath().startsWith(
                                                canonicalLoaderDir)) {
                                            throw new IllegalArgumentException(
                                                    sm.getString("webappClassLoader.illegalJarPath",
                                                jarEntry2.getName()));
                                        }
                                    } catch (IOException ioe) {
                                        throw new IllegalArgumentException(
                                                sm.getString("webappClassLoader.validationErrorJarPath",
                                                        jarEntry2.getName()), ioe);
                                    }                                 
                                    resourceFile.getParentFile().mkdirs();
                                    FileOutputStream os = null;
                                    InputStream is = null;
                                    try {
                                        is = jarFiles[i].getInputStream
                                            (jarEntry2);
                                        os = new FileOutputStream
                                            (resourceFile);
                                        while (true) {
                                            int n = is.read(buf);
                                            if (n <= 0) {
                                                break;
                                            }
                                            os.write(buf, 0, n);
                                        }
                                    } catch (IOException e) {
                                        // Ignore
                                    } finally {
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                            if (is != null) {
                                                is.close();
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                        } catch (IOException e) {
                                        }
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                            if (os != null) {
                                                os.close();
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                            // Ignore
                                        } finally {
                                            try {
                                                if (is != null) {
                                                    is.close();
                                                }
                                            } catch (IOException e) {
                                            }
                                            try {
                                                if (os != null) {
                                                    os.close();
                                                }
                                            } catch (IOException e) {
                                            }
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

    
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                }
            }
            if (entry == null) {
                synchronized (notFoundResources) {
                    notFoundResources.put(name, name);
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                return null;
            }
            if (binaryStream != null) {
                byte[] binaryContent = new byte[contentLength];
                int pos = 0;
                try {
                    while (true) {
                        int n = binaryStream.read(binaryContent, pos,
                                                  binaryContent.length - pos);
                        if (n <= 0)
                            break;
                        pos += n;
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                } catch (IOException e) {
                    log.error(sm.getString("webappClassLoader.readError", name), e);
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                } finally {
                    try {
                        binaryStream.close();
                    } catch (IOException e) {}
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                if (fileNeedConvert) {
                    // Workaround for certain files on platforms that use
                    // EBCDIC encoding, when they are read through FileInputStream.
                    // See commit message of rev.303915 for details
                    // http://svn.apache.org/viewvc?view=revision&revision=303915
                    String str = new String(binaryContent,0,pos);
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                        binaryContent = str.getBytes("UTF-8");
                    } catch (Exception e) {
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                    if (fileNeedConvert) {
                        // Workaround for certain files on platforms that use
                        // EBCDIC encoding, when they are read through FileInputStream.
                        // See commit message of rev.303915 for details
                        // http://svn.apache.org/viewvc?view=revision&revision=303915
                        String str = new String(binaryContent,0,pos);
                        try {
                            binaryContent = str.getBytes("UTF-8");
                        } catch (Exception e) {
                            return null;
                        }
                    }
                    entry.binaryContent = binaryContent;
    
                    // The certificates are only available after the JarEntry 
                    // associated input stream has been fully read
                    if (jarEntry != null) {
                        entry.certificates = jarEntry.getCertificates();
                    }
    
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                entry.binaryContent = binaryContent;
                // The certificates are only available after the JarEntry 
                // associated input stream has been fully read
                if (jarEntry != null) {
                    entry.certificates = jarEntry.getCertificates();
======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

======= fetch "protected ResourceEntry findResourceInternal(String name, String path) {" dda2cbc^:"java/org/apache/catalina/loader/WebappClassLoader.java"


 *   className="org.apache.catalina.connector.RemoteIpValve"
 *   className="org.apache.catalina.connector.RemoteIpValve"
 *   className="org.apache.catalina.connector.RemoteIpValve"
 *   className="org.apache.catalina.connector.RemoteIpValve"
    private static final String info = "org.apache.catalina.connector.RemoteIpValve/1.0";

======= fetch "public Session load(String id)" 6f48cde^:"java/org/apache/catalina/session/FileStore.java"

        BufferedInputStream bis = null;
======= fetch "public Session load(String id)" 6f48cde^:"java/org/apache/catalina/session/FileStore.java"

            BufferedInputStream bis = new BufferedInputStream(fis);
======= fetch "public Session load(String id)" 6f48cde^:"java/org/apache/catalina/session/FileStore.java"

            if (ois != null) {
======= fetch "public Session load(String id)" 6f48cde^:"java/org/apache/catalina/session/FileStore.java"

                    ois.close();
======= fetch "public Session load(String id)" 6f48cde^:"java/org/apache/catalina/session/FileStore.java"

                ois = null;
======= fetch "public Session load(String id)" 6f48cde^:"java/org/apache/catalina/session/FileStore.java"

            if (ois != null) {
                try {
                    ois.close();
                } catch (IOException f) {
                    // Ignore
                }
======= fetch "public void save(Session session) throws IOException {" 6f48cde^:"java/org/apache/catalina/session/FileStore.java"

            if (oos != null) {
======= fetch "public void save(Session session) throws IOException {" 6f48cde^:"java/org/apache/catalina/session/FileStore.java"

                    oos.close();
======= fetch "protected void doLoad() throws ClassNotFoundException, IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

        BufferedInputStream bis = null;
======= fetch "protected void doLoad() throws ClassNotFoundException, IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

            BufferedInputStream bis = new BufferedInputStream(fis);
======= fetch "protected void doLoad() throws ClassNotFoundException, IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

            if (ois != null) {
======= fetch "protected void doLoad() throws ClassNotFoundException, IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

                    ois.close();
======= fetch "protected void doLoad() throws ClassNotFoundException, IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

                ois = null;
======= fetch "protected void doLoad() throws ClassNotFoundException, IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

                if (ois != null) {
                    try {
                        ois.close();
                    } catch (IOException f) {
                        // Ignore
                    }
                    ois = null;
======= fetch "protected void doLoad() throws ClassNotFoundException, IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

                if (ois != null) {
                    try {
                        ois.close();
                    } catch (IOException f) {
                        // Ignore
                    }
                    ois = null;
======= fetch "protected void doLoad() throws ClassNotFoundException, IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

                    if (ois != null)
                        ois.close();
======= fetch "protected void doUnload() throws IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

            if (oos != null) {
======= fetch "protected void doUnload() throws IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

                    oos.close();
======= fetch "protected void doUnload() throws IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

                oos = null;
======= fetch "protected void doUnload() throws IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

                if (oos != null) {
                    try {
                        oos.close();
                    } catch (IOException f) {
                        // Ignore
                    }
                    oos = null;
======= fetch "protected void doUnload() throws IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

            oos.close();
            oos = null;
        } catch (IOException e) {
            if (oos != null) {
                try {
                    oos.close();
                } catch (IOException f) {
                    // Ignore
                }
                oos = null;
======= fetch "protected void doUnload() throws IOException {" 6f48cde^:"java/org/apache/catalina/session/StandardManager.java"

            throw e;

     * The server component we are starting or stopping
     */
    protected Server server = null;
    /**
======= fetch "public void setParentClassLoader(ClassLoader parentClassLoader) {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

    /**
     * Set the server instance we are configuring.
     *
     * @param server The new server
     */
    @Override
    public void setServer(Server server) {
        this.server = server;
    }
======= fetch "public void stopServer(String[] arguments) {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

        if( server == null ) {
======= fetch "public void stopServer(String[] arguments) {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

            if (server.getPort()>0) { 
                Socket socket = new Socket(server.getAddress(), server.getPort());
======= fetch "public void stopServer(String[] arguments) {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

                String shutdown = server.getShutdown();
======= fetch "public void load() {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

        if (server instanceof Lifecycle) {
======= fetch "public void load() {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

                server.initialize();
======= fetch "public void start() {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

        if (server == null) {
======= fetch "public void start() {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

        if (server == null) {
======= fetch "public void start() {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

        if (server instanceof Lifecycle) {
======= fetch "public void start() {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

                ((Lifecycle) server).start();
======= fetch "public void stop() {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

        if (server instanceof Lifecycle) {
======= fetch "public void stop() {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

                ((Lifecycle) server).stop();
======= fetch "public void await() {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

        server.await();
======= fetch "public void run() {" 067e0ba^:"java/org/apache/catalina/startup/Catalina.java"

            if (server != null) {

======= fetch "public void configureContext(Context context) {" c85e791^:"java/org/apache/catalina/deploy/WebXml.java"

        for (String contextParam : contextParams.keySet()) {
            context.addParameter(contextParam, contextParams.get(contextParam));
======= fetch "public void configureContext(Context context) {" c85e791^:"java/org/apache/catalina/deploy/WebXml.java"

        for (String locale : localeEncodingMappings.keySet()) {
            context.addLocaleEncodingMappingParameter(locale,
                    localeEncodingMappings.get(locale));
======= fetch "public void configureContext(Context context) {" c85e791^:"java/org/apache/catalina/deploy/WebXml.java"

        for (String extension : mimeMappings.keySet()) {
            context.addMimeMapping(extension, mimeMappings.get(extension));
======= fetch "public void configureContext(Context context) {" c85e791^:"java/org/apache/catalina/deploy/WebXml.java"

            for (String param : params.keySet()) {
                wrapper.addInitParameter(param, params.get(param));
======= fetch "public void configureContext(Context context) {" c85e791^:"java/org/apache/catalina/deploy/WebXml.java"

        for (String pattern : servletMappings.keySet()) {
            context.addServletMapping(pattern, servletMappings.get(pattern));
======= fetch "public void configureContext(Context context) {" c85e791^:"java/org/apache/catalina/deploy/WebXml.java"

        for (String uri : taglibs.keySet()) {
            context.addTaglib(uri, taglibs.get(uri));
======= fetch "public boolean merge(Set<WebXml> fragments) {" c85e791^:"java/org/apache/catalina/deploy/WebXml.java"

        for (String key : fragmentMap.keySet()) {
======= fetch "public boolean merge(Set<WebXml> fragments) {" c85e791^:"java/org/apache/catalina/deploy/WebXml.java"

                T value = fragmentMap.get(key);
======= fetch "private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest," c85e791^:"java/org/apache/catalina/deploy/WebXml.java"

                    for (String name : fragments.keySet()) {
                        if (!requestedOrder.contains(name)) {
                            WebXml fragment = fragments.get(name);
======= fetch "public static String toString(ByteChunk bc) {" c85e791^:"java/org/apache/tomcat/util/buf/StringCache.java"

                        Iterator<ByteEntry> entries =
                            bcStats.keySet().iterator();
                        while (entries.hasNext()) {
                            ByteEntry entry = entries.next();
                            int[] countA = bcStats.get(entry);
======= fetch "public static String toString(CharChunk cc) {" c85e791^:"java/org/apache/tomcat/util/buf/StringCache.java"

                        Iterator<CharEntry> entries = ccStats.keySet().iterator();
                        while (entries.hasNext()) {
                            CharEntry entry = entries.next();
                            int[] countA = ccStats.get(entry);

 * <td>httpServerPort</td>
 * <td>Value returned by {@link ServletRequest#getServerPort()} when the <code>protocolHeader</code> indicates <code>http</code> protocol</td>
 * <td>N/A</td>
 * <td>integer</td>
 * <td>80</td>
 * </tr>
 * <tr>
 * <td>httpsServerPort</td>
 * <td>Value returned by {@link ServletRequest#getServerPort()} when the <code>protocolHeader</code> indicates <code>https</code> protocol</td>
 * <td>N/A</td>
 * <td>integer</td>
 * <td>443</td>
 * </tr>
======= fetch "protected static boolean matchesOne(String str, Pattern... patterns) {" 1789bd8^:"java/org/apache/catalina/valves/RemoteIpValve.java"

     * @see #setHttpServerPort(int)
     */
    private int httpServerPort = 80;
    
    /**
======= fetch "public int getHttpsServerPort() {" 1789bd8^:"java/org/apache/catalina/valves/RemoteIpValve.java"

    public int getHttpServerPort() {
        return httpServerPort;
    }
    
======= fetch "public String getRemoteIpHeader() {" 1789bd8^:"java/org/apache/catalina/valves/RemoteIpValve.java"

    
======= fetch "public void invoke(Request request, Response response) throws IOException, Servl" 1789bd8^:"java/org/apache/catalina/valves/RemoteIpValve.java"

                if (protocolHeaderValue != null && protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) {
======= fetch "public void invoke(Request request, Response response) throws IOException, Servl" 1789bd8^:"java/org/apache/catalina/valves/RemoteIpValve.java"

                } else {
                    request.setSecure(false);
                    // use request.coyoteRequest.scheme instead of request.setScheme() because request.setScheme() is no-op in Tomcat 6.0
                    request.getCoyoteRequest().scheme().setString("http");
                    
                    request.setServerPort(httpServerPort);
======= fetch "public void invoke(Request request, Response response) throws IOException, Servl" 1789bd8^:"java/org/apache/catalina/valves/RemoteIpValve.java"

               
    <attribute name="remoteIpHedaer"
======= fetch "public String getRemoteHost() {" 1789bd8^:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

        public String getScheme() {
            return scheme;
        }
        public int getServerPort() {
            return serverPort;
        }
        public boolean isSecure() {
            return secure;
        }
        
======= fetch "public void invoke(Request request, Response response) throws IOException, Servl" 1789bd8^:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

            this.scheme = request.getScheme();
            this.secure = request.isSecure();
            this.serverPort = request.getServerPort();
======= fetch "public void testInvokeAllProxiesAreTrustedAndRemoteAddrMatchRegexp() throws Exce" 1789bd8^:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

    (http/https) and server port with the scheme presented by a proxy or a load
    balancer via a request header (e.g. &quot;X-Forwarded-Proto&quot;).</p>
 

 * <td>httpServerPort</td>
 * <td>Value returned by {@link ServletRequest#getServerPort()} when the <code>protocolHeader</code> indicates <code>http</code> protocol</td>
 * <td>N/A</td>
 * <td>integer</td>
 * <td>80</td>
 * </tr>
 * <tr>
 * <td>httpsServerPort</td>
 * <td>Value returned by {@link ServletRequest#getServerPort()} when the <code>protocolHeader</code> indicates <code>https</code> protocol</td>
 * <td>N/A</td>
 * <td>integer</td>
 * <td>443</td>
 * </tr>
======= fetch "public void setServerPort(int serverPort) {" 7aa1206^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    protected static final String HTTP_SERVER_PORT_PARAMETER = "httpServerPort";
======= fetch "protected static boolean matchesOne(String str, Pattern... patterns) {" 7aa1206^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

     * @see #setHttpServerPort(int)
     */
    private int httpServerPort = 80;
    /**
======= fetch "protected static boolean matchesOne(String str, Pattern... patterns) {" 7aa1206^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 7aa1206^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                if (protocolHeaderValue != null && protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) {
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 7aa1206^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                } else {
                    xRequest.setSecure(false);
                    xRequest.setScheme("http");
                    xRequest.setServerPort(httpServerPort);
======= fetch "public void init(FilterConfig filterConfig) throws ServletException {" 7aa1206^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

        if (filterConfig.getInitParameter(HTTP_SERVER_PORT_PARAMETER) != null) {
            try {
                setHttpServerPort(Integer.parseInt(filterConfig.getInitParameter(HTTP_SERVER_PORT_PARAMETER)));
            } catch (NumberFormatException e) {
                throw new NumberFormatException("Illegal " + HTTP_SERVER_PORT_PARAMETER + " : " + e.getMessage());
            }
        }
        
======= fetch "public void init(FilterConfig filterConfig) throws ServletException {" 7aa1206^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                throw new NumberFormatException("Illegal serverPort : " + e.getMessage());
======= fetch "public void init(FilterConfig filterConfig) throws ServletException {" 7aa1206^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    (http/https) and server port with the scheme presented by a proxy or a load
    balancer via a request header (e.g. &quot;X-Forwarded-Proto&quot;).</p>

======= fetch "public static String URLDecode(byte[] bytes, String enc) {" d0f9da2^:"java/org/apache/catalina/util/RequestUtil.java"

        return URLDecode(bytes, null, false);

======= fetch "protected synchronized Principal getPrincipal(DirContext context," 62d29b6^:"java/org/apache/catalina/realm/JNDIRealm.java"

        return new GenericPrincipal(user.username, user.password ,
                getRoles(context, user));

======= fetch "protected void prepareResponse() {" 13daf69^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

            // Always overrides anything the app might set
======= fetch "protected void prepareResponse() {" 13daf69^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        } else {
======= fetch "protected void prepareResponse() throws IOException {" 13daf69^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            // Always overrides anything the app might set
======= fetch "protected void prepareResponse() throws IOException {" 13daf69^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

        } else {
======= fetch "public String run(){" 13daf69^:"java/org/apache/coyote/http11/Http11Processor.java"

            // Always overrides anything the app might set
======= fetch "public String run(){" 13daf69^:"java/org/apache/coyote/http11/Http11Processor.java"

        } else {
      <p>The Server header for the http response.
         Unless you are paranoid, you won't need this feature.

    private final class Cleaner extends Thread {
        
        @Override
        public void run() {
            // The JVM us being shutdown. Make sure all loggers for all class
            // loaders are shutdown
            for (ClassLoaderLogInfo clLogInfo : classLoaderLoggers.values()) {
                for (Logger logger : clLogInfo.loggers.values()) {
                    resetLogger(logger);
                }
            }
        }
            
        private void resetLogger(Logger logger) {
            
            Handler[] handlers = logger.getHandlers();
            for (Handler handler : handlers) {
                logger.removeHandler(handler);
                try {
                    handler.close();
                } catch (Exception e) {
                    // Ignore
                }
            }
        }
    }
    
    // ------------------------------------------------------------Constructors
    public ClassLoaderLogManager() {
        super();
        try { 
            Runtime.getRuntime().addShutdownHook(new Cleaner());
        } catch (IllegalStateException ise) {
            // We are probably already being shutdown. Ignore this error.
        }
    }
======= fetch "protected String replace(String str) {" eeb017a^:"java/org/apache/juli/ClassLoaderLogManager.java"

    /**
     * Need to override reset so the loggers loaded by the web applications can
     * be shutdown.
     */
    @Override
    public void reset() {
        super.reset();
        for (ClassLoaderLogInfo classLoaderLogInfo : classLoaderLoggers.values()) {
            for (Logger logger : classLoaderLogInfo.loggers.values()) {
                resetLogger(logger);
            }
        }
    }
    
    private void resetLogger(Logger logger) {
        
        Handler[] handlers = logger.getHandlers();
        for (Handler handler : handlers) {
            logger.removeHandler(handler);
            try {
                handler.close();
            } catch (Exception e) {
                // Ignore
            }
        }
    }
======= fetch "public static Log getLog(String name)" eeb017a^:"java/org/apache/juli/logging/LogFactory.java"

    public static void release(ClassLoader classLoader) {
        // nothing - we don't use any class loaders

======= fetch "protected void processAnnotationsJndi(URL url, WebXml fragment) {" f2eea0c^:"java/org/apache/catalina/startup/ContextConfig.java"

                sm.getString("contextConfig.jndiUrl", url);

======= fetch "public BeanProperty(Class<?> owner, PropertyDescriptor descriptor) {" 4df1957^:"java/javax/el/BeanELResolver.java"

        public Class getPropertyType() {
======= fetch "public ELContext() {" 4df1957^:"java/javax/el/ELContext.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
    public Object getContext(Class key) {
======= fetch "public Object getContext(Class key) {" 4df1957^:"java/javax/el/ELContext.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
    public void putContext(Class key, Object contextObject) throws NullPointerException {
======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" 4df1957^:"java/javax/el/ResourceBundleELResolver.java"

    @SuppressWarnings("unchecked") // Can't use Iterator<FeatureDescriptor> because API needs to match specification
    public Iterator getFeatureDescriptors(ELContext context, Object base) {
======= fetch "private final void clearReferencesJdbc() {" 4df1957^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            @SuppressWarnings("unchecked")
======= fetch "private final void clearReferencesStaticFinal() {" 4df1957^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        @SuppressWarnings("unchecked")
======= fetch "private void nullInstance(Object instance) {" 4df1957^:"java/org/apache/catalina/loader/WebappClassLoader.java"

    @SuppressWarnings("deprecation")
======= fetch "public final static int compare(final Object obj0, final Object obj1)" 4df1957^:"java/org/apache/el/lang/ELSupport.java"

            @SuppressWarnings("unchecked")
======= fetch "public final static int compare(final Object obj0, final Object obj1)" 4df1957^:"java/org/apache/el/lang/ELSupport.java"

            @SuppressWarnings("unchecked")
======= fetch "public VariableMapper getVariableMapper() {" 4df1957^:"java/org/apache/el/lang/EvaluationContext.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification in super-class
    public Object getContext(Class key) {
======= fetch "public boolean isPropertyResolved() {" 4df1957^:"java/org/apache/el/lang/EvaluationContext.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification in super-class
    public void putContext(Class key, Object contextObject) {
======= fetch "public void setValue(EvaluationContext ctx, Object value)" 4df1957^:"java/org/apache/el/parser/AstIdentifier.java"

    @SuppressWarnings("unchecked")
======= fetch "public void setValue(EvaluationContext ctx, Object value)" 4df1957^:"java/org/apache/el/parser/AstIdentifier.java"

    public Object invoke(EvaluationContext ctx, Class[] paramTypes,
======= fetch "public Object invoke(EvaluationContext ctx, Class[] paramTypes," 4df1957^:"java/org/apache/el/parser/AstIdentifier.java"

    @SuppressWarnings("unchecked")
======= fetch "public Object invoke(EvaluationContext ctx, Class[] paramTypes," 4df1957^:"java/org/apache/el/parser/AstIdentifier.java"

    public MethodInfo getMethodInfo(EvaluationContext ctx, Class[] paramTypes)
======= fetch "private boolean isAssignable(Object value, Class<?> targetClass) {" 4df1957^:"java/org/apache/el/parser/AstValue.java"

    @SuppressWarnings("unchecked")
======= fetch "private boolean isAssignable(Object value, Class<?> targetClass) {" 4df1957^:"java/org/apache/el/parser/AstValue.java"

    public MethodInfo getMethodInfo(EvaluationContext ctx, Class[] paramTypes)
======= fetch "public MethodInfo getMethodInfo(EvaluationContext ctx, Class[] paramTypes)" 4df1957^:"java/org/apache/el/parser/AstValue.java"

    @SuppressWarnings("unchecked")
======= fetch "public MethodInfo getMethodInfo(EvaluationContext ctx, Class[] paramTypes)" 4df1957^:"java/org/apache/el/parser/AstValue.java"

    public Object invoke(EvaluationContext ctx, Class[] paramTypes,
======= fetch "public void accept(NodeVisitor visitor) throws Exception {" 4df1957^:"java/org/apache/el/parser/SimpleNode.java"

    @SuppressWarnings("unchecked")
    public Object invoke(EvaluationContext ctx, Class[] paramTypes,
======= fetch "public Object invoke(EvaluationContext ctx, Class[] paramTypes," 4df1957^:"java/org/apache/el/parser/SimpleNode.java"

    @SuppressWarnings("unchecked")
======= fetch "public MethodInfo getMethodInfo(EvaluationContext ctx," 4df1957^:"java/org/apache/el/parser/SimpleNode.java"

            Class[] paramTypes) throws ELException {
======= fetch "public Attributes getAttributes(String name) throws NamingException {" 4df1957^:"java/org/apache/naming/resources/VirtualDirContext.java"

    @SuppressWarnings("unchecked")
    protected ArrayList list(File file) {
        ArrayList entries = super.list(file);

======= fetch "public void testParserStringLiteral() {" 11810fb^:"test/org/apache/el/TestELEvaluation.java"

    public void testParserFunction() {
        // bug 48112
        assertEquals("{world}", evaluateExpression("${fn:trim('{world}')}"));
    }
======= fetch "private String evaluateExpression(String expression) {" 11810fb^:"test/org/apache/el/TestELEvaluation.java"

        ctx.setFunctionMapper(new FMapper());
======= fetch "private String evaluateExpression(String expression) {" 11810fb^:"test/org/apache/el/TestELEvaluation.java"

    
    public static class FMapper extends FunctionMapper {
        @Override
        public Method resolveFunction(String prefix, String localName) {
            if ("trim".equals(localName)) {
                Method m;
                try {
                    m = this.getClass().getMethod("trim", String.class);
                    return m;
                } catch (SecurityException e) {
                    // Ignore
                } catch (NoSuchMethodException e) {
                    // Ignore
                } 
            }
            return null;
        }
        
        public static String trim(String input) {
            return input.trim();
        }
    }

======= fetch "protected ObjectName createObjectName(String domain, String type)" da5f249^:"java/org/apache/catalina/connector/Connector.java"

        String encodedAddr = null;
        if (getProperty("address") != null) {
            encodedAddr = URLEncoder.encode(getProperty("address").toString());
======= fetch "protected ObjectName createObjectName(String domain, String type)" da5f249^:"java/org/apache/catalina/connector/Connector.java"

        String addSuffix = (getProperty("address") == null) ? "" : ",address="
                + encodedAddr;
        ObjectName _oname = new ObjectName(domain + ":type=" + type + ",port="
                + getPort() + addSuffix);
======= fetch "static ObjectName createObjectName(String domain," da5f249^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

            String address = (String)
                IntrospectionUtils.getProperty(connector, "address");
======= fetch "static ObjectName createObjectName(String domain," da5f249^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

======= fetch "static ObjectName createObjectName(String domain," da5f249^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

            sb.append(",port=" + port);
            if ((address != null) && (address.length()>0)) {
                sb.append(",address=" + address);

    implements Adapter 
 {
======= fetch "public void service(org.apache.coyote.Request req," 3d309a5^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            response.addHeader("X-Powered-By", "Servlet/2.5");

    private static final String SERVICE_RESOURCE_NAME =
        "META-INF/services/javax.el.ExpressionFactory";
    private static final String SEP = System.getProperty("file.separator");
    private static final String PROPERTY_FILE =
        System.getProperty("java.home") + "jre" + SEP + "lib" + SEP +
        "el.properties";
    private static final String PROPERTY_NAME = "javax.el.ExpressionFactory";
======= fetch "public abstract MethodExpression createMethodExpression(ELContext context," 9a2ae02^:"java/javax/el/ExpressionFactory.java"

    
======= fetch "public static ExpressionFactory newInstance() {" 9a2ae02^:"java/javax/el/ExpressionFactory.java"

    /**
     * Create a new {@link ExpressionFactory} passing in the provided
     * {@link Properties}. Search order is the same as {@link #newInstance()}.
     * 
     * @param properties
     * @return
     */
======= fetch "public static ExpressionFactory newInstance(Properties properties) {" 9a2ae02^:"java/javax/el/ExpressionFactory.java"

        // TODO
    // private static ExpressionEvaluatorImpl expressionEvaluator
    // = new ExpressionEvaluatorImpl();
    private ExpressionFactory expressionFactory = new ExpressionFactoryImpl();
======= fetch "private void compareTagEncodings(String thePageDirEnc," 9a2ae02^:"java/org/apache/jasper/compiler/Validator.java"

        private static final ExpressionFactory EXPRESSION_FACTORY =
            ExpressionFactory.newInstance();
======= fetch "private void checkXmlAttributes(Node.CustomTag n," 9a2ae02^:"java/org/apache/jasper/compiler/Validator.java"

                                        ELSupport.checkType(attrs.getValue(i), expectedClass);

======= fetch "public void processExpires() {" d939925^:"java/org/apache/catalina/session/StoreBase.java"

    
======= fetch "public void processExpires() {" d939925^:"java/org/apache/catalina/session/StoreBase.java"

                if (session.isValid()) {
======= fetch "public void processExpires() {" d939925^:"java/org/apache/catalina/session/StoreBase.java"

                remove(session.getIdInternal());

    private String parameterEncoding = System.getProperty("file.encoding",
                                                          "UTF-8");
======= fetch "public void init(ServletConfig config) throws ServletException {" ae6c3c4^:"java/org/apache/catalina/servlets/CGIServlet.java"

        if (getServletConfig().getInitParameter("stderrTimeout") != null) {
            stderrTimeout = Long.parseLong(getServletConfig().getInitParameter(
                    "stderrTimeout"));
        }
======= fetch "protected void run() throws IOException {" ae6c3c4^:"java/org/apache/catalina/servlets/CGIServlet.java"

            Thread errReaderThread = null;
======= fetch "protected void run() throws IOException {" ae6c3c4^:"java/org/apache/catalina/servlets/CGIServlet.java"

                new Thread() {
======= fetch "public void run () {" ae6c3c4^:"java/org/apache/catalina/servlets/CGIServlet.java"

                }.start() ;
======= fetch "public void run () {" ae6c3c4^:"java/org/apache/catalina/servlets/CGIServlet.java"

                // Make sure the error stream reader has finished
                if (errReaderThread != null) {
                    try {
                        errReaderThread.join(stderrTimeout);
                    } catch (InterruptedException e) {
                        log ("Interupted waiting for stderr reader thread");
                    }
                }

======= fetch "public Permission getPermission() {" ff22e4a^:"java/org/apache/naming/resources/DirContextURLConnection.java"

                // This will be of the form /<hostname>/<contextpath/file name
======= fetch "public Permission getPermission() {" ff22e4a^:"java/org/apache/naming/resources/DirContextURLConnection.java"

                int start = file.indexOf('/', file.indexOf('/', 1) + 1);

    protected Lock diffLock = new ReentrantReadWriteLock().writeLock();
    ReentrantReadWriteLock inLock = new ReentrantReadWriteLock(true);
    ReentrantReadWriteLock outLock= new ReentrantReadWriteLock(true);
======= fetch "public int getNextPoll() {" e1d1476^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

    final ReentrantLock[] locks = new ReentrantLock[LOCK_COUNT];

======= fetch "public Void run() throws Exception{" d9f2c99^:"java/org/apache/catalina/session/PersistentManagerBase.java"

    /**
     * Sessions currently being swapped in and the associated locks
     */
    private Map<String,Object> sessionSwapInLocks =
    	new HashMap<String,Object>();
======= fetch "protected Session swapIn(String id) throws IOException {" d9f2c99^:"java/org/apache/catalina/session/PersistentManagerBase.java"

        Session session = null;
        try {
            if (SecurityUtil.isPackageProtectionEnabled()){
                try{
                    session = AccessController.doPrivileged(
                            new PrivilegedStoreLoad(id));
                }catch(PrivilegedActionException ex){
                    Exception exception = ex.getException();
                    log.error("Exception in the Store during swapIn: "
                              + exception);
                    if (exception instanceof IOException){
                        throw (IOException)exception;
                    } else if (exception instanceof ClassNotFoundException) {
                        throw (ClassNotFoundException)exception;
                    }
                }
            } else {
                 session = store.load(id);
            }   
        } catch (ClassNotFoundException e) {
            log.error(sm.getString("persistentManager.deserializeError", id, e));
            throw new IllegalStateException
                (sm.getString("persistentManager.deserializeError", id, e));
        }
======= fetch "protected Session swapIn(String id) throws IOException {" d9f2c99^:"java/org/apache/catalina/session/PersistentManagerBase.java"

        if (session == null)
            return (null);
======= fetch "protected Session swapIn(String id) throws IOException {" d9f2c99^:"java/org/apache/catalina/session/PersistentManagerBase.java"

        if (!session.isValid()) {
            log.error("session swapped in is invalid or expired");
            session.expire();
            removeSession(id);
            return (null);
======= fetch "protected Session swapIn(String id) throws IOException {" d9f2c99^:"java/org/apache/catalina/session/PersistentManagerBase.java"

        if(log.isDebugEnabled())
            log.debug(sm.getString("persistentManager.swapIn", id));
        session.setManager(this);
        // make sure the listeners know about it.
        ((StandardSession)session).tellNew();
        add(session);
        ((StandardSession)session).activate();
        // endAccess() to ensure timeouts happen correctly.
        // access() to keep access count correct or it will end up negative
        session.access();
        session.endAccess();

 * <code>192.168/16</code>) to configure <code>RemoteIPInternalProxy</code> and <code>RemoteIPTrustedProxy</code> ; as the JVM doesnt have a
 * href="http://apr.apache.org/docs/apr/1.3/group__apr__network__io.html#gb74d21b8898b7c40bf7fd07ad3eb993d">apr_ipsubnet_test</a>.
======= fetch "public void setServerPort(int serverPort) {" 803d64d^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    protected static final String PROTOCOL_HEADER_SSL_VALUE_PARAMETER = "protocolHeaderSslValue";
======= fetch "protected static boolean matchesOne(String str, Pattern... patterns) {" 803d64d^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    private String protocolHeaderSslValue = "https";
======= fetch "public void doFilter(HttpServletRequest request, HttpServletResponse response, F" 803d64d^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                if (protocolHeaderValue != null && protocolHeaderSslValue.equalsIgnoreCase(protocolHeaderValue)) {
======= fetch "public String getProtocolHeader() {" 803d64d^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    public String getProtocolHeaderSslValue() {
        return protocolHeaderSslValue;
======= fetch "public void init(FilterConfig filterConfig) throws ServletException {" 803d64d^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

        if (filterConfig.getInitParameter(PROTOCOL_HEADER_SSL_VALUE_PARAMETER) != null) {
            setProtocolHeaderSslValue(filterConfig.getInitParameter(PROTOCOL_HEADER_SSL_VALUE_PARAMETER));
======= fetch "public void setProtocolHeader(String protocolHeader) {" 803d64d^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

     * Case insensitive value of the protocol header to indicate that the incoming http request uses SSL.
======= fetch "public void setProtocolHeader(String protocolHeader) {" 803d64d^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

     * Default value : <code>HTTPS</code>
======= fetch "public void setProtocolHeader(String protocolHeader) {" 803d64d^:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    public void setProtocolHeaderSslValue(String protocolHeaderSslValue) {
        this.protocolHeaderSslValue = protocolHeaderSslValue;

    
    private static final Map<SSLSession,Integer> keySizeCache =
        new WeakHashMap<SSLSession, Integer>();
======= fetch "public Integer getKeySize()" 51d5511^:"java/org/apache/tomcat/util/net/jsse/JSSESupport.java"

        Integer keySize = (Integer) session.getValue(KEY_SIZE_KEY);
======= fetch "public Integer getKeySize()" 51d5511^:"java/org/apache/tomcat/util/net/jsse/JSSESupport.java"

            session.putValue(KEY_SIZE_KEY, keySize);

======= fetch "public boolean authenticate(Request request," 88b5d4b^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

     * @throws IOException  If the forward to the login page fails and the call
     *                      to {@link HttpServletResponse#sendError(int, String)
     *                      throws an {@link IOException}
======= fetch "protected void forwardToLoginPage(Request request," 88b5d4b^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

            HttpServletResponse response, LoginConfig config) {
======= fetch "protected void forwardToLoginPage(Request request," 88b5d4b^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

            log.warn("Unexpected error forwarding to login page", t);
======= fetch "protected void forwardToLoginPage(Request request," 88b5d4b^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

     * @throws IOException  If the forward to the error page fails and the call
     *                      to {@link HttpServletResponse#sendError(int, String)
     *                      throws an {@link IOException}
======= fetch "protected void forwardToErrorPage(Request request," 88b5d4b^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

            HttpServletResponse response, LoginConfig config) {
======= fetch "protected void forwardToErrorPage(Request request," 88b5d4b^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

            log.warn("Unexpected error forwarding to error page", t);

======= fetch "public boolean hasClient(String clientId) {" b09d817^:"modules/bayeux/java/org/apache/tomcat/bayeux/TomcatBayeux.java"

        return java.util.Arrays.asList(clients.entrySet().toArray(new Client[0]));

    JSONObject msgData = null;
======= fetch "public PublishRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throw" 9be399f^:"modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java"

    @Override
======= fetch "public HttpError validate() {" 9be399f^:"modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java"

    @Override

======= fetch "static boolean isSSLAttribute(String name) {" 549a5d5^:"java/org/apache/catalina/connector/Request.java"

     * names return will only be those for the attributes set via
======= fetch "static boolean isSSLAttribute(String name) {" 549a5d5^:"java/org/apache/catalina/connector/Request.java"

     * <li>{@link Globals.DISPATCHER_TYPE_ATTR}</li>
     * <li>{@link Globals.DISPATCHER_REQUEST_PATH_ATTR}</li>
     * <li>{@link Globals.ASYNC_SUPPORTED_ATTR}</li>
     * <li>{@link Globals.CERTIFICATES_ATTR} (SSL connections only)</li>
     * <li>{@link Globals.CIPHER_SUITE_ATTR} (SSL connections only)</li>
     * <li>{@link Globals.KEY_SIZE_ATTR} (SSL connections only)</li>
     * <li>{@link Globals.SSL_SESSION_ID_ATTR} (SSL connections only)</li>
     * <li>{@link Globals.SSL_SESSION_MGR_ATTR} (SSL connections only)</li>
======= fetch "public Session getSessionInternal(boolean create) {" 549a5d5^:"java/org/apache/catalina/connector/Request.java"

     * @return
======= fetch "public void setCometTimeout(long timeout) {" 549a5d5^:"java/org/apache/catalina/connector/Request.java"

     * @return

======= fetch "private void writeObject(ObjectOutput stream) throws IOException {" 806200c^:"java/org/apache/catalina/ha/session/DeltaSession.java"

            if (value == null)

======= fetch "protected void createProperty(String propertyPrefix, Object result) {" ed40c2c^:"java/org/apache/catalina/ant/jmx/JMXAccessorTask.java"

                for (Iterator<Object> iter1 = ((List<Object>) key).iterator(); iter1.hasNext();) {
======= fetch "public Object clone() {" ed40c2c^:"java/org/apache/catalina/tribes/membership/Membership.java"

            clone.map = (HashMap<MemberImpl, MbrEntry>) map.clone();
======= fetch "public synchronized void reset() {" ed40c2c^:"java/org/apache/catalina/tribes/membership/Membership.java"

     * @return - true if this member is new to the cluster, false otherwise.
     * @return - false if this member is the local member or updated.
======= fetch "protected String getHeaderValueAsString(Object headerValue) {" ed40c2c^:"java/org/apache/naming/resources/DirContextURLConnection.java"

          return (Collections.EMPTY_MAP);
======= fetch "public Object getContent()" ed40c2c^:"java/org/apache/naming/resources/DirContextURLConnection.java"

    @SuppressWarnings("unchecked") // overridden method uses raw type Class[]

======= fetch "public synchronized void start() throws LifecycleException {" 9afe6ce^:"java/org/apache/catalina/ha/context/ReplicatedContext.java"

        if( !initialized ) { 
            try {
                init();
            } catch( Exception ex ) {
                throw new LifecycleException("Error initializaing ", ex);
            }
        }

======= fetch "public final static void throwUnhandled(Object base, Object property)" b8599a3^:"java/org/apache/el/lang/ELSupport.java"

     * @param obj0
     * @param obj1
     * @return
     * @throws EvaluationException
======= fetch "public final static int compare(final Object obj0, final Object obj1)" b8599a3^:"java/org/apache/el/lang/ELSupport.java"

        if (obj0 instanceof Comparable) {
            return (obj1 != null) ? ((Comparable) obj0).compareTo(obj1) : 1;
======= fetch "public final static int compare(final Object obj0, final Object obj1)" b8599a3^:"java/org/apache/el/lang/ELSupport.java"

        if (obj1 instanceof Comparable) {
            return (obj0 != null) ? -((Comparable) obj1).compareTo(obj0) : -1;
======= fetch "public final static int compare(final Object obj0, final Object obj1)" b8599a3^:"java/org/apache/el/lang/ELSupport.java"

     * @param obj0
     * @param obj1
     * @return
     * @throws EvaluationException
======= fetch "public final static Enum coerceToEnum(final Object obj, Class type) {" b8599a3^:"java/org/apache/el/lang/ELSupport.java"

            return (Enum) obj;
======= fetch "public final static Enum coerceToEnum(final Object obj, Class type) {" b8599a3^:"java/org/apache/el/lang/ELSupport.java"

     * @param obj
     * @return
======= fetch "protected final static Number coerceToNumber(final String val," b8599a3^:"java/org/apache/el/lang/ELSupport.java"

     * Coerce an object to a string
======= fetch "protected final static Number coerceToNumber(final String val," b8599a3^:"java/org/apache/el/lang/ELSupport.java"

     * @return
======= fetch "public final static String coerceToString(final Object obj) {" b8599a3^:"java/org/apache/el/lang/ELSupport.java"

        } else if (obj instanceof Enum) {
            return ((Enum) obj).name();
======= fetch "public final static Object coerceToType(final Object obj," b8599a3^:"java/org/apache/el/lang/ELSupport.java"

     * @param obj
     * @return
======= fetch "public void testMisc() {" b8599a3^:"test/org/apache/el/TestELEvaluation.java"

    private void compareBoth(String msg, int expected, Object o1, Object o2){
        int i1 = ELSupport.compare(o1, o2);
        int i2 = ELSupport.compare(o2, o1);
        assertEquals(msg,expected, i1);
        assertEquals(msg,expected, -i2);
    }
    public void testElSupportCompare(){
        compareBoth("Nulls should compare equal", 0, null, null);
        compareBoth("Null should compare equal to \"\"", 0, "", null);
        compareBoth("Null should be less than File()",-1, null, new File(""));
        compareBoth("Null should be less than Date()",-1, null, new Date());
        compareBoth("Date(0) should be less than Date(1)",-1, new Date(0), new Date(1));        
        try {
            compareBoth("Should not compare",0, new Date(), new File(""));
            fail("Expecting ClassCastException");
        } catch (ClassCastException expected) {
            // Expected
        }
        assertTrue(null == null);
    }

======= fetch "public VariableMapper getVariableMapper() {" 2ac1900^:"java/org/apache/el/lang/EvaluationContext.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification in super-class
======= fetch "public boolean isPropertyResolved() {" 2ac1900^:"java/org/apache/el/lang/EvaluationContext.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification in super-class
======= fetch "public VariableMapper getVariableMapper() {" 2ac1900^:"java/org/apache/jasper/el/ELContextWrapper.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match super-class specification
======= fetch "public boolean isPropertyResolved() {" 2ac1900^:"java/org/apache/jasper/el/ELContextWrapper.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match super-class specification

======= fetch "public String getMimeType(String file) {" ce8d1c5^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= fetch "public Servlet getServlet(String name)" ce8d1c5^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= fetch "public Servlet getServlet(String name)" ce8d1c5^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= fetch "public String getInitParameter(String name) {" ce8d1c5^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= fetch "public Object getAttribute(String name) {" ce8d1c5^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= fetch "public String getContextPath() {" ce8d1c5^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= fetch "public FilterRegistration getFilterRegistration(String filterName) {" ce8d1c5^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= fetch "public ServletRegistration getServletRegistration(String servletName) {" ce8d1c5^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= fetch "public ServletRegistration getServletRegistration(String servletName) {" ce8d1c5^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= fetch "public void addListener(String className) {" ce8d1c5^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= fetch "public int getEffectiveMinorVersion() {" ce8d1c5^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= fetch "public JspConfigDescriptor getJspConfigDescriptor() {" ce8d1c5^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type

======= fetch "private boolean matchDispatcher(FilterMap filterMap, DispatcherType type) {" f0a0aec^:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

            case ASYNC : {
                if ((filterMap.getDispatcherMapping() & FilterMap.ASYNC) > 0) {
                    return true;
                }
                break;
            }
    public static final int ASYNC = 16;
======= fetch "public void addURLPattern(String urlPattern) {" f0a0aec^:"java/org/apache/catalina/deploy/FilterMap.java"

     * representing the state of when filters should be applied:
     *
     *        ERROR
     *        FORWARD
     *        FORWARD_ERROR
     *        INCLUDE
     *        INCLUDE_ERROR
     *        INCLUDE_ERROR_FORWARD
     *        REQUEST
     *        REQUEST_ERROR
     *        REQUEST_ERROR_INCLUDE
     *        REQUEST_ERROR_FORWARD_INCLUDE
     *        REQUEST_INCLUDE
     *        REQUEST_FORWARD,
     *        REQUEST_FORWARD_INCLUDE
     *
======= fetch "public void setDispatcher(String dispatcherString) {" f0a0aec^:"java/org/apache/catalina/deploy/FilterMap.java"

        }  else if (dispatcher.equals(DispatcherType.ASYNC.name())) {
            // apply ERROR to the global dispatcherMapping.
            dispatcherMapping |= ASYNC;

======= fetch "public ManagedBean findManagedBean(String name) {" 56897be^:"java/org/apache/tomcat/util/modeler/Registry.java"

            if ((group == null) && (item.getGroup() == null)) {
                results.add(item.getName());
======= fetch "public Object convertValue(String type, String value)" 56897be^:"java/org/apache/tomcat/util/modeler/Registry.java"

        } else if( source instanceof Class ) {

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
   @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
======= fetch "public BeanProperty(Class<?> owner, PropertyDescriptor descriptor) {" 632e68c^:"java/javax/el/BeanELResolver.java"

        public Class getPropertyType() {
======= fetch "private final BeanProperty property(ELContext ctx, Object base," 632e68c^:"java/javax/el/BeanELResolver.java"

======= fetch "public ELContext() {" 632e68c^:"java/javax/el/ELContext.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
======= fetch "public Object getContext(Class key) {" 632e68c^:"java/javax/el/ELContext.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
======= fetch "public Object getValue(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/ListELResolver.java"

======= fetch "public Object getValue(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/ListELResolver.java"

======= fetch "public Object getValue(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/ListELResolver.java"

======= fetch "public Object getValue(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/ListELResolver.java"

======= fetch "public void setValue(ELContext context, Object base, Object property," 632e68c^:"java/javax/el/ListELResolver.java"

======= fetch "public void setValue(ELContext context, Object base, Object property," 632e68c^:"java/javax/el/ListELResolver.java"

======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/ListELResolver.java"

======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/ListELResolver.java"

======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/ListELResolver.java"

======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/ListELResolver.java"

======= fetch "public Object getValue(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/MapELResolver.java"

======= fetch "public Object getValue(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/MapELResolver.java"

======= fetch "public Object getValue(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/MapELResolver.java"

======= fetch "public Object getValue(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/MapELResolver.java"

======= fetch "public void setValue(ELContext context, Object base, Object property," 632e68c^:"java/javax/el/MapELResolver.java"

======= fetch "public void setValue(ELContext context, Object base, Object property," 632e68c^:"java/javax/el/MapELResolver.java"

======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/MapELResolver.java"

======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/MapELResolver.java"

======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/MapELResolver.java"

======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" 632e68c^:"java/javax/el/ResourceBundleELResolver.java"

    @SuppressWarnings("unchecked") // Can't use Iterator<FeatureDescriptor> because API needs to match specification
======= fetch "public Iterator getFeatureDescriptors(ELContext context, Object base) {" 632e68c^:"java/javax/el/ResourceBundleELResolver.java"

======= fetch "public Iterator getFeatureDescriptors(ELContext context, Object base) {" 632e68c^:"java/javax/el/ResourceBundleELResolver.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification

======= fetch "protected void createProperty(String propertyPrefix, Object result) {" 21cd308^:"java/org/apache/catalina/ant/jmx/JMXAccessorTask.java"

                if (type instanceof SimpleType) {
======= fetch "protected void createProperty(String propertyPrefix, Object result) {" 21cd308^:"java/org/apache/catalina/ant/jmx/JMXAccessorTask.java"

                    if (type instanceof SimpleType) {
======= fetch "public void init(String host, int port) throws Exception {" 21cd308^:"java/org/apache/catalina/ha/backend/CollectedInfo.java"

        Set set = mBeanServer.queryMBeans(objectName, null);
======= fetch "public String listSessionIdsFull() {" 21cd308^:"java/org/apache/catalina/ha/session/BackupManager.java"

        @SuppressWarnings("unchecked") // sessions is of type Map<String, Session>
======= fetch "protected void sendCrossContextSession(CatalinaCluster containerCluster) {" 21cd308^:"java/org/apache/catalina/ha/tcp/ReplicationValve.java"

        Object sessions = crossContextSessions.get();
        if(sessions != null && sessions instanceof List
                && ((List<Session>)sessions).size() >0) {
            for(Iterator<Session> iter = ((List<Session>)sessions).iterator(); iter.hasNext() ;) {          
======= fetch "protected void resetReplicationRequest(Request request, boolean isCrossContext)" 21cd308^:"java/org/apache/catalina/ha/tcp/ReplicationValve.java"

            Object sessions = crossContextSessions.get();
            if(sessions != null && sessions instanceof List
               && ((List<Session>)sessions).size() >0) {
                Iterator<Session> iter = ((List<Session>)sessions).iterator();
======= fetch "public boolean equals(Object o) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            @SuppressWarnings("unchecked") // mapMembers has the correct type
======= fetch "public void replicate(boolean complete) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        Iterator i = super.entrySet().iterator();
======= fetch "public void replicate(boolean complete) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Map.Entry e = (Map.Entry) i.next();
======= fetch "public void transferState() {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                        ArrayList list = (ArrayList) msg.getValue();
======= fetch "public Serializable replyRequest(Serializable msg, final Member sender) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Iterator i = super.entrySet().iterator();
======= fetch "public Serializable replyRequest(Serializable msg, final Member sender) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    Map.Entry e = (Map.Entry) i.next();
======= fetch "public void mapMemberAdded(Member member) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Iterator i = super.entrySet().iterator();
======= fetch "public void mapMemberAdded(Member member) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    Map.Entry e = (Map.Entry) i.next();
======= fetch "public void memberDisappeared(Member member) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        Iterator i = super.entrySet().iterator();
======= fetch "public void memberDisappeared(Member member) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Map.Entry e = (Map.Entry) i.next();
======= fetch "protected void printMap(String header) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Iterator i = super.entrySet().iterator();
======= fetch "protected void printMap(String header) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Map.Entry e = (Map.Entry) i.next();
======= fetch "public void putAll(Map m) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Iterator i = m.entrySet().iterator();
======= fetch "public void putAll(Map m) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Map.Entry entry = (Map.Entry)i.next();
======= fetch "public boolean containsValue(Object value) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Iterator i = super.entrySet().iterator();
======= fetch "public boolean containsValue(Object value) {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    Map.Entry e = (Map.Entry) i.next();
======= fetch "public int sizeFull() {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Iterator i = super.entrySet().iterator();
======= fetch "public int sizeFull() {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Map.Entry e = (Map.Entry)i.next();
======= fetch "public int sizeFull() {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Iterator i = super.entrySet().iterator();
======= fetch "public int sizeFull() {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Map.Entry e = (Map.Entry)i.next();
======= fetch "public int size() {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Iterator it = super.entrySet().iterator();
======= fetch "public int size() {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Map.Entry e = (Map.Entry) it.next();
======= fetch "public boolean isEmpty() {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Iterator i = super.entrySet().iterator();
======= fetch "public boolean isEmpty() {" 21cd308^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Map.Entry e = (Map.Entry)i.next();
======= fetch "public boolean keepalive() {" 21cd308^:"java/org/apache/catalina/tribes/transport/bio/MultipointBioSender.java"

        @SuppressWarnings("unchecked") // bioSenders is of type HashMap<Member, BioSender>

======= fetch "private void resetContext() throws Exception, MBeanRegistrationException {" 92e53f3^:"java/org/apache/catalina/core/StandardContext.java"

        taglibs = new HashMap<String, String>();
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 92e53f3^:"java/org/apache/catalina/startup/TldConfig.java"

        } // Ignore the other event types - nothing to do 

======= fetch "public void parseHost(MessageBytes valueMB) {" 55e5052^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

                int charValue = HexUtils.DEC[valueB[i + valueS]];
======= fetch "public void parseHost(MessageBytes valueMB) {" 55e5052^:"java/org/apache/coyote/ajp/AjpProcessor.java"

                int charValue = HexUtils.DEC[valueB[i + valueS]];
======= fetch "public void parseHost(MessageBytes valueMB) {" 55e5052^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                int charValue = HexUtils.DEC[valueB[i + valueS]];
======= fetch "public void parseHost(MessageBytes valueMB) {" 55e5052^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                int charValue = HexUtils.DEC[valueB[i + valueS]];
======= fetch "protected void parseHost(MessageBytes valueMB) {" 55e5052^:"java/org/apache/coyote/http11/Http11Processor.java"

                int charValue = HexUtils.DEC[valueB[i + valueS]];
======= fetch "protected boolean parseChunkHeader()" 55e5052^:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

                if (HexUtils.DEC[buf[pos]] != -1) {
======= fetch "protected boolean parseChunkHeader()" 55e5052^:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

                    result += HexUtils.DEC[buf[pos]];
======= fetch "public int doWrite(ByteChunk chunk, Response res)" 55e5052^:"java/org/apache/coyote/http11/filters/ChunkedOutputFilter.java"

            chunkLength[pos--] = HexUtils.HEX[digit];
    public static final int[] DEC = {
    public static final byte[] HEX = 
======= fetch "public static void load() {" 55e5052^:"java/org/apache/tomcat/util/buf/HexUtils.java"

    public static int getDec(int index){
        return DEC[index];
    }
    public static byte getHex(int index){
        return HEX[index];
    }
======= fetch "public void setInt(int i) {" 55e5052^:"java/org/apache/tomcat/util/buf/MessageBytes.java"

            buf[end++] = HexUtils.HEX[digit];
======= fetch "public void setLong(long l) {" 55e5052^:"java/org/apache/tomcat/util/buf/MessageBytes.java"

            buf[end++] = HexUtils.HEX[digit];

======= fetch "protected static synchronized int inc() {" a524187^:"java/org/apache/catalina/tribes/group/GroupChannel.java"

        protected boolean doRun = true;
    protected boolean run = false;
    protected boolean running = true;
    protected boolean doRunSender = false;
    protected boolean doRunReceiver = false;
======= fetch "public void run() {" a524187^:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

        static boolean running = false;

======= fetch "public int read(ByteBuffer buf, NioChannel socket, long readTimeout) throws IOEx" c7d7ba2^:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"

        protected boolean run = true;

======= fetch "public void destroySubcontext(Name name)" af8a612^:"java/org/apache/naming/NamingContext.java"

                ((Context) entry.value).unbind(name.getSuffix(1));

======= fetch "public void setDomain(byte[] domain) {" 94c643b^:"java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java"

    public void setDomain(String domain) {
        if ( domain == null ) return;
        if (domain.startsWith("{"))
            setDomain(org.apache.catalina.tribes.util.Arrays.fromString(domain));
            setDomain(org.apache.catalina.tribes.util.Arrays.convert(domain));
    }
======= fetch "public void setDomain(byte[] domain) {" 94c643b^:"java/org/apache/catalina/tribes/membership/McastService.java"

    public void setDomain(String domain) {
        if ( domain == null ) return;
        if ( domain.startsWith("{") ) setDomain(Arrays.fromString(domain));
        else setDomain(Arrays.convert(domain));
    }

======= fetch "public void begin(String namespace, String name, Attributes attributes)" 04b0838^:"java/org/apache/catalina/startup/WebRuleSet.java"

        } else if ("false".equals(value)) {
            webxml.setMetadataComplete(false);

======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 58162ed^:"java/org/apache/catalina/core/NamingContextListener.java"

            namingResources.addPropertyChangeListener(this);
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 58162ed^:"java/org/apache/catalina/core/NamingContextListener.java"

                namingResources.addPropertyChangeListener(this);
======= fetch "public void containerEvent(ContainerEvent event) {" 58162ed^:"java/org/apache/catalina/core/NamingContextListener.java"

     * Process property change events.  Currently, only listens to such events
     * on the <code>NamingResources</code> instance for the global naming
     * resources.
======= fetch "public void propertyChange(PropertyChangeEvent event) {" 58162ed^:"java/org/apache/catalina/core/NamingContextListener.java"

     * Process a property change on the global naming resources, by making the
======= fetch "private void processGlobalResourcesChange(String name," 58162ed^:"java/org/apache/catalina/core/NamingContextListener.java"

        // NOTE - It seems that the Context for global JNDI resources
        // is left in read-write mode, so we do not have to change it here

======= fetch "public void destroy() {" ae5c640^:"java/org/apache/catalina/session/ManagerBase.java"

        if (randomIS!=null) {
            try {
                randomIS.close();
            } catch (IOException ioe) {
                log.warn("Failed to close randomIS.");
            }
            randomIS=null;
        }

======= fetch "public static boolean setProperty(Object o, String name, String value) {" c0cb61b^:"java/org/apache/tomcat/util/IntrospectionUtils.java"

        return setProperty(o,name,value,true);
    }
    public static boolean setProperty(Object o, String name, String value,boolean invokeSetProperty) {
======= fetch "public boolean setProperty(String name, String value) {" c0cb61b^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

                return IntrospectionUtils.setProperty(this,name,value);

======= fetch "public synchronized void setLoader(Loader loader) {" c53173b^:"java/org/apache/catalina/core/ContainerBase.java"

     * Return the Logger with which this Container is associated.  If there is
     * no associated Logger, return the Logger associated with our parent
     * Container (if any); otherwise return <code>null</code>.

    private int jspReloadCount;
======= fetch "public JspRuntimeContext(ServletContext context, Options options) {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

        parentClassLoader = Thread.currentThread().getContextClassLoader();
        if (parentClassLoader == null) {
            parentClassLoader = this.getClass().getClassLoader();
======= fetch "public JspRuntimeContext(ServletContext context, Options options) {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

            if (parentClassLoader != null) {
======= fetch "public JspRuntimeContext(ServletContext context, Options options) {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                                               parentClassLoader.toString()));
======= fetch "public JspRuntimeContext(ServletContext context, Options options) {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

        initClassPath();
======= fetch "public JspRuntimeContext(ServletContext context, Options options) {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

            codeSource = null;
            permissionCollection = null;
======= fetch "public JspRuntimeContext(ServletContext context, Options options) {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

            initSecurity();
======= fetch "public JspRuntimeContext(ServletContext context, Options options) {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

    private ServletContext context;
    private Options options;
    private ClassLoader parentClassLoader;
    private PermissionCollection permissionCollection;
    private CodeSource codeSource;                    
    private String classpath;
    private long lastCheck = -1L;
======= fetch "public void destroy() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

    public synchronized void incrementJspReloadCount() {
        jspReloadCount++;
======= fetch "public synchronized void incrementJspReloadCount() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

    public synchronized void setJspReloadCount(int count) {
        this.jspReloadCount = count;
======= fetch "public int getJspReloadCount() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

        return jspReloadCount;
======= fetch "public String getClassPath() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

    private void initClassPath() {
======= fetch "private void initClassPath() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

        classpath = cpath.toString() + cp;
======= fetch "private void initClassPath() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

            log.debug("Compilation classpath initialized: " + getClassPath());
======= fetch "private void initClassPath() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

        return path;
======= fetch "private void initClassPath() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

    // Helper class to allow initSecurity() to return two items
    private static class SecurityHolder{
        private final CodeSource cs;
        private final PermissionCollection pc;
        private SecurityHolder(CodeSource cs, PermissionCollection pc){
            this.cs = cs;
            this.pc = pc;
        }
    }
======= fetch "private void initClassPath() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

    private void initSecurity() {
======= fetch "private void initSecurity() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

        CodeSource source = null;
        PermissionCollection permissions = null;
======= fetch "private void initSecurity() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                codeSource = new CodeSource(url,(Certificate[])null);
                permissionCollection = policy.getPermissions(codeSource);
======= fetch "private void initSecurity() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                    permissionCollection.add
======= fetch "private void initSecurity() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                    permissionCollection.add
======= fetch "private void initSecurity() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                permissionCollection.add(new FilePermission(docBase,"read"));
======= fetch "private void initSecurity() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                    permissionCollection.add
======= fetch "private void initSecurity() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                permissionCollection.add(new FilePermission(
======= fetch "private void initSecurity() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                permissionCollection.add( new RuntimePermission(
======= fetch "private void initSecurity() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                        permissionCollection.add(
======= fetch "private void initSecurity() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                        permissionCollection.add(
======= fetch "private void initSecurity() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                        permissionCollection.add(
======= fetch "private void initSecurity() {" 242b6a3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

        return new SecurityHolder(source, permissions);

    public static final org.apache.juli.logging.Log log =
    public static final byte[] START_DATA = {70,76,84,50,48,48,50};
    public static final byte[] END_DATA = {84,76,70,50,48,48,51};
======= fetch "public ChannelData extractPackage(boolean clearFromBuffer) throws java.io.IOExce" a1cb0c3^:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

     * 
======= fetch "public static long toLong(byte[] b,int off){" a1cb0c3^:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    /**
     * Converts a byte array entry to boolean
     * @param b byte array
     * @param offset within byte array
     * @return true if byte array entry is non-zero, false otherwise
     */
======= fetch "public static Serializable deserialize(byte[] data, int offset, int length)" a1cb0c3^:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    public static AtomicInteger invokecount = new AtomicInteger(0);


    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(AbstractHttp11Protocol.class);
======= fetch "public NioEndpoint getEndpoint() {" 0d7263a^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    @Override
======= fetch "public void init() throws Exception {" 0d7263a^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    @Override
======= fetch "public void deregister(Http11NioProcessor processor) {" 0d7263a^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    protected static final org.apache.juli.logging.Log log
    protected static final org.apache.juli.logging.Log log
======= fetch "public Http11Protocol() {" 0d7263a^:"java/org/apache/coyote/http11/Http11Protocol.java"

    @Override
======= fetch "public void init() throws Exception {" 0d7263a^:"java/org/apache/coyote/http11/Http11Protocol.java"

    @Override

======= fetch "public boolean isUnavailable() {" 38f52b5^:"java/org/apache/catalina/startup/Tomcat.java"

    public static final String[] DEFAULT_MIME_MAPPINGS = {
    public static final byte[] START_DATA = new byte[] {113, 1, -58, 2, -34, -60, 75, -78, -101, -12, 32, -29, 32, 111, -40, 4};
    public static final byte[] END_DATA = new byte[] {54, -13, 90, 110, 47, -31, 75, -24, -81, -29, 36, 52, -58, 77, -110, 56};
    public static final int[] DEC = {

    public static int DEFAULT_POOL_SIZE = 100*1024*1024; //100MB
    public static int TAB_WIDTH = 2;
    public static String SPACES = "                              ";
    public static Hashtable<String,String> defaultMap =

    private static org.apache.juli.logging.Log log =
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    protected static org.apache.juli.logging.Log log=
    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ClusterListener.class);
    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( ReplicatedContext.class );
    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( BackupManager.class );
    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(DeltaManager.class);
    public static org.apache.juli.logging.Log log =
    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(DeltaSession.class);
    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
    protected static org.apache.juli.logging.Log log =
    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( SimpleTcpReplicationManager.class );
    private static org.apache.juli.logging.Log log =
    protected static org.apache.juli.logging.Log log=
======= fetch "private boolean copy(InputStream is, OutputStream os) {" 799b934^:"java/org/apache/catalina/loader/WebappLoader.java"

    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log = 
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
======= fetch "public void run() {" 799b934^:"java/org/apache/catalina/startup/Catalina.java"

    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    protected static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
   protected static org.apache.juli.logging.Log log = 
    protected static org.apache.juli.logging.Log log=
    protected static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(
======= fetch "public void remove() {" 799b934^:"java/org/apache/catalina/tribes/group/GroupChannel.java"

        protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(HeartbeatThread.class);
    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(RpcChannel.class);
    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( FragmentationInterceptor.class );
    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(MessageDispatchInterceptor.class);
    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( TcpFailureDetector.class );
    protected static org.apache.juli.logging.Log log = 
    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ThroughputInterceptor.class);
    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(TwoPhaseCommitInterceptor.class);
    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ObjectReader.class);
    public static org.apache.juli.logging.Log log =
    private static org.apache.juli.logging.Log log =
    private static org.apache.juli.logging.Log log =
    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(LazyReplicatedMap.class);
    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ReplicatedMap.class);
    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(BioReceiver.class);
    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( BioReplicationTask.class );
    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(BioSender.class);
    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(FastQueue.class);
    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(NioReceiver.class);
    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( NioReplicationTask.class );
    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(NioSender.class);
    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ParallelNioSender.class);
    public static Log MESSAGES = LogFactory.getLog( "org.apache.catalina.tribes.MESSAGES" );
    private static org.apache.juli.logging.Log log=
    protected static org.apache.juli.logging.Log log
    protected static org.apache.juli.logging.Log log =
    protected static org.apache.juli.logging.Log log =
    protected static org.apache.juli.logging.Log log
    protected static org.apache.juli.logging.Log log =
    protected static org.apache.juli.logging.Log log
    protected static org.apache.juli.logging.Log log
    protected static org.apache.juli.logging.Log log = 
======= fetch "public void deregister(Http11NioProcessor processor) {" 799b934^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    protected static org.apache.juli.logging.Log log
    protected static org.apache.juli.logging.Log log
    protected org.apache.juli.logging.Log log =
======= fetch "private static String unqualify(String path) {" 799b934^:"java/org/apache/jasper/compiler/SmapUtil.java"

        private org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    private org.apache.juli.logging.Log log=
    private org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log =
    private static org.apache.juli.logging.Log log =
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log log=
    private static org.apache.juli.logging.Log logger =
    private static org.apache.juli.logging.Log logger =
    static org.apache.juli.logging.Log logger = 
    static org.apache.juli.logging.Log log =
    private static org.apache.juli.logging.Log log =
    private static org.apache.juli.logging.Log logger =
    private static org.apache.juli.logging.Log log=

    static public String APR_ANYADDR = "0.0.0.0";

    public static ChannelData[] EMPTY_DATA_ARRAY = new ChannelData[0];

 * 
 * 

======= fetch "public String getServletInfo() {" 7849435^:"java/javax/servlet/GenericServlet.java"

     *					that contains configutation
======= fetch "protected long getLastModified(" 7849435^:"java/javax/servlet/http/HttpServlet.java"

     *                  uses to return the headers to the clien
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "protected JspWriter(int bufferSize, boolean autoFlush) {" 7849435^:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occured while writing
======= fetch "abstract public void include(String relativeUrlPath, boolean flush)" 7849435^:"java/javax/servlet/jsp/PageContext.java"

     * This method is kept for backwards compatiblity reasons.  Newly
 * the pagein the case where one tag invokes another (as can be
     * @throws javax.servlet.jsp.JspException Thrown if an error occured
 * when being pased to a TagLibraryValidator instance.
======= fetch "public PageData() {" 7849435^:"java/javax/servlet/jsp/tagext/PageData.java"

     * The stream is encoded in UTF-8.  Recall tht the XML view of a 
======= fetch "protected JspFragment getJspBody() {" 7849435^:"java/javax/servlet/jsp/tagext/SimpleTagSupport.java"

     * This addititional constraint can be exploited by a
======= fetch "public FunctionInfo getFunction(String name) {" 7849435^:"java/javax/servlet/jsp/tagext/TagLibraryInfo.java"

     * If a tag library is imported more than once and bound to different prefices, 
 * The JSP container is reponsible for locating an appropriate
     * This addititional constraint can be exploited by a

======= fetch "private ActionCode(int code) {" 39a78f4^:"java/org/apache/coyote/ActionCode.java"

    /** Action id, useable in switches and table indexes
 * This is the main interface to be implemented by a coyoute connector.
 * Adapter is the main interface to be impleneted by a coyote servlet container.
======= fetch "public Request() {" 39a78f4^:"java/org/apache/coyote/Request.java"

    // Time of the request - usefull to avoid repeated calls to System.currentTime
======= fetch "public Request() {" 39a78f4^:"java/org/apache/coyote/Request.java"

     * Get the instance id (or JVM route). Curently Ajp is sending it with each
======= fetch "public Request() {" 39a78f4^:"java/org/apache/coyote/Request.java"

     * 'negociated' at config time so both tomcat and apache share the same name.
 *  It is currently used only as a JMX artifact, to agregate the data
 * about the requests beeing processed.
======= fetch "public void setGlobalProcessor(RequestGroupInfo global) {" 39a78f4^:"java/org/apache/coyote/RequestInfo.java"

    // This is usefull for long-running requests only
======= fetch "public Locale getLocale() {" 39a78f4^:"java/org/apache/coyote/Response.java"

     * Called explicitely by user to set the Content-Language and
======= fetch "public String getContentLanguage() {" 39a78f4^:"java/org/apache/coyote/Response.java"

     * @param charset String containing the name of the chararacter encoding.
======= fetch "public int doWrite(ByteChunk chunk, Response res)" 39a78f4^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

            // 4 - hardcoded, byte[] marshalling overhead
======= fetch "public AjpAprProtocol() {" 39a78f4^:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

     * Adapter which will process the requests recieved by this endpoint.
======= fetch "public int doWrite(ByteChunk chunk, Response res)" 39a78f4^:"java/org/apache/coyote/ajp/AjpProcessor.java"

            // 4 - hardcoded, byte[] marshalling overhead
======= fetch "public AjpProtocol() {" 39a78f4^:"java/org/apache/coyote/ajp/AjpProtocol.java"

     * Adapter which will process the requests recieved by this endpoint.
     * Content delimitator for the request (if false, the connection will
     * Minimum contentsize to make compression.
======= fetch "public void setNoCompressionUserAgents(String noCompressionUserAgents) {" 39a78f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

     * Add a mime-type which will be compressable
======= fetch "public void addCompressableMimeType(String mimeType) {" 39a78f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

     * Set compressable mime-type list (this method is best when used with
======= fetch "protected boolean isCompressable() {" 39a78f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        // Check if content is not allready gzipped
======= fetch "protected boolean isCompressable() {" 39a78f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        // If force mode, allways compress (test purposes only)
======= fetch "protected boolean isCompressable() {" 39a78f4^:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        // Check if suffisant len to trig the compression
======= fetch "public void nextRequest() {" 39a78f4^:"java/org/apache/coyote/http11/AbstractInputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "public void addActiveFilter(OutputFilter filter) {" 39a78f4^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "public int doWrite(ByteChunk chunk, Response res)" 39a78f4^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "public void nextRequest() {" 39a78f4^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "public void endHeaders() {" 39a78f4^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * This method will write the contents of the specyfied message bytes 
======= fetch "protected void write(MessageBytes mb) {" 39a78f4^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * This method will write the contents of the specyfied message bytes 
======= fetch "protected void write(ByteChunk bc) {" 39a78f4^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * This method will write the contents of the specyfied char 
======= fetch "protected void write(CharChunk cc) {" 39a78f4^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * This method will write the contents of the specyfied byte 
======= fetch "public void write(byte[] b) {" 39a78f4^:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * This method will write the contents of the specyfied String to the 
======= fetch "public Http11AprProcessor(int headerBufferSize, AprEndpoint endpoint) {" 39a78f4^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

     * Content delimitator for the request (if false, the connection will
======= fetch "public Http11AprProcessor(int headerBufferSize, AprEndpoint endpoint) {" 39a78f4^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

     * Minimum contentsize to make compression.
======= fetch "public void setNoCompressionUserAgents(String noCompressionUserAgents) {" 39a78f4^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

     * Add a mime-type which will be compressable
======= fetch "public void addCompressableMimeType(String mimeType) {" 39a78f4^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

     * Set compressable mime-type list (this method is best when used with
======= fetch "public void setCompressableMimeTypes(String[] compressableMimeTypes) {" 39a78f4^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

     * Set compressable mime-type list
======= fetch "public void action(ActionCode actionCode, Object param) {" 39a78f4^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

            // Acknowlege request
======= fetch "public void parseHost(MessageBytes valueMB) {" 39a78f4^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

            // Default is what the socket tells us. Overriden if a host is
======= fetch "private boolean isCompressable() {" 39a78f4^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        // Check if content is not allready gzipped
======= fetch "private boolean isCompressable() {" 39a78f4^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        // If force mode, allways compress (test purposes only)
======= fetch "private boolean isCompressable() {" 39a78f4^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        // Check if suffisant len to trig the compression
======= fetch "public void action(ActionCode actionCode, Object param) {" 39a78f4^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            // Acknowlege request
======= fetch "public void parseHost(MessageBytes valueMB) {" 39a78f4^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            // Default is what the socket tells us. Overriden if a host is
======= fetch "public void action(ActionCode actionCode, Object param) {" 39a78f4^:"java/org/apache/coyote/http11/Http11Processor.java"

            // Acknowlege request
======= fetch "protected void parseHost(MessageBytes valueMB) {" 39a78f4^:"java/org/apache/coyote/http11/Http11Processor.java"

            // Default is what the socket tells us. Overriden if a host is
======= fetch "public void nextRequest() {" 39a78f4^:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "public void endRequest()" 39a78f4^:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

     * read operations, or if the given buffer is not big enough to accomodate
======= fetch "public int doRead(ByteChunk chunk, Request req)" 39a78f4^:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

     * Fill the internal buffer using data from the undelying input stream.
======= fetch "public void addActiveFilter(OutputFilter filter) {" 39a78f4^:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "public void nextRequest() {" 39a78f4^:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "public void endRequest()" 39a78f4^:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * Send an acknoledgement.
======= fetch "public void endHeaders() {" 39a78f4^:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "public int doWrite(ByteChunk chunk, Response res)" 39a78f4^:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "protected void commit()" 39a78f4^:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * This method will write the contents of the specyfied message bytes 
======= fetch "protected void write(MessageBytes mb) {" 39a78f4^:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * This method will write the contents of the specyfied message bytes 
======= fetch "protected void write(ByteChunk bc) {" 39a78f4^:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * This method will write the contents of the specyfied char 
======= fetch "protected void write(CharChunk cc) {" 39a78f4^:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * This method will write the contents of the specyfied byte 
======= fetch "public void write(byte[] b) {" 39a78f4^:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * This method will write the contents of the specyfied String to the 
======= fetch "public InternalInputBuffer(Request request, int headerBufferSize) {" 39a78f4^:"java/org/apache/coyote/http11/InternalInputBuffer.java"

     * read operations, or if the given buffer is not big enough to accomodate
======= fetch "public void nextRequest() {" 39a78f4^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

     * read operations, or if the given buffer is not big enough to accomodate
======= fetch "public boolean parseRequestLine(boolean useAvailableDataOnly)" 39a78f4^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

                    if (!fill(true, false)) //reques line parsing
======= fetch "public NioSelectorPool getSelectorPool() {" 39a78f4^:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "public void recycle() {" 39a78f4^:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "public boolean isWritable() {" 39a78f4^:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

     * Send an acknoledgement.
======= fetch "private synchronized int writeToSocket(ByteBuffer bytebuffer, boolean block, boo" 39a78f4^:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "public void endRequest()" 39a78f4^:"java/org/apache/coyote/http11/InternalOutputBuffer.java"

     * Send an acknoledgement.
======= fetch "public void sendAck()" 39a78f4^:"java/org/apache/coyote/http11/InternalOutputBuffer.java"

     * @throws IOException an undelying I/O error occured
======= fetch "public int doRead(ByteChunk chunk, Request req)" 39a78f4^:"java/org/apache/coyote/http11/filters/VoidInputFilter.java"

     * Set the associated reauest.
======= fetch "private final Target getTarget(EvaluationContext ctx) throws ELException {" 39a78f4^:"java/org/apache/el/parser/AstValue.java"

        // if our base is null (we know there are more properites to evaluate)
======= fetch "public ParseException(String message) {" 39a78f4^:"java/org/apache/el/parser/ParseException.java"

   * followng this token will (therefore) be the first error token.

     * Default URLs to download the pluging for Netscape and IE.
     * Is the generation of SMAP info for JSR45 debuggin suppressed?
======= fetch "public boolean getClassDebugInfo() {" 6ce7032^:"java/org/apache/jasper/EmbeddedServletOptions.java"

     * Background JSP compile thread check intervall
======= fetch "public boolean getDevelopment() {" 6ce7032^:"java/org/apache/jasper/EmbeddedServletOptions.java"

     * Is the generation of SMAP info for JSR45 debuggin suppressed?
 * convienient to catch just this at the top-level. 
======= fetch "public boolean getDevelopment() {" 6ce7032^:"java/org/apache/jasper/JspC.java"

     * Is the generation of SMAP info for JSR45 debuggin suppressed?
======= fetch "public boolean getFailOnError() {" 6ce7032^:"java/org/apache/jasper/JspC.java"

     * Obtain JSP configuration informantion specified in web.xml.
======= fetch "protected void locateUriRoot( File f ) {" 6ce7032^:"java/org/apache/jasper/JspC.java"

                    // If there is no acceptible candidate, uriRoot will
======= fetch "public JspCompilationContext(String jspUri," 6ce7032^:"java/org/apache/jasper/JspCompilationContext.java"

            // strip the basde slash since it will be combined with the
======= fetch "public String resolveRelativeUri(String uri) {" 6ce7032^:"java/org/apache/jasper/JspCompilationContext.java"

        // a root directory deperator char
======= fetch "public void setPrototypeMode(boolean pm) {" 6ce7032^:"java/org/apache/jasper/JspCompilationContext.java"

     * derived package name directly mirrors the file heirachy of the JSP page.
     * A tag library is 'exposed' either explicitely in 
     * web.xml or implicitely via the uri tag in the TLD 
     * Obtain JSP configuration informantion specified in web.xml.  
 * Collect info about the page and nodes, and make them availabe through
======= fetch "public boolean isOutDated() {" 6ce7032^:"java/org/apache/jasper/compiler/Compiler.java"

     * has dependencies, the check is also extended to its dependeants, and so
     * on. This method can by overidden by a subclasses of Compiler.
 * Instead of a global mapper, a mapper is used for ecah call to EL
======= fetch "private void genPreambleImports() {" 6ce7032^:"java/org/apache/jasper/compiler/Generator.java"

     * Generation of static initializers in preamble. For example, dependant
======= fetch "public void visit(Node.UseBean n) throws JasperException {" 6ce7032^:"java/org/apache/jasper/compiler/Generator.java"

             * Check if bean is alredy there
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" 6ce7032^:"java/org/apache/jasper/compiler/Generator.java"

                // Initilaize local variables used in this method.
======= fetch "public void visit(Node.TemplateText n) throws JasperException {" 6ce7032^:"java/org/apache/jasper/compiler/Generator.java"

            int srcLine = 0; // relative to starting srouce line
======= fetch "private String getExpressionFactoryVar() {" 6ce7032^:"java/org/apache/jasper/compiler/Generator.java"

         * shortName and endcoded to make the resultant string a valid Java
 * impementation.
======= fetch "private JarScannerFactory() {" 6ce7032^:"java/org/apache/jasper/compiler/JarScannerFactory.java"

     * Obtain the {@link JarScanner} associated with the specificed {@link
======= fetch "private JarScannerFactory() {" 6ce7032^:"java/org/apache/jasper/compiler/JspConfig.java"

                        // The url patterns are reconstructed as the follwoing:
    // Flag set to delay incrmenting tagDependentNesting until jsp:body
======= fetch "private int registerSourceFile(final String file) {" 6ce7032^:"java/org/apache/jasper/compiler/JspReader.java"

     * gets a uniq identifier (which is the index in the array of source
======= fetch "private boolean popFile() throws JasperException {" 6ce7032^:"java/org/apache/jasper/compiler/JspReader.java"

        // is not set to null just for convience, for it maybe used to
 * is dependent upon.  If a dpendent file changes the JSP page
======= fetch "public int getJspCount() {" 6ce7032^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

     * applicaiton context.
======= fetch "public PermissionCollection getPermissionCollection() {" 6ce7032^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

     * Process a "destory" event for this web application context.
======= fetch "public static String toJavaSourceType(String type) {" 6ce7032^:"java/org/apache/jasper/compiler/JspUtil.java"

     * replacment of '$' with '.' of a binary name would not work, as '$' is a
 * An internal data representation of a JSP page or a JSP docuement (XML). Also
 * included here is a visitor class for tranversing nodes.
======= fetch "private void addToParent(Node parent) {" 6ce7032^:"java/org/apache/jasper/compiler/Node.java"

         * page's bom.
======= fetch "public NamedAttribute(String qName, Attributes attrs," 6ce7032^:"java/org/apache/jasper/compiler/Node.java"

                // Mandatary attribute "name" will be checked in Validator
======= fetch "public boolean isAllSpace() {" 6ce7032^:"java/org/apache/jasper/compiler/Node.java"

         *            The postion of the source line, relative to the line at
======= fetch "public void addSmap(int srcLine) {" 6ce7032^:"java/org/apache/jasper/compiler/Node.java"

     * Auxillary classes used in Node
======= fetch "private void checkUniqueName(String name, String type, Node n," 6ce7032^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

         * Perform miscellean checks after the nodes are visited.
======= fetch "void postCheck() throws JasperException {" 6ce7032^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

     *            the url for the Jar containign the tag file 
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," 6ce7032^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                    // dependency exists. The circularily dependant tag
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," 6ce7032^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            // Add the dependants for this tag file to its parent's
            // dependant list. The only reliable dependency information
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" 6ce7032^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

     * assumed to have been proccessed and encapsulated as TagFileInfo in the
======= fetch "private TagInfo createTagInfo(TreeNode elem, String jspVersion)" 6ce7032^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

     * @return TagInfo correspoding to tag file directives
======= fetch "public void doVisit(Node n) throws JasperException {" 6ce7032^:"java/org/apache/jasper/compiler/TextOptimizer.java"

         * The following directis are ignored in text concatenation
    // Constructor and Initilizations
 * some page global value (such as those from page direcitves) are stored, for
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" 6ce7032^:"java/org/apache/jasper/compiler/Validator.java"

             * The bodyconet of a SimpleTag cannot be JSP.
======= fetch "private void checkXmlAttributes(Node.CustomTag n," 6ce7032^:"java/org/apache/jasper/compiler/Validator.java"

                                    // The String litteral must be castable to what is declared as type
 * This interface allows the plugin author to make inqueries about the
     * used to declare an innter class, a method, or a class variable.
     * Generate codesto evaluate value of a attribute in the custom tag
     * is deemed too compilicated for optimization.
======= fetch "public void clear() throws IOException {" 6ce7032^:"java/org/apache/jasper/runtime/BodyContentImpl.java"

     * mehtod will not throw an IOException if the buffer has already been
======= fetch "public void syncBeginTagFile() {" 6ce7032^:"java/org/apache/jasper/runtime/JspContextWrapper.java"

======= fetch "public int getJspReloadCount() {" 6ce7032^:"java/org/apache/jasper/servlet/JspServlet.java"

     * @param request The servlet requset we are processing
======= fetch "public void setServletClassLastModifiedTime(long lastModified) {" 6ce7032^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

     * when compiling tag files with circular dependencies.  A prototpe
======= fetch "public void doTag(TagPluginContext ctxt) {" 6ce7032^:"java/org/apache/jasper/tagplugins/jstl/core/Import.java"

            //assign appropriate value tp the charset
 * Constructors are provided to easliy create such wrappers.
======= fetch "public int read(char ch[], int offset, int length) throws IOException {" 6ce7032^:"java/org/apache/jasper/xmlparser/UTF8Reader.java"

        //       error. By signalling the error on the next block read we
======= fetch "final boolean load(int offset, boolean changeEntity)" 6ce7032^:"java/org/apache/jasper/xmlparser/XMLEncodingDetector.java"

     * invocation when it's read() method is inovked, but uses the
======= fetch "public Object run() {" 6ce7032^:"java/org/apache/juli/ClassLoaderLogManager.java"

     * @throws IOException Errot
 * it easier to grep the logs. The only excpetion is stacktraces which are
 * always preceeded by whitespace to make it simple to skip them.
                // it is also possible that the user modifed jre/lib/logging.properties - 
======= fetch "public final void fatal(Object message, Throwable t) {" 6ce7032^:"java/org/apache/juli/logging/DirectJDKLog.java"

    // is bad - design by comitee can be really bad ! The impact on performance of 
 * The implemention should ensure, though, that this ordering behaves
 * Note that this implementation is not just a wrapper arround JDK logging ( like
     * For example, running the following ant scriplet:
======= fetch "public static void releaseAll() {" 6ce7032^:"java/org/apache/juli/logging/LogFactory.java"

     * the specified object's class has overidden the toString method.

======= fetch "public NamingEntry(String name, Object value, int type) {" 21e86e6^:"java/org/apache/naming/NamingEntry.java"

     * The type instance variable is used to avoid unsing RTTI when doing
======= fetch "public void postDeregister() {" 21e86e6^:"java/org/apache/naming/NamingService.java"

     * Retruns the Catalina component name.
     * Retruns the JNDI component name.
     * @param auth Resource authetication
======= fetch "public ResourceRef(String resourceClass, String description," 21e86e6^:"java/org/apache/naming/ResourceRef.java"

     * @param auth Resource authetication
     * Crete a new EJB instance.
     * Crete a new EJB instance using OpenEJB.
     * Crete a new Resource env instance.
 * Object factory for User trasactions.
     * Crete a new User transaction instance.
======= fetch "public abstract DirContext getSchemaClassDefinition(String name)" 21e86e6^:"java/org/apache/naming/resources/BaseDirContext.java"

     * @return an enumeration of SearchResults of the objects that satisy the 
======= fetch "public DirContextURLConnection(DirContext context, URL url) {" 21e86e6^:"java/org/apache/naming/resources/DirContextURLConnection.java"

     * Connect to the DirContext, and retrive the bound object, as well as
======= fetch "public DirContext getSchemaClassDefinition(String name)" 21e86e6^:"java/org/apache/naming/resources/FileDirContext.java"

     * @return an enumeration of SearchResults of the objects that satisy the
======= fetch "protected File file(String name) {" 21e86e6^:"java/org/apache/naming/resources/FileDirContext.java"

     * @return Vector containg NamingEntry objects
======= fetch "protected void cacheLoad(CacheEntry entry) {" 21e86e6^:"java/org/apache/naming/resources/ProxyDirContext.java"

        // Retriving object
 * Encapsultes the contents of a resource.
======= fetch "public boolean unload(String name) {" 21e86e6^:"java/org/apache/naming/resources/ResourceCache.java"

     * Find a map elemnt given its name in a sorted array of map elements.
======= fetch "public DirContext getSchemaClassDefinition(String name)" 21e86e6^:"java/org/apache/naming/resources/WARDirContext.java"

     * @return an enumeration of SearchResults of the objects that satisy the 

     * @param buf containg the bytes to write.
     * @return String with up to len bytes readed
     * @param perm Permissions for the new direcoty.
     * @param perm Permissions for the new direcoty.
======= fetch "public static native long seek(long thefile, int where, long offset)" ed97da7^:"java/org/apache/tomcat/jni/File.java"

     * Write data from aray of byte arrays to the specified file.
======= fetch "public static native long seek(long thefile, int where, long offset)" ed97da7^:"java/org/apache/tomcat/jni/File.java"

     * Write data from aray of byte arrays to the specified file,
======= fetch "public static native long seek(long thefile, int where, long offset)" ed97da7^:"java/org/apache/tomcat/jni/File.java"

     * @return The readed character
======= fetch "public static native int getc(long thefile)" ed97da7^:"java/org/apache/tomcat/jni/File.java"

     * This function should be used in preference to explict manipulation
======= fetch "public static native int getc(long thefile)" ed97da7^:"java/org/apache/tomcat/jni/File.java"

     * @param file The file to retrive flags.
======= fetch "public static native long create(String path, long cont)" ed97da7^:"java/org/apache/tomcat/jni/Local.java"

     *                the number of instances is unlimite.
     * Get the name of the system default characer set.
     * data can't be retreved on this system.
    public static final int APR_POLLNVAL = 0x040; /** Descriptior invalid */
======= fetch "public static native long create(int size, long p, int flags, long ttl)" ed97da7^:"java/org/apache/tomcat/jni/Poll.java"

     * descriptor is signalled in apr_pollset_poll().
======= fetch "public static native int add(long pollset, long sock," ed97da7^:"java/org/apache/tomcat/jni/Poll.java"

     * @param descriptors Array of signalled descriptors (output parameter)
     *        The desctiptor array must be two times the size of pollset.
======= fetch "public static native int add(long pollset, long sock," ed97da7^:"java/org/apache/tomcat/jni/Poll.java"

     * @return Number of signalled descriptors (output parameter)
======= fetch "public static native int poll(long pollset, long timeout," ed97da7^:"java/org/apache/tomcat/jni/Poll.java"

     * @param descriptors Array of signalled descriptors (output parameter)
     *        The desctiptor array must be the size of pollset.
======= fetch "public static native int poll(long pollset, long timeout," ed97da7^:"java/org/apache/tomcat/jni/Poll.java"

     * @return Number of signalled descriptors (output parameter)
======= fetch "public static native int maintain(long pollset, long [] descriptors," ed97da7^:"java/org/apache/tomcat/jni/Poll.java"

     *        The desctiptor array must be two times the size of pollset.
     * Object attached to the pool will be globaly referenced
     * untill the pool is cleared or dataSet is called with the null data.
    /** a restart is occuring, perform any necessary cleanup (including
    /** a health check is occuring, for most maintainence functions
     * Allocate apr_proc_t stucture from pool
     * a hardware accellerator card for crypto operations.
======= fetch "public static native long newBIO(long pool, BIOCallback callback)" ed97da7^:"java/org/apache/tomcat/jni/SSL.java"

     * Close BIO and derefrence callback object
======= fetch "public static native long newBIO(long pool, BIOCallback callback)" ed97da7^:"java/org/apache/tomcat/jni/SSL.java"

     * @param file File contatining DH params.
======= fetch "public static native long make(long pool, int protocol, int mode)" ed97da7^:"java/org/apache/tomcat/jni/SSLContext.java"

     * Asssociate BIOCallback for input or output data capture.
======= fetch "public static native long make(long pool, int protocol, int mode)" ed97da7^:"java/org/apache/tomcat/jni/SSLContext.java"

     * [WARN]   -- Varning messages
======= fetch "public static native long make(long pool, int protocol, int mode)" ed97da7^:"java/org/apache/tomcat/jni/SSLContext.java"

     * renegotation with the reconfigured Cipher Suite after the HTTP request
======= fetch "public static native boolean setCertificateChainFile(long ctx, String file," ed97da7^:"java/org/apache/tomcat/jni/SSLContext.java"

     *                 is encrypted, password prompt will be dispayed.
======= fetch "public static native boolean setCACertificate(long ctx, String file," ed97da7^:"java/org/apache/tomcat/jni/SSLContext.java"

     * is established. In per-directory context it forces a SSL renegotation with
     * Create and make accessable a shared memory segment.
     *         Not all plaforms support anonymous shared memory segments, but in
     *         some cases it is prefered over other types of shared memory
======= fetch "public static native int optGet(long sock, int opt)" ed97da7^:"java/org/apache/tomcat/jni/Socket.java"

     *           elapsess with no data read or written
======= fetch "public static native long pool(long thesocket)" ed97da7^:"java/org/apache/tomcat/jni/Socket.java"

     * Private method for geting the socket struct members
     * @param socket The soocket to use
======= fetch "public static native long pool(long thesocket)" ed97da7^:"java/org/apache/tomcat/jni/Socket.java"

     * @return The stucture member address
    /** number of miliseconds per microsecond */
======= fetch "public static long msec(long t)" ed97da7^:"java/org/apache/tomcat/jni/Time.java"

     * number of microseconds since 00:00:00 january 1, 1970 UTC
======= fetch "public static native String groupname(long groupid, long p)" ed97da7^:"java/org/apache/tomcat/jni/User.java"

     * @return APR_SUCCESS if the apr_uid_t strutures identify the same user,
======= fetch "public static native String groupname(long groupid, long p)" ed97da7^:"java/org/apache/tomcat/jni/User.java"

     * @return APR_SUCCESS if the apr_gid_t strutures identify the same group,
    /** Get the trimed text content of a node or null if there is no text
======= fetch "public static String getContent(Node n ) {" ed97da7^:"java/org/apache/tomcat/util/DomUtil.java"

     * @param parent lookup direct childs
======= fetch "public static boolean hasHook(Object obj, String methodN) {" ed97da7^:"java/org/apache/tomcat/util/IntrospectionUtils.java"

                    // check if it's overriden
 *  This uses the standard JDK mechansim - a reader - but provides mechanisms
======= fetch "public ReadConvertor( IntermediateInputStream in, String enc )" ed97da7^:"java/org/apache/tomcat/util/buf/B2CConverter.java"

    /** Overriden - will do nothing but reset internal state.
======= fetch "public  final void recycle() {" ed97da7^:"java/org/apache/tomcat/util/buf/B2CConverter.java"

    /** Input interface, used when the buffer is emptiy
======= fetch "public int getLength() {" ed97da7^:"java/org/apache/tomcat/util/buf/ByteChunk.java"

     *  If -1 or not set, the buffer will grow undefinitely.
======= fetch "public int substract( byte src[], int off, int len )" ed97da7^:"java/org/apache/tomcat/util/buf/ByteChunk.java"

     *  You can also call it explicitely to force the data to be written.
======= fetch "public String toStringInternal() {" ed97da7^:"java/org/apache/tomcat/util/buf/ByteChunk.java"

             it's safer to use the "clasical" new String().
 *  This uses the standard JDK mechansim - a writer - but provides mechanisms
======= fetch "public  final void flushBuffer() throws IOException {" ed97da7^:"java/org/apache/tomcat/util/buf/C2BConverter.java"

 *  Special writer class, where close() is overritten. The default implementation
 *  would set byteOutputter to null, and the writter can't be recycled. 
======= fetch "public  final void flushBuffer() throws IOException {" ed97da7^:"java/org/apache/tomcat/util/buf/C2BConverter.java"

    // stream with flush() and close(). overriden.
======= fetch "public WriteConvertor( IntermediateOutputStream out, String enc )" ed97da7^:"java/org/apache/tomcat/util/buf/C2BConverter.java"

    /** Overriden - will do nothing but reset internal state.
======= fetch "public  final void recycle() {" ed97da7^:"java/org/apache/tomcat/util/buf/C2BConverter.java"

 * Utilities to manipluate char chunks. While String is
 * designed as imutable and secure objects.
======= fetch "public void realWriteChars(char cbuf[], int off, int len)" ed97da7^:"java/org/apache/tomcat/util/buf/CharChunk.java"

    // -1: grow undefinitely
======= fetch "public void setChars( char[] c, int off, int len ) {" ed97da7^:"java/org/apache/tomcat/util/buf/CharChunk.java"

     *  If -1 or not set, the buffer will grow undefinitely.
======= fetch "public void setEncoding( String enc ) {" ed97da7^:"java/org/apache/tomcat/util/buf/MessageBytes.java"

======= fetch "public void resetStringValue() {" ed97da7^:"java/org/apache/tomcat/util/buf/MessageBytes.java"

======= fetch "public boolean equals(MessageBytes mb) {" ed97da7^:"java/org/apache/tomcat/util/buf/MessageBytes.java"

======= fetch "public static String toString(ByteChunk bc) {" ed97da7^:"java/org/apache/tomcat/util/buf/StringCache.java"

                    // while waiting fot the lock, just return the toString value
======= fetch "public void convert( ByteChunk mb, boolean query )" ed97da7^:"java/org/apache/tomcat/util/buf/UDecoder.java"

======= fetch "public void urlEncode( Writer buf, byte bytes[], int off, int len)" ed97da7^:"java/org/apache/tomcat/util/buf/UEncoder.java"

     * Utility funtion to re-encode the URL.
======= fetch "public void remove( int i ) {" ed97da7^:"java/org/apache/tomcat/util/collections/MultiMap.java"

    /** Create a new, unitialized entry. 
    Each nextElement() is O(n) ( a comparation is
======= fetch "Each nextElement() is O(n) ( a comparation is" ed97da7^:"java/org/apache/tomcat/util/collections/MultiMapNamesEnumeration.java"

    This is less frequesnt than add() -
======= fetch "we want to keep add O(1)." ed97da7^:"java/org/apache/tomcat/util/collections/MultiMapNamesEnumeration.java"

    // we allways to toString and unique.
    /** Namespace uri to assoicate with subsequent <code>Rule</code>'s */
======= fetch "public CallMethodRule(int targetOffset, String methodName) {" ed97da7^:"java/org/apache/tomcat/util/digester/CallMethodRule.java"

     *  zero for a single argument from the body of ths element
======= fetch "public CallMethodRule(int targetOffset, String methodName) {" ed97da7^:"java/org/apache/tomcat/util/digester/CallMethodRule.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public CallMethodRule(" ed97da7^:"java/org/apache/tomcat/util/digester/CallMethodRule.java"

     *  zero for a single argument from the body of ths element
======= fetch "public CallMethodRule(" ed97da7^:"java/org/apache/tomcat/util/digester/CallMethodRule.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public CallMethodRule(  int targetOffset," ed97da7^:"java/org/apache/tomcat/util/digester/CallMethodRule.java"

     *  zero for a single argument from the body of ths element
======= fetch "public CallMethodRule(  int targetOffset," ed97da7^:"java/org/apache/tomcat/util/digester/CallMethodRule.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public CallMethodRule(" ed97da7^:"java/org/apache/tomcat/util/digester/CallMethodRule.java"

     *  zero for a single argument from the body of ths element
======= fetch "public CallMethodRule(" ed97da7^:"java/org/apache/tomcat/util/digester/CallMethodRule.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public Digester(SAXParser parser) {" ed97da7^:"java/org/apache/tomcat/util/digester/Digester.java"

     * properties only affect the SAXParser and emtpy constructor.
======= fetch "public void setNamespaceAware(boolean namespaceAware) {" ed97da7^:"java/org/apache/tomcat/util/digester/Digester.java"

     * Set the publid id of the current file being parse.
======= fetch "public void addCallMethod(String pattern, String methodName," ed97da7^:"java/org/apache/tomcat/util/digester/Digester.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public void addCallMethod(String pattern, String methodName," ed97da7^:"java/org/apache/tomcat/util/digester/Digester.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public void addSetNext(String pattern, String methodName) {" ed97da7^:"java/org/apache/tomcat/util/digester/Digester.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public void addSetTop(String pattern, String methodName) {" ed97da7^:"java/org/apache/tomcat/util/digester/Digester.java"

     *  (if you wish to use a primitive type, specify the corresonding
 * needed before the object can be created.  A common senario is for the
     * Create a <code>SAXParser</code> configured to support XML Scheman and DTD
 *   only the XML content under the element the rule was trigged on.</li>
 * class that imlements this interface:</p>
     * order that they were orginally registered.
======= fetch "public SetNextRule(Digester digester, String methodName) {" ed97da7^:"java/org/apache/tomcat/util/digester/SetNextRule.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public SetNextRule(String methodName) {" ed97da7^:"java/org/apache/tomcat/util/digester/SetNextRule.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public SetNextRule(String methodName," ed97da7^:"java/org/apache/tomcat/util/digester/SetNextRule.java"

     * to introspect the relevent objects so that the right method can be called.
======= fetch "public SetPropertiesRule(String attributeName, String propertyName) {" ed97da7^:"java/org/apache/tomcat/util/digester/SetPropertiesRule.java"

     * <p>Constructor allows attribute->property mapping to be overriden.</p>
======= fetch "public SetPropertiesRule(String attributeName, String propertyName) {" ed97da7^:"java/org/apache/tomcat/util/digester/SetPropertiesRule.java"

     * property name, then this indicates that the attibute should be ignored.</p>
======= fetch "public SetPropertyRule(String name, String value) {" ed97da7^:"java/org/apache/tomcat/util/digester/SetPropertyRule.java"

     *  have a writeable property of the specified name
======= fetch "public SetRootRule(Digester digester, String methodName) {" ed97da7^:"java/org/apache/tomcat/util/digester/SetRootRule.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public SetRootRule(String methodName) {" ed97da7^:"java/org/apache/tomcat/util/digester/SetRootRule.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public SetRootRule(String methodName," ed97da7^:"java/org/apache/tomcat/util/digester/SetRootRule.java"

     * to introspect the relevent objects so that the right method can be called.
======= fetch "public SetTopRule(Digester digester, String methodName) {" ed97da7^:"java/org/apache/tomcat/util/digester/SetTopRule.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public SetTopRule(String methodName) {" ed97da7^:"java/org/apache/tomcat/util/digester/SetTopRule.java"

     *  (if you wish to use a primitive type, specify the corresonding
======= fetch "public SetTopRule(String methodName," ed97da7^:"java/org/apache/tomcat/util/digester/SetTopRule.java"

     * to introspect the relevent objects so that the right method can be called.
======= fetch "public Digester getDigester() {" ed97da7^:"java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java"

    /** Sets digeseter using these Rules */
 * Usefull methods for Content-Type processing
======= fetch "public int getCookieCount() {" ed97da7^:"java/org/apache/tomcat/util/http/Cookies.java"

    /** Register a new, unitialized cookie. Cookies are recycled, and
======= fetch "protected final void processCookieHeader(byte bytes[], int off, int len){" ed97da7^:"java/org/apache/tomcat/util/http/Cookies.java"

                    // at the last qoute. This must be dealt with
======= fetch "protected final void processCookieHeader(byte bytes[], int off, int len){" ed97da7^:"java/org/apache/tomcat/util/http/Cookies.java"

                        // getToken returns the position at the delimeter
======= fetch "private static final int getTokenEndPosition(byte bytes[], int off, int end," ed97da7^:"java/org/apache/tomcat/util/http/Cookies.java"

     * Given a starting position after an initial quote chracter, this gets
 *  For input headers it is possible to use the MessageByte for Fileds - so no GC
======= fetch "private void removeHeader(int idx) {" ed97da7^:"java/org/apache/tomcat/util/http/MimeHeaders.java"

    Each nextElement() is O(n) ( a comparation is
======= fetch "Each nextElement() is O(n) ( a comparation is" ed97da7^:"java/org/apache/tomcat/util/http/MimeHeaders.java"

    This is less frequesnt than add() -
     *         for storing the contensts of the file.
 *   close-delimiter := "--" boudary "--"<br>
======= fetch "private void notifyListener() {" ed97da7^:"java/org/apache/tomcat/util/http/fileupload/MultipartStream.java"

     * The index of last valid characer in the buffer + 1.
======= fetch "private void notifyListener() {" ed97da7^:"java/org/apache/tomcat/util/http/fileupload/MultipartStream.java"

        // We prepend CR/LF to the boundary to chop trailng CR/LF from
======= fetch "public boolean skipPreamble()" ed97da7^:"java/org/apache/tomcat/util/http/fileupload/MultipartStream.java"

            // Read boundary - if succeded, the stream contains an
======= fetch "private final void internalMapWrapper(Context context, CharChunk path," ed97da7^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

     * Find a map elemnt given its name in a sorted array of map elements.
======= fetch "private static final int find(MapElement[] map, CharChunk name) {" ed97da7^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

     * Find a map elemnt given its name in a sorted array of map elements.
======= fetch "private static final int find(MapElement[] map, CharChunk name," ed97da7^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

     * Find a map elemnt given its name in a sorted array of map elements.
======= fetch "private static final int findIgnoreCase(MapElement[] map, CharChunk name) {" ed97da7^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

     * Find a map elemnt given its name in a sorted array of map elements.
======= fetch "public void setSetMethod(String setMethod) {" ed97da7^:"java/org/apache/tomcat/util/modeler/AttributeInfo.java"

     * Is this attribute writeable by management applications?
 *  - some of the gratuituous flexibility removed - instead this is more predictive and
 *     supportd.</li>
======= fetch "the methods ( before 1.1 final )" ed97da7^:"java/org/apache/tomcat/util/modeler/Registry.java"

    /** List of managed byeans, keyed by class name
======= fetch "public void stop() {" ed97da7^:"java/org/apache/tomcat/util/modeler/Registry.java"

     * This method should be used to explicitely load metadata - but this is not
======= fetch "public void stop() {" ed97da7^:"java/org/apache/tomcat/util/modeler/Registry.java"

     * in the same pacakge.
======= fetch "protected boolean isBeanCompatible(Class<?> javaType) {" ed97da7^:"java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java"

     * @param getAttMap The readable attributess map
     * Use endfile for sending static files.
======= fetch "protected void destroy() {" ed97da7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            // exit, otherwise parallel descturction of sockets which are still
======= fetch "public void run() {" ed97da7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

         * be 62 (reocmpiling APR is necessary to remove this limitation).
======= fetch "protected void destroy() {" ed97da7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            // exit, otherwise parallel descturction of sockets which are still
======= fetch "protected void destroy() {" ed97da7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

         * @param data containing the reference to the data which should be snet
======= fetch "public void run() {" ed97da7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                // Close the socket, as the reponse would be incomplete
======= fetch "public void run() {" ed97da7^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                // Close the socket, as the reponse would be incomplete
 * plain ol' server sockets.
======= fetch "protected boolean processKey(SelectionKey sk, KeyAttachment attachment) {" ed97da7^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                                //invokations for both read and write on separate threads
======= fetch "protected void timeout(int keyCount, boolean hasEvents) {" ed97da7^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                        reg(key,ka,0);//avoid multiple calls, this gets reregistered after invokation
======= fetch "protected ServerSocketFactory () {" ed97da7^:"java/org/apache/tomcat/util/net/ServerSocketFactory.java"

     *  Note that the "prefered" mechanism is to
======= fetch "void init() throws IOException {" ed97da7^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

     * Gets the intialized trust managers.

     * @param maxAge
======= fetch "public String getClassLoader() {" c52b1ba^:"java/org/apache/catalina/ant/jmx/JMXAccessorCreateTask.java"

     * @param classLoader The classLoader to set.
======= fetch "private void internalDoFilter(ServletRequest request," c52b1ba^:"java/org/apache/catalina/core/ApplicationFilterChain.java"

     * Invoke the next filter in this chain, passing the specified request
     * and response.  If there are no more filters in this chain, invoke
     * the <code>service()</code> method of the servlet itself.
     *
     * @param request The servlet request we are processing
     * @param response The servlet response we are creating
     *
======= fetch "public void setContainer(Container container) {" c52b1ba^:"java/org/apache/catalina/core/StandardContextValve.java"

     * @param valveContext Valve context used to forward to the next Valve
======= fetch "public final void invoke(Request request, Response response)" c52b1ba^:"java/org/apache/catalina/core/StandardContextValve.java"

     * @param valveContext Valve context used to forward to the next Valve
======= fetch "public String getInfo() {" c52b1ba^:"java/org/apache/catalina/core/StandardEngineValve.java"

     * @param valveContext Valve context used to forward to the next Valve
======= fetch "public final void invoke(Request request, Response response)" c52b1ba^:"java/org/apache/catalina/core/StandardEngineValve.java"

     * @param valveContext Valve context used to forward to the next Valve
======= fetch "public String getInfo() {" c52b1ba^:"java/org/apache/catalina/core/StandardHostValve.java"

     * @param valveContext Valve context used to forward to the next Valve
======= fetch "public final void invoke(Request request, Response response)" c52b1ba^:"java/org/apache/catalina/core/StandardHostValve.java"

     * @param valveContext Valve context used to forward to the next Valve
======= fetch "public StandardWrapperValve() {" c52b1ba^:"java/org/apache/catalina/core/StandardWrapperValve.java"

     * @param valveContext Valve context used to forward to the next Valve
    * @param sendClusterDomainOnly Flag value.
    public DeltaSession() {
        this(null);
    }
======= fetch "public void memberDisappeared(Member member) {" c52b1ba^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

     * @param message
======= fetch "public static void setContentType(HttpServletResponse response," c52b1ba^:"java/org/apache/catalina/manager/StatusTransformer.java"

     * Process a GET request for the specified resource.
======= fetch "public static void setContentType(HttpServletResponse response," c52b1ba^:"java/org/apache/catalina/manager/StatusTransformer.java"

     * @param request The servlet request we are processing
     * @param response The servlet response we are creating
======= fetch "public static void setContentType(HttpServletResponse response," c52b1ba^:"java/org/apache/catalina/manager/StatusTransformer.java"

     * @exception IOException if an input/output error occurs
     * @exception ServletException if a servlet-specified error occurs
======= fetch "public Principal authenticate(String username, byte[] credentials) {" c52b1ba^:"java/org/apache/catalina/realm/CombinedRealm.java"

     * @param nOnce Unique (or supposedly unique) token which has been used
======= fetch "public Principal authenticate(String username, byte[] credentials) {" c52b1ba^:"java/org/apache/catalina/realm/CombinedRealm.java"

     * @param realm Realm name
======= fetch "public Principal authenticate(String username, String clientDigest," c52b1ba^:"java/org/apache/catalina/realm/CombinedRealm.java"

            String once, String nc, String cnonce, String qop,
======= fetch "public Principal authenticate(String username, String clientDigest," c52b1ba^:"java/org/apache/catalina/realm/CombinedRealm.java"

            authenticatedUser = realm.authenticate(username, clientDigest, once,
======= fetch "public Principal authenticate(String username, byte[] credentials) {" c52b1ba^:"java/org/apache/catalina/realm/LockOutRealm.java"

     * @param nOnce Unique (or supposedly unique) token which has been used
======= fetch "public Principal authenticate(String username, byte[] credentials) {" c52b1ba^:"java/org/apache/catalina/realm/LockOutRealm.java"

     * @param realm Realm name
======= fetch "public Principal authenticate(String username, String clientDigest," c52b1ba^:"java/org/apache/catalina/realm/LockOutRealm.java"

            String once, String nc, String cnonce, String qop,
======= fetch "public Principal authenticate(String username, String clientDigest," c52b1ba^:"java/org/apache/catalina/realm/LockOutRealm.java"

                once, nc, cnonce, qop, realmName, md5a2);
======= fetch "public boolean isRedirectStreams() {" c52b1ba^:"java/org/apache/catalina/startup/Embedded.java"

     * Enables or disables naming support.
======= fetch "public boolean isRedirectStreams() {" c52b1ba^:"java/org/apache/catalina/startup/Embedded.java"

     * @param useNaming The new use naming value
======= fetch "public SoapHeaderRule() {" c52b1ba^:"java/org/apache/catalina/startup/WebRuleSet.java"

     * @param bodyText The body text of this element
======= fetch "public ServiceQnameRule() {" c52b1ba^:"java/org/apache/catalina/startup/WebRuleSet.java"

     * @param bodyText The body text of this element
======= fetch "public ChannelCoordinator(ChannelReceiver receiver," c52b1ba^:"java/org/apache/catalina/tribes/group/ChannelCoordinator.java"

     * @param options int - sender options, see class documentation
     * @return ClusterMessage[] - the replies from the members, if any.
======= fetch "public int getOptions() {" c52b1ba^:"java/org/apache/catalina/tribes/io/ChannelData.java"

     * @param sets the message options
======= fetch "public int getDataPackageLength() {" c52b1ba^:"java/org/apache/catalina/tribes/io/ChannelData.java"

     * @param b byte[]
======= fetch "public boolean isAccessed() {" c52b1ba^:"java/org/apache/catalina/tribes/io/ObjectReader.java"

     * @param off offset
======= fetch "public boolean isAccessed() {" c52b1ba^:"java/org/apache/catalina/tribes/io/ObjectReader.java"

     * @return number of messages that was sent to callback
     * @param classLoader The class loader used to instantiate objects
======= fetch "public void clear() {" c52b1ba^:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

     * @param off - the offset to extract data from
======= fetch "public ChannelData extractPackage(boolean clearFromBuffer) throws java.io.IOExce" c52b1ba^:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

     * @param indata - the message data to be contained within the package
     * @param compressed - compression flag for the indata buffer
======= fetch "public static long toLong(byte[] b,int off){" c52b1ba^:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

     * Converts an integer to four bytes
     * @param n - the integer
     * @return - four bytes in an array
======= fetch "public static long toLong(byte[] b,int off){" c52b1ba^:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    /**
     * 
     * @param <any> long
     * @return use
     */
======= fetch "public static Serializable deserialize(byte[] data, int offset, int length, Clas" c52b1ba^:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

     * @param compress boolean
     * @return 
     * @param disableLoopbackMode - disable loopbackMode
======= fetch "public void run() {" c52b1ba^:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

     * @throws Exception
     * The number of milliseconds since this members was
======= fetch "public MemberImpl() {" c52b1ba^:"java/org/apache/catalina/tribes/membership/MemberImpl.java"

     * @param name - the name of this member, cluster unique
     * @param domain - the cluster domain name of this member
======= fetch "public MemberImpl() {" c52b1ba^:"java/org/apache/catalina/tribes/membership/MemberImpl.java"

     * @param aliveTime - the number of milliseconds since this member was created
======= fetch "protected void inc() {" c52b1ba^:"java/org/apache/catalina/tribes/membership/MemberImpl.java"

     * @throws Exception
======= fetch "public Object clone() {" c52b1ba^:"java/org/apache/catalina/tribes/membership/Membership.java"

     * @param name - has to be the name of the local member. Used to filter the local member from the cluster membership
     * @param key The key
======= fetch "public void stop() {" c52b1ba^:"java/org/apache/catalina/tribes/transport/nio/NioReceiver.java"

     * @throws Exception
======= fetch "public boolean getReadonly() {" c52b1ba^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

     * @param pathname The new pathname
======= fetch "public void setProxiesHeader(String proxiesHeader) {" c52b1ba^:"java/org/apache/catalina/valves/RemoteIpValve.java"

     * @param remoteIPHeader
======= fetch "public void setRemoteIpHeader(String remoteIpHeader) {" c52b1ba^:"java/org/apache/catalina/valves/RemoteIpValve.java"

     * Comma delimited list of proxies that are trusted when they appear in the {@link #remoteIPHeader} header. Can be expressed as a
======= fetch "public void setSSLSupport(SSLSupport sslSupport) {" c52b1ba^:"java/org/apache/coyote/http11/Http11Processor.java"

     * @param socket Socket from which the HTTP requests will be read
======= fetch "public Compiler getCompiler () {" c52b1ba^:"java/org/apache/jasper/compiler/ParserController.java"

     * @param jarFile The JAR file from which to read the included resource,
======= fetch "void postCheck() throws JasperException {" c52b1ba^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

     * @param tagfile
     * @param redeployMode if true, then the compiler will allow redeploying 
     * a tag library from the same jar, at the expense of slowing down the
     * server a bit. Note that this may only work on JDK 1.3.1_01a and later,
     * because of JDK bug 4211817 fixed in this release.
     * If redeployMode is false, a faster but less capable mode will be used.
    /**
     * Service Reference.
     * 
     * @param serviceClass Service class
     */
======= fetch "public HandlerRef(String refname, String handlerClass) {" c52b1ba^:"java/org/apache/naming/HandlerRef.java"

    /**
     * Service Reference.
     * 
     * @param serviceClass Service class
     */
    /**
     * Service Reference.
     * 
     * @param serviceClass Service class
     */
======= fetch "public ServiceRef(String refname, String serviceInterface, String[] serviceQname" c52b1ba^:"java/org/apache/naming/ServiceRef.java"

    /**
     * Service Reference.
     * 
     * @param serviceClass Service class
     */
======= fetch "public void release() {" c52b1ba^:"java/org/apache/naming/resources/BaseDirContext.java"

     * @param path The path to the desired resource
======= fetch "public void setTodir( File todir ) {" c52b1ba^:"java/org/apache/tomcat/buildutil/Txt2Html.java"

     * @param fileset The fileset to be converted.
======= fetch "public void addFileset( FileSet fs ) {" c52b1ba^:"java/org/apache/tomcat/buildutil/Txt2Html.java"

     * @param BuildException Thrown if an error occurs during execution of
======= fetch "public SetPropertiesRule(String[] attributeNames, String[] propertyNames) {" c52b1ba^:"java/org/apache/tomcat/util/digester/SetPropertiesRule.java"

     * @param name the local name if the parser is namespace aware, or just 
======= fetch "public SetPropertyRule(String name, String value) {" c52b1ba^:"java/org/apache/tomcat/util/digester/SetPropertyRule.java"

     * @param name the local name if the parser is namespace aware, or just 
======= fetch "public void removeNotificationListener(NotificationListener listener," c52b1ba^:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

    /**
     * Instantiates this MBean instance from data found in the persistent
     * store.  The data loaded could include attribute and operation values.
     * This method should be called during construction or initialization
     * of the instance, and before the MBean is registered with the
     * <code>MBeanServer</code>.
     *
     * <p><strong>IMPLEMENTATION NOTE</strong> - This implementation does
     * not support persistence.</p>
     *
     * @exception InstanceNotFoundException if the managed resource object
     *  cannot be found
     * @exception MBeanException if the initializer of the object throws
     *  an exception
     * @exception RuntimeOperationsException if an exception is reported
     *  by the persistence mechanism
     */
======= fetch "public void removeNotificationListener(NotificationListener listener," c52b1ba^:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

    /**
     * Capture the current state of this MBean instance and write it out
     * to the persistent store.  The state stored could include attribute
     * and operation values.  If one of these methods of persistence is not
     * supported, a "service not found" exception will be thrown.
     *
     * <p><strong>IMPLEMENTATION NOTE</strong> - This implementation does
     * not support persistence.</p>
     *
     * @exception InstanceNotFoundException if the managed resource object
     *  cannot be found
     * @exception MBeanException if the initializer of the object throws
     *  an exception, or persistence is not supported
     * @exception RuntimeOperationsException if an exception is reported
     *  by the persistence mechanism
     */
======= fetch "public void removeNotificationListener(NotificationListener listener," c52b1ba^:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

    /** Set the type of the mbean. This is used as a key to locate
     * the description in the Registry.
     *
     * @param type the type of classname of the modeled object
     */
======= fetch "public void removeNotificationListener(NotificationListener listener," c52b1ba^:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

    /** Set the type of the mbean. This is used as a key to locate
     * the description in the Registry.
     *
     * @param type the type of classname of the modeled object
     */
======= fetch "public void removeNotificationListener(NotificationListener listener," c52b1ba^:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

    /** Set the type of the mbean. This is used as a key to locate
     * the description in the Registry.
     */
======= fetch "public String getObjectName() {" c52b1ba^:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

    /**
     * Create and return a default <code>ModelMBeanInfo</code> object.
     */
======= fetch "public String getObjectName() {" c52b1ba^:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

    /**
     * Is the specified <code>ModelMBeanInfo</code> instance valid?
     *
     * <p><strong>IMPLEMENTATION NOTE</strong> - This implementation
     * does not check anything, but this method can be overridden
     * as required.</p>
     *
     * @param info The <code>ModelMBeanInfo object to check
     */
======= fetch "public int write(ByteBuffer buf, NioChannel socket, long writeTimeout,MutableInt" c52b1ba^:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"

     * @param selector Selector - the selector to use for blocking, if null then a busy read will be initiated
     * Invalidate the specified SSL session
     * @param   sessionId   The ID of the session to invalidate.

======= fetch "public Tomcat() {" ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

        // NOOP
======= fetch "public void setHostname(String s) {" ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

     * @return
======= fetch "public StandardContext addWebapp(String contextPath," ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

     *  @param host NULL for the 'default' host
======= fetch "public StandardContext addWebapp(String contextPath," ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

     *  @param dir base dir for the context, for static files. Must exist, 
======= fetch "public StandardWrapper addServlet(String contextPath," ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

     * Static version of {@link #addServlet(String, String, String)
======= fetch "public StandardWrapper addServlet(String contextPath," ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

     * Static version of {@link #addServlet(String, String, Servlet).
======= fetch "public void addUser(String user, String pass) {" ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

     * @see addUser 
======= fetch "public StandardContext addContext(StandardHost host," ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

            host = getHost();
======= fetch "public StandardContext addContext(StandardHost host," ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

        host.addChild(ctx);
======= fetch "public StandardContext addWebapp(StandardHost host," ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

                                     String url, String path) 
           throws ServletException {
======= fetch "public StandardContext addWebapp(StandardHost host," ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

            host = getHost();
======= fetch "public StandardContext addWebapp(StandardHost host," ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

        host.addChild(ctx);
======= fetch "public void initWebappDefaults(String contextPath) {" ab3620c^:"java/org/apache/catalina/startup/Tomcat.java"

     * Static version of {@link #initWebappDefaults(String)

     * cluster that this mananger is participating in the cluster.
     *  Note that the response object and depedent OutputStream and Writer are still 
     * request. The servlet should perform any needed cleanup as if it had recieved
 * asynchronous IO, recieving events when data is available for reading, and
     * Remove the tag library location forthe specified tag library URI.
     * @return true if namespace awarenes is enabled.
     * @return true if namespace awarenes is enabled.
     * this host's child webapps should be discovred and automatically 
     * that this host's child webapps should be discovred and automatically 
     * @return true if namespace awarenes is enabled.
     * Valve for this Pipeline (if any).  Prioer to setting the basic Valve,
     * @exception IllegalArgumentException if the specifie Valve refuses to be
     * always sent to the log. Default is that otput is sent only to
======= fetch "protected void closeRedirector() {" 18c0edc^:"java/org/apache/catalina/ant/BaseRedirectorHelperTask.java"

         * this is to prevent that we attempt to reuse the previuosly 
======= fetch "protected void handleErrorFlush(String output) {" 18c0edc^:"java/org/apache/catalina/ant/BaseRedirectorHelperTask.java"

     * pritorities to output stream.
======= fetch "protected void handleOutput(String output, int priority) {" 18c0edc^:"java/org/apache/catalina/ant/BaseRedirectorHelperTask.java"

     * pritorities to output stream, then flushes the stream.
======= fetch "private StringBuilder createLink() {" 18c0edc^:"java/org/apache/catalina/ant/JKStatusUpdateTask.java"

     * check correct lb and worker pararmeter
 * The poperty manager.lenght show the size of the result 
 * and with manager.[0..lenght].name the 
======= fetch "public String jmxExecute(MBeanServerConnection jmxServerConnection)" 18c0edc^:"java/org/apache/catalina/ant/jmx/JMXAccessorQueryTask.java"

     *  with <em>attributebindung=true</em> you can save all attributes from all found objects
======= fetch "protected String jmxSet(MBeanServerConnection jmxServerConnection," 18c0edc^:"java/org/apache/catalina/ant/jmx/JMXAccessorSetTask.java"

     * Get MBean Attriute from Mbean Server
======= fetch "protected void createProperty(Object result) {" 18c0edc^:"java/org/apache/catalina/ant/jmx/JMXAccessorTask.java"

     * option is that you delemit your result with a delimiter
 * so that it can be ommitted in environments that do not require these
======= fetch "protected void forwardToErrorPage(Request request, Response response, LoginConfi" 18c0edc^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

     * we signalled after successful authentication?
======= fetch "protected boolean restoreRequest(Request request, Session session)" 18c0edc^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

            // The browser isn't expecting this conditional reposponse now.
 * web application is propogated to other web applications in the same
======= fetch "public Connector(String protocol) {" 18c0edc^:"java/org/apache/catalina/connector/Connector.java"

     * The server port to which we should pretent requests to this Connector
======= fetch "protected boolean postParseRequest(org.apache.coyote.Request req," 18c0edc^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

     * Look for SSL sesison ID if required. Only look for SSL Session ID if it
======= fetch "public int readLine(byte[] b, int off, int len) throws IOException {" 18c0edc^:"java/org/apache/catalina/connector/CoyoteInputStream.java"

     * which would permantely disable us.
 * Coyote implementation of the buffred reader.
 * Coyote is mostly the Processor's responsability).
======= fetch "public void setCoyoteRequest(org.apache.coyote.Request coyoteRequest) {" 18c0edc^:"java/org/apache/catalina/connector/Request.java"

     * The preferred Locales assocaited with this Request.
======= fetch "protected B2CConverter getURIConverter() {" 18c0edc^:"java/org/apache/catalina/connector/Request.java"

     * @param URIConverter the new URI connverter
======= fetch "public void removeAttribute(String name) {" 18c0edc^:"java/org/apache/catalina/connector/Request.java"

                // Error valve will pick this execption up and display it to user
======= fetch "public void setAttribute(String name, Object value) {" 18c0edc^:"java/org/apache/catalina/connector/Request.java"

                // Error valve will pick this execption up and display it to user
======= fetch "public MessageBytes getContextPathMB() {" 18c0edc^:"java/org/apache/catalina/connector/Request.java"

     * Set the set of cookies recieved with this Request.
======= fetch "public boolean isUserInRole(String role) {" 18c0edc^:"java/org/apache/catalina/connector/Request.java"

        // Identify the Realm we will use for checking role assignmenets
======= fetch "public String getParameter(String name) {" 18c0edc^:"java/org/apache/catalina/connector/RequestFacade.java"

         * in place, so that performance won't suffer in the nonsecure case
======= fetch "public String getAuthType() {" 18c0edc^:"java/org/apache/catalina/connector/RequestFacade.java"

         * in place, so that performance won't suffer in the nonsecure case
======= fetch "public void setContentType(String type) {" 18c0edc^:"java/org/apache/catalina/connector/Response.java"

     * @param charset String containing the name of the chararacter encoding.
======= fetch "public void addCookieInternal(final Cookie cookie) {" 18c0edc^:"java/org/apache/catalina/connector/Response.java"

        //from the appendCookieValue invokation
======= fetch "public void addPortcomponent(String serviceendpoint, String portlink) {" 18c0edc^:"java/org/apache/catalina/deploy/ContextService.java"

     * The instanciation of the handler have to be done.
 *   <li>Cancelling the first authentication dialog box and then trying to
 * authenticates to one web application is propogated to other web applications and
 * send the muticast merssage using the format...
 * send the muticast merssage using the format...
======= fetch "public void remove(String contextPath, boolean undeploy) throws IOException {" 18c0edc^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     * Modifcation from watchDir war detected!
======= fetch "public void fileModified(File newWar) {" 18c0edc^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     * War remvoe from watchDir
     * The number of the last message procssed. Message IDs are 1 based.
======= fetch "public WarWatcher(FileChangeListener listener, File watchDir) {" 18c0edc^:"java/org/apache/catalina/ha/deploy/WarWatcher.java"

     * check for modification and send notifcation to listener
======= fetch "public int getMaxActiveSessions() {" 18c0edc^:"java/org/apache/catalina/ha/session/DeltaManager.java"

     * Set the maximum number of actives Sessions allowed, or -1 for no limit.
======= fetch "protected DeltaRequest deserializeDeltaRequest(DeltaSession session, byte[] data" 18c0edc^:"java/org/apache/catalina/ha/session/DeltaManager.java"

     * FIXME replace currently sessions with same id without notifcation.
======= fetch "protected void sessionExpired(String id) {" 18c0edc^:"java/org/apache/catalina/ha/session/DeltaManager.java"

     * Exipre all find sessions.
 * a request is executed. These actions will then translate into invokations of methods 
     * Last time the session was replicatd, used for distributed expiring of
 * nodes. After all that, the session stickyness will work directly to the
======= fetch "public String getSessionIdAttribute() {" 18c0edc^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

     * get name of failed reqeust session attribute
======= fetch "public void setCluster(CatalinaCluster cluster) {" 18c0edc^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

     * Handle jvmRoute stickyness after tomcat instance failed. After this
======= fetch "public void setCluster(CatalinaCluster cluster) {" 18c0edc^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

     * SessionID change propage to the other cluster nodes.
======= fetch "protected void changeSessionID(Request request," 18c0edc^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

        // FIXME: setId trigger session Listener, but only chance to registiert manager with correct id!
======= fetch "protected void changeSessionID(Request request," 18c0edc^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

            // now sending the change to all other clusternode!
======= fetch "protected void changeRequestSessionID(Request request, Response response, String" 18c0edc^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

        // set orginal sessionid at request, to allow application detect the
======= fetch "public void setTimestamp(long time) {" 18c0edc^:"java/org/apache/catalina/ha/session/SessionMessageImpl.java"

     * @return the event type in a string representating, useful for debugging
======= fetch "public void invoke(Request request, Response response)" 18c0edc^:"java/org/apache/catalina/ha/tcp/ReplicationValve.java"

     * reset the active statitics 
======= fetch "protected void sendCrossContextSession(CatalinaCluster containerCluster) {" 18c0edc^:"java/org/apache/catalina/ha/tcp/ReplicationValve.java"

     * @param request current request after responce is generated
======= fetch "public void memberDisappeared(Member member) {" 18c0edc^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

     * emitt Failure Event to LifecylceListener
======= fetch "public void memberDisappeared(Member member) {" 18c0edc^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

     *            receveived Message
======= fetch "protected void addURL(URL url) {" 18c0edc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * <code>URL</code> refering to it, or <code>null</code> if this resource
======= fetch "protected boolean filter(String name) {" 18c0edc^:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * Validate a classname. As per SRV.9.7.2, we must restict loading of 
======= fetch "protected String reload(String path) {" 18c0edc^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

     * @param path Context path of the application to be undeployd
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" 18c0edc^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    // limited number of subsitutions MessageFormat can process
    // (maximium of 10).
======= fetch "public void listBeans( PrintWriter writer, String qry )" 18c0edc^:"java/org/apache/catalina/manager/JMXProxyServlet.java"

                // can't be null - I thinl
======= fetch "protected void serverinfo(PrintWriter writer) {" 18c0edc^:"java/org/apache/catalina/manager/ManagerServlet.java"

     * @param idle Expire all sessions with idle time &ge; idle for this context
======= fetch "public void list(HttpServletRequest request," 18c0edc^:"java/org/apache/catalina/manager/host/HTMLHostManagerServlet.java"

    // limited number of subsitutions MessageFormat can process
    // (maximium of 10).
======= fetch "private SessionUtils() {" 18c0edc^:"java/org/apache/catalina/manager/util/SessionUtils.java"

     * JSF check the browser meta tag "accept languages" to choose what langage to display.
======= fetch "public void setAttribute(Attribute attribute)" 18c0edc^:"java/org/apache/catalina/mbeans/ContextEnvironmentMBean.java"

        // cannot use side-efects.  It's removed and added back each time 
======= fetch "public void setAttribute(Attribute attribute)" 18c0edc^:"java/org/apache/catalina/mbeans/ContextResourceLinkMBean.java"

        // cannot use side-efects.  It's removed and added back each time 
======= fetch "public void setAttribute(Attribute attribute)" 18c0edc^:"java/org/apache/catalina/mbeans/ContextResourceMBean.java"

        // cannot use side-efects.  It's removed and added back each time 
======= fetch "public void removeConnector(String name) throws Exception {" 18c0edc^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * @param contextName MBean Name of the comonent to remove
======= fetch "public void removeContext(String contextName) throws Exception {" 18c0edc^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * @param name MBean Name of the comonent to remove
======= fetch "public void removeHost(String name) throws Exception {" 18c0edc^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * @param name MBean Name of the comonent to remove
======= fetch "public void removeLoader(String name) throws Exception {" 18c0edc^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * @param name MBean Name of the comonent to remove
======= fetch "public void removeManager(String name) throws Exception {" 18c0edc^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * @param name MBean Name of the comonent to remove
======= fetch "public void removeRealm(String name) throws Exception {" 18c0edc^:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * @param name MBean Name of the comonent to remove
     * Semicolon separated list of paths containing MBean desciptor resources.
======= fetch "protected void createMBeans(Connector connector) throws Exception {" 18c0edc^:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        // Create the MBean for the Connnector itself
     * The column in the user table that holds the user's credintials
======= fetch "public JAASCallbackHandler(JAASRealm realm, String username," 18c0edc^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

     * @param qop           Quality of protection aplied to the message
======= fetch "public JAASCallbackHandler(JAASRealm realm, String username," 18c0edc^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

     * Quality of protection aplied to the message.
======= fetch "public JAASCallbackHandler(JAASRealm realm, String username," 18c0edc^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

     * {@link TextInputCallback} is ued to pass the various additional
 *     "catalina.base" system property) or absolute pahtname to the
     * <code>null</code> if validation falied.
======= fetch "public boolean login() throws LoginException {" 18c0edc^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

     * @return <code>true</code> in all cases because thie
 * <p>Implmentation of <b>Realm</b> that authenticates users via the <em>Java
 * <li>As this Realm iterates over the <code>Princpals</code> returned by
======= fetch "public Principal authenticate(String username, String credentials) {" 18c0edc^:"java/org/apache/catalina/realm/JAASRealm.java"

     * @param qop           Quality of protection aplied to the message
     * The column in the user table that holds the user's credintials
======= fetch "public synchronized Principal authenticate(String username, String credentials)" 18c0edc^:"java/org/apache/catalina/realm/JDBCRealm.java"

        // Number of tries is the numebr of attempts to connect to the database
======= fetch "public synchronized Principal authenticate(String username, String credentials)" 18c0edc^:"java/org/apache/catalina/realm/JDBCRealm.java"

        // This needs rewritten wuth better pooling support, the existing code
======= fetch "protected synchronized String getPassword(String username) {" 18c0edc^:"java/org/apache/catalina/realm/JDBCRealm.java"

        // Number of tries is the numebr of attempts to connect to the database
======= fetch "protected synchronized String getPassword(String username) {" 18c0edc^:"java/org/apache/catalina/realm/JDBCRealm.java"

        // This needs rewritten wuth better pooling support, the existing code
======= fetch "protected synchronized Principal getPrincipal(String username) {" 18c0edc^:"java/org/apache/catalina/realm/JDBCRealm.java"

        // Number of tries is the numebr of attempts to connect to the database
======= fetch "protected Principal getPrincipal(String username) {" 18c0edc^:"java/org/apache/catalina/realm/JNDIRealm.java"

            // Occassionally the directory context will timeout.  Try one more
 * associated user storage mecahisms. It achieves this by recording all failed
======= fetch "public boolean hasRole(Principal principal, String role) {" 18c0edc^:"java/org/apache/catalina/realm/RealmBase.java"

        // Should be overriten in JAASRealm - to avoid pretty inefficient conversions
======= fetch "public static void doAsPrivilege(final String methodName," 18c0edc^:"java/org/apache/catalina/security/SecurityUtil.java"

     * @param targetType <code>Class</code> array used to instanciate a i
======= fetch "public static void doAsPrivilege(final String methodName," 18c0edc^:"java/org/apache/catalina/security/SecurityUtil.java"

     * @param targetType <code>Class</code> array used to instanciate a 
======= fetch "public static void doAsPrivilege(final String methodName," 18c0edc^:"java/org/apache/catalina/security/SecurityUtil.java"

     * @param targetType <code>Class</code> array used to instanciate a
======= fetch "public static void doAsPrivilege(final String methodName," 18c0edc^:"java/org/apache/catalina/security/SecurityUtil.java"

     * @param targetType <code>Class</code> array used to instanciate a
======= fetch "private static Method findMethod(Method[] methodsCache," 18c0edc^:"java/org/apache/catalina/security/SecurityUtil.java"

     * @param targetType <code>Class</code> array used to instanciate a 
 * <b>Metavariable Values</b>: According to the CGI specificion,
 * supplied to the script are preceisely as supplied by the client and
======= fetch "protected void setupFromRequest(HttpServletRequest req)" 18c0edc^:"java/org/apache/catalina/servlets/CGIServlet.java"

         * script; relies heavliy on Servlet API methods and findCGI
======= fetch "protected void setupFromRequest(HttpServletRequest req)" 18c0edc^:"java/org/apache/catalina/servlets/CGIServlet.java"

         *           invokation
======= fetch "protected String blanksToString(String couldBeBlank," 18c0edc^:"java/org/apache/catalina/servlets/CGIServlet.java"

     * passed to the constuctor.
======= fetch "protected String blanksToString(String couldBeBlank," 18c0edc^:"java/org/apache/catalina/servlets/CGIServlet.java"

         *                  paramters as strings
======= fetch "protected boolean checkIfHeaders(HttpServletRequest request," 18c0edc^:"java/org/apache/catalina/servlets/DefaultServlet.java"

     * @param path Path which has to be rewiten
======= fetch "private void parseProperties(HttpServletRequest req," 18c0edc^:"java/org/apache/catalina/servlets/WebdavServlet.java"

     * Propfind helper method. Dispays the properties of a lock-null resource.
======= fetch "public InputSource resolveEntity (String publicId, String systemId) {" 18c0edc^:"java/org/apache/catalina/servlets/WebdavServlet.java"

    // This one colides with HTTP 1.1
    // "207 Parital Update OK"
======= fetch "public InputSource resolveEntity (String publicId, String systemId) {" 18c0edc^:"java/org/apache/catalina/servlets/WebdavServlet.java"

    // This one colides with HTTP 1.1
======= fetch "public InputSource resolveEntity (String publicId, String systemId) {" 18c0edc^:"java/org/apache/catalina/servlets/WebdavServlet.java"

    // This one colides with HTTP 1.1
======= fetch "public InputSource resolveEntity (String publicId, String systemId) {" 18c0edc^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        // HTTP 1.0 tatus Code
======= fetch "public void save(Session session) throws IOException {" 18c0edc^:"java/org/apache/catalina/session/JDBCStore.java"

     * @return <code>Connection</code> if the connection suceeded
 * persistence, even if onlyfor  restarts.
======= fetch "public int getMaxActiveSessions() {" 18c0edc^:"java/org/apache/catalina/session/PersistentManagerBase.java"

     * Set the maximum number of actives Sessions allowed, or -1 for
======= fetch "public void setRejectedSessions(int rejectedSessions) {" 18c0edc^:"java/org/apache/catalina/session/StandardManager.java"

     * Set the maximum number of actives Sessions allowed, or -1 for
======= fetch "private void parseExpression(String expr) throws ParseException {" 18c0edc^:"java/org/apache/catalina/ssi/ExpressionParseTree.java"

                    // Similar stategy to NOT_EQ above, except this
======= fetch "private void parseExpression(String expr) throws ParseException {" 18c0edc^:"java/org/apache/catalina/ssi/ExpressionParseTree.java"

                    // Similar stategy to NOT_EQ above, except this
======= fetch "public String padLeft(String str, int maxChars) {" 18c0edc^:"java/org/apache/catalina/ssi/SSIFsize.java"

    //We try to mimick Apache here, as we do everywhere
======= fetch "protected String getPathWithoutFileName(String servletPath) {" 18c0edc^:"java/org/apache/catalina/ssi/SSIServletExternalResolver.java"

            //cut off file namee
 * commands. This is used to mimick the Apache behavior in #set with invalid
 *    registerering a <code>MembershipListener</code><br>
     * SEND_OPTIONS_BYTE_MESSAGE - The message is a pure byte message and no marshalling or unmarshalling will
 * was processed by an above application or if it was just received and forgot about, a featuer required
     * Heartbeat invokation for resources cleanup etc
     * @return the listen port for this member, -1 if its not listening on an unsecure port
 * <p>Title: Represents a globabally unique Id</p>
     * The first interceptor in the inteceptor stack.
======= fetch "public boolean getHeartbeat() {" 18c0edc^:"java/org/apache/catalina/tribes/group/GroupChannel.java"

     * sleep in between invokations of <code>Channel.heartbeat()</code>
 * except is ues an atomic long for the currentSize calculation
======= fetch "public boolean isAccessed() {" 18c0edc^:"java/org/apache/catalina/tribes/io/ObjectReader.java"

     * @return number of messages that sended to callback
======= fetch "protected void setupSocket() throws IOException {" 18c0edc^:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

                 * On some plattforms (e.g. Linux) it is not possible to bind
======= fetch "public void add(Member member) {" 18c0edc^:"java/org/apache/catalina/tribes/transport/PooledSender.java"

        // no op, senders created upon demans
======= fetch "protected void drainSocket () throws Exception {" 18c0edc^:"java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java"

     * send a reply-acknowledgement (6,2,3)
======= fetch "protected void closeSocket() {" 18c0edc^:"java/org/apache/catalina/tribes/transport/bio/BioSender.java"

     * After successfull sending update stats
======= fetch "protected void closeSocket() {" 18c0edc^:"java/org/apache/catalina/tribes/transport/bio/BioSender.java"

     * WARNING: Subclasses must be very carefull that only one thread call this pushMessage at once!!!
======= fetch "protected void pushMessage(byte[] data, boolean reconnect, boolean waitForAck) t" 18c0edc^:"java/org/apache/catalina/tribes/transport/bio/BioSender.java"

     * Wait for Acknowledgement from other server
     * FIXME Please, not wait only for three charcters, better control that the wait ack message is correct.
 * length when you have strange producer thread problemes.
     * limit the queue legnth ( default is unlimited)
======= fetch "protected boolean write(SelectionKey key) throws IOException {" 18c0edc^:"java/org/apache/catalina/tribes/transport/nio/NioSender.java"

                //weve written everything, or we are starting a new package
======= fetch "public synchronized void sendMessage(Member[] destination, ChannelMessage msg) t" 18c0edc^:"java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java"

                //timeout has occured
======= fetch "public boolean keepalive() {" 18c0edc^:"java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java"

        //clean up any cancelled keys
======= fetch "public MemoryUserDatabase(String id) {" 18c0edc^:"java/org/apache/catalina/users/MemoryUserDatabase.java"

     * The relative or absolute pathname ot the file in which we write
======= fetch "public static boolean isArrayByteBase64( byte[] arrayOctect )" 18c0edc^:"java/org/apache/catalina/util/Base64.java"

     * Encodes hex octects into Base64.
======= fetch "public static boolean isArrayByteBase64( byte[] arrayOctect )" 18c0edc^:"java/org/apache/catalina/util/Base64.java"

     * Decodes Base64 data into octects
     * US locale - all HTTP dates are in english
 * Ensures that all extension dependies are resolved for a WEB application
 * applicaiton and then validates those extensions.
     * Runtime validation of a Web Applicaiton.
======= fetch "public static synchronized boolean validateApplication(" 18c0edc^:"java/org/apache/catalina/util/ExtensionValidator.java"

        // Find the Manifest for the Web Applicaiton
======= fetch "public static void addSystemResource(File jarFile) throws IOException {" 18c0edc^:"java/org/apache/catalina/util/ExtensionValidator.java"

     * This method should also provide static validation of a Web Applicaiton 
======= fetch "private static boolean validateManifestResources(String appName," 18c0edc^:"java/org/apache/catalina/util/ExtensionValidator.java"

                // check the applicaion itself for the extension
======= fetch "private IOTools() {" 18c0edc^:"java/org/apache/catalina/util/IOTools.java"

     * @param buf the char array to use as a bufferx
======= fetch "public int getRequiredExtensionCount() {" 18c0edc^:"java/org/apache/catalina/util/ManifestResource.java"

     * Convienience method to check if this <code>ManifestResource</code>
======= fetch "public ParameterMap(int initialCapacity, float loadFactor) {" 18c0edc^:"java/org/apache/catalina/util/ParameterMap.java"

     * @param map Map whose contents are dupliated in the new map
======= fetch "public static String URLDecode(byte[] bytes, String enc, boolean isQuery) {" 18c0edc^:"java/org/apache/catalina/util/RequestUtil.java"

     * Convert a byte character value to hexidecimal digit value.
     * The disgester instance for which this class is the entity resolver.
     * all remote dtds and schema to a locat destination.
        //translate.put("s","seconds since ecpoch");
        //translate.put("U","week in year with first sunday as first day...");
        //translate.put("W","week in year with first monday as first day...");
======= fetch "public boolean isResolveHosts() {" 18c0edc^:"java/org/apache/catalina/valves/AccessLogValve.java"

     * performing conditional loggging. If null, every
======= fetch "public void addElement(StringBuilder buf, Date date, Request request," 18c0edc^:"java/org/apache/catalina/valves/AccessLogValve.java"

                 * not enounter a closing } - then I ignore the {
======= fetch "public CometConnectionManagerValve() {" 18c0edc^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

     * List of current Coment connections.
======= fetch "public void invoke(Request request, Response response)" 18c0edc^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

            // Track the conection for webapp reload

    private Hashtable portComponentRef = null;
======= fetch "private Object getProxyPortQNameClass(Object[] args)" 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceProxy.java"

        Class serviceendpointClass = (Class) args[1];
======= fetch "private Object getProxyPortQNameClass(Object[] args)" 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceProxy.java"

        for (Iterator ports = service.getPorts(); ports.hasNext();) {
            QName portName = (QName) ports.next();
======= fetch "private Object getProxyPortQNameClass(Object[] args)" 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceProxy.java"

    public void setPortComponentRef(Hashtable portComponentRef) {
======= fetch "private Remote getProxyPortClass(Object[] args)" 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceProxy.java"

        Class serviceendpointClass = (Class) args[0];
======= fetch "private Remote getProxyPortClass(Object[] args)" 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceProxy.java"

        QName portname = (QName) this.portComponentRef.get(serviceendpointClass.getName());
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

            Hashtable environment)
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

            Hashtable portComponentRef = new Hashtable();
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

            Class serviceInterfaceClass = null;
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                    Map ports = wsdlservice.getPorts();
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                    for (Iterator i = ports.keySet().iterator(); i.hasNext();) {
                        String portName = (String) i.next();
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

            Class[] interfaces = null;
            Class[] serviceInterfaces = serviceInterfaceClass.getInterfaces();
            if (serviceInterfaceClass != null) {
                interfaces = new Class[serviceInterfaces.length + 1];
                for (int i = 0; i < serviceInterfaces.length; i++) {
                    interfaces[i] = serviceInterfaces[i];
                }
            } else {
                interfaces = new Class[1];
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                ArrayList soaproles = new ArrayList();
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                    Class handlerClass = null;
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                    ArrayList headers = new ArrayList();
                    Hashtable config = new Hashtable();
                    ArrayList portNames = new ArrayList();
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                    handlerref.setHeaders((QName []) headers.toArray(new QName[headers.size()]));
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                        Iterator iter = portNames.iterator();
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                            initHandlerChain(new QName((String) iter.next()), handlerRegistry,
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                        Enumeration e = portComponentRef.elements();
======= fetch "public Object getObjectInstance(Object obj, Name name, Context nameCtx," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                            initHandlerChain((QName) e.nextElement(), handlerRegistry,
======= fetch "private String getSOAPLocation(Port port) {" 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

        List extensions = port.getExtensibilityElements();
        for (Iterator i = extensions.iterator(); i.hasNext();) {
            ExtensibilityElement ext = (ExtensibilityElement) i.next();
======= fetch "private void initHandlerChain(QName portName, HandlerRegistry handlerRegistry," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

            HandlerInfo handlerref, ArrayList soaprolesToAdd) {
======= fetch "private void initHandlerChain(QName portName, HandlerRegistry handlerRegistry," 97ccffd^:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

            soaproles[i+j] = (String) soaprolesToAdd.get(j);

======= fetch "public String getInfo() {" 9204e4d^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

     * called servlet will be propogated to the caller.
======= fetch "private void doForward(ServletRequest request, ServletResponse response)" 9204e4d^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

            // Servlet SRV.6.2.2. The Resquest/Response may have been wrapped
======= fetch "private String getCombinedPath() {" 9204e4d^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

     * called servlet will be propogated to the caller.
 * Factory for the creation and caching of Filters and creationg 
     * Prevent instanciation outside of the getInstanceMethod().
======= fetch "private ApplicationFilterFactory() {" 9204e4d^:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

     * Return the fqctory instance.
======= fetch "private ApplicationFilterFactory() {" 9204e4d^:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

     * Convienience method which returns true if  the dispatcher type
======= fetch "public ApplicationHttpRequest(HttpServletRequest request, Context context," 9204e4d^:"java/org/apache/catalina/core/ApplicationHttpRequest.java"

     * If this request is cross context, since this changes session accesss
======= fetch "public void destroy() throws Exception {" 9204e4d^:"java/org/apache/catalina/core/ContainerBase.java"

     * @exception IllegalArgumentException if the specifie Valve refuses to be
======= fetch "public synchronized void removeValve(Valve valve) {" 9204e4d^:"java/org/apache/catalina/core/ContainerBase.java"

     * Valve for this Pipeline (if any).  Prioer to setting the basic Valve,
======= fetch "public void fireContainerEvent(String type, Object data) {" 9204e4d^:"java/org/apache/catalina/core/ContainerBase.java"

     * Return the abbreviated name of this container for logging messsages
======= fetch "public StandardContext() {" 9204e4d^:"java/org/apache/catalina/core/StandardContext.java"

     * before the mappings in the deploymenmt descriptor but must be inserted in
======= fetch "public String getOriginalDocBase() {" 9204e4d^:"java/org/apache/catalina/core/StandardContext.java"

     * @param docBase The orginal document root
======= fetch "public StandardEngine() {" 9204e4d^:"java/org/apache/catalina/core/StandardEngine.java"

    /** Allow the base dir to be specified explicitely for
======= fetch "public Realm getRealm() {" 9204e4d^:"java/org/apache/catalina/core/StandardEngine.java"

        // This can be overriden at engine, context and host level  
======= fetch "public void init() {" 9204e4d^:"java/org/apache/catalina/core/StandardEngine.java"

            // for consistency...: we are probably in embeded mode
======= fetch "public StandardHost() {" 9204e4d^:"java/org/apache/catalina/core/StandardHost.java"

     * Attribute value used to turn on/off XML namespace awarenes.
======= fetch "public void setContextClass(String contextClass) {" 9204e4d^:"java/org/apache/catalina/core/StandardHost.java"

     * that this host's child webapps should be discovred and automatically 
======= fetch "public boolean getXmlValidation(){" 9204e4d^:"java/org/apache/catalina/core/StandardHost.java"

     * @return true if namespace awarenes is enabled.
======= fetch "public synchronized void start() throws LifecycleException {" 9204e4d^:"java/org/apache/catalina/core/StandardHost.java"

      * Return the MBean Names of the Valves assoicated with this Host
======= fetch "public Valve getBasic() {" 9204e4d^:"java/org/apache/catalina/core/StandardPipeline.java"

     * Valve for this Pipeline (if any).  Prioer to setting the basic Valve,
======= fetch "public void setBasic(Valve valve) {" 9204e4d^:"java/org/apache/catalina/core/StandardPipeline.java"

     * @exception IllegalArgumentException if the specifie Valve refuses to be
======= fetch "public void removeValve(Valve valve) {" 9204e4d^:"java/org/apache/catalina/core/StandardPipeline.java"

            // Unregister the removed valave
======= fetch "public void stop() throws LifecycleException {" 9204e4d^:"java/org/apache/catalina/core/StandardService.java"

        // FIXME pero -- Why container stop first? KeepAlive connetions can send request! 
======= fetch "public void stop() throws LifecycleException {" 9204e4d^:"java/org/apache/catalina/core/StandardService.java"

            // backward compat, nobody should bother to load it explicitely
======= fetch "public void initialize()" 9204e4d^:"java/org/apache/catalina/core/StandardService.java"

        // Service shouldn't be used with embeded, so it doesn't matter
     * Create a new facede around a StandardWrapper.
======= fetch "public StandardWrapperValve() {" 9204e4d^:"java/org/apache/catalina/core/StandardWrapperValve.java"

    // Some JMX statistics. This vavle is associated with a StandardWrapper.

    @Deprecated
    @Deprecated
    @Deprecated
    @Deprecated
    @Deprecated
======= fetch "public RequestDispatcher getRequestDispatcher(String path) {" a3fa5d3^:"java/javax/servlet/ServletRequestWrapper.java"

    @Deprecated
    @Deprecated
======= fetch "public UnavailableException(Servlet servlet, String msg) {" a3fa5d3^:"java/javax/servlet/UnavailableException.java"

    @Deprecated
======= fetch "public boolean isPermanent() {" a3fa5d3^:"java/javax/servlet/UnavailableException.java"

    @Deprecated
    @Deprecated
======= fetch "public boolean isRequestedSessionIdFromURL() {" a3fa5d3^:"java/javax/servlet/http/HttpServletRequestWrapper.java"

    @Deprecated
    @Deprecated
    @Deprecated
    @Deprecated
======= fetch "public String encodeRedirectURL(String url) {" a3fa5d3^:"java/javax/servlet/http/HttpServletResponseWrapper.java"

    @Deprecated
======= fetch "public String encodeUrl(String url) {" a3fa5d3^:"java/javax/servlet/http/HttpServletResponseWrapper.java"

    @Deprecated
======= fetch "public void setStatus(int sc) {" a3fa5d3^:"java/javax/servlet/http/HttpServletResponseWrapper.java"

     public void setStatus(int sc, String sm) {
======= fetch "public JspException(Throwable cause) {" a3fa5d3^:"java/javax/servlet/jsp/JspException.java"

    @Deprecated
    @Deprecated
    @Deprecated
    @Deprecated
    @Deprecated
======= fetch "public BufferedReader getReader() throws IOException {" a3fa5d3^:"java/org/apache/catalina/connector/Request.java"

    @Deprecated
======= fetch "public boolean isRequestedSessionIdFromURL() {" a3fa5d3^:"java/org/apache/catalina/connector/Request.java"

    @Deprecated
======= fetch "public String encodeRedirectURL(String url) {" a3fa5d3^:"java/org/apache/catalina/connector/Response.java"

    @Deprecated
======= fetch "public String encodeURL(String url) {" a3fa5d3^:"java/org/apache/catalina/connector/Response.java"

    @Deprecated
======= fetch "public void setStatus(int status) {" a3fa5d3^:"java/org/apache/catalina/connector/Response.java"

    @Deprecated
======= fetch "public String getServerInfo() {" a3fa5d3^:"java/org/apache/catalina/core/ApplicationContext.java"

    @Deprecated
======= fetch "public String getServletContextName() {" a3fa5d3^:"java/org/apache/catalina/core/ApplicationContext.java"

    @Deprecated
======= fetch "public String getServletContextName() {" a3fa5d3^:"java/org/apache/catalina/core/ApplicationContext.java"

    @Deprecated
======= fetch "public void log(String message) {" a3fa5d3^:"java/org/apache/catalina/core/ApplicationContext.java"

    @Deprecated
======= fetch "public RequestDispatcher getNamedDispatcher(String name) {" a3fa5d3^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @Deprecated
======= fetch "public Servlet getServlet(String name)" a3fa5d3^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @Deprecated
======= fetch "public Servlet getServlet(String name)" a3fa5d3^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @Deprecated
======= fetch "public void log(String msg) {" a3fa5d3^:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @Deprecated
======= fetch "public void setStatus(int sc) {" a3fa5d3^:"java/org/apache/catalina/core/ApplicationHttpResponse.java"

    @Deprecated
======= fetch "public ServletInputStream getInputStream() throws IOException {" a3fa5d3^:"java/org/apache/catalina/core/DummyRequest.java"

    @Deprecated
======= fetch "public void setDecodedRequestURI(@SuppressWarnings("unused") String uri) {}" a3fa5d3^:"java/org/apache/catalina/core/DummyRequest.java"

    @Deprecated
======= fetch "public void addIntHeader(String name, int value) {}" a3fa5d3^:"java/org/apache/catalina/core/DummyResponse.java"

    @Deprecated
======= fetch "public void addIntHeader(String name, int value) {}" a3fa5d3^:"java/org/apache/catalina/core/DummyResponse.java"

    @Deprecated
======= fetch "public void setStatus(int status) {}" a3fa5d3^:"java/org/apache/catalina/core/DummyResponse.java"

    @Deprecated
======= fetch "protected void setAccessCount(int count) {" a3fa5d3^:"java/org/apache/catalina/ha/session/DeltaSession.java"

======= fetch "protected void setAccessCount(int count) {" a3fa5d3^:"java/org/apache/catalina/ha/session/DeltaSession.java"

    @Deprecated
======= fetch "protected void setAccessCount(int count) {" a3fa5d3^:"java/org/apache/catalina/ha/session/DeltaSession.java"

    @Deprecated
======= fetch "public void setNotifyLifecycleListenerOnFailure(" a3fa5d3^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Deprecated
======= fetch "public String getManagerClassName() {" a3fa5d3^:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Deprecated
    @Deprecated
======= fetch "public void addPropertyChangeListener(PropertyChangeListener listener) {" a3fa5d3^:"java/org/apache/catalina/session/ManagerBase.java"

    @Deprecated
======= fetch "public ServletContext getServletContext() {" a3fa5d3^:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= fetch "public Object getAttribute(String name) {" a3fa5d3^:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= fetch "public Object getValue(String name) {" a3fa5d3^:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= fetch "public boolean isNew() {" a3fa5d3^:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= fetch "public void removeAttribute(String name, boolean notify) {" a3fa5d3^:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= fetch "protected void removeAttributeInternal(String name, boolean notify) {" a3fa5d3^:"java/org/apache/catalina/session/StandardSession.java"

======= fetch "protected void removeAttributeInternal(String name, boolean notify) {" a3fa5d3^:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= fetch "protected void removeAttributeInternal(String name, boolean notify) {" a3fa5d3^:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= fetch "public int getMaxInactiveInterval() {" a3fa5d3^:"java/org/apache/catalina/session/StandardSessionFacade.java"

    @Deprecated
======= fetch "public Object getAttribute(String name) {" a3fa5d3^:"java/org/apache/catalina/session/StandardSessionFacade.java"

    @Deprecated
======= fetch "public Object getValue(String name) {" a3fa5d3^:"java/org/apache/catalina/session/StandardSessionFacade.java"

    @Deprecated
======= fetch "public void setAttribute(String name, Object value) {" a3fa5d3^:"java/org/apache/catalina/session/StandardSessionFacade.java"

    @Deprecated
======= fetch "public void removeAttribute(String name) {" a3fa5d3^:"java/org/apache/catalina/session/StandardSessionFacade.java"

    @Deprecated
======= fetch "public void stopServer(String[] arguments) {" a3fa5d3^:"java/org/apache/catalina/startup/Catalina.java"

    @Deprecated
======= fetch "public void setCatalinaBase() {" a3fa5d3^:"java/org/apache/catalina/startup/Catalina.java"

    @Deprecated
======= fetch "public static long toLong(byte[] b,int off){" a3fa5d3^:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    @Deprecated
======= fetch "public static boolean toBoolean(byte[] b, int offset) {" a3fa5d3^:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    @Deprecated
======= fetch "public static boolean toBoolean(byte[] b, int offset) {" a3fa5d3^:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    @Deprecated
======= fetch "public void setAddress(String addr) {" a3fa5d3^:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= fetch "public String getAddress() {" a3fa5d3^:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= fetch "public void setBind(String bindaddr) {" a3fa5d3^:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= fetch "public String getBind() {" a3fa5d3^:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= fetch "public void setLocalLoopbackDisabled(boolean localLoopbackDisabled) {" a3fa5d3^:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= fetch "public int getPort() {" a3fa5d3^:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= fetch "public void setFrequency(long time) {" a3fa5d3^:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= fetch "public void setDropTime(long time) {" a3fa5d3^:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= fetch "public void broadcast(ChannelMessage message) throws ChannelException {" a3fa5d3^:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= fetch "public int getSoTimeout() {" a3fa5d3^:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= fetch "public void setSoTimeout(int mcastSoTimeout) {" a3fa5d3^:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= fetch "public int getTtl() {" a3fa5d3^:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= fetch "public int getTxBufSize() {" a3fa5d3^:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= fetch "public void setMessageListener(MessageListener listener) {" a3fa5d3^:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= fetch "public void setTcpListenPort(int tcpListenPort) {" a3fa5d3^:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= fetch "public void setTxBufSize(int txBufSize) {" a3fa5d3^:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= fetch "public void setBind(java.net.InetAddress bind) {" a3fa5d3^:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= fetch "public long getSelectorTimeout() {" a3fa5d3^:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= fetch "public RxTaskPool getTaskPool() {" a3fa5d3^:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= fetch "public boolean isListening() {" a3fa5d3^:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= fetch "public char readChar() throws java.io.IOException" a3fa5d3^:"java/org/apache/el/parser/SimpleCharStream.java"

  public int getColumn() {
======= fetch "public int getColumn() {" a3fa5d3^:"java/org/apache/el/parser/SimpleCharStream.java"

  public int getLine() {
======= fetch "public String getServerInfo() {" a3fa5d3^:"java/org/apache/jasper/servlet/JspCServletContext.java"

    @Deprecated
======= fetch "public String getServletContextName() {" a3fa5d3^:"java/org/apache/jasper/servlet/JspCServletContext.java"

    @Deprecated
======= fetch "public String getServletContextName() {" a3fa5d3^:"java/org/apache/jasper/servlet/JspCServletContext.java"

    @Deprecated
======= fetch "public void log(String message) {" a3fa5d3^:"java/org/apache/jasper/servlet/JspCServletContext.java"

    @Deprecated
======= fetch "public void setLastModified(long lastModified) {" a3fa5d3^:"java/org/apache/naming/resources/ResourceAttributes.java"

    @Deprecated
======= fetch "public void setNamespaceURI(String namespaceURI) {" a3fa5d3^:"java/org/apache/tomcat/util/digester/Rule.java"

    @Deprecated
======= fetch "public void begin(String namespace, String name, Attributes attributes)" a3fa5d3^:"java/org/apache/tomcat/util/digester/Rule.java"

    @Deprecated
======= fetch "public void body(String namespace, String name, String text)" a3fa5d3^:"java/org/apache/tomcat/util/digester/Rule.java"

    @Deprecated
    @Deprecated
======= fetch "public SetNextRule(Digester digester, String methodName) {" a3fa5d3^:"java/org/apache/tomcat/util/digester/SetNextRule.java"

    @Deprecated
    @Deprecated
    @Deprecated
    @Deprecated
======= fetch "public SetRootRule(Digester digester, String methodName) {" a3fa5d3^:"java/org/apache/tomcat/util/digester/SetRootRule.java"

    @Deprecated
    @Deprecated
======= fetch "public SetTopRule(Digester digester, String methodName) {" a3fa5d3^:"java/org/apache/tomcat/util/digester/SetTopRule.java"

    @Deprecated

     * matching pattern prefix and default fargment setting.
======= fetch "public void recycle(){" 363b79a^:"java/org/apache/catalina/startup/WebRuleSet.java"

 * Rule to check that the <code>login-config</code> is occuring 
======= fetch "public void begin(String namespace, String name, Attributes attributes)" 363b79a^:"java/org/apache/catalina/startup/WebRuleSet.java"

 * Rule to check that the <code>jsp-config</code> is occuring 
======= fetch "public void begin(String namespace, String name, Attributes attributes)" 363b79a^:"java/org/apache/catalina/startup/WebRuleSet.java"

 * Rule to check that the <code>session-config</code> is occuring 

======= fetch "private static Digester createTldDigester(boolean namespaceAware," 5d9f68b^:"java/org/apache/catalina/startup/TldConfig.java"

     * Attribute value used to turn on/off TLD  namespace awarenes.
======= fetch "public boolean getTldValidation(){" 5d9f68b^:"java/org/apache/catalina/startup/TldConfig.java"

     * @return true if namespace awarenes is enabled.

     *  (if you wish to use a primitive type, specify the corresonding

======= fetch "protected synchronized void stop() {" b6df018^:"java/org/apache/catalina/startup/ContextConfig.java"

        // Removing sercurity role
======= fetch "protected InputSource getContextWebXmlSource() {" b6df018^:"java/org/apache/catalina/startup/ContextConfig.java"

     *                  segemnts) to read

     * Attribute value used to turn on/off XML namespace awarenes.
======= fetch "public boolean getXmlValidation(){" 07e5982^:"java/org/apache/catalina/startup/HostConfig.java"

     * @return true if namespace awarenes is enabled.
======= fetch "public boolean getXmlNamespaceAware(){" 07e5982^:"java/org/apache/catalina/startup/HostConfig.java"

     * Set the namespace aware feature of the XML parser used when
======= fetch "public long getDeploymentTime(String name) {" 07e5982^:"java/org/apache/catalina/startup/HostConfig.java"

     * <code>false</code> if the applciation has not been deployed or does not
======= fetch "public void check(String name) {" 07e5982^:"java/org/apache/catalina/startup/HostConfig.java"

     * Entry point for the admin webapp, and other JMX Context controlers.
======= fetch "public void manageApp(Context context)  {" 07e5982^:"java/org/apache/catalina/startup/HostConfig.java"

     * Entry point for the admin webapp, and other JMX Context controlers.

======= fetch "public void setUseNaming(boolean useNaming) {" ae16eb2^:"java/org/apache/catalina/startup/Embedded.java"

     * Return true if redirction of standard streams is enabled.
======= fetch "public void stop() throws LifecycleException {" ae16eb2^:"java/org/apache/catalina/startup/Embedded.java"

     * If tomcat is embeded in an application that already defines those -

======= fetch "public static MBeanServerConnection accessJMXConnection(Project project," 6908b18^:"java/org/apache/catalina/ant/jmx/JMXAccessorTask.java"

                if (project != null) {
                    project.log("wrong object reference " + refId + " - "
======= fetch "public static MBeanServerConnection accessJMXConnection(Project project," 6908b18^:"java/org/apache/catalina/ant/jmx/JMXAccessorTask.java"

                }
 * @version $Revision:$ $Date:$
======= fetch "public void invoke(Request request, Response response)" 6908b18^:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

        String remoteHost = EMPTY;
======= fetch "public void invoke(Request request, Response response)" 6908b18^:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

        String user = EMPTY;
        if(request != null)
            user = request.getRemoteUser();
        String query="";
        if(request != null)
            query = request.getRequestURI();
======= fetch "public void invoke(Request request, Response response)" 6908b18^:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

        if (pattern.equals("combined") && request != null) {
======= fetch "public void run() {" 6908b18^:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"

                            if (sk!=null) sk.cancel();
======= fetch "public void finalize() {" 6908b18^:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"


 * Boostrap loader for Catalina.  This application constructs a class loader
======= fetch "public void stop()" c060034^:"java/org/apache/catalina/startup/Bootstrap.java"

     * Stop the standlone server.
======= fetch "public void stopServer()" c060034^:"java/org/apache/catalina/startup/Bootstrap.java"

     * Stop the standlone server.

 * <li><b>-help</b> - Display usage information.
 * <li><b>-stop</b> - Stop the currently running instance of Catalina.
======= fetch "protected void usage() {" 481cfe9^:"java/org/apache/catalina/startup/Catalina.java"

             + " [ -nonaming ] { start | stop }");

======= fetch "public static void main(String args[]) {" 3ef0f21^:"java/org/apache/catalina/startup/Bootstrap.java"

                args[0] = "start";
======= fetch "public static void main(String args[]) {" 3ef0f21^:"java/org/apache/catalina/startup/Bootstrap.java"

                args[0] = "stop";

======= fetch "public void visit(Node.UninterpretedTag n) throws JasperException {" f3b04b4^:"java/org/apache/jasper/compiler/Validator.java"

                    // JSP.2.2 - '#{' not allowed in template text
                    String value = attrs.getValue(i);
                    if (!pageInfo.isDeferredSyntaxAllowedAsLiteral()) {
                        if (containsDeferredSyntax(value)) {
                            err.jspError(n, "jsp.error.el.template.deferred");
                        }
                    }
======= fetch "public void visit(Node.UninterpretedTag n) throws JasperException {" f3b04b4^:"java/org/apache/jasper/compiler/Validator.java"

                            attrs.getURI(i), attrs.getLocalName(i), attrs
                                    .getValue(i), n, false);
======= fetch "public void visit(Node.UninterpretedTag n) throws JasperException {" f3b04b4^:"java/org/apache/jasper/compiler/Validator.java"

        /*
         * Look for a #{ sequence that isn't preceded by \.
         */
        private boolean containsDeferredSyntax(String value) {
            if (value == null) {
                return false;
            }
            
            int i = 0;
            int len = value.length();
            boolean prevCharIsEscape = false;
            while (i < value.length()) {
                char c = value.charAt(i);
                if (c == '#' && (i+1) < len && value.charAt(i+1) == '{' && !prevCharIsEscape) {
                    return true;
                } else if (c == '\\') {
                    prevCharIsEscape = true;
                } else {
                    prevCharIsEscape = false;
                }
                i++;
            }
            return false;
        }
======= fetch "private void checkXmlAttributes(Node.CustomTag n," f3b04b4^:"java/org/apache/jasper/compiler/Validator.java"

                                    // The String litteral must be castable to what is declared as type

======= fetch "public void addDateHeader(String name, long value) {" 14084ac^:"java/org/apache/catalina/connector/Response.java"

        if (name == null || name.length() == 0) {
            return;
        }
======= fetch "public void addHeader(String name, String value) {" 14084ac^:"java/org/apache/catalina/connector/Response.java"

        if (name == null || name.length() == 0 || value == null) {
            return;
        }
======= fetch "public void addIntHeader(String name, int value) {" 14084ac^:"java/org/apache/catalina/connector/Response.java"

        if (name == null || name.length() == 0) {
            return;
        }
======= fetch "public void setDateHeader(String name, long value) {" 14084ac^:"java/org/apache/catalina/connector/Response.java"

        if (name == null || name.length() == 0) {
            return;
        }
======= fetch "public void setHeader(String name, String value) {" 14084ac^:"java/org/apache/catalina/connector/Response.java"

        if (name == null || name.length() == 0 || value == null) {
            return;
        }
======= fetch "public void setIntHeader(String name, int value) {" 14084ac^:"java/org/apache/catalina/connector/Response.java"

        if (name == null || name.length() == 0) {
            return;
        }

======= fetch "static boolean isSSLAttribute(String name) {" 7fc56b4^:"java/org/apache/catalina/connector/Request.java"

     * empty <code>Enumeration</code> if there are none.

======= fetch "protected synchronized void checkResources(DeployedApplication app) {" d55f1d9^:"java/org/apache/catalina/startup/HostConfig.java"

                // There is a chance the the resource was only missing
                // temporarily eg renamed during a text editor save
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e1) {
                    // Ignore
                }
                // Recheck the resource to see if it was really deleted
                if (resource.exists()) {
                    continue;
                }

======= fetch "private void parseFileDirectives(Node parent) throws JasperException {" deac657^:"java/org/apache/jasper/compiler/Parser.java"

                parseComment(parent);
======= fetch "private void parseFileDirectives(Node parent) throws JasperException {" deac657^:"java/org/apache/jasper/compiler/Parser.java"

            } else if (reader.matches("%!")) {
                // Declaration
                reader.skipUntil("%>");
            } else if (reader.matches("%=")) {
                // Expression
                reader.skipUntil("%>");
            } else if (reader.matches("%")) {
                // Scriptlet
                reader.skipUntil("%>");

        org.apache.catalina.util.TomcatCSS.TOMCAT_CSS +
        "<table cellspacing=\"4\" width=\"100%\" border=\"0\">\n" +
        "<table cellspacing=\"4\" width=\"100%\" border=\"0\">\n" +
======= fetch "public void doGet(HttpServletRequest request," 99f01fd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        String deployPath = request.getParameter("deployPath");
        String deployConfig = request.getParameter("deployConfig");
        String deployWar = request.getParameter("deployWar");
======= fetch "public void doGet(HttpServletRequest request," 99f01fd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        } else if (command.equals("/deploy")) {
            message = deployInternal(deployConfig, deployPath, deployWar);
======= fetch "public void doGet(HttpServletRequest request," 99f01fd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        } else if (command.equals("/reload")) {
            message = reload(path);
        } else if (command.equals("/undeploy")) {
            message = undeploy(path);
        } else if (command.equals("/expire")) {
            message = expireSessions(path, request);
======= fetch "public void doGet(HttpServletRequest request," 99f01fd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        } else if (command.equals("/start")) {
            message = start(path);
        } else if (command.equals("/stop")) {
            message = stop(path);
======= fetch "public void doPost(HttpServletRequest request," 99f01fd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        if (command == null || !command.equals("/upload")) {
            doGet(request,response);
            return;
        }
======= fetch "public void doPost(HttpServletRequest request," 99f01fd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        String message = upload(request);
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" 99f01fd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <small>\n" +
        "  &nbsp;{1}&nbsp;\n" +
        "  &nbsp;<a href=\"{2}\" onclick=\"return(confirm('''Are you sure?'''))\">{3}</a>&nbsp;\n" +
        "  &nbsp;<a href=\"{4}\" onclick=\"return(confirm('''Are you sure?'''))\">{5}</a>&nbsp;\n" +
        "  &nbsp;<a href=\"{6}\" onclick=\"return(confirm('''Are you sure?'''))\">{7}</a>&nbsp;\n" +
        "  </small>\n" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" 99f01fd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <small>\n" +
        "  &nbsp;<a href=\"{0}\" onclick=\"return(confirm('''Are you sure?'''))\">{1}</a>&nbsp;\n" +
        "  &nbsp;{3}&nbsp;\n" +
        "  &nbsp;{5}&nbsp;\n" +
        "  &nbsp;<a href=\"{6}\" onclick=\"return(confirm('''Are you sure?  This will delete the application.'''))\">{7}</a>&nbsp;\n" +
        "  </small>\n" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" 99f01fd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <small>\n" +
        "  &nbsp;{1}&nbsp;\n" +
        "  &nbsp;<a href=\"{2}\" onclick=\"return(confirm('''Are you sure?'''))\">{3}</a>&nbsp;\n" +
        "  &nbsp;<a href=\"{4}\" onclick=\"return(confirm('''Are you sure?'''))\">{5}</a>&nbsp;\n" +
        "  &nbsp;{7}&nbsp;\n" +
        "  </small>\n" +
======= fetch "public int setSessionMaxInactiveInterval(String path, String sessionId, int maxI" 99f01fd^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <small>\n" +
        "  &nbsp;<a href=\"{0}\" onclick=\"return(confirm('''Are you sure?'''))\">{1}</a>&nbsp;\n" +
        "  &nbsp;{3}&nbsp;\n" +
        "  &nbsp;{5}&nbsp;\n" +
        "  &nbsp;{7}&nbsp;\n" +
        "  </small>\n" +

======= fetch "protected void parseSessionId(org.apache.coyote.Request req, Request request) {" 0f99904^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            // What encoding to use? Some platforms, eg z/os, use a default
            // encoding that doesn't give the expected result so be explicit 
            String enc = connector.getURIEncoding();
            if (enc == null) {
                enc = "ISO-8859-1";
            }
======= fetch "protected void parseSessionId(org.apache.coyote.Request req, Request request) {" 0f99904^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            if (semicolon2 >= 0) {
                request.setRequestedSessionId
                    (new String(uriBC.getBuffer(), start + sessionIdStart, 
                            semicolon2 - sessionIdStart));
                // Extract session ID from request URI
                byte[] buf = uriBC.getBuffer();
                for (int i = 0; i < end - start - semicolon2; i++) {
                    buf[start + semicolon + i] 
                        = buf[start + i + semicolon2];
======= fetch "protected void parseSessionId(org.apache.coyote.Request req, Request request) {" 0f99904^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                uriBC.setBytes(buf, start, end - start - semicolon2 + semicolon);
            } else {
                request.setRequestedSessionId
                    (new String(uriBC.getBuffer(), start + sessionIdStart, 
                            (end - start) - sessionIdStart));
                uriBC.setEnd(start + semicolon);
======= fetch "protected void parseSessionId(org.apache.coyote.Request req, Request request) {" 0f99904^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            request.setRequestedSessionURL(true);

======= fetch "public void init()" 73bb9e4^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

            } catch (BindException be) {
======= fetch "public void init()" 73bb9e4^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

                    throw new BindException(be.getMessage() + "<null>:" + getPort());
======= fetch "public void init()" 73bb9e4^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

                    throw new BindException(be.getMessage() + " " +
                            getAddress().toString() + ":" + getPort());

======= fetch "public void doGet(HttpServletRequest req, HttpServletResponse res)" 189181a^:"test/org/apache/catalina/startup/TestTomcat.java"

     * Simple servlet to test iJNDI 
======= fetch "public void doGet(HttpServletRequest req, HttpServletResponse res)" 189181a^:"test/org/apache/catalina/startup/TestTomcat.java"

    /**
     * Servlet that tries to obtain a URL for WEB-INF/web.xml
     */
    public static class GetResource extends HttpServlet {
        
        private static final long serialVersionUID = 1L;
        
        public void doGet(HttpServletRequest req, HttpServletResponse res) 
        throws IOException {
            URL url = req.getServletContext().getResource("/WEB-INF/web.xml");
         
            res.getWriter().write("The URL obtained for /WEB-INF/web.xml was ");
            if (url == null) {
                res.getWriter().write("null");
            } else {
                res.getWriter().write(url.toString());
            }
        }
    }
    
======= fetch "public void testProgrammatic() throws Exception {" 189181a^:"test/org/apache/catalina/startup/TestTomcat.java"

        assertEquals(res.toString(), "Hello world");
======= fetch "public void testSingleWebapp() throws Exception {" 189181a^:"test/org/apache/catalina/startup/TestTomcat.java"

        // Currently in sandbox/tomcat-lite
======= fetch "public void testEnableNaming() throws Exception {" 189181a^:"test/org/apache/catalina/startup/TestTomcat.java"

        assertEquals(res.toString(), "Hello, Tomcat User");
======= fetch "public void testEnableNaming() throws Exception {" 189181a^:"test/org/apache/catalina/startup/TestTomcat.java"

     * Test for https://issues.apache.org/bugzilla/show_bug.cgi?id=47866
     */
    public void testGetResource() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        
        // Must have a real docBase - just use temp
        StandardContext ctx = 
            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
        // You can customize the context by calling 
        // its API
        
        Tomcat.addServlet(ctx, "myServlet", new GetResource());
        ctx.addServletMapping("/", "myServlet");
        
        tomcat.start();
        
        int rc =getUrl("http://localhost:" + getPort() + "/", new ByteChunk(),
                null);
        assertEquals(HttpServletResponse.SC_OK, rc);
    }
    /**

======= fetch "private final void internalMapWrapper(Context context, CharChunk path," a31d52f^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

                (path.getBuffer(), pathOffset, pathEnd);

======= fetch "public void setMaxThreads(int maxThreads) {" aaf7b5d^:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    public int getMaxThreads() { return maxThreads; }

    protected static final int TCN_REQUIRED_PATCH = 8;
    protected static final int TCN_RECOMMENDED_PV = 16;
======= fetch "public void action(ActionCode actionCode, Object param) {" e9248d7^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                    // certLength == -1 indicates an error
======= fetch "public void action(ActionCode actionCode, Object param) {" e9248d7^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                    if (clientCert != null) {
======= fetch "public void action(ActionCode actionCode, Object param) {" e9248d7^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                 // Consume and buffer the request body, so that it does not
                 // interfere with the client's handshake messages
======= fetch "public void action(ActionCode actionCode, Object param) {" e9248d7^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                    // Renegociate certificates
                    SSLSocket.renegotiate(socket);
                    // Get client certificate and the certificate chain if present
                    int certLength = SSLSocket.getInfoI(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN);
                    byte[] clientCert = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT);
                    X509Certificate[] certs = null;
                    if (clientCert != null) {
                        certs = new X509Certificate[certLength + 1];
                        CertificateFactory cf = CertificateFactory.getInstance("X.509");
                        certs[0] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(clientCert));
                        for (int i = 0; i < certLength; i++) {
                            byte[] data = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
                            certs[i+1] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data));
======= fetch "public void action(ActionCode actionCode, Object param) {" e9248d7^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                    }
                    if (certs != null) {
                        request.setAttribute(AprEndpoint.CERTIFICATE_KEY, certs);
======= fetch "public static native int attach(long ctx, long sock)" e9248d7^:"java/org/apache/tomcat/jni/SSLSocket.java"

     * usually there is no acknowledgment step between the headers and the
======= fetch "public static native int attach(long ctx, long sock)" e9248d7^:"java/org/apache/tomcat/jni/SSLSocket.java"

     * Retrun SSL Info parameter as byte array.
======= fetch "public static native int attach(long ctx, long sock)" e9248d7^:"java/org/apache/tomcat/jni/SSLSocket.java"

     * Retrun SSL Info parameter as String.
======= fetch "public static native String getInfoS(long sock, int id)" e9248d7^:"java/org/apache/tomcat/jni/SSLSocket.java"

     * Retrun SSL Info parameter as integer.

======= fetch "protected void initBaseDir() {" 59e88f1^:"java/org/apache/catalina/startup/Tomcat.java"

     * Sets the log level to WARN for the loggers that log information on
     * Tomcat start up. This prevents the usual startup information being
     * logged to the console.
======= fetch "protected void initBaseDir() {" 59e88f1^:"java/org/apache/catalina/startup/Tomcat.java"

    public void setSilent() {
======= fetch "public void setSilent() {" 59e88f1^:"java/org/apache/catalina/startup/Tomcat.java"

            Logger.getLogger(s).setLevel(Level.WARNING);

======= fetch "public StandardContext addContext(String contextPath," 6cce550^:"java/org/apache/catalina/startup/Tomcat.java"

    public StandardWrapper addServlet(String contextPath, 
                                      String servletName, 
                                      String servletClass) {
        Container ctx = getHost().findChild(contextPath);
        return addServlet((StandardContext) ctx, 
                servletName, servletClass);
    }
    
======= fetch "public StandardWrapper addServlet(String contextPath," 6cce550^:"java/org/apache/catalina/startup/Tomcat.java"

     *    
     * @param contextPath   Context to add Servlet to
     * @param servletName   Servlet name (used in mappings)
     * @param servletClass  The class to be used for the Servlet
     * @return The wrapper for the servlet
     */
    public StandardWrapper addServlet(String contextPath, 
            String servletName, 
            String servletClass) {
        Container ctx = getHost().findChild(contextPath);
        return addServlet((StandardContext) ctx, 
                servletName, servletClass);
    }
    /**
     * Static version of {@link #addServlet(String, String, String)
     * @param ctx           Context to add Servlet to
     * @param servletName   Servlet name (used in mappings)
     * @param servletClass  The class to be used for the Servlet
     * @return The wrapper for the servlet
======= fetch "public static StandardWrapper addServlet(StandardContext ctx," 6cce550^:"java/org/apache/catalina/startup/Tomcat.java"

    /** Use an existing servlet, no class.forName or initialization will be 
     *  performed
======= fetch "public void enableNaming() {" 6cce550^:"java/org/apache/catalina/startup/Tomcat.java"

     *  
     * @param contextPath   The context to set the defaults for
     */
    public void initWebappDefaults(String contextPath) {
        Container ctx = getHost().findChild(contextPath);
        initWebappDefaults((StandardContext) ctx);
    }
    
    /**
     * Static version of {@link #initWebappDefaults(String)
     * @param ctx   The context to set the defaults for
======= fetch "public static void initWebappDefaults(StandardContext ctx) {" 6cce550^:"java/org/apache/catalina/startup/Tomcat.java"

    /** Fix startup sequence - required if you don't use web.xml.
======= fetch "public static void initWebappDefaults(StandardContext ctx) {" 6cce550^:"java/org/apache/catalina/startup/Tomcat.java"

     *  The start() method in context will set 'configured' to false - and
     *  expects a listener to set it back to true.
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 6cce550^:"java/org/apache/catalina/startup/Tomcat.java"

    /** Helper class for wrapping existing servlets. This disables servlet 

======= fetch "private ClassLoader createClassLoader(String name, ClassLoader parent)" 720de5e^:"java/org/apache/catalina/startup/Bootstrap.java"

                log.debug("Expanded " + before + " to " + replace);

======= fetch "protected void sessions(PrintWriter writer, String path, int idle) {" 6ab874a^:"java/org/apache/catalina/manager/ManagerServlet.java"

            if (0==histoInterval)
                histoInterval=1;

======= fetch "private final void internalMapWrapper(Context context, CharChunk path," fe53ca9^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

        /* welcome file processing - take 2
         * Now that we have looked for welcome files with a physical
         * backing, now look for an extension mapping listed
         * but may not have a physical backing to it. This is for 
         * the case of index.jsf, index.do, etc.
         * A watered down version of rule 4
         */
        if (mappingData.wrapper == null) {
            boolean checkWelcomeFiles = checkJspWelcomeFiles;
            if (!checkWelcomeFiles) {
                char[] buf = path.getBuffer();
                checkWelcomeFiles = (buf[pathEnd - 1] == '/');
            }
            if (checkWelcomeFiles) {
                for (int i = 0; (i < context.welcomeResources.length)
                         && (mappingData.wrapper == null); i++) {
                    path.setOffset(pathOffset);
                    path.setEnd(pathEnd);
                    path.append(context.welcomeResources[i], 0,
                                context.welcomeResources[i].length());
                    path.setOffset(servletPath);
                    internalMapExtensionWrapper(extensionWrappers,
                                                path, mappingData);
                }
                path.setOffset(servletPath);
                path.setEnd(pathEnd);
            }
        }

    public static final String[] statements = {"createStatement","prepareStatement","prepareCall"};
    public static final String[] executes = {"execute","executeQuery","executeUpdate","executeBatch"};
======= fetch "public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl" 4f5a5e4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractCreateStatementInterceptor.java"

            process = process(statements, method, process);
======= fetch "public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl" 4f5a5e4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractCreateStatementInterceptor.java"

     * @param method the method that was called. It will be one of the methods defined in {@link #statements}
======= fetch "public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl" 4f5a5e4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractCreateStatementInterceptor.java"

        new Constructor[AbstractCreateStatementInterceptor.statements.length];
======= fetch "protected String reportFailedQuery(String query, Object[] args, final String nam" 4f5a5e4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

        if (sql==null && compare(executes[3],name)) {
======= fetch "protected String reportQuery(String query, Object[] args, final String name, lon" 4f5a5e4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

        if (sql==null && compare(executes[3],name)) {
======= fetch "protected String reportSlowQuery(String query, Object[] args, final String name," 4f5a5e4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

        if (sql==null && compare(executes[3],name)) {
======= fetch "public Object createStatement(Object proxy, Method method, Object[] args, Object" 4f5a5e4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

            if (compare(statements[0],name)) {
======= fetch "public Object createStatement(Object proxy, Method method, Object[] args, Object" 4f5a5e4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

                constructor = getConstructor(0,Statement.class);
            }else if (compare(statements[1],name)) {
======= fetch "public Object createStatement(Object proxy, Method method, Object[] args, Object" 4f5a5e4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

                constructor = getConstructor(1,PreparedStatement.class);
======= fetch "public Object createStatement(Object proxy, Method method, Object[] args, Object" 4f5a5e4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

            }else if (compare(statements[2],name)) {
======= fetch "public Object createStatement(Object proxy, Method method, Object[] args, Object" 4f5a5e4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

                constructor = getConstructor(2,CallableStatement.class);
======= fetch "public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl" 4f5a5e4^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

            process = process(executes, method, process);

======= fetch "protected void tearDown() throws Exception {" 278dedc^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestConcurrency.java"

        Driver.reset();
======= fetch "protected void tearDown() throws Exception {" 278dedc^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestConcurrency.java"

        Driver.reset();
======= fetch "public void run() {" 278dedc^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestConcurrency.java"

                assertEquals("Size comparison:",10, ds.getPool().getSize());

======= fetch "public boolean add(E e) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public int drainTo(Collection<? super E> c, int maxElements) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean addAll(Collection<? extends E> c) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public void clear() {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean isEmpty() {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean removeAll(Collection<?> c) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean retainAll(Collection<?> c) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean retainAll(Collection<?> c) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean retainAll(Collection<?> c) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public E element() {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public E peek() {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean add(E e) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public int drainTo(Collection<? super E> c, int maxElements) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean addAll(Collection<? extends E> c) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public void clear() {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean isEmpty() {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean removeAll(Collection<?> c) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean retainAll(Collection<?> c) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean retainAll(Collection<?> c) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public boolean retainAll(Collection<?> c) {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public E element() {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported
======= fetch "public E peek() {" abbb922^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperation - this operation is not supported

    @Override
    public void setUp() throws Exception {
        super.setUp();
    }
    @Override
    public void tearDown() throws Exception {
        super.tearDown();
    }
======= fetch "public void testBug37794() throws Exception {" a9e00d5^:"test/org/apache/catalina/connector/TestRequest.java"

        client.setPort(getPort());
======= fetch "public void testBug37794() throws Exception {" a9e00d5^:"test/org/apache/catalina/connector/TestRequest.java"

        private static final long serialVersionUID = 1L;
======= fetch "protected void doPost(HttpServletRequest req, HttpServletResponse resp)" a9e00d5^:"test/org/apache/catalina/connector/TestRequest.java"

    private static class Bug37794Client extends SimpleHttpClient {
======= fetch "private Exception doRequest(int postLimit, boolean ucChunkedHead) {" a9e00d5^:"test/org/apache/catalina/connector/TestRequest.java"

            Tomcat tomcat = new Tomcat();
======= fetch "private Exception doRequest(int postLimit, boolean ucChunkedHead) {" a9e00d5^:"test/org/apache/catalina/connector/TestRequest.java"

                StandardContext root = tomcat.addContext("", TEMP_DIR);
                Tomcat.addServlet(root, "Bug37794", new Bug37794Servlet());
                root.addServletMapping("/test", "Bug37794");
======= fetch "private Exception doRequest(int postLimit, boolean ucChunkedHead) {" a9e00d5^:"test/org/apache/catalina/connector/TestRequest.java"

                tomcat.start();
======= fetch "private Exception doRequest(int postLimit, boolean ucChunkedHead) {" a9e00d5^:"test/org/apache/catalina/connector/TestRequest.java"

            } finally {
                try {
                    tomcat.stop();
                } catch (Exception e) {
                    // Ignore
                }
======= fetch "public boolean isResponseBodyOK() {" a9e00d5^:"test/org/apache/catalina/connector/TestRequest.java"

        private int port = 8080;
======= fetch "public boolean isResponseBodyOK() {" a9e00d5^:"test/org/apache/catalina/connector/TestRequest.java"

        public void setPort(int thePort) {
            port = thePort;
        }
======= fetch "public void connect() throws UnknownHostException, IOException {" a9e00d5^:"test/org/apache/catalina/connector/TestRequest.java"

            socket = new Socket("localhost", 8080);
    Tomcat tomcat;
    // if you run in eclipse - or tomcat src dir 
    String base = "./"; 
    File tempDir;
    static int port = 8001;
    long t0;
    
======= fetch "public void doGet(HttpServletRequest req, HttpServletResponse res)" a9e00d5^:"test/org/apache/catalina/startup/TestTomcat.java"

    public void setUp() throws Exception {
        t0 = System.currentTimeMillis();
        tempDir = new File(base + "output/tmp");
        tempDir.mkdir();
        
        tomcat = new Tomcat();
        tomcat.setBaseDir(tempDir.getAbsolutePath());
        tomcat.getHost().setAppBase(tempDir.getAbsolutePath() + "/webapps");
          
        // If each test is running on same port - they
        // may interfere with each other (on unix at least)
        port++;
        tomcat.setPort(port);
    }
    
    public void tearDown() throws Exception {
        tomcat.stop();
        System.err.println("Test time: " + 
                (System.currentTimeMillis() - t0));
        ExpandWar.delete(tempDir);
    }
    
======= fetch "public void testProgrammatic() throws Exception {" a9e00d5^:"test/org/apache/catalina/startup/TestTomcat.java"

        Tomcat tomcat = getTomcatInstance();
======= fetch "public void testProgrammatic() throws Exception {" a9e00d5^:"test/org/apache/catalina/startup/TestTomcat.java"

        // Must have a real docBase - just use temp
======= fetch "public void testProgrammatic() throws Exception {" a9e00d5^:"test/org/apache/catalina/startup/TestTomcat.java"

            tomcat.addContext("/", 
                    tempDir.getAbsolutePath());
======= fetch "public void testProgrammatic() throws Exception {" a9e00d5^:"test/org/apache/catalina/startup/TestTomcat.java"

        ByteChunk res = getUrl("http://localhost:" + port + "/");
======= fetch "public void testSingleWebapp() throws Exception {" a9e00d5^:"test/org/apache/catalina/startup/TestTomcat.java"

        Tomcat tomcat = getTomcatInstance();
======= fetch "public void testSingleWebapp() throws Exception {" a9e00d5^:"test/org/apache/catalina/startup/TestTomcat.java"

            new File(base + "output/build/webapps/examples");
======= fetch "public void testSingleWebapp() throws Exception {" a9e00d5^:"test/org/apache/catalina/startup/TestTomcat.java"

        ByteChunk res = getUrl("http://localhost:" + port + "/examples/servlets/servlet/HelloWorldExample");
======= fetch "public void testLaunchTime() throws Exception {" a9e00d5^:"test/org/apache/catalina/startup/TestTomcat.java"

        tomcat.addContext(null, "/", base);
======= fetch "public void testLaunchTime() throws Exception {" a9e00d5^:"test/org/apache/catalina/startup/TestTomcat.java"

    }

======= fetch "public void setUp() throws Exception {" cfb18a0^:"test/org/apache/catalina/startup/TestTomcat.java"

        tempDir = new File("output/tmp");
======= fetch "public void setUp() throws Exception {" cfb18a0^:"test/org/apache/catalina/startup/TestTomcat.java"

        tomcat.getHost().setAppBase(tempDir.getAbsolutePath());
======= fetch "public void setUp() throws Exception {" cfb18a0^:"test/org/apache/catalina/startup/TestTomcat.java"

        tomcat.getHost().setAppBase(tempDir.getAbsolutePath() + "/webapps");
======= fetch "public void tearDown() throws Exception {" cfb18a0^:"test/org/apache/catalina/startup/TestTomcat.java"

        ExpandWar.delete(tempDir);

======= fetch "public static String interpreterCall(boolean isTagFile, String expression," 768af9f^:"java/org/apache/jasper/compiler/JspUtil.java"

        String targetType = expectedType.getName();

======= fetch "public void service (HttpServletRequest request," 50d0e6e^:"java/org/apache/jasper/servlet/JspServlet.java"

            log.debug("\t  Request Params: ");
            Enumeration<String> e = request.getParameterNames();
            while (e.hasMoreElements()) {
                String name = e.nextElement();
                log.debug("\t\t " + name + " = " 
                          + request.getParameter(name));
            }

     *     executing <code>context.invokeNext()</code>.
     *     <code>invokeNext()</code> method has returned.
     *     specified Response after the <code>invokeNext()</code> method has

======= fetch "protected void clearReferences() {" a9f0239^:"java/org/apache/catalina/loader/WebappClassLoader.java"

            Iterator<ResourceEntry> loadedClasses = ((HashMap<String, ResourceEntry>) resourceEntries.clone()).values().iterator();

======= fetch "public void invoke(Request request, Response response) throws IOException," f0d447d^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

             && getCluster() != null
======= fetch "public void invoke(Request request, Response response) throws IOException," f0d447d^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

             if (manager != null && manager instanceof ClusterManager
                     && getCluster().getManager(((ClusterManager)manager).getName()) != null)
======= fetch "protected void changeSessionID(Request request," f0d447d^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

        // now sending the change to all other clusternode!
        ClusterManager manager = (ClusterManager)catalinaSession.getManager();
        sendSessionIDClusterBackup(manager,request,sessionId, newSessionID);
======= fetch "public void start() throws LifecycleException {" f0d447d^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

        if (cluster == null) {
            throw new RuntimeException("No clustering support at container "
                    + container.getName());
        }
======= fetch "public void start() throws LifecycleException {" f0d447d^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

        if (log.isInfoEnabled())
======= fetch "public void start() throws LifecycleException {" f0d447d^:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

            if (cluster == null)
                log.info(sm.getString("jvmRoute.noCluster"));
        }

======= fetch "public ClusterMessage requestCompleted(String sessionId) {" 83e98da^:"java/org/apache/catalina/ha/session/DeltaManager.java"

            if (msg != null) session.setLastTimeReplicated(System.currentTimeMillis());

======= fetch "public StandardSession(Manager manager) {" 6f3e56e^:"java/org/apache/catalina/session/StandardSession.java"

    protected transient boolean expiring = false;
======= fetch "public StandardSession(Manager manager) {" 6f3e56e^:"java/org/apache/catalina/session/StandardSession.java"

    protected boolean isValid = false;
======= fetch "public void expire(boolean notify) {" 6f3e56e^:"java/org/apache/catalina/session/StandardSession.java"

        // Mark this session as "being expired" if needed
        if (expiring)
======= fetch "public void expire(boolean notify) {" 6f3e56e^:"java/org/apache/catalina/session/StandardSession.java"

            // Check again, now we are inside the sync so this code only runs once
            // Double check locking - expiring and isValid need to be volatile
            if (expiring || !isValid)
                return;
======= fetch "public void expire(boolean notify) {" 6f3e56e^:"java/org/apache/catalina/session/StandardSession.java"

            // Mark this session as "being expired"

    protected ExecutorService executor = new ThreadPoolExecutor(0, 2, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
======= fetch "public void start() throws IOException {" aa8a2d3^:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

            TaskQueue taskqueue = new TaskQueue();
======= fetch "public void start() throws IOException {" aa8a2d3^:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

            executor = new ThreadPoolExecutor(minThreads, maxThreads, maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf);
            taskqueue.setParent((ThreadPoolExecutor)executor);
======= fetch "public void setUdpTxBufSize(int udpTxBufSize) {" aa8a2d3^:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

 // ---------------------------------------------- TaskQueue Inner Class
    class TaskQueue extends LinkedBlockingQueue<Runnable> {
        ThreadPoolExecutor parent = null;
        public TaskQueue() {
            super();
        }
        public TaskQueue(int initialCapacity) {
            super(initialCapacity);
        }
        public TaskQueue(Collection<? extends Runnable> c) {
            super(c);
        }
        public void setParent(ThreadPoolExecutor tp) {
            parent = tp;
        }
        
        public boolean force(Runnable o) {
            if ( parent.isShutdown() ) throw new RejectedExecutionException("Executor not running, can't force a command into the queue");
            return super.offer(o); //forces the item onto the queue, to be used if the task is rejected
        }
        public boolean offer(Runnable o) {
            //we can't do any checks
            if (parent==null) return super.offer(o);
            //we are maxed out on threads, simply queue the object
            if (parent.getPoolSize() == parent.getMaximumPoolSize()) return super.offer(o);
            //we have idle threads, just add it to the queue
            //this is an approximation, so it could use some tuning
            if (parent.getActiveCount()<(parent.getPoolSize())) return super.offer(o);
            //if we have less threads than maximum force creation of a new thread
            if (parent.getPoolSize()<parent.getMaximumPoolSize()) return false;
            //if we reached here, we need to add it to the queue
            return super.offer(o);
        }
    }

======= fetch "public GenericPrincipal(Realm realm, String name, String password," 80f8ec6^:"java/org/apache/catalina/realm/GenericPrincipal.java"

        this(realm, name, password, roles, userPrincipal, null);
    }
    
    /**
     * Construct a new Principal, associated with the specified Realm, for the
     * specified username and password, with the specified role names
     * (as Strings).
     *
     * @param realm The Realm that owns this principal
     * @param name The username of the user represented by this Principal
     * @param password Credentials used to authenticate this user
     * @param roles List of roles (must be Strings) possessed by this user
     * @param userPrincipal - the principal to be returned from the request 
     *        getUserPrincipal call if not null; if null, this will be returned
     * @param loginContext  - If provided, this will be used to log out the user
     *        at the appropriate time
     */
    public GenericPrincipal(Realm realm, String name, String password,
                            List<String> roles, Principal userPrincipal,
                            LoginContext loginContext) {
======= fetch "public GenericPrincipal(Realm realm, String name, String password," 80f8ec6^:"java/org/apache/catalina/realm/GenericPrincipal.java"

        this.loginContext = loginContext;
======= fetch "public Principal getUserPrincipal() {" 80f8ec6^:"java/org/apache/catalina/realm/GenericPrincipal.java"

    
    /**
     * The JAAS LoginContext, if any, used to authenticate this Principal.
     * Kept so we can call logout().
     */
    protected LoginContext loginContext = null;
    public LoginContext getLoginContext() {
        return loginContext;
    }
======= fetch "protected Principal authenticate(String username," 80f8ec6^:"java/org/apache/catalina/realm/JAASRealm.java"

        Principal principal = createPrincipal(username, subject);
======= fetch "protected Principal getPrincipal(String username) {" 80f8ec6^:"java/org/apache/catalina/realm/JAASRealm.java"

     * @param loginContext Associated with th Princpal so
     *                     {@link LoginContext#logout()} can be called later
======= fetch "protected Principal getPrincipal(String username) {" 80f8ec6^:"java/org/apache/catalina/realm/JAASRealm.java"

    protected Principal createPrincipal(String username, Subject subject) {
======= fetch "protected Principal createPrincipal(String username, Subject subject) {" 80f8ec6^:"java/org/apache/catalina/realm/JAASRealm.java"

        return new GenericPrincipal(this, username, null, roles, userPrincipal);
======= fetch "public void expire(boolean notify) {" 80f8ec6^:"java/org/apache/catalina/session/StandardSession.java"

            // Call the JAAS logout method if necessary
            if (principal instanceof GenericPrincipal) {
                GenericPrincipal gp = (GenericPrincipal) principal;
                if (gp.getLoginContext() != null) {
                    try {
                        gp.getLoginContext().logout();
                    } catch (LoginException e) {
                        manager.getContainer().getLogger().error(
                                sm.getString("standardSession.jaaslogoutfail"),
                                e);
                    }
                }
            }

======= fetch "public void applyDiff(byte[] diff, int offset, int length) throws IOException, C" c1099f7^:"java/org/apache/catalina/ha/session/DeltaSession.java"

                    getDeltaRequest().execute(this);

    
    private Set<String> varInfoNames;
======= fetch "public void visit(Node.GetProperty n) throws JasperException {" 202a33e^:"java/org/apache/jasper/compiler/Generator.java"

            } else {
                // The object could be a custom action with an associated
======= fetch "public void visit(Node.GetProperty n) throws JasperException {" 202a33e^:"java/org/apache/jasper/compiler/Generator.java"

                                + "(_jspx_page_context.getAttribute(\""
======= fetch "public void visit(Node.GetProperty n) throws JasperException {" 202a33e^:"java/org/apache/jasper/compiler/Generator.java"

                                + "\", PageContext.PAGE_SCOPE), \""
======= fetch "public void visit(Node.GetProperty n) throws JasperException {" 202a33e^:"java/org/apache/jasper/compiler/Generator.java"

            } else {
                StringBuilder msg =
                    new StringBuilder("jsp:getProperty for bean with name '");
                msg.append(name);
                msg.append(
                        "'. Name was not previously introduced as per JSP.5.3");
                
                throw new JasperException(msg.toString());
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" 202a33e^:"java/org/apache/jasper/compiler/Generator.java"

            
            // Add the named objects to the lits of 'introduced' names to enable
            // a later test as per JSP.5.3
            VariableInfo[] infos = n.getVariableInfos();
            if (infos != null && infos.length > 0) {
                for (int i = 0; i < infos.length; i++) {
                    VariableInfo info = infos[i];
                    if (info != null && info.getVarName() != null)
                    pageInfo.getVarInfoNames().add(info.getVarName());
                }
            }
            
======= fetch "private void generatePostamble() {" 202a33e^:"java/org/apache/jasper/compiler/Generator.java"

        varInfoNames = pageInfo.getVarInfoNames();
    private Set<String> varInfoNames;
        this.varInfoNames = new HashSet<String>();
======= fetch "public void setTrimDirectiveWhitespaces(boolean trimDirectiveWhitespaces) {" 202a33e^:"java/org/apache/jasper/compiler/PageInfo.java"

    public Set<String> getVarInfoNames() {
        return varInfoNames;
    }

======= fetch "protected boolean compareCredentials(DirContext context," c6818a0^:"java/org/apache/catalina/realm/JNDIRealm.java"

            // iPlanet support if the values starts with {SHA1}
======= fetch "protected boolean compareCredentials(DirContext context," c6818a0^:"java/org/apache/catalina/realm/JNDIRealm.java"

            if (password.startsWith("{SHA}")) {

======= fetch "public void testDBCPThreads10Connections10Validate() throws Exception {" d92da6e^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

        this.datasource.getPoolProperties().setValidationQuery("SELECT 1");
======= fetch "public void testPoolThreads10Connections10Validate() throws Exception {" d92da6e^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

        this.datasource.getPoolProperties().setValidationQuery("SELECT 1");
======= fetch "public void testPoolThreads10Connections10ValidateFair() throws Exception {" d92da6e^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

        this.datasource.getPoolProperties().setValidationQuery("SELECT 1");
======= fetch "public void testC3P0Threads10Connections10Validate() throws Exception {" d92da6e^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

        this.datasource.getPoolProperties().setValidationQuery("SELECT 1");
======= fetch "public void testDBCPThreads20Connections10Validate() throws Exception {" d92da6e^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

        this.datasource.getPoolProperties().setValidationQuery("SELECT 1");
======= fetch "public void testPoolThreads10Connections20Validate() throws Exception {" d92da6e^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

        this.datasource.getPoolProperties().setValidationQuery("SELECT 1");
======= fetch "public void testPoolThreads10Connections20ValidateFair() throws Exception {" d92da6e^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

        this.datasource.getPoolProperties().setValidationQuery("SELECT 1");
======= fetch "public void testC3P0Threads10Connections20Validate() throws Exception {" d92da6e^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

        this.datasource.getPoolProperties().setValidationQuery("SELECT 1");
======= fetch "public DefaultProperties() {" d92da6e^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/DefaultProperties.java"

        url = "jdbc:mysql://localhost:3306/mysql?autoReconnect=true";
        driverClassName = "com.mysql.jdbc.Driver";
        password = "password";
        username = "root";
======= fetch "public DefaultProperties() {" d92da6e^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/DefaultProperties.java"

        validationQuery = "SELECT 1";
======= fetch "public void testFastSql() throws Exception {" d92da6e^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestSlowQueryReport.java"

        String slowSql = "select 1";
======= fetch "public void testFastSql() throws Exception {" d92da6e^:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestSlowQueryReport.java"

            ResultSet rs = st.executeQuery(slowSql);

======= fetch "public void connect() throws SQLException {" ef96fa2^:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        if (connection==null) {
            throw new SQLException("Driver:"+driver+" returned null for URL:"+driverURL);
        }
        

======= fetch "private void initSecurity() {" 76a4eb3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                // Create a file read permission for web app tempdir (work)
                // directory
======= fetch "private void initSecurity() {" 76a4eb3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                        (new FilePermission(workDir,"read"));
======= fetch "private void initSecurity() {" 76a4eb3^:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                permissionCollection.add(new FilePermission(workDir,"read"));

======= fetch "public void setRecoverySleepTime(long recoverySleepTime) {" 51fd68b^:"java/org/apache/catalina/tribes/membership/McastService.java"

    public void setLocalLoopbackDisabled(boolean localLoopbackDisabled) {
        properties.setProperty("localLoopbackDisabled",String.valueOf(localLoopbackDisabled));
    }
======= fetch "public void start(int level) throws java.lang.Exception {" 51fd68b^:"java/org/apache/catalina/tribes/membership/McastService.java"

                                    this);
======= fetch "public McastServiceImpl(" 51fd68b^:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

        MessageListener msgservice)
======= fetch "public McastServiceImpl(" 51fd68b^:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

        this.localLoopbackDisabled = localLoopbackDisabled;
======= fetch "protected void setupSocket() throws IOException {" 51fd68b^:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

        socket.setLoopbackMode(true); //hint that we don't need loop back messages

======= fetch "protected void handleSESSION_CREATED(SessionMessage msg,Member sender) {" c768090^:"java/org/apache/catalina/ha/session/DeltaManager.java"

        if(notifySessionListenersOnReplication)
======= fetch "protected void handleSESSION_CREATED(SessionMessage msg,Member sender) {" c768090^:"java/org/apache/catalina/ha/session/DeltaManager.java"

        else
======= fetch "protected void handleSESSION_CREATED(SessionMessage msg,Member sender) {" c768090^:"java/org/apache/catalina/ha/session/DeltaManager.java"

            add(session);
        }

======= fetch "public void replicate(Object key, boolean complete) {" b3e2be4^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    rentry.resetDiff();

======= fetch "protected void deployWAR(String contextPath, File war, String file) {" cc1f0dd^:"java/org/apache/catalina/startup/HostConfig.java"

                deployedApp.redeployResources.put
                    (xml.getAbsolutePath(), new Long(xml.lastModified()));
======= fetch "protected void deployWAR(String contextPath, File war, String file) {" cc1f0dd^:"java/org/apache/catalina/startup/HostConfig.java"

            if (deployXML && xml.exists()) {
                deployedApp.redeployResources.put
                (xml.getAbsolutePath(), new Long(xml.lastModified()));
            }
======= fetch "protected void deployDirectory(String contextPath, File dir, String file) {" cc1f0dd^:"java/org/apache/catalina/startup/HostConfig.java"

            File xmlCopy = null;
======= fetch "protected void deployDirectory(String contextPath, File dir, String file) {" cc1f0dd^:"java/org/apache/catalina/startup/HostConfig.java"

                File xmlCopy = new File(configBase(), file + ".xml");
======= fetch "protected void deployDirectory(String contextPath, File dir, String file) {" cc1f0dd^:"java/org/apache/catalina/startup/HostConfig.java"

                deployedApp.redeployResources.put
                    (xmlCopy.getAbsolutePath(), new Long(xmlCopy.lastModified()));
======= fetch "protected void deployDirectory(String contextPath, File dir, String file) {" cc1f0dd^:"java/org/apache/catalina/startup/HostConfig.java"

            if (xmlCopy != null) {
                deployedApp.redeployResources.put
                (xmlCopy.getAbsolutePath(), new Long(xmlCopy.lastModified()));
            }

======= fetch "public StandardSession(Manager manager) {" 468f370^:"java/org/apache/catalina/session/StandardSession.java"

     * The <code>java.lang.Method</code> for the
     * <code>fireContainerEvent()</code> method of the
     * <code>org.apache.catalina.core.StandardContext</code> method,
     * if our Context implementation is of this class.  This value is
     * computed dynamically the first time it is needed, or after
     * a session reload (since it is declared transient).
     */
    protected transient Method containerEventMethod = null;
    /**
     * The method signature for the <code>fireContainerEvent</code> method.
     */
    protected static final Class<?> containerEventTypes[] =
        { String.class, Object.class };
    /**
======= fetch "protected void fireContainerEvent(Context context," 468f370^:"java/org/apache/catalina/session/StandardSession.java"

        if (!"org.apache.catalina.core.StandardContext".equals
            (context.getClass().getName())) {
            return; // Container events are not supported
======= fetch "protected void fireContainerEvent(Context context," 468f370^:"java/org/apache/catalina/session/StandardSession.java"

        // NOTE:  Race condition is harmless, so do not synchronize
        if (containerEventMethod == null) {
            containerEventMethod =
                context.getClass().getMethod("fireContainerEvent",
                                             containerEventTypes);
        }
        Object containerEventParams[] = new Object[2];
        containerEventParams[0] = type;
        containerEventParams[1] = data;
        containerEventMethod.invoke(context, containerEventParams);

    private String dateStamp = "";
    private long currentMillis = 0;
======= fetch "public synchronized boolean rotate(String newFileName) {" f00029e^:"java/org/apache/catalina/valves/AccessLogValve.java"

            currentDate = new Date(System.currentTimeMillis());
            dateStamp = fileDateFormatter.format(currentDate);
======= fetch "public void log(String message) {" f00029e^:"java/org/apache/catalina/valves/AccessLogValve.java"

                // We need a new currentDate
                currentDate = new Date(systime);
======= fetch "public void log(String message) {" f00029e^:"java/org/apache/catalina/valves/AccessLogValve.java"

                String tsDate = fileDateFormatter.format(currentDate);
======= fetch "public void log(String message) {" f00029e^:"java/org/apache/catalina/valves/AccessLogValve.java"

                    currentDate = new Date(System.currentTimeMillis());
                    dateStamp = fileDateFormatter.format(currentDate);

======= fetch "protected void prepareRequest() {" 36feee0^:"java/org/apache/coyote/http11/Http11Processor.java"

    public void parseHost(MessageBytes valueMB) {

     * When was the service started
     */
    protected long serviceStartTime = System.currentTimeMillis();
    
    /**
======= fetch "public synchronized void start(int level) throws IOException {" 9fa7640^:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

            serviceStartTime = System.currentTimeMillis();
======= fetch "public synchronized boolean stop(int level) throws IOException {" 9fa7640^:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

            serviceStartTime = Long.MAX_VALUE;
======= fetch "public long getServiceStartTime() {" 9fa7640^:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

       return this.serviceStartTime;

======= fetch "private StringManager(String packageName) {" 96167ed^:"java/org/apache/tomcat/util/res/StringManager.java"

        this( packageName, Locale.getDefault() );
    }
    private StringManager(String packageName, Locale loc) {
======= fetch "private StringManager(String packageName, Locale loc) {" 96167ed^:"java/org/apache/tomcat/util/res/StringManager.java"

        bundle = ResourceBundle.getBundle(bundleName, loc);
======= fetch "private StringManager(String packageName, Locale loc) {" 96167ed^:"java/org/apache/tomcat/util/res/StringManager.java"

    private StringManager(ResourceBundle bundle ) {
        this.bundle=bundle;
        locale = bundle.getLocale();
    }
======= fetch "public synchronized static StringManager getManager(String packageName) {" 96167ed^:"java/org/apache/tomcat/util/res/StringManager.java"

    /**
     * Get the StringManager for a particular package. If a manager for
     * a package already exists, it will be reused, else a new
     * StringManager will be created and returned.
     *
     * @param bundle The resource bundle
     */
    public synchronized static StringManager getManager(ResourceBundle bundle) {
        return new StringManager( bundle );
    }
    /**
     * Get the StringManager for a particular package and Locale. If a manager for
     * a package already exists, it will be reused, else a new
     * StringManager will be created for that Locale and returned.
     *
     * @param packageName The package name
     * @param loc The locale
     */
    public synchronized static StringManager getManager(String packageName,Locale loc) {
        StringManager mgr = managers.get(packageName+"_"+loc.toString());
        if (mgr == null) {
            mgr = new StringManager(packageName,loc);
            managers.put(packageName+"_"+loc.toString(), mgr);
        }
        return mgr;
    }

======= fetch "protected void status(Request request, Response response) {" 1ad0501^:"java/org/apache/catalina/core/StandardHostValve.java"

            String message = RequestUtil.filter(response.getMessage());

======= fetch "private void unregisterHost(ObjectName objectName)" 54b9da9^:"java/org/apache/catalina/connector/MapperListener.java"

            host.removeContainerListener(this);
======= fetch "static ObjectName createObjectName(String domain," 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        if (connector.getClass().getName().indexOf("CoyoteConnector") >= 0 ) {
            try {
                String address = (String)
                    IntrospectionUtils.getProperty(connector, "address");
                Integer port = (Integer)
                    IntrospectionUtils.getProperty(connector, "port");
                StringBuffer sb = new StringBuffer(domain);
                sb.append(":type=Connector");
                sb.append(",port=" + port);
                if ((address != null) && (address.length()>0)) {
                    sb.append(",address=" + address);
                }
                name = new ObjectName(sb.toString());
                return (name);
            } catch (Exception e) {
                throw new MalformedObjectNameException
                    ("Cannot create object name for " + connector+e);
======= fetch "static ObjectName createObjectName(String domain," 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        } else {
======= fetch "static ObjectName createObjectName(String domain," 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

                ("Cannot create object name for " + connector);
======= fetch "static ObjectName createObjectName(String domain," 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

======= fetch "static void destroyMBean(Connector connector, Service service)" 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        connector.setService(service);
        String mname = createManagedName(connector);
        ManagedBean managed = registry.findManagedBean(mname);
        if (managed == null) {
            return;
        }
        String domain = managed.getDomain();
======= fetch "static void destroyMBean(Connector connector, Service service)" 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        // Unregister associated request processor
        String worker = null;
        ProtocolHandler handler = connector.getProtocolHandler();
        if (handler instanceof Http11Protocol) {
            worker = ((Http11Protocol)handler).getName();
        } else if (handler instanceof Http11NioProtocol) {
            worker = ((Http11NioProtocol)handler).getName();
        } else if (handler instanceof Http11AprProtocol) {
            worker = ((Http11AprProtocol)handler).getName();
        } else if (handler instanceof AjpProtocol) {
            worker = ((AjpProtocol)handler).getName();
        } else if (handler instanceof AjpAprProtocol) {
            worker = ((AjpAprProtocol)handler).getName();
        }
        ObjectName query = new ObjectName(
                domain + ":type=RequestProcessor,worker=" + worker + ",*");
        Set<ObjectName> results = mserver.queryNames(query, null);
        for(ObjectName result : results) {
            mserver.unregisterMBean(result);
        }
======= fetch "static void destroyMBean(Context context)" 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        String mname = createManagedName(context);
        ManagedBean managed = registry.findManagedBean(mname);
        if (managed == null) {
            return;
        }
        String domain = managed.getDomain();
======= fetch "static void destroyMBean(ContextResource resource)" 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        // If this is a user database resource need to destroy groups, roles,
        // users and UserDatabase mbean
        if ("org.apache.catalina.UserDatabase".equals(resource.getType())) {
            destroyMBeanUserDatabase(resource.getName());
        }
======= fetch "static void destroyMBean(Engine engine)" 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        String mname = createManagedName(engine);
        ManagedBean managed = registry.findManagedBean(mname);
        if (managed == null) {
            return;
        }
        String domain = managed.getDomain();
======= fetch "static void destroyMBean(Host host)" 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        String mname = createManagedName(host);
        ManagedBean managed = registry.findManagedBean(mname);
        if (managed == null) {
            return;
        }
        String domain = managed.getDomain();
======= fetch "static void destroyMBean(NamingResources resources)" 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

       if( mserver.isRegistered(oname) )
======= fetch "static void destroyMBean(Server server)" 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        
        // Global String cache - fixed name
        oname = new ObjectName("Catalina:type=StringCache");
        if( mserver.isRegistered(oname) )
            mserver.unregisterMBean(oname);
        // MBean Factory - fixed name
        oname = new ObjectName("Catalina:type=MBeanFactory");
        if( mserver.isRegistered(oname) )
            mserver.unregisterMBean(oname);
======= fetch "static void destroyMBean(UserDatabase userDatabase)" 54b9da9^:"java/org/apache/catalina/mbeans/MBeanUtils.java"

     * Deregister the MBean for the
     * <code>UserDatabase</code> object with this name.
     *
     * @param userDatabase The UserDatabase to be managed
     *
     * @exception Exception if an MBean cannot be deregistered
     */
    static void destroyMBeanUserDatabase(String userDatabase)
        throws Exception {
        ObjectName query = null;
        Set<ObjectName> results = null;
        
        // Groups
        query = new ObjectName(
                "Users:type=Group,database=" + userDatabase + ",*");
        results = mserver.queryNames(query, null);
        for(ObjectName result : results) {
            mserver.unregisterMBean(result);
        }
        
        // Roles
        query = new ObjectName(
                "Users:type=Role,database=" + userDatabase + ",*");
        results = mserver.queryNames(query, null);
        for(ObjectName result : results) {
            mserver.unregisterMBean(result);
        }
        
        // Users
        query = new ObjectName(
                "Users:type=User,database=" + userDatabase + ",*");
        results = mserver.queryNames(query, null);
        for(ObjectName result : results) {
            mserver.unregisterMBean(result);
        }
        // The database itself
        ObjectName db = new ObjectName(
                "Users:type=UserDatabase,database=" + userDatabase);
        mserver.unregisterMBean(db);
    }
    /**
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 54b9da9^:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        } else if (Lifecycle.STOP_EVENT.equals(event.getType())) {
======= fetch "protected void createMBeans(Service service) throws Exception {" 54b9da9^:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        // Create the MBean for the Service itself
        if (log.isDebugEnabled())
            log.debug("Creating MBean for Service " + service);
        //MBeanUtils.createMBean(service);
======= fetch "protected void destroyMBeans(Connector connector, Service service)" 54b9da9^:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        // deregister the MBean for the Connector itself
        if (log.isDebugEnabled())
            log.debug("Destroying MBean for Connector " + connector);
        MBeanUtils.destroyMBean(connector, service);
======= fetch "protected void destroyMBeans(Context context) throws Exception {" 54b9da9^:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        //MBeanUtils.destroyMBean(context);
======= fetch "protected void destroyMBeans(Engine engine) throws Exception {" 54b9da9^:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        //MBeanUtils.destroyMBean(engine);
======= fetch "protected void destroyMBeans(Host host) throws Exception {" 54b9da9^:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        //MBeanUtils.destroyMBean(host);
======= fetch "protected void destroyMBeans(Server server) throws Exception {" 54b9da9^:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        //MBeanUtils.destroyMBean(server);
======= fetch "protected void destroyMBeans(Service service) throws Exception {" 54b9da9^:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

            //destroyMBeans(engine);
======= fetch "protected void destroyMBeans(Service service) throws Exception {" 54b9da9^:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        // Deregister the MBean for the Service itself
        if (log.isDebugEnabled()) {
            log.debug("Destroying MBean for Service " + service);
======= fetch "protected void destroyMBeans(Service service) throws Exception {" 54b9da9^:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        //MBeanUtils.destroyMBean(service);

 * <li>If the directory server contains nested roles, you can search for roles
 * recursively by setting <code>roleRecursionLimit</code> to some positive value.
 * The default value is <code>0</code>, so role searches do not recurse.</li>
    /**
     * The maximum recursion depth when resolving roles recursively.
     * By default we don't resolve roles recursively.
     */
    protected int roleRecursionLimit = 0;
======= fetch "public void setUserRoleName(String userRoleName) {" d04dd88^:"java/org/apache/catalina/realm/JNDIRealm.java"

     * Return the maximum recursion depth for role searches.
     */
    public int getRoleRecursionLimit() {
        return (this.roleRecursionLimit);
    }
    /**
     * Set the maximum recursion depth for role searches.
     *
     * @param roleRecursionLimit The new recursion limit
     */
    public void setRoleRecursionLimit(int roleRecursionLimit) {
        this.roleRecursionLimit = roleRecursionLimit;
    }
    /**
======= fetch "public void setRoleSubtree(boolean roleSubtree) {" d04dd88^:"java/org/apache/catalina/realm/JNDIRealm.java"

    
    /**
     * Return the "The nested group search flag" flag.
     */
    public boolean getRoleNested() {
        return (this.roleNested);
    }
    /**
     * Set the "search subtree for roles" flag.
     *
     * @param roleNested The nested group search flag
     */
    public void setRoleNested(boolean roleNested) {
        this.roleNested = roleNested;
    }
     
======= fetch "protected boolean bindAsUser(DirContext context," d04dd88^:"java/org/apache/catalina/realm/JNDIRealm.java"

    /**
     * Add roles to a user and search for other roles containing them themselves.
     * We search recursively with a limited depth.
     * By default the depth is 0, and we only use direct roles.
     * The search needs to use the distinguished role names,
     * but to return the role names.
     *
     * @param depth Recursion depth, starting at zero
     * @param context The directory context we are searching
     * @param recursiveMap The cumulative result map of role names and DNs.
     * @param recursiveSet The cumulative result set of role names.
     * @param groupName The role name to add to the list.
     * @param groupDName The distinguished name of the role.
     *
     * @exception NamingException if a directory server error occurs
     */
    private void getRolesRecursive(int depth, DirContext context, Map<String, String> recursiveMap, Set<String> recursiveSet,
                                     String groupName, String groupDName) throws NamingException {
        if (containerLog.isTraceEnabled())
            containerLog.trace("Recursive search depth " + depth + " for group '" + groupDName + " (" + groupName + ")'");
        // Adding the given group to the result set if not already found
        if (!recursiveSet.contains(groupDName)) {
            recursiveSet.add(groupDName);
            recursiveMap.put(groupDName, groupName);
            if (depth >= roleRecursionLimit) {
                if (roleRecursionLimit > 0)
                    containerLog.warn("Terminating recursive role search because of recursion limit " +
                                      roleRecursionLimit + ", results might be incomplete");
                return;
            }
            // Prepare the parameters for searching groups
            String filter = roleFormat.format(new String[] { groupDName });
            SearchControls controls = new SearchControls();
            controls.setSearchScope(roleSubtree ? SearchControls.SUBTREE_SCOPE : SearchControls.ONELEVEL_SCOPE);
            controls.setReturningAttributes(new String[] { roleName });
            if (containerLog.isTraceEnabled()) {
                containerLog.trace("Recursive search in role base '" + roleBase + "' for attribute '" + roleName + "'" +
                                   " with filter expression '" + filter + "'");
            }
            // Searching groups that assign the given group
            NamingEnumeration<SearchResult> results =
                context.search(roleBase, filter, controls);
            if (results != null) {
                // Iterate over the resulting groups
                try {
                    while (results.hasMore()) {
                        SearchResult result = results.next();
                        Attributes attrs = result.getAttributes();
                        if (attrs == null)
                            continue;
                        String dname = getDistinguishedName(context, roleBase, result);
                        String name = getAttributeValue(roleName, attrs);
                        if (name != null && dname != null) {
                           getRolesRecursive(depth+1, context, recursiveMap, recursiveSet, name, dname);
                        }
                    }
                } catch (PartialResultException ex) {
                    if (!adCompat)
                        throw ex;
                }
            }
        }
    }
======= fetch "private void getRolesRecursive(int depth, DirContext context, Map<String, String" d04dd88^:"java/org/apache/catalina/realm/JNDIRealm.java"

        
======= fetch "private void getRolesRecursive(int depth, DirContext context, Map<String, String" d04dd88^:"java/org/apache/catalina/realm/JNDIRealm.java"

            for (Iterator<String> i = keys.iterator(); i.hasNext();) {
                Object k = i.next();
                containerLog.trace(  "  Found direct role " + k + " -> " + groupMap.get(k));
======= fetch "private void getRolesRecursive(int depth, DirContext context, Map<String, String" d04dd88^:"java/org/apache/catalina/realm/JNDIRealm.java"

        HashSet<String> recursiveSet = new HashSet<String>();
        HashMap<String, String> recursiveMap = new HashMap<String, String>();
======= fetch "private void getRolesRecursive(int depth, DirContext context, Map<String, String" d04dd88^:"java/org/apache/catalina/realm/JNDIRealm.java"

        for (Iterator<String> i = keys.iterator(); i.hasNext();) {
            String k = i.next();
            getRolesRecursive(0, context, recursiveMap, recursiveSet, groupMap.get(k), k);
        }
======= fetch "private void getRolesRecursive(int depth, DirContext context, Map<String, String" d04dd88^:"java/org/apache/catalina/realm/JNDIRealm.java"

        HashSet<String> resultSet = new HashSet<String>(list);
        resultSet.addAll(recursiveMap.values());
======= fetch "private void getRolesRecursive(int depth, DirContext context, Map<String, String" d04dd88^:"java/org/apache/catalina/realm/JNDIRealm.java"

        if (containerLog.isTraceEnabled()) {
            containerLog.trace("  Returning " + resultSet.size() + " roles");
            for (Iterator<String> i = resultSet.iterator(); i.hasNext();)
                containerLog.trace(  "  Found role " + i.next());
======= fetch "private void getRolesRecursive(int depth, DirContext context, Map<String, String" d04dd88^:"java/org/apache/catalina/realm/JNDIRealm.java"

        return new ArrayList<String>(resultSet);
        session attribute serializatyion. (mturk)

======= fetch "private int doGetAttributeScope(String name) {" 04cacaf^:"java/org/apache/jasper/runtime/PageContextImpl.java"

======= fetch "private Object doFindAttribute(String name) {" 04cacaf^:"java/org/apache/jasper/runtime/PageContextImpl.java"

======= fetch "private void doRemoveAttribute(String name) {" 04cacaf^:"java/org/apache/jasper/runtime/PageContextImpl.java"


    public static final String PRECOMPILE = 
        System.getProperty("org.apache.jasper.Constants.PRECOMPILE",
                "jsp_precompile");
======= fetch "public synchronized Servlet loadServlet() throws ServletException {" c8cbc28^:"java/org/apache/catalina/core/StandardWrapper.java"

                    req.setQueryString("jsp_precompile=true");

======= fetch "protected String doRFC2254Encoding(String inString) {" 90e8d0d^:"java/org/apache/catalina/realm/JNDIRealm.java"

    protected String getDistinguishedName(DirContext context, String base, SearchResult result)
        throws NamingException {
        // Get the entry's distinguished name
        NameParser parser = context.getNameParser("");
        Name contextName = parser.parse(context.getNameInNamespace());
        Name baseName = parser.parse(base);
        // Bugzilla 32269
        Name entryName = parser.parse(new CompositeName(result.getName()).get(0));
        Name name = contextName.addAll(baseName);
        name = name.addAll(entryName);
        return name.toString();

    // See comment in setWriter()
    private int bufferSizeSave;
    
======= fetch "public void close() throws IOException {" 78a994a^:"java/org/apache/jasper/runtime/BodyContentImpl.java"

     * This method returns the size of the buffer used by the JspWriter.
     *
     * @return the size of the buffer in bytes, or 0 is unbuffered.
     */
    public int getBufferSize() {
        // According to the spec, the JspWriter returned by 
        // JspContext.pushBody(java.io.Writer writer) must behave as
        // though it were unbuffered. This means that its getBufferSize()
        // must always return 0.
        return (writer == null) ? bufferSize : 0;
    }
    
    /**
======= fetch "void setWriter(Writer writer) {" 78a994a^:"java/org/apache/jasper/runtime/BodyContentImpl.java"

        if (writer != null) {
            // According to the spec, the JspWriter returned by 
            // JspContext.pushBody(java.io.Writer writer) must behave as
            // though it were unbuffered. This means that its getBufferSize()
            // must always return 0. The implementation of
            // JspWriter.getBufferSize() returns the value of JspWriter's
            // 'bufferSize' field, which is inherited by this class. 
            // Therefore, we simply save the current 'bufferSize' (so we can 
            // later restore it should this BodyContentImpl ever be reused by
            // a call to PageContext.pushBody()) before setting it to 0.
            if (bufferSize != 0) {
                bufferSizeSave = bufferSize;
                bufferSize = 0;
            }
        } else {
            bufferSize = bufferSizeSave;

======= fetch "public SocketState process(long socket)" 42a093b^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

            // Setting up filters, and parse some request headers
            rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
            try {
                prepareRequest();
            } catch (Throwable t) {
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("http11processor.request.prepare"), t);
======= fetch "public SocketState process(long socket)" 42a093b^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                // 400 - Internal Server Error
                response.setStatus(400);
                error = true;
======= fetch "public SocketState process(NioChannel socket)" 42a093b^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            // Setting up filters, and parse some request headers
            rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
            try {
                prepareRequest();
            } catch (Throwable t) {
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("http11processor.request.prepare"), t);
======= fetch "public SocketState process(NioChannel socket)" 42a093b^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                // 400 - Internal Server Error
                response.setStatus(400);
                error = true;
======= fetch "public SocketState process(NioChannel socket)" 42a093b^:"java/org/apache/coyote/http11/Http11Processor.java"

            // Setting up filters, and parse some request headers
            rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
            try {
                prepareRequest();
            } catch (Throwable t) {
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("http11processor.request.prepare"), t);
======= fetch "public SocketState process(NioChannel socket)" 42a093b^:"java/org/apache/coyote/http11/Http11Processor.java"

                // 400 - Internal Server Error
                response.setStatus(400);
                error = true;
======= fetch "public boolean parseRequestLine(boolean useAvailableData)" 42a093b^:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

            // Spec says no CR or LF in method name
            if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {
                throw new IllegalArgumentException(
                        sm.getString("iib.invalidmethod"));
            }
======= fetch "public void parseRequestLine()" 42a093b^:"java/org/apache/coyote/http11/InternalInputBuffer.java"

            // Spec says no CR or LF in method name
            if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {
                throw new IllegalArgumentException(
                        sm.getString("iib.invalidmethod"));
            }
======= fetch "public boolean parseRequestLine(boolean useAvailableData)" 42a093b^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

                // Spec says no CR or LF in method name
                if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {
                    throw new IllegalArgumentException(
                            sm.getString("iib.invalidmethod"));
                }

======= fetch "public InputStream getResourceAsStream(String name) {" f109fb9^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                clazz = loader.loadClass(name);
======= fetch "public InputStream getResourceAsStream(String name) {" f109fb9^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                clazz = loader.loadClass(name);

                            + ";"
                            + ((jreversion == null) ? "" : "version="
                            + ";"
                            + ((jreversion == null) ? "" : "version="

======= fetch "protected void processSSI(HttpServletRequest req, HttpServletResponse res," 6ecc35d^:"java/org/apache/catalina/ssi/SSIServlet.java"

        bufferedReader.close();

    final ThreadGroup group;
    final AtomicInteger threadNumber = new AtomicInteger(1);
    final String namePrefix;
    final boolean daemon;
    final int threadPriority;

    ThreadPoolExecutor parent = null;
======= fetch "public boolean offer(Runnable o) {" 4e1c4b2^:"java/org/apache/tomcat/util/threads/TaskQueue.java"

        //we can't do any checks
        if (parent==null) return super.offer(o);
        //we are maxed out on threads, simply queue the object
        if (parent.getPoolSize() == parent.getMaximumPoolSize()) return super.offer(o);
        //we have idle threads, just add it to the queue
        if (parent.getActiveCount()<(parent.getPoolSize())) return super.offer(o);
        //if we have less threads than maximum force creation of a new thread
        if (parent.getPoolSize()<parent.getMaximumPoolSize()) return false;
        //if we reached here, we need to add it to the queue
        return super.offer(o);

======= fetch "public int invoke( Msg msg, MsgContext ep )" a228c06^:"java/org/apache/jk/server/JkCoyoteHandler.java"

        req.recycle();
======= fetch "public int invoke( Msg msg, MsgContext ep )" a228c06^:"java/org/apache/jk/server/JkCoyoteHandler.java"

        req.recycle();

======= fetch "public StandardContext() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

    
    private final Object applicationListenersLock = new Object();
======= fetch "public StandardContext() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

    private final Object applicationParametersLock = new Object();
    
======= fetch "public StandardContext() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

    
    private final Object constraintsLock = new Object();
======= fetch "public StandardContext() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

    
    private final Object filterMapsLock = new Object();
======= fetch "public StandardContext() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

    private final Object instanceListenersLock = new Object();
======= fetch "public StandardContext() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

    private final Object securityRolesLock = new Object();
======= fetch "public StandardContext() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

    
    private final Object servletMappingsLock = new Object();
======= fetch "public StandardContext() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

    private final Object watchedResourcesLock = new Object();
======= fetch "public StandardContext() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

    private final Object welcomeFilesLock = new Object();
======= fetch "public StandardContext() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

    private final Object wrapperLifecyclesLock = new Object();
======= fetch "public StandardContext() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

    private final Object wrapperListenersLock = new Object();
======= fetch "public void addApplicationListener(String listener) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (applicationListeners) {
======= fetch "public void addApplicationParameter(ApplicationParameter parameter) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (applicationParameters) {
======= fetch "public void addConstraint(SecurityConstraint constraint) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (constraints) {
======= fetch "public void addFilterMap(FilterMap filterMap) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (filterMaps) {
======= fetch "public void addFilterMapBefore(FilterMap filterMap) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (filterMaps) {
======= fetch "public void addInstanceListener(String listener) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (instanceListeners) {
======= fetch "public void addSecurityRole(String role) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (securityRoles) {
======= fetch "public void addServletMapping(String pattern, String name," f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (servletMappings) {
======= fetch "public void addWatchedResource(String name) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (watchedResources) {
======= fetch "public void addWelcomeFile(String name) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (welcomeFiles) {
======= fetch "public void addWrapperLifecycle(String listener) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperLifecycles) {
======= fetch "public void addWrapperListener(String listener) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperListeners) {
======= fetch "public Wrapper createWrapper() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (instanceListeners) {
======= fetch "public Wrapper createWrapper() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperLifecycles) {
======= fetch "public Wrapper createWrapper() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperListeners) {
======= fetch "public Wrapper createWrapper() {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        return (applicationParameters);
======= fetch "public FilterDef findFilterDef(String filterName) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        return (instanceListeners);
======= fetch "public boolean findSecurityRole(String role) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (securityRoles) {
======= fetch "public boolean findSecurityRole(String role) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        return (securityRoles);
======= fetch "public String findServletMapping(String pattern) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (servletMappings) {
======= fetch "public String findServletMapping(String pattern) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (servletMappings) {
======= fetch "public boolean findWelcomeFile(String name) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (welcomeFiles) {
======= fetch "public boolean findWelcomeFile(String name) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        return watchedResources;
======= fetch "public boolean findWelcomeFile(String name) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        return (welcomeFiles);
======= fetch "public boolean findWelcomeFile(String name) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        return (wrapperLifecycles);
======= fetch "public boolean findWelcomeFile(String name) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        return (wrapperListeners);
======= fetch "public void removeApplicationListener(String listener) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (applicationListeners) {
======= fetch "public void removeApplicationParameter(String name) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (applicationParameters) {
======= fetch "public void removeConstraint(SecurityConstraint constraint) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (constraints) {
======= fetch "public void removeFilterMap(FilterMap filterMap) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (filterMaps) {
======= fetch "public void removeInstanceListener(String listener) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (instanceListeners) {
======= fetch "public void removeSecurityRole(String role) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (securityRoles) {
======= fetch "public void removeServletMapping(String pattern) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (servletMappings) {
======= fetch "public void removeWatchedResource(String name) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (watchedResources) {
======= fetch "public void removeWelcomeFile(String name) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (welcomeFiles) {
======= fetch "public void removeWrapperLifecycle(String listener) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperLifecycles) {
======= fetch "public void removeWrapperListener(String listener) {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperListeners) {
======= fetch "public void destroy() throws Exception {" f1fd999^:"java/org/apache/catalina/core/StandardContext.java"

        instanceListeners = new String[0];
======= fetch "public StandardHost() {" f1fd999^:"java/org/apache/catalina/core/StandardHost.java"

    
    private final Object aliasesLock = new Object();
======= fetch "public void addAlias(String alias) {" f1fd999^:"java/org/apache/catalina/core/StandardHost.java"

        // Skip duplicate aliases
        for (int i = 0; i < aliases.length; i++) {
            if (aliases[i].equals(alias))
                return;
======= fetch "public void addAlias(String alias) {" f1fd999^:"java/org/apache/catalina/core/StandardHost.java"

        // Add this alias to the list
        String newAliases[] = new String[aliases.length + 1];
        for (int i = 0; i < aliases.length; i++)
            newAliases[i] = aliases[i];
        newAliases[aliases.length] = alias;
        aliases = newAliases;
======= fetch "public void addChild(Container child) {" f1fd999^:"java/org/apache/catalina/core/StandardHost.java"

        return (this.aliases);
======= fetch "public void removeAlias(String alias) {" f1fd999^:"java/org/apache/catalina/core/StandardHost.java"

        synchronized (aliases) {
======= fetch "public synchronized void start() throws LifecycleException {" f1fd999^:"java/org/apache/catalina/core/StandardHost.java"

        return aliases;
======= fetch "public Object clone() {" f1fd999^:"java/org/apache/catalina/tribes/membership/Membership.java"

        synchronized (members) {
======= fetch "public synchronized MbrEntry addMember(MemberImpl member) {" f1fd999^:"java/org/apache/catalina/tribes/membership/Membership.java"

      synchronized (members) {
======= fetch "public void removeMember(MemberImpl member) {" f1fd999^:"java/org/apache/catalina/tribes/membership/Membership.java"

        synchronized (members) {
======= fetch "public InstanceSupport(Wrapper wrapper) {" f1fd999^:"java/org/apache/catalina/util/InstanceSupport.java"

    
    private final Object listenersLock = new Object(); // Lock object for changes to listeners
======= fetch "public void addInstanceListener(InstanceListener listener) {" f1fd999^:"java/org/apache/catalina/util/InstanceSupport.java"

      synchronized (listeners) {
======= fetch "public void removeInstanceListener(InstanceListener listener) {" f1fd999^:"java/org/apache/catalina/util/InstanceSupport.java"

        synchronized (listeners) {
======= fetch "public LifecycleSupport(Lifecycle lifecycle) {" f1fd999^:"java/org/apache/catalina/util/LifecycleSupport.java"

    
    private final Object listenersLock = new Object(); // Lock object for changes to listeners
======= fetch "public void addLifecycleListener(LifecycleListener listener) {" f1fd999^:"java/org/apache/catalina/util/LifecycleSupport.java"

      synchronized (listeners) {
======= fetch "public void removeLifecycleListener(LifecycleListener listener) {" f1fd999^:"java/org/apache/catalina/util/LifecycleSupport.java"

        synchronized (listeners) {

    // ----------------------------------------------------- Instance Variables
    public static String JMX_SERVICE_PREFIX = "service:jmx:rmi:///jndi/rmi://";
    public static String JMX_SERVICE_SUFFIX = "/jmxrmi";

    public static final String[] STANDARD_IMPORTS = { 
    public static final String[] CACHED_DTD_PUBLIC_IDS = {
    public static final String[] CACHED_DTD_RESOURCE_PATHS = {
        for(int i = 0; i < Constants.STANDARD_IMPORTS.length; i++)
            imports.add(Constants.STANDARD_IMPORTS[i]);
======= fetch "public InputSource resolveEntity(String publicId, String systemId)" f497f12^:"java/org/apache/jasper/xmlparser/ParserUtils.java"

        for (int i = 0; i < Constants.CACHED_DTD_PUBLIC_IDS.length; i++) {
            String cachedDtdPublicId = Constants.CACHED_DTD_PUBLIC_IDS[i];
======= fetch "public InputSource resolveEntity(String publicId, String systemId)" f497f12^:"java/org/apache/jasper/xmlparser/ParserUtils.java"

                String resourcePath = Constants.CACHED_DTD_RESOURCE_PATHS[i];

        public DataInputStream run(){               
======= fetch "public DataInputStream run(){" 243aa86^:"java/org/apache/catalina/session/ManagerBase.java"

                log.warn("Error reading " + devRandomSource, ex);
                if (randomIS != null) {
                    try {
                        randomIS.close();
                    } catch (Exception e) {
                        log.warn("Failed to close randomIS.");
                    }
                }
                devRandomSource = null;
                randomIS=null;
======= fetch "public DataInputStream run(){" 243aa86^:"java/org/apache/catalina/session/ManagerBase.java"

            }
======= fetch "public void setRandomFile( String s ) {" 243aa86^:"java/org/apache/catalina/session/ManagerBase.java"

        // as a hack, you can use a static file - and genarate the same
======= fetch "public void setRandomFile( String s ) {" 243aa86^:"java/org/apache/catalina/session/ManagerBase.java"

            randomIS = AccessController.doPrivileged(new PrivilegedSetRandomFile());
======= fetch "public void setRandomFile( String s ) {" 243aa86^:"java/org/apache/catalina/session/ManagerBase.java"

                try {
                    randomIS.close();
                } catch (Exception e) {
                    log.warn("Failed to close randomIS.");
======= fetch "public void setRandomFile( String s ) {" 243aa86^:"java/org/apache/catalina/session/ManagerBase.java"

                

        "<?xml-stylesheet type=\"text/xsl\" href=\"/manager/xform.xsl\" ?>";

======= fetch "public String getString(String key) {" 23c47da^:"java/org/apache/tomcat/util/res/StringManager.java"

    public String getString(String key, Object[] args) {
        String iString = null;
======= fetch "public String getString(String key, Object[] args) {" 23c47da^:"java/org/apache/tomcat/util/res/StringManager.java"

        // this check for the runtime exception is some pre 1.1.6
        // VM's don't do an automatic toString() on the passed in
        // objects and barf out
        try {
            // ensure the arguments are not null so pre 1.2 VM's don't barf
            if(args==null){
                args = new Object[1];
            }
            
            Object[] nonNullArgs = args;
            for (int i=0; i<args.length; i++) {
                if (args[i] == null) {
                    if (nonNullArgs==args){
                        nonNullArgs=args.clone();
                    }
                    nonNullArgs[i] = "null";
                }
            }
            if( value==null ) value=key;
            mf.setLocale(locale);
            iString = mf.format(nonNullArgs, new StringBuffer(), null).toString();
        } catch (IllegalArgumentException iae) {
            StringBuffer buf = new StringBuffer();
            buf.append(value);
            for (int i = 0; i < args.length; i++) {
                buf.append(" arg[" + i + "]=" + args[i]);
            }
            iString = buf.toString();
======= fetch "public String getString(String key, Object[] args) {" 23c47da^:"java/org/apache/tomcat/util/res/StringManager.java"

        return iString;
    }
    /**
     * Get a string from the underlying resource bundle and format it
     * with the given object argument. This argument can of course be
     * a String object.
     *
     * @param key
     * @param arg
     */
======= fetch "public String getString(String key, Object[] args) {" 23c47da^:"java/org/apache/tomcat/util/res/StringManager.java"

    public String getString(String key, Object arg) {
======= fetch "public String getString(String key, Object arg) {" 23c47da^:"java/org/apache/tomcat/util/res/StringManager.java"

    /**
     * Get a string from the underlying resource bundle and format it
     * with the given object arguments. These arguments can of course
     * be String objects.
     *
     * @param key
     * @param arg1
     * @param arg2
     */
    public String getString(String key, Object arg1, Object arg2) {
    }
    
    /**
     * Get a string from the underlying resource bundle and format it
     * with the given object arguments. These arguments can of course
     * be String objects.
     *
     * @param key
     * @param arg1
     * @param arg2
     * @param arg3
     */
    public String getString(String key, Object arg1, Object arg2,
    }
    /**
     * Get a string from the underlying resource bundle and format it
     * with the given object arguments. These arguments can of course
     * be String objects.
     *
     * @param key
     * @param arg1
     * @param arg2
     * @param arg3
     * @param arg4
     */
    public String getString(String key, Object arg1, Object arg2,
    }

======= fetch "public void start() throws LifecycleException {" 360f8eb^:"java/org/apache/catalina/valves/AccessLogValve.java"

        Calendar calendar = Calendar.getInstance(timezone);
        int offset = calendar.get(Calendar.DST_OFFSET);

======= fetch "public void compile(boolean compileClass, boolean jspcMode)" f36a2c4^:"java/org/apache/jasper/compiler/Compiler.java"

                // Fix for bugzilla 41606
                // Set JspServletWrapper.servletClassLastModifiedTime after successful compile
                String targetFileName = ctxt.getClassFileName();
                if (targetFileName != null) {
                    File targetFile = new File(targetFileName);
                    if (targetFile.exists() && jsw != null) {
                        jsw.setServletClassLastModifiedTime(targetFile.lastModified());
                    }
                }

======= fetch "public void setDelegate(boolean delegate) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

        support.firePropertyChange("delegate", new Boolean(oldDelegate),
                                   new Boolean(this.delegate));
======= fetch "public void setAntiJARLocking(boolean antiJARLocking) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Boolean(oldAntiJARLocking),
                                   new Boolean(this.antiJARLocking));
======= fetch "public void setAntiResourceLocking(boolean antiResourceLocking) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Boolean(oldAntiResourceLocking),
                                   new Boolean(this.antiResourceLocking));
======= fetch "public void setAvailable(boolean available) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Boolean(oldAvailable),
                                   new Boolean(this.available));
======= fetch "public void setConfigured(boolean configured) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Boolean(oldConfigured),
                                   new Boolean(this.configured));
======= fetch "public void setCookies(boolean cookies) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Boolean(oldCookies),
                                   new Boolean(this.cookies));
======= fetch "public void setUseHttpOnly(boolean useHttpOnly) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                new Boolean(oldUseHttpOnly),
                new Boolean(this.useHttpOnly));
======= fetch "public void setCrossContext(boolean crossContext) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Boolean(oldCrossContext),
                                   new Boolean(this.crossContext));
======= fetch "public void setDistributable(boolean distributable) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Boolean(oldDistributable),
                                   new Boolean(this.distributable));
======= fetch "public void setIgnoreAnnotations(boolean ignoreAnnotations) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

        support.firePropertyChange("ignoreAnnotations", Boolean.valueOf(oldIgnoreAnnotations),
                Boolean.valueOf(this.ignoreAnnotations));
======= fetch "public void setPrivileged(boolean privileged) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Boolean(oldPrivileged),
                                   new Boolean(this.privileged));
======= fetch "public void setReloadable(boolean reloadable) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Boolean(oldReloadable),
                                   new Boolean(this.reloadable));
======= fetch "public void setOverride(boolean override) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Boolean(oldOverride),
                                   new Boolean(this.override));
======= fetch "public void setReplaceWelcomeFiles(boolean replaceWelcomeFiles) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Boolean(oldReplaceWelcomeFiles),
                                   new Boolean(this.replaceWelcomeFiles));
======= fetch "public void setSessionTimeout(int timeout) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Integer(oldSessionTimeout),
                                   new Integer(this.sessionTimeout));
======= fetch "public void setSwallowOutput(boolean swallowOutput) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Boolean(oldSwallowOutput),
                                   new Boolean(this.swallowOutput));
======= fetch "public void setUnloadDelay(long unloadDelay) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                                   new Long(oldUnloadDelay),
                                   new Long(this.unloadDelay));
======= fetch "public void addErrorPage(ErrorPage errorPage) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                statusPages.put(new Integer(errorPage.getErrorCode()),
======= fetch "public ErrorPage findErrorPage(int errorCode) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

            return (statusPages.get(new Integer(errorCode)));
======= fetch "public String findStatusPage(int status) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

        ErrorPage errorPage = statusPages.get(new Integer(status));
======= fetch "public void removeErrorPage(ErrorPage errorPage) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

                statusPages.remove(new Integer(errorPage.getErrorCode()));
======= fetch "public void loadOnStartup(Container children[]) {" b10d9da^:"java/org/apache/catalina/core/StandardContext.java"

            Integer key = new Integer(loadOnStartup);

======= fetch "public void await() {" fae26ce^:"java/org/apache/catalina/core/StandardServer.java"

                    random = new Random(System.currentTimeMillis());
    protected static Random rand = new Random(System.currentTimeMillis());
======= fetch "public static void printArray(byte[] data) {" fae26ce^:"test/org/apache/catalina/tribes/demos/LoadTest.java"

        public static Random r = new Random(System.currentTimeMillis());
======= fetch "public void run() {" fae26ce^:"test/org/apache/catalina/tribes/demos/MapDemo.java"

        public static Random random = new Random(System.currentTimeMillis());
======= fetch "public void messageReceived(Serializable s, Member m) {" fae26ce^:"test/org/apache/catalina/tribes/test/channel/TestDataIntegrity.java"

        public static Random r = new Random(System.currentTimeMillis());
======= fetch "public void messageReceived(Serializable s, Member m) {" fae26ce^:"test/org/apache/catalina/tribes/test/channel/TestMulticastPackages.java"

        public static Random r = new Random(System.currentTimeMillis());
======= fetch "public void printStats(PrintStream stream) {" fae26ce^:"test/org/apache/catalina/tribes/test/channel/TestRemoteProcessException.java"

        public static Random r = new Random(System.currentTimeMillis());
======= fetch "public void messageReceived(Serializable s, Member m) {" fae26ce^:"test/org/apache/catalina/tribes/test/channel/TestUdpPackages.java"

        public static Random r = new Random(System.currentTimeMillis());
======= fetch "protected void tearDown() throws Exception {" fae26ce^:"test/org/apache/catalina/tribes/test/io/TestSenderConnections.java"

        static Random r = new Random(System.currentTimeMillis());

======= fetch "public void event(Request request, Response response, CometEvent event)" 08f7a5f^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                        Request[] reqs = (Request[])
                            session.getAttribute(cometRequestsAttribute);
======= fetch "public void event(Request request, Response response, CometEvent event)" 08f7a5f^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                                    session.setAttribute(cometRequestsAttribute,
                                            newConnectionInfos);
======= fetch "public void event(Request request, Response response, CometEvent event)" 08f7a5f^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                                    session.removeAttribute(
                                            cometRequestsAttribute);

======= fetch "public void process(Socket socket)" ac6369a^:"java/org/apache/coyote/http11/Http11Processor.java"

                if (!disableUploadTimeout && keptAlive) {

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

======= fetch "public AsyncContext startAsync(ServletRequest servletRequest," 9752018^:"java/org/apache/catalina/connector/RequestFacade.java"

    public boolean getAllowTrace() {
        return request.getConnector().getAllowTrace();
    }
    
======= fetch "protected void doHead(HttpServletRequest request," 9752018^:"java/org/apache/catalina/servlets/DefaultServlet.java"

     * Override default implementation to ensure that TRACE is correctly
     * handled.
     *
     * @param req   the {@link HttpServletRequest} object that
     *                  contains the request the client made of
     *                  the servlet
     *
     * @param resp  the {@link HttpServletResponse} object that
     *                  contains the response the servlet returns
     *                  to the client                                
     *
     * @exception IOException   if an input or output error occurs
     *                              while the servlet is handling the
     *                              OPTIONS request
     *
     * @exception ServletException  if the request for the
     *                                  OPTIONS cannot be handled
     */
    protected void doOptions(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        StringBuffer allow = new StringBuffer();
        // There is a doGet method
        allow.append("GET, HEAD");
        // There is a doPost
        allow.append(", POST");
        // There is a doPut
        allow.append(", PUT");
        // There is a doDelete
        allow.append(", POST");
        // Trace - assume disabled unless we can prove otherwise
        if (req instanceof RequestFacade &&
                ((RequestFacade) req).getAllowTrace()) {
            allow.append(", TRACE");
        }
        // Always allow options
        allow.append(", OPTIONS");
        
        resp.setHeader("Allow", allow.toString());
    }
    
    
    /**

======= fetch "protected void fixDocBase()" 8d2b8ff^:"java/org/apache/catalina/startup/ContextConfig.java"

        if (docBase.startsWith(canonicalAppBase.getPath())) {

======= fetch "public boolean authenticate(Request request," 156f1ca^:"java/org/apache/catalina/authenticator/SSLAuthenticator.java"

            response.sendError(HttpServletResponse.SC_BAD_REQUEST,

======= fetch "public void visit(Node.CustomTag n) throws JasperException {" 2824a70^:"java/org/apache/jasper/compiler/Generator.java"

                            .getLocalName(), n.getAttributes(), n
                            .hasEmptyBody());
======= fetch "private String createTagHandlerPoolName(String prefix," 2824a70^:"java/org/apache/jasper/compiler/Generator.java"

                    String shortName, Attributes attrs, boolean hasEmptyBody) {
======= fetch "private String createTagHandlerPoolName(String prefix," 2824a70^:"java/org/apache/jasper/compiler/Generator.java"

                    String[] attrNames = new String[attrs.getLength()];
======= fetch "private String createTagHandlerPoolName(String prefix," 2824a70^:"java/org/apache/jasper/compiler/Generator.java"

                    for (int i = 0; i < namedAttrs.size(); i++) {
                        attrNames[attrs.getLength() + i] =
                            ((NamedAttribute) namedAttrs.getNode(i)).getQName();
                    }

     * Default depth is infite.
     */
    private static final int INFINITY = 3; // To limit tree browsing a bit
    /**
======= fetch "public void init()" f0bd732^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if (getServletConfig().getInitParameter("maxDepth") != null)
            maxDepth = Integer.parseInt(
                    getServletConfig().getInitParameter("maxDepth"));
======= fetch "protected void doPropfind(HttpServletRequest req, HttpServletResponse resp)" f0bd732^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        int depth = INFINITY;
======= fetch "protected void doPropfind(HttpServletRequest req, HttpServletResponse resp)" f0bd732^:"java/org/apache/catalina/servlets/WebdavServlet.java"

            depth = INFINITY;
======= fetch "protected void doPropfind(HttpServletRequest req, HttpServletResponse resp)" f0bd732^:"java/org/apache/catalina/servlets/WebdavServlet.java"

                depth = INFINITY;
======= fetch "protected void doLock(HttpServletRequest req, HttpServletResponse resp)" f0bd732^:"java/org/apache/catalina/servlets/WebdavServlet.java"

            lock.depth = INFINITY;
======= fetch "protected void doLock(HttpServletRequest req, HttpServletResponse resp)" f0bd732^:"java/org/apache/catalina/servlets/WebdavServlet.java"

                lock.depth = INFINITY;
======= fetch "protected void doLock(HttpServletRequest req, HttpServletResponse resp)" f0bd732^:"java/org/apache/catalina/servlets/WebdavServlet.java"

                 (lock.depth == INFINITY) ) {
======= fetch "public void toXML(XMLWriter generatedXML) {" f0bd732^:"java/org/apache/catalina/servlets/WebdavServlet.java"

            if (depth == INFINITY) {

======= fetch "private String comparePageEncodings(String thePageDirEnc," 7d7f757^:"java/org/apache/jasper/compiler/Validator.java"

         * @param pageDirEnc The value of the pageEncoding attribute of the page
======= fetch "private String comparePageEncodings(String thePageDirEnc," 7d7f757^:"java/org/apache/jasper/compiler/Validator.java"

        private void compareTagEncodings(String pageDirEnc,
======= fetch "private void compareTagEncodings(String pageDirEnc," 7d7f757^:"java/org/apache/jasper/compiler/Validator.java"

            String pageDirEnc = thePageDirEnc.toUpperCase();
======= fetch "private void compareTagEncodings(String pageDirEnc," 7d7f757^:"java/org/apache/jasper/compiler/Validator.java"

                String pageEnc = root.getPageEncoding();

======= fetch "public TagFileInfo getTagFile(String shortName) {" 3aaac85^:"java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java"

                        pc.getJspCompilationContext().getTagFileJarUrl(path),
======= fetch "public static InputStream getInputStream(String fname, JarFile jarFile," 3aaac85^:"java/org/apache/jasper/compiler/JspUtil.java"

     * 
     * @deprecated Use {@link #getTagHandlerClassName(String, String,
     *             ErrorDispatcher)
     *             See https://issues.apache.org/bugzilla/show_bug.cgi?id=46471
======= fetch "public static String getTagHandlerClassName(String path, ErrorDispatcher err)" 3aaac85^:"java/org/apache/jasper/compiler/JspUtil.java"

        return getTagHandlerClassName(path, null, err);
    }
    
    /**
     * Gets the fully-qualified class name of the tag handler corresponding to
     * the given tag file path.
     * 
     * @param path
     *            Tag file path
     * @param err
     *            Error dispatcher
     * 
     * @return Fully-qualified class name of the tag handler corresponding to
     *         the given tag file path
     */
    public static String getTagHandlerClassName(String path, String urn,
            ErrorDispatcher err) throws JasperException {
======= fetch "public static String getTagHandlerClassName(String path, ErrorDispatcher err)" 3aaac85^:"java/org/apache/jasper/compiler/JspUtil.java"

                className = "org.apache.jsp.tag.meta.";
======= fetch "public static String getTagHandlerClassName(String path, ErrorDispatcher err)" 3aaac85^:"java/org/apache/jasper/compiler/JspUtil.java"

    private static String getClassNameBase(String urn) {
        StringBuffer base = new StringBuffer("org.apache.jsp.tag.meta.");
        if (urn != null) {
            base.append(makeJavaPackage(urn));
            base.append('.');
        }
        return base.toString();
    }
======= fetch "public Compiler getCompiler () {" 3aaac85^:"java/org/apache/jasper/compiler/ParserController.java"

     * @deprecated Use {@link #parseTagFileDirectives(String, URL)}
     *             See https://issues.apache.org/bugzilla/show_bug.cgi?id=46471
======= fetch "public Compiler getCompiler () {" 3aaac85^:"java/org/apache/jasper/compiler/ParserController.java"

        return parseTagFileDirectives(
                inFileName, ctxt.getTagFileJarUrl(inFileName));
    }
    /**
     * Extracts tag file directive information from the given tag file.
     *
     * This is invoked by the compiler 
     *
     * @param inFileName    The name of the tag file to be parsed.
     * @param tagFileJarUrl The location of the tag file.
     */
    public Node.Nodes parseTagFileDirectives(String inFileName,
            URL tagFileJarUrl)
            throws FileNotFoundException, JasperException, IOException {
======= fetch "public Compiler getCompiler () {" 3aaac85^:"java/org/apache/jasper/compiler/ParserController.java"

        Node.Nodes page = doParse(inFileName, null,
                ctxt.getTagFileJarUrl(inFileName));
======= fetch "public TagInfo getTagInfo() throws JasperException {" 3aaac85^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            String tagClassName = JspUtil.getTagHandlerClassName(path, err);
======= fetch "void postCheck() throws JasperException {" 3aaac85^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

     * @deprecated Use {@link TagFileProcessor#parseTagFileDirectives(
     *                  ParserController, String, String, URL, TagLibraryInfo)}
     *             See https://issues.apache.org/bugzilla/show_bug.cgi?id=46471
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," 3aaac85^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

        return parseTagFileDirectives(pc, name, path,
                pc.getJspCompilationContext().getTagFileJarUrl(path),
                tagLibInfo);
    }
    
    /**
     * Parses the tag file, and collects information on the directives included
     * in it. The method is used to obtain the info on the tag file, when the
     * handler that it represents is referenced. The tag file is not compiled
     * here.
     * 
     * @param pc
     *            the current ParserController used in this compilation
     * @param name
     *            the tag name as specified in the TLD
     * @param tagfile
     *            the path for the tagfile
     * @param tagFileJarUrl
     *            the url for the Jar containign the tag file 
     * @param tagLibInfo
     *            the TagLibraryInfo object associated with this TagInfo
     * @return a TagInfo object assembled from the directives in the tag file.
     */
    public static TagInfo parseTagFileDirectives(ParserController pc,
            String name, String path, URL tagFileJarUrl, TagLibraryInfo tagLibInfo)
            throws JasperException {
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," 3aaac85^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            page = pc.parseTagFileDirectives(path);
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," 3aaac85^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

        URL tagFileJarUrl = null;
        if (tagFilePath.startsWith("/META-INF/")) {
            try { 
                tagFileJarUrl = new URL("jar:" +
                        compiler.getCompilationContext().getTldLocation(
                        tagInfo.getTagLibrary().getURI())[0] + "!/");
            } catch (MalformedURLException e) {
                e.printStackTrace();
            }
        }
        String tagFileJarPath;
        if (tagFileJarUrl == null) {
            tagFileJarPath = "";
        } else {
            tagFileJarPath = tagFileJarUrl.toString();
        }
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," 3aaac85^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

        JspServletWrapper wrapper = rctxt.getWrapper(tagFilePath);
======= fetch "public static TagInfo parseTagFileDirectives(ParserController pc," 3aaac85^:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                        .getRuntimeContext(), ctxt.getTagFileJarUrl(tagFilePath));
                rctxt.addWrapper(tagFilePath, wrapper);
======= fetch "private TagFileInfo createTagFileInfo(TreeNode elem, String uri," 3aaac85^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

            // See https://issues.apache.org/bugzilla/show_bug.cgi?id=46471
            // This needs to be removed once all the broken code that depends on
            // it has been removed
======= fetch "private TagFileInfo createTagFileInfo(TreeNode elem, String uri," 3aaac85^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                parserController, name, path, this);
======= fetch "private TagFileInfo createTagFileInfo(TreeNode elem, String uri," 3aaac85^:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                ; // Do nothing

======= fetch "public JasperLoader(URL[] urls, ClassLoader parent," 1ca03ff^:"java/org/apache/jasper/servlet/JasperLoader.java"

        if( !name.startsWith(Constants.JSP_PACKAGE_NAME) ) {

======= fetch "protected Connection open() throws SQLException {" e31998a^:"java/org/apache/catalina/realm/JDBCRealm.java"

        if (dbConnection == null) {
            throw new SQLException(sm.getString(
                    "jdbcRealm.open.invalidurl",driverName, connectionURL));
        }

======= fetch "public void setPath(String path) {" 85fc30c^:"java/org/apache/catalina/core/StandardContext.java"

        setName(RequestUtil.URLDecode(path));
======= fetch "public void list(HttpServletRequest request," 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

 
======= fetch "public void list(HttpServletRequest request," 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args = new Object[6];
                args[0] = displayPath;
                args[1] = context.getDisplayName();
                if (args[1] == null) {
                    args[1] = "&nbsp;";
======= fetch "public void list(HttpServletRequest request," 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args[2] = new Boolean(context.getAvailable());
                args[3] = response.encodeURL
======= fetch "public void list(HttpServletRequest request," 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                     "/html/sessions?path=" + displayPath);
======= fetch "public void list(HttpServletRequest request," 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                    args[4] = new Integer
======= fetch "public void list(HttpServletRequest request," 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                    args[4] = new Integer(0);
======= fetch "public void list(HttpServletRequest request," 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args[5] = highlightColor;
======= fetch "public void list(HttpServletRequest request," 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                     "/html/start?path=" + displayPath);
======= fetch "public void list(HttpServletRequest request," 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                     "/html/stop?path=" + displayPath);
======= fetch "public void list(HttpServletRequest request," 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                     "/html/reload?path=" + displayPath);
======= fetch "public void list(HttpServletRequest request," 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                     "/html/undeploy?path=" + displayPath);
======= fetch "public void list(HttpServletRequest request," 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                     "/html/expire?path=" + displayPath);
======= fetch "public Comparable getComparableObject(Session session) {" 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        " <td class=\"row-left\" bgcolor=\"{5}\" rowspan=\"2\"><small><a href=\"{0}\">{0}</a>" +
======= fetch "public Comparable getComparableObject(Session session) {" 85fc30c^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        " <td class=\"row-left\" bgcolor=\"{5}\" rowspan=\"2\"><small>{1}</small></td>\n" +
        " <td class=\"row-center\" bgcolor=\"{5}\" rowspan=\"2\"><small>{2}</small></td>\n" +
        " <td class=\"row-center\" bgcolor=\"{5}\" rowspan=\"2\">" +
        "<small><a href=\"{3}\" target=\"_new\">{4}</a></small></td>\n";

======= fetch "private String attributeValueWithEL(boolean isTag, String tx," 24bcb47^:"java/org/apache/jasper/compiler/Generator.java"

            Class<?> type = expectedType;
======= fetch "private String attributeValueWithEL(boolean isTag, String tx," 24bcb47^:"java/org/apache/jasper/compiler/Generator.java"

                            // Composite expression - must coerce to String
                            type = String.class;
======= fetch "private String attributeValueWithEL(boolean isTag, String tx," 24bcb47^:"java/org/apache/jasper/compiler/Generator.java"

                        // Composite expression - must coerce to String
                        type = String.class;
======= fetch "private String attributeValueWithEL(boolean isTag, String tx," 24bcb47^:"java/org/apache/jasper/compiler/Generator.java"

                                    tx.substring(mark, i+1), expectedType,

======= fetch "public void start() throws Exception {" 7e6a2ec^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

        if(econtainer == null && econtainer instanceof Engine) {

======= fetch "private void generateCustomEnd(Node.CustomTag n, String tagHandlerVar," 5277185^:"java/org/apache/jasper/compiler/Generator.java"

            if (isPoolingEnabled) {

    /**
     * If set to false, we don't use the IE6/7 Max-Age/Expires work around
     */
    public static final boolean ALWAYS_ADD_EXPIRES =
        Boolean.valueOf(System.getProperty("org.apache.tomcat.util.http.ServerCookie.ALWAYS_ADD_EXPIRES", "true")).booleanValue();
======= fetch "public static void appendCookieValue( StringBuffer headerBuf," 99c5ca6^:"java/org/apache/tomcat/util/http/ServerCookie.java"

            if (version == 0) {
======= fetch "public static void appendCookieValue( StringBuffer headerBuf," 99c5ca6^:"java/org/apache/tomcat/util/http/ServerCookie.java"

            } else {
                buf.append ("; Max-Age=");
                buf.append (maxAge);

======= fetch "public Object run() throws Exception{" a1e4c86^:"java/org/apache/catalina/security/SecurityUtil.java"

       } catch( PrivilegedActionException pe) {
            Throwable e = ((InvocationTargetException)pe.getException())
======= fetch "public Object run() throws Exception{" a1e4c86^:"java/org/apache/catalina/security/SecurityUtil.java"

            } else {
                e = pe;
            }

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * This interface represents the server side API for the Bayeux messaging protocol.
 * Bayeux is a simple subscribe/publish/receive methodology, not far from JMS, but much simplified.<br/>
 * It is used both by the actual implementation and by server side clients.<br/>
 * Server side clients use this to create, retrieve and subscribe to channels.
 * Server side clients are represented, just like remote clients, through the Client interface.
 * <br/>
 * The Bayeux implementations is intended to be thread safe and multiple threads may simultaneously call Bayeux methods.
 * <br/>
 * The Bayeux object, is the starting point for any cometd application relying on the Bayeux object.
 * Dependent on the container, the Bayeux object will be stored in the <code>javax.servlet.ServletContext</code> object
 * as an attribute under the name <code>Bayeux.DOJOX_COMETD_BAYEUX</code><br/>
 * To retrieve this object, one would simply call<br/>
 * <code>Bayeux bx = (Bayeux)getServletContext().getAttribute(Bayeux.DOJOX_COMETD_BAYEUX);
 * <br/><br/>
 * The Bayeux protocol is pretty straight forward and includes a bunch of messaging that is not needed to be known to clients,
 * both server side and remote clients.
 * This object gets initialized by a container dependent servlet, and the servlet then handles all Bayeux communication from the client.
 * Remote messsages are delivered to channels, and to server side clients using the <code>Listener</code> interface.<br/>
 * <br/>
 * A <code>Bayeux session</code> is active as long as the webapp hosting the Bayeux object is active.<br/>
 * When the webapplication shuts down, the Bayeux object will unsubscribe all clients and remove all the active channels.
 * 
 * @author Greg Wilkins
 * @author Filip Hanik
 */
    
    /**Meta definitions for channels*/
    public static final String META="/meta";
    /**Meta definitions for channels*/
    public static final String META_SLASH="/meta/";
    /**Meta definitions for channels - connect message*/
    public static final String META_CONNECT="/meta/connect";
    /**Meta definitions for channels - client messsage*/
    public static final String META_CLIENT="/meta/client";
    /**Meta definitions for channels - disconnect messsage*/
    public static final String META_DISCONNECT="/meta/disconnect";
    /**Meta definitions for channels - handshake messsage*/
    public static final String META_HANDSHAKE="/meta/handshake";
    /**Meta definitions for channels - ping messsage*/
    public static final String META_PING="/meta/ping";
    /**Meta definitions for channels - reconnect messsage
     * @deprecated
     */
    public static final String META_RECONNECT="/meta/reconnect";
    /**Meta definitions for channels - status messsage*/
    public static final String META_STATUS="/meta/status";
    /**Meta definitions for channels - subscribe messsage*/
    public static final String META_SUBSCRIBE="/meta/subscribe";
    /**Meta definitions for channels - unsubscribe messsage*/
    public static final String META_UNSUBSCRIBE="/meta/unsubscribe";
    /*Field names inside Bayeux messages*/
    /**Field names inside Bayeux messages - clientId field*/
    public static final String CLIENT_FIELD="clientId";
    /**Field names inside Bayeux messages - data field*/
    public static final String DATA_FIELD="data";
    /**Field names inside Bayeux messages - channel field*/
    public static final String CHANNEL_FIELD="channel";
    /**Field names inside Bayeux messages - id field*/
    public static final String ID_FIELD="id";
    /**Field names inside Bayeux messages - error field*/
    public static final String ERROR_FIELD="error";
    /**Field names inside Bayeux messages - timestamp field*/
    public static final String TIMESTAMP_FIELD="timestamp";
    /**Field names inside Bayeux messages - transport field*/
    public static final String TRANSPORT_FIELD="transport";
    /**Field names inside Bayeux messages - advice field*/
    public static final String ADVICE_FIELD="advice";
    /**Field names inside Bayeux messages - successful field*/
    public static final String SUCCESSFUL_FIELD="successful";
    /**Field names inside Bayeux messages - subscription field*/
    public static final String SUBSCRIPTION_FIELD="subscription";
    /**Field names inside Bayeux messages - ext field*/
    public static final String EXT_FIELD="ext";
    /**Field names inside Bayeux messages - connectionType field*/
    public static final String CONNECTION_TYPE_FIELD="connectionType";
    /**Field names inside Bayeux messages - version field*/
    public static final String VERSION_FIELD="version";
    /**Field names inside Bayeux messages - minimumVersion field*/
    public static final String MIN_VERSION_FIELD="minimumVersion";
    /**Field names inside Bayeux messages - supportedConnectionTypes field*/
    public static final String SUPP_CONNECTION_TYPE_FIELD="supportedConnectionTypes";
    /**Field names inside Bayeux messages - json-comment-filtered field*/
    public static final String JSON_COMMENT_FILTERED_FIELD="json-comment-filtered";
    /**Field names inside Bayeux messages - reconnect field*/
    public static final String RECONNECT_FIELD = "reconnect";
    /**Field names inside Bayeux messages - interval field*/
    public static final String INTERVAL_FIELD = "interval";
    /**Field values inside Bayeux messages - retry response*/
    public static final String RETRY_RESPONSE = "retry";
    /**Field values inside Bayeux messages - handshake response*/
    public static final String HANDSHAKE_RESPONSE = "handshake";
    /**Field values inside Bayeux messages - none response*/
    public static final String NONE_RESPONSE = "none";
    /**Service channel names-starts with*/
    public static final String SERVICE="/service";
    /**Service channel names-trailing slash*/
    public static final String SERVICE_SLASH="/service/";
    /*Transport types*/
    /**Transport types - long polling*/
    public static final String TRANSPORT_LONG_POLL="long-polling";
    /**Transport types - callback polling*/
    public static final String TRANSPORT_CALLBACK_POLL="callback-polling";
    /**Transport types - iframe*/
    public static final String TRANSPORT_IFRAME="iframe";
    /**Transport types - flash*/
    public static final String TRANSPORT_FLASH="flash";
    /** ServletContext attribute name used to obtain the Bayeux object */
    public static final String DOJOX_COMETD_BAYEUX="dojox.cometd.bayeux";
    /*http field names*/
    /**http helpers - text/json content type*/
    public static final String JSON_CONTENT_TYPE="text/json";
    /**http helpers - parameter name for json message*/
    public static final String MESSAGE_PARAMETER="message";
    /**http helpers - name of the jsonp parameter*/
    public static final String JSONP_PARAMETER="jsonp";
    /**http helpers - default name of the jsonp callback function*/
    public static final String JSONP_DEFAULT_NAME="jsonpcallback";
    /*--Client----------------------------------------------------------- */
    /**
     * Creates a new server side client. This method is to be invoked
     * by server side objects only. You cannot create a remote client by using this method.
     * A client represents an entity that can subscribe to channels and publish and receive messages
     * through these channels
     * @param idprefix String - the prefix string for the id generated, can be null
     * @param listener Listener - a callback object to be called when messages are to be delivered to the new client
     * @return Client - returns an implementation of the client interface.
     */
    public Client newClient(String idprefix, Listener listener);
    /**
     * retrieve a client based on an ID. Will return null if the client doesn't exist.
     * @param clientid String
     * @return Client-null if the client doesn't exist.returns the client if it does.
     */
    public Client getClient(String clientid);
    
    /**
     * Returns a non modifiable list of all the clients that are currently active
     * in this Bayeux session
     * @return List<Client> - a list containing all clients. The List can not be modified.
     */
    public List<Client> getClients();
    
    /**
     * Returns true if a client with the given id exists.<br/>
     * Same as executing <code>getClient(id)!=null</code>.
     * @param clientId String
     * @return boolean - true if the client exists
     */
    public boolean hasClient(String clientId);
    
    /**
     * Removes the client all together.
     * This will unsubscribe the client to any channels it may be subscribed to
     * and remove it from the list.
     * @param client Client
     * @return Client - returns the client that was removed, or null if no client was removed.
     */
    public Client remove(Client client);
    
    /*--Channel---------------------------------------------------------- */
    /**
     * Returns the channel for a given channel id.
     * If the channel doesn't exist, and the <code>create</code> parameter is set to true,
     * the channel will be created and added to the list of active channels.<br/>
     * if <code>create</code> is set to false, and the channel doesn't exist, null will be returned.
     * @param channelId String - the id of the channel to be retrieved or created
     * @param create boolean - true if the Bayeux impl should create the channel
     * @return Channel - null if <code>create</code> is set to false and the channel doesn't exist, 
     * otherwise it returns a channel object.
     */
    public Channel getChannel(String channelId, boolean create);
    
    /**
     * Returns a list of currently active channels in this Bayeux session.
     * @return List<Channel>
     */
    public List<Channel> getChannels();
    /**
     * Removes a channel from the Bayeux object.
     * This will also unsubscribe all the clients currently subscribed to the
     * the channel.
     * @param channel Channel - the channel to be removed
     * @return Channel - returns the channel that was removed, or null if no channel was removed.
     */
    public Channel remove(Channel channel);
    /**
     * returns true if a channel with the given channelId exists.
     * <br/>Same as executing <code>Bayeux.getChannel(channelId,false)!=null</code>
     * @param channelId String
     * @return boolean - true if the channel exists.
     */
    public boolean hasChannel(String channelId);
    /* --Message---------------------------------------------------------- */
    /**
     * Creates a new message to be sent by a server side client.
     * @return Message - returns a new Message object, that has a unique id.
     */
    public Message newMessage(Client from);
    /*--Security policy----------------------------------------------------------- */
    /**
     * Returns the security policy associated with this Bayeux session
     * @return SecurityPolicy
     */
    public SecurityPolicy getSecurityPolicy();
   
    /**
     * Sets the security policy to be used in this Bayeux session
     * @param securityPolicy SecurityPolicy
     */
    public void setSecurityPolicy(SecurityPolicy securityPolicy);
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * A Bayeux Channel represents a channel used to receive messages from and to publish messages to.
 * In order to publish messages to or receive messages from, one must subscribe to the channel.
 * This is easily done by invoking the <code>subscribe</code> method.
 * A channel is created by calling the <code>Bayeux.getChannel(channelId,true)</code> method.
 * A channel can be created either server side by invoking the getChannel, or client side
 * by using the /meta/subscribe message without a wildcard.
 * @author Greg Wilkins
 * @author Filip Hanik
 */
    /**
     * Returns the id for this channel. The id is unique within bayeux session.
     * @return String - will never be null.
     */
    public String getId();
    /** 
     * Publishes a message to all the subscribers of this channel.
     * The <code>from</code> is contained within the message, by calling
     * <code>msg.getClient()</code>
     * @param data - the message to be published, can not be null.
     */
    public void publish(Message msg);
    
    /** 
     * Publishes more than one message to all the subscribers of this channel.
     * The <code>from</code> is contained within the message, by calling
     * <code>msg[x].getClient()</code>
     * @param data - the message to be published, can not be null.
     */
    public void publish(Message[] msgs);
    /** 
     * Non persistent channels are removed when the last subscription is
     * removed. Persistent channels survive periods without any subscribers.
     * @return true if the Channel will persist without any subscription.
     */
    public boolean isPersistent();
    
    /**
     * @param persistent true if the Channel will persist without any subscription.
     * @see isPersistent
     */
    public void setPersistent(boolean persistent);
    
    /** 
     * Subscribes a client to a channel.
     * @param subscriber - the client to be subscribed. If the client
     * already is subscribed, this call will not create a duplicate subscription.
     */
    public void subscribe(Client subscriber);
    /** 
     * Unsubscribes a client from a channel
     * @param subscriber - the client to be subscribed.
     * @return - returns the client that was unsubscribed, or null if the client wasn't subscribed.
     */
    public Client unsubscribe(Client subscriber);
    /**
     * returns a non modifiable list of all the subscribers to this 
     * channel.
     * @return a list of subscribers
     */
    public List<Client> getSubscribers();
    
    /**
     * Adds a data filter to this channel. All messages received by this channel 
     * will run through this filter.
     * @param filter Filter
     */
    public void addFilter(DataFilter filter);
    
    /**
     * Removes a filter from this channel.
     * returns the filter that was removed, or null if the filter wasn't in the channel.
     * @param filter Filter
     * @return Filter - null if no filter was removed otherwise it returns the filter that was removed.
     */
    public DataFilter removeFilter(DataFilter filter);
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * <p>
 * A client may subscribe to channels and publish messages to channels.
 * Client instances should not be directly created by uses, but should 
 * be obtained via the {@link Bayeux#getClient(String)} or {@link Bayeux#newClient(String, Listener)}
 * methods.
 * </p>
 * <p>
 * Three types of client may be represented by this interface:<nl>
 * <li>The server representation of a remote client connected via HTTP, 
 *     automatically created by the Bayeux server when a connect message comes in</li>
 * <li>A server side client, created by the application using the {@link Bayeux#newClient(String, Listener)} method</li>
 * <li>A java client connected to a remote Bayeux server - not implemented</li>
 * </nl>
 * @author Greg Wilkins
 * @author Filip Hanik
 */
    /**
     * Returns a unique id for this client. The id is unique within this Bayeux session.
     * @return String - will not be null
     */
    public String getId();
    /**
     * Returns true if this client is holding messages to be delivered to the remote client.
     * This method always returns false for local clients, since messages are delivered instantly using the 
     * Listener(callback) object
     * @return boolean
     */
    public boolean hasMessages();
    /** 
     * Deliver a message to this client only
     * Deliver a message directly to the client. The message is not 
     * filtered or published to a channel.
     * @param message
     */
    public void deliver(Message message);
    /** 
     * Deliver a batch of messages to this client only
     * Deliver a batch messages directly to the client. The messages are not 
     * filtered or published to a channel.
     * @param message
     */
    public void deliver(Message[] message);
    /**
     * @return True if the client is local. False if this client is either a remote HTTP client or
     * a java client to a remote server. 
     */
    public boolean isLocal();
    
    /**
     * Starts a batch, no messages will be delivered until endBatch is called.
     * Batches can be nested, and messages will only be delivered after
     * the last endBatch has been called.
     */
    public void startBatch();
    
    /**
     * Ends a batch. since batches can be nested, messages will only be delivered
     * after the endBatch has been called as many times as startBatch has.
     */
    public void endBatch();
    
    
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Data Filter<br/>
 * Data filters are used to transform data as it is sent to a Channel.
 * Messages are filtered as the message is published to a channel, invoking the 
 * {@link Channel#publish(Message)} method.<br/>
 * This method gets invoked in two different scenarios, the first being when a message is received from
 * a remote client, and the Bayeux implementation invokes the publish method directly.
 * The second scenario is when a local client invokes {@link Channel#publish(Message)} directly in the local JVM.
 * @author Greg Wilkins
 * @author Filip Hanik
 *
 */
    /**
     * Runs a message through the filter. Filtering can only modify an existing object, it can not replace it.
     * @param data Message - the message to be filtered, may not be null
     */
    public void filter(Message data);
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Cometd Listener interface.<br/>
 * For local clients, in order to receive messages, they pass in a callback object
 * when the local client is created using the {@link Bayeux#newClient(String,Listener)} method.
 * This callback object, implementing the Listener interface, is used to deliver messages to local, in JVM, clients.
 * @author Greg Wilkins
 * @author Filip Hanik
 *
 */
    /**
     * This method is called when the client is removed (explicitly or from a timeout)
     * @param timeout - true if the client was removed from a timeout
     * false if it was removed explicitly.
     */
    public void removed(boolean timeout);
    
    /**
     * Invoked when a message is delivered to the client.
     * The message contains the message itself, as well as what channel this message came through
     * and who the sender is. If someone invoked {@link Client#deliver(Message)} then the channel reference will
     * be null.
     * @param msg 
     */
    public void deliver(Message[] msg);
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * A Bayeux Message<br/>
 * A Bayeux message is a Map of String/Object key value pairs representing the data in the message.
 * The message contains information about the channel it was published through and who the sender was
 * 
 * @author Greg Wilkins
 * @author Filip Hanik
 */
    /**
     * Returns a reference to the client that sent this message
     * @return Client - may be null
     */
    public Client getClient();
    /**
     * Returns a reference to the channel that this message was published throuhg
     * @return Channel - may be null
     */
    public Channel getChannel();
    /**
     * Returns the unique id of this message
     * @return String
     */
    public String getId();
    
    /**
     * Sets the time to live in milliseconds. If the message hasn't been delivered 
     * when the time passed after the creation time is longer than the TTL the message will
     * expire and removed from any delivery queues.
     * @param ttl long
     */
    public void setTTL(long ttl);
    
    /**
     * Returns the time to live (in milliseconds) for this message
     * @return long
     */
    public long getTTL();
    
    /**
     * returns the timestamp in milliseconds(System.currentTimeMillis()) of when this message was created.
     * @return long
     */
    public long getCreationTime();
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * @author Greg Wilkins
 */
    boolean canHandshake(Message message);
    boolean canCreate(Client client,String channel,Message message);
    boolean canSubscribe(Client client,String channel,Message messsage);
    boolean canPublish(Client client,String channel,Message messsage);
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * 
 * @author Filip Hanik
 * @version 1.0
 */
    public BayeuxException() {
        super();
    }
    public BayeuxException(String message) {
        super(message);
    }
    public BayeuxException(String message, Throwable cause) {
        super(message, cause);
    }
    public BayeuxException(Throwable cause) {
        super(cause);
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * An interface that defines methods for managing Bayeux request meta 
 * messages.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 0.9
 */
    public static final String LAST_REQ_ATTR = "org.apache.cometd.bayeux.last_request";
    public static final String CURRENT_REQ_ATTR = "org.apache.cometd.bayeux.current_request";
    public static final String JSON_MSG_ARRAY = "org.apache.cometd.bayeux.json_msg_array";
    /**
     * Validates a specific request. 
     * This method must be called prior to process()
     * as a request can do pre processing in the validate method.
     * <br/>
     * Should the validation fail, an error object is returned 
     * containing an error message, and potentially a stack trace
     * if an exception was generated
     * @return HttpError - null if no error was detected, an HttpError object containing information about the error.
     */
    public HttpError validate();
    
    /**
     * processes a remote client Bayeux message
     * @param prevops - the operation requested by the previous request, in case of chained requests.
     * @return int - returns the interest operation for a CometEvent. Currently not used
     * @throws BayeuxException - if an error was detected, and the appropriate error response couldn't be delivered to the client. 
     */
    public int process(int prevops) throws BayeuxException;
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * 
 * @author Filip Hanik
 * @author Guy Molinari
 * @version 1.0
 */
    /**
     * Attribute to hold the TomcatBayeux object in the servlet context
     */
    public static final String TOMCAT_BAYEUX_ATTR = Bayeux.DOJOX_COMETD_BAYEUX;
    
    /**
     * Logger object
     */
    protected static Log log = LogFactory.getLog(BayeuxServlet.class);
    /**
     * Servlet config - for future use
     */
    protected ServletConfig servletConfig;
    
    /**
     * Reference to the global TomcatBayeux object
     */
    protected TomcatBayeux tb;
    
    /**
     * Upon servlet destruction, the servlet will clean up the 
     * TomcatBayeux object and terminate any outstanding events.
     */
    public void destroy() {
        servletConfig = null;
        //to do, close all outstanding comet events
        //tb.destroy();
        tb = null;//TO DO, close everything down
        
    }
    
    /**
     * Returns the preconfigured connection timeout.
     * If no timeout has been configured as a servlet init parameter named <code>timeout</code>
     * then the default of 2min will be used.
     * @return int - the timeout for a connection in milliseconds
     */
    protected int getTimeout() {
        String timeoutS = servletConfig.getInitParameter("timeout");
        int timeout = 120*1000; //2 min
        try {
            timeout = Integer.parseInt(timeoutS);
        }catch (NumberFormatException nfe) {
            //ignore, we have a default value
        }
        return timeout;
    }
    
    protected int getReconnectInterval() {
        String rs = servletConfig.getInitParameter("reconnectInterval");
        int rct = 1000; //1 seconds
        try {
            rct = Integer.parseInt(rs);
        }catch (NumberFormatException nfe) {
            //ignore, we have a default value
        }
        return rct;
    }
    public void event(CometEvent cometEvent) throws IOException, ServletException {
        CometEvent.EventType type = cometEvent.getEventType();
        if (log.isDebugEnabled()) {
            log.debug("["+Thread.currentThread().getName()+"] Received Comet Event type="+type+" subtype:"+cometEvent.getEventSubType());
        }
        synchronized (cometEvent) {
            if (type==CometEvent.EventType.BEGIN) {
                //begin event, set the timeout
                cometEvent.setTimeout(getTimeout());
                //checkBayeux(cometEvent); - READ event should always come
            } else if (type==CometEvent.EventType.READ) {
                checkBayeux(cometEvent);
            } else if (type==CometEvent.EventType.ERROR) {
                tb.remove(cometEvent);
                cometEvent.close();
            } else if (type==CometEvent.EventType.END) {
                tb.remove(cometEvent);
                cometEvent.close();
            }//end if
            
        }//synchronized
    }//event
    /**
     * 
     * @param cometEvent CometEvent
     * @return boolean - true if we comet event stays open
     * @throws IOException
     * @throws UnsupportedOperationException
     */
    protected void checkBayeux(CometEvent cometEvent) throws IOException, UnsupportedOperationException {
        //we actually have data.
        //data can be text/json or 
        if (Bayeux.JSON_CONTENT_TYPE.equals(cometEvent.getHttpServletRequest().getContentType())) {
            //read and decode the bytes according to content length
            log.warn("["+Thread.currentThread().getName()+"] JSON encoding not supported, will throw an exception and abort the request.");
            int contentlength = cometEvent.getHttpServletRequest().getContentLength();
            throw new UnsupportedOperationException("Decoding "+Bayeux.JSON_CONTENT_TYPE+" not yet implemented.");
        } else { //GET method or application/x-www-form-urlencoded
            String message = cometEvent.getHttpServletRequest().getParameter(Bayeux.MESSAGE_PARAMETER);
            if (log.isTraceEnabled()) {
                log.trace("["+Thread.currentThread().getName()+"] Received JSON message:"+message);
            }
            try {
                int action = handleBayeux(message, cometEvent);
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Bayeux handling complete, action result="+action);
                }
                if (action<=0) {
                    cometEvent.close();
                }
            }catch (Exception x) {
                x.printStackTrace();
                tb.remove(cometEvent);
                log.error(x);
                cometEvent.close();
            }
        }
    }
    
    protected int handleBayeux(String message, CometEvent event) throws IOException, ServletException {
        int result = 0;
        if (message==null || message.length()==0) return result;
        try {
            BayeuxRequest request = null;
            //a message can be an array of messages
            JSONArray jsArray = new JSONArray(message);
            for (int i = 0; i < jsArray.length(); i++) {
                JSONObject msg = jsArray.getJSONObject(i);
                
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Processing bayeux message:"+msg);
                }
                request = RequestFactory.getRequest(tb,event,msg);
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Processing bayeux message using request:"+request);
                }
                result = request.process(result);
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Processing bayeux message result:"+result);
                }
            }
            if (result>0 && request!=null) {
                event.getHttpServletRequest().setAttribute(BayeuxRequest.LAST_REQ_ATTR, request);
                ClientImpl ci = (ClientImpl)tb.getClient(((RequestBase)request).getClientId());
                ci.addCometEvent(event);
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Done bayeux message added to request attribute");
                }
            } else if (result == 0 && request!=null) {
                RequestBase.deliver(event,(ClientImpl)tb.getClient(((RequestBase)request).getClientId()));
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Done bayeux message, delivered to client");
                }
            }
            
        }catch (JSONException x) {
            log.error(x);//to do impl error handling
            result = -1;
        }catch (BayeuxException x) {
            log.error(x); //to do impl error handling
            result = -1;
        }
        return result;
    }
    public ServletConfig getServletConfig() {
        return servletConfig;
    }
    public String getServletInfo() {
        return "Tomcat/BayeuxServlet/1.0";
    }
    public void init(ServletConfig servletConfig) throws ServletException {
        
        this.servletConfig = servletConfig;
        ServletContext ctx = servletConfig.getServletContext();
        if (ctx.getAttribute(TOMCAT_BAYEUX_ATTR)==null)
            ctx.setAttribute(TOMCAT_BAYEUX_ATTR,new TomcatBayeux());
        this.tb = (TomcatBayeux)ctx.getAttribute(TOMCAT_BAYEUX_ATTR);
        tb.setReconnectInterval(getReconnectInterval());
    }
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        if (servletResponse instanceof HttpServletResponse) {
            ( (HttpServletResponse) servletResponse).sendError(500, "Misconfigured Tomcat server, must be configured to support Comet operations.");
        } else {
            throw new ServletException("Misconfigured Tomcat server, must be configured to support Comet operations for the Bayeux protocol.");
        }
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * 
 * @author Filip Hanik
 * @version 1.0
 */
    
    protected static Log log = LogFactory.getLog(ChannelImpl.class);
    
    /**
     * The unique id of this channel
     */
    protected String id = null;
    
    /**
     * A list of the current subscribers
     */
    protected LinkedList<Client> subscribers = new LinkedList<Client>();
    
    /**
     * A list of the current filters
     */
    protected LinkedList<DataFilter> filters = new LinkedList<DataFilter>();
    
    /**
     * Is this channel persistent, default value is true
     */
    protected boolean persistent = true; 
    
    /**
     * Creates a new channel
     * @param id String - the id of the channel, can not be null
     */
    protected ChannelImpl(String id) {
        assert id != null;
        this.id = id;
    }
    /**
     * returns the id of this channel
     * @return String
     */
    public String getId() {
        return id;
    }
    
    /**
     * Returns true if this channel matches the pattern to its id.
     * The channel pattern can be a complete name like <code>/service/mychannel</code>
     * or it can be a wild card pattern like <code>/service/app2/**</code>
     * @param pattern String according to the Bayeux specification section 2.2.1 Channel Globbing, can not be null.
     * @return boolean true if the id of this channel matches the pattern
     */
    public boolean matches(String pattern) {
        if (pattern == null)
            throw new NullPointerException("Channel pattern must not be null.");
        if (getId().equals(pattern))
            return true;
        int wildcardPos = pattern.indexOf("/*");
        if (wildcardPos == -1)
            return false;
        boolean multiSegment = pattern.indexOf("**") != -1;
        String leadSubstring = pattern.substring(0, wildcardPos);
        if (leadSubstring == null)
            return false;
        if (multiSegment) 
            return getId().startsWith(leadSubstring);
        else {
            if (getId().length() <= wildcardPos + 2)
                return false;
            return !(getId().substring(wildcardPos + 2).contains("/"));
        }
    }
    /**
     * @return returns a non modifiable list of the subscribers for this channel.
     */
    public List<Client> getSubscribers() {
        return Collections.unmodifiableList(subscribers);
    }
    /**
     * @return true if the Channel will persist without any subscription.
     */
    public boolean isPersistent() {
        return persistent;
    }
    
    public void publish(Message msg) {
        publish(new Message[] {msg});
    }
    public void publish(Message[] msgs) {
        if (msgs==null) return;
        MessageImpl[] imsgs = new MessageImpl[msgs.length];
        for (int i=0; msgs!=null && i<msgs.length; i++) {
            Message data = msgs[i];
            if (!(data instanceof MessageImpl)) 
                throw new IllegalArgumentException("Invalid message class, you can only publish messages "+
                                                   "created through the Bayeux.newMessage() method");
            if (log.isDebugEnabled()) {
                log.debug("Publishing message:"+data+" to channel:"+this);
            }
            //clone it so that we can set this channel as a reference
            MessageImpl msg = (MessageImpl)((MessageImpl)data).clone();
            //this is the channel it was delivered through
            msg.setChannel(this);
            //pass through filters
            for (Iterator<DataFilter> it = filters.iterator(); it.hasNext(); ) {
                it.next().filter(msg);
            }
            imsgs[i] = msg;
        }
        //deliver it to the clients
        for (Iterator<Client> it = subscribers.iterator(); it.hasNext(); ) {
            ClientImpl c = (ClientImpl)it.next();
            c.deliverInternal(this,imsgs);
        }
        
    }
    public void setPersistent(boolean persistent) {
        this.persistent = persistent;
    }
    public void subscribe(Client subscriber) {
        if (!subscribers.contains((subscriber))) { 
            subscribers.addLast(subscriber);
            ((ClientImpl)subscriber).subscribed(this);
        }
    }
    public Client unsubscribe(Client subscriber) {
        if (subscribers.remove(subscriber)) {
            ((ClientImpl)subscriber).unsubscribed(this);
            return subscriber;
        } else
            return null;
    }
    
    public void addFilter(DataFilter filter) {
        if (!filters.contains(filter)) 
            filters.addLast(filter);
    }
    public DataFilter removeFilter(DataFilter filter) {
        if ( filters.remove(filter) ) return filter;
        else return null;
    }
    
    public String toString() {
        StringBuffer buf = new StringBuffer(super.toString());
        buf.append("; channelId=").append(getId());
        return buf.toString();
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    
    public static final int SUPPORT_CALLBACK_POLL = 0x1;
    public static final int SUPPORT_LONG_POLL = 0x2; 
    public static final String COMET_EVENT_ATTR = "org.apache.cometd.bayeux.client";
    
    protected static Log log = LogFactory.getLog(ClientImpl.class);
    protected static LinkedList<Message> EMPTY_LIST = new LinkedList<Message>();
    /**
     * queued message for remote clients.
     */
    protected LinkedList<Message> messages = null;
    
    /**
     * 
     */
    protected Queue<CometEvent> events = new LinkedList<CometEvent>();
    
    /**
     * Unique id representing this client
     */
    protected String id;
    
    /**
     * supported connection types, defaults to long-polling
     */
    protected int supportedConnTypes = SUPPORT_LONG_POLL | SUPPORT_CALLBACK_POLL;
    
    /**
     * The desired connection type
     */
    protected int desirectConnType = SUPPORT_LONG_POLL;
    
    /**
     * Does this client use json-comment-filtered messages
     */
    protected boolean useJsonFiltered = false;
    
    /**
     * Same JVM clients, get local=true
     */
    protected boolean local;
    
    /**
     * The callback object for local clients
     */
    protected Listener listener;
    
    protected AtomicInteger nrofsubscriptions = new AtomicInteger(0);
    
    protected ClientImpl(String id, boolean local) {
        this.id = id;
        this.local = local;
        if (!local) messages = new LinkedList<Message>();
    }
    
    protected ClientImpl(String id, CometEvent event) {
        this(id,false);
        events = new ConcurrentLinkedQueue<CometEvent>();
        addCometEvent(event);
    }
    public synchronized void deliver(Message message) {
        deliverInternal(null,new MessageImpl[] {(MessageImpl)message});
    }
    
    public synchronized void deliver(Message[] message) {
        deliverInternal(null,message);
    }
    protected synchronized void deliverInternal(ChannelImpl channel, MessageImpl message) {
        deliverInternal(channel,new MessageImpl[] {message});
    }
    protected synchronized void deliverInternal(ChannelImpl channel, Message[] msgs) {
        if (isLocal()) {
            //local clients must have a listener
            ArrayList<Message> list = new ArrayList<Message>();
            for (int i=0; msgs!=null && i<msgs.length; i++) {
                //dont deliver to ourselves
                if (this!=msgs[i].getClient()) list.add(msgs[i]);
            }
            if (getListener() != null && list.size()>0) {
                getListener().deliver(list.toArray(new Message[0]));
            }
        } else {
            for (int i=0; msgs!=null && i<msgs.length; i++) {
                MessageImpl message = (MessageImpl)msgs[i];
                if (this==message.getClient()) { 
                    //dont deliver to ourself
                    continue;
                }
                //we are not implementing forever responses, if the client is connected
                //then we will fire off the message
                //first we check to see if we have any existing connections we can piggy back on
                CometEvent event = events.poll();
                boolean delivered = false;
                //TODO TODO - check on thread safety, for writing and for getting last request.
                if (event!=null) {
                    synchronized (event) {
                        RequestBase rq = (RequestBase)event.getHttpServletRequest().getAttribute(RequestBase.LAST_REQ_ATTR);
                        if (rq!=null) {
                            Map map = new HashMap();
                            try {
                                map.put(Bayeux.CHANNEL_FIELD,message.getChannel().getId());
                                map.put(Bayeux.DATA_FIELD,message);
                                JSONObject json = new JSONObject(map);
                                if (log.isDebugEnabled()) {
                                    log.debug("Message instantly delivered to remote client["+this+"] message:"+json);
                                }
                                rq.addToDeliveryQueue(this, json);
                                //deliver the batch
                                if (i==(msgs.length-1)) {
                                    rq.deliver(event, this);
                                    event.close(); //todo, figure out a better way, this means only one message gets delivered
                                    removeCometEvent(event); //and delivered instantly
                                }
                                delivered = true;
                            } catch (Exception x) {
                                log.error(x);
                            }
                        }
                    }
                } 
                if (!delivered) {
                    if (log.isDebugEnabled()) {
                        log.debug("Message added to queue for remote client["+this+"] message:"+message);
                    }
                    //queue the message for the next round
                    messages.add(message);
                }
            }
        }
    }
    public String getId() {
        return this.id;
    }
    protected Listener getListener() {
        return listener;
    }
    public boolean hasMessages() {
        if (isLocal()) return false;
        else {
            return messages.size() > 0;
        }
    }
    public boolean isLocal() {
        return local;
    }
    public int getSupportedConnTypes() {
        return supportedConnTypes;
    }
    public int getDesirectConnType() {
        return desirectConnType;
    }
    public boolean useJsonFiltered() {
        return useJsonFiltered;
    }
    public void setListener(Listener listener) {
        this.listener = listener;
    }
    public void setSupportedConnTypes(int supportedConnTypes) {
        this.supportedConnTypes = supportedConnTypes;
    }
    public void setUseJsonFiltered(boolean useJsonFiltered) {
        this.useJsonFiltered = useJsonFiltered;
    }
    public void setDesirectConnType(int desirectConnType) {
        this.desirectConnType = desirectConnType;
    }
    public boolean supportsCallbackPoll() {
        return (supportedConnTypes & SUPPORT_CALLBACK_POLL) == SUPPORT_CALLBACK_POLL;
    }
    public boolean supportsLongPoll() {
        return (supportedConnTypes & SUPPORT_LONG_POLL) == SUPPORT_LONG_POLL;
    }
    public synchronized List<Message> takeMessages() {
        if (isLocal()) return null;
        if (messages.size()==0) return EMPTY_LIST;
        List result = new LinkedList(messages);
        messages.clear();
        return result;
    }
    
    public String toString() {
        StringBuffer buf = new StringBuffer(super.toString());
        buf.append(" id=").append(getId());
        return buf.toString();
    }
    
    public boolean isSubscribed() {
        return nrofsubscriptions.get()>0;
    }
    
    protected synchronized boolean addCometEvent(CometEvent event) {
        boolean result = false;
        if (!events.contains(event)) {
            events.add(event);
            result = true;
        }
        event.getHttpServletRequest().setAttribute(COMET_EVENT_ATTR,this);
        return result;
    }
    
    protected synchronized boolean removeCometEvent(CometEvent event) {
        boolean result = events.remove(event);
        event.getHttpServletRequest().removeAttribute(COMET_EVENT_ATTR);
        return result;
    }
    
    
    protected void subscribed(ChannelImpl ch) {
        nrofsubscriptions.addAndGet(1);
    }
    
    protected void unsubscribed(ChannelImpl ch) {
        nrofsubscriptions.addAndGet(-1);
    }
    
    public void startBatch(){
        //noop until improved
    }
    public void endBatch() {
        //noop until improved
    }
        
    private int code;
    private String status;
    private Throwable cause;
    public HttpError(int code, String status, Throwable cause) {
        this.code = code;
        this.status = status;
        this.cause = cause;
    }
    public void setCode(int code) {
        this.code = code;
    }
    public void setStatus(String status) {
        this.status = status;
    }
    public void setCause(Throwable exception) {
        this.cause = exception;
    }
    public int getCode() {
        return code;
    }
    public String getStatus() {
        return status;
    }
    public Throwable getCause() {
        return cause;
    }
    public String toString() {
        if (cause != null)
            return code + ":" + status + " - [" + cause + "]";
        else
            return code + ":" + status;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    
    protected Channel channel;
    protected Client client;
    protected String id;
    private long TTL = 1000*60*5; //5min is the default TTL for a message
    protected long creationTime = System.currentTimeMillis();
    public Object clone() {
        MessageImpl copy = new MessageImpl(id);
        copy.putAll(this);
        copy.channel = channel;
        copy.client = client;
        copy.id = id;
        copy.creationTime = creationTime;
        copy.TTL = TTL;
        return copy;
    }
    protected MessageImpl(String id) {
        assert id != null;
        this.id = id;
    }
    public Channel getChannel() {
        return channel;
    }
    public Client getClient() {
        return client;
    }
    public long getCreationTime() {
        return creationTime;
    }
    public long getTTL() {
        return TTL;
    }
    public String getId() {
        return id;
    }
    protected void setChannel(Channel channel) {
        this.channel = channel;
    }
    protected void setClient(Client client) {
        this.client = client;
    }
    public void setTTL(long TTL) {
        this.TTL = TTL;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Common functionality and member variables for all Bayeux requests.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 0.9
 *
 */
    
    protected static final SimpleDateFormat timestampFmt =
        new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
    static {
        timestampFmt.setTimeZone(TimeZone.getTimeZone("GMT"));
    }
    //message properties, combined for all messages
    protected TomcatBayeux tomcatBayeux;
    protected String channel;
    protected String id;
    protected String clientId;
    protected String version = null;
    protected String[] suppConnTypes = null;
    protected int suppConnTypesFlag = 0;
    protected int desiredConnTypeFlag = 0;
    protected String minVersion = null;
    protected String subscription = null;
    protected String data = null;
    protected String conType = null;
    protected LinkedHashMap<String, Object> ext = new LinkedHashMap<String, Object> ();
    
    protected CometEvent event;
    
    protected HashMap<String, Object> response = null;
    
    protected static Log log = LogFactory.getLog(RequestBase.class);
    
    protected int reconnectInterval = 1000;
    
    protected RequestBase(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        this.tomcatBayeux = tb;
        this.event = event;
        channel = jsReq.optString(Bayeux.CHANNEL_FIELD);
        id = jsReq.optString(Bayeux.ID_FIELD);
        clientId = jsReq.optString(Bayeux.CLIENT_FIELD);
        version = jsReq.optString(Bayeux.VERSION_FIELD);
        minVersion = jsReq.optString(Bayeux.MIN_VERSION_FIELD);
        conType = jsReq.optString(Bayeux.CONNECTION_TYPE_FIELD);
        subscription = jsReq.optString(Bayeux.SUBSCRIPTION_FIELD);
        data = jsReq.optString(Bayeux.DATA_FIELD);
        reconnectInterval = tb.getReconnectInterval();
        if (jsReq.has(Bayeux.EXT_FIELD)) {
            JSONObject jext = jsReq.getJSONObject(Bayeux.EXT_FIELD);
            for (Iterator<String> i = jext.keys(); i.hasNext(); ) {
                String key = i.next();
                ext.put(key, jext.get(key));
            }//for
        }//end if
        
        if (jsReq.has(Bayeux.SUPP_CONNECTION_TYPE_FIELD)) {
            JSONArray types = jsReq.getJSONArray(Bayeux.SUPP_CONNECTION_TYPE_FIELD);
            suppConnTypes = new String[types.length()];
            for (int i = 0; i < types.length(); i++) {
                suppConnTypes[i] = types.getString(i);
                if (Bayeux.TRANSPORT_CALLBACK_POLL.equals(suppConnTypes[i]))
                    suppConnTypesFlag = suppConnTypesFlag|ClientImpl.SUPPORT_CALLBACK_POLL;
                else if (Bayeux.TRANSPORT_LONG_POLL.equals(suppConnTypes[i]))
                    suppConnTypesFlag = suppConnTypesFlag|ClientImpl.SUPPORT_LONG_POLL;
            }//for
        }//end if
        if (conType!=null) {
            if (Bayeux.TRANSPORT_CALLBACK_POLL.equals(conType))
                desiredConnTypeFlag = ClientImpl.SUPPORT_CALLBACK_POLL;
            else if (Bayeux.TRANSPORT_LONG_POLL.equals(conType))
                desiredConnTypeFlag = ClientImpl.SUPPORT_LONG_POLL;
        }//end if
        
        //due to the fact that the javascript doesn't send up a required field
        //we have to fake it
        suppConnTypesFlag = ClientImpl.SUPPORT_CALLBACK_POLL | ClientImpl.SUPPORT_LONG_POLL;
    }
    public HttpError validate() {
        HttpError result = null;
        return result;
    }
    public TomcatBayeux getTomcatBayeux() {
        return tomcatBayeux;
    }
    public String getChannel() {
        return channel;
    }
    public String getId() {
        return id;
    }
    public String getClientId() {
        return clientId;
    }
    public LinkedHashMap getExt() {
        return ext;
    }
    public CometEvent getEvent() {
        return event;
    }
    
    protected static void deliver(CometEvent event, ClientImpl to) throws IOException, ServletException, BayeuxException {
        JSONArray jarray = getJSONArray(event,true);
        if ( jarray == null ) throw new BayeuxException("No message to send!");
        String jsonstring = jarray.toString();
        if (log.isDebugEnabled()) {
            log.debug("["+Thread.currentThread().getName()+"] Delivering message to[" + to + "] message:" + jsonstring);
        }
        if (to!=null) {
            if (to.useJsonFiltered()) {
                if (!event.getHttpServletResponse().isCommitted()) event.getHttpServletResponse().setContentType("text/json-comment-filtered");
            }else {	
                if (!event.getHttpServletResponse().isCommitted()) event.getHttpServletResponse().setContentType("text/json");
            }
        }
        PrintWriter out = event.getHttpServletResponse().getWriter();
        if (to==null) {
            //do nothing
        }else if ( (to.getDesirectConnType() == 0 && to.supportsLongPoll()) || to.getDesirectConnType() == ClientImpl.SUPPORT_LONG_POLL) {
            if (to.useJsonFiltered())
                out.print("/*");
        } else if ( (to.getDesirectConnType() == 0 && to.supportsCallbackPoll()) || to.getDesirectConnType() == ClientImpl.SUPPORT_CALLBACK_POLL) {
            String jsonp = event.getHttpServletRequest().getParameter(Bayeux.JSONP_PARAMETER);
            if (jsonp == null)
                jsonp = Bayeux.JSONP_DEFAULT_NAME;
            out.print(jsonp);
            out.print('(');
        } else {
            throw new BayeuxException("Client doesn't support any appropriate connection type.");
        }
        out.print(jsonstring);
        if ( to == null ) {
            //do nothing
        } else if ( (to.getDesirectConnType() == 0 && to.supportsLongPoll()) || to.getDesirectConnType() == ClientImpl.SUPPORT_LONG_POLL) {
            if (to.useJsonFiltered())
                out.print("*/");
        } else if ( (to.getDesirectConnType() == 0 && to.supportsCallbackPoll()) || to.getDesirectConnType() == ClientImpl.SUPPORT_CALLBACK_POLL) {
            out.print(");");
        } 
        out.flush();
        event.getHttpServletResponse().flushBuffer();
        
    }
    protected static JSONArray getJSONArray(CometEvent event, boolean nullok) {
        synchronized(event) {
            JSONArray jarray = (JSONArray) event.getHttpServletRequest().getAttribute(JSON_MSG_ARRAY);
            if (jarray == null && (!nullok)) {
                jarray = new JSONArray();
                event.getHttpServletRequest().setAttribute(JSON_MSG_ARRAY, jarray);
            }
            return jarray;
        }
    }
    protected JSONArray getJSONArray() {
        return getJSONArray(event,false);
    }
    protected void addToDeliveryQueue(ClientImpl to, JSONObject msg) throws IOException, ServletException, BayeuxException {
        synchronized (event) {
            getJSONArray().put(msg);
        }
    }
    
    protected void flushMessages(ClientImpl client) throws BayeuxException {
        List<Message> msgs = client.takeMessages();
        synchronized (event) {
            try {
                for (Iterator<Message> it = msgs.iterator(); it.hasNext(); ){
                    MessageImpl msg = (MessageImpl)it.next();
                    Map map = new HashMap();
                    map.put(Bayeux.CHANNEL_FIELD,msg.getChannel().getId());
                    if (msg.getClient()!=null) map.put(Bayeux.CLIENT_FIELD,msg.getClient().getId());
                    map.put(Bayeux.DATA_FIELD,msg);
                    JSONObject obj = new JSONObject(map);
                    addToDeliveryQueue(client, obj);
                }
            } catch (ServletException x) {
                throw new BayeuxException(x);
            } catch (IOException x) {
                throw new BayeuxException(x);
            }
        }
    }
    
    public int process(int prevops) throws BayeuxException {
        event.getHttpServletRequest().setAttribute(CURRENT_REQ_ATTR,this);
        return prevops;
    }
    
    public int getReconnectInterval() {
        return reconnectInterval;
    }
    public String getTimeStamp() {
        return timestampFmt.format(new Date(System.currentTimeMillis()));
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    public static BayeuxRequest getRequest(TomcatBayeux tomcatBayeux, CometEvent event, JSONObject msg) throws JSONException {
        String channel = msg.optString(Bayeux.CHANNEL_FIELD);
        if (Bayeux.META_HANDSHAKE.equals(channel)) {
            return new MetaHandshakeRequest(tomcatBayeux,event,msg);
        }else if (Bayeux.META_CONNECT.equals(channel)) {
            return new MetaConnectRequest(tomcatBayeux,event,msg);
        }else if (Bayeux.META_DISCONNECT.equals(channel)) {
            return new MetaDisconnectRequest(tomcatBayeux,event,msg);
        }else if (Bayeux.META_SUBSCRIBE.equals(channel)) {
            return new MetaSubscribeRequest(tomcatBayeux,event,msg);
        }else if (Bayeux.META_UNSUBSCRIBE.equals(channel)) {
            return new MetaUnsubscribeRequest(tomcatBayeux,event,msg);
        } else {
            return new PublishRequest(tomcatBayeux,event,msg);
        }
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * 
 * @author Filip Hanik
 * @version 1.0
 */
    
    protected int reconnectInterval = 5000;
    /**
     * a list of all active clients
     */
    protected HashMap<String,Client> clients = new HashMap<String,Client>();
    
    /**
     * a list of all active channels
     */
    protected LinkedHashMap<String, Channel> channels = new LinkedHashMap<String,Channel>();
    
    /**
     * security policy to be used.
     */
    protected SecurityPolicy securityPolicy = null;
    /**
     * default client to use when we need to send an error message but don't have a client valid reference
     */
    protected static ClientImpl errorClient = new ClientImpl("error-no-client",false);
    
    /**
     * returns the default error client
     * @return ClientImpl
     */
    public static ClientImpl getErrorClient() {
        return errorClient;
    }
    
    protected TomcatBayeux() {
    }
    
    /**
     * should be invoked when the servlet is destroyed or when the context shuts down
     */
    public void destroy() {
        throw new UnsupportedOperationException("TomcatBayeux.destroy() not yet implemented");
    }
    public Channel getChannel(String channelId, boolean create) {
        Channel result = channels.get(channelId);
        if (result==null && create) {
            result = new ChannelImpl(channelId);
            channels.put(channelId,result);
        }
        return result;
    }
    
    public Channel remove(Channel channel) {
        return channels.remove(channel.getId());
    }
    
    public Client remove(Client client) {
        if (client==null) return null;
        for (Channel ch : getChannels()) {
            ch.unsubscribe(client);
        }
        return clients.remove(client.getId());
    }
    public Client getClient(String clientId) {
        return clients.get(clientId);
    }
    
    public boolean hasClient(String clientId) {
        return clients.containsKey(clientId);
    }
    
    public List<Client> getClients() {
        return java.util.Arrays.asList(clients.entrySet().toArray(new Client[0]));
    }
    public SecurityPolicy getSecurityPolicy() {
        return securityPolicy;
    }
    public int getReconnectInterval() { 
        return reconnectInterval;
    }
    public boolean hasChannel(String channel) {
        return channels.containsKey(channel);
    }
    public Client newClient(String idprefix, Listener listener, boolean local, CometEvent event) {
        String id = createUUID(idprefix);
        ClientImpl client = new ClientImpl(id, local);
        client.setListener(listener);
        clients.put(id, client);
        return client;
    }
    public Client newClient(String idprefix, Listener listener) {
        assert listener!=null;
        //if this method gets called, someone is using the API inside
        //the JVM, this is a local client
        return newClient(idprefix,listener,true, null);
    }
    
    protected ClientImpl getClientImpl(CometEvent event) {
        return (ClientImpl)event.getHttpServletRequest().getAttribute(ClientImpl.COMET_EVENT_ATTR);
    }
    
    protected void remove(CometEvent event) {
        ClientImpl client = getClientImpl(event);
        if (client!=null) {
            client.removeCometEvent(event);
        }
    }
    public String createUUID(String idprefix) {
        if (idprefix==null) idprefix="";
        return idprefix + Arrays.toString(UUIDGenerator.randomUUID(false));
    }
    
    public List<Channel> getChannels() {
        return java.util.Arrays.asList(channels.entrySet().toArray(new Channel[0]));
    }
    protected Message newMessage() {
        String id = createUUID("msg-");
        return new MessageImpl(id);
    }
    public Message newMessage(Client from) {
        MessageImpl msg = (MessageImpl)newMessage();
        msg.setClient(from);
        return msg;
    }
    public void setSecurityPolicy(SecurityPolicy securityPolicy) {
        this.securityPolicy = securityPolicy;
    }
    public void setReconnectInterval(int reconnectTimeout) {
        this.reconnectInterval = reconnectTimeout;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_CONNECT);
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaConnectRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
        if (clientId!=null && getTomcatBayeux().hasClient(clientId)) {
            event.getHttpServletRequest().setAttribute("client",getTomcatBayeux().getClient(clientId));
        }
    }
    /**
     * Check client request for validity.
     *
     * Per section 4.2.1 of the Bayuex spec a connect request must contain:
     *  1) The "/meta/connect" channel identifier.
     *  2) The clientId returned by the server after handshake.
     *  3) The desired connectionType (must be one of the server's supported
     *     types returned by handshake response.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(clientId==null|| (!getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        if (! (Bayeux.TRANSPORT_LONG_POLL.equals(conType) || Bayeux.TRANSPORT_CALLBACK_POLL.equals(conType)))
            return new HttpError(400,"Unsupported connection type.",null);
        return null;//no error
    }
    /**
     * Transition to connected state, flushing pending messages if
     * available.  If there are pending subscriptions and no messages to
     * flush then the connection is held until there is a pending publish
     * event to be delivered to this client (Section 4.2.2 of spec).
     */
    public int process(int prevops) throws BayeuxException {
        super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = (ClientImpl)getTomcatBayeux().getClient(clientId);
        boolean success = false;
        HttpError error = validate();
        if (error == null) {
            client.setDesirectConnType(desiredConnTypeFlag);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.RETRY_RESPONSE);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.INTERVAL_FIELD, getReconnectInterval());
            success = true;
        }else {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.HANDSHAKE_RESPONSE);
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        response.put(Bayeux.TIMESTAMP_FIELD,getTimeStamp());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        
        //return immediately if there is no subscriptions
        //so that we can process the next message
        int result = client.isSubscribed()?1:0; 
        if (success && client!=null && client.hasMessages()) {
            //send out messages 
            flushMessages(client);
            result = 0; //flush out the messages
        }
        return result;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_DISCONNECT);
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaDisconnectRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
    }
    /**
     * Check client request for validity.
     *
     * Per section 4.4.1 of the Bayuex spec a connect request must contain:
     *  1) The "/meta/disconnect" channel identifier.
     *  2) The clientId.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(clientId==null|| (!this.getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        return null;//no error
    }
    /**
     * Disconnect a client session.
     */
    public int process(int prevops) throws BayeuxException {
        super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = (ClientImpl)getTomcatBayeux().getClient(clientId);
        HttpError error = validate();
        if (error == null) {
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "retry");
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("interval", getReconnectInterval());
        }else {
            getTomcatBayeux().remove(client);
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "none");
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        return 0;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_HANDSHAKE);
        responseTemplate.put(Bayeux.VERSION_FIELD,"1.0");
        responseTemplate.put(Bayeux.SUPP_CONNECTION_TYPE_FIELD,new String[] { Bayeux.TRANSPORT_LONG_POLL, Bayeux.TRANSPORT_CALLBACK_POLL });
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaHandshakeRequest(TomcatBayeux tomcatBayeux, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tomcatBayeux, event, jsReq);
    }
    
    public String getVersion() { return version; }
    public String getMinimumVersion() { return minVersion; }
    /**
     * Check client request for validity.
     *
     * Per section 4.1.1 of the Bayuex spec a handshake request must contain:
     *  1) The "/meta/handshake" channel identifier.
     *  2) The version of the protocol supported by the client
     *  3) The client's supported connection types.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        boolean error = (version==null || version.length()==0);
        if (!error) error = suppConnTypesFlag==0;
        if (error) return new HttpError(400,"Invalid handshake request, supportedConnectionType field missing.",null);
        else return null;
    }
    /**
     * Generate and return a client identifier.  Return a list of
     * supported connection types.  Must be a subset of or identical to
     * the list of types supported by the client.  See section 4.1.2 of
     * the Bayuex specification.
     */
    public int process(int prevops) throws BayeuxException {
        super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = null;
        HttpError error = validate();
        if (error == null) {
            client = (ClientImpl) getTomcatBayeux().newClient("http-", null, false,getEvent());
            clientId = client.getId();
            client.setSupportedConnTypes(suppConnTypesFlag);
            client.setUseJsonFiltered(getExt().get(Bayeux.JSON_COMMENT_FILTERED_FIELD) != null);
            response.put(Bayeux.CLIENT_FIELD, client.getId());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.RETRY_RESPONSE);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.INTERVAL_FIELD, getReconnectInterval());
        }else {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            client = TomcatBayeux.getErrorClient();
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.NONE_RESPONSE);
        }
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        return 0;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_SUBSCRIBE);
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaSubscribeRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
    }
    /**
     * Check client request for validity.
     *
     * Per section 4.5.1 of the Bayuex spec a connect request must contain:
     *  1) The "/meta/subscribe" channel identifier.
     *  2) The clientId.
     *  3) The subscription.  This is the name of the channel of interest,
     *     or a pattern.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(clientId==null|| (!this.getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        if (subscription==null||subscription.length()==0)
            return new HttpError(400,"Subscription missing.",null);
        return null;//no error
    }
    /**
     * Register interest for one or more channels.  Per section 2.2.1 of the
     * Bayeux spec, a pattern may be specified.  Assign client to matching
     * channels and inverse client to channel reference.
     */
    public int process(int prevops) throws BayeuxException {
        super.process(prevops);
        response = (HashMap<String, Object>)this.responseTemplate.clone();
        ClientImpl client = (ClientImpl)getTomcatBayeux().getClient(clientId);
        HttpError error = validate();
        if (error == null) {
            boolean wildcard = subscription.indexOf('*')!=-1;
            boolean subscribed = false;
            if (wildcard) {
                List<Channel> channels = getTomcatBayeux().getChannels();
                Iterator<Channel> it = channels.iterator();
                while (it.hasNext()) {
                    ChannelImpl ch = (ChannelImpl)it.next();
                    if (ch.matches(subscription)) {
                        ch.subscribe(client);
                        subscribed = true;
                    }
                }
            }else {
                ChannelImpl ch = (ChannelImpl)getTomcatBayeux().getChannel(subscription,true);
                ch.subscribe(client);
                subscribed = true;
            }
            response.put(Bayeux.SUCCESSFUL_FIELD, Boolean.valueOf(subscribed));
            response.put(Bayeux.SUBSCRIPTION_FIELD,subscription);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "retry");
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("interval", getReconnectInterval());
        }else {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "handshake");
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        response.put(Bayeux.TIMESTAMP_FIELD,getTimeStamp());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        return 0;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_UNSUBSCRIBE);
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaUnsubscribeRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
    }
    /**
     * Check client request for validity.
     *
     * Per section 4.6.1 of the Bayuex spec a connect request must contain:
     *  1) The "/meta/unsubscribe" channel identifier.
     *  2) The clientId.
     *  3) The subscription.  This is the name of the channel of interest,
     *     or a pattern.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(clientId==null|| (!this.getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        if (subscription==null||subscription.length()==0)
            return new HttpError(400,"Subscription missing.",null);
        return null;//no error
    }
    /**
     * De-register interest for one or more channels.  Per section 2.2.1 of the
     * Bayeux spec, a pattern may be specified.  Sever relationships.
     */
    public int process(int prevops) throws BayeuxException {
        super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = (ClientImpl)getTomcatBayeux().getClient(clientId);
        HttpError error = validate();
        if (error == null) {
            boolean wildcard = subscription.indexOf('*')!=-1;
            boolean unsubscribed = false;
            if (wildcard) {
                List<Channel> channels = getTomcatBayeux().getChannels();
                Iterator<Channel> it = channels.iterator();
                while (it.hasNext()) {
                    ChannelImpl ch = (ChannelImpl)it.next();
                    if (ch.matches(subscription)) {
                        ch.unsubscribe(client);
                        unsubscribed = true;
                    }
                }
            }else {
                ChannelImpl ch = (ChannelImpl)getTomcatBayeux().getChannel(subscription,true);
                ch.unsubscribe(client);
                unsubscribed = true;
            }
            response.put(Bayeux.SUCCESSFUL_FIELD, Boolean.valueOf(unsubscribed));
            response.put(Bayeux.SUBSCRIPTION_FIELD,subscription);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "retry");
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("interval", getReconnectInterval());
        }else {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "handshake");
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        response.put(Bayeux.TIMESTAMP_FIELD,getTimeStamp());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        return 0;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    JSONObject msgData = null;
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public PublishRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
    }
    /**
     * Check client request for validity.
     *
     * Per section 5.1.1 of the Bayuex spec a connect request must contain:
     *  1) The channel identifier of the channel for publication.
     *  2) The data to send.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(channel==null|| (!this.getTomcatBayeux().hasChannel(channel)))
            return new HttpError(400,"Channel Id not valid.", null);
        if(data==null || data.length()==0)
            return new HttpError(400,"Message data missing.", null);
        try {
            this.msgData = new JSONObject(data);
        }catch (JSONException x) {
            return new HttpError(400,"Invalid JSON object in data attribute.",x);
        }
        if(clientId==null|| (!this.getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        return null;//no error
    }
    /**
     *  Send the event message to all registered subscribers.
     */
    public int process(int prevops) throws BayeuxException {
        super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = clientId!=null?(ClientImpl)getTomcatBayeux().getClient(clientId):
                                           (ClientImpl)event.getHttpServletRequest().getAttribute("client");
        boolean success = false;
        HttpError error = validate();
        if (error == null) {
            ChannelImpl chimpl = (ChannelImpl)getTomcatBayeux().getChannel(channel,false);
            MessageImpl mimpl = (MessageImpl)getTomcatBayeux().newMessage(client);
            
            try {
                String[] keys = JSONObject.getNames(msgData);
                for (int i = 0; i < keys.length; i++) {
                    mimpl.put(keys[i], msgData.get(keys[i]));
                }
                success = true;
                ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.RETRY_RESPONSE);
                ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.INTERVAL_FIELD, getReconnectInterval());
            }catch (JSONException x) {
                if (log.isErrorEnabled()) log.error("Unable to parse:"+msgData,x);
                throw new BayeuxException(x);
            }
            chimpl.publish(mimpl);
        }
        if(!success) {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.HANDSHAKE_RESPONSE);
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CHANNEL_FIELD,channel);
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        
        if (success && client!=null && client.hasMessages()) {
            //send out messages 
            flushMessages(client);
        }
        return 0;
    }
        ServletContextAttributeListener, Listener {
    static AtomicInteger counter = new AtomicInteger(0);
    protected int id;
    protected Bayeux b;
    protected Client c;
    protected boolean alive = true;
    protected boolean initialized = false;
    protected TickerThread tt = new TickerThread();
    public BayeuxStockTicker() {
        id = counter.incrementAndGet();
        System.out.println("new listener created with id:" + id);
    }
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        alive = false;
        tt.run = false;
        tt.interrupt();
    }
    public void contextInitialized(ServletContextEvent servletContextEvent) {
    }
    public void attributeAdded(ServletContextAttributeEvent scae) {
        if (scae.getName().equals(Bayeux.DOJOX_COMETD_BAYEUX)) {
            if (initialized) return;
            initialized = true;
            System.out.println("Starting stock ticker server client!");
            b = (Bayeux) scae.getValue();
            c = b.newClient("stock-ticker-", this);
            tt.start();
        }
    }
    public void attributeRemoved(ServletContextAttributeEvent scae) {
        if (scae.getName().equals(Bayeux.DOJOX_COMETD_BAYEUX)) {
            initialized = false;
            b = (Bayeux) scae.getValue();
            List<Channel> chs = b.getChannels();
            for (Channel ch : chs) {
                ch.unsubscribe(c);
            }
        }
    }
    public void attributeReplaced(
            ServletContextAttributeEvent servletContextAttributeEvent) {
    }
    public void removed(boolean timeout) {
        System.out.println("Client removed.");
    }
    public void deliver(Message[] msgs) {
        for (int i = 0; msgs != null && i < msgs.length; i++) {
            Message msg = msgs[i];
            System.out.println("[stock ticker server client ]received message:" + msg);
        }
    }
    public class TickerThread extends Thread {
        public boolean run = true;
        public TickerThread() {
            setName("Ticker Thread");
        }
        public void run() {
            try {
                
                Stock[] stocks = new Stock[] { 
                        new Stock("GOOG", 435.43),
                        new Stock("YHOO", 27.88), 
                        new Stock("SPRG", 1015.55), };
                for (Stock s : stocks) {
                    Channel ch = b.getChannel("/stock/"+s.getSymbol(), true);
                    ch.subscribe(c);
                    
                }
                Random r = new Random(System.currentTimeMillis());
                while (run) {
                    for (int j = 0; j < 1; j++) {
                        int i = r.nextInt() % 3;
                        if (i < 0)
                            i = i * (-1);
                        Stock stock = stocks[i];
                        double change = r.nextDouble();
                        boolean plus = r.nextBoolean();
                        if (plus) {
                            stock.setValue(stock.getValue() + change);
                        } else {
                            stock.setValue(stock.getValue() - change);
                        }
                        Channel ch = b.getChannel("/stock/"+stock.getSymbol(), true);
                        Message m = b.newMessage(c);
                        m.put("stock", stock.toString());
                        m.put("symbol", stock.getSymbol());
                        m.put("price", stock.getValueAsString());
                        m.put("change", stock.getLastChangeAsString());
                        ch.publish(m);
                        System.out.println("Stock: "+stock.getSymbol()+" Price: "+stock.getValueAsString()+" Change: "+stock.getLastChangeAsString());
                    }
                    Thread.sleep(850);
                }
            } catch (InterruptedException ix) {
            } catch (Exception x) {
                x.printStackTrace();
            }
        }
    }
    public static class Stock {
        protected static DecimalFormat df = new DecimalFormat("0.00");
        protected String symbol = "";
        protected double value = 0.0d;
        protected double lastchange = 0.0d;
        protected int cnt = 0;
        public Stock(String symbol, double initvalue) {
            this.symbol = symbol;
            this.value = initvalue;
        }
        public void setCnt(int c) {
            this.cnt = c;
        }
        public int getCnt() {
            return cnt;
        }
        public String getSymbol() {
            return symbol;
        }
        public double getValue() {
            return value;
        }
        public void setValue(double value) {
            double old = this.value;
            this.value = value;
            this.lastchange = value - old;
        }
        public String getValueAsString() {
            return df.format(value);
        }
        public double getLastChange() {
            return this.lastchange;
        }
        public void setLastChange(double lastchange) {
            this.lastchange = lastchange;
        }
        public String getLastChangeAsString() {
            return df.format(lastchange);
        }
        public int hashCode() {
            return symbol.hashCode();
        }
        public boolean equals(Object other) {
            if (other instanceof Stock) {
                return this.symbol.equals(((Stock) other).symbol);
            } else {
                return false;
            }
        }
        
        public String toString(){
            StringBuffer buf = new StringBuffer("STOCK#");
            buf.append(getSymbol());
            buf.append("#");
            buf.append(getValueAsString());
            buf.append("#");
            buf.append(getLastChangeAsString());
            buf.append("#");
            buf.append(String.valueOf(getCnt()));
            return buf.toString();
         
        }
        public Object clone() {
            Stock s = new Stock(this.getSymbol(), this.getValue());
            s.setLastChange(this.getLastChange());
            s.setCnt(this.cnt);
            return s;
        }
    }
    
    static AtomicInteger counter = new AtomicInteger(0);
    protected int id;
    protected Bayeux b;
    protected Client c;
    protected boolean alive = true;
    protected TimestampThread tt = new TimestampThread();
    public EchoChatClient() {
        id = counter.incrementAndGet();
        System.out.println("new listener created with id:"+id);
    }
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        alive = false;
        tt.interrupt();
    }
    public void contextInitialized(ServletContextEvent servletContextEvent) {
    }
    public void attributeAdded(ServletContextAttributeEvent scae) {
        if (scae.getName().equals(Bayeux.DOJOX_COMETD_BAYEUX)) {
            System.out.println("Starting echo chat client!");
            b = (Bayeux)scae.getValue();
            c = b.newClient("echochat-",this);
            Channel ch = b.getChannel("/chat/demo",true);
            ch.subscribe(c);
            tt.start();
        }
    }
    public void attributeRemoved(ServletContextAttributeEvent servletContextAttributeEvent) {
    }
    public void attributeReplaced(ServletContextAttributeEvent servletContextAttributeEvent) {
    }
    public void removed(boolean timeout) {
        System.out.println("Client removed.");
    }
    public void deliver(Message[] msgs) {
        for (int i=0; msgs!=null && i<msgs.length; i++) {
            Message msg = msgs[i];
            System.out.println("[echochatclient ]received message:" + msg);
            Message m = b.newMessage(c);
            m.putAll(msg);
            //echo the same message
            m.put("user", "echochatserver");
            if (m.containsKey("msg")) {
                //simple chat demo
                String chat = (String) m.get("msg");
                m.put("msg", "echochatserver|I received your message-" + chat.substring(chat.indexOf("|") + 1));
            }
            System.out.println("[echochatclient ]sending message:" + m);
            msg.getChannel().publish(m);
        }
    }
    public class TimestampThread extends Thread {
        public TimestampThread() {
            setDaemon(true);
        }
        
        public void run() {
            while (alive) {
                try {
                    sleep(5000);
                    Channel ch = b.getChannel("/chat/demo",false);
                    if (ch.getSubscribers().size()<=1) {
                        continue;
                    }
                    Message m = b.newMessage(c);
                    m.put("user","echochatserver");
                    m.put("chat","Time is:"+new java.sql.Date(System.currentTimeMillis()).toLocaleString());
                    m.put("join",false);
                    ch.publish(m);
                }catch (InterruptedException ignore) {
                    Thread.currentThread().interrupted();
                }catch (Exception x) {
                    x.printStackTrace();
                }
            }
        }
    }
   xmlns="http://java.sun.com/xml/ns/javaee" 
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
   version="2.5"> 
  <display-name>Cometd Test WebApp</display-name>
  
  <servlet>
    <servlet-name>cometd</servlet-name>
    <servlet-class>org.apache.tomcat.bayeux.BayeuxServlet</servlet-class>
    <init-param>
      <param-name>timeout</param-name>
      <param-value>120000000</param-value>
    </init-param>
    <init-param>
      <param-name>reconnectInterval</param-name>
      <param-value>250</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>cometd</servlet-name>
    <url-pattern>/cometd/*</url-pattern>
  </servlet-mapping>
  
  <listener>
    <listener-class>org.apache.cometd.bayeux.samples.EchoChatClient</listener-class>
  </listener>
  <listener>
    <listener-class>org.apache.cometd.bayeux.samples.BayeuxStockTicker</listener-class>
  </listener>
  
  dojox.cometd.init("/cometd/cometd");
  dojox.cometd.startBatch();
  dojox.cometd.subscribe("/stock/GOOG", onMsgEvent);
  dojox.cometd.subscribe("/stock/YHOO", onMsgEvent);
  dojox.cometd.subscribe("/stock/SPRG", onMsgEvent);
  dojox.cometd.endBatch();
   if(node == undefined || node == null)
   {
      return;
   }
   var len = node.childNodes.length;
   // Break apart the text string into screen name and message parts.
   var symbol = event.data.symbol;
   var price = event.data.price;
   var pricechange = event.data.change;
   //alert("symbol: "+symbol+" price: "+price+" change: "+pricechange);
   var pricenode = dojo.byId("price."+symbol);
   var changenode = dojo.byId("change."+symbol);
   removeChildrenFromNode(pricenode);
   removeChildrenFromNode(changenode);
   var pricelabel = document.createTextNode(price);
   pricelabel.value = price;
   var changelabel = document.createTextNode(pricechange);
   changelabel.value = pricechange;
   pricenode.appendChild(pricelabel);
   changenode.appendChild(changelabel);
   var table = dojo.byId("stocktable");  
   var rows = table.getElementsByTagName("tr");  
   for(i = 0; i < rows.length; i++){
   }          
   //manipulate rows 
   var rowCurrent = dojo.byId("row."+symbol);
   if (pricechange<=0) {
       rowCurrent.bgColor = "red";
   } else {
   }
  <tr id="row.HEADER">
    <td>SYMBOL</td>
    <td>PRICE</td>
    <td>LAST CHANGE</td>
    <td>SUBSCRIBE</td></tr>
  <tr id="row.SPRG">
    <td>SPRG</td>
    <td id="price.SPRG"></td>
    <td id="change.SPRG"></td>
    <td id="check.SPRG"><input type="checkbox" id="check.SPRG" checked onClick="subscribe(this,'SPRG')"></td>
  </tr>
  <tr id="row.GOOG">
    <td>GOOG</td>
    <td id="price.GOOG"></td>
    <td id="change.GOOG"></td>
    <td id="check.GOOG"><input type="checkbox" id="check.GOOG" checked  onClick="subscribe(this,'GOOG')"></td>
  </tr>
  <tr id="row.YHOO">
    <td>YHOO</td>
    <td id="price.YHOO"></td>
    <td id="change.YHOO"></td>
    <td id="check.YHOO"><input type="checkbox" id="check.GOOG" checked  onClick="subscribe(this,'YHOO')"></td>
  </tr>
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Interceptor that keep track of connection state to avoid roundtrips to the database
 * @author fhanik
 *
 */
    protected static Log log = LogFactory.getLog(ConnectionState.class);
    
    protected final String[] readState = {"getAutoCommit","getTransactionIsolation","isReadOnly","getCatalog"};
    protected final String[] writeState = {"setAutoCommit","setTransactionIsolation","setReadOnly","setCatalog"};
    protected Boolean autoCommit = null;
    protected Integer transactionIsolation = null;
    protected Boolean readOnly = null;
    protected String catalog = null;
    
    
    public void reset(ConnectionPool parent, PooledConnection con) {
        PoolProperties poolProperties = parent.getPoolProperties();
        if (poolProperties.getDefaultReadOnly()!=null) {
            try {
                if (readOnly==null || readOnly.booleanValue()!=poolProperties.getDefaultReadOnly().booleanValue()) {
                    con.getConnection().setReadOnly(poolProperties.getDefaultReadOnly().booleanValue());
                    readOnly = poolProperties.getDefaultReadOnly();
                }
            }catch (SQLException x) {
                readOnly = null;
                log.error("Unable to reset readonly state to connection.",x);
            }
        }
        if (poolProperties.getDefaultAutoCommit()!=null) {
            try {
                if (autoCommit==null || autoCommit.booleanValue()!=poolProperties.getDefaultAutoCommit().booleanValue()) {
                    con.getConnection().setAutoCommit(poolProperties.getDefaultAutoCommit().booleanValue());
                    autoCommit = poolProperties.getDefaultAutoCommit();
                }
            }catch (SQLException x) {
                autoCommit = null;
                log.error("Unable to reset autocommit state to connection.",x);
            }
        }
        if (poolProperties.getDefaultCatalog()!=null) {
            try {
                if (catalog==null || (!catalog.equals(poolProperties.getDefaultCatalog()))) {
                    con.getConnection().setCatalog(poolProperties.getDefaultCatalog());
                    catalog = poolProperties.getDefaultCatalog();
                }
            }catch (SQLException x) {
                catalog = null;
                log.error("Unable to reset default catalog state to connection.",x);
            }
        }
        if (poolProperties.getDefaultTransactionIsolation()!=DataSourceFactory.UNKNOWN_TRANSACTIONISOLATION) {
            try {
                if (transactionIsolation==null || transactionIsolation.intValue()!=poolProperties.getDefaultTransactionIsolation()) {
                    con.getConnection().setTransactionIsolation(poolProperties.getDefaultTransactionIsolation());
                    transactionIsolation = poolProperties.getDefaultTransactionIsolation();
                }
            }catch (SQLException x) {
                transactionIsolation = null;
                log.error("Unable to reset transaction isolation state to connection.",x);
            }
        }
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        String name = method.getName();
        boolean read = false;
        int index = -1;
        for (int i=0; (!read) && i<readState.length; i++) {
            read = compare(name,readState[i]);
            if (read) index = i;
        }
        boolean write = false;
        for (int i=0; (!write) && (!read) && i<writeState.length; i++) {
            write = compare(name,writeState[i]);
            if (write) index = i;
        }
        Object result = null;
        if (read) {
            switch (index) {
                case 0:{result = autoCommit; break;}
                case 1:{result = transactionIsolation; break;}
                case 2:{result = readOnly; break;}
                case 3:{result = catalog; break;}
                default: result = null;
            }
            //return cached result, if we have it
            if (result!=null) return result;
        }
        result = super.invoke(proxy, method, args);
        if (read || write) {
            switch (index) {
                case 0:{autoCommit = (Boolean) (read?result:args[0]); break;}
                case 1:{transactionIsolation = (Integer)(read?result:args[0]); break;}
                case 2:{readOnly = (Boolean)(read?result:args[0]); break;}
                case 3:{catalog = (String)(read?result:args[0]); break;}
            }
        }
        return result;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * @author Filip Hanik
 * @version 1.0
 */
    protected final String[] statements = {"createStatement","prepareStatement","prepareCall"};
    protected final String[] executes = {"execute","executeQuery","executeUpdate","executeBatch"};
    protected static IdentityHashMap<ConnectionPool,HashMap<String,QueryStats>> perPoolStats = 
        new IdentityHashMap<ConnectionPool,HashMap<String,QueryStats>>();
    
    protected HashMap<String,QueryStats> queries = null;
    
    protected long threshold = 100; //don't report queries less than this
    protected int  maxQueries= 1000; //don't store more than this amount of queries
    
    
    public SlowQueryReport() {
        super();
    }
    public long getThreshold() {
        return threshold;
    }
    public void setThreshold(long threshold) {
        this.threshold = threshold;
    }
    @Override
    public void closeInvoked() {
        // TODO Auto-generated method stub
        
    }
    @Override
    public Object createStatement(Object proxy, Method method, Object[] args, Object statement) {
        // TODO Auto-generated method stub
        String sql = null;
        if (method.getName().startsWith("prepare")) {
            sql = (args.length>0 && (args[0] instanceof String))?(String)args[0]:null;
        }
        return new StatementProxy(statement,sql);
    }
    protected boolean process(final String[] names, Method method, boolean process) {
        for (int i=0; (!process) && i<names.length; i++) {
            process = compare(method.getName(),names[i]);
        }
        return process;
    }
    protected class QueryStats {
        private final String query;
        private int nrOfInvocations;
        private long maxInvocationTime;
        private long maxInvocationDate;
        private long minInvocationTime;
        private long minInvocationDate;
        private long totalInvocationTime;
        
        public QueryStats(String query) {
            this.query = query;
        }
        
        public void add(long invocationTime) {
            long now = -1;
            //not thread safe, but don't sacrifice performance for this kind of stuff
            maxInvocationTime = Math.max(invocationTime, maxInvocationTime);
            if (maxInvocationTime == invocationTime) {
                now = System.currentTimeMillis();
                maxInvocationDate = now;
            }
            minInvocationTime = Math.min(invocationTime, minInvocationTime);
            if (minInvocationTime==invocationTime) {
                now = (now==-1)?System.currentTimeMillis():now;
                minInvocationDate = now;
            }
            nrOfInvocations++;
            totalInvocationTime+=invocationTime;
        }
        
        public String getQuery() {
            return query;
        }
        public int getNrOfInvocations() {
            return nrOfInvocations;
        }
        public long getMaxInvocationTime() {
            return maxInvocationTime;
        }
        public long getMaxInvocationDate() {
            return maxInvocationDate;
        }
        public long getMinInvocationTime() {
            return minInvocationTime;
        }
        public long getMinInvocationDate() {
            return minInvocationDate;
        }
        public long getTotalInvocationTime() {
            return totalInvocationTime;
        }
        public int hashCode() {
            return query.hashCode();
        }
        
        public boolean equals(Object other) {
            if (other instanceof QueryStats) {
                QueryStats qs = (QueryStats)other;
                return SlowQueryReport.this.compare(qs.query,this.query);
            } 
            return false;
        }
    }
    
    protected class StatementProxy implements InvocationHandler {
        protected boolean closed = false;
        protected Object delegate;
        protected final String query;
        public StatementProxy(Object parent, String query) {
            this.delegate = parent;
            this.query = query;
        }
        
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            final String name = method.getName();
            boolean close = compare(JdbcInterceptor.CLOSE_VAL,name);
            if (close && closed) return null; //allow close to be called multiple times
            if (closed) throw new SQLException("Statement closed.");
            boolean process = false;
            process = process(executes, method, process);
            long start = (process)?System.currentTimeMillis():0;
            //execute the query
            Object result =  method.invoke(delegate,args);
            long delta = (process)?(System.currentTimeMillis()-start):0;
            if (delta>threshold) {
                String sql = null;//TODO
                QueryStats qs = SlowQueryReport.this.queries.get(sql);
                if (qs == null) {
                    qs = new QueryStats(sql);
                    SlowQueryReport.this.queries.put((String)sql,qs);
                }
                qs.add(delta);
                return qs;
            }
            if (close) {
                closed=true;
                delegate = null;
            }
            return result;
        }
    }
    public void reset(ConnectionPool parent, PooledConnection con) {
        if (queries==null && SlowQueryReport.perPoolStats.get(parent)==null) {
            queries = new LinkedHashMap<String,QueryStats>() {
                @Override
                protected boolean removeEldestEntry(Entry<String, QueryStats> eldest) {
                    return size()>maxQueries;
                }
            };
        }
    }
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/
   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
   1. Definitions.
      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.
      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.
      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.
      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.
      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.
      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.
      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).
      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.
      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."
      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.
   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.
   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.
   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:
      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and
      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and
      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and
      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.
      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.
   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.
   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.
   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.
   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.
   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.
   END OF TERMS AND CONDITIONS
   APPENDIX: How to apply the Apache License to your work.
      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.
   Copyright [yyyy] [name of copyright owner]
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" 8d5db6f^:"java/javax/el/CompositeELResolver.java"

        private Iterator itr;
======= fetch "public boolean isReadOnly(ELContext context, Object base, Object property)" 8d5db6f^:"java/javax/el/CompositeELResolver.java"

        private FeatureDescriptor next;
======= fetch "private void guaranteeIterator() {" 8d5db6f^:"java/javax/el/CompositeELResolver.java"

        public boolean hasNext() {
            return this.itr != null;
======= fetch "public FeatureDescriptor next() {" 8d5db6f^:"java/javax/el/CompositeELResolver.java"

            Object result = null;
            if (this.itr != null) {
                if (this.itr.hasNext()) {
                    result = this.itr.next();
                    if (!this.itr.hasNext()) {
                        this.itr = null;
                        this.guaranteeIterator();
                    }
                }
            }
            return (FeatureDescriptor) result;

======= fetch "public void compile(boolean compileClass, boolean jspcMode)" b5a5094^:"java/org/apache/jasper/compiler/Compiler.java"

            if (tfp != null) {

    implements NotificationListener 
======= fetch "public void handleNotification(Notification notification," 23a8ba0^:"java/org/apache/catalina/connector/MapperListener.java"

    // --------------------------------------------- Container Listener methods
    public void containerEvent(ContainerEvent event) {
        if (event.getType() == Host.ADD_ALIAS_EVENT) {
            mapper.addHostAlias(((Host) event.getSource()).getName(),
                    event.getData().toString());
        } else if (event.getType() == Host.REMOVE_ALIAS_EVENT) {
            mapper.removeHostAlias(event.getData().toString());
        }
    }
    
======= fetch "private void registerEngine()" 23a8ba0^:"java/org/apache/catalina/connector/MapperListener.java"

        // This should probablt be called later 
======= fetch "private void registerHost(ObjectName objectName)" 23a8ba0^:"java/org/apache/catalina/connector/MapperListener.java"

            String[] aliases = (String[])
                mBeanServer.invoke(objectName, "findAliases", null, null);
======= fetch "private void registerHost(ObjectName objectName)" 23a8ba0^:"java/org/apache/catalina/connector/MapperListener.java"

            host.addContainerListener(this);
======= fetch "private void registerHost(ObjectName objectName)" 23a8ba0^:"java/org/apache/catalina/connector/MapperListener.java"

======= fetch "private void unregisterHost(ObjectName objectName)" 23a8ba0^:"java/org/apache/catalina/connector/MapperListener.java"

        mapper.removeHost(name);
        if(log.isDebugEnabled())
            log.debug(sm.getString
                 ("mapperListener.unregisterHost", name, domain));
======= fetch "public synchronized void removeHost(String name) {" 23a8ba0^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

    /**
     * Add an alias to an existing host.
     * @param name  The name of the host
     * @param alias The alias to add
     */
    public synchronized void addHostAlias(String name, String alias) {
        int pos = find(hosts, name);
        if (pos < 0) {
            // Should not be adding an alias for a host that doesn't exist but
            // just in case...
            return;
        }
        Host realHost = hosts[pos];
        
        Host[] newHosts = new Host[hosts.length + 1];
        Host newHost = new Host();
        newHost.name = alias;
        newHost.contextList = realHost.contextList;
        newHost.object = realHost;
        if (insertMap(hosts, newHosts, newHost)) {
            hosts = newHosts;
        }
    }
    /**
     * Remove a host alias
     * @param alias The alias to remove
     */
    public synchronized void removeHostAlias(String alias) {
        // Find and remove the alias
        int pos = find(hosts, alias);
        if (pos < 0) {
            return;
        }
        Host[] newHosts = new Host[hosts.length - 1];
        if (removeMap(hosts, newHosts, alias)) {
            hosts = newHosts;
        }
    }
======= fetch "private static final int findIgnoreCase(MapElement[] map, CharChunk name," 23a8ba0^:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

     * Find a map elemnt given its name in a sorted array of map elements.

======= fetch "protected String getPathWithoutFileName(String servletPath) {" 4d5cca1^:"java/org/apache/catalina/ssi/SSIServletExternalResolver.java"

    protected String getPathWithoutContext(String servletPath) {
        String retVal = null;
        int secondSlash = servletPath.indexOf('/', 1);
        if (secondSlash >= 0) {
            //cut off context
            retVal = servletPath.substring(secondSlash);
======= fetch "protected String getPathWithoutContext(String servletPath) {" 4d5cca1^:"java/org/apache/catalina/ssi/SSIServletExternalResolver.java"

        return retVal;
======= fetch "protected ServletContextAndPath getServletContextAndPathFromVirtualPath(" 4d5cca1^:"java/org/apache/catalina/ssi/SSIServletExternalResolver.java"

                    String noContext = getPathWithoutContext(normalized);

======= fetch "private void internalDoFilter(ServletRequest request," e148369^:"java/org/apache/catalina/core/ApplicationFilterChain.java"

                        ("doFilter", filter, classType, args);
======= fetch "public static void doAsPrivilege(final String methodName," e148369^:"java/org/apache/catalina/security/SecurityUtil.java"

     * Perform work as a particular </code>Subject</code>. Here the work
======= fetch "public static void doAsPrivilege(final String methodName," e148369^:"java/org/apache/catalina/security/SecurityUtil.java"

        doAsPrivilege(
                methodName, targetObject, targetType, targetArguments, null);
    }
    
    /**
     * Perform work as a particular <code>Subject</code>. Here the work
     * will be granted to a <code>null</code> subject. 
     *
     * @param methodName the method to apply the security restriction
     * @param targetObject the <code>Filter</code> on which the method will 
     * be called.
     * @param targetType <code>Class</code> array used to instanciate a
     * <code>Method</code> object.
     * @param targetArguments <code>Object</code> array contains the 
     * runtime parameters instance.
     * @param principal the <code>Principal</code> to which the security 
     * privilege apply
     */    
    public static void doAsPrivilege(final String methodName, 
                                     final Filter targetObject, 
                                     final Class[] targetType,
                                     final Object[] targetArguments,
                                     Principal principal) 
        throws java.lang.Exception{
======= fetch "public static void doAsPrivilege(final String methodName," e148369^:"java/org/apache/catalina/security/SecurityUtil.java"

        execute(method, targetObject, targetArguments, null);

======= fetch "public Compiler getCompiler () {" 38ef38d^:"java/org/apache/jasper/compiler/ParserController.java"

            compiler.getPageInfo().addDependant(absFileName);

======= fetch "protected void status(Request request, Response response) {" e0489c8^:"java/org/apache/catalina/core/StandardHostValve.java"

        Class clazz = exception.getClass();
======= fetch "protected boolean custom(Request request, Response response," e0489c8^:"java/org/apache/catalina/core/StandardHostValve.java"

            // Reset the response if possible (else IllegalStateException)
            //hres.reset();
======= fetch "protected boolean custom(Request request, Response response," e0489c8^:"java/org/apache/catalina/core/StandardHostValve.java"

            Integer statusCodeObj =
                (Integer) request.getAttribute(Globals.STATUS_CODE_ATTR);
            int statusCode = statusCodeObj.intValue();
            String message =
                (String) request.getAttribute(Globals.ERROR_MESSAGE_ATTR);
            response.reset(statusCode, message);

    private static final char[] LINE_SEP = { '\r', '\n' };

======= fetch "protected boolean restoreRequest(Request request, Session session)" d9def07^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

        

======= fetch "public DeferredFileOutputStream(int threshold, File outputFile)" 85e71cf^:"java/org/apache/tomcat/util/http/fileupload/DeferredFileOutputStream.java"

        memoryOutputStream = new ByteArrayOutputStream(threshold);

======= fetch "public StandardSession(Manager manager) {" 6344b96^:"java/org/apache/catalina/session/StandardSession.java"

    protected long lastAccessedTime = creationTime;
======= fetch "public StandardSession(Manager manager) {" 6344b96^:"java/org/apache/catalina/session/StandardSession.java"

    protected long thisAccessedTime = creationTime;

======= fetch "public void destroyInstance(Object instance) throws IllegalAccessException, Invo" 428c03b^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

    protected void postConstruct(Object instance, Class<?> clazz)
======= fetch "protected void postConstruct(Object instance, Class<?> clazz)" 428c03b^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

        Method[] methods = clazz.getDeclaredMethods();
======= fetch "protected void processAnnotations(Object instance, Map<String, String> injection" 428c03b^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

            Field[] fields = clazz.getDeclaredFields();
======= fetch "protected void processAnnotations(Object instance, Map<String, String> injection" 428c03b^:"java/org/apache/catalina/core/DefaultInstanceManager.java"

            Method[] methods = clazz.getDeclaredMethods();

======= fetch "public void setResourceType(String resourceType) {" e40c910^:"java/org/apache/naming/resources/ResourceAttributes.java"

     * @return strong ETag if available, else weak ETag.
======= fetch "public String getETag() {" e40c910^:"java/org/apache/naming/resources/ResourceAttributes.java"

        String result = null;
        if (attributes != null) {
            Attribute attribute = attributes.get(ETAG);
            if (attribute != null) {
                try {
                    result = attribute.get().toString();
                } catch (NamingException e) {
                    ; // No value for the attribute
                }
            }
        }
        if (result == null) {
            if (strongETag != null) {
                // The strong ETag must always be calculated by the resources
                result = strongETag;
            } else {
                // The weakETag is contentLength + lastModified
                if (weakETag == null) {
                    long contentLength = getContentLength();
                    long lastModified = getLastModified();
                    if ((contentLength >= 0) || (lastModified >= 0)) {
                        weakETag = "W/\"" + contentLength + "-" 
                        + lastModified + "\"";
======= fetch "public String getETag() {" e40c910^:"java/org/apache/naming/resources/ResourceAttributes.java"

                result = weakETag;
======= fetch "public String getETag() {" e40c910^:"java/org/apache/naming/resources/ResourceAttributes.java"

            return strongETag;
        } else {
            // The weakETag is contentLenght + lastModified
            if (weakETag == null) {
                weakETag = "W/\"" + getContentLength() + "-" 
                    + getLastModified() + "\"";
            }
            return weakETag;
======= fetch "public String getETag() {" e40c910^:"java/org/apache/naming/resources/ResourceAttributes.java"

        return result;

======= fetch "protected boolean postParseRequest(org.apache.coyote.Request req," e277f6c^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        // XXX the processor needs to set a correct scheme and port prior to this point, 
        // in ajp13 protocols dont make sense to get the port from the connector..

    public static final String SESSION_COOKIE_NAME = "JSESSIONID";
    public static final String SESSION_PARAMETER_NAME = "jsessionid";
    public static final String SINGLE_SIGN_ON_COOKIE = "JSESSIONIDSSO";
    public static final String SESSION_PARAMETER_NAME = "jsessionid";

======= fetch "public synchronized void start() throws LifecycleException {" f69637f^:"java/org/apache/catalina/core/StandardContext.java"

                if(getProcessTlds()) {
                    processTlds();
                }
                
======= fetch "private void addInjectionTarget(Injectable resource, Map<String, Map<String, Str" f69637f^:"java/org/apache/catalina/core/StandardContext.java"

     * Processes TLDs.
     *
     * @throws LifecycleException If an error occurs
     */
     protected void processTlds() throws LifecycleException {
       TldConfig tldConfig = new TldConfig();
       tldConfig.setContext(this);
       // (1)  check if the attribute has been defined
       //      on the context element.
       tldConfig.setTldValidation(tldValidation);
       tldConfig.setTldNamespaceAware(tldNamespaceAware);
       // (2) if the attribute wasn't defined on the context
       //     try the host.
       if (!tldValidation) {
         tldConfig.setTldValidation
           (((StandardHost) getParent()).getXmlValidation());
       }
       if (!tldNamespaceAware) {
         tldConfig.setTldNamespaceAware
           (((StandardHost) getParent()).getXmlNamespaceAware());
       }
                    
       try {
         tldConfig.execute();
       } catch (Exception ex) {
         log.error("Error reading tld listeners " 
                    + ex.toString(), ex); 
       }
     }
    
    /**
======= fetch "public void init() throws Exception {" f69637f^:"java/org/apache/catalina/core/StandardContext.java"

 * Startup event listener for a <b>Context</b> that configures the properties
 * of that Context, and the associated defined servlets.
======= fetch "private void processCache(File tldCache ) throws IOException {" f69637f^:"java/org/apache/catalina/startup/TldConfig.java"

     * Create (if necessary) and return a Digester configured to process a tag
     * library descriptor, looking for additional listener classes to be
     * registered.
     */
    private static Digester createTldDigester() {
        return DigesterFactory.newDigester(tldValidation, 
                                           tldNamespaceAware, 
                                           new TldRuleSet());
    }
    /**
======= fetch "private void tldScanStream(InputSource resourceStream)" f69637f^:"java/org/apache/catalina/startup/TldConfig.java"

        if (tldDigester == null){
            tldDigester = createTldDigester();
        }
        
======= fetch "private void tldScanResourcePathsWebInf(DirContext resources," f69637f^:"java/org/apache/catalina/startup/TldConfig.java"

    public void lifecycleEvent(LifecycleEvent event) {
        // Identify the context we are associated with
        try {
            context = (Context) event.getLifecycle();
        } catch (ClassCastException e) {
            log.error(sm.getString("tldConfig.cce", event.getLifecycle()), e);
            return;
        }
        
        if (event.getType().equals(Lifecycle.INIT_EVENT)) {
            init();
        } else if (event.getType().equals(Lifecycle.START_EVENT)) {
            try {
                execute();
            } catch (Exception e) {
                log.error(sm.getString(
                        "tldConfig.execute", context.getPath()), e);
            }
        } // Ignore the other event types - nothing to do 
    }
    
    private void init() {
        if (tldDigester == null){
            // (1)  check if the attribute has been defined
            //      on the context element.
            setTldValidation(context.getTldValidation());
            setTldNamespaceAware(context.getTldNamespaceAware());
    
            // (2) if the attribute wasn't defined on the context
            //     try the host.
            if (!tldValidation) {
              setTldValidation(
                      ((StandardHost) context.getParent()).getXmlValidation());
            }
    
            if (!tldNamespaceAware) {
              setTldNamespaceAware(
                      ((StandardHost) context.getParent()).getXmlNamespaceAware());
            }
            tldDigester = DigesterFactory.newDigester(tldValidation, 
                    tldNamespaceAware, 
                    new TldRuleSet());
            tldDigester.getParser();
        }
    }

======= fetch "public void start() throws Exception {" c340c69^:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     * The number of messages we have read or written
======= fetch "public boolean writeMessage(FileMessage msg)" c340c69^:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

        if (out != null) {
            out.write(msg.getData(), 0, msg.getDataLength());
            nrOfMessagesProcessed++;
======= fetch "public boolean writeMessage(FileMessage msg)" c340c69^:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

            if (msg.getMessageNumber() == msg.getTotalNrOfMsgs()) {
======= fetch "public boolean writeMessage(FileMessage msg)" c340c69^:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

            }//end if
        } else {
            if (log.isWarnEnabled())
                log.warn("Receive Message again -- Sender ActTimeout to short [ path: "
                                + msg.getContextPath()
                                + " war: "
                                + msg.getFileName()
                                + " data: "
                                + msg.getData()
                                + " data length: " + msg.getDataLength() + " ]");
======= fetch "public boolean writeMessage(FileMessage msg)" c340c69^:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

        
======= fetch "public void cleanup() {" c340c69^:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

        msgBuffer.clear();
        lastMessageProcessed = null;
======= fetch "public File getFile() {" c340c69^:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"


======= fetch "public void appendHead(Response res) throws IOException {" 03097fa^:"java/org/apache/jk/common/JkInputStream.java"

        if (message == null) {
            // mod_jk + httpd 2.x fails with a null status message - bug 45026
            message = Integer.toString(res.getStatus());
        }

    
======= fetch "public void init() throws ServletException {" 633545f^:"java/org/apache/catalina/servlets/DefaultServlet.java"

        if (getServletConfig().getInitParameter("useAcceptRanges") != null)
            useAcceptRanges = Boolean.parseBoolean(getServletConfig().getInitParameter("useAcceptRanges"));
======= fetch "protected void serveResource(HttpServletRequest request," 633545f^:"java/org/apache/catalina/servlets/DefaultServlet.java"

            if (useAcceptRanges) {
                // Accept ranges header
                response.setHeader("Accept-Ranges", "bytes");
            }
======= fetch "protected void serveResource(HttpServletRequest request," 633545f^:"java/org/apache/catalina/servlets/DefaultServlet.java"

  <tr>
    <th valign='top'>useAcceptRanges</th>
    <td valign='top'>
        If true, the Accept-Ranges header will be set when appropriate for the
        response. [true]
    </td>
  </tr>

======= fetch "private void processRequest(ServletRequest request," 2c0fffe^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

                     servletPath);
======= fetch "private void processRequest(ServletRequest request," 2c0fffe^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

    
======= fetch "private void doInclude(ServletRequest request, ServletResponse response)" 2c0fffe^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

                    servletPath);
======= fetch "private void doInclude(ServletRequest request, ServletResponse response)" 2c0fffe^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

                    servletPath);

======= fetch "public void addElement(StringBuffer buf, Date date, Request request," 678b516^:"java/org/apache/catalina/valves/AccessLogValve.java"

            buf.append(request.getHeader(header));

======= fetch "public void finalize() {" d69b378^:"java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java"

        try {selector.close();} catch (Exception ignore) {}

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
        <classpathentry excluding="**/.svn/**|org/apache/naming/factory/webservices/" kind="src" path="java"/>
  <target name="extras" depends="prepare,commons-logging,webservices">

======= fetch "public boolean isFulfilled() {" 3773ec4^:"java/org/apache/catalina/util/ManifestResource.java"

            return false;

======= fetch "public void include(String relativeUrlPath, boolean flush)" ccc1014^:"java/org/apache/jasper/runtime/JspContextWrapper.java"


======= fetch "final public void Function() throws ParseException {" 6d40691^:"java/org/apache/el/parser/ELParser.java"

                        jjtn000.setPrefix(t0.image.substring(0, t0.image.length() - 1));

======= fetch "public void init(JspCompilationContext ctxt, JspServletWrapper jsw) {" 337d6a6^:"java/org/apache/jasper/compiler/Compiler.java"

            // Reset the temporary variable counter for the generator.
            JspUtil.resetTemporaryVariableName();
    private static int tempSequenceNumber = 0;
    
======= fetch "public static void validateExpressions(Mark where," 337d6a6^:"java/org/apache/jasper/compiler/JspUtil.java"

    /**
     * Resets the temporary variable name.
     * (not thread-safe)
     */
    public static void resetTemporaryVariableName() {
        tempSequenceNumber = 0;
    }
    /**
     * Generates a new temporary variable name.
     * (not thread-safe)
     */
    public static String nextTemporaryVariableName() {
        return Constants.TEMP_VARIABLE_NAME_PREFIX + (tempSequenceNumber++);
    }
======= fetch "private void addToParent(Node parent) {" 337d6a6^:"java/org/apache/jasper/compiler/Node.java"

         * Sequence number for temporary variables.
         */
        private int tempSequenceNumber = 0;
        /*
======= fetch "public Root getParentRoot() {" 337d6a6^:"java/org/apache/jasper/compiler/Node.java"

        
        /**
         * Generates a new temporary variable name.
         */
        public String nextTemporaryVariableName() {
            if (parentRoot == null) {
                return Constants.TEMP_VARIABLE_NAME_PREFIX + (tempSequenceNumber++);
            } else {
                return parentRoot.nextTemporaryVariableName();
            }
            
        }
======= fetch "public String getTemporaryVariableName() {" 337d6a6^:"java/org/apache/jasper/compiler/Node.java"

                temporaryVariableName = JspUtil.nextTemporaryVariableName();
======= fetch "public String getTemporaryVariableName() {" 337d6a6^:"java/org/apache/jasper/compiler/TagPluginManager.java"

            return JspUtil.nextTemporaryVariableName();

======= fetch "public String getName() {" 6a1f316^:"java/org/apache/coyote/http11/Http11AprProtocol.java"

    public void setPollerThreadCount(int pollerThreadCount) { endpoint.setPollerThreadCount(pollerThreadCount); }
    public int getPollerThreadCount() { return endpoint.getPollerThreadCount(); }
    
======= fetch "public String getName() {" 6a1f316^:"java/org/apache/coyote/http11/Http11AprProtocol.java"

    public void setSendfileThreadCount(int sendfileThreadCount) { endpoint.setSendfileThreadCount(sendfileThreadCount); }
    public int getSendfileThreadCount() { return endpoint.getSendfileThreadCount(); }
    
     <fix><bug>45074</bug>Add configuration parameters in Http11AprProtocol</fix>

======= fetch "public void lifecycleEvent(LifecycleEvent event) {" 46055c5^:"java/org/apache/catalina/core/AprLifecycleListener.java"

                        log.debug(sm.getString("aprListener.sslInit"));

======= fetch "public void init()" fea7658^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        serverSock = Socket.create(family, Socket.SOCK_STREAM,

======= fetch "public Object run() {" b266836^:"java/org/apache/juli/ClassLoaderLogManager.java"

                    info = (ClassLoaderLogInfo) classLoaderLoggers.get(current);
======= fetch "public Object run() {" b266836^:"java/org/apache/juli/ClassLoaderLogManager.java"

                        handler = (Handler) info.handlers.get(handlerName);
======= fetch "public synchronized Logger getLogger(final String name) {" b266836^:"java/org/apache/juli/ClassLoaderLogManager.java"

        return (Logger) getClassLoaderInfo(classLoader).loggers.get(name);
======= fetch "public String getProperty(String name) {" b266836^:"java/org/apache/juli/ClassLoaderLogManager.java"

        String prefix = (String) this.prefix.get();
======= fetch "public String getProperty(String name) {" b266836^:"java/org/apache/juli/ClassLoaderLogManager.java"

                info = (ClassLoaderLogInfo) classLoaderLoggers.get(current);
======= fetch "protected ClassLoaderLogInfo getClassLoaderInfo(ClassLoader classLoader) {" b266836^:"java/org/apache/juli/ClassLoaderLogManager.java"

        ClassLoaderLogInfo info = (ClassLoaderLogInfo) classLoaderLoggers
                .get(classLoader);
======= fetch "public Object run() {" b266836^:"java/org/apache/juli/ClassLoaderLogManager.java"

            info = (ClassLoaderLogInfo) classLoaderLoggers.get(classLoader);
======= fetch "protected void readConfiguration(InputStream is, ClassLoader classLoader)" b266836^:"java/org/apache/juli/ClassLoaderLogManager.java"

        ClassLoaderLogInfo info = 
            (ClassLoaderLogInfo) classLoaderLoggers.get(classLoader);
======= fetch "LogNode findNode(String name) {" b266836^:"java/org/apache/juli/ClassLoaderLogManager.java"

                LogNode childNode = (LogNode) currentNode.children
                        .get(nextName);

======= fetch "public StandardWrapper() {" 816ecb8^:"java/org/apache/catalina/core/StandardWrapper.java"

    protected int countAllocated = 0;
======= fetch "public int getCountAllocated() {" 816ecb8^:"java/org/apache/catalina/core/StandardWrapper.java"

        return (this.countAllocated);
======= fetch "public Servlet allocate() throws ServletException {" 816ecb8^:"java/org/apache/catalina/core/StandardWrapper.java"

                                countAllocated++;
======= fetch "public Servlet allocate() throws ServletException {" 816ecb8^:"java/org/apache/catalina/core/StandardWrapper.java"

                    countAllocated++;
======= fetch "public Servlet allocate() throws ServletException {" 816ecb8^:"java/org/apache/catalina/core/StandardWrapper.java"

            while (countAllocated >= nInstances) {
======= fetch "public Servlet allocate() throws ServletException {" 816ecb8^:"java/org/apache/catalina/core/StandardWrapper.java"

            countAllocated++;
======= fetch "public void deallocate(Servlet servlet) throws ServletException {" 816ecb8^:"java/org/apache/catalina/core/StandardWrapper.java"

            countAllocated--;
======= fetch "public void deallocate(Servlet servlet) throws ServletException {" 816ecb8^:"java/org/apache/catalina/core/StandardWrapper.java"

            countAllocated--;
======= fetch "public synchronized void unload() throws ServletException {" 816ecb8^:"java/org/apache/catalina/core/StandardWrapper.java"

        if (countAllocated > 0) {
======= fetch "public synchronized void unload() throws ServletException {" 816ecb8^:"java/org/apache/catalina/core/StandardWrapper.java"

            while ((nRetries < 21) && (countAllocated > 0)) {
======= fetch "public synchronized void unload() throws ServletException {" 816ecb8^:"java/org/apache/catalina/core/StandardWrapper.java"

                                          new Integer(countAllocated)));

======= fetch "public JAASCallbackHandler(JAASRealm realm, String username," 6d78232^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

     * @param realm     Our associated JAASRealm instance
     * @param username  Username to be authenticated with
     * @param password  Password to be authenticated with
     * @param nonce     Server generated nonce
     * @param nc        Nonce count
     * @param cnonce    Client generated nonce
     * @param qop       Quality of protection aplied to the message
     * @param realmName Realm name
     * @param md5a2     Second MD5 digest used to calculate the digest
======= fetch "public JAASCallbackHandler(JAASRealm realm, String username," 6d78232^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

     * @param authMethod    The authentication mehtod in use 
======= fetch "public JAASCallbackHandler(JAASRealm realm, String username," 6d78232^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

                               String md5a2) {
======= fetch "public JAASCallbackHandler(JAASRealm realm, String username," 6d78232^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

        this.authMethod = authMethod;
======= fetch "public JAASCallbackHandler(JAASRealm realm, String username," 6d78232^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

======= fetch "public JAASCallbackHandler(JAASRealm realm, String username," 6d78232^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

    /**
     * The authentication methdod to be used. If null, assume BASIC/FORM.
     */
    protected String authMethod;
======= fetch "public void handle(Callback callbacks[])" 6d78232^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

                } else if (cb.getPrompt().equals("authMethod")) {
                    cb.setText(authMethod);
======= fetch "public boolean login() throws LoginException {" 6d78232^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        Callback callbacks[] = new Callback[8];
======= fetch "public boolean login() throws LoginException {" 6d78232^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        callbacks[8] = new TextInputCallback("authMethod");
======= fetch "public boolean login() throws LoginException {" 6d78232^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        String authMethod = null;
======= fetch "public boolean login() throws LoginException {" 6d78232^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

            authMethod = ((TextInputCallback) callbacks[8]).getText();
======= fetch "public boolean login() throws LoginException {" 6d78232^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        if (md5a2 == null) {
            // Not using DIGEST
======= fetch "public boolean login() throws LoginException {" 6d78232^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        } else {
            // Must be using DIGEST
======= fetch "public boolean login() throws LoginException {" 6d78232^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        } else if (authMethod.equals(Constants.CERT_METHOD)) {
            principal = super.getPrincipal(username);
        } else {
            throw new LoginException("Unknown authentication method");
======= fetch "public Principal authenticate(String username, String credentials) {" 6d78232^:"java/org/apache/catalina/realm/JAASRealm.java"

     * @param authMethod    The authentication scheme in use
======= fetch "public Principal authenticate(String username, String clientDigest," 6d78232^:"java/org/apache/catalina/realm/JAASRealm.java"

                        nc, cnonce, qop, realmName, md5a2));
======= fetch "protected Principal getPrincipal(String username) {" 6d78232^:"java/org/apache/catalina/realm/JAASRealm.java"

        return (null);

======= fetch "public JAASCallbackHandler(JAASRealm realm, String username," c984c6a^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

    
    /**
     * Construct a callback handler for DIGEST authentication.
     *
     * @param realm     Our associated JAASRealm instance
     * @param username  Username to be authenticated with
     * @param password  Password to be authenticated with
     * @param nonce     Server generated nonce
     * @param nc        Nonce count
     * @param cnonce    Client generated nonce
     * @param qop       Quality of protection aplied to the message
     * @param realmName Realm name
     * @param md5a2     Second MD5 digest used to calculate the digest
     *                      MD5(Method + ":" + uri)
     */
    public JAASCallbackHandler(JAASRealm realm, String username,
                               String password, String nonce, String nc,
                               String cnonce, String qop, String realmName,
                               String md5a2) {
        this(realm, username, password);
        this.nonce = nonce;
        this.nc = nc;
        this.cnonce = cnonce;
        this.qop = qop;
        this.realmName = realmName;
        this.md5a2 = md5a2;
    }
======= fetch "public JAASCallbackHandler(JAASRealm realm, String username," c984c6a^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

    /**
     * Server generated nonce.
     */
    protected String nonce = null;
    
    /**
     * Nonce count.
     */
    protected String nc = null;
    
    /**
     * Client generated nonce.
     */
    protected String cnonce = null;
    /**
     * Quality of protection aplied to the message.
     */
    protected String qop;
    /**
     * Realm name.
     */
    protected String realmName;
    /**
     * Second MD5 digest.
     */
    protected String md5a2;
======= fetch "public JAASCallbackHandler(JAASRealm realm, String username," c984c6a^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

     * This implementation only recognizes <code>NameCallback</code> and
     * <code>PasswordCallback</code> instances.
======= fetch "public void handle(Callback callbacks[])" c984c6a^:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

            } else if (callbacks[i] instanceof TextInputCallback) {
                TextInputCallback cb = ((TextInputCallback) callbacks[i]);
                if (cb.getPrompt().equals("nonce")) {
                    cb.setText(nonce);
                } else if (cb.getPrompt().equals("nc")) {
                    cb.setText(nc);
                } else if (cb.getPrompt().equals("cnonce")) {
                    cb.setText(cnonce);
                } else if (cb.getPrompt().equals("qop")) {
                    cb.setText(qop);
                } else if (cb.getPrompt().equals("realmName")) {
                    cb.setText(realmName);
                } else if (cb.getPrompt().equals("md5a2")) {
                    cb.setText(md5a2);
                } else {
                    throw new UnsupportedCallbackException(callbacks[i]);
                }
======= fetch "public boolean login() throws LoginException {" c984c6a^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        Callback callbacks[] = new Callback[2];
======= fetch "public boolean login() throws LoginException {" c984c6a^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        callbacks[2] = new TextInputCallback("nonce");
        callbacks[3] = new TextInputCallback("nc");
        callbacks[4] = new TextInputCallback("cnonce");
        callbacks[5] = new TextInputCallback("qop");
        callbacks[6] = new TextInputCallback("realmName");
        callbacks[7] = new TextInputCallback("md5a2");
======= fetch "public boolean login() throws LoginException {" c984c6a^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        String nonce = null;
        String nc = null;
        String cnonce = null;
        String qop = null;
        String realmName = null;
        String md5a2 = null;
======= fetch "public boolean login() throws LoginException {" c984c6a^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

            nonce = ((TextInputCallback) callbacks[2]).getText();
            nc = ((TextInputCallback) callbacks[3]).getText();
            cnonce = ((TextInputCallback) callbacks[4]).getText();
            qop = ((TextInputCallback) callbacks[5]).getText();
            realmName = ((TextInputCallback) callbacks[6]).getText();
            md5a2 = ((TextInputCallback) callbacks[7]).getText();
======= fetch "public boolean login() throws LoginException {" c984c6a^:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        principal = super.authenticate(username, password);
======= fetch "public void setUserClassNames(String userClassNames) {" c984c6a^:"java/org/apache/catalina/realm/JAASRealm.java"

     * Return the <code>Principal</code> associated with the specified username and
     * credentials, if there is one; otherwise return <code>null</code>.
     *
     * If there are any errors with the JDBC connection, executing
     * the query or anything we return null (don't authenticate). This
     * event is also logged, and the connection will be closed so that
     * a subsequent request will automatically re-open it.
======= fetch "public Principal authenticate(String username, String credentials) {" c984c6a^:"java/org/apache/catalina/realm/JAASRealm.java"

        return authenticate(username,
                new JAASCallbackHandler(this, username, credentials));
    }
     
    /**
     * Return the <code>Principal</code> associated with the specified username
     * and digest, if there is one; otherwise return <code>null</code>.
     *
     * @param username      Username of the <code>Principal</code> to look up
     * @param clientDigest  Digest to use in authenticating this username
     * @param nonce         Server generated nonce
     * @param nc            Nonce count
     * @param cnonce        Client generated nonce
     * @param qop           Quality of protection aplied to the message
     * @param realmName     Realm name
     * @param md5a2         Second MD5 digest used to calculate the digest
     *                          MD5(Method + ":" + uri)
     */
    public Principal authenticate(String username, String clientDigest,
            String nonce, String nc, String cnonce, String qop,
            String realmName, String md5a2) {
        return authenticate(username,
                new JAASCallbackHandler(this, username, clientDigest, nonce,
                        nc, cnonce, qop, realmName, md5a2));
    }
    // -------------------------------------------------------- Package Methods
    // ------------------------------------------------------ Protected Methods
    /**
     * Perform the actual JAAS authentication
     */
    protected Principal authenticate(String username,
            CallbackHandler callbackHandler) {
======= fetch "public Principal authenticate(String username, String credentials) {" c984c6a^:"java/org/apache/catalina/realm/JAASRealm.java"

            loginContext = new LoginContext
                (appName, new JAASCallbackHandler(this, username,
                                                  credentials));
======= fetch "public Principal authenticate(String username, String credentials) {" c984c6a^:"java/org/apache/catalina/realm/JAASRealm.java"

     
    // -------------------------------------------------------- Package Methods
    // ------------------------------------------------------ Protected Methods
======= fetch "protected String getName() {" c984c6a^:"java/org/apache/catalina/realm/JAASRealm.java"

     * Return the password associated with the given principal's user name.

======= fetch "public void pause() throws Exception {" 38a62a6^:"java/org/apache/jk/server/JkMain.java"

        for( int i=0; i<wEnv.getHandlerCount(); i++ ) {
            if( wEnv.getHandler(i) != null ) {
                wEnv.getHandler(i).pause();

======= fetch "protected synchronized String getPassword(String username) {" 9d3cad7^:"java/org/apache/catalina/realm/JDBCRealm.java"

    protected Principal getPrincipal(String username) {

======= fetch "public boolean listenerStart() {" 4cab5f3^:"java/org/apache/catalina/core/StandardContext.java"

            } catch (IllegalAccessException iae) {
                getLogger().error
                (sm.getString("standardContext.applicationListenerIAE",
                              listeners[i]), iae);
            ok = false;

======= fetch "public String readLine()" 92f847d^:"java/org/apache/catalina/connector/CoyoteReader.java"

                    if (pos == 0) {

======= fetch "public void run () {" d41f610^:"java/org/apache/catalina/servlets/CGIServlet.java"

                // Close the output stream used
                cgiOutput.close();

======= fetch "protected void deployDescriptor(String contextPath, File contextXml, String file" 252fca1^:"java/org/apache/catalina/startup/HostConfig.java"

                if (!docBase.getCanonicalPath().startsWith(appBase().getAbsolutePath())) {

======= fetch "public synchronized void getAllClusterSessions() {" 36bb5d9^:"java/org/apache/catalina/ha/session/DeltaManager.java"

                if (log.isWarnEnabled()) log.warn(sm.getString("deltaManager.waitForSessionState",getName(), mbr));

======= fetch "public void getBytes(MessageBytes mb) {" f23907d^:"java/org/apache/coyote/ajp/AjpMessage.java"

        mb.getCharChunk().recycle(); // not valid anymore

======= fetch "public synchronized boolean stop(int level) throws IOException {" a2a7714^:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

            try {socket.close();}catch ( Exception ignore){}

======= fetch "public long getLastModified() {" e0200b0^:"java/org/apache/naming/resources/DirContextURLConnection.java"

    protected String getHeaderValueAsString(Object headerValue) {
        if (headerValue == null) return null;
        if (headerValue instanceof Date) {
            // return date strings (ie Last-Modified) in HTTP format, rather
            // than Java format
            return FastHttpDateFormat.formatDate(
                    ((Date)headerValue).getTime(), null);
        }
        return headerValue.toString();
    }
======= fetch "public Map getHeaderFields() {" e0200b0^:"java/org/apache/naming/resources/DirContextURLConnection.java"

                  attributeValueList.add(attributeValues.next().toString());
======= fetch "public String getHeaderField(String name) {" e0200b0^:"java/org/apache/naming/resources/DirContextURLConnection.java"

                    return attribute.get(attribute.size()-1).toString();

======= fetch "public boolean parseRequestLine(boolean useAvailableData)" f93376d^:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

            if (buf[pos] == Constants.SP) {
======= fetch "public boolean parseRequestLine(boolean useAvailableData)" f93376d^:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

        // Spec says single SP but also says be tolerant of multiple and/or HT
        while (space) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill())
                    throw new EOFException(sm.getString("iib.eof.error"));
            }
            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                pos++;
            } else {
                space = false;
            }
        }
======= fetch "public boolean parseRequestLine(boolean useAvailableData)" f93376d^:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

        space = false;
======= fetch "public boolean parseRequestLine(boolean useAvailableData)" f93376d^:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

            if (buf[pos] == Constants.SP) {
======= fetch "public boolean parseRequestLine(boolean useAvailableData)" f93376d^:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

        // Spec says single SP but also says be tolerant of multiple and/or HT
        while (space) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill())
                    throw new EOFException(sm.getString("iib.eof.error"));
            }
            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                pos++;
            } else {
                space = false;
            }
        }
======= fetch "public void parseRequestLine()" f93376d^:"java/org/apache/coyote/http11/InternalInputBuffer.java"

            if (buf[pos] == Constants.SP) {
======= fetch "public void parseRequestLine()" f93376d^:"java/org/apache/coyote/http11/InternalInputBuffer.java"

        
        // Spec says single SP but also says be tolerant of multiple and/or HT
        while (space) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill())
                    throw new EOFException(sm.getString("iib.eof.error"));
            }
            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                pos++;
            } else {
                space = false;
            }
        }
======= fetch "public void parseRequestLine()" f93376d^:"java/org/apache/coyote/http11/InternalInputBuffer.java"

        space = false;
======= fetch "public void parseRequestLine()" f93376d^:"java/org/apache/coyote/http11/InternalInputBuffer.java"

            if (buf[pos] == Constants.SP) {
======= fetch "public void parseRequestLine()" f93376d^:"java/org/apache/coyote/http11/InternalInputBuffer.java"

        // Spec says single SP but also says be tolerant of multiple and/or HT
        while (space) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill())
                    throw new EOFException(sm.getString("iib.eof.error"));
            }
            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                pos++;
            } else {
                space = false;
            }
        }
======= fetch "public boolean parseRequestLine(boolean useAvailableData)" f93376d^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

                if (buf[pos] == Constants.SP) {
======= fetch "public boolean parseRequestLine(boolean useAvailableData)" f93376d^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            // Spec says single SP but also be tolerant of multiple and/or HT
            boolean space = true;
            while (space) {
                // Read new bytes if needed
                if (pos >= lastValid) {
                    if (!fill(true, false)) //request line parsing
                        return false;
                }
                if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                    pos++;
                } else {
                    space = false;
                }
            }
======= fetch "public boolean parseRequestLine(boolean useAvailableData)" f93376d^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            boolean space = false;
======= fetch "public boolean parseRequestLine(boolean useAvailableData)" f93376d^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

                if (buf[pos] == Constants.SP) {
======= fetch "public boolean parseRequestLine(boolean useAvailableData)" f93376d^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            // Spec says single SP but also be tolerant of multiple and/or HT
            boolean space = true;
            while (space) {
                // Read new bytes if needed
                if (pos >= lastValid) {
                    if (!fill(true, false)) //request line parsing
                        return false;
                }
                if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                    pos++;
                } else {
                    space = false;
                }
            }

======= fetch "public void visit(Node.VariableDirective n) throws JasperException {" 3c84dcf^:"java/org/apache/jasper/compiler/Validator.java"

        private String comparePageEncodings(String pageDirEnc,
======= fetch "private String comparePageEncodings(String pageDirEnc," 3c84dcf^:"java/org/apache/jasper/compiler/Validator.java"

            String configEnc = root.getJspConfigPageEncoding();
======= fetch "private String comparePageEncodings(String pageDirEnc," 3c84dcf^:"java/org/apache/jasper/compiler/Validator.java"

                String pageEnc = root.getPageEncoding();

======= fetch "public synchronized void start() throws LifecycleException {" a9cb6a6^:"java/org/apache/catalina/core/StandardContext.java"

                // Start manager
                if ((manager != null) && (manager instanceof Lifecycle)) {
                    ((Lifecycle) getManager()).start();
                }
                // Start ContainerBackgroundProcessor thread
                super.threadStart();
======= fetch "public synchronized void start() throws LifecycleException {" a9cb6a6^:"java/org/apache/catalina/core/StandardContext.java"

            // Configure and call application event listeners and filters
======= fetch "public synchronized void start() throws LifecycleException {" a9cb6a6^:"java/org/apache/catalina/core/StandardContext.java"

            
            try {
                // Start manager
                if ((manager != null) && (manager instanceof Lifecycle)) {
                    ((Lifecycle) getManager()).start();
                }
    
                // Start ContainerBackgroundProcessor thread
                super.threadStart();
            } catch(Exception e) {
                log.error("Error manager.start()", e);
                ok = false;
            }
            // Configure and call application filters

======= fetch "public void startElement(" 17b4436^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        String currentPrefix = getPrefix(current.getQName());
        
======= fetch "public void startElement(" 17b4436^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        if (JSP_URI.equals(uri) && TEXT_ACTION.equals(current.getLocalName())) {
======= fetch "private Node parseCustomAction(" 17b4436^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        String prefix = "";
        int colon = qName.indexOf(':');
        if (colon != -1) {
            prefix = qName.substring(0, colon);
        }
======= fetch "private void checkPrefix(String uri, String qName) {" 17b4436^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        int index = qName.indexOf(':');
        if (index != -1) {
            String prefix = qName.substring(0, index);
======= fetch "private void checkPrefix(String uri, String qName) {" 17b4436^:"java/org/apache/jasper/compiler/JspDocumentParser.java"

    private String getPrefix(String qName) {
        int index = qName.indexOf(':');
        if (index != -1) {
            return qName.substring(0, index);
        }
        return "";
    }

======= fetch "private boolean validateURLPattern(String urlPattern) {" 332d0f0^:"java/org/apache/catalina/core/StandardContext.java"

            if (urlPattern.indexOf('/') < 0)
======= fetch "private boolean validateURLPattern(String urlPattern) {" 332d0f0^:"java/org/apache/catalina/core/StandardContext.java"

            else
======= fetch "private boolean validateURLPattern(String urlPattern) {" 332d0f0^:"java/org/apache/catalina/core/StandardContext.java"

                (urlPattern.indexOf("*.") < 0))
======= fetch "private boolean validateURLPattern(String urlPattern) {" 332d0f0^:"java/org/apache/catalina/core/StandardContext.java"

        else
======= fetch "private boolean validateURLPattern(String urlPattern) {" 332d0f0^:"java/org/apache/catalina/core/StandardContext.java"

    private static Log log = LogFactory.getLog(SecurityCollection.class);
======= fetch "public void addPattern(String pattern) {" 332d0f0^:"java/org/apache/catalina/deploy/SecurityCollection.java"

        // Bugzilla 34805: add friendly warning.
        if(pattern.endsWith("*")) {
          if (pattern.charAt(pattern.length()-1) != '/') {
            if (log.isDebugEnabled()) {
              log.warn("Suspicious url pattern: \"" + pattern + "\"" +
                       " - see http://java.sun.com/aboutJava/communityprocess/first/jsr053/servlet23_PFD.pdf" +
                       "  section 11.2" );
            }
          }
        }

======= fetch "public void setCompressableMimeTypes(String compressableMimeTypes) {" e2524a8^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

            this.compressableMimeTypes = null;
======= fetch "public void setCompressableMimeTypes(String compressableMimeTypes) {" e2524a8^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            this.compressableMimeTypes = null;
======= fetch "public void setCompressableMimeTypes(String compressableMimeTypes) {" e2524a8^:"java/org/apache/coyote/http11/Http11Processor.java"

            this.compressableMimeTypes = null;

======= fetch "public static ClassLoader createClassLoader(File unpacked[]," fa91954^:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                URL url = file.toURL();
======= fetch "public static ClassLoader createClassLoader(File unpacked[]," fa91954^:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                    URL url = file.toURL();
======= fetch "public static ClassLoader createClassLoader(String locations[]," fa91954^:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                    URL url = directory.toURL();
======= fetch "public static ClassLoader createClassLoader(String locations[]," fa91954^:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                    URL url = file.toURL();
======= fetch "public static ClassLoader createClassLoader(String locations[]," fa91954^:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                        URL url = file.toURL();
======= fetch "protected void createOutputDir() {" fa91954^:"java/org/apache/jasper/JspCompilationContext.java"

            path = tagName.replace('.', '/');
======= fetch "protected void createOutputDir() {" fa91954^:"java/org/apache/jasper/JspCompilationContext.java"

            path = getServletPackageName().replace('.', '/');
======= fetch "protected void createOutputDir() {" fa91954^:"java/org/apache/jasper/JspCompilationContext.java"

                baseUrl = options.getScratchDir().toURL();
                String outUrlString = baseUrl.toString() + '/' + path;
                URL outUrl = new URL(outUrlString);
                outputDir = outUrl.getFile() + File.separator;

======= fetch "protected void deployWARs(File appBase, String[] files) {" 6a8b1bb^:"java/org/apache/catalina/startup/HostConfig.java"

            if (files[i].toLowerCase().endsWith(".war")) {

 * <li><b>/sessions</b> - Deprecated. Use expire.
======= fetch "public void doGet(HttpServletRequest request," f4a7632^:"java/org/apache/catalina/manager/ManagerServlet.java"

        } else if (command.equals("/sessions")) {
            expireSessions(writer, path, request);

======= fetch "private String createTagHandlerPoolName(String prefix," dfa25f4^:"java/org/apache/jasper/compiler/Generator.java"

                    if (attrNames.length > 0) {
                        poolName = poolName + "&";
                    }

   String description() default "";
   PersistenceProperty[] properties() default {};
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
   String name();
   String value();

======= fetch "protected void generateClass(String[] smap)" 0ea3e15^:"java/org/apache/jasper/compiler/AntCompiler.java"

                endorsedArg.setLine("-J-Djava.endorsed.dirs="+endorsed);
                info.append("    endorsed dir=" + endorsed + "\n");
======= fetch "protected void generateClass(String[] smap)" 0ea3e15^:"java/org/apache/jasper/compiler/AntCompiler.java"

    

======= fetch "protected void applicationWebConfig() {" 06c23d8^:"java/org/apache/catalina/startup/ContextConfig.java"

        if (webDigester == null){
            webDigester = createWebDigester();
        }
        
======= fetch "protected void defaultWebConfig() {" 06c23d8^:"java/org/apache/catalina/startup/ContextConfig.java"

        if (webDigester == null){
            webDigester = createWebDigester();
        }
        
======= fetch "protected void processContextConfig(File baseDir, String resourceName) {" 06c23d8^:"java/org/apache/catalina/startup/ContextConfig.java"

        if (contextDigester == null){
            contextDigester = createContextDigester();
        }
======= fetch "protected void init() {" 06c23d8^:"java/org/apache/catalina/startup/ContextConfig.java"

        if (webDigester == null){
            webDigester = createWebDigester();
            webDigester.getParser();
        }
        
        if (contextDigester == null){
            contextDigester = createContextDigester();
            contextDigester.getParser();
        }

======= fetch "private void tldScanResourcePathsWebInf(DirContext resources," 2edf51e^:"java/org/apache/catalina/startup/TldConfig.java"

                    // Expect file URLs, these are %xx encoded or not depending on
                    // the class loader
======= fetch "private void tldScanResourcePathsWebInf(DirContext resources," 2edf51e^:"java/org/apache/catalina/startup/TldConfig.java"

                    
                    // Check that the URL is using file protocol, else ignore it
                    if (!"file".equals(urls[i].getProtocol())) {
                        continue;
                    }
                    

======= fetch "private static String getJNDIUri(String hostName, String path) {" 6723b35^:"java/org/apache/catalina/core/ApplicationContext.java"

    private final class DispatchData {

======= fetch "public long process(Reader reader, long lastModifiedDate," df75937^:"java/org/apache/catalina/ssi/SSIProcessor.java"

                        bIdx++;
======= fetch "public long process(Reader reader, long lastModifiedDate," df75937^:"java/org/apache/catalina/ssi/SSIProcessor.java"

                    if (c == '"' && !escaped) quotes++;
======= fetch "public long process(Reader reader, long lastModifiedDate," df75937^:"java/org/apache/catalina/ssi/SSIProcessor.java"

                    if (c == '"') quotes++;

======= fetch "public long process(SSIMediator ssiMediator, String commandName," 75fbd91^:"java/org/apache/catalina/ssi/SSIEcho.java"

    	long lastModified = 0;
======= fetch "public long process(SSIMediator ssiMediator, String commandName," 75fbd91^:"java/org/apache/catalina/ssi/SSIEcho.java"

        String originalValue = null;
======= fetch "public long process(SSIMediator ssiMediator, String commandName," 75fbd91^:"java/org/apache/catalina/ssi/SSIEcho.java"

                String variableValue = ssiMediator.getVariableValue(
                        paramValue, encoding);
                if (variableValue == null) {
                    variableValue = MISSING_VARIABLE_VALUE;
                }
                writer.write(variableValue);
                lastModified = System.currentTimeMillis();
======= fetch "public long process(SSIMediator ssiMediator, String commandName," 75fbd91^:"java/org/apache/catalina/ssi/SSIEcho.java"

        return lastModified;
======= fetch "public String substituteVariables(String val) {" 75fbd91^:"java/org/apache/catalina/ssi/SSIMediator.java"

        // If it has no variable references then no work
======= fetch "public String substituteVariables(String val) {" 75fbd91^:"java/org/apache/catalina/ssi/SSIMediator.java"

        if (val.indexOf('$') < 0) return val;
======= fetch "public String substituteVariables(String val) {" 75fbd91^:"java/org/apache/catalina/ssi/SSIMediator.java"

        int charStart = sb.indexOf("&#");
        while (charStart > -1) {
            int charEnd = sb.indexOf(";", charStart);
            if (charEnd > -1) {
                char c = (char) Integer.parseInt(
                        sb.substring(charStart + 2, charEnd));
                sb.delete(charStart, charEnd + 1);
                sb.insert(charStart, c);
                charStart = sb.indexOf("&#");
            } else {
                break;
            }
        }
======= fetch "protected String encode(String value, String encoding) {" 75fbd91^:"java/org/apache/catalina/ssi/SSIMediator.java"

            //Not sure how this is really different than none
            retVal = value;

======= fetch "public static Object proprietaryEvaluate(final String expression," 1f41c3d^:"java/org/apache/jasper/runtime/PageContextImpl.java"

        final ExpressionFactory exprFactory = JspFactory.getDefaultFactory().getJspApplicationContext(pageContext.getServletContext()).getExpressionFactory();

======= fetch "public void writeExternal(ObjectOutput out) throws IOException {" 0035fd4^:"java/org/apache/el/lang/FunctionMapperImpl.java"

            // make sure m isn't null
            getMethod();

======= fetch "public int getPoolSize() {" c3c525b^:"java/org/apache/catalina/core/StandardThreadExecutor.java"

    public int getQueueSize() {
        return (executor != null) ? executor.getQueue().size() : -1;
    }
======= fetch "public Thread newThread(Runnable r) {" c3c525b^:"java/org/apache/catalina/core/StandardThreadExecutor.java"


======= fetch "public boolean hasResourcePermission(Request request," 7be2374^:"java/org/apache/catalina/realm/RealmBase.java"

                    break;
======= fetch "public boolean hasResourcePermission(Request request," 7be2374^:"java/org/apache/catalina/realm/RealmBase.java"

                    return (true);
======= fetch "public boolean hasResourcePermission(Request request," 7be2374^:"java/org/apache/catalina/realm/RealmBase.java"

                status = false;
            } else if(!denyfromall) {
======= fetch "public boolean hasResourcePermission(Request request," 7be2374^:"java/org/apache/catalina/realm/RealmBase.java"

        if (allRolesMode != AllRolesMode.STRICT_MODE && !status && principal != null) {

    /**
     * The string manager for this package.
     */
    protected static StringManager sm =
        StringManager.getManager(Constants.Package);
======= fetch "public int readByte()" ca41a27^:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= fetch "public int read(byte[] b, int off, int len)" ca41a27^:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= fetch "public int read()" ca41a27^:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= fetch "public int read(char[] cbuf)" ca41a27^:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= fetch "public int read(char[] cbuf, int off, int len)" ca41a27^:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= fetch "public long skip(long n)" ca41a27^:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= fetch "public boolean ready()" ca41a27^:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= fetch "public void mark(int readAheadLimit)" ca41a27^:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= fetch "public void reset()" ca41a27^:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));

     * Connection list.
    protected ConcurrentHashMap<String, ConnectionInfo[]> connections
        = new ConcurrentHashMap<String, ConnectionInfo[]>();
======= fetch "public void stop() throws LifecycleException {" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

        // The webapp is getting stopped, so all current connections 
        // should be closed
        // Close all Comet connections associated with this session
        // Note: this will only be done if the container was not a Context
        // (otherwise, this needs to be done before stop, as the servlet would
        // be deallocated already)
        Iterator<ConnectionInfo[]> iterator = connections.values().iterator();
        while (iterator.hasNext()) {
            ConnectionInfo[] connectionInfos = iterator.next();
            if (connectionInfos != null) {
                for (int i = 0; i < connectionInfos.length; i++) {
                    ConnectionInfo connectionInfo = connectionInfos[i];
                    try {
                        connectionInfo.event.close();
                    } catch (Exception e) {
                        container.getLogger().warn(sm.getString("cometConnectionManagerValve.event"), e);
                    }
                }
            }
        }
        connections.clear();
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

            // The webapp is getting stopped, so all current connections 
            // should be closed
            // Close all Comet connections associated with this session
            Iterator<ConnectionInfo[]> iterator = connections.values().iterator();
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                ConnectionInfo[] connectionInfos = iterator.next();
                if (connectionInfos != null) {
                    for (int i = 0; i < connectionInfos.length; i++) {
                        ConnectionInfo connectionInfo = connectionInfos[i];
                        try {
                            ((CometEventImpl) connectionInfo.event).setEventType(CometEvent.EventType.END);
                            ((CometEventImpl) connectionInfo.event).setEventSubType(CometEvent.EventSubType.WEBAPP_RELOAD);
                            getNext().event(connectionInfo.request, connectionInfo.response, connectionInfo.event);
                            connectionInfo.event.close();
                        } catch (Exception e) {
                            container.getLogger().warn(sm.getString("cometConnectionManagerValve.event"), e);
                        }
                    }
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

            connections.clear();
======= fetch "public void invoke(Request request, Response response)" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

            ConnectionInfo newConnectionInfo = new ConnectionInfo();
            newConnectionInfo.request = request;
            newConnectionInfo.response = response;
            newConnectionInfo.event = request.getEvent();
======= fetch "public void invoke(Request request, Response response)" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                String id = session.getId();
                ConnectionInfo[] connectionInfos = connections.get(id);
                if (connectionInfos == null) {
                    connectionInfos = new ConnectionInfo[1];
                    connectionInfos[0] = newConnectionInfo;
                    connections.put(id, connectionInfos);
======= fetch "public void invoke(Request request, Response response)" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                    ConnectionInfo[] newConnectionInfos = 
                        new ConnectionInfo[connectionInfos.length + 1];
                    for (int i = 0; i < connectionInfos.length; i++) {
                        newConnectionInfos[i] = connectionInfos[i];
======= fetch "public void invoke(Request request, Response response)" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                    newConnectionInfos[connectionInfos.length] = newConnectionInfo;
                    connections.put(id, newConnectionInfos);
======= fetch "public void event(Request request, Response response, CometEvent event)" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                            && !(event.getEventSubType() == CometEvent.EventSubType.TIMEOUT))) {
                // Remove from tracked list, the connection is done
                HttpSession session = request.getSession(true);
                synchronized (session) {
                    ConnectionInfo[] connectionInfos = connections.get(session.getId());
                    if (connectionInfos != null) {
                        boolean found = false;
                        for (int i = 0; !found && (i < connectionInfos.length); i++) {
                            found = (connectionInfos[i].request == request);
                        }
                        if (found) {
                            ConnectionInfo[] newConnectionInfos = 
                                new ConnectionInfo[connectionInfos.length - 1];
                            int pos = 0;
                            for (int i = 0; i < connectionInfos.length; i++) {
                                if (connectionInfos[i].request != request) {
                                    newConnectionInfos[pos++] = connectionInfos[i];
======= fetch "public void event(Request request, Response response, CometEvent event)" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                            connections.put(session.getId(), newConnectionInfos);
======= fetch "public void event(Request request, Response response, CometEvent event)" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                }                
======= fetch "public void event(Request request, Response response, CometEvent event)" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

        
======= fetch "public void sessionDestroyed(HttpSessionEvent se) {" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

        ConnectionInfo[] connectionInfos = connections.remove(se.getSession().getId());
        if (connectionInfos != null) {
            for (int i = 0; i < connectionInfos.length; i++) {
                ConnectionInfo connectionInfo = connectionInfos[i];
======= fetch "public void sessionDestroyed(HttpSessionEvent se) {" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                    ((CometEventImpl) connectionInfo.event).setEventType(CometEvent.EventType.END);
                    ((CometEventImpl) connectionInfo.event).setEventSubType(CometEvent.EventSubType.SESSION_END);
                    getNext().event(connectionInfo.request, connectionInfo.response, connectionInfo.event);
                    connectionInfo.event.close();
======= fetch "public void sessionDestroyed(HttpSessionEvent se) {" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                    container.getLogger().warn(sm.getString("cometConnectionManagerValve.event"), e);
======= fetch "public void sessionDestroyed(HttpSessionEvent se) {" fdac1d6^:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

    // --------------------------------------------- ConnectionInfo Inner Class
    
    protected class ConnectionInfo {
        public CometEvent event;
        public Request request;
        public Response response;
    }

======= fetch "public void init()" 7bd915c^:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

                throw new BindException(be.getMessage() + ":" + port);

======= fetch "public void service(ServletRequest req, ServletResponse res)" 288b2ae^:"java/javax/servlet/http/HttpServlet.java"

 * A response that includes no body, for use in (dumb) "HEAD" support.
======= fetch "public void service(ServletRequest req, ServletResponse res)" 288b2ae^:"java/javax/servlet/http/HttpServlet.java"

 * the content length appropriately.  All other methods delegate directly
 * to the HTTP Servlet Response object used to construct this one.
======= fetch "public void service(ServletRequest req, ServletResponse res)" 288b2ae^:"java/javax/servlet/http/HttpServlet.java"

    private HttpServletResponse                resp;
======= fetch "public void service(ServletRequest req, ServletResponse res)" 288b2ae^:"java/javax/servlet/http/HttpServlet.java"

        resp = r;
======= fetch "void setContentLength() {" 288b2ae^:"java/javax/servlet/http/HttpServlet.java"

          resp.setContentLength(noBody.getContentLength());
======= fetch "public void setContentLength(int len) {" 288b2ae^:"java/javax/servlet/http/HttpServlet.java"

        resp.setContentLength(len);
======= fetch "public void setContentLength(int len) {" 288b2ae^:"java/javax/servlet/http/HttpServlet.java"

    public void setCharacterEncoding(String charset)
      { resp.setCharacterEncoding(charset); }
    public void setContentType(String type)
      { resp.setContentType(type); }
    public String getContentType()
      { return resp.getContentType(); }
    public ServletOutputStream getOutputStream() throws IOException
      { return noBody; }
======= fetch "public ServletOutputStream getOutputStream() throws IOException" 288b2ae^:"java/javax/servlet/http/HttpServlet.java"

    public String getCharacterEncoding()
        { return resp.getCharacterEncoding(); }
======= fetch "public String getCharacterEncoding()" 288b2ae^:"java/javax/servlet/http/HttpServlet.java"

    public PrintWriter getWriter() throws UnsupportedEncodingException
    {
======= fetch "public PrintWriter getWriter() throws UnsupportedEncodingException" 288b2ae^:"java/javax/servlet/http/HttpServlet.java"

            OutputStreamWriter        w;
======= fetch "public PrintWriter getWriter() throws UnsupportedEncodingException" 288b2ae^:"java/javax/servlet/http/HttpServlet.java"

    public void setBufferSize(int size) throws IllegalStateException
      { resp.setBufferSize(size); }
    public int getBufferSize()
      { return resp.getBufferSize(); }
    public void reset() throws IllegalStateException
      { resp.reset(); }
      
      public void resetBuffer() throws IllegalStateException
      { resp.resetBuffer(); }
    public boolean isCommitted()
      { return resp.isCommitted(); }
    public void flushBuffer() throws IOException
      { resp.flushBuffer(); }
    public void setLocale(Locale loc)
      { resp.setLocale(loc); }
    public Locale getLocale()
      { return resp.getLocale(); }
    // HTTP SERVLET RESPONSE interface methods
    public void addCookie(Cookie cookie)
      { resp.addCookie(cookie); }
    public boolean containsHeader(String name)
      { return resp.containsHeader(name); }
    /** @deprecated */
    public void setStatus(int sc, String sm)
      { resp.setStatus(sc, sm); }
    public void setStatus(int sc)
      { resp.setStatus(sc); }
    public void setHeader(String name, String value)
      { resp.setHeader(name, value); }
    public void setIntHeader(String name, int value)
      { resp.setIntHeader(name, value); }
    public void setDateHeader(String name, long date)
      { resp.setDateHeader(name, date); }
    public void sendError(int sc, String msg) throws IOException
      { resp.sendError(sc, msg); }
    public void sendError(int sc) throws IOException
      { resp.sendError(sc); }
    public void sendRedirect(String location) throws IOException
      { resp.sendRedirect(location); }
    
    public String encodeURL(String url) 
      { return resp.encodeURL(url); }
    public String encodeRedirectURL(String url)
      { return resp.encodeRedirectURL(url); }
      
    public void addHeader(String name, String value)
      { resp.addHeader(name, value); }
      
    public void addDateHeader(String name, long value)
      { resp.addDateHeader(name, value); }
      
    public void addIntHeader(String name, int value)
      { resp.addIntHeader(name, value); }
      
    /**
     * @deprecated        As of Version 2.1, replaced by
     *                         {@link HttpServletResponse#encodeURL}.
     *
     */
    public String encodeUrl(String url) 
      { return this.encodeURL(url); }
      
    /**
     * @deprecated        As of Version 2.1, replaced by
     *                        {@link HttpServletResponse#encodeRedirectURL}.
     *
     */
    public String encodeRedirectUrl(String url)
      { return this.encodeRedirectURL(url); }

======= fetch "protected String getReadme(DirContext directory)" 8a3b14b^:"java/org/apache/catalina/servlets/DefaultServlet.java"

                throw new ServletException("Error opening readme resource", e);
======= fetch "protected InputStream findXsltInputStream(DirContext directory)" 8a3b14b^:"java/org/apache/catalina/servlets/DefaultServlet.java"

                throw new ServletException("Error opening XSLT resource", e);

======= fetch "public void start()" bf6ce6f^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

            // Start poller thread
            poller = new Poller();
            Thread pollerThread = new Thread(poller, getName() + "-ClientPoller");
            pollerThread.setPriority(threadPriority);
            pollerThread.setDaemon(true);
            pollerThread.start();
======= fetch "public void start()" bf6ce6f^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

            // Start poller thread
            poller = new Poller();
            Thread pollerThread = new Thread(poller, getName() + "-ClientPoller");
            pollerThread.setPriority(threadPriority);
            pollerThread.setDaemon(true);
            pollerThread.start();

======= fetch "public Object run() {" 948598d^:"java/org/apache/catalina/loader/WebappClassLoader.java"

    
    protected final class PrivilegedGetClassLoader
        implements PrivilegedAction<ClassLoader> {
        public Class<?> clazz;
        public PrivilegedGetClassLoader(Class<?> clazz){
            this.clazz = clazz;
        }
        public ClassLoader run() {       
            return clazz.getClassLoader();
        }           
    }
    
======= fetch "public Class findClass(String name) throws ClassNotFoundException {" 948598d^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if ((log.isTraceEnabled()) && (clazz != null))
            log.debug("      Loaded by " + clazz.getClassLoader());

======= fetch "public void addApplicationListener(String listener) {" cdff09f^:"java/org/apache/catalina/core/StandardContext.java"

                if (listener.equals(applicationListeners[i]))
======= fetch "public void addApplicationListener(String listener) {" cdff09f^:"java/org/apache/catalina/core/StandardContext.java"

                }

======= fetch "protected KeyStore getTrustStore(String keystoreType) throws IOException {" f9e41b8^:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

        if( truststoreType == null) {
            truststoreType = System.getProperty("javax.net.ssl.trustStoreType");
        }

======= fetch "public void list(HttpServletRequest request," e14afee^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args[11] = new Integer(context.getManager().getMaxInactiveInterval()/60);

======= fetch "public int doRead(ByteChunk chunk, Request req)" 1cc6641^:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

            needCRLFParse = true;
======= fetch "protected boolean parseCRLF()" 1cc6641^:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

        boolean crfound = false;
======= fetch "protected boolean parseCRLF()" 1cc6641^:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

                if (crfound) throw new IOException("Invalid CRLF, two CR characters encountered.");
                crfound = true;
======= fetch "protected boolean parseCRLF()" 1cc6641^:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

                if (!crfound) throw new IOException("Invalid CRLF, no CR character encountered.");

======= fetch "private void parseTaglibDirective(Node parent) throws JasperException {" 98b8ba2^:"java/org/apache/jasper/compiler/Parser.java"

                    } else {
                        // Current compilation context needs location of cached
                        // tag files
                        for (TagFileInfo info : impl.getTagFiles()) {
                            ctxt.setTagFileJarUrl(info.getPath(),
                                    ctxt.getTagFileJarUrl());
                        }

======= fetch "public String getText() {" 61ce1a3^:"java/org/apache/jasper/compiler/Node.java"

            if ((ret == null) && (body != null)) {
                StringBuffer buf = new StringBuffer();
                for (int i = 0; i < body.size(); i++) {
                    buf.append(body.getNode(i).getText());
======= fetch "public String getText() {" 61ce1a3^:"java/org/apache/jasper/compiler/Node.java"

                ret = buf.toString();

======= fetch "public Method getSetter(String aname, BaseModelMBean bean, Object resource)" ccadbbc^:"java/org/apache/tomcat/util/modeler/ManagedBean.java"

                object = this;
======= fetch "public Method getInvoke(String aname, Object[] params, String[] signature, BaseM" ccadbbc^:"java/org/apache/tomcat/util/modeler/ManagedBean.java"

                object = this;

======= fetch "public void setValue(EvaluationContext ctx, Object value)" c5bcc98^:"java/org/apache/el/parser/AstValue.java"

        ctx.getELResolver().setValue(ctx, t.base, t.property, value);

======= fetch "public FileResourceAttributes(File file) {" 2441155^:"java/org/apache/naming/resources/FileDirContext.java"

            getCreation();
            getLastModified();
======= fetch "public long getCreation() {" 2441155^:"java/org/apache/naming/resources/FileDirContext.java"

            creation = file.lastModified();
======= fetch "public Date getCreationDate() {" 2441155^:"java/org/apache/naming/resources/FileDirContext.java"

                creation = file.lastModified();
======= fetch "public Date getLastModifiedDate() {" 2441155^:"java/org/apache/naming/resources/FileDirContext.java"

                lastModified = file.lastModified();

======= fetch "public CoyoteAdapter(Connector connector) {" e452200^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

    /**
     * Encoder for the Location URL in HTTP redirects.
     */
    protected static URLEncoder urlEncoder;
    // ----------------------------------------------------- Static Initializer
    /**
     * The safe character set.
     */
    static {
        urlEncoder = new URLEncoder();
        urlEncoder.addSafeCharacter('-');
        urlEncoder.addSafeCharacter('_');
        urlEncoder.addSafeCharacter('.');
        urlEncoder.addSafeCharacter('*');
        urlEncoder.addSafeCharacter('/');
    }
======= fetch "protected boolean postParseRequest(org.apache.coyote.Request req," e452200^:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            String redirectPath = redirectPathMB.toString();

======= fetch "public void setPropertyResolved(boolean resolved) {" fdb170e^:"java/org/apache/el/lang/EvaluationContext.java"

    
    public Locale getLocale() { 
        return this.elContext.getLocale();
        }
    public void setLocale(Locale locale) { 
        this.elContext.setLocale(locale);
    }

======= fetch "protected final Number coerce(final Object obj) {" c228054^:"java/org/apache/el/lang/ELArithmetic.java"

        throw new IllegalArgumentException(MessageFactory.get("el.convert", obj,
                objType));

======= fetch "public Comparable getComparableObject(Session session) {" df2b1e6^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  &nbsp;<input type=\"submit\" value=\"{9}\">&nbsp;{10}&nbsp;<input type=\"text\" name=\"expire\" size=\"5\" value=\"{11}\">&nbsp;{12}&nbsp;\n" +
======= fetch "public Comparable getComparableObject(Session session) {" df2b1e6^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  &nbsp;<input type=\"submit\" value=\"{9}\">&nbsp;{10}&nbsp;<input type=\"text\" name=\"expire\" size=\"5\" value=\"{11}\">&nbsp;{12}&nbsp;\n" +

======= fetch "public String getRoleClassNames() {" 46721e4^:"java/org/apache/catalina/realm/JAASRealm.java"

      * Sets the list of comma-delimited classes that represent 
      * roles. The classes in the list must implement <code>java.security.Principal</code>.
      * When this accessor is called (for example, by a <code>Digester</code>
      * instance parsing the
      * configuration file), it will parse the class names and store the resulting
      * string(s) into the <code>ArrayList</code> field </code>roleClasses</code>.
======= fetch "public void setRoleClassNames(String roleClassNames) {" 46721e4^:"java/org/apache/catalina/realm/JAASRealm.java"

         parseClassNames(roleClassNames, roleClasses);
======= fetch "public void setRoleClassNames(String roleClassNames) {" 46721e4^:"java/org/apache/catalina/realm/JAASRealm.java"

      * in the provided List. Each class must implement <codejava.security.Principal</code>.
======= fetch "protected void parseClassNames(String classNamesString, List<String> classNamesL" 46721e4^:"java/org/apache/catalina/realm/JAASRealm.java"

         
======= fetch "protected void parseClassNames(String classNamesString, List<String> classNamesL" 46721e4^:"java/org/apache/catalina/realm/JAASRealm.java"

                 Class principalClass = Class.forName(classNames[i]);
======= fetch "public String getUserClassNames() {" 46721e4^:"java/org/apache/catalina/realm/JAASRealm.java"

     * Sets the list of comma-delimited classes that represent individual
     * users. The classes in the list must implement <code>java.security.Principal</code>.
     * When this accessor is called (for example, by a <code>Digester</code>
     * instance parsing the
     * configuration file), it will parse the class names and store the resulting
     * string(s) into the <code>ArrayList</code> field </code>userClasses</code>.
     */
======= fetch "public void setUserClassNames(String userClassNames) {" 46721e4^:"java/org/apache/catalina/realm/JAASRealm.java"

        parseClassNames(userClassNames, userClasses);
======= fetch "public Principal authenticate(String username, String credentials) {" 46721e4^:"java/org/apache/catalina/realm/JAASRealm.java"

        if (isUseContextClassLoader()) {
          ocl=Thread.currentThread().getContextClassLoader();
          Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());
======= fetch "public Principal authenticate(String username, String credentials) {" 46721e4^:"java/org/apache/catalina/realm/JAASRealm.java"

            if( isUseContextClassLoader()) {
======= fetch "protected Principal createPrincipal(String username, Subject subject) {" 46721e4^:"java/org/apache/catalina/realm/JAASRealm.java"

        Iterator principals = subject.getPrincipals().iterator();
======= fetch "protected Principal createPrincipal(String username, Subject subject) {" 46721e4^:"java/org/apache/catalina/realm/JAASRealm.java"

            Principal principal = (Principal) principals.next();
======= fetch "public void start() throws LifecycleException {" 46721e4^:"java/org/apache/catalina/realm/JAASRealm.java"

        // These need to be called after loading configuration, in case
        // useContextClassLoader appears after them in xml config
        parseClassNames(userClassNames, userClasses);
        parseClassNames(roleClassNames, roleClasses);

======= fetch "public void reset() {" 71bd193^:"java/org/apache/catalina/connector/Response.java"

        usingOutputStream = false;
        usingWriter = false;
        isCharacterEncodingSet = false;

======= fetch "public InputStream getResourceAsStream(String path) {" 8f91433^:"java/org/apache/catalina/core/ApplicationContext.java"

        if (path == null)
======= fetch "private String normalize(String path) {" 8f91433^:"java/org/apache/catalina/core/ApplicationContext.java"

        // Normalize the slashes and add leading slash if necessary

======= fetch "public void doPost(HttpServletRequest request," ffbbe88^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                if ((host.findChild(path) != null) && !isDeployed(path)) {
                    message = sm.getString
                        ("htmlManagerServlet.deployUploadInServerXml", war);
                    break;
                }

======= fetch "protected Http11AprProcessor createProcessor() {" d1d0619^:"java/org/apache/coyote/http11/Http11AprProtocol.java"

            processor.setCompression(proto.compression);
======= fetch "protected Http11AprProcessor createProcessor() {" d1d0619^:"java/org/apache/coyote/http11/Http11AprProtocol.java"

            processor.setCompression(proto.compression);
======= fetch "public Http11NioProcessor createProcessor() {" d1d0619^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

            processor.setCompression(proto.compression);
======= fetch "public Http11NioProcessor createProcessor() {" d1d0619^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

            processor.setCompression(proto.compression);
======= fetch "protected Http11Processor createProcessor() {" d1d0619^:"java/org/apache/coyote/http11/Http11Protocol.java"

            processor.setCompression(proto.compression);
======= fetch "protected Http11Processor createProcessor() {" d1d0619^:"java/org/apache/coyote/http11/Http11Protocol.java"

            processor.setCompression(proto.compression);

======= fetch "public static JavacErrorDetail createJavacError(String fname," eb87635^:"java/org/apache/jasper/compiler/ErrorDispatcher.java"

            javacError = new JavacErrorDetail(
                    fname,
                    lineNum,
                    errNode.getStart().getFile(),
                    errNode.getStart().getLineNumber(),
                    errMsgBuf,
                    ctxt);

======= fetch "private boolean copyResource(HttpServletRequest req," 324387d^:"java/org/apache/catalina/servlets/WebdavServlet.java"

        // Copy was successful
        resp.setStatus(WebdavStatus.SC_CREATED);

======= fetch "protected void registerJMX(StandardContext ctx) {" 9314e5b^:"java/org/apache/catalina/core/StandardWrapper.java"

            log.info("Error registering servlet with jmx " + this);
======= fetch "protected void registerJMX(StandardContext ctx) {" 9314e5b^:"java/org/apache/catalina/core/StandardWrapper.java"

                         instance);

 * are handled by the DefaultServlet.
======= fetch "protected String getRelativePath(HttpServletRequest request) {" 3c61f9b^:"java/org/apache/catalina/servlets/WebdavServlet.java"


  http://issues.apache.org/bugzilla/attachment.cgi?id=20883
  +1: remm, pero, funkman
  -1: 
  http://issues.apache.org/bugzilla/attachment.cgi?id=20930
  +1: remm, pero, funkman
  -1: 
  -1: 
  +1: jfclere
======= fetch "protected void remove(SendfileData data) {" 16464d6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            sendfileData.remove(data);
======= fetch "public void run() {" 16464d6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            long maintainTime = 0;
======= fetch "public void run() {" 16464d6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    // Reset maintain time.
                    maintainTime = 0;
======= fetch "public void run() {" 16464d6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    maintainTime += pollTime;
======= fetch "public void run() {" 16464d6^:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    /* TODO: See if we need to call the maintain for sendfile poller */

======= fetch "public String findStatusPage(int status) {" 73b5e41^:"java/org/apache/catalina/core/StandardContext.java"

        return ((String) statusPages.get(new Integer(status)));
        Patch by Tuomas Kiviaho- tuomas.kiviahos at ikis fi

======= fetch "public void memberDisappeared(Member member) {" 5aed2f5^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            if (!removed) {
                if (log.isDebugEnabled()) log.debug("Member["+member+"] disappeared, but was not present in the map.");
                return; //the member was not part of our map.
            }
        <bug>43435</bug>: Don't iterate and relocate sessions if they are not part of the map.
      </fix>
      <fix>

======= fetch "public void setOomParachute(int oomParachute) {" 28da141^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    public boolean getClientAuth() { return ep.getClientAuth();}
    public void setClientAuth(boolean b ) { ep.setClientAuth(b);}
======= fetch "public void setOomParachute(int oomParachute) {" 28da141^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    
    
======= fetch "public void setOomParachute(int oomParachute) {" 28da141^:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    public void setTruststoreFile(String f){ep.setTruststoreFile(f);}
    public String getTruststoreFile(){return ep.getTruststoreFile();}
    public void setTruststorePass(String p){ep.setTruststorePass(p);}
    public String getTruststorePass(){return ep.getTruststorePass();}
    public void setTruststoreType(String t){ep.setTruststoreType(t);}
    public String getTruststoreType(){ return ep.getTruststoreType();}
    
    
======= fetch "public void setProperty(String name, String value) {" 28da141^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    public String adjustRelativePath(String path, String relativeTo) {
        File f = new File(path);
        if ( !f.isAbsolute()) {
            path = relativeTo + File.separator + path;
            f = new File(path);
        }
        if (!f.exists()) {
            log.warn("configured file:["+path+"] does not exist.");
        }
        return path;
    }
    
    public String defaultIfNull(String val, String defaultValue) {
        if (val==null) return defaultValue;
        else return val;
    }
======= fetch "public void setProperty(String name, String value) {" 28da141^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    protected String truststoreFile = System.getProperty("javax.net.ssl.trustStore");
    public void setTruststoreFile(String s) {
        s = adjustRelativePath(s,System.getProperty("catalina.base"));
        this.truststoreFile = s;
    }
    public String getTruststoreFile() {return truststoreFile;}
    protected String truststorePass = System.getProperty("javax.net.ssl.trustStorePassword");
    public void setTruststorePass(String truststorePass) {this.truststorePass = truststorePass;}
    public String getTruststorePass() {return truststorePass;}
    protected String truststoreType = System.getProperty("javax.net.ssl.trustStoreType");
    public void setTruststoreType(String truststoreType) {this.truststoreType = truststoreType;}
    public String getTruststoreType() {return truststoreType;}
    
======= fetch "public void setProperty(String name, String value) {" 28da141^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    public void setKeystoreFile(String s ) { this.keystoreFile = s; }
    public void setKeystore(String s ) { setKeystoreFile(s);}
    public String getKeystore() { return getKeystoreFile();}
======= fetch "public void setProperty(String name, String value) {" 28da141^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    protected boolean clientAuth = false;
    public boolean getClientAuth() { return clientAuth;}
    public void setClientAuth(boolean b ) { this.clientAuth = b;}
======= fetch "public void init()" 28da141^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

            KeyStore ts = KeyStore.getInstance(getKeystoreType());
            ts.load(new FileInputStream(getKeystoreFile()), passphrase);
======= fetch "public void init()" 28da141^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

            char[] tpassphrase = (getTruststorePass()!=null)?getTruststorePass().toCharArray():passphrase;
            String ttype = (getTruststoreType()!=null)?getTruststoreType():getKeystoreType();
            KeyStore ts = null;
            if (getTruststoreFile()==null) {
                ts = KeyStore.getInstance(getKeystoreType());
                ts.load(new FileInputStream(getKeystoreFile()), passphrase);
            }else {
                ts = KeyStore.getInstance(ttype);
                ts.load(new FileInputStream(getTruststoreFile()), tpassphrase);
            }
======= fetch "protected SSLEngine createSSLEngine() {" 28da141^:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        engine.setNeedClientAuth(getClientAuth());

            wrequest.recycle();
            unwrapRequest(state);
            wrequest.recycle();
            unwrapRequest(state);
            wrequest.recycle();
            wrequest.recycle();
======= fetch "private void invoke(ServletRequest request, ServletResponse response," 4dd22a5^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        // Recycle request if necessary (also BZ 30949)
        recycleRequestWrapper(state);
        
======= fetch "private void checkSameObjects(ServletRequest appRequest," 4dd22a5^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

    private void recycleRequestWrapper(State state) {
        if (state.wrapRequest instanceof ApplicationHttpRequest) {
            ((ApplicationHttpRequest) state.wrapRequest).recycle();        }
    }
        <bug>30949</bug>: Improve previous fix. Ensure requests are re-cycled
        on cross-context includes and forwards when an exception occurs in the
        target page. (markt)
      </fix>
      <fix>

======= fetch "protected void doLoad() throws ClassNotFoundException, IOException {" 9c37a01^:"java/org/apache/catalina/session/StandardManager.java"

                    session.endAccess();

======= fetch "public static void parseParameters(Map map, String data, String encoding)" 44e36ea^:"java/org/apache/catalina/util/RequestUtil.java"

     * servers.
======= fetch "public static String URLDecode(String str) {" 44e36ea^:"java/org/apache/catalina/util/RequestUtil.java"

======= fetch "public static String URLDecode(String str) {" 44e36ea^:"java/org/apache/catalina/util/RequestUtil.java"

======= fetch "public static String URLDecode(String str) {" 44e36ea^:"java/org/apache/catalina/util/RequestUtil.java"

    
    
======= fetch "public static String URLDecode(String str) {" 44e36ea^:"java/org/apache/catalina/util/RequestUtil.java"

     * Decode and return the specified URL-encoded String.
======= fetch "public static String URLDecode(String str, String enc) {" 44e36ea^:"java/org/apache/catalina/util/RequestUtil.java"

        return URLDecode(str, enc, false);
    }
    
    /**
     * Decode and return the specified URL-encoded String.
     *
     * @param str The url-encoded string
     * @param enc The encoding to use; if null, the default encoding is used
     * @param isQuery Is this a query string being processed
     * @exception IllegalArgumentException if a '%' character is not followed
     * by a valid 2-digit hexadecimal number
     */
    public static String URLDecode(String str, String enc, boolean isQuery) {
======= fetch "public static String URLDecode(String str, String enc) {" 44e36ea^:"java/org/apache/catalina/util/RequestUtil.java"

        return URLDecode(bytes, enc);
======= fetch "public static String URLDecode(String str, String enc) {" 44e36ea^:"java/org/apache/catalina/util/RequestUtil.java"

     * Decode and return the specified URL-encoded byte array.
======= fetch "public static String URLDecode(byte[] bytes) {" 44e36ea^:"java/org/apache/catalina/util/RequestUtil.java"

     * Decode and return the specified URL-encoded byte array.
======= fetch "public static String URLDecode(byte[] bytes, String enc) {" 44e36ea^:"java/org/apache/catalina/util/RequestUtil.java"

        return URLDecode(bytes, null, false);
    }
======= fetch "public static String URLDecode(byte[] bytes, String enc) {" 44e36ea^:"java/org/apache/catalina/util/RequestUtil.java"

    /**
     * Decode and return the specified URL-encoded byte array.
     *
     * @param bytes The url-encoded byte array
     * @param enc The encoding to use; if null, the default encoding is used
     * @param isQuery Is this a query string being processed
     * @exception IllegalArgumentException if a '%' character is not followed
     * by a valid 2-digit hexadecimal number
     */
    public static String URLDecode(byte[] bytes, String enc, boolean isQuery) {
    
======= fetch "public static String URLDecode(byte[] bytes, String enc) {" 44e36ea^:"java/org/apache/catalina/util/RequestUtil.java"

            if (b == '+') {

======= fetch "public void setSubmit(String s) {" 8aa247e^:"webapps/examples/WEB-INF/classes/sessions/DummyCart.java"

    public void processRequest(HttpServletRequest request) {
======= fetch "public void processRequest(HttpServletRequest request) {" 8aa247e^:"webapps/examples/WEB-INF/classes/sessions/DummyCart.java"

        if (submit == null) 
            addItem(item);
        if (submit.equals("add"))

======= fetch "public static ApplicationFilterFactory getInstance() {" a6ea14d^:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

            comet = req.isComet();
======= fetch "public static ApplicationFilterFactory getInstance() {" a6ea14d^:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

                if (comet) {
                    req.setFilterChain(filterChain);
                }
======= fetch "public static ApplicationFilterFactory getInstance() {" a6ea14d^:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

            comet = req.isComet();

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * <p>Representation of a security role reference for a web application, as
 * represented in a <code>&lt;security-role-ref&gt;</code> element
 * in the deployment descriptor.</p>
 *
 * @author Mark Thomas
 * @version $Revision$ $Date$
 * @since Tomcat 5.5
 */
    // ------------------------------------------------------------- Properties
    /**
     * The (required) role name.
     */
    private String name = null;
    public String getName() {
        return (this.name);
    }
    public void setName(String name) {
        this.name = name;
    }
    /**
     * The optional role link.
     */
    private String link = null;
    public String getLink() {
        return (this.link);
    }
    public void setLink(String link) {
        this.link = link;
    }
    // --------------------------------------------------------- Public Methods
    /**
     * Return a String representation of this object.
     */
    public String toString() {
        StringBuffer sb = new StringBuffer("SecurityRoleRef[");
        sb.append("name=");
        sb.append(name);
        if (link != null) {
            sb.append(", link=");
            sb.append(link);
        }
        sb.append("]");
        return (sb.toString());
    }
======= fetch "public void addRuleInstances(Digester digester) {" ba25bfb^:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addCallMethod(prefix + "web-app/servlet/security-role-ref",
                               "addSecurityReference", 2);
        digester.addCallParam(prefix + "web-app/servlet/security-role-ref/role-link", 1);
        digester.addCallParam(prefix + "web-app/servlet/security-role-ref/role-name", 0);
======= fetch "public void begin(String namespace, String name, Attributes attributes)" ba25bfb^:"java/org/apache/catalina/startup/WebRuleSet.java"

        Context context = (Context) digester.peek(digester.getCount() - 1);
======= fetch "public void body(String text)" ba25bfb^:"java/org/apache/catalina/startup/WebRuleSet.java"

        override an env-entry in web.xml.

======= fetch "public JavacErrorDetail(String javaFileName," 6c6ad83^:"java/org/apache/jasper/compiler/JavacErrorDetail.java"

            InputStream is = null;
            FileInputStream  fis = null;
            
======= fetch "public JavacErrorDetail(String javaFileName," 6c6ad83^:"java/org/apache/jasper/compiler/JavacErrorDetail.java"

                String[] jspLines = readFile
                    (ctxt.getResourceAsStream(jspFileName));
======= fetch "public JavacErrorDetail(String javaFileName," 6c6ad83^:"java/org/apache/jasper/compiler/JavacErrorDetail.java"

                String[] javaLines = readFile
                    (new FileInputStream(ctxt.getServletJavaFileName()));
======= fetch "public JavacErrorDetail(String javaFileName," 6c6ad83^:"java/org/apache/jasper/compiler/JavacErrorDetail.java"

            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }
                }
                if (fis != null) {
                    try {
                        fis.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }
                }

======= fetch "public void addEnvironment(ContextEnvironment environment) {" 53add24^:"java/org/apache/catalina/deploy/NamingResources.java"

            if (findEnvironment(environment.getName()).getOverride()) {
                removeEnvironment(environment.getName());
======= fetch "public void addEnvironment(ContextEnvironment environment) {" 53add24^:"java/org/apache/catalina/deploy/NamingResources.java"

                // It exists but it isn't an env or a res link...
      <fix>
        <bug>42547</bug>: Fix NPE when a ResourceLink in context.xml tries to
        override an env-entry in web.xml.
      </fix>

    static private int currFunc = 0;
    private ErrorDispatcher err;
======= fetch "public static void map(Compiler compiler, Node.Nodes page)" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

                throws JasperException {
        ELFunctionMapper map = new ELFunctionMapper();
        map.ds = new StringBuffer();
        map.ss = new StringBuffer();
        page.visit(map.new ELFunctionVisitor());
        // Append the declarations to the root node
        String ds = map.ds.toString();
        if (ds.length() > 0) {
            Node root = page.getRoot();
            new Node.Declaration(map.ss.toString(), null, root);
            new Node.Declaration("static {\n" + ds + "}\n", null, root);
        }
======= fetch "public static void map(Compiler compiler, Node.Nodes page)" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

        
        /**
         * Use a global name map to facilitate reuse of function maps.
         * The key used is prefix:function:uri.
         */
        private HashMap<String, String> gMap = new HashMap<String, String>();
        public void visit(Node.ParamAction n) throws JasperException {
            doMap(n.getValue());
            visitBody(n);
        }
        public void visit(Node.IncludeAction n) throws JasperException {
            doMap(n.getPage());
            visitBody(n);
        }
        public void visit(Node.ForwardAction n) throws JasperException {
            doMap(n.getPage());
            visitBody(n);
        }
======= fetch "public void visit(Node.SetProperty n) throws JasperException {" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

            doMap(n.getValue());
            visitBody(n);
        }
======= fetch "public void visit(Node.UseBean n) throws JasperException {" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

            doMap(n.getBeanName());
            visitBody(n);
        }
======= fetch "public void visit(Node.PlugIn n) throws JasperException {" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

            doMap(n.getHeight());
            doMap(n.getWidth());
            visitBody(n);
        }
======= fetch "public void visit(Node.JspElement n) throws JasperException {" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

            Node.JspAttribute[] attrs = n.getJspAttributes();
            for (int i = 0; attrs != null && i < attrs.length; i++) {
                doMap(attrs[i]);
            }
            doMap(n.getNameAttribute());
            visitBody(n);
        }
======= fetch "public void visit(Node.UninterpretedTag n) throws JasperException {" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

            Node.JspAttribute[] attrs = n.getJspAttributes();
            for (int i = 0; attrs != null && i < attrs.length; i++) {
                doMap(attrs[i]);
            }
            visitBody(n);
        }
======= fetch "public void visit(Node.CustomTag n) throws JasperException {" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

            Node.JspAttribute[] attrs = n.getJspAttributes();
            for (int i = 0; attrs != null && i < attrs.length; i++) {
                doMap(attrs[i]);
            }
            visitBody(n);
        }
======= fetch "public void visit(Node.ELExpression n) throws JasperException {" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

            doMap(n.getEL());
        }
======= fetch "public void visit(Node.ELExpression n) throws JasperException {" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

        private void doMap(Node.JspAttribute attr) 
                throws JasperException {
            if (attr != null) {
                doMap(attr.getEL());
            }
        }
======= fetch "private void doMap(Node.JspAttribute attr)" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

        private void doMap(ELNode.Nodes el) 
                throws JasperException {
======= fetch "private void doMap(ELNode.Nodes el)" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

            class Fvisitor extends ELNode.Visitor {
                ArrayList<ELNode.Function> funcs =
                    new ArrayList<ELNode.Function>();
                HashMap<String, String> keyMap = new HashMap<String, String>();
                public void visit(ELNode.Function n) throws JasperException {
                    String key = n.getPrefix() + ":" + n.getName();
                    if (! keyMap.containsKey(key)) {
                        keyMap.put(key,"");
                        funcs.add(n);
                    }
                }
            }
            if (el == null) {
                return;
            }
            // First locate all unique functions in this EL
            Fvisitor fv = new Fvisitor();
            el.visit(fv);
            ArrayList functions = fv.funcs;
            if (functions.size() == 0) {
                return;
            }
            // Reuse a previous map if possible
            String decName = matchMap(functions);
            if (decName != null) {
                el.setMapName(decName);
                return;
            }
        
            // Generate declaration for the map statically
            decName = getMapName();
            ss.append("static private org.apache.jasper.runtime.ProtectedFunctionMapper " + decName + ";\n");
            ds.append("  " + decName + "= ");
            ds.append("org.apache.jasper.runtime.ProtectedFunctionMapper");
            // Special case if there is only one function in the map
            String funcMethod = null;
            if (functions.size() == 1) {
                funcMethod = ".getMapForFunction";
            } else {
                ds.append(".getInstance();\n");
                funcMethod = "  " + decName + ".mapFunction";
            }
======= fetch "public void visit(ELNode.Function n) throws JasperException {" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

            for (int i = 0; i < functions.size(); i++) {
                ELNode.Function f = (ELNode.Function)functions.get(i);
                FunctionInfo funcInfo = f.getFunctionInfo();
                String key = f.getPrefix()+ ":" + f.getName();
                ds.append(funcMethod + "(\"" + key + "\", " +
                        funcInfo.getFunctionClass() + ".class, " +
                        '\"' + f.getMethodName() + "\", " +
                        "new Class[] {");
                String params[] = f.getParameters();
                for (int k = 0; k < params.length; k++) {
                    if (k != 0) {
                        ds.append(", ");
                    }
                    int iArray = params[k].indexOf('[');
                    if (iArray < 0) {
                        ds.append(params[k] + ".class");
                    }
                    else {
                        String baseType = params[k].substring(0, iArray);
                        ds.append("java.lang.reflect.Array.newInstance(");
                        ds.append(baseType);
                        ds.append(".class,");
                        // Count the number of array dimension
                        int aCount = 0;
                        for (int jj = iArray; jj < params[k].length(); jj++ ) {
                            if (params[k].charAt(jj) == '[') {
                                aCount++;
                            }
                        }
                        if (aCount == 1) {
                            ds.append("0).getClass()");
                        } else {
                            ds.append("new int[" + aCount + "]).getClass()");
                        }
                    }
                }
                ds.append("});\n");
                // Put the current name in the global function map
                gMap.put(f.getPrefix() + ':' + f.getName() + ':' + f.getUri(),
                         decName);
            }
            el.setMapName(decName);
        }
======= fetch "public void visit(ELNode.Function n) throws JasperException {" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

        private String matchMap(ArrayList functions) {
            String mapName = null;
            for (int i = 0; i < functions.size(); i++) {
                ELNode.Function f = (ELNode.Function)functions.get(i);
                String temName = (String) gMap.get(f.getPrefix() + ':' +
                                        f.getName() + ':' + f.getUri());
                if (temName == null) {
                    return null;
                }
                if (mapName == null) {
                    mapName = temName;
                } else if (!temName.equals(mapName)) {
                    // If not all in the previous match, then no match.
                    return null;
                }
            }
            return mapName;
        }
======= fetch "private String matchMap(ArrayList functions) {" 5b65cf4^:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

        private String getMapName() {
            return "_jspx_fnmap_" + currFunc++;
        }
      <fix>
        Fix XSS security vulnerability (CVE-2007-2450) in the Manager and Host
        Manager. Reported by Daiki Fukumori. (markt)
      </fix>
      <fix>
        <bug>42643</bug> Prevent creation of duplicate JSP function mapper
        variables. (markt)
      </fix>
      <fix>
        Fix XSS security vulnerabilities (CVE-2007-2449) in the examples.
        Reported by Toshiharu Sugiyama. (markt)
      </fix>

======= fetch "protected ArrayList parseRange(HttpServletRequest request," 0114b2d^:"java/org/apache/catalina/servlets/DefaultServlet.java"

        ArrayList result = new ArrayList();
======= fetch "protected boolean checkIfModifiedSince(HttpServletRequest request," 0114b2d^:"java/org/apache/catalina/servlets/DefaultServlet.java"

                    response.setHeader("ETag", getETag(resourceAttributes));
======= fetch "protected boolean checkIfNoneMatch(HttpServletRequest request," 0114b2d^:"java/org/apache/catalina/servlets/DefaultServlet.java"

         <bug>42449</bug>:
         JNDIRealm does not catch NullPointerException for Sun's
         LDAP provider (See bug for details) (funkman)
      </fix>
      <fix>
         <bug>42444</bug>: prevent NPE for AccessLogValve
         Patch provided by Nils Hammar (funkman)
         <bug>39875</bug>: Fix BPE in RealmBase.init(). Port of yoavs's fix from
         Tomcat 5. (markt)

======= fetch "public void invoke(Request request, Response response)" 71eccb3^:"java/org/apache/catalina/valves/ErrorReportValve.java"

        if (response.isAppCommitted()) {

======= fetch "public void backgroundProcess() {" 0ea4c7c^:"java/org/apache/catalina/realm/RealmBase.java"

        ArrayList results = null;
======= fetch "public void backgroundProcess() {" 0ea4c7c^:"java/org/apache/catalina/realm/RealmBase.java"

                                results = new ArrayList();
======= fetch "public void backgroundProcess() {" 0ea4c7c^:"java/org/apache/catalina/realm/RealmBase.java"

                            results = new ArrayList();
======= fetch "public void backgroundProcess() {" 0ea4c7c^:"java/org/apache/catalina/realm/RealmBase.java"

                        results = new ArrayList();
======= fetch "public void backgroundProcess() {" 0ea4c7c^:"java/org/apache/catalina/realm/RealmBase.java"

                        results = new ArrayList();
======= fetch "public void backgroundProcess() {" 0ea4c7c^:"java/org/apache/catalina/realm/RealmBase.java"

    private SecurityConstraint [] resultsToArray(ArrayList results) {
======= fetch "public void init() {" 0ea4c7c^:"java/org/apache/catalina/realm/RealmBase.java"

        this.containerLog = container.getLogger();
======= fetch "public void init() {" 0ea4c7c^:"java/org/apache/catalina/realm/RealmBase.java"

        // We want logger as soon as possible
        if (container != null) {
            this.containerLog = container.getLogger();
        }
      <fix>
         <bug>39875</bug>: Fix BPE in RealmBase.init(). Port of yoavs's fix from
         Tomcat 5. (markt)
      </fix>

======= fetch "public NamedAttribute(String qName, Attributes attrs," 5e188bc^:"java/org/apache/jasper/compiler/Node.java"

            temporaryVariableName = JspUtil.nextTemporaryVariableName();
======= fetch "public String getTemporaryVariableName() {" 5e188bc^:"java/org/apache/jasper/compiler/Node.java"

            if (temporaryVariableName == null) {
                temporaryVariableName = JspUtil.nextTemporaryVariableName();
            }
  <subsection name="Jasper">
    <changelog>
      <fix>
        <bug>42438</bug> Duplicate temporary variables were created when
        jsp:attribute was used in conjunction with custom tags. Patch provided
        by Brian Lenz. (markt)
      </fix>
    </changelog>
  </subsection>

======= fetch "public Comparable getComparableObject(Session session) {" 33c9949^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "</tr>\n";
======= fetch "public Comparable getComparableObject(Session session) {" 33c9949^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "</tr>\n";
======= fetch "public Comparable getComparableObject(Session session) {" 33c9949^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "</tr>\n";

======= fetch "public void addElement(StringBuffer buf, Date date, Request request," 776736f^:"java/org/apache/catalina/valves/AccessLogValve.java"

                buf.append(request.getProtocol());

======= fetch "protected boolean restoreRequest(Request request, Session session)" 637acc5^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

                contentType.setString("application/x-www-form-urlencoded");
======= fetch "protected void saveRequest(Request request, Session session)" 637acc5^:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

            saved.setContentType(request.getContentType());
======= fetch "public void setBody(ByteChunk body) {" 637acc5^:"java/org/apache/catalina/authenticator/SavedRequest.java"

    
    /**
     * The content type of the request, used if this is a POST.
     */
    private String contentType = null;
    
    public String getContentType() {
        return (this.contentType);
    }
    
    public void setContentType(String contentType) {
        this.contentType = contentType;
    }
  <subsection name="Catalina">
    <changelog>
      <fix>
         <bug>42361</bug>: Handle multi-part forms when saving requests during
         FORM authentication process. Patch provided by Peter Runge. (markt)
      </fix>
    </changelog>
  </subsection>

======= fetch "public Connector createConnector(String address, int port," 9546005^:"java/org/apache/catalina/startup/Embedded.java"

                connector.setProperty("SSLEnabled","true");
======= fetch "public Connector createConnector(String address, int port," 9546005^:"java/org/apache/catalina/startup/Embedded.java"

            } else {
                connector = new Connector(protocol);

======= fetch "public SocketState process(long socket)" 4a04722^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

            if (!comet) {
                // Next request
                inputBuffer.nextRequest();
                outputBuffer.nextRequest();
            }
            
======= fetch "public void endRequest() {" 4a04722^:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        // Next request
        inputBuffer.nextRequest();
        outputBuffer.nextRequest();
        
======= fetch "public SocketState process(NioChannel socket)" 4a04722^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            if (!comet) {
                // Next request
                inputBuffer.nextRequest();
                outputBuffer.nextRequest();
            }
======= fetch "public void endRequest() {" 4a04722^:"java/org/apache/coyote/http11/Http11NioProcessor.java"

        // Next request
        inputBuffer.nextRequest();
        outputBuffer.nextRequest();
======= fetch "public void nextRequest() {" 4a04722^:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

        //System.out.println("LV-pos: " + (lastValid - pos));

======= fetch "private void tldScanJar(String resourcePath) throws Exception {" f9ddaba^:"java/org/apache/catalina/startup/TldConfig.java"

        File file = new File(url.getFile());
        file = file.getCanonicalFile();
======= fetch "private Map getJarPaths() {" f9ddaba^:"java/org/apache/catalina/startup/TldConfig.java"

                    // Expect file URLs
======= fetch "private Map getJarPaths() {" f9ddaba^:"java/org/apache/catalina/startup/TldConfig.java"

                    File file = new File(urls[i].getFile());

======= fetch "public void service(HttpServletRequest request," 508f513^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                response.setDateHeader("Retry-After", available);
                response.sendError
                    (HttpServletResponse.SC_SERVICE_UNAVAILABLE,
                     Localizer.getMessage("jsp.error.unavailable"));

    private static Log log = LogFactory.getLog(StandardWrapperValve.class);
======= fetch "public final void invoke(Request request, Response response)" c3d2ce4^:"java/org/apache/catalina/core/StandardWrapperValve.java"

            container.getLogger().error(
                    sm.getString("standardWrapper.allocateException",
                            wrapper.getName()), e);

    // Basically return everything after ";charset="
    // If no charset specified, use the HTTP default (ASCII) character set.
    public static String getCharsetFromContentType(String type) {
        if (type == null) {
            return null;
        }
        int semi = type.indexOf(";");
        if (semi == -1) {
            return null;
        }
        int charsetLocation = type.indexOf("charset=", semi);
        if (charsetLocation == -1) {
            return null;
        }
        // The charset value in a Content-Type header is allowed to be quoted
        // and charset values can't contain quotes.  Just convert any quote
        // chars into spaces and let trim clean things up.
        afterCharset = afterCharset.replace('"', ' ');
        String encoding = afterCharset.trim();
        return encoding;

======= fetch "protected void readConfiguration(InputStream is, ClassLoader classLoader)" fa2b746^:"java/org/apache/juli/ClassLoaderLogManager.java"

            // Add handlers to the root logger, if any are defined using the .handlers property.
            if (rootHandlers != null) {
                StringTokenizer tok2 = new StringTokenizer(rootHandlers, ",");
                while (tok2.hasMoreTokens()) {
                    String handlerName = (tok2.nextToken().trim());
                    Handler handler = (Handler) info.handlers.get(handlerName);
                    if (handler != null) {
                        localRootLogger.addHandler(handler);
                    }
                }
            }
            

======= fetch "public Servlet getServlet()" 3d27771^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                    Servlet servlet = null;
                    
======= fetch "public Servlet getServlet()" 3d27771^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                        theServlet = (Servlet) servletClass.newInstance();
======= fetch "public Servlet getServlet()" 3d27771^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                           annotationProcessor.processAnnotations(theServlet);
                           annotationProcessor.postConstruct(theServlet);
======= fetch "public Servlet getServlet()" 3d27771^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                    theServlet.init(config);
======= fetch "public Servlet getServlet()" 3d27771^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                    theServlet = servlet;
      <fix>
        <bug>42072</bug> Don't call destroy() if the associated init() fails.
        Patch provided by Kawasima Kazuh. (markt)
      </fix>

======= fetch "protected void deploy(PrintWriter writer, String config," d721522^:"java/org/apache/catalina/manager/ManagerServlet.java"

                        configBase.mkdirs();

======= fetch "public void setAddress(Member member) {" 2049b78^:"java/org/apache/catalina/ha/authenticator/SingleSignOnMessage.java"

        <bug>41703</bug> SingleSignOnMessage invalid setter, patch provided by Nils Hammar (fhanik)
      </fix>
      <fix>

======= fetch "public void expire(boolean notify, boolean notifyCluster) {" 12d912d^:"java/org/apache/catalina/ha/session/DeltaSession.java"

                                       ((DeltaManager)manager).getName(), 

======= fetch "public void setAttribute(String name, Object value) {" 4f96d21^:"java/org/apache/catalina/core/ApplicationContext.java"

    protected StandardContext getContext() {
        return this.context;
    }
    
    protected Map getReadonlyAttributes() {
        return this.readOnlyAttributes;
    }
======= fetch "public void setAttribute(String name, Object value) {" 4f96d21^:"java/org/apache/catalina/core/ApplicationContext.java"

    void clearAttributes() {
======= fetch "public ServletContext getServletContext() {" 4f96d21^:"java/org/apache/catalina/ha/context/ReplicatedContext.java"

        if (context == null) {
            context = new ReplApplContext(getBasePath(), this);
            if (getAltDDName() != null)
                context.setAttribute(Globals.ALT_DD_ATTR,getAltDDName());
        }
======= fetch "public void setAttributeMap(AbstractMap map) {" 4f96d21^:"java/org/apache/catalina/ha/context/ReplicatedContext.java"

        
        public void removeAttribute(String name) {
            //do nothing
            super.removeAttribute(name);
        }
        
        public void setAttribute(String name, Object value) {
            //do nothing
            super.setAttribute(name,value);
        }
        
======= fetch "public void setAttributeMap(AbstractMap map) {" 4f96d21^:"java/org/apache/catalina/ha/context/ReplicatedContext.java"

======= fetch "public Object remove(Object key) {" 4f96d21^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        return remove(key,true);
    }
    public Object remove(Object key, boolean notify) {
======= fetch "public Object remove(Object key) {" 4f96d21^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            if (getMapMembers().length > 0 ) {
======= fetch "public void putAll(Map m) {" 4f96d21^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    
======= fetch "public void clear() {" 4f96d21^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            //only delete active keys
            Iterator keys = keySet().iterator();
            while ( keys.hasNext() ) remove(keys.next());
======= fetch "public Set entrySet() {" 4f96d21^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                MapEntry entry = (MapEntry)e.getValue();
                if ( entry.isPrimary() ) set.add(entry);
======= fetch "public Set keySet() {" 4f96d21^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                MapEntry entry = (MapEntry)e.getValue();
                if ( entry.isPrimary() ) set.add(entry.getKey());
======= fetch "public Set keySet() {" 4f96d21^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

======= fetch "public Object setValue(Object value) {" 4f96d21^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            this.value = (Serializable) value;
======= fetch "public Object setKey(Object key) {" 4f96d21^:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            this.key = (Serializable)key;

======= fetch "protected void prepareRequest() {" 7fd4fa8^:"java/org/apache/coyote/http11/Http11Processor.java"

            if (log.isDebugEnabled()) {
                log.debug(sm.getString("http11processor.request.prepare")+
                          " Unsupported HTTP version \""+protocolMB+"\"");
            }
======= fetch "protected void prepareRequest() {" 7fd4fa8^:"java/org/apache/coyote/http11/Http11Processor.java"

                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("http11processor.request.prepare")+
                              " Unsupported transfer encoding \""+encodingName+"\"");
                }
======= fetch "protected void prepareRequest() {" 7fd4fa8^:"java/org/apache/coyote/http11/Http11Processor.java"

            if (log.isDebugEnabled()) {
                log.debug(sm.getString("http11processor.request.prepare")+
                          " host header missing");
            }
      <add>
        <bug>41675</bug> Add a couple of DEBUG-level logging statements to Http11Processors
          when sending error responses.  Patch by Ralf Hauser. (yoavs)
      </add>

    protected List roleClasses = new ArrayList();
    protected List userClasses = new ArrayList();
======= fetch "public void setContainer(Container container) {" 400d684^:"java/org/apache/catalina/realm/JAASRealm.java"

    /**
     * Comma-delimited list of <code>java.security.Principal</code> classes
     * that represent security roles.
     */
    protected String roleClassNames = null;
    public String getRoleClassNames() {
        return (this.roleClassNames);
    }
======= fetch "public void setRoleClassNames(String roleClassNames) {" 400d684^:"java/org/apache/catalina/realm/JAASRealm.java"

        roleClasses.clear();
        String temp = this.roleClassNames;
        if (temp == null) {
            return;
        }
        while (true) {
            int comma = temp.indexOf(',');
            if (comma < 0) {
                break;
            }
            roleClasses.add(temp.substring(0, comma).trim());
            temp = temp.substring(comma + 1);
        }
        temp = temp.trim();
        if (temp.length() > 0) {
            roleClasses.add(temp);
        }
    }
    /**
     * Comma-delimited list of <code>java.security.Principal</code> classes
     * that represent individual users.
     */
    protected String userClassNames = null;
    public String getUserClassNames() {
        return (this.userClassNames);
    }
======= fetch "public void setUserClassNames(String userClassNames) {" 400d684^:"java/org/apache/catalina/realm/JAASRealm.java"

        userClasses.clear();
        String temp = this.userClassNames;
        if (temp == null) {
            return;
        }
        while (true) {
            int comma = temp.indexOf(',');
            if (comma < 0) {
                break;
            }
            userClasses.add(temp.substring(0, comma).trim());
            temp = temp.substring(comma + 1);
        }
        temp = temp.trim();
        if (temp.length() > 0) {
            userClasses.add(temp);
        }
======= fetch "protected Principal createPrincipal(String username, Subject subject) {" 400d684^:"java/org/apache/catalina/realm/JAASRealm.java"

        List roles = new ArrayList();

======= fetch "protected void generateClass(String[] smap)" 455b6f8^:"java/org/apache/jasper/compiler/JDTCompiler.java"

                FileInputStream is = null;
======= fetch "protected void generateClass(String[] smap)" 455b6f8^:"java/org/apache/jasper/compiler/JDTCompiler.java"

                    InputStreamReader isReader =
                        new InputStreamReader(new FileInputStream(sourceFile),
                                ctxt.getOptions().getJavaEncoding());
                    Reader reader = new BufferedReader(isReader);
======= fetch "protected void generateClass(String[] smap)" 455b6f8^:"java/org/apache/jasper/compiler/JDTCompiler.java"

                } finally {
                    if (is != null) {
                        try {
                            is.close();
                        } catch (IOException exc) {
                            // Ignore
                        }
                    }

======= fetch "public synchronized void start() throws LifecycleException {" e33b67a^:"java/org/apache/catalina/realm/MemoryRealm.java"

            throw new LifecycleException("memoryRealm.readXml", e);

======= fetch "protected boolean checkIfModifiedSince(HttpServletRequest request," 9ac3428^:"java/org/apache/catalina/servlets/DefaultServlet.java"

                    && (lastModified <= headerValue + 1000)) {
======= fetch "protected boolean checkIfUnmodifiedSince(HttpServletRequest request," 9ac3428^:"java/org/apache/catalina/servlets/DefaultServlet.java"

                if ( lastModified > (headerValue + 1000)) {

======= fetch "public void loadOnStartup(Container children[]) {" 01d38a5^:"java/org/apache/catalina/core/StandardContext.java"

            if (loadOnStartup == 0)     // Arbitrarily put them last
                loadOnStartup = Integer.MAX_VALUE;

======= fetch "public final void invoke(Request request, Response response)" 8ba8334^:"java/org/apache/catalina/core/StandardWrapperValve.java"

            container.getLogger().warn(sm.getString("standardWrapper.serviceException",
======= fetch "public final void invoke(Request request, Response response)" 8ba8334^:"java/org/apache/catalina/core/StandardWrapperValve.java"

            container.getLogger().warn(sm.getString("standardWrapper.serviceException",
======= fetch "public void event(Request request, Response response, CometEvent event)" 8ba8334^:"java/org/apache/catalina/core/StandardWrapperValve.java"

            container.getLogger().warn(sm.getString("standardWrapper.serviceException",
======= fetch "public void event(Request request, Response response, CometEvent event)" 8ba8334^:"java/org/apache/catalina/core/StandardWrapperValve.java"

            container.getLogger().warn(sm.getString("standardWrapper.serviceException",

    private static final boolean THREAD_LOCAL_POOL = 
        Boolean.valueOf(System.getProperty("org.apache.jasper.runtime.JspFactoryImpl.THREAD_LOCAL_POOL", "true")).booleanValue();
    private SimplePool pool = new SimplePool( 100 );
======= fetch "private PageContext internalGetPageContext(Servlet servlet, ServletRequest reque" 4612c8a^:"java/org/apache/jasper/runtime/JspFactoryImpl.java"

            if( USE_POOL ) {
                pc = (PageContext) pool.get();
                if( pc == null ) {
======= fetch "private void internalReleasePageContext(PageContext pc) {" 4612c8a^:"java/org/apache/jasper/runtime/JspFactoryImpl.java"

            pool.put( pc );
======= fetch "public Object run() {" 4612c8a^:"java/org/apache/jasper/runtime/JspFactoryImpl.java"

    protected final class PageContextPool  {
        private PageContext[] pool;
        private int current = -1;
        public PageContextPool() {
            this.pool = new PageContext[POOL_SIZE];
        }
        public void put(PageContext o) {
            if (current < (POOL_SIZE - 1)) {
                current++;
                pool[current] = o;
            }
        }
        public PageContext get() {
            PageContext item = null;
            if (current >= 0) {
                item = pool[current];
                current--;
            }
            return item;
        }
    }

======= fetch "private void generateInit() {" 1a8c492^:"java/org/apache/jasper/compiler/Generator.java"

        out.print(" = JspFactory.getDefaultFactory().getJspApplicationContext(");
======= fetch "private void genPreambleStaticInitializers() throws JasperException {" 1a8c492^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();");
        out.println();
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" 1a8c492^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("JspFactory _jspxFactory = null;");
======= fetch "private void generatePreamble(Node.Nodes page) throws JasperException {" 1a8c492^:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("_jspxFactory = JspFactory.getDefaultFactory();");
======= fetch "private void generatePostamble(Node.Nodes page) {" 1a8c492^:"java/org/apache/jasper/compiler/Generator.java"

                .printil("if (_jspxFactory != null) _jspxFactory.releasePageContext(_jspx_page_context);");
    static {
        if( JspFactory.getDefaultFactory() == null ) {
            JspFactoryImpl factory = new JspFactoryImpl();
            if( System.getSecurityManager() != null ) {
                String basePackage = "org.apache.jasper.";
                try {
                    factory.getClass().getClassLoader().loadClass( basePackage +
                                                                   "runtime.JspFactoryImpl$PrivilegedGetPageContext");
                    factory.getClass().getClassLoader().loadClass( basePackage +
                                                                   "runtime.JspFactoryImpl$PrivilegedReleasePageContext");
                    factory.getClass().getClassLoader().loadClass( basePackage +
                                                                   "runtime.JspRuntimeLibrary");
                    factory.getClass().getClassLoader().loadClass( basePackage +
                                                                   "runtime.JspRuntimeLibrary$PrivilegedIntrospectHelper");
                    factory.getClass().getClassLoader().loadClass( basePackage +
                                                                   "runtime.ServletResponseWrapperInclude");
                    factory.getClass().getClassLoader().loadClass( basePackage +
                                                                   "servlet.JspServletWrapper");
                } catch (ClassNotFoundException ex) {
                    org.apache.juli.logging.LogFactory.getLog( HttpJspBase.class )
                        .error("Jasper JspRuntimeContext preload of class failed: " +
                                       ex.getMessage(), ex);
                }
            }
            JspFactory.setDefaultFactory(factory);
        }
    }

======= fetch "private boolean matchFiltersURL(FilterMap filterMap, String requestPath) {" 8b0d130^:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

        if (filterMap.getAllMatch())
======= fetch "private boolean matchFiltersServlet(FilterMap filterMap," 8b0d130^:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

        }
        // Check the specific "*" special servlet name
        else if (filterMap.getMatchAllServletNames()) {
            return (true);
======= fetch "public void addServletName(String servletName) {" 8b0d130^:"java/org/apache/catalina/deploy/FilterMap.java"

        String[] results = new String[servletNames.length + 1];
        System.arraycopy(servletNames, 0, results, 0, servletNames.length);
        results[servletNames.length] = servletName;
        servletNames = results;
======= fetch "public void addServletName(String servletName) {" 8b0d130^:"java/org/apache/catalina/deploy/FilterMap.java"

     * The flag that indicates this mapping will match all.
======= fetch "public void addServletName(String servletName) {" 8b0d130^:"java/org/apache/catalina/deploy/FilterMap.java"

    private boolean allMatch = false;
======= fetch "public void addServletName(String servletName) {" 8b0d130^:"java/org/apache/catalina/deploy/FilterMap.java"

    public boolean getAllMatch() {
        return allMatch;
======= fetch "public boolean getAllMatch() {" 8b0d130^:"java/org/apache/catalina/deploy/FilterMap.java"

     * The flag that indicates this mapping will match all servlet-names
     */
    private boolean matchAllServletNames = false;
    
    public boolean getMatchAllServletNames() {
        return matchAllServletNames;
    }
    
    /**
======= fetch "public void addURLPattern(String urlPattern) {" 8b0d130^:"java/org/apache/catalina/deploy/FilterMap.java"

            this.allMatch = true;

======= fetch "public int write(ByteBuffer buf, NioChannel socket, Selector selector, long writ" fce171f^:"java/org/apache/tomcat/util/net/NioSelectorPool.java"

        if ( socket.getBufHandler().getWriteBuffer()!= buf ) {
            socket.getBufHandler().getWriteBuffer().put(buf);
            buf = socket.getBufHandler().getWriteBuffer();
        }

      <fix>
        <bug>39572</bug>: Improvements to CompressionFilter example provided by
        Eric Hedstrm. (markt)
      </fix>
======= fetch "public CompressionResponseStream(HttpServletResponse response) throws IOExceptio" f06d41f^:"webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java"

    protected GZIPOutputStream gzipstream = null;
======= fetch "public void writeToGZip(byte b[], int off, int len) throws IOException {" f06d41f^:"webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java"

            response.addHeader("Content-Encoding", "gzip");
            gzipstream = new GZIPOutputStream(output);
======= fetch "public void setContentLength(int length) {" f06d41f^:"webapps/examples/WEB-INF/classes/compressionFilters/CompressionServletResponseWrapper.java"

    /**
     * Returns character from content type. This method was taken from tomcat.
     * @author rajo
     */
    private static String getCharsetFromContentType(String type) {
        if (type == null) {
            return null;
        }
        int semi = type.indexOf(";");
        if (semi == -1) {
            return null;
        }
        String afterSemi = type.substring(semi + 1);
        int charsetLocation = afterSemi.indexOf("charset=");
        if(charsetLocation == -1) {
            return null;
        } else {
            String afterCharset = afterSemi.substring(charsetLocation + 8);
            String encoding = afterCharset.trim();
            return encoding;
        }
    }

======= fetch "public EmbeddedServletOptions(ServletConfig config," 39fe247^:"java/org/apache/jasper/EmbeddedServletOptions.java"

                if (this.checkInterval == 0) {
                    this.checkInterval = 300;
                    if (log.isWarnEnabled()) {
                        log.warn(Localizer.getMessage("jsp.warning.checkInterval"));
                    }
                }

    public static final String CERT_METHOD = "CLIENT-CERT";
     *     will return BASIC, CLIENT-CERT, DIGEST, FORM, or <code>null</code>
======= fetch "public boolean authenticate(Request request," dc33554^:"java/org/apache/catalina/authenticator/SSLAuthenticator.java"

        // BASIC or FORM, which are less secure than the CLIENT-CERT auth-type
======= fetch "protected void register(String ssoId, Principal principal, String authType," dc33554^:"java/org/apache/catalina/authenticator/SingleSignOn.java"

     * following DIGEST or CLIENT-CERT authentication) to be updated with
======= fetch "protected void register(String ssoId, Principal principal, String authType," dc33554^:"java/org/apache/catalina/authenticator/SingleSignOn.java"

     * @param authType  the type of authenticator used (BASIC, CLIENT-CERT,
     * @param authType  the type of authenticator used (BASIC, CLIENT-CERT,
======= fetch "public synchronized void removeSession(Session session) {" dc33554^:"java/org/apache/catalina/authenticator/SingleSignOnEntry.java"

     * @return "BASIC", "CLIENT-CERT", "DIGEST", "FORM" or "NONE"
======= fetch "public String getUsername() {" dc33554^:"java/org/apache/catalina/authenticator/SingleSignOnEntry.java"

     * @param authType  the type of authenticator used (BASIC, CLIENT-CERT,

======= fetch "protected void register(Request request, Response response," 11b9c92^:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

            // Bugzilla 41217
            cookie.setSecure(request.isSecure());
      <fix>
        <bug>41217</bug>: Set secure attribute on SSO cookie when cookie is
        created during a secure request. Patch provided by Chris Halstead.
        (markt)
      </fix>

======= fetch "private void serviceJspFile(HttpServletRequest request," 3a6225a^:"java/org/apache/jasper/servlet/JspServlet.java"

                                           jspUri);

 * 
 * 
    
======= fetch "public void lifecycleEvent(LifecycleEvent event) {" a1b1bed^:"java/org/apache/catalina/core/JasperListener.java"

                this.getClass().getClassLoader().loadClass
                    ("org.apache.jasper.compiler.JspRuntimeContext");

                        // out.println( "<PARAM name=\"blah\"
                        out.printil("out.write( \"<PARAM name=\\\""
            // <OBJECT ...>
            String s0 = "<OBJECT"
            // <PARAM > for java_code
            s0 = "<PARAM name=\"java_code\"" + makeAttr("value", code) + '>';
            // <PARAM > for java_codebase
                s0 = "<PARAM name=\"java_codebase\""
            // <PARAM > for java_archive
                s0 = "<PARAM name=\"java_archive\""
            // <PARAM > for type
            s0 = "<PARAM name=\"type\""
             * generate a <PARAM> for each <jsp:param> in the plugin body
            out.printil("out.write(" + quote("<COMMENT>") + ");");
            out.printil("out.write(" + quote("<NOEMBED>") + ");");
            out.printil("out.write(" + quote("</NOEMBED>") + ");");
            out.printil("out.write(" + quote("</COMMENT>") + ");");
            out.printil("out.write(" + quote("</OBJECT>") + ");");

======= fetch "public FileHandler() {" c6b3f71^:"java/org/apache/juli/FileHandler.java"

        configure();
        open();
======= fetch "public FileHandler(String directory, String prefix, String suffix) {" c6b3f71^:"java/org/apache/juli/FileHandler.java"

        this();
======= fetch "public FileHandler(String directory, String prefix, String suffix) {" c6b3f71^:"java/org/apache/juli/FileHandler.java"

        configure();
        open();
======= fetch "private void configure() {" c6b3f71^:"java/org/apache/juli/FileHandler.java"

        LogManager manager = LogManager.getLogManager();
======= fetch "private void configure() {" c6b3f71^:"java/org/apache/juli/FileHandler.java"

        directory = getProperty(className + ".directory", "logs");
        prefix = getProperty(className + ".prefix", "juli.");
        suffix = getProperty(className + ".suffix", ".log");

    private static final String JSP_VERSION = "2.0";
    private static final String JSP_VERSION = "2.0";
======= fetch "public void visit(Node.JspRoot n) throws JasperException {" 514256e^:"java/org/apache/jasper/compiler/Validator.java"

            if (!version.equals("1.2") && !version.equals("2.0")) {

    /**
======= fetch "public static String toString(ByteChunk bc) {" de5c3b7^:"java/org/apache/tomcat/util/buf/StringCache.java"

            if (byteEnabled) {
======= fetch "public static String toString(CharChunk cc) {" de5c3b7^:"java/org/apache/tomcat/util/buf/StringCache.java"

            if (charEnabled) {

======= fetch "protected void setupFromRequest(HttpServletRequest req)" b70962f^:"java/org/apache/catalina/servlets/CGIServlet.java"

            // If request is HEAD or GET and Query String does not contain
            // an unencoded "=" this is an indexed query. Parsed Query String
            // forms command line parameters for cgi command.
            if (!"GET".equals(req.getMethod()) &&
                    !"HEAD".equals(req.getMethod()))
                return;
            
            String qs = req.getQueryString();
            
            if (qs == null || qs.indexOf("=")>0)
                return;
            
            int delimIndex = 0;
            int lastDelimIndex = 0;
            delimIndex = qs.indexOf("+");
            
            while (delimIndex >0) {
                cmdLineParameters.add(URLDecoder.decode(qs.substring(
                        lastDelimIndex,delimIndex),parameterEncoding));
                lastDelimIndex = delimIndex + 1;
                delimIndex = qs.indexOf("+",lastDelimIndex);
======= fetch "protected void setupFromRequest(HttpServletRequest req)" b70962f^:"java/org/apache/catalina/servlets/CGIServlet.java"

            cmdLineParameters.add(URLDecoder.decode(qs.substring(
                    lastDelimIndex),parameterEncoding));

======= fetch "protected InputStream renderXml(String contextPath," cb2c655^:"java/org/apache/catalina/servlets/DefaultServlet.java"

                sb.append(trimmed);
======= fetch "protected InputStream renderHtml(String contextPath, CacheEntry cacheEntry)" cb2c655^:"java/org/apache/catalina/servlets/DefaultServlet.java"

                sb.append(trimmed);

 * Subclass implementation of <b>java.net.URLClassLoader</b> that knows how
 * to load classes from disk directories, as well as local and remote JAR
 * files.  It also implements the <code>Reloader</code> interface, to provide
 * automatic reloading support to the associated loader.
 * <p>
 * In all cases, URLs must conform to the contract specified by
 * <code>URLClassLoader</code> - any URL that ends with a "/" character is
 * assumed to represent a directory; all other URLs are assumed to be the
 * address of a JAR file.
 * <p>
 * <strong>IMPLEMENTATION NOTE</strong> - Local repositories are searched in
 * the order they are added via the initial constructor and/or any subsequent
 * calls to <code>addRepository()</code>.
 * <p>
 * <strong>IMPLEMENTATION NOTE</strong> - At present, there are no dependencies
 * from this class to any other Catalina class, so that it could be used
 * independently.
        <bug>37509</bug>: Do not remove whitespace from the end of values
        defined in logging.properties files. (markt)

======= fetch "protected void parseParameters() {" e713e77^:"java/org/apache/catalina/connector/Request.java"

                ; // Ignore
======= fetch "public void processParameters( byte bytes[], int start, int len," e713e77^:"java/org/apache/tomcat/util/http/Parameters.java"

                log.warn("Parameters: Invalid chunk ignored.");
======= fetch "public void processParameters( byte bytes[], int start, int len," e713e77^:"java/org/apache/tomcat/util/http/Parameters.java"

                // XXX log it ?
======= fetch "public void processParameters( byte bytes[], int start, int len," e713e77^:"java/org/apache/tomcat/util/http/Parameters.java"

                log.warn("Parameters: Character decoding failed. " + 
                         "Parameter skipped.", e);
      <fix>
        <bug>40860</bug>: Log exceptions and other problems during parameter
        processing. (markt)
      </fix>

======= fetch "protected String replace(String str) {" a6d6962^:"java/org/apache/juli/ClassLoaderLogManager.java"

        String result = str.trim();

======= fetch "protected String getName() {" be9d523^:"java/org/apache/catalina/realm/JDBCRealm.java"

    protected String getPassword(String username) {
======= fetch "protected void release(Connection dbConnection) {" be9d523^:"java/org/apache/catalina/realm/JDBCRealm.java"

    protected PreparedStatement roles(Connection dbConnection, String username)

======= fetch "private void checkXmlAttributes(Node.CustomTag n," f7ca96d^:"java/org/apache/jasper/compiler/Validator.java"

                                if (!deferred && (tldAttrs[j].isDeferredMethod() || tldAttrs[j].isDeferredValue())) {

======= fetch "private void doForward(ServletRequest request, ServletResponse response)" 22d1ad7^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        if (Globals.STRICT_SERVLET_COMPLIANCE) {
            // Check SRV.8.2 / SRV.14.2.5.1 compliance
            checkSameObjects();
        }
======= fetch "private void doInclude(ServletRequest request, ServletResponse response)" 22d1ad7^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        if (Globals.STRICT_SERVLET_COMPLIANCE) {
            // Check SRV.8.2 / SRV.14.2.5.1 compliance
            checkSameObjects();
        }
        
======= fetch "private ServletResponse wrapResponse() {" 22d1ad7^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

    private void checkSameObjects() throws ServletException {
        ServletRequest originalRequest =
            ApplicationFilterChain.getLastServicedRequest();
        ServletResponse originalResponse =
            ApplicationFilterChain.getLastServicedResponse();
        
        // Some forwards, eg from valves will not set original values 
        if (originalRequest == null || originalResponse == null) {
            return;
        }
        
        boolean same = false;
        ServletRequest dispatchedRequest = appRequest;
        
        while (!same) {
            if (originalRequest.equals(dispatchedRequest)) {
                same = true;
            }
            if (!same && dispatchedRequest instanceof ServletRequestWrapper) {
                dispatchedRequest =
                    ((ServletRequestWrapper) dispatchedRequest).getRequest();
            } else {
                break;
            }
        }
        if (!same) {
            throw new ServletException(sm.getString(
                    "applicationDispatcher.specViolation.request"));
        }
        
        same = false;
        ServletResponse dispatchedResponse = appResponse;
        
        while (!same) {
            if (originalResponse.equals(dispatchedResponse)) {
                same = true;
            }
            
            if (!same && dispatchedResponse instanceof ServletResponseWrapper) {
                dispatchedResponse =
                    ((ServletResponseWrapper) dispatchedResponse).getResponse();
            } else {
                break;
            }
        }
======= fetch "private ServletResponse wrapResponse() {" 22d1ad7^:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        if (!same) {
            throw new ServletException(sm.getString(
                    "applicationDispatcher.specViolation.response"));
        }
    }
    // Used to enforce requirements of SRV.8.2 / SRV.14.2.5.1
    private final static ThreadLocal lastServicedRequest;
    private final static ThreadLocal lastServicedResponse;
    static {
        if (Globals.STRICT_SERVLET_COMPLIANCE) {
            lastServicedRequest = new ThreadLocal();
            lastServicedResponse = new ThreadLocal();
        } else {
            lastServicedRequest = null;
            lastServicedResponse = null;
        }
    }
======= fetch "private void internalDoFilter(ServletRequest request," 22d1ad7^:"java/org/apache/catalina/core/ApplicationFilterChain.java"

            if (Globals.STRICT_SERVLET_COMPLIANCE) {
                lastServicedRequest.set(request);
                lastServicedResponse.set(response);
            }
======= fetch "private void internalDoFilter(ServletRequest request," 22d1ad7^:"java/org/apache/catalina/core/ApplicationFilterChain.java"

        } finally {
            if (Globals.STRICT_SERVLET_COMPLIANCE) {
                lastServicedRequest.set(null);
                lastServicedResponse.set(null);
            }
======= fetch "private void internalDoFilter(ServletRequest request," 22d1ad7^:"java/org/apache/catalina/core/ApplicationFilterChain.java"

    
    /**
     * The last request passed to a servlet for servicing from the current
     * thread.
     * 
     * @return The last request to be serviced. 
     */
    public static ServletRequest getLastServicedRequest() {
        return (ServletRequest) lastServicedRequest.get();
    }
    
    /**
     * The last response passed to a servlet for servicing from the current
     * thread.
     * 
     * @return The last response to be serviced. 
     */
    public static ServletResponse getLastServicedResponse() {
        return (ServletResponse) lastServicedResponse.get();
    }
    
    

======= fetch "protected void setupFromRequest(HttpServletRequest req)" 6d274b4^:"java/org/apache/catalina/servlets/CGIServlet.java"

                cginame =
                currentLocation.getParent().substring(webAppRootDir.length())
                + File.separator
                + name;
======= fetch "protected boolean setCGIEnvironment(HttpServletRequest req) throws IOException {" 6d274b4^:"java/org/apache/catalina/servlets/CGIServlet.java"

            envp.put("SCRIPT_FILENAME", command);  //for PHP

======= fetch "protected Class findClassInternal(String name)" 79631bb^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        synchronized (this) {
======= fetch "protected Class findClassInternal(String name)" 79631bb^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        }
        // Looking up the package
        String packageName = null;
        int pos = name.lastIndexOf('.');
        if (pos != -1)
            packageName = name.substring(0, pos);
        Package pkg = null;
======= fetch "protected Class findClassInternal(String name)" 79631bb^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (packageName != null) {
            pkg = getPackage(packageName);
            // Define the package (if null)
            if (pkg == null) {
                if (entry.manifest == null) {
                    definePackage(packageName, null, null, null, null, null,
                                  null, null);
                } else {
                    definePackage(packageName, entry.manifest, entry.codeBase);
======= fetch "protected Class findClassInternal(String name)" 79631bb^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        }
        // Create the code source object
        CodeSource codeSource =
            new CodeSource(entry.codeBase, entry.certificates);
        if (securityManager != null) {
            // Checking sealing
            if (pkg != null) {
                boolean sealCheck = true;
                if (pkg.isSealed()) {
                    sealCheck = pkg.isSealed(entry.codeBase);
                } else {
                    sealCheck = (entry.manifest == null)
                        || !isPackageSealed(packageName, entry.manifest);
======= fetch "protected Class findClassInternal(String name)" 79631bb^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                if (!sealCheck)
                    throw new SecurityException
                        ("Sealing violation loading " + name + " : Package "
                         + packageName + " is sealed.");
======= fetch "protected Class findClassInternal(String name)" 79631bb^:"java/org/apache/catalina/loader/WebappClassLoader.java"

        }
        synchronized (this) {
======= fetch "protected Class findClassInternal(String name)" 79631bb^:"java/org/apache/catalina/loader/WebappClassLoader.java"

                        codeSource);

 * ts TIMESTAMP NOT NULL,
 * INDEX (ts),

======= fetch "public int doRead(ByteChunk chunk, org.apache.coyote.Request request)" 17eecdb^:"java/org/apache/coyote/http11/filters/SavedRequestInputFilter.java"

        if(input.getOffset()>= input.getEnd())
            return -1;
        

======= fetch "public void removeValve(Valve valve) {" b18c29e^:"java/org/apache/catalina/core/StandardPipeline.java"

        if (first == basic) first = null;

======= fetch "public void addEnvironment(ContextEnvironment environment) {" 1a5e6e7^:"java/org/apache/catalina/deploy/NamingResources.java"

            return;
        } else {
            entries.put(environment.getName(), environment.getType());
======= fetch "public void addEnvironment(ContextEnvironment environment) {" 1a5e6e7^:"java/org/apache/catalina/deploy/NamingResources.java"

        
        entries.put(environment.getName(), environment.getType());

======= fetch "public void run () {" bbb8fe1^:"java/org/apache/catalina/servlets/CGIServlet.java"

                throw new IOException (e.toString());

======= fetch "public final void invoke(Request request, Response response)" fda223a^:"java/org/apache/catalina/core/StandardContextValve.java"

                    container.getLogger().error(sm.getString("requestListenerValve.requestInit",
======= fetch "public final void invoke(Request request, Response response)" fda223a^:"java/org/apache/catalina/core/StandardContextValve.java"

                    container.getLogger().error(sm.getString("requestListenerValve.requestDestroy",
======= fetch "public final void event(Request request, Response response, CometEvent event)" fda223a^:"java/org/apache/catalina/core/StandardContextValve.java"

     * Report a "bad request" error for the specified resource.  FIXME:  We
     * should really be using the error reporting settings for this web
     * application, but currently that code runs at the wrapper level rather
     * than the context level.
     *
     * @param requestURI The request URI for the requested resource
     * @param response The response we are creating
     */
    private void badRequest(String requestURI, HttpServletResponse response) {
        try {
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, requestURI);
        } catch (IllegalStateException e) {
            ;
        } catch (IOException e) {
            ;
        }
    }
    
    
    /**
     * Report a "forbidden" error for the specified resource. 
     *
     * @param requestURI The request URI for the requested resource
     * @param response The response we are creating
     */
    private void forbidden(String requestURI, HttpServletResponse response) {
        try {
            response.sendError(HttpServletResponse.SC_FORBIDDEN, requestURI);
        } catch (IllegalStateException e) {
            ;
        } catch (IOException e) {
            ;
        }
    }
    /**

======= fetch "public void list(HttpServletRequest request," 9dd8a23^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        boolean isDeployed = true;
======= fetch "public void list(HttpServletRequest request," 9dd8a23^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                try {
                    isDeployed = isDeployed(contextPath);
                } catch (Exception e) {
                    // Assume false on failure for safety
                    isDeployed = false;
                }
                
======= fetch "public void list(HttpServletRequest request," 9dd8a23^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                } else if (context.getAvailable()) {
======= fetch "public void list(HttpServletRequest request," 9dd8a23^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                        STARTED_APPS_ROW_BUTTON_SECTION, args));
======= fetch "public void list(HttpServletRequest request," 9dd8a23^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                        STOPPED_APPS_ROW_BUTTON_SECTION, args));
======= fetch "protected String stop(String path) {" 9dd8a23^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    private static final String STARTED_APPS_ROW_BUTTON_SECTION =
======= fetch "protected String stop(String path) {" 9dd8a23^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    private static final String STOPPED_APPS_ROW_BUTTON_SECTION =
======= fetch "protected String stop(String path) {" 9dd8a23^:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    private static final String STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION =
        " <td class=\"row-left\" bgcolor=\"{8}\">\n" +
        "  <small>\n" +
        "  &nbsp;{1}&nbsp;\n" +
        "  &nbsp;<a href=\"{2}\" onclick=\"return(confirm('''Are you sure?'''))\">{3}</a>&nbsp;\n" +
        "  &nbsp;<a href=\"{4}\" onclick=\"return(confirm('''Are you sure?'''))\">{5}</a>&nbsp;\n" +
        "  &nbsp;{7}&nbsp;\n" +
        "  </small>\n" +
        " </td>\n" +
        "</tr>\n";
    private static final String STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION =
        " <td class=\"row-left\" bgcolor=\"{8}\">\n" +
        "  <small>\n" +
        "  &nbsp;<a href=\"{0}\" onclick=\"return(confirm('''Are you sure?'''))\">{1}</a>&nbsp;\n" +
        "  &nbsp;{3}&nbsp;\n" +
        "  &nbsp;{5}&nbsp;\n" +
        "  &nbsp;{7}&nbsp;\n" +
        "  </small>\n" +
        " </td>\n" +
        "</tr>\n";
======= fetch "protected void undeploy(PrintWriter writer, String path) {" 9dd8a23^:"java/org/apache/catalina/manager/ManagerServlet.java"

            if (!isDeployed(path)) {
                writer.println(sm.getString("managerServlet.notDeployed",
                        RequestUtil.filter(displayPath)));
                return;
            }
======= fetch "protected File getAppBase() {" 9dd8a23^:"java/org/apache/catalina/manager/ManagerServlet.java"

     * Invoke the isDeployed method on the deployer.
     */
    protected boolean isDeployed(String name) 
        throws Exception {
        String[] params = { name };
        String[] signature = { "java.lang.String" };
        Boolean result = 
            (Boolean) mBeanServer.invoke(oname, "isDeployed", params, signature);
        return result.booleanValue();
    }
    
    /**
======= fetch "protected void check(String name)" 9dd8a23^:"java/org/apache/catalina/manager/ManagerServlet.java"

     * Invoke the check method on the deployer.
======= fetch "protected boolean isServiced(String name)" 9dd8a23^:"java/org/apache/catalina/manager/ManagerServlet.java"

     * Invoke the check method on the deployer.
======= fetch "protected void addServiced(String name)" 9dd8a23^:"java/org/apache/catalina/manager/ManagerServlet.java"

     * Invoke the check method on the deployer.
======= fetch "public long getDeploymentTime(String name) {" 9dd8a23^:"java/org/apache/catalina/startup/HostConfig.java"

    /**
     * Has the specified application been deployed? Note applications defined
     * in server.xml will not have been deployed.
     * @return <code>true</code> if the application has been deployed and
     * <code>false</code> if the applciation has not been deployed or does not
     * exist
     */
    public boolean isDeployed(String name) {
        DeployedApplication app = (DeployedApplication) deployed.get(name);
        if (app == null) {
            return false;
        } else {
            return true;
        }
    }
    
    
======= fetch "protected void deployWARs(File appBase, String[] files) {" 9dd8a23^:"java/org/apache/catalina/startup/HostConfig.java"

        boolean checkAdditionalDeployments = false;
        

======= fetch "private String createTagHandlerPoolName(String prefix," 823101d^:"java/org/apache/jasper/compiler/Generator.java"

                return JspUtil.makeXmlJavaIdentifier(poolName);
======= fetch "private String createTagVarName(String fullName, String prefix," 823101d^:"java/org/apache/jasper/compiler/Generator.java"

            return JspUtil.makeXmlJavaIdentifier(varName);

======= fetch "private String skipUntilEL() {" b55e9c2^:"java/org/apache/jasper/compiler/ELParser.java"

                prev = 0;

======= fetch "private void generateSetters(Node.CustomTag n, String tagHandlerVar," 2d6d717^:"java/org/apache/jasper/compiler/Generator.java"

            if (!simpleTag) {

 * Copyright 1999,2004 The Apache Software Foundation.
    private String baseOutputDir;
======= fetch "public void incrementRemoved() {" c7f0f60^:"java/org/apache/jasper/JspCompilationContext.java"

        if (removed > 1) {
            jspCompiler.removeGeneratedFiles();
            if( rctxt != null )
                rctxt.removeWrapper(jspUri);
======= fetch "public void compile() throws JasperException, FileNotFoundException {" c7f0f60^:"java/org/apache/jasper/JspCompilationContext.java"

                jspCompiler.removeGeneratedFiles();
======= fetch "public void compile() throws JasperException, FileNotFoundException {" c7f0f60^:"java/org/apache/jasper/JspCompilationContext.java"

                ex.printStackTrace();
 * Copyright 1999,2004-2005 The Apache Software Foundation.
======= fetch "public boolean isOutDated(boolean checkClass) {" c7f0f60^:"java/org/apache/jasper/compiler/Compiler.java"

            e.printStackTrace();
======= fetch "public boolean isOutDated(boolean checkClass) {" c7f0f60^:"java/org/apache/jasper/compiler/Compiler.java"

                e.printStackTrace();
 * Copyright 1999,2004-2005 The Apache Software Foundation.
======= fetch "public void service(HttpServletRequest request," c7f0f60^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        
======= fetch "public void service(HttpServletRequest request," c7f0f60^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        } catch (FileNotFoundException ex) {
            ctxt.incrementRemoved();
            String includeRequestUri = (String)
                request.getAttribute("javax.servlet.include.request_uri");
            if (includeRequestUri != null) {
                // This file was included. Throw an exception as
                // a response.sendError() will be ignored by the
                // servlet engine.
                throw new ServletException(ex);
            } else {
                try {
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, 
                                      ex.getMessage());
                } catch (IllegalStateException ise) {
                    log.error(Localizer.getMessage("jsp.error.file.not.found",
                           ex.getMessage()),
                  ex);
                }
            }
        } catch (ServletException ex) {
            if (options.getDevelopment()) {
                throw handleJspException(ex);
            } else {
                throw ex;
            }
        } catch (IOException ex) {
            if (options.getDevelopment()) {
                throw handleJspException(ex);
            } else {
                throw ex;
            }
        } catch (IllegalStateException ex) {
            if (options.getDevelopment()) {
                throw handleJspException(ex);
            } else {
                throw ex;
            }
        } catch (Exception ex) {
            if (options.getDevelopment()) {
                throw handleJspException(ex);
            } else {
                throw new JasperException(ex);
            }
        }
        try {
            
======= fetch "public void service(HttpServletRequest request," c7f0f60^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        } catch (FileNotFoundException ex) {
            ctxt.incrementRemoved();
            String includeRequestUri = (String)
                request.getAttribute("javax.servlet.include.request_uri");
            if (includeRequestUri != null) {
                // This file was included. Throw an exception as
                // a response.sendError() will be ignored by the
                // servlet engine.
                throw new ServletException(ex);
            } else {
                try {
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, 
                                      ex.getMessage());
                } catch (IllegalStateException ise) {
                    log.error(Localizer.getMessage("jsp.error.file.not.found",
                }
            }

======= fetch "public void action(ActionCode actionCode, Object param) {" a91b95e^:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

            request.setContentLength(-1); // reset content length
======= fetch "public void action(ActionCode actionCode, Object param) {" a91b95e^:"java/org/apache/jk/core/MsgContext.java"

            req.setContentLength(-1); // reset content length

======= fetch "public final static boolean equals(final Object obj0, final Object obj1)" edc20fa^:"java/org/apache/el/lang/ELSupport.java"

        } else if (obj0.getClass().isEnum()) {
            return obj0.equals(coerceToEnum(obj1, obj0.getClass()));
        } else if (obj1.getClass().isEnum()) {
            return obj1.equals(coerceToEnum(obj0, obj1.getClass()));
======= fetch "public final static boolean equals(final Object obj0, final Object obj1)" edc20fa^:"java/org/apache/el/lang/ELSupport.java"

    
    /**
     * @param obj
     * @param type
     * @return
     */
    public final static Enum coerceToEnum(final Object obj, Class type) {
        if (obj == null || "".equals(obj)) {
            return null;
        }
        if (obj.getClass().isEnum()) {
            return (Enum) obj;
        }
        return Enum.valueOf(type, obj.toString());
    }
======= fetch "public final static String coerceToString(final Object obj) {" edc20fa^:"java/org/apache/el/lang/ELSupport.java"

        } else if (obj instanceof Enum) {
            return ((Enum) obj).name();
======= fetch "public final static Object coerceToType(final Object obj, final Class type)" edc20fa^:"java/org/apache/el/lang/ELSupport.java"

        if (type.isEnum()) {
            return coerceToEnum(obj, type);
        }
======= fetch "public Class loadTagFile() throws JasperException {" edc20fa^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                reload = false;
======= fetch "public Class loadTagFilePrototype() throws JasperException {" edc20fa^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        try {
            Object target;
            if (isTagFile) {
======= fetch "public Class loadTagFilePrototype() throws JasperException {" edc20fa^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                    reload = false;
======= fetch "public Class loadTagFilePrototype() throws JasperException {" edc20fa^:"java/org/apache/jasper/servlet/JspServletWrapper.java"

            return ((java.util.List) ((JspSourceDependent) target).getDependants());

======= fetch "public String getFileText(String originalPath, boolean virtual)" 0f9844c^:"java/org/apache/catalina/ssi/SSIServletExternalResolver.java"

            if (retVal.equals("")) {

======= fetch "public long process(Reader reader, long lastModifiedDate," 8ed77be^:"java/org/apache/catalina/ssi/SSIProcessor.java"

        char endQuote = 0;
======= fetch "public long process(Reader reader, long lastModifiedDate," 8ed77be^:"java/org/apache/catalina/ssi/SSIProcessor.java"

                while (bIdx < cmd.length() && cmd.charAt(bIdx) != '"')
======= fetch "public long process(Reader reader, long lastModifiedDate," 8ed77be^:"java/org/apache/catalina/ssi/SSIProcessor.java"

                endQuote = cmd.charAt(bIdx);
======= fetch "public long process(Reader reader, long lastModifiedDate," 8ed77be^:"java/org/apache/catalina/ssi/SSIProcessor.java"

                    if (c == '"' && !escaped) break;
======= fetch "protected boolean isSpace(char c) {" 8ed77be^:"java/org/apache/catalina/ssi/SSIProcessor.java"

    
    protected boolean isQuote(char c) {
        return c == '\'' || c == '\"' || c == '`';
    }

======= fetch "protected void run() throws IOException {" c30afec^:"java/org/apache/catalina/servlets/CGIServlet.java"

            rt = Runtime.getRuntime();
            proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd);
            String sContentLength = (String) env.get("CONTENT_LENGTH");
            if(!"".equals(sContentLength)) {
                commandsStdIn = new BufferedOutputStream(proc.getOutputStream());
                IOTools.flow(stdin, commandsStdIn);
                commandsStdIn.flush();
                commandsStdIn.close();
            }
======= fetch "protected void run() throws IOException {" c30afec^:"java/org/apache/catalina/servlets/CGIServlet.java"

            /* we want to wait for the process to exit,  Process.waitFor()
             * is useless in our situation; see
             * http://developer.java.sun.com/developer/
             *                               bugParade/bugs/4223650.html
             */
======= fetch "protected void run() throws IOException {" c30afec^:"java/org/apache/catalina/servlets/CGIServlet.java"

            boolean isRunning = true;
            commandsStdErr = new BufferedReader
                (new InputStreamReader(proc.getErrorStream()));
            final BufferedReader stdErrRdr = commandsStdErr ;
            new Thread() {
                public void run () {
                    sendToLog(stdErrRdr) ;
                } ;
            }.start() ;
            InputStream cgiHeaderStream =
                new HTTPHeaderInputStream(proc.getInputStream());
            BufferedReader cgiHeaderReader =
                new BufferedReader(new InputStreamReader(cgiHeaderStream));
======= fetch "public void run () {" c30afec^:"java/org/apache/catalina/servlets/CGIServlet.java"

            while (isRunning) {
                try {
                    //set headers
                    String line = null;
                    while (((line = cgiHeaderReader.readLine()) != null)
                           && !("".equals(line))) {
                        if (debug >= 2) {
                            log("runCGI: addHeader(\"" + line + "\")");
                        }
                        if (line.startsWith("HTTP")) {
                            response.setStatus(getSCFromHttpStatusLine(line));
                        } else if (line.indexOf(":") >= 0) {
                            String header =
                                line.substring(0, line.indexOf(":")).trim();
                            String value =
                                line.substring(line.indexOf(":") + 1).trim(); 
                            if (header.equalsIgnoreCase("status")) {
                                response.setStatus(getSCFromCGIStatusHeader(value));
======= fetch "public void run () {" c30afec^:"java/org/apache/catalina/servlets/CGIServlet.java"

                                response.addHeader(header , value);
======= fetch "public void run () {" c30afec^:"java/org/apache/catalina/servlets/CGIServlet.java"

                        } else {
                            log("runCGI: bad header line \"" + line + "\"");
======= fetch "public void run () {" c30afec^:"java/org/apache/catalina/servlets/CGIServlet.java"

                    }
                    //write output
                    byte[] bBuf = new byte[2048];
                    OutputStream out = response.getOutputStream();
                    cgiOutput = proc.getInputStream();
                    try {
                        while ((bufRead = cgiOutput.read(bBuf)) != -1) {
                            if (debug >= 4) {
                                log("runCGI: output " + bufRead +
                                    " bytes of data");
======= fetch "public void run () {" c30afec^:"java/org/apache/catalina/servlets/CGIServlet.java"

                            out.write(bBuf, 0, bufRead);
======= fetch "public void run () {" c30afec^:"java/org/apache/catalina/servlets/CGIServlet.java"

                    } finally {
                        // Attempt to consume any leftover byte if something bad happens,
                        // such as a socket disconnect on the servlet side; otherwise, the
                        // external process could hang
                        if (bufRead != -1) {
                            while ((bufRead = cgiOutput.read(bBuf)) != -1) {}
======= fetch "public void run () {" c30afec^:"java/org/apache/catalina/servlets/CGIServlet.java"

                } //replacement for Process.waitFor()
======= fetch "public void run () {" c30afec^:"java/org/apache/catalina/servlets/CGIServlet.java"

                    proc.exitValue(); // Throws exception if alive
                    isRunning = false;
                } catch (IllegalThreadStateException e) {
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException ignored) {
                    }
======= fetch "public void run () {" c30afec^:"java/org/apache/catalina/servlets/CGIServlet.java"

            } //replacement for Process.waitFor()
            // Close the output stream used
            cgiOutput.close();

======= fetch "public Object resolveVariable(String pName) throws ELException {" 01a9b59^:"java/org/apache/jasper/el/VariableResolverImpl.java"


======= fetch "public synchronized void unload() throws ServletException {" 276e5ac^:"java/org/apache/catalina/core/StandardWrapper.java"

        ClassLoader oldCtxClassLoader =
            Thread.currentThread().getContextClassLoader();
        ClassLoader classLoader = instance.getClass().getClassLoader();
======= fetch "public synchronized void unload() throws ServletException {" 276e5ac^:"java/org/apache/catalina/core/StandardWrapper.java"

            Thread.currentThread().setContextClassLoader(classLoader);
======= fetch "public synchronized void unload() throws ServletException {" 276e5ac^:"java/org/apache/catalina/core/StandardWrapper.java"

            // restore the context ClassLoader
            Thread.currentThread().setContextClassLoader(oldCtxClassLoader);
======= fetch "public synchronized void unload() throws ServletException {" 276e5ac^:"java/org/apache/catalina/core/StandardWrapper.java"

                Thread.currentThread().setContextClassLoader(classLoader);
======= fetch "public synchronized void unload() throws ServletException {" 276e5ac^:"java/org/apache/catalina/core/StandardWrapper.java"

            } finally {
                // restore the context ClassLoader
                Thread.currentThread().setContextClassLoader
                    (oldCtxClassLoader);

======= fetch "public synchronized void start() throws LifecycleException {" 7b870a4^:"java/org/apache/catalina/core/StandardContext.java"

        // Acquire clustered manager
        Manager contextManager = null;
        if (manager == null) {
        	if ((getCluster() != null) && distributable) {
        		try {
        			contextManager = getCluster().createManager(getName());
        		} catch (Exception ex) {
        			log.error("standardContext.clusterFail", ex);
        			ok = false;
        		}
        	} else {
        		contextManager = new StandardManager();
        	}
        }
        
        
======= fetch "public synchronized void start() throws LifecycleException {" 7b870a4^:"java/org/apache/catalina/core/StandardContext.java"

                if (manager == null) {
                    if ((getCluster() != null) && distributable) {
                        try {
                            setManager(getCluster().createManager(getName()));
                        } catch (Exception ex) {
                            log.error("standardContext.clusterFail", ex);
                            ok = false;
                        }
                    } else {
                        setManager(new StandardManager());
                    }
