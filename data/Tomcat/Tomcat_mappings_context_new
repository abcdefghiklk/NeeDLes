======= 42056be:"java/org/apache/jasper/compiler/PageInfo.java"

    public void setExtends(String value) {
    }
    /**
     * @deprecated Use {@link #setExtends(String)}
     */
    @Deprecated
    public void setExtends(String value, @SuppressWarnings("unused") Node.PageDirective n) {
        xtends = value;
======= 42056be:"java/org/apache/jasper/compiler/Validator.java"

                        pageInfo.setExtends(value);

======= b430e29:"java/org/apache/jasper/compiler/ELParser.java"

        while (hasNextChar()) {
======= b430e29:"java/org/apache/jasper/compiler/ELParser.java"

        if (hasNextChar()) {
                if (hasNextChar()) {
                        if (hasNextChar()) {
======= b430e29:"java/org/apache/jasper/compiler/ELParser.java"

        String trimmed = id.trim();
            int result = reservedWords[k].compareTo(trimmed);
======= b430e29:"java/org/apache/jasper/compiler/ELParser.java"

======= b430e29:"java/org/apache/jasper/compiler/ELParser.java"

======= b430e29:"test/org/apache/jasper/compiler/TestELParser.java"

    @Test
    public void testTernary01() throws JasperException {
        doTestParser("${true?true:false}");
    }
    @Test
    public void testTernary02() throws JasperException {
        doTestParser("${a==1?true:false}");
    }
    @Test
    public void testTernary03() throws JasperException {
        doTestParser("${a eq1?true:false}");
    }
    @Test
    public void testTernary04() throws JasperException {
        doTestParser(" ${ a eq 1 ? true : false } ");
    }
    @Test
    public void testTernary05() throws JasperException {
        // Note this is invalid EL
        doTestParser("${aeq1?true:false}");
    }
    @Test
    public void testTernary06() throws JasperException {
        doTestParser("${do:it(a eq1?true:false,y)}");
    }
    @Test
    public void testTernary07() throws JasperException {
        doTestParser(" $ { do:it( a eq 1 ? true : false, y ) } ");
    }

======= f28800c:"java/org/apache/catalina/loader/WebappClassLoader.java"

        ClassLoader p = getParent();
        if (p == null) {
            p = getSystemClassLoader();
        }
        this.parent = p;
        ClassLoader j = String.class.getClassLoader();
        if (j == null) {
            j = getSystemClassLoader();
            while (j.getParent() != null) {
                j = j.getParent();
            }
        }
        this.j2seClassLoader = j;
        securityManager = System.getSecurityManager();
======= f28800c:"java/org/apache/catalina/loader/WebappClassLoader.java"

        ClassLoader p = getParent();
        if (p == null) {
            p = getSystemClassLoader();
        }
        this.parent = p;
        ClassLoader j = String.class.getClassLoader();
        if (j == null) {
            j = getSystemClassLoader();
            while (j.getParent() != null) {
                j = j.getParent();
            }
        }
        this.j2seClassLoader = j;
        securityManager = System.getSecurityManager();
======= f28800c:"java/org/apache/catalina/loader/WebappClassLoader.java"

    protected final ClassLoader parent;
     * The bootstrap class loader used to load the J2SE classes. In some
     * implementations this class loader is always <code>null</null> and in
     * those cases {@link ClassLoader#getParent()} will be called recursively on
     * the system class loader and the last non-null result used.
    protected final ClassLoader j2seClassLoader;
======= f28800c:"java/org/apache/catalina/loader/WebappClassLoader.java"

        WebappClassLoader result = new WebappClassLoader(getParent());
======= f28800c:"java/org/apache/catalina/loader/WebappClassLoader.java"

            url = parent.getResource(name);
======= f28800c:"java/org/apache/catalina/loader/WebappClassLoader.java"

            url = parent.getResource(name);
======= f28800c:"java/org/apache/catalina/loader/WebappClassLoader.java"

            stream = parent.getResourceAsStream(name);
======= f28800c:"java/org/apache/catalina/loader/WebappClassLoader.java"

            stream = parent.getResourceAsStream(name);
======= f28800c:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (j2seClassLoader.getResource(resourceName) != null) {
                clazz = j2seClassLoader.loadClass(name);
======= f28800c:"java/org/apache/catalina/loader/WebappClassLoader.java"

                clazz = Class.forName(name, false, parent);
======= f28800c:"java/org/apache/catalina/loader/WebappClassLoader.java"

                clazz = Class.forName(name, false, parent);
======= f28800c:"java/org/apache/catalina/loader/WebappClassLoader.java"


======= 11b1e83:"java/org/apache/tomcat/websocket/server/UpgradeUtil.java"

        subProtocol = sec.getConfigurator().getNegotiatedSubprotocol(
                sec.getSubprotocols(), subProtocols);
======= 11b1e83:"java/org/apache/tomcat/websocket/server/UpgradeUtil.java"

======= 11b1e83:"java/org/apache/tomcat/websocket/server/UpgradeUtil.java"

        Endpoint ep;
        try {
            Class<?> clazz = sec.getEndpointClass();
            if (Endpoint.class.isAssignableFrom(clazz)) {
                ep = (Endpoint) sec.getConfigurator().getEndpointInstance(
                        clazz);
            } else {
                ep = new PojoEndpointServer();
            }
        } catch (InstantiationException e) {
            throw new ServletException(e);
        }

======= 48650dd:"java/org/apache/jasper/runtime/PageContextImpl.java"

======= 48650dd:"java/org/apache/jasper/runtime/PageContextImpl.java"

        if (bufferSize == JspWriter.DEFAULT_BUFFER) {
            bufferSize = Constants.DEFAULT_BUFFER_SIZE;
        }
======= 48650dd:"test/org/apache/jasper/runtime/TestPageContextImpl.java"

======= 48650dd:"test/org/apache/jasper/runtime/TestPageContextImpl.java"

    @Test
    public void testDefaultBufferSize() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp");
        // app dir is relative to server home
        Context ctx = tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        // Add the Servlet
        Tomcat.addServlet(ctx, "bug56010", new Bug56010());
        ctx.addServletMapping("/bug56010", "bug56010");
        tomcat.start();
        ByteChunk res = getUrl("http://localhost:" + getPort() + "/test/bug56010");
        String result = res.toString();
        Assert.assertTrue(result.contains("OK"));
    }
    public static class Bug56010 extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            PageContext pageContext = JspFactory.getDefaultFactory().getPageContext(
                    this, req, resp, null, false, JspWriter.DEFAULT_BUFFER, true);
            JspWriter out = pageContext.getOut();
            if (Constants.DEFAULT_BUFFER_SIZE == out.getBufferSize()) {
                resp.getWriter().println("OK");
            } else {
                resp.getWriter().println("FAIL");
            }
        }
    }

======= 553ad39:"java/org/apache/tomcat/util/net/SocketWrapper.java"

    public void access() {
        // Async timeouts are based on the time between the call to startAsync()
        // and complete() / dispatch() so don't update the last access time
        // (that drives the timeout) on every read and write when using async
        // processing.
        if (!isAsync()) {
            access(System.currentTimeMillis());
        }
    }

======= 5e6b884:"java/org/apache/jasper/compiler/TldCache.java"

            String webappPath = tldResourcePath.getWebappPath();
            if (webappPath != null) {
                // webappPath will be null for JARs containing TLDs that are on
                // the class path but not part of the web application
                URL url = servletContext.getResource(tldResourcePath.getWebappPath());
                URLConnection conn = url.openConnection();
                result[0] = conn.getLastModified();
                if ("file".equals(url.getProtocol())) {
                    // Reading the last modified time opens an input stream so we
                    // need to make sure it is closed again otherwise the TLD file
                    // will be locked until GC runs.
                    conn.getInputStream().close();
                }

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * <p>Abstract implementation of the <b>Valve</b> interface that generates a web
 * server access log with the detailed line contents matching a configurable
 * pattern. The syntax of the available patterns is similar to that supported by
 * the <a href="http://httpd.apache.org/">Apache HTTP Server</a>
 * <code>mod_log_config</code> module.</p>
 *
 * <p>Patterns for the logged message may include constant text or any of the
 * following replacement strings, for which the corresponding information
 * from the specified Response is substituted:</p>
 * <ul>
 * <li><b>%a</b> - Remote IP address
 * <li><b>%A</b> - Local IP address
 * <li><b>%b</b> - Bytes sent, excluding HTTP headers, or '-' if no bytes
 *     were sent
 * <li><b>%B</b> - Bytes sent, excluding HTTP headers
 * <li><b>%h</b> - Remote host name (or IP address if
 * <code>enableLookups</code> for the connector is false)
 * <li><b>%H</b> - Request protocol
 * <li><b>%l</b> - Remote logical username from identd (always returns '-')
 * <li><b>%m</b> - Request method
 * <li><b>%p</b> - Local port
 * <li><b>%q</b> - Query string (prepended with a '?' if it exists, otherwise
 *     an empty string
 * <li><b>%r</b> - First line of the request
 * <li><b>%s</b> - HTTP status code of the response
 * <li><b>%S</b> - User session ID
 * <li><b>%t</b> - Date and time, in Common Log Format format
 * <li><b>%t{format}</b> - Date and time, in any format supported by SimpleDateFormat
 * <li><b>%u</b> - Remote user that was authenticated
 * <li><b>%U</b> - Requested URL path
 * <li><b>%v</b> - Local server name
 * <li><b>%D</b> - Time taken to process the request, in millis
 * <li><b>%T</b> - Time taken to process the request, in seconds
 * <li><b>%I</b> - current Request thread name (can compare later with stacktraces)
 * </ul>
 * <p>In addition, the caller can specify one of the following aliases for
 * commonly utilized patterns:</p>
 * <ul>
 * <li><b>common</b> - <code>%h %l %u %t "%r" %s %b</code>
 * <li><b>combined</b> -
 *   <code>%h %l %u %t "%r" %s %b "%{Referer}i" "%{User-Agent}i"</code>
 * </ul>
 *
 * <p>
 * There is also support to write information from the cookie, incoming
 * header, the Session or something else in the ServletRequest.<br>
 * It is modeled after the
 * <a href="http://httpd.apache.org/">Apache HTTP Server</a> log configuration
 * syntax:</p>
 * <ul>
 * <li><code>%{xxx}i</code> for incoming headers
 * <li><code>%{xxx}o</code> for outgoing response headers
 * <li><code>%{xxx}c</code> for a specific cookie
 * <li><code>%{xxx}r</code> xxx is an attribute in the ServletRequest
 * <li><code>%{xxx}s</code> xxx is an attribute in the HttpSession
 * <li><code>%{xxx}t</code> xxx is an enhanced SimpleDateFormat pattern
 * (see Configuration Reference document for details on supported time patterns)
 * </ul>
 *
 * <p>
 * Conditional logging is also supported. This can be done with the
 * <code>conditionUnless</code> and <code>conditionIf</code> properties.
 * If the value returned from ServletRequest.getAttribute(conditionUnless)
 * yields a non-null value, the logging will be skipped.
 * If the value returned from ServletRequest.getAttribute(conditionIf)
 * yields the null value, the logging will be skipped.
 * The <code>condition</code> attribute is synonym for
 * <code>conditionUnless</code> and is provided for backwards compatibility.
 * </p>
 *
 * <p>
 * For extended attributes coming from a getAttribute() call,
 * it is you responsibility to ensure there are no newline or
 * control characters.
 * </p>
 *
 * @author Craig R. McClanahan
 * @author Jason Brittain
 * @author Remy Maucherat
 * @author Takayuki Kaneko
 * @author Peter Rossbach
 *
 * @version $Id$
 */
    private static final Log log = LogFactory.getLog(AbstractAccessLogValve.class);
    //------------------------------------------------------ Constructor
    public AbstractAccessLogValve() {
        super(true);
    }
    // ----------------------------------------------------- Instance Variables
    /**
     * enabled this component
     */
    protected boolean enabled = true;
    /**
     * The pattern used to format our access log lines.
     */
    protected String pattern = null;
    /**
     * The size of our global date format cache
     */
    private static final int globalCacheSize = 300;
    /**
     * The size of our thread local date format cache
     */
    private static final int localCacheSize = 60;
    /**
     * <p>Cache structure for formatted timestamps based on seconds.</p>
     *
     * <p>The cache consists of entries for a consecutive range of
     * seconds. The length of the range is configurable. It is
     * implemented based on a cyclic buffer. New entries shift the range.</p>
     *
     * <p>There is one cache for the CLF format (the access log standard
     * format) and a HashMap of caches for additional formats used by
     * SimpleDateFormat.</p>
     *
     * <p>Although the cache supports specifying a locale when retrieving a
     * formatted timestamp, each format will always use the locale given
     * when the format was first used. New locales can only be used for new formats.
     * The CLF format will always be formatted using the locale
     * <code>en_US</code>.</p>
     *
     * <p>The cache is not threadsafe. It can be used without synchronization
     * via thread local instances, or with synchronization as a global cache.</p>
     *
     * <p>The cache can be created with a parent cache to build a cache hierarchy.
     * Access to the parent cache is threadsafe.</p>
     *
     * <p>This class uses a small thread local first level cache and a bigger
     * synchronized global second level cache.</p>
     */
    protected static class DateFormatCache {
        protected class Cache {
            /* CLF log format */
            private static final String cLFFormat = "dd/MMM/yyyy:HH:mm:ss Z";
            /* Second used to retrieve CLF format in most recent invocation */
            private long previousSeconds = Long.MIN_VALUE;
            /* Value of CLF format retrieved in most recent invocation */
            private String previousFormat = "";
            /* First second contained in cache */
            private long first = Long.MIN_VALUE;
            /* Last second contained in cache */
            private long last = Long.MIN_VALUE;
            /* Index of "first" in the cyclic cache */
            private int offset = 0;
            /* Helper object to be able to call SimpleDateFormat.format(). */
            private final Date currentDate = new Date();
            protected final String cache[];
            private SimpleDateFormat formatter;
            private boolean isCLF = false;
            private Cache parent = null;
            private Cache(Cache parent) {
                this(null, parent);
            }
            private Cache(String format, Cache parent) {
                this(format, null, parent);
            }
            private Cache(String format, Locale loc, Cache parent) {
                cache = new String[cacheSize];
                for (int i = 0; i < cacheSize; i++) {
                    cache[i] = null;
                }
                if (loc == null) {
                    loc = cacheDefaultLocale;
                }
                if (format == null) {
                    isCLF = true;
                    format = cLFFormat;
                    formatter = new SimpleDateFormat(format, Locale.US);
                } else {
                    formatter = new SimpleDateFormat(format, loc);
                }
                formatter.setTimeZone(TimeZone.getDefault());
                this.parent = parent;
            }
            private String getFormatInternal(long time) {
                long seconds = time / 1000;
                /* First step: if we have seen this timestamp
                   during the previous call, and we need CLF, return the previous value. */
                if (seconds == previousSeconds) {
                    return previousFormat;
                }
                /* Second step: Try to locate in cache */
                previousSeconds = seconds;
                int index = (offset + (int)(seconds - first)) % cacheSize;
                if (index < 0) {
                    index += cacheSize;
                }
                if (seconds >= first && seconds <= last) {
                    if (cache[index] != null) {
                        /* Found, so remember for next call and return.*/
                        previousFormat = cache[index];
                        return previousFormat;
                    }
                /* Third step: not found in cache, adjust cache and add item */
                } else if (seconds >= last + cacheSize || seconds <= first - cacheSize) {
                    first = seconds;
                    last = first + cacheSize - 1;
                    index = 0;
                    offset = 0;
                    for (int i = 1; i < cacheSize; i++) {
                        cache[i] = null;
                    }
                } else if (seconds > last) {
                    for (int i = 1; i < seconds - last; i++) {
                        cache[(index + cacheSize - i) % cacheSize] = null;
                    }
                    first = seconds - (cacheSize - 1);
                    last = seconds;
                    offset = (index + 1) % cacheSize;
                } else if (seconds < first) {
                    for (int i = 1; i < first - seconds; i++) {
                        cache[(index + i) % cacheSize] = null;
                    }
                    first = seconds;
                    last = seconds + (cacheSize - 1);
                    offset = index;
                }
                /* Last step: format new timestamp either using
                 * parent cache or locally. */
                if (parent != null) {
                    synchronized(parent) {
                        previousFormat = parent.getFormatInternal(time);
                    }
                } else {
                    currentDate.setTime(time);
                    previousFormat = formatter.format(currentDate);
                    if (isCLF) {
                        StringBuilder current = new StringBuilder(32);
                        current.append('[');
                        current.append(previousFormat);
                        current.append(']');
                        previousFormat = current.toString();
                    }
                }
                cache[index] = previousFormat;
                return previousFormat;
            }
        }
        /* Number of cached entries */
        private int cacheSize = 0;
        private final Locale cacheDefaultLocale;
        private final DateFormatCache parent;
        protected final Cache cLFCache;
        private final HashMap<String, Cache> formatCache = new HashMap<>();
        protected DateFormatCache(int size, Locale loc, DateFormatCache parent) {
            cacheSize = size;
            cacheDefaultLocale = loc;
            this.parent = parent;
            Cache parentCache = null;
            if (parent != null) {
                synchronized(parent) {
                    parentCache = parent.getCache(null, null);
                }
            }
            cLFCache = new Cache(parentCache);
        }
        private Cache getCache(String format, Locale loc) {
            Cache cache;
            if (format == null) {
                cache = cLFCache;
            } else {
                cache = formatCache.get(format);
                if (cache == null) {
                    Cache parentCache = null;
                    if (parent != null) {
                        synchronized(parent) {
                            parentCache = parent.getCache(format, loc);
                        }
                    }
                    cache = new Cache(format, loc, parentCache);
                    formatCache.put(format, cache);
                }
            }
            return cache;
        }
        public String getFormat(long time) {
            return cLFCache.getFormatInternal(time);
        }
        public String getFormat(String format, Locale loc, long time) {
            return getCache(format, loc).getFormatInternal(time);
        }
    }
    /**
     * Global date format cache.
     */
    private static final DateFormatCache globalDateCache =
            new DateFormatCache(globalCacheSize, Locale.getDefault(), null);
    /**
     * Thread local date format cache.
     */
    private static final ThreadLocal<DateFormatCache> localDateCache =
            new ThreadLocal<DateFormatCache>() {
        @Override
        protected DateFormatCache initialValue() {
            return new DateFormatCache(localCacheSize, Locale.getDefault(), globalDateCache);
        }
    };
    /**
     * The system time when we last updated the Date that this valve
     * uses for log lines.
     */
    private static final ThreadLocal<Date> localDate =
            new ThreadLocal<Date>() {
        @Override
        protected Date initialValue() {
            return new Date();
        }
    };
    /**
     * The list of our format types.
     */
    private static enum FormatType {
        CLF, SEC, MSEC, MSEC_FRAC, SDF
    }
    /**
     * Are we doing conditional logging. default null.
     * It is the value of <code>conditionUnless</code> property.
     */
    protected String condition = null;
    /**
     * Are we doing conditional logging. default null.
     * It is the value of <code>conditionIf</code> property.
     */
    protected String conditionIf = null;
    /**
     * Name of locale used to format timestamps in log entries and in
     * log file name suffix.
     */
    protected String localeName = Locale.getDefault().toString();
    /**
     * Locale used to format timestamps in log entries and in
     * log file name suffix.
     */
    protected Locale locale = Locale.getDefault();
    /**
     * Array of AccessLogElement, they will be used to make log message.
     */
    protected AccessLogElement[] logElements = null;
    /**
     * @see #setRequestAttributesEnabled(boolean)
     */
    protected boolean requestAttributesEnabled = false;
    /**
     * Buffer pool used for log message generation. Pool used to reduce garbage
     * generation.
     */
    private SynchronizedStack<CharArrayWriter> charArrayWriters =
            new SynchronizedStack<>();
    /**
     * Log message buffers are usually recycled and re-used. To prevent
     * excessive memory usage, if a buffer grows beyond this size it will be
     * discarded. The default is 256 characters. This should be set to larger
     * than the typical access log message size.
     */
    private int maxLogMessageBufferSize = 256;
    // ------------------------------------------------------------- Properties
    /**
     * {@inheritDoc}
     */
    @Override
    public void setRequestAttributesEnabled(boolean requestAttributesEnabled) {
        this.requestAttributesEnabled = requestAttributesEnabled;
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getRequestAttributesEnabled() {
        return requestAttributesEnabled;
    }
    /**
     * @return Returns the enabled.
     */
    public boolean getEnabled() {
        return enabled;
    }
    /**
     * @param enabled
     *            The enabled to set.
     */
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
    /**
     * Return the format pattern.
     */
    public String getPattern() {
        return (this.pattern);
    }
    /**
     * Set the format pattern, first translating any recognized alias.
     *
     * @param pattern The new pattern
     */
    public void setPattern(String pattern) {
        if (pattern == null) {
            this.pattern = "";
        } else if (pattern.equals(Constants.AccessLog.COMMON_ALIAS)) {
            this.pattern = Constants.AccessLog.COMMON_PATTERN;
        } else if (pattern.equals(Constants.AccessLog.COMBINED_ALIAS)) {
            this.pattern = Constants.AccessLog.COMBINED_PATTERN;
        } else {
            this.pattern = pattern;
        }
        logElements = createLogElements();
    }
    /**
     * Return whether the attribute name to look for when
     * performing conditional logging. If null, every
     * request is logged.
     */
    public String getCondition() {
        return condition;
    }
    /**
     * Set the ServletRequest.attribute to look for to perform
     * conditional logging. Set to null to log everything.
     *
     * @param condition Set to null to log everything
     */
    public void setCondition(String condition) {
        this.condition = condition;
    }
    /**
     * Return whether the attribute name to look for when
     * performing conditional logging. If null, every
     * request is logged.
     */
    public String getConditionUnless() {
        return getCondition();
    }
    /**
     * Set the ServletRequest.attribute to look for to perform
     * conditional logging. Set to null to log everything.
     *
     * @param condition Set to null to log everything
     */
    public void setConditionUnless(String condition) {
        setCondition(condition);
    }
    /**
     * Return whether the attribute name to look for when
     * performing conditional logging. If null, every
     * request is logged.
     */
    public String getConditionIf() {
        return conditionIf;
    }
    /**
     * Set the ServletRequest.attribute to look for to perform
     * conditional logging. Set to null to log everything.
     *
     * @param condition Set to null to log everything
     */
    public void setConditionIf(String condition) {
        this.conditionIf = condition;
    }
    /**
     * Return the locale used to format timestamps in log entries and in
     * log file name suffix.
     */
    public String getLocale() {
        return localeName;
    }
    /**
     * Set the locale used to format timestamps in log entries and in
     * log file name suffix. Changing the locale is only supported
     * as long as the AccessLogValve has not logged anything. Changing
     * the locale later can lead to inconsistent formatting.
     *
     * @param localeName The locale to use.
     */
    public void setLocale(String localeName) {
        this.localeName = localeName;
        locale = findLocale(localeName, locale);
    }
    // --------------------------------------------------------- Public Methods
    /**
     * Log a message summarizing the specified request and response, according
     * to the format specified by the <code>pattern</code> property.
     *
     * @param request Request being processed
     * @param response Response being processed
     *
     * @exception IOException if an input/output error has occurred
     * @exception ServletException if a servlet error has occurred
     */
    @Override
    public void invoke(Request request, Response response) throws IOException,
            ServletException {
        getNext().invoke(request, response);
    }
    @Override
    public void log(Request request, Response response, long time) {
        if (!getState().isAvailable() || !getEnabled() || logElements == null
                || condition != null
                && null != request.getRequest().getAttribute(condition)
                || conditionIf != null
                && null == request.getRequest().getAttribute(conditionIf)) {
            return;
        }
        /**
         * XXX This is a bit silly, but we want to have start and stop time and
         * duration consistent. It would be better to keep start and stop
         * simply in the request and/or response object and remove time
         * (duration) from the interface.
         */
        long start = request.getCoyoteRequest().getStartTime();
        Date date = getDate(start + time);
        CharArrayWriter result = charArrayWriters.pop();
        if (result == null) {
            result = new CharArrayWriter(128);
        }
        for (int i = 0; i < logElements.length; i++) {
            logElements[i].addElement(result, date, request, response, time);
        }
        log(result);
        if (result.size() <= maxLogMessageBufferSize) {
            result.reset();
            charArrayWriters.push(result);
        }
    }
    // -------------------------------------------------------- Protected Methods
    /**
     * Log the specified message.
     *
     * @param message Message to be logged. This object will be recycled by
     *  the calling method.
     */
    protected abstract void log(CharArrayWriter message);
    // -------------------------------------------------------- Private Methods
    /**
     * This method returns a Date object that is accurate to within one second.
     * If a thread calls this method to get a Date and it's been less than 1
     * second since a new Date was created, this method simply gives out the
     * same Date again so that the system doesn't spend time creating Date
     * objects unnecessarily.
     *
     * @return Date
     */
    private static Date getDate(long systime) {
        Date date = localDate.get();
        date.setTime(systime);
        return date;
    }
    /**
     * Find a locale by name
     */
    protected static Locale findLocale(String name, Locale fallback) {
        if (name == null || name.isEmpty()) {
            return Locale.getDefault();
        } else {
            for (Locale l: Locale.getAvailableLocales()) {
                if (name.equals(l.toString())) {
                    return(l);
                }
            }
        }
        log.error(sm.getString("accessLogValve.invalidLocale", name));
        return fallback;
    }
    /**
     * Start this component and implement the requirements
     * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
     *
     * @exception LifecycleException if this component detects a fatal error
     *  that prevents this component from being used
     */
    @Override
    protected synchronized void startInternal() throws LifecycleException {
        setState(LifecycleState.STARTING);
    }
    /**
     * Stop this component and implement the requirements
     * of {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
     *
     * @exception LifecycleException if this component detects a fatal error
     *  that prevents this component from being used
     */
    @Override
    protected synchronized void stopInternal() throws LifecycleException {
        setState(LifecycleState.STOPPING);
    }
    /**
     * AccessLogElement writes the partial message into the buffer.
     */
    protected interface AccessLogElement {
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time);
    }
    /**
     * write thread name - %I
     */
    protected static class ThreadNameElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            RequestInfo info = request.getCoyoteRequest().getRequestProcessor();
            if(info != null) {
                buf.append(info.getWorkerThreadName());
            } else {
                buf.append("-");
            }
        }
    }
    /**
     * write local IP address - %A
     */
    protected static class LocalAddrElement implements AccessLogElement {
        private static final String LOCAL_ADDR_VALUE;
        static {
            String init;
            try {
                init = InetAddress.getLocalHost().getHostAddress();
            } catch (Throwable e) {
                ExceptionUtils.handleThrowable(e);
                init = "127.0.0.1";
            }
            LOCAL_ADDR_VALUE = init;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            buf.append(LOCAL_ADDR_VALUE);
        }
    }
    /**
     * write remote IP address - %a
     */
    protected class RemoteAddrElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (requestAttributesEnabled) {
                Object addr = request.getAttribute(REMOTE_ADDR_ATTRIBUTE);
                if (addr == null) {
                    buf.append(request.getRemoteAddr());
                } else {
                    buf.append(addr.toString());
                }
            } else {
                buf.append(request.getRemoteAddr());
            }
        }
    }
    /**
     * write remote host name - %h
     */
    protected class HostElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            String value = null;
            if (requestAttributesEnabled) {
                Object host = request.getAttribute(REMOTE_HOST_ATTRIBUTE);
                if (host != null) {
                    value = host.toString();
                }
            }
            if (value == null || value.length() == 0) {
                value = request.getRemoteHost();
            }
            if (value == null || value.length() == 0) {
                value = "-";
            }
            buf.append(value);
        }
    }
    /**
     * write remote logical username from identd (always returns '-') - %l
     */
    protected static class LogicalUserNameElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            buf.append('-');
        }
    }
    /**
     * write request protocol - %H
     */
    protected class ProtocolElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (requestAttributesEnabled) {
                Object proto = request.getAttribute(PROTOCOL_ATTRIBUTE);
                if (proto == null) {
                    buf.append(request.getProtocol());
                } else {
                    buf.append(proto.toString());
                }
            } else {
                buf.append(request.getProtocol());
            }
        }
    }
    /**
     * write remote user that was authenticated (if any), else '-' - %u
     */
    protected static class UserElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (request != null) {
                String value = request.getRemoteUser();
                if (value != null) {
                    buf.append(value);
                } else {
                    buf.append('-');
                }
            } else {
                buf.append('-');
            }
        }
    }
    /**
     * write date and time, in configurable format (default CLF) - %t or %t{format}
     */
    protected class DateAndTimeElement implements AccessLogElement {
        /**
         * Format prefix specifying request start time
         */
        private static final String requestStartPrefix = "begin";
        /**
         * Format prefix specifying response end time
         */
        private static final String responseEndPrefix = "end";
        /**
         * Separator between optional prefix and rest of format
         */
        private static final String prefixSeparator = ":";
        /**
         * Special format for seconds since epoch
         */
        private static final String secFormat = "sec";
        /**
         * Special format for milliseconds since epoch
         */
        private static final String msecFormat = "msec";
        /**
         * Special format for millisecond part of timestamp
         */
        private static final String msecFractionFormat = "msec_frac";
        /**
         * The patterns we use to replace "S" and "SSS" millisecond
         * formatting of SimpleDateFormat by our own handling
         */
        private static final String msecPattern = "{#}";
        private static final String trippleMsecPattern =
            msecPattern + msecPattern + msecPattern;
        /* Our format description string, null if CLF */
        private final String format;
        /* Whether to use begin of request or end of response as the timestamp */
        private final boolean usesBegin;
        /* The format type */
        private final FormatType type;
        /* Whether we need to postprocess by adding milliseconds */
        private boolean usesMsecs = false;
        protected DateAndTimeElement() {
            this(null);
        }
        /**
         * Replace the millisecond formatting character 'S' by
         * some dummy characters in order to make the resulting
         * formatted time stamps cacheable. We replace the dummy
         * chars later with the actual milliseconds because that's
         * relatively cheap.
         */
        private String tidyFormat(String format) {
            boolean escape = false;
            StringBuilder result = new StringBuilder();
            int len = format.length();
            char x;
            for (int i = 0; i < len; i++) {
                x = format.charAt(i);
                if (escape || x != 'S') {
                    result.append(x);
                } else {
                    result.append(msecPattern);
                    usesMsecs = true;
                }
                if (x == '\'') {
                    escape = !escape;
                }
            }
            return result.toString();
        }
        protected DateAndTimeElement(String header) {
            String format = header;
            boolean usesBegin = false;
            FormatType type = FormatType.CLF;
            if (format != null) {
                if (format.equals(requestStartPrefix)) {
                    usesBegin = true;
                    format = "";
                } else if (format.startsWith(requestStartPrefix + prefixSeparator)) {
                    usesBegin = true;
                    format = format.substring(6);
                } else if (format.equals(responseEndPrefix)) {
                    usesBegin = false;
                    format = "";
                } else if (format.startsWith(responseEndPrefix + prefixSeparator)) {
                    usesBegin = false;
                    format = format.substring(4);
                }
                if (format.length() == 0) {
                    type = FormatType.CLF;
                } else if (format.equals(secFormat)) {
                    type = FormatType.SEC;
                } else if (format.equals(msecFormat)) {
                    type = FormatType.MSEC;
                } else if (format.equals(msecFractionFormat)) {
                    type = FormatType.MSEC_FRAC;
                } else {
                    type = FormatType.SDF;
                    format = tidyFormat(format);
                }
            }
            this.format = format;
            this.usesBegin = usesBegin;
            this.type = type;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            long timestamp = date.getTime();
            long frac;
            if (usesBegin) {
                timestamp -= time;
            }
            switch (type) {
            case CLF:
                buf.append(localDateCache.get().getFormat(timestamp));
                break;
            case SEC:
                buf.append(Long.toString(timestamp / 1000));
                break;
            case MSEC:
                buf.append(Long.toString(timestamp));
                break;
            case MSEC_FRAC:
                frac = timestamp % 1000;
                if (frac < 100) {
                    if (frac < 10) {
                        buf.append('0');
                        buf.append('0');
                    } else {
                        buf.append('0');
                    }
                }
                buf.append(Long.toString(frac));
                break;
            case SDF:
                String temp = localDateCache.get().getFormat(format, locale, timestamp);
                if (usesMsecs) {
                    frac = timestamp % 1000;
                    StringBuilder trippleMsec = new StringBuilder(4);
                    if (frac < 100) {
                        if (frac < 10) {
                            trippleMsec.append('0');
                            trippleMsec.append('0');
                        } else {
                            trippleMsec.append('0');
                        }
                    }
                    trippleMsec.append(frac);
                    temp = temp.replace(trippleMsecPattern, trippleMsec);
                    temp = temp.replace(msecPattern, Long.toString(frac));
                }
                buf.append(temp);
                break;
            }
        }
    }
    /**
     * write first line of the request (method and request URI) - %r
     */
    protected static class RequestElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (request != null) {
                String method = request.getMethod();
                if (method == null) {
                    // No method means no request line
                    buf.append('-');
                } else {
                    buf.append(request.getMethod());
                    buf.append(' ');
                    buf.append(request.getRequestURI());
                    if (request.getQueryString() != null) {
                        buf.append('?');
                        buf.append(request.getQueryString());
                    }
                    buf.append(' ');
                    buf.append(request.getProtocol());
                }
            } else {
                buf.append('-');
            }
        }
    }
    /**
     * write HTTP status code of the response - %s
     */
    protected static class HttpStatusCodeElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (response != null) {
                // This approach is used to reduce GC from toString conversion
                int status = response.getStatus();
                if (100 <= status && status < 1000) {
                    buf.append((char) ('0' + (status / 100)))
                            .append((char) ('0' + ((status / 10) % 10)))
                            .append((char) ('0' + (status % 10)));
                } else {
                   buf.append(Integer.toString(status));
                }
            } else {
                buf.append('-');
            }
        }
    }
    /**
     * write local port on which this request was received - %p
     */
    protected class LocalPortElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (requestAttributesEnabled) {
                Object port = request.getAttribute(SERVER_PORT_ATTRIBUTE);
                if (port == null) {
                    buf.append(Integer.toString(request.getServerPort()));
                } else {
                    buf.append(port.toString());
                }
            } else {
                buf.append(Integer.toString(request.getServerPort()));
            }
        }
    }
    /**
     * write bytes sent, excluding HTTP headers - %b, %B
     */
    protected static class ByteSentElement implements AccessLogElement {
        private final boolean conversion;
        /**
         * if conversion is true, write '-' instead of 0 - %b
         */
        public ByteSentElement(boolean conversion) {
            this.conversion = conversion;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            // Don't need to flush since trigger for log message is after the
            // response has been committed
            long length = response.getBytesWritten(false);
            if (length <= 0) {
                // Protect against nulls and unexpected types as these values
                // may be set by untrusted applications
                Object start = request.getAttribute(
                        Globals.SENDFILE_FILE_START_ATTR);
                if (start instanceof Long) {
                    Object end = request.getAttribute(
                            Globals.SENDFILE_FILE_END_ATTR);
                    if (end instanceof Long) {
                        length = ((Long) end).longValue() -
                                ((Long) start).longValue();
                    }
                }
            }
            if (length <= 0 && conversion) {
                buf.append('-');
            } else {
                buf.append(Long.toString(length));
            }
        }
    }
    /**
     * write request method (GET, POST, etc.) - %m
     */
    protected static class MethodElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (request != null) {
                buf.append(request.getMethod());
            }
        }
    }
    /**
     * write time taken to process the request - %D, %T
     */
    protected static class ElapsedTimeElement implements AccessLogElement {
        private final boolean millis;
        /**
         * if millis is true, write time in millis - %D
         * if millis is false, write time in seconds - %T
         */
        public ElapsedTimeElement(boolean millis) {
            this.millis = millis;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (millis) {
                buf.append(Long.toString(time));
            } else {
                // second
                buf.append(Long.toString(time / 1000));
                buf.append('.');
                int remains = (int) (time % 1000);
                buf.append(Long.toString(remains / 100));
                remains = remains % 100;
                buf.append(Long.toString(remains / 10));
                buf.append(Long.toString(remains % 10));
            }
        }
    }
    /**
     * write time until first byte is written (commit time) in millis - %F
     */
    protected static class FirstByteTimeElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request, Response response, long time) {
            long commitTime = response.getCoyoteResponse().getCommitTime();
            if (commitTime == -1) {
                buf.append('-');
            } else {
                long delta = commitTime - request.getCoyoteRequest().getStartTime();
                buf.append(Long.toString(delta));
            }
        }
    }
    /**
     * write Query string (prepended with a '?' if it exists) - %q
     */
    protected static class QueryElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            String query = null;
            if (request != null) {
                query = request.getQueryString();
            }
            if (query != null) {
                buf.append('?');
                buf.append(query);
            }
        }
    }
    /**
     * write user session ID - %S
     */
    protected static class SessionIdElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (request == null) {
                buf.append('-');
            } else {
                Session session = request.getSessionInternal(false);
                if (session == null) {
                    buf.append('-');
                } else {
                    buf.append(session.getIdInternal());
                }
            }
        }
    }
    /**
     * write requested URL path - %U
     */
    protected static class RequestURIElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (request != null) {
                buf.append(request.getRequestURI());
            } else {
                buf.append('-');
            }
        }
    }
    /**
     * write local server name - %v
     */
    protected static class LocalServerNameElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            buf.append(request.getServerName());
        }
    }
    /**
     * write any string
     */
    protected static class StringElement implements AccessLogElement {
        private final String str;
        public StringElement(String str) {
            this.str = str;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            buf.append(str);
        }
    }
    /**
     * write incoming headers - %{xxx}i
     */
    protected static class HeaderElement implements AccessLogElement {
        private final String header;
        public HeaderElement(String header) {
            this.header = header;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            Enumeration<String> iter = request.getHeaders(header);
            if (iter.hasMoreElements()) {
                buf.append(iter.nextElement());
                while (iter.hasMoreElements()) {
                    buf.append(',').append(iter.nextElement());
                }
                return;
            }
            buf.append('-');
        }
    }
    /**
     * write a specific cookie - %{xxx}c
     */
    protected static class CookieElement implements AccessLogElement {
        private final String header;
        public CookieElement(String header) {
            this.header = header;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            String value = "-";
            Cookie[] c = request.getCookies();
            if (c != null) {
                for (int i = 0; i < c.length; i++) {
                    if (header.equals(c[i].getName())) {
                        value = c[i].getValue();
                        break;
                    }
                }
            }
            buf.append(value);
        }
    }
    /**
     * write a specific response header - %{xxx}o
     */
    protected static class ResponseHeaderElement implements AccessLogElement {
        private final String header;
        public ResponseHeaderElement(String header) {
            this.header = header;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            if (null != response) {
                Iterator<String> iter = response.getHeaders(header).iterator();
                if (iter.hasNext()) {
                    buf.append(iter.next());
                    while (iter.hasNext()) {
                        buf.append(',').append(iter.next());
                    }
                    return;
                }
            }
            buf.append('-');
        }
    }
    /**
     * write an attribute in the ServletRequest - %{xxx}r
     */
    protected static class RequestAttributeElement implements AccessLogElement {
        private final String header;
        public RequestAttributeElement(String header) {
            this.header = header;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            Object value = null;
            if (request != null) {
                value = request.getAttribute(header);
            } else {
                value = "??";
            }
            if (value != null) {
                if (value instanceof String) {
                    buf.append((String) value);
                } else {
                    buf.append(value.toString());
                }
            } else {
                buf.append('-');
            }
        }
    }
    /**
     * write an attribute in the HttpSession - %{xxx}s
     */
    protected static class SessionAttributeElement implements AccessLogElement {
        private final String header;
        public SessionAttributeElement(String header) {
            this.header = header;
        }
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            Object value = null;
            if (null != request) {
                HttpSession sess = request.getSession(false);
                if (null != sess) {
                    value = sess.getAttribute(header);
                }
            } else {
                value = "??";
            }
            if (value != null) {
                if (value instanceof String) {
                    buf.append((String) value);
                } else {
                    buf.append(value.toString());
                }
            } else {
                buf.append('-');
            }
        }
    }
    /**
     * parse pattern string and create the array of AccessLogElement
     */
    protected AccessLogElement[] createLogElements() {
        List<AccessLogElement> list = new ArrayList<>();
        boolean replace = false;
        StringBuilder buf = new StringBuilder();
        for (int i = 0; i < pattern.length(); i++) {
            char ch = pattern.charAt(i);
            if (replace) {
                /*
                 * For code that processes {, the behavior will be ... if I do
                 * not encounter a closing } - then I ignore the {
                 */
                if ('{' == ch) {
                    StringBuilder name = new StringBuilder();
                    int j = i + 1;
                    for (; j < pattern.length() && '}' != pattern.charAt(j); j++) {
                        name.append(pattern.charAt(j));
                    }
                    if (j + 1 < pattern.length()) {
                        /* the +1 was to account for } which we increment now */
                        j++;
                        list.add(createAccessLogElement(name.toString(),
                                pattern.charAt(j)));
                        i = j; /* Since we walked more than one character */
                    } else {
                        // D'oh - end of string - pretend we never did this
                        // and do processing the "old way"
                        list.add(createAccessLogElement(ch));
                    }
                } else {
                    list.add(createAccessLogElement(ch));
                }
                replace = false;
            } else if (ch == '%') {
                replace = true;
                list.add(new StringElement(buf.toString()));
                buf = new StringBuilder();
            } else {
                buf.append(ch);
            }
        }
        if (buf.length() > 0) {
            list.add(new StringElement(buf.toString()));
        }
        return list.toArray(new AccessLogElement[0]);
    }
    /**
     * create an AccessLogElement implementation which needs header string
     */
    protected AccessLogElement createAccessLogElement(String header, char pattern) {
        switch (pattern) {
        case 'i':
            return new HeaderElement(header);
        case 'c':
            return new CookieElement(header);
        case 'o':
            return new ResponseHeaderElement(header);
        case 'r':
            return new RequestAttributeElement(header);
        case 's':
            return new SessionAttributeElement(header);
        case 't':
            return new DateAndTimeElement(header);
        default:
            return new StringElement("???");
        }
    }
    /**
     * create an AccessLogElement implementation
     */
    protected AccessLogElement createAccessLogElement(char pattern) {
        switch (pattern) {
        case 'a':
            return new RemoteAddrElement();
        case 'A':
            return new LocalAddrElement();
        case 'b':
            return new ByteSentElement(true);
        case 'B':
            return new ByteSentElement(false);
        case 'D':
            return new ElapsedTimeElement(true);
        case 'F':
            return new FirstByteTimeElement();
        case 'h':
            return new HostElement();
        case 'H':
            return new ProtocolElement();
        case 'l':
            return new LogicalUserNameElement();
        case 'm':
            return new MethodElement();
        case 'p':
            return new LocalPortElement();
        case 'q':
            return new QueryElement();
        case 'r':
            return new RequestElement();
        case 's':
            return new HttpStatusCodeElement();
        case 'S':
            return new SessionIdElement();
        case 't':
            return new DateAndTimeElement();
        case 'T':
            return new ElapsedTimeElement(false);
        case 'u':
            return new UserElement();
        case 'U':
            return new RequestURIElement();
        case 'v':
            return new LocalServerNameElement();
        case 'I':
            return new ThreadNameElement();
        default:
            return new StringElement("???" + pattern + "???");
        }
    }
======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

 * This is a concrete implementation of {@link AbstractAccessLogValve} that
 * outputs the access log to a file. The features of this implementation
 * include:
 * <li>Automatic date-based rollover of log files</li>
 * <li>Optional log file rotation</li>
======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

        super();
======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

    @Override
======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

        super.startInternal();
======= 92ce68a:"java/org/apache/catalina/valves/AccessLogValve.java"

        super.stopInternal();

======= bd24edc:"java/org/apache/coyote/AbstractProtocol.java"

                        if (processor.isUpgrade()) {
                            state = processor.upgradeDispatch(
                                    nextDispatch.getSocketStatus());
                        } else {
                            state = processor.asyncDispatch(
                                    nextDispatch.getSocketStatus());
                        }
======= bd24edc:"java/org/apache/coyote/http11/upgrade/AbstractProcessor.java"

    private final AbstractServletOutputStream<S> upgradeServletOutputStream;
            AbstractServletOutputStream<S> upgradeServletOutputStream) {
======= bd24edc:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

    protected final SocketWrapper<S> socketWrapper;
======= bd24edc:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

    public AbstractServletOutputStream(SocketWrapper<S> socketWrapper) {
        this.socketWrapper = socketWrapper;
    }
======= bd24edc:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

======= bd24edc:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

        // Container is responsible for first call to onWritePossible() but only
        // need to do this if setting the listener for the first time rather
        // than changing it.
        synchronized (fireListenerLock) {
            fireListener = true;
        }
        socketWrapper.addDispatch(DispatchType.NON_BLOCKING_WRITE);
======= bd24edc:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

======= bd24edc:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

                if (buffer != null) {
                    writeInternal(buffer, 0, buffer.length);
                }
======= bd24edc:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

            // Make sure isReady() and onWritePossible() have a consistent view
            // of buffer and fireListener when determining if the listener
            // should fire
======= bd24edc:"java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java"

======= bd24edc:"java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java"

    public AprServletOutputStream(SocketWrapper<Long> socketWrapper,
        super(socketWrapper);
        this.socket = socketWrapper.getSocket().longValue();
======= bd24edc:"java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java"

        Lock readLock = socketWrapper.getBlockingStatusReadLock();
        WriteLock writeLock = socketWrapper.getBlockingStatusWriteLock();
            if (socketWrapper.getBlockingStatus() == block) {
======= bd24edc:"java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java"

            socketWrapper.setBlockingStatus(block);
======= bd24edc:"java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java"

                        Integer.valueOf(-written), Long.valueOf(socket), socketWrapper));
======= bd24edc:"java/org/apache/coyote/http11/upgrade/BioServletOutputStream.java"

    public BioServletOutputStream(SocketWrapper<Socket> socketWrapper)
        super(socketWrapper);
        os = socketWrapper.getSocket().getOutputStream();
======= bd24edc:"java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java"

======= bd24edc:"java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java"

            SocketWrapper<NioChannel> socketWrapper, NioSelectorPool pool) {
        super(socketWrapper);
        channel = socketWrapper.getSocket();
======= bd24edc:"test/org/apache/coyote/http11/upgrade/TestUpgrade.java"

    @Test
    public void testFirstCallToOnWritePossible() throws Exception {
        doTestFixedResponse(FixedResponseNonBlocking.class);
    }
======= bd24edc:"test/org/apache/coyote/http11/upgrade/TestUpgrade.java"

    private void doTestFixedResponse(
            Class<? extends HttpUpgradeHandler> upgradeHandlerClass)
                    throws Exception {
        UpgradeConnection conn = doUpgrade(upgradeHandlerClass);
        Reader r = conn.getReader();
        int c = r.read();
        Assert.assertEquals(FixedResponseNonBlocking.FIXED_RESPONSE, c);
    }
======= bd24edc:"test/org/apache/coyote/http11/upgrade/TestUpgrade.java"

    public static class FixedResponseNonBlocking implements HttpUpgradeHandler {
        public static final char FIXED_RESPONSE = 'F';
        private ServletInputStream sis;
        private ServletOutputStream sos;
        @Override
        public void init(WebConnection connection) {
            try {
                sis = connection.getInputStream();
                sos = connection.getOutputStream();
            } catch (IOException ioe) {
                throw new IllegalStateException(ioe);
            }
            sis.setReadListener(new NoOpReadListener());
            sos.setWriteListener(new FixedResponseWriteListener());
        }
        @Override
        public void destroy() {
            // NO-OP
        }
        private class FixedResponseWriteListener extends NoOpWriteListener {
            @Override
            public void onWritePossible() {
                try {
                    sos.write(FIXED_RESPONSE);
                    sos.flush();
                } catch (IOException ioe) {
                    throw new IllegalStateException(ioe);
                }
            }
        }
    }
======= bd24edc:"test/org/apache/coyote/http11/upgrade/TestUpgrade.java"


======= d423ae2:"java/org/apache/coyote/http11/Http11NioProcessor.java"

        openSocket = keepAlive;
======= d423ae2:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            if (socketWrapper.getSocket().getPoller().processSendfile(key,
                    (KeyAttachment) socketWrapper, true)) {
                sendfileInProgress = true;
            } else {
                // Write failed
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("http11processor.sendfile.error"));
                }
                error = true;
            }

======= 328adb1:"java/org/apache/tomcat/util/descriptor/XmlErrorHandler.java"

======= 328adb1:"java/org/apache/tomcat/util/descriptor/XmlErrorHandler.java"

    private final List<SAXParseException> errors = new ArrayList<>();
    private final List<SAXParseException> warnings = new ArrayList<>();
======= 328adb1:"java/org/apache/tomcat/util/descriptor/XmlErrorHandler.java"

    public List<SAXParseException> getErrors() {
    public List<SAXParseException> getWarnings() {

======= 5594699:"java/org/apache/catalina/loader/WebappClassLoader.java"

        // Filter out non-JAR resources
        int jarCount = 0;
                jarCount++;
                    // Jar has been added
======= 5594699:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (jarCount < jarModificationTimes.size()){
            log.info(sm.getString("webappClassLoader.jarsRemoved",
                    resources.getContext().getName()));
            return true;
        }

======= ad129f8:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

======= ad129f8:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

 *
 * <p>
 * The two Authenticators are thoroughly exercised by two other unit test
 * classes: TestBasicAuthParser and TestNonLoginAndBasicAuthenticator.
 * This class mainly examines the way the Single SignOn Valve interacts with
 * two webapps when the second cannot be authenticated directly, but needs
 * to inherit its authentication via the other.
 *
 * <p>
 * When the server and client can both use cookies, the authentication
 * is preserved through the exchange of a JSSOSESSIONID cookie, which
 * is different to the individual and unique JSESSIONID cookies assigned
 * separately to the two webapp sessions.
 *
 * <p>
 * The other situation examined is where the server returns authentication
 * cookies, but the client is configured to ignore them. The Tomcat
 * documentation clearly states that SSO <i>requires</i> the client to
 * support cookies, so access to resources in other webapp containers
 * receives no SSO assistance.
    protected static final boolean USE_COOKIES = true;
    protected static final boolean NO_COOKIES = !USE_COOKIES;
    private static final String NICE_METHOD = "Basic";
======= ad129f8:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

    // session expiry in web.xml is defined in minutes
    private static final int SHORT_SESSION_TIMEOUT_MINS = 1;
    private static final int LONG_SESSION_TIMEOUT_MINS = 2;
    // we don't change the expiry scan interval - just the iteration count
    private static final int MANAGER_SCAN_INTERVAL_SECS = 10;
    private static final int MANAGER_EXPIRE_SESSIONS_FAST = 1;
    // now compute some delays - beware of the units!
    private static final int EXTRA_DELAY_SECS = 5;
    private static final long REASONABLE_MSECS_TO_EXPIRY =
            (((MANAGER_SCAN_INTERVAL_SECS * MANAGER_EXPIRE_SESSIONS_FAST)
                    + EXTRA_DELAY_SECS) * 1000);
    private static final String CLIENT_AUTH_HEADER = "authorization";
    private static final String SERVER_AUTH_HEADER = "WWW-Authenticate";
    private static final String SERVER_COOKIE_HEADER = "Set-Cookie";
    private static final String CLIENT_COOKIE_HEADER = "Cookie";
    private static final String ENCODE_SESSION_PARAM = "jsessionid";
    private static final String ENCODE_SSOSESSION_PARAM = "jssosessionid";
    private static final
            TestSSOnonLoginAndBasicAuthenticator.BasicCredentials
                    NO_CREDENTIALS = null;
    private static final
            TestSSOnonLoginAndBasicAuthenticator.BasicCredentials
                    GOOD_CREDENTIALS =
                new TestSSOnonLoginAndBasicAuthenticator.BasicCredentials(
                            NICE_METHOD, USER, PWD);
    private Tomcat tomcat;
    private Context basicContext;
    private Context nonloginContext;
    private String encodedURL;
     * Run some sanity checks without an established SSO session
     * to make sure the test environment is correct.
    public void testEssentialEnvironment() throws Exception {
        // should be permitted to access an unprotected resource.
                       USE_COOKIES, HttpServletResponse.SC_OK);
        // should not be permitted to access a protected resource
        // with the two Authenticators used in the remaining tests.
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                USE_COOKIES, HttpServletResponse.SC_FORBIDDEN);
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                NO_CREDENTIALS, USE_COOKIES,
                HttpServletResponse.SC_UNAUTHORIZED);
    public void testEssentialEnvironmentWithoutCookies() throws Exception {
        // should be permitted to access an unprotected resource.
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PUBLIC,
                       NO_COOKIES, HttpServletResponse.SC_OK);
        // should not be permitted to access a protected resource
        // with the two Authenticators used in the remaining tests.
                NO_COOKIES, HttpServletResponse.SC_FORBIDDEN);
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                NO_CREDENTIALS, NO_COOKIES,
                HttpServletResponse.SC_UNAUTHORIZED);
     * the resource. This should be rejected with SC_FORBIDDEN 401 status.
     *
     * Note: this test will run for slightly more than 1 minute.
    public void testBasicAccessAndSessionTimeout() throws Exception {
        setRapidSessionTimeoutDetection();
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                NO_CREDENTIALS, USE_COOKIES,
                HttpServletResponse.SC_UNAUTHORIZED);
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                GOOD_CREDENTIALS, USE_COOKIES,
                HttpServletResponse.SC_OK);
        // verify the SSOID exists as a cookie
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                GOOD_CREDENTIALS, USE_COOKIES,
                HttpServletResponse.SC_OK);
        // make the session time out and lose authentication
        doImminentSessionTimeout(basicContext);
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                NO_CREDENTIALS, USE_COOKIES,
                HttpServletResponse.SC_UNAUTHORIZED);
     * webapp while providing the SSO session cookie received from the
     * first webapp. This should be successful with SC_OK 200 status.
    public void testBasicLoginThenAcceptWithCookies() throws Exception {
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                NO_CREDENTIALS, NO_COOKIES,
                HttpServletResponse.SC_UNAUTHORIZED);
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                GOOD_CREDENTIALS, USE_COOKIES, HttpServletResponse.SC_OK);
        // send the cookie which proves we have an authenticated SSO session
                       USE_COOKIES, HttpServletResponse.SC_OK);
     * webapp, but without sending the SSO session cookie.
     * This should be rejected with SC_FORBIDDEN 403 status.
    public void testBasicLoginThenRejectWithoutCookie() throws Exception {
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                NO_CREDENTIALS, USE_COOKIES,
                HttpServletResponse.SC_UNAUTHORIZED);
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                GOOD_CREDENTIALS, USE_COOKIES,
                HttpServletResponse.SC_OK);
        // fail to send the authentication cookie to the other webapp.
                NO_COOKIES, HttpServletResponse.SC_FORBIDDEN);
    }
    /*
     * Logon to access a protected resource using BASIC authentication,
     * which will establish an SSO session.
     * Then try to access a protected resource in the NonLogin
     * webapp by sending the JSESSIONID from the redirect header.
     * The access request should be rejected because the Basic webapp's
     * sessionID is not valid for any other container.
     */
    @Test
    public void testBasicAccessThenAcceptAuthWithUri() throws Exception {
        setAlwaysUseSession();
        // first, fail to access the protected resource without credentials
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                NO_CREDENTIALS, NO_COOKIES,
                HttpServletResponse.SC_UNAUTHORIZED);
        // now, access the protected resource with good credentials
        // to establish the session
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                GOOD_CREDENTIALS, NO_COOKIES,
                HttpServletResponse.SC_OK);
        // next, access it again to harvest the session id url parameter
        String forwardParam = "?nextUrl=" + CONTEXT_PATH_LOGIN + URI_PROTECTED;
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED + forwardParam,
                GOOD_CREDENTIALS, NO_COOKIES,
                HttpServletResponse.SC_OK);
        // verify the sessionID was encoded in the absolute URL
        String firstEncodedURL = encodedURL;
        assertTrue(firstEncodedURL.contains(ENCODE_SESSION_PARAM));
        // access the protected resource with the encoded url (with session id)
        doTestBasic(firstEncodedURL + forwardParam,
                NO_CREDENTIALS, NO_COOKIES,
                HttpServletResponse.SC_OK);
        // verify the sessionID has not changed
        // verify the SSO sessionID was not encoded
        String secondEncodedURL = encodedURL;
        assertEquals(firstEncodedURL, secondEncodedURL);
        assertFalse(firstEncodedURL.contains(ENCODE_SSOSESSION_PARAM));
        // extract the first container's session ID
        int ix = secondEncodedURL.indexOf(ENCODE_SESSION_PARAM);
        String sessionId = secondEncodedURL.substring(ix);
        // expect to fail using that sessionID in a different container
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED + ";" + sessionId,
                NO_COOKIES, HttpServletResponse.SC_FORBIDDEN);
     * webapp while providing the SSO session cookie received from the
     * first webapp. This should be successful with SC_OK 200 status.
     * has expired. This should be successful with SC_OK 200 status.
     *
     * Note: this test will run for slightly more than 3 minutes.
        setRapidSessionTimeoutDetection();
        // begin with a repeat of testBasicLoginAcceptProtectedWithCookies
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                NO_CREDENTIALS, USE_COOKIES,
                HttpServletResponse.SC_UNAUTHORIZED);
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                GOOD_CREDENTIALS, USE_COOKIES,
                HttpServletResponse.SC_OK);
                       USE_COOKIES, HttpServletResponse.SC_OK);
        // but not long enough for the NonLogin session expiry.
        doImminentSessionTimeout(basicContext);
        // this successful NonLogin access should replenish the
        // the individual session expiry time and keep the SSO session alive
                       USE_COOKIES, HttpServletResponse.SC_OK);
        // wait long enough for the NonLogin session to expire,
        // which will also tear down the SSO session at the same time.
        doImminentSessionTimeout(nonloginContext);
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED, USE_COOKIES,
                HttpServletResponse.SC_FORBIDDEN);
        doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED,
                NO_CREDENTIALS, USE_COOKIES,
                HttpServletResponse.SC_UNAUTHORIZED);
    public void doTestNonLogin(String uri, boolean useCookie,
            int expectedRC) throws Exception {
        if (useCookie && (cookies != null)) {
            reqHeaders.put(CLIENT_COOKIE_HEADER + ":", cookies);
        }
        if (expectedRC != HttpServletResponse.SC_OK) {
    private void doTestBasic(String uri,
            TestSSOnonLoginAndBasicAuthenticator.BasicCredentials credentials,
            boolean useCookie, int expectedRC) throws Exception {
        Map<String,List<String>> reqHeaders = new HashMap<>();
        Map<String,List<String>> respHeaders = new HashMap<>();
        if (useCookie && (cookies != null)) {
            reqHeaders.put(CLIENT_COOKIE_HEADER + ":", cookies);
            if (credentials != null) {
                List<String> auth = new ArrayList<>();
                auth.add(credentials.getCredentials());
                reqHeaders.put(CLIENT_AUTH_HEADER, auth);
            }
        ByteChunk bc = new ByteChunk();
        int rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders,
                respHeaders);
        assertEquals("Unexpected Return Code", expectedRC, rc);
        if (expectedRC != HttpServletResponse.SC_OK) {
            assertTrue(bc.getLength() > 0);
            if (expectedRC == HttpServletResponse.SC_UNAUTHORIZED) {
                // The server should identify the acceptable method(s)
                boolean methodFound = false;
                List<String> authHeaders = respHeaders.get(SERVER_AUTH_HEADER);
                for (String authHeader : authHeaders) {
                    if (authHeader.indexOf(NICE_METHOD) > -1) {
                        methodFound = true;
                        break;
                    }
                }
                assertTrue(methodFound);
            }
            String thePage = bc.toString();
            assertNotNull(thePage);
            assertTrue(thePage.startsWith("OK"));
            if (useCookie) {
                List<String> newCookies = respHeaders.get(SERVER_COOKIE_HEADER);
                if (newCookies != null) {
                    // harvest cookies whenever the server sends some new ones
                    cookies = newCookies;
                }
            }
            else {
                encodedURL = "";
                final String start = "<a href=\"";
                final String end = "\">";
                int iStart = thePage.indexOf(start);
                int iEnd = 0;
                if (iStart > -1) {
                    iStart += start.length();
                    iEnd = thePage.indexOf(end, iStart);
                    if (iEnd > -1) {
                        encodedURL = thePage.substring(iStart, iEnd);
                    }
                }
            }
    /*
     * setup two webapps for every test
     *
     * note: the super class tearDown method will stop tomcat
     */
        tomcat = getTomcatInstance();
======= ad129f8:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        setUpNonLogin();
        setUpLogin();
    @Override
    public void tearDown() throws Exception {
        tomcat.stop();
    }
    private void setUpNonLogin() throws Exception {
        nonloginContext = tomcat.addContext(CONTEXT_PATH_NOLOGIN,
        nonloginContext.setSessionTimeout(LONG_SESSION_TIMEOUT_MINS);
        // Add protected servlet to the context
        Tomcat.addServlet(nonloginContext, "TesterServlet1",
                new TesterServletEncodeUrl());
        nonloginContext.addServletMapping(URI_PROTECTED, "TesterServlet1");
        nonloginContext.addConstraint(sc1);
        // Add unprotected servlet to the context
        Tomcat.addServlet(nonloginContext, "TesterServlet2",
                new TesterServletEncodeUrl());
        nonloginContext.addServletMapping(URI_PUBLIC, "TesterServlet2");
        nonloginContext.addConstraint(sc2);
        nonloginContext.setLoginConfig(lc);
        AuthenticatorBase nonloginAuthenticator = new NonLoginAuthenticator();
        nonloginContext.getPipeline().addValve(nonloginAuthenticator);
    private void setUpLogin() throws Exception {
        basicContext = tomcat.addContext(CONTEXT_PATH_LOGIN,
        basicContext.setSessionTimeout(SHORT_SESSION_TIMEOUT_MINS);
        // Add protected servlet to the context
        Tomcat.addServlet(basicContext, "TesterServlet3",
                new TesterServletEncodeUrl());
        basicContext.addServletMapping(URI_PROTECTED, "TesterServlet3");
        basicContext.addConstraint(sc);
        // Add unprotected servlet to the context
        Tomcat.addServlet(basicContext, "TesterServlet4",
                new TesterServletEncodeUrl());
        basicContext.addServletMapping(URI_PUBLIC, "TesterServlet4");
        SecurityCollection collection2 = new SecurityCollection();
        collection2.addPattern(URI_PUBLIC);
        SecurityConstraint sc2 = new SecurityConstraint();
        // do not add a role - which signals access permitted without one
        sc2.addCollection(collection2);
        basicContext.addConstraint(sc2);
        // Configure the authenticator and inherit the Realm from Engine
        basicContext.setLoginConfig(lc);
        AuthenticatorBase basicAuthenticator = new BasicAuthenticator();
        basicContext.getPipeline().addValve(basicAuthenticator);
======= ad129f8:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

        cookies = respHeaders.get(SERVER_COOKIE_HEADER);
======= ad129f8:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

            reqHeaders.put(CLIENT_COOKIE_HEADER + ":", cookies);
        }
    }
    /*
     * Force non-default behaviour for both Authenticators.
     * The session id will not be regenerated after authentication,
     * which is less secure but needed for browsers that will not
     * handle cookies.
     */
    private void setAlwaysUseSession() {
        ((AuthenticatorBase) basicContext.getAuthenticator())
                .setAlwaysUseSession(true);
        ((AuthenticatorBase) nonloginContext.getAuthenticator())
                .setAlwaysUseSession(true);
    }
    /*
     * Force faster timeout for an active Container than can
     * be defined in web.xml. By getting to the active Session we
     * can choose seconds instead of minutes.
     * Note: shamelessly cloned from ManagerBase - beware of synch issues
     *       on the underlying sessions.
     */
    private void doImminentSessionTimeout(Context activeContext) {
        ManagerBase manager = (ManagerBase) activeContext.getManager();
        Session[] sessions = manager.findSessions();
        for (int i = 0; i < sessions.length; i++) {
            if (sessions[i]!=null && sessions[i].isValid()) {
                sessions[i].setMaxInactiveInterval(EXTRA_DELAY_SECS);
                // leave it to be expired by the manager
            }
        }
        try {
            Thread.sleep(REASONABLE_MSECS_TO_EXPIRY);
        } catch (InterruptedException ie) {
            // ignored
        }
        // paranoid verification that active sessions have now gone
        sessions = manager.findSessions();
        assertTrue(sessions.length == 0);
    }
    /*
     * Force rapid timeout scanning for both webapps
     * The StandardManager default service cycle time is 10 seconds,
     * with a session expiry scan every 6 cycles.
     */
    private void setRapidSessionTimeoutDetection() {
        ((ManagerBase) basicContext.getManager())
                .setProcessExpiresFrequency(MANAGER_EXPIRE_SESSIONS_FAST);
        ((ManagerBase) nonloginContext.getManager())
                .setProcessExpiresFrequency(MANAGER_EXPIRE_SESSIONS_FAST);
    }
    /*
     * Encapsulate the logic to generate an HTTP header
     * for BASIC Authentication.
     * Note: only used internally, so no need to validate arguments.
     */
    private static final class BasicCredentials {
        private final String method;
        private final String username;
        private final String password;
        private final String credentials;
        private BasicCredentials(String aMethod,
                String aUsername, String aPassword) {
            method = aMethod;
            username = aUsername;
            password = aPassword;
            String userCredentials = username + ":" + password;
            byte[] credentialsBytes =
                    userCredentials.getBytes(StandardCharsets.ISO_8859_1);
            String base64auth = Base64.encodeBase64String(credentialsBytes);
            credentials= method + " " + base64auth;
        }
        private String getCredentials() {
            return credentials;
======= ad129f8:"test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * A test servlet that will always encode the url in case the client requires
 * session persistence but is not configured to support cookies.
 */
    private static final long serialVersionUID = 1L;
    /**
     * Almost minimal processing for a servlet.
     *
     * @param nextUrl The url the caller would like to go to next. If
     *                supplied, put an encoded url into the returned
     *                html page as a hyperlink.
     */
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        resp.setContentType("text/plain");
        PrintWriter out = resp.getWriter();
        out.print("OK");
        String param = req.getParameter("nextUrl");
        if (param!=null) {
            // append an encoded url to carry the sessionids
            String targetUrl = resp.encodeURL(param);
            out.print(". You want to go <a href=\"");
            out.print(targetUrl);
            out.print("\">here next</a>.");
        }
    }

======= 5964a52:"java/org/apache/catalina/core/ContainerBase.java"

                ContextName cn = new ContextName(c.getName(), false);
======= 5964a52:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            ContextName cn = new ContextName(deployWar.getName(), true);
======= 5964a52:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            ContextName cn = new ContextName(removeWar.getName(), true);
======= 5964a52:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                ContextName cn = new ContextName(filename, true);
======= 5964a52:"java/org/apache/catalina/mbeans/MBeanUtils.java"

            ContextName cn = new ContextName(context.getName(), false);
======= 5964a52:"java/org/apache/catalina/mbeans/MBeanUtils.java"

            ContextName cn = new ContextName(context.getName(), false);
======= 5964a52:"java/org/apache/catalina/mbeans/MBeanUtils.java"

            ContextName cn = new ContextName(context.getName(), false);
======= 5964a52:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        ContextName cn = new ContextName(context.getName(), false);
======= 5964a52:"java/org/apache/catalina/startup/FailedContext.java"

                ContextName cn = new ContextName(c.getName(), false);
======= 5964a52:"java/org/apache/catalina/startup/HostConfig.java"

        ContextName cn = new ContextName(name, false);
======= 5964a52:"java/org/apache/catalina/startup/HostConfig.java"

                ContextName cn = new ContextName(files[i], true);
======= 5964a52:"java/org/apache/catalina/startup/HostConfig.java"

                ContextName cn = new ContextName(files[i], true);
======= 5964a52:"java/org/apache/catalina/startup/HostConfig.java"

                ContextName cn = new ContextName(files[i], false);
======= 5964a52:"java/org/apache/catalina/startup/HostConfig.java"

        ContextName previous = new ContextName(iter.next(), false);
            ContextName current = new ContextName(iter.next(), false);
======= 5964a52:"java/org/apache/catalina/storeconfig/StandardContextSF.java"

                    ContextName cn = new ContextName(context.getName(), false);
======= 5964a52:"java/org/apache/catalina/util/ContextName.java"

     * @param stripFileExtension    If a .war or .xml file extension is present
     *                              at the end of the provided name should it be
     *                              removed?
    public ContextName(String name, boolean stripFileExtension) {
======= 5964a52:"java/org/apache/catalina/util/ContextName.java"

        if (stripFileExtension &&
                (tmp1.toLowerCase(Locale.ENGLISH).endsWith(".war") ||
                        tmp1.toLowerCase(Locale.ENGLISH).endsWith(".xml"))) {
======= 5964a52:"test/org/apache/catalina/startup/TestHostConfigAutomaticDeployment.java"

    private static final ContextName  APP_NAME = new ContextName("myapp", false);
======= 5964a52:"test/org/apache/catalina/util/TestContextName.java"

    private ContextName cn21;
    private ContextName cn22;
======= 5964a52:"test/org/apache/catalina/util/TestContextName.java"

        cn11 = new ContextName("ROOT", false);
        cn12 = new ContextName("foo", false);
        cn13 = new ContextName("foo#bar", false);
        cn14 = new ContextName("ROOT##A", false);
        cn15 = new ContextName("foo##D", false);
        cn16 = new ContextName("foo#bar##E", false);
        cn18 = new ContextName("/ROOT#bar", false);
        cn19 = new ContextName("/ROOT#bar##A", false);
        cn20 = new ContextName("/ROOT##A", false);
        cn21 = new ContextName("foo.war", false);
        cn22 = new ContextName("foo.war", true);
======= 5964a52:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("foo.war", cn21.getBaseName());
        assertEquals("foo", cn22.getBaseName());
======= 5964a52:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("/foo.war", cn21.getPath());
        assertEquals("/foo", cn22.getPath());
======= 5964a52:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("", cn21.getVersion());
        assertEquals("", cn22.getVersion());
======= 5964a52:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("/foo.war", cn21.getName());
        assertEquals("/foo", cn22.getName());
======= 5964a52:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("/foo.war", cn21.getDisplayName());
        assertEquals("/foo", cn22.getDisplayName());
======= 5964a52:"test/org/apache/catalina/util/TestContextName.java"

        doTestConstructorString(cn21);
        doTestConstructorString(cn22);
        doCompare(src, new ContextName(src.getBaseName(), false));
        doCompare(src, new ContextName(src.getDisplayName(), false));
        doCompare(src, new ContextName(src.getName(), false));

======= 346e264:"java/org/apache/catalina/util/ContextName.java"

        // Path should never be null, '/' or '/ROOT'
        if (path == null || "/".equals(path) || "/ROOT".equals(path)) {
======= 346e264:"test/org/apache/catalina/util/TestContextName.java"

    private ContextName cn17;
    private ContextName cn18;
    private ContextName cn19;
    private ContextName cn20;
======= 346e264:"test/org/apache/catalina/util/TestContextName.java"

        cn17 = new ContextName("/ROOT", null);
        cn18 = new ContextName("/ROOT#bar");
        cn19 = new ContextName("/ROOT#bar##A");
        cn20 = new ContextName("/ROOT##A");
======= 346e264:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("ROOT", cn17.getBaseName());
        assertEquals("ROOT#bar", cn18.getBaseName());
        assertEquals("ROOT#bar##A", cn19.getBaseName());
        assertEquals("ROOT##A", cn20.getBaseName());
======= 346e264:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("", cn17.getPath());
        assertEquals("/ROOT/bar", cn18.getPath());
        assertEquals("/ROOT/bar", cn19.getPath());
        assertEquals("", cn20.getPath());
======= 346e264:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("", cn17.getVersion());
        assertEquals("", cn18.getVersion());
        assertEquals("A", cn19.getVersion());
        assertEquals("A", cn20.getVersion());
======= 346e264:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("", cn17.getName());
        assertEquals("/ROOT/bar", cn18.getName());
        assertEquals("/ROOT/bar##A", cn19.getName());
        assertEquals("##A", cn20.getName());
======= 346e264:"test/org/apache/catalina/util/TestContextName.java"

        assertEquals("/", cn17.getDisplayName());
        assertEquals("/ROOT/bar", cn18.getDisplayName());
        assertEquals("/ROOT/bar##A", cn19.getDisplayName());
        assertEquals("/##A", cn20.getDisplayName());
======= 346e264:"test/org/apache/catalina/util/TestContextName.java"

        doTestConstructorString(cn17);
        doTestConstructorString(cn18);
        doTestConstructorString(cn19);
        doTestConstructorString(cn20);

======= 411e4cc:"java/org/apache/coyote/Response.java"

        // Servlet 3.1 non-blocking write listener
        fireListener = false;
        registeredForWrite = false;

======= bcb9c58:"java/org/apache/jasper/servlet/TldScanner.java"

            if (url != null) {
                TldResourcePath tldResourcePath;
                if (resourcePath.endsWith(".jar")) {
                    // if the path points to a jar file, the TLD is presumed to be
                    // inside at META-INF/taglib.tld
                    tldResourcePath = new TldResourcePath(url, resourcePath, "META-INF/taglib.tld");
                } else {
                    tldResourcePath = new TldResourcePath(url, resourcePath);
                }
                // parse TLD but store using the URI supplied in the descriptor
                TaglibXml tld = tldParser.parse(tldResourcePath);
                uriTldResourcePathMap.put(taglibURI, tldResourcePath);
                tldResourcePathTaglibXmlMap.put(tldResourcePath, tld);
                if (tld.getListeners() != null) {
                    listeners.addAll(tld.getListeners());
                }
                log.warn(Localizer.getMessage(MSG + ".webxmlFailPathDoesNotExist",
                        resourcePath,
                        taglibURI));
                continue;

======= 8a5179c:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

======= 8a5179c:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

            for (int i = 0; i < urls.length; i++) {
                // Tomcat can use URLs other than file URLs. However, a protocol
                // other than file: will generate a bad file system path, so
                // only add file: protocol URLs to the classpath.
                if (urls[i].getProtocol().equals("file") ) {
                    try {
                        // Need to decode the URL, primarily to convert %20
                        // sequences back to spaces
                        String decoded = URLDecoder.decode(urls[i].getPath(), "UTF-8");
                        cpath.append(decoded + sep);
                    } catch (UnsupportedEncodingException e) {
                        // All JREs are required to support UTF-8
                    }

======= c1be72f:"java/org/apache/catalina/filters/RemoteIpFilter.java"

 * <td>10\.\d{1,3}\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|
 *     169\.254\.\d{1,3}\.\d{1,3}|127\.\d{1,3}\.\d{1,3}\.\d{1,3}|
 *     172\.1[6-9]{1}\.\d{1,3}\.\d{1,3}|172\.2[0-9]{1}\.\d{1,3}\.\d{1,3}|
 *     172\.3[0-1]{1}\.\d{1,3}\.\d{1,3}
 *     <br/>
 * By default, 10/8, 192.168/16, 169.254/16, 127/8 and 172.16/12 are allowed.</td>
======= c1be72f:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            "127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|" +
            "172\\.1[6-9]{1}\\.\\d{1,3}\\.\\d{1,3}|" +
            "172\\.2[0-9]{1}\\.\\d{1,3}\\.\\d{1,3}|" +
            "172\\.3[0-1]{1}\\.\\d{1,3}\\.\\d{1,3}");
======= c1be72f:"java/org/apache/catalina/valves/RemoteIpValve.java"

 * <td>10\.\d{1,3}\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|
 *     169\.254\.\d{1,3}\.\d{1,3}|127\.\d{1,3}\.\d{1,3}\.\d{1,3}|
 *     172\.1[6-9]{1}\.\d{1,3}\.\d{1,3}|172\.2[0-9]{1}\.\d{1,3}\.\d{1,3}|
 *     172\.3[0-1]{1}\.\d{1,3}\.\d{1,3}
 *     <br/>
 * By default, 10/8, 192.168/16, 169.254/16, 127/8 and 172.16/12 are allowed.</td>
======= c1be72f:"java/org/apache/catalina/valves/RemoteIpValve.java"

            "127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|" +
            "172\\.1[6-9]{1}\\.\\d{1,3}\\.\\d{1,3}|" +
            "172\\.2[0-9]{1}\\.\\d{1,3}\\.\\d{1,3}|" +
            "172\\.3[0-1]{1}\\.\\d{1,3}\\.\\d{1,3}");
        10\.\d{1,3}\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|169\.254\.\d{1,3}\.\d{1,3}|127\.\d{1,3}\.\d{1,3}\.\d{1,3}|172\.1[6-9]{1}\.\d{1,3}\.\d{1,3}|172\.2[0-9]{1}\.\d{1,3}\.\d{1,3}|172\.3[0-1]{1}\.\d{1,3}\.\d{1,3}
        10\.\d{1,3}\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|169\.254\.\d{1,3}\.\d{1,3}|127\.\d{1,3}\.\d{1,3}\.\d{1,3}|172\.1[6-9]{1}\.\d{1,3}\.\d{1,3}|172\.2[0-9]{1}\.\d{1,3}\.\d{1,3}|172\.3[0-1]{1}\.\d{1,3}\.\d{1,3}

======= f4da7dc:"java/org/apache/catalina/startup/ContextConfig.java"

        Map<String,WebXml> fragments = processJarsForWebFragments(webXml);
======= f4da7dc:"java/org/apache/catalina/startup/ContextConfig.java"

    protected Map<String,WebXml> processJarsForWebFragments(WebXml application) {
        boolean parseRequired = true;
        Set<String> absoluteOrder = application.getAbsoluteOrdering();
        if (absoluteOrder != null && absoluteOrder.isEmpty() &&
                !context.getXmlValidation()) {
            // Skip parsing when there is an empty absolute ordering and
            // validation is not enabled
            parseRequired = false;
        }
                new FragmentJarScannerCallback(webXmlParser, delegate, parseRequired);
======= f4da7dc:"java/org/apache/jasper/servlet/JspCServletContext.java"

        // If an empty absolute ordering element is present, fragment processing
        // may be skipped.
        Set<String> absoluteOrdering = webXml.getAbsoluteOrdering();
        if (absoluteOrdering != null && absoluteOrdering.isEmpty()) {
            return webXml;
        }
======= f4da7dc:"java/org/apache/jasper/servlet/JspCServletContext.java"

        FragmentJarScannerCallback callback =
                new FragmentJarScannerCallback(webXmlParser, false, true);
======= f4da7dc:"java/org/apache/tomcat/util/descriptor/web/FragmentJarScannerCallback.java"

    private final boolean parseRequired;
    public FragmentJarScannerCallback(WebXmlParser webXmlParser, boolean delegate,
            boolean parseRequired) {
        this.parseRequired = parseRequired;
======= f4da7dc:"java/org/apache/tomcat/util/descriptor/web/FragmentJarScannerCallback.java"

            // files.
            // web-fragment.xml files don't need to be parsed if they are never
            // going to be used.
            if (isWebapp && parseRequired) {

======= ef3f56e:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

    /**
     * Property name to set to configure used SSLContext. The value should be an
     * instance of SSLContext. If this property is present, the SSL_TRUSTSTORE*
     * properties are ignored.
     */
    public static final String SSL_CONTEXT_PROPERTY =
            "org.apache.tomcat.websocket.SSL_CONTEXT";
======= ef3f56e:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

            // See if a custom SSLContext has been provided
            SSLContext sslContext =
                    (SSLContext) userProperties.get(SSL_CONTEXT_PROPERTY);
            if (sslContext == null) {
                // Create the SSL Context
                sslContext = SSLContext.getInstance("TLS");
                // Trust store
                String sslTrustStoreValue =
                        (String) userProperties.get(SSL_TRUSTSTORE_PROPERTY);
                if (sslTrustStoreValue != null) {
                    String sslTrustStorePwdValue = (String) userProperties.get(
                            SSL_TRUSTSTORE_PWD_PROPERTY);
                    if (sslTrustStorePwdValue == null) {
                        sslTrustStorePwdValue = SSL_TRUSTSTORE_PWD_DEFAULT;
                    }
                    File keyStoreFile = new File(sslTrustStoreValue);
                    KeyStore ks = KeyStore.getInstance("JKS");
                    try (InputStream is = new FileInputStream(keyStoreFile)) {
                        ks.load(is, sslTrustStorePwdValue.toCharArray());
                    }
                    TrustManagerFactory tmf = TrustManagerFactory.getInstance(
                            TrustManagerFactory.getDefaultAlgorithm());
                    tmf.init(ks);
                    sslContext.init(null, tmf.getTrustManagers(), null);
                } else {
                    sslContext.init(null, null, null);
                }
     <li><code>org.apache.tomcat.websocket.SSL_CONTEXT</code></li>
   <p>If the <code>org.apache.tomcat.websocket.SSL_CONTEXT</code> property is
      set then the <code>org.apache.tomcat.websocket.SSL_TRUSTSTORE</code> and
      <code>org.apache.tomcat.websocket.SSL_TRUSTSTORE_PWD</code> properties
      will be ignored.</p>

======= bba9747:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

            outToken = Subject.doAs(lc.getSubject(), new AcceptAction(gssContext, decoded));
======= bba9747:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

    /**
     * This class gets a gss credential via a privileged action.
     */
    private static class AcceptAction implements PrivilegedExceptionAction<byte[]> {
        GSSContext gssContext;
        byte[] decoded;
        AcceptAction(GSSContext context, byte[] decodedToken) {
            this.gssContext = context;
            this.decoded = decodedToken;
        }
        @Override
        public byte[] run() throws GSSException {
            return gssContext.acceptSecContext(decoded,
                    0, decoded.length);
        }
    }

======= f4970a7:"java/org/apache/catalina/connector/OutputBuffer.java"

                if (bb.getBuffer().length == bb.getEnd() && bb.getLength() < bb.getLimit()) {
                    // Need to expand output buffer
                    bb.makeSpace(outputCharChunk.getLength());
                } else {
                    bb.flushBuffer();
                }
======= f4970a7:"java/org/apache/tomcat/util/buf/ByteChunk.java"

    /**
     * Make space for len chars. If len is small, allocate a reserve space too.
     * Never grow bigger than limit.
    public void makeSpace(int count) {

======= a63bf3a:"java/org/apache/catalina/webresources/DirResourceSet.java"

            File f = file(path.substring(webAppMount.length()), false);
            if (!f.exists()) {
                return new EmptyResource(root, path, f);
            }
======= a63bf3a:"java/org/apache/catalina/webresources/EmptyResource.java"

======= a63bf3a:"java/org/apache/catalina/webresources/EmptyResource.java"

    private final File file;
        this(root, webAppPath, null);
    }
    public EmptyResource(WebResourceRoot root, String webAppPath, File file) {
        this.file = file;
======= a63bf3a:"java/org/apache/catalina/webresources/EmptyResource.java"

        if (file == null) {
            return null;
        } else {
            try {
                return file.getCanonicalPath();
            } catch (IOException e) {
                return null;
            }
        }
======= a63bf3a:"java/org/apache/catalina/webresources/StandardRoot.java"

        WebResource mainEmpty = null;
======= a63bf3a:"java/org/apache/catalina/webresources/StandardRoot.java"

                    if (virtual == null) {
                        if (result.isVirtual()) {
                            virtual = result;
                        } else if (main.equals(webResourceSet)) {
                            mainEmpty = result;
                        }
======= a63bf3a:"java/org/apache/catalina/webresources/StandardRoot.java"

        return mainEmpty;
======= a63bf3a:"test/org/apache/catalina/webresources/AbstractTestResourceSet.java"

======= a63bf3a:"test/org/apache/catalina/webresources/AbstractTestResourceSet.java"

    // ------------------------------------------------------ getCanonicalPath()
    @Test
    public final void testGetCanonicalPathExists() {
        WebResource exists =
                resourceRoot.getResource(getMount() + "/d1/d1-f1.txt");
        String existsCanonicalPath = exists.getCanonicalPath();
        URL existsUrl = exists.getURL();
        if ("file".equals(existsUrl.getProtocol())) {
            // Should have a canonical path
            Assert.assertNotNull(existsCanonicalPath);
        } else {
            Assert.assertNull(existsCanonicalPath);
        }
    }
    @Test
    public final void testGetCanonicalPathDoesNotExist() {
        WebResource exists =
                resourceRoot.getResource(getMount() + "/d1/d1-f1.txt");
        WebResource doesNotExist =
                resourceRoot.getResource(getMount() + "/d1/dummy.txt");
        String doesNotExistCanonicalPath = doesNotExist.getCanonicalPath();
        URL existsUrl = exists.getURL();
        if ("file".equals(existsUrl.getProtocol())) {
            // Should be possible to construct a canonical path for a resource
            // that doesn't exist given that a resource that does exist in the
            // same directory has a URL with the file protocol
            Assert.assertNotNull(doesNotExistCanonicalPath);
        } else {
            Assert.assertNull(doesNotExistCanonicalPath);
        }
    }

======= 8f67335:"java/org/apache/catalina/connector/Request.java"

======= 8f67335:"java/org/apache/catalina/connector/Request.java"

            GSSCredential gssCredential =
                    ((TomcatPrincipal) userPrincipal).getGssCredential();
            if (gssCredential != null) {
                int left = -1;
                try {
                    left = gssCredential.getRemainingLifetime();
                } catch (GSSException e) {
                    log.warn(sm.getString("coyoteRequest.gssLifetimeFail",
                            userPrincipal.getName()), e);
                }
                if (left == 0) {
                    // GSS credential has expired. Need to re-authenticate.
                    try {
                        logout();
                    } catch (ServletException e) {
                        // Should never happen (no code called by logout()
                        // throws a ServletException
                    }
                    return null;
                }
            }

======= 13c6551:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                    log.error(sm.getString("memoryUserDatabase.fileNotFound",
                            file.getAbsolutePath()));

======= 27806aa:"java/org/apache/catalina/realm/JNDIRealm.java"

    /**
     * The QOP that should be used for the connection to the LDAP server after
     * authentication. This value is used to set the
     * <code>javax.security.sasl.qop</code> environment property for the LDAP
     * connection.
     */
    protected String spengoDelegationQop = "auth-conf";
======= 27806aa:"java/org/apache/catalina/realm/JNDIRealm.java"

======= 27806aa:"java/org/apache/catalina/realm/JNDIRealm.java"

    public String getSpengoDelegationQop() {
        return spengoDelegationQop;
    }
    public void setSpengoDelegationQop(String spengoDelegationQop) {
        this.spengoDelegationQop = spengoDelegationQop;
    }
======= 27806aa:"java/org/apache/catalina/realm/JNDIRealm.java"

                        "javax.security.sasl.qop", spengoDelegationQop);
      <attribute mame="spengoDelegationQop" requireed="false">
        <p>When the JNDI Realm is used with the SPNEGO authenticator and
        <code>useDelegatedCredential</code> is <code>true</code> this attribute
        controls the QOP that should be used for the connection to the LDAP
        server after authentication. This value is used to set the
        <code>javax.security.sasl.qop</code> environment property for the LDAP
        connection. This attribute should be a comma-separated list of values
        selected from <code>auth-conf</code>, <code>auth-int</code> and
        <code>auth</code>. The default value is <code>auth-conf</code>.</p>
      </attribute>
        <p>When the JNDIRealm is used with the SPNEGO authenticator, delegated

======= a1ad6ce:"java/org/apache/catalina/webresources/StandardRoot.java"

======= a1ad6ce:"java/org/apache/catalina/webresources/StandardRoot.java"

    private String[] list(String path, boolean validate) {
        if (validate) {
            path = validate(path);
======= a1ad6ce:"java/org/apache/catalina/webresources/StandardRoot.java"

        path = validate(path);
======= a1ad6ce:"java/org/apache/catalina/webresources/StandardRoot.java"

        path = validate(path);
======= a1ad6ce:"java/org/apache/catalina/webresources/StandardRoot.java"

        path = validate(path);
======= a1ad6ce:"java/org/apache/catalina/webresources/StandardRoot.java"

    private WebResource getResource(String path, boolean validate,
        if (validate) {
            path = validate(path);
======= a1ad6ce:"java/org/apache/catalina/webresources/StandardRoot.java"

    /**
     * Ensures that this object is in a valid state to serve resources, checks
     * that the path is a String that starts with '/' and checks that the path
     * can be normalized without stepping outside of the root.
     *
     * @param path
     * @return  the normlized path
     */
    private String validate(String path) {
        if (!getState().isAvailable()) {
            throw new IllegalStateException(
                    sm.getString("standardRoot.checkStateNotStarted"));
        }
        return RequestUtil.normalize(path);
======= a1ad6ce:"java/org/apache/catalina/webresources/StandardRoot.java"

        path = validate(path);
======= a1ad6ce:"java/org/apache/catalina/webresources/StandardRoot.java"

    private WebResource[] listResources(String path, boolean validate) {
        if (validate) {
            path = validate(path);
======= a1ad6ce:"java/org/apache/catalina/webresources/StandardRoot.java"


======= cb62f86:"java/org/apache/catalina/connector/CoyoteAdapter.java"

======= cb62f86:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            AtomicBoolean error = new AtomicBoolean(false);
            res.action(ActionCode.IS_ERROR, error);
            if (!comet && !async || error.get()) {
======= cb62f86:"java/org/apache/coyote/ActionCode.java"

     * Has the processor been placed into the error state? Note that the
     * response may not have an appropriate error code set.
     */
    IS_ERROR,
    /**
======= cb62f86:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        } else if (actionCode == ActionCode.IS_ERROR) {
            ((AtomicBoolean) param).set(error);
======= cb62f86:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        } else if (actionCode == ActionCode.IS_ERROR) {
            ((AtomicBoolean) param).set(error);
======= cb62f86:"java/org/apache/coyote/spdy/SpdyProcessor.java"

        } else if (actionCode == ActionCode.IS_ERROR) {
            ((AtomicBoolean) param).set(error);
======= cb62f86:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

======= cb62f86:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

======= cb62f86:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

======= cb62f86:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

    private static CountDownLatch bug55772Latch1 = new CountDownLatch(1);
    private static CountDownLatch bug55772Latch2 = new CountDownLatch(1);
    private static CountDownLatch bug55772Latch3 = new CountDownLatch(1);
    private static boolean bug55772IsSecondRequest = false;
    private static boolean bug55772RequestStateLeaked = false;
    @Test
    public void testBug55772() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        tomcat.getConnector().setProperty("processorCache", "1");
        tomcat.getConnector().setProperty("maxThreads", "1");
        // Must have a real docBase - just use temp
        Context ctxt = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctxt, "async", new Bug55772Servlet());
        ctxt.addServletMapping("/*", "async");
        tomcat.start();
        String request1 = "GET /async HTTP/1.1\r\n" +
                "Host: localhost:" + getPort() + "\r\n" +
                "Connection: keep-alive\r\n" +
                "Cache-Control: max-age=0\r\n" +
                "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\n" +
                "User-Agent: Request1\r\n" +
                "Accept-Encoding: gzip,deflate,sdch\r\n" +
                "Accept-Language: en-US,en;q=0.8,fr;q=0.6,es;q=0.4\r\n" +
                "Cookie: something.that.should.not.leak=true\r\n" +
                "\r\n";
        String request2 = "GET /async HTTP/1.1\r\n" +
                "Host: localhost:" + getPort() + "\r\n" +
                "Connection: keep-alive\r\n" +
                "Cache-Control: max-age=0\r\n" +
                "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\n" +
                "User-Agent: Request2\r\n" +
                "Accept-Encoding: gzip,deflate,sdch\r\n" +
                "Accept-Language: en-US,en;q=0.8,fr;q=0.6,es;q=0.4\r\n" +
                "\r\n";
        try (final Socket connection = new Socket("localhost", getPort())) {
            connection.setSoLinger(true, 0);
            Writer writer = new OutputStreamWriter(connection.getOutputStream(),
                    B2CConverter.getCharset("US-ASCII"));
            writer.write(request1);
            writer.flush();
            bug55772Latch1.await();
            connection.close();
        }
        bug55772Latch2.await();
        bug55772IsSecondRequest = true;
        try (final Socket connection = new Socket("localhost", getPort())) {
            connection.setSoLinger(true, 0);
            Writer writer = new OutputStreamWriter(connection.getOutputStream(),
                    B2CConverter.getCharset("US-ASCII"));
            writer.write(request2);
            writer.flush();
            connection.getInputStream().read();
        }
        bug55772Latch3.await();
        if (bug55772RequestStateLeaked) {
            Assert.fail("State leaked between requests!");
        }
    }
    private static class Bug55772Servlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            if (bug55772IsSecondRequest) {
                Cookie[] cookies = req.getCookies();
                if (cookies != null && cookies.length > 0) {
                    for (Cookie cookie : req.getCookies()) {
                        if (cookie.getName().equalsIgnoreCase("something.that.should.not.leak")) {
                            bug55772RequestStateLeaked = true;
                        }
                    }
                }
                bug55772Latch3.countDown();
            } else {
                req.getCookies(); // We have to do this so Tomcat will actually parse the cookies from the request
            }
            req.setAttribute("org.apache.catalina.ASYNC_SUPPORTED", Boolean.TRUE);
            AsyncContext asyncContext = req.startAsync();
            asyncContext.setTimeout(5000);
            bug55772Latch1.countDown();
            PrintWriter writer = asyncContext.getResponse().getWriter();
            writer.print('\n');
            writer.flush();
            bug55772Latch2.countDown();
        }
    }

======= 0a4e847:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"


======= 014cf1c:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            try {
                sslContext = SSLContext.make(rootPool, value, SSL.SSL_MODE_SERVER);
            } catch (Exception e) {
                // If the sslEngine is disabled on the AprLifecycleListener
                // there will be an Exception here but there is no way to check
                // the AprLifecycleListener settings from here
                throw new Exception(
                        sm.getString("endpoint.apr.failSslContextMake"), e);
            }

======= 7ee1275:"java/org/apache/jasper/compiler/Validator.java"

======= 7ee1275:"java/org/apache/jasper/compiler/Validator.java"

                        if (n.getRoot().isXmlSyntax()) {
                            // The non-EL elements need to be XML escaped
                            XmlEscapeNonELVisitor v = new XmlEscapeNonELVisitor();
                            el.visit(v);
                            result = new Node.JspAttribute(tai, qName, uri,
                                    localName, v.getText(), false, el, dynamic);
                        } else {
                            result = new Node.JspAttribute(tai, qName, uri,
                                    localName, value, false, el, dynamic);
                        }
======= 7ee1275:"java/org/apache/jasper/compiler/Validator.java"

        private static class XmlEscapeNonELVisitor extends ELParser.TextBuilder {
            @Override
            public void visit(Text n) throws JasperException {
                output.append(xmlEscape(n.getText()));
            }
        }
======= 7ee1275:"java/org/apache/jasper/compiler/Validator.java"

    protected static String xmlEscape(String s) {
        if (s == null) {
            return null;
        }
        int len = s.length();
        /*
         * Look for any "bad" characters, Escape "bad" character was found
         */
        // ASCII " 34 & 38 ' 39 < 60 > 62
        for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            if (c >= '\"' && c <= '>' &&
                    (c == '<' || c == '>' || c == '\'' || c == '&' || c == '"')) {
                // need to escape them and then quote the whole string
                StringBuilder sb = new StringBuilder((int) (len * 1.2));
                sb.append(s, 0, i);
                int pos = i + 1;
                for (int j = i; j < len; j++) {
                    c = s.charAt(j);
                    if (c >= '\"' && c <= '>') {
                        if (c == '<') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&lt;");
                            pos = j + 1;
                        } else if (c == '>') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&gt;");
                            pos = j + 1;
                        } else if (c == '\'') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&#039;"); // &apos;
                            pos = j + 1;
                        } else if (c == '&') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&amp;");
                            pos = j + 1;
                        } else if (c == '"') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&#034;"); // &quot;
                            pos = j + 1;
                        }
                    }
                }
                if (pos < len) {
                    sb.append(s, pos, len);
                }
                return sb.toString();
            }
        }
        return s;
    }
======= 7ee1275:"java/org/apache/jasper/runtime/PageContextImpl.java"

======= 7ee1275:"java/org/apache/jasper/runtime/PageContextImpl.java"

======= 7ee1275:"test/org/apache/jasper/compiler/TestParser.java"

        Assert.assertTrue(result.contains("&quot;1foo1&quot;") ||
                result.contains("&#034;1foo1&#034;"));
        Assert.assertTrue(result.contains("&quot;2bar2&quot;") ||
                result.contains("&#034;2bar2&#034;"));
        Assert.assertTrue(result.contains("&quot;3a&amp;b3&quot;") ||
                result.contains("&#034;3a&amp;b3&#034;"));
        Assert.assertTrue(result.contains("&quot;4&4&quot;") ||
                result.contains("&#034;4&4&#034;"));
        Assert.assertTrue(result.contains("&quot;5&apos;5&quot;") ||
                result.contains("&#034;5&apos;5&#034;"));
======= 7ee1275:"test/org/apache/jasper/compiler/TestParser.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Performance tests for {@link Validator}.
 */
    private static String[] bug53867TestData = new String[] {
            "Hello World!",
            "<meta http-equiv=\"Content-Language\">",
            "This connection has limited network connectivity.",
            "Please use this web page & to access file server resources." };
    @Test
    public void testBug53867() {
        for (int i = 0; i < 10; i++) {
            doTestBug53867();
        }
    }
    private static void doTestBug53867() {
        int count = 100000;
        for (int j = 0; j < bug53867TestData.length; j++) {
            Assert.assertEquals(doTestBug53867OldVersion(bug53867TestData[j]),
                    Validator.xmlEscape(bug53867TestData[j]));
        }
        for (int i = 0; i < 100; i++) {
            for (int j = 0; j < bug53867TestData.length; j++) {
                doTestBug53867OldVersion(bug53867TestData[j]);
            }
        }
        for (int i = 0; i < 100; i++) {
            for (int j = 0; j < bug53867TestData.length; j++) {
                Validator.xmlEscape(bug53867TestData[j]);
            }
        }
        long start = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            for (int j = 0; j < bug53867TestData.length; j++) {
                doTestBug53867OldVersion(bug53867TestData[j]);
            }
        }
        System.out.println(
                "Old escape:" + (System.currentTimeMillis() - start));
        start = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            for (int j = 0; j < bug53867TestData.length; j++) {
                Validator.xmlEscape(bug53867TestData[j]);
            }
        }
        System.out.println(
                "New escape:" + (System.currentTimeMillis() - start));
    }
    private static String doTestBug53867OldVersion(String s) {
        if (s == null)
            return null;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '<') {
                sb.append("&lt;");
            } else if (c == '>') {
                sb.append("&gt;");
            } else if (c == '\'') {
                sb.append("&#039;"); // &apos;
            } else if (c == '&') {
                sb.append("&amp;");
            } else if (c == '"') {
                sb.append("&#034;"); // &quot;
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }
======= 7ee1275:"test/org/apache/jasper/runtime/TesterPageContextImpl.java"


======= 3f316f1:"java/org/apache/tomcat/websocket/server/Constants.java"

    // Executor configuration
    public static final String EXECUTOR_CORE_SIZE_INIT_PARAM =
            "org.apache.tomcat.websocket.executorCoreSize";
    public static final String EXECUTOR_MAX_SIZE_INIT_PARAM =
            "org.apache.tomcat.websocket.executorMaxSize";
    public static final String EXECUTOR_KEEPALIVETIME_SECONDS_INIT_PARAM =
            "org.apache.tomcat.websocket.executorKeepAliveTimeSeconds";
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsContextListener.java"

            ((WsServerContainer) obj).shutdownExecutor();
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java"

            // Triggered by the poller so this isn't the same thread that
            // triggered the write so no need for a dispatch
            wsRemoteEndpointServer.onWritePossible(false);
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

    private static final Queue<OnResultRunnable> onResultRunnables =
            new ConcurrentLinkedQueue<>();
    private final ExecutorService executorService;
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

        this.executorService = serverContainer.getExecutorService();
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

        // This is definitely the same thread that triggered the write so a
        // dispatch will be required.
        onWritePossible(true);
    public void onWritePossible(boolean useDispatch) {
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

                    clearHandler(null, useDispatch);
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

            clearHandler(ioe, useDispatch);
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

            // close() can be triggered by a wide range of scenarios. It is far
            // simpler just to always use a dispatch that it is to try and track
            // whether or not this method was called by the same thread that
            // triggered the write
            clearHandler(new EOFException(), true);
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

    /*
     * Currently this is only called from the background thread so we could just
     * call clearHandler() with useDispatch == false but the method parameter
     * was added in case other callers started to use this method to make sure
     * that those callers think through what the correct value of useDispatch is
     * for them.
     */
    protected void onTimeout(boolean useDispatch) {
            clearHandler(new SocketTimeoutException(), useDispatch);
    /**
     *
     * @param t             The throwable associated with any error that
     *                      occurred
     * @param useDispatch   Should {@link SendHandler#onResult(SendResult)} be
     *                      called from a new thread, keeping in mind the
     *                      requirements of
     *                      {@link javax.websocket.RemoteEndpoint.Async}
     */
    private void clearHandler(Throwable t, boolean useDispatch) {
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

            if (useDispatch) {
                OnResultRunnable r = onResultRunnables.poll();
                if (r == null) {
                    r = new OnResultRunnable(onResultRunnables);
                }
                r.init(sh, t);
                if (executorService == null || executorService.isShutdown()) {
                    // Can't use the executor so call the runnable directly.
                    // This may not be strictly specification compliant in all
                    // cases but during shutdown only close messages are going
                    // to be sent so there should not be the issue of nested
                    // calls leading to stack overflow as described in bug
                    // 55715. The issues with nested calls was the reason for
                    // the separate thread requirement in the specification.
                    r.run();
                } else {
                    executorService.execute(r);
                }
            } else {
                if (t == null) {
                    sh.onResult(new SendResult());
                } else {
                    sh.onResult(new SendResult(t));
                }
            }
        }
    }
    private static class OnResultRunnable implements Runnable {
        private final Queue<OnResultRunnable> queue;
        private volatile SendHandler sh;
        private volatile Throwable t;
        private OnResultRunnable(Queue<OnResultRunnable> queue) {
            this.queue = queue;
        }
        private void init(SendHandler sh, Throwable t) {
            this.sh = sh;
            this.t = t;
        }
        @Override
        public void run() {
            t = null;
            sh = null;
            // Return the Runnable to the queue when it has been finished with
            // Note if this method takes an age to finish there shouldn't be any
            // thread safety issues as the fields are cleared above.
            queue.add(this);
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

    private final ExecutorService executorService;
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

        // Executor config
        int executorCoreSize = 0;
        int executorMaxSize = 10;
        long executorKeepAliveTimeSeconds = 60;
        value = servletContext.getInitParameter(
                Constants.EXECUTOR_CORE_SIZE_INIT_PARAM);
        if (value != null) {
            executorCoreSize = Integer.parseInt(value);
        }
        value = servletContext.getInitParameter(
                Constants.EXECUTOR_MAX_SIZE_INIT_PARAM);
        if (value != null) {
            executorMaxSize = Integer.parseInt(value);
        }
        value = servletContext.getInitParameter(
                Constants.EXECUTOR_KEEPALIVETIME_SECONDS_INIT_PARAM);
        if (value != null) {
            executorKeepAliveTimeSeconds = Long.parseLong(value);
        }
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

        // Use a per web application executor for any threads the the WebSocket
        // server code needs to create. Group all of the threads under a single
        // ThreadGroup.
        StringBuffer threadGroupName = new StringBuffer("WebSocketServer-");
        threadGroupName.append(servletContext.getVirtualServerName());
        threadGroupName.append('-');
        if ("".equals(servletContext.getContextPath())) {
            threadGroupName.append("ROOT");
        } else {
            threadGroupName.append(servletContext.getContextPath());
        }
        ThreadGroup threadGroup = new ThreadGroup(threadGroupName.toString());
        WsThreadFactory wsThreadFactory = new WsThreadFactory(threadGroup);
        executorService = new ThreadPoolExecutor(executorCoreSize,
                executorMaxSize, executorKeepAliveTimeSeconds, TimeUnit.SECONDS,
                new LinkedBlockingQueue<Runnable>(), wsThreadFactory);
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

    ExecutorService getExecutorService() {
        return executorService;
    }
    void shutdownExecutor() {
        executorService.shutdown();
        try {
            executorService.awaitTermination(10, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            // Ignore the interruption and carry on
        }
    }
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

    private static class WsThreadFactory implements ThreadFactory {
        private final ThreadGroup tg;
        private final AtomicLong count = new AtomicLong(0);
        private WsThreadFactory(ThreadGroup tg) {
            this.tg = tg;
        }
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(tg, r);
            t.setName(tg.getName() + "-" + count.incrementAndGet());
            return t;
        }
    }
======= 3f316f1:"java/org/apache/tomcat/websocket/server/WsWriteTimeout.java"

                    // Background thread, not the thread that triggered the
                    // write so no need to use a dispatch
                    endpoint.onTimeout(false);
   asynchronous writes are performed on a different thread to the thread that
   initiated the write. Since the container thread pool is not exposed via the
   Servlet API, the WebSocket implementation has to provide its own thread pool.
   This thread pool is controlled by the following servlet context
   initialization parameters:<a>
   <ul>
     <li><code>org.apache.tomcat.websocket.executorCoreSize</code>: The core
         size of the executor thread pool. If not set, the default of 0 (zero)
         is used.</li>
     <li><code>org.apache.tomcat.websocket.executorMaxSize</code>: The maximum
         permitted size of the executor thread pool. If not set, the default of
         10 is used.</li>
     <li><code>org.apache.tomcat.websocket.executorKeepAliveTimeSeconds</code>:
         The maximum time an idle thread will remain in the executor thread pool
         until it is terminated. If not specified, the default of 60 seconds is
         used.</li>
   </ul>

======= ad50e54:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

======= ad50e54:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

    private InputStream getResourceAsStream(String uriAsString)
        if (uriAsString.startsWith("file:")) {
            URI uri;
            try {
                uri = new URI(uriAsString);
            } catch (URISyntaxException e) {
                FileNotFoundException fnfe = new FileNotFoundException(e.getMessage());
                fnfe.initCause(e);
                throw fnfe;
            }
            return new FileInputStream(new File(uri));
                String real = ctxt.getRealPath(uriAsString);
                    return ctxt.getResourceAsStream(uriAsString);
                return ctxt.getResourceAsStream(uriAsString);

======= d244284:"java/org/apache/catalina/loader/WebappClassLoader.java"

        try {
            while (tg.getParent() != null) {
                tg = tg.getParent();
            }
        } catch (SecurityException se) {
            String msg = sm.getString(
                    "webappClassLoader.getThreadGroupError", tg.getName());
            if (log.isDebugEnabled()) {
                log.debug(msg, se);
            } else {
                log.warn(msg);
            }

======= b82c0c6:"java/javax/el/ArrayELResolver.java"

            if (value != null && !Util.isAssignableFrom(value.getClass(),
                    base.getClass().getComponentType())) {
======= b82c0c6:"java/javax/el/Util.java"

    static boolean isAssignableFrom(Class<?> src, Class<?> target) {
======= b82c0c6:"test/javax/el/TestArrayELResolver.java"

     * Tests setting arrays of primitives.
     * https://issues.apache.org/bugzilla/show_bug.cgi?id=55691
     */
    @Test
    public void testSetValue08() {
        ArrayELResolver resolver = new ArrayELResolver();
        ELContext context = new StandardELContext(
                ELManager.getExpressionFactory());
        int[] base = new int[] { 1, 2, 3 };
        resolver.setValue(context, base, new Integer(1), Integer.valueOf(4));
        Assert.assertEquals(Integer.valueOf(base[1]), Integer.valueOf(4));
    }
    /**

======= 514cefb:"java/org/apache/tomcat/websocket/Util.java"

======= 514cefb:"java/org/apache/tomcat/websocket/Util.java"

            MessageHandler listener, EndpointConfig endpointConfig,
            Session session) {
======= 514cefb:"java/org/apache/tomcat/websocket/Util.java"

                            getOnMessageMethod(listener), session,
======= 514cefb:"java/org/apache/tomcat/websocket/Util.java"

                            getOnMessageMethod(listener), session,
======= 514cefb:"java/org/apache/tomcat/websocket/Util.java"

                            getOnMessageMethod(listener), session,
======= 514cefb:"java/org/apache/tomcat/websocket/Util.java"

                        new PojoMessageHandlerWholeBinary(listener, m, session,
======= 514cefb:"java/org/apache/tomcat/websocket/Util.java"

                        new PojoMessageHandlerWholeText(listener, m, session,
======= 514cefb:"java/org/apache/tomcat/websocket/WsSession.java"

                Util.getMessageHandlers(listener, endpointConfig, this);

======= 4e4a24a:"java/org/apache/tomcat/websocket/Util.java"

    public static Class<?> getDecoderType(Class<? extends Decoder> decoder) {
        return (Class<?>) Util.getGenericType(Decoder.class, decoder);
======= 4e4a24a:"java/org/apache/tomcat/websocket/Util.java"

        } else if (argType instanceof ParameterizedType) {
            return ((ParameterizedType) argType).getRawType();
======= 4e4a24a:"test/org/apache/tomcat/websocket/TestUtil.java"

======= 4e4a24a:"test/org/apache/tomcat/websocket/TestUtil.java"

    @Test
    public void testGetEncoderTypeSimpleWithGenericType() {
        Assert.assertEquals(List.class,
                Util.getEncoderType(SimpleEncoderWithGenericType.class));
    }
======= 4e4a24a:"test/org/apache/tomcat/websocket/TestUtil.java"

    private static class SimpleEncoderWithGenericType
            implements Encoder.Text<List<String>> {
        @Override
        public void init(EndpointConfig endpointConfig) {
            // NO-OP
        }
        @Override
        public void destroy() {
            // NO-OP
        }
        @Override
        public String encode(List<String> object) throws EncodeException {
            return null;
        }
    }
======= 4e4a24a:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

======= 4e4a24a:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

    private static final String PATH_GENERICS_EP = "/echoGenericsEP";
======= 4e4a24a:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

    @Test
    public void testGenericsCoders() throws Exception {
        // Set up utility classes
        GenericsServer server = new GenericsServer();
        SingletonConfigurator.setInstance(server);
        ServerConfigListener.setPojoClazz(GenericsServer.class);
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        ctx.addApplicationListener(new ApplicationListener(
                ServerConfigListener.class.getName(), false));
        Tomcat.addServlet(ctx, "default", new DefaultServlet());
        ctx.addServletMapping("/", "default");
        WebSocketContainer wsContainer =
                ContainerProvider.getWebSocketContainer();
        tomcat.start();
        GenericsClient client = new GenericsClient();
        URI uri = new URI("ws://localhost:" + getPort() + PATH_GENERICS_EP);
        Session session = wsContainer.connectToServer(client, uri);
        ArrayList<String> list = new ArrayList<>(2);
        list.add("str1");
        list.add("str2");
        session.getBasicRemote().sendObject(list);
        // Should not take very long
        int i = 0;
        while (i < 20) {
            if (server.received.size() > 0 && client.received.size() > 0) {
                break;
            }
            Thread.sleep(100);
        }
        // Check messages were received
        Assert.assertEquals(1, server.received.size());
        Assert.assertEquals(server.received.peek().toString(), "[str1, str2]");
        Assert.assertEquals(1, client.received.size());
        Assert.assertEquals(client.received.peek().toString(), "[str1, str2]");
        session.close();
    }
======= 4e4a24a:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

    @ClientEndpoint(decoders={ListStringDecoder.class},
            encoders={ListStringEncoder.class})
    public static class GenericsClient {
        private Queue<Object> received = new ConcurrentLinkedQueue<>();
        @OnMessage
        public void rx(List<String> in) {
            received.add(in);
        }
    }
======= 4e4a24a:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

    @ServerEndpoint(value=PATH_GENERICS_EP,
            decoders={ListStringDecoder.class},
            encoders={ListStringEncoder.class},
            configurator=SingletonConfigurator.class)
    public static class GenericsServer {
        private Queue<Object> received = new ConcurrentLinkedQueue<>();
        @OnMessage
        public List<String> rx(List<String> in) {
            received.add(in);
            // Echo the message back
            return in;
        }
    }
======= 4e4a24a:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

    public static class ListStringEncoder implements Encoder.Text<List<String>> {
        @Override
        public void init(EndpointConfig endpointConfig) {
            Server.addLifeCycleEvent(getClass().getName() + ":init");
        }
        @Override
        public void destroy() {
            Server.addLifeCycleEvent(getClass().getName() + ":destroy");
        }
        @Override
        public String encode(List<String> str) throws EncodeException {
            StringBuffer sbuf = new StringBuffer();
            sbuf.append("[");
            for (String s: str){
                sbuf.append(s).append(",");
            }
            sbuf.deleteCharAt(sbuf.lastIndexOf(",")).append("]");
            return sbuf.toString();
        }
    }
    public static class ListStringDecoder implements Decoder.Text<List<String>> {
        @Override
        public void init(EndpointConfig endpointConfig) {
             Server.addLifeCycleEvent(getClass().getName() + ":init");
        }
        @Override
        public void destroy() {
            Server.addLifeCycleEvent(getClass().getName() + ":destroy");
        }
        @Override
        public List<String> decode(String str) throws DecodeException {
            List<String> lst = new ArrayList<>(1);
            str = str.substring(1,str.length()-1);
            String[] strings = str.split(",");
            for (String t : strings){
                lst.add(t);
            }
            return lst;
        }
        @Override
        public boolean willDecode(String str) {
            return str.startsWith("[") && str.endsWith("]");
        }
    }

======= 86ec1f4:"java/org/apache/catalina/startup/Catalina.java"

======= 86ec1f4:"java/org/apache/catalina/startup/Catalina.java"

        digester.setUseContextClassLoader(true);
======= 86ec1f4:"java/org/apache/catalina/startup/Catalina.java"

        digester.setUseContextClassLoader(true);
======= 86ec1f4:"java/org/apache/catalina/startup/Catalina.java"


        <init-param>
            <param-name>gzip</param-name>
            <param-value>true</param-value>
        </init-param>
======= f0101d0:"java/org/apache/catalina/servlets/DefaultServlet.java"

======= f0101d0:"java/org/apache/catalina/servlets/DefaultServlet.java"

     * Should be serve gzip versions of files. By default, it's set to true.
     */
    protected boolean gzip = true;
    /**
======= f0101d0:"java/org/apache/catalina/servlets/DefaultServlet.java"

        if (getServletConfig().getInitParameter("gzip") != null)
            gzip = Boolean.parseBoolean(getServletConfig().getInitParameter("gzip"));
======= f0101d0:"java/org/apache/catalina/servlets/DefaultServlet.java"

        // Serve a gzipped version of the file if present
        if (gzip
                && checkIfGzip(request)
                && resource.isFile()
                && !path.endsWith(".gz")) {
            WebResource gzipResource = resources.getResource(path + ".gz");
            if (gzipResource.exists() && gzipResource.isFile()) {
                gzipResource.setMimeType(contentType);
                response.addHeader("Content-Encoding", "gzip");
                resource = gzipResource;
            }
        }
======= f0101d0:"java/org/apache/catalina/servlets/DefaultServlet.java"

    /**
     * Check if the user agent supports gzip encoding.
     *
     * @param request   The servlet request we are processing
     * @return boolean true if the user agent supports gzip encoding,
     * and false if the user agent does not support gzip encoding
     */
    protected boolean checkIfGzip(HttpServletRequest request) {
        Enumeration<String> headers = request.getHeaders("Accept-Encoding");
        while (headers.hasMoreElements()) {
            String header = headers.nextElement();
            if (header.indexOf("gzip") != -1) {
                return true;
            }
        }
        return false;
    }
======= f0101d0:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

     * Verify serving of gzipped resources from context root.
     */
    @Test
    public void testGzippedFile() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir =
            new File("test/webapp");
        File gzipIndex = new File(appDir, "index.html.gz");
        long gzipSize = gzipIndex.length();
        File index = new File(appDir, "index.html");
        long indexSize = index.length();
        // app dir is relative to server home
        tomcat.addWebapp(null, "", appDir.getAbsolutePath());
        tomcat.start();
        TestGzipClient gzipClient = new TestGzipClient(getPort());
        gzipClient.reset();
        gzipClient.setRequest(new String[] {
                "GET /index.html HTTP/1.1" + CRLF +
                "Host: localhost" + CRLF +
                "Connection: Close" + CRLF +
                "Accept-Encoding: gzip" + CRLF + CRLF });
        gzipClient.connect();
        gzipClient.processRequest();
        assertTrue(gzipClient.isResponse200());
        List<String> responseHeaders = gzipClient.getResponseHeaders();
        assertTrue(responseHeaders.contains("Content-Length: " + gzipSize));
        gzipClient.reset();
        gzipClient.setRequest(new String[] {
                "GET /index.html HTTP/1.1" + CRLF +
                "Host: localhost" + CRLF +
                "Connection: Close" + CRLF+ CRLF });
        gzipClient.connect();
        gzipClient.processRequest();
        assertTrue(gzipClient.isResponse200());
        responseHeaders = gzipClient.getResponseHeaders();
        assertTrue(responseHeaders.contains("Content-Type: text/html"));
        assertFalse(responseHeaders.contains("Content-Encoding: gzip"));
        assertTrue(responseHeaders.contains("Content-Length: " + indexSize));
    }
    /**
======= f0101d0:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

    private static class TestGzipClient extends SimpleHttpClient {
        public TestGzipClient(int port) {
            setPort(port);
        }
        @Override
        public boolean isResponseBodyOK() {
            return true;
        }
    }
      <add>
        <bug>54095</bug>: Add support to the Default Servlet for serving
        gzipped versions of static resources directly from disk as an
        alternative to Tomcat compressing them on each request. Patch by
        Philippe Marschall. (markt)
      </add>
  <property name="gzip">
        If a gzipped version of a file exists (a file with <code>.gz</code>
        appended to the file name located alongside the original file), Tomcat
        will serve the gzipped file if the user agent supports gzip and this
        option is enabled. [true]
  </property>

======= 06d8338:"java/org/apache/jasper/JspC.java"

    protected void initWebXml() throws JasperException {
======= 06d8338:"java/org/apache/jasper/JspC.java"

            throw new JasperException(ioe);
      <fix>
        <bug>55251</bug>: Do not allow JspC task to fail silently if the web.xml
        or web.xml fragment can not be generated. (markt)
      </fix>

======= af49b44:"java/org/apache/jasper/compiler/Node.java"

======= af49b44:"java/org/apache/jasper/compiler/Node.java"

            return !expression && (el == null) && !namedAttribute;
======= af49b44:"java/org/apache/jasper/compiler/Node.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testJspAttributeIsLiteral() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir =
            new File("test/webapp");
        // app dir is relative to server home
        tomcat.addWebapp(null, "", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = getUrl("http://localhost:" + getPort() +
                "/bug5nnnn/bug55642a.jsp");
        String result = res.toString();
        System.out.println(result);
        Assert.assertTrue(
                result.indexOf("/bug5nnnn/bug55642b.jsp?foo=bar&a=1&b=2") > 0);
    }
======= af49b44:"java/org/apache/jasper/compiler/Node.java"

  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  --%>
  <jsp:param name="a" value="1"/>
  <jsp:param name="b" value="2"/>
======= af49b44:"java/org/apache/jasper/compiler/Node.java"

  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  --%>

======= bd56eea:"java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java"

    private static volatile TomcatURLStreamHandlerFactory instance = null;
     * Obtain a reference to the singleton instance. It is recommended that
     * callers check the value of {@link #isRegistered()} before using the
     * returned instance.
        getInstanceInternal(true);
    private static TomcatURLStreamHandlerFactory getInstanceInternal(boolean register) {
        // Double checked locking. OK because instance is volatile.
        if (instance == null) {
            synchronized (TomcatURLStreamHandlerFactory.class) {
                if (instance == null) {
                    instance = new TomcatURLStreamHandlerFactory(register);
                }
            }
        }
        return instance;
    }
    private final boolean registered;
     *
     * @returns <code>true</code> if the factory is already registered with the
     *          JVM or was successfully registered as a result of this call.
     *          <code>false</code> if the factory was disabled prior to this
     *          call.
    public static boolean register() {
        return getInstanceInternal(true).isRegistered();
     * Prevent this this factory from registering with the JVM. May be called
     * more than once.
     *
     * @returns <code>true</code> if the factory is already disabled or was
     *          successfully disabled as a result of this call.
     *          <code>false</code> if the factory was already registered prior
     *          to this call.
    public static boolean disable() {
        return !getInstanceInternal(false).isRegistered();
======= bd56eea:"java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java"

    private TomcatURLStreamHandlerFactory(boolean register) {
        this.registered = register;
        if (register) {
            URL.setURLStreamHandlerFactory(this);
        }
    }
    public boolean isRegistered() {
        return registered;
    }
    /**
     * Since the JVM only allows a single call to
     * {@link URL#setURLStreamHandlerFactory(URLStreamHandlerFactory)} and
     * Tomcat needs to register a handler, provide a mechanism to allow
     * applications to register their own handlers.
     */
    public void addUserFactory(URLStreamHandlerFactory factory) {
        userFactories.add(factory);

======= 95faaec:"java/org/apache/catalina/manager/StatusManagerServlet.java"

        // Unregister with MBean server
        String onStr = "JMImplementation:type=MBeanServerDelegate";
        ObjectName objectName;
        try {
            objectName = new ObjectName(onStr);
            mBeanServer.removeNotificationListener(objectName, this, null, null);
        } catch (Exception e) {
            e.printStackTrace();
        }

======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

 * <strong>IMPLEMENTATION NOTE</strong> - As of 8.0, this class
 * loader implements {@link InstrumentableClassLoader}, permitting web
 * application classes to instrument other classes in the same web
 * application. It does not permit instrumentation of system or container
 * classes or classes in other web apps.
        implements Lifecycle, InstrumentableClassLoader {
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

    private static final String CLASS_FILE_SUFFIX = ".class";
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

    /**
     * Holds the class file transformers decorating this class loader. The
     * CopyOnWriteArrayList is thread safe. It is expensive on writes, but
     * those should be rare. It is very fast on reads, since synchronization
     * is not actually used. Importantly, the ClassLoader will never block
     * iterating over the transformers while loading a class.
     */
    private final List<ClassFileTransformer> transformers = new CopyOnWriteArrayList<>();
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

    /**
     * Adds the specified class file transformer to this class loader. The
     * transformer will then be able to modify the bytecode of any classes
     * loaded by this class loader after the invocation of this method.
     *
     * @param transformer The transformer to add to the class loader
     */
    @Override
    public void addTransformer(ClassFileTransformer transformer) {
        if (transformer == null) {
            throw new IllegalArgumentException(sm.getString(
                    "webappClassLoader.addTransformer.illegalArgument", getContextName()));
        }
        if (this.transformers.contains(transformer)) {
            // if the same instance of this transformer was already added, bail out
            log.warn(sm.getString("webappClassLoader.addTransformer.duplicate",
                    transformer, getContextName()));
            return;
        }
        this.transformers.add(transformer);
        log.info(sm.getString("webappClassLoader.addTransformer", transformer, getContextName()));
    }
    /**
     * Removes the specified class file transformer from this class loader.
     * It will no longer be able to modify the byte code of any classes
     * loaded by the class loader after the invocation of this method.
     * However, any classes already modified by this transformer will
     * remain transformed.
     *
     * @param transformer The transformer to remove
     */
    @Override
    public void removeTransformer(ClassFileTransformer transformer) {
        if (transformer == null) {
            return;
        }
        if (this.transformers.remove(transformer)) {
            log.info(sm.getString("webappClassLoader.removeTransformer",
                    transformer, getContextName()));
            return;
        }
    }
    /**
     * Returns a copy of this class loader without any class file
     * transformers. This is a tool often used by Java Persistence API
     * providers to inspect entity classes in the absence of any
     * instrumentation, something that can't be guaranteed within the
     * context of a {@link ClassFileTransformer}'s
     * {@link ClassFileTransformer#transform(ClassLoader, String, Class,
     * ProtectionDomain, byte[]) transform} method.
     * <p>
     * The returned class loader's resource cache will have been cleared
     * so that classes already instrumented will not be retained or
     * returned.
     *
     * @return the transformer-free copy of this class loader.
     */
    @Override
    public WebappClassLoader copyWithoutTransformers() {
        WebappClassLoader loader = new WebappClassLoader(this.parent);
        loader.antiJARLocking = this.antiJARLocking;
        loader.resources = this.resources;
        loader.delegate = this.delegate;
        loader.lastJarAccessed = this.lastJarAccessed;
        loader.repositoryPath = this.repositoryPath;
        loader.repository = this.repository;
        loader.jarPath = this.jarPath;
        loader.loaderDir = this.loaderDir;
        loader.canonicalLoaderDir = this.canonicalLoaderDir;
        loader.started = this.started;
        loader.needConvert = this.needConvert;
        loader.clearReferencesStatic = this.clearReferencesStatic;
        loader.clearReferencesStopThreads = this.clearReferencesStopThreads;
        loader.clearReferencesStopTimerThreads = this.clearReferencesStopTimerThreads;
        loader.clearReferencesLogFactoryRelease = this.clearReferencesLogFactoryRelease;
        loader.clearReferencesHttpClientKeepAliveThread = this.clearReferencesHttpClientKeepAliveThread;
        loader.repositoryURLs = this.repositoryURLs.clone();
        loader.jarFiles = this.jarFiles.clone();
        loader.jarRealFiles = this.jarRealFiles.clone();
        loader.jarNames = this.jarNames.clone();
        loader.lastModifiedDates = this.lastModifiedDates.clone();
        loader.paths = this.paths.clone();
        loader.notFoundResources.putAll(this.notFoundResources);
        loader.permissionList.addAll(this.permissionList);
        loader.loaderPC.putAll(this.loaderPC);
        return loader;
    }
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (this.transformers.size() > 0) {
            sb.append("----------> Class file transformers:\r\n");
            for (ClassFileTransformer transformer : this.transformers) {
                sb.append(transformer).append("\r\n");
            }
        }
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

                            && (!(name.endsWith(CLASS_FILE_SUFFIX)))) {
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

        String classPath = tempPath + CLASS_FILE_SUFFIX;
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

    protected ResourceEntry findResourceInternal(final String name, final String path) {
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

        boolean isClassResource = path.endsWith(CLASS_FILE_SUFFIX);
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

                        if (antiJARLocking && !(path.endsWith(CLASS_FILE_SUFFIX))) {
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                            (CLASS_FILE_SUFFIX))) {
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (isClassResource && entry.binaryContent != null &&
                this.transformers.size() > 0) {
            // If the resource is a class just being loaded, decorate it
            // with any attached transformers
            String className = name.endsWith(CLASS_FILE_SUFFIX) ?
                    name.substring(0, name.length() - CLASS_FILE_SUFFIX.length()) : name;
            String internalName = className.replace(".", "/");
            for (ClassFileTransformer transformer : this.transformers) {
                try {
                    byte[] transformed = transformer.transform(
                            this, internalName, null, null, entry.binaryContent
                    );
                    if (transformed != null) {
                        entry.binaryContent = transformed;
                    }
                } catch (IllegalClassFormatException e) {
                    log.error(sm.getString("webappClassLoader.transformError", name), e);
                    return null;
                }
            }
        }
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

                String name = triggers[i].replace('.', '/') + CLASS_FILE_SUFFIX;
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Specifies a class loader capable of being decorated with
 * {@link ClassFileTransformer}s. These transformers can instrument
 * (or weave) the byte code of classes loaded through this class loader
 * to alter their behavior. Currently only
 * {@link org.apache.catalina.loader.WebappClassLoader} implements this
 * interface. This allows web application frameworks or JPA providers
 * bundled with a web application to instrument web application classes
 * as necessary.
 * <p>
 * You should always program against the methods of this interface
 * (whether using reflection or otherwise). The methods in
 * {@code WebappClassLoader} are protected by the default security
 * manager if one is in use.
 *
 * @since 8.0, 7.0.44
 */
    /**
     * Adds the specified class file transformer to this class loader. The
     * transformer will then be able to instrument the bytecode of any
     * classes loaded by this class loader after the invocation of this
     * method.
     *
     * @param classFileTransformer The transformer to add to the class loader
     * @throws IllegalArgumentException if the {@literal transformer} is null.
     */
    void addTransformer(ClassFileTransformer transformer);
    /**
     * Removes the specified class file transformer from this class loader.
     * It will no longer be able to instrument the byte code of any classes
     * loaded by the class loader after the invocation of this method.
     * However, any classes already instrumented by this transformer before
     * this method call will remain in their instramented state.
     *
     * @param classFileTransformer The transformer to remove
     */
    void removeTransformer(ClassFileTransformer transformer);
    /**
     * Returns a copy of this class loader without any class file
     * transformers. This is a tool often used by Java Persistence API
     * providers to inspect entity classes in the absence of any
     * instrumentation, something that can't be guaranteed within the
     * context of a {@link ClassFileTransformer}'s
     * {@link ClassFileTransformer#transform(ClassLoader, String, Class,
     * java.security.ProtectionDomain, byte[]) transform} method.
     * <p>
     * The returned class loader's resource cache will have been cleared
     * so that classes already instrumented will not be retained or
     * returned.
     *
     * @return the transformer-free copy of this class loader.
     */
    ClassLoader copyWithoutTransformers();
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private static final String PACKAGE_PREFIX = "org/apache/catalina/loader";
    private static String WEBAPP_DOC_BASE;
    @BeforeClass
    public static void setUpClass() throws Exception {
        WEBAPP_DOC_BASE = System.getProperty("java.io.tmpdir") + "/TestWebappClassLoaderWeaving";
        File classes = new File(WEBAPP_DOC_BASE + "/WEB-INF/classes/" + PACKAGE_PREFIX);
        classes.mkdirs();
        copyResource(PACKAGE_PREFIX + "/TesterNeverWeavedClass.class",
                new File(classes, "TesterNeverWeavedClass.class"));
        copyResource(PACKAGE_PREFIX + "/TesterUnweavedClass.class",
                new File(classes, "TesterUnweavedClass.class"));
    }
    @AfterClass
    public static void tearDownClass() throws Exception {
        FileUtils.deleteDirectory(new File(WEBAPP_DOC_BASE));
    }
    private Tomcat tomcat;
    private Context context;
    private WebappClassLoader loader;
    @Before
    @Override
    public void setUp() throws Exception {
        super.setUp();
        this.tomcat = getTomcatInstance();
        this.context = this.tomcat.addContext("/weaving", WEBAPP_DOC_BASE);
        this.tomcat.start();
        ClassLoader loader = this.context.getLoader().getClassLoader();
        assertNotNull("The class loader should not be null.", loader);
        assertSame("The class loader is not correct.", WebappClassLoader.class, loader.getClass());
        this.loader = (WebappClassLoader) loader;
    }
    @After
    @Override
    public void tearDown() throws Exception {
        try {
            this.loader = null;
            this.context.stop();
            this.tomcat.getHost().removeChild(this.context);
            this.context = null;
        } finally {
            super.tearDown();
        }
    }
    @Test
    public void testNoWeaving() throws Exception {
        String result = invokeDoMethodOnClass(this.loader, "TesterNeverWeavedClass");
        assertEquals("The first result is not correct.", "This will never be weaved.", result);
        result = invokeDoMethodOnClass(this.loader, "TesterUnweavedClass");
        assertEquals("The second result is not correct.", "Hello, Unweaved World!", result);
    }
    @Test
    public void testAddingNullTransformerThrowsException() throws Exception {
        try {
            this.loader.addTransformer(null);
            fail("Expected exception IllegalArgumentException, got no exception.");
        } catch (IllegalArgumentException ignore) {
            // good
        }
        // class loading should still work, no weaving
        String result = invokeDoMethodOnClass(this.loader, "TesterNeverWeavedClass");
        assertEquals("The first result is not correct.", "This will never be weaved.", result);
        result = invokeDoMethodOnClass(this.loader, "TesterUnweavedClass");
        assertEquals("The second result is not correct.", "Hello, Unweaved World!", result);
    }
    @Test
    public void testAddedTransformerInstrumentsClass1() throws Exception {
        this.loader.addTransformer(new ReplacementTransformer(WEAVED_REPLACEMENT_1));
        String result = invokeDoMethodOnClass(this.loader, "TesterNeverWeavedClass");
        assertEquals("The first result is not correct.", "This will never be weaved.", result);
        result = invokeDoMethodOnClass(this.loader, "TesterUnweavedClass");
        assertEquals("The second result is not correct.", "Hello, Weaver #1!", result);
    }
    @Test
    public void testAddedTransformerInstrumentsClass2() throws Exception {
        this.loader.addTransformer(new ReplacementTransformer(WEAVED_REPLACEMENT_2));
        String result = invokeDoMethodOnClass(this.loader, "TesterNeverWeavedClass");
        assertEquals("The first result is not correct.", "This will never be weaved.", result);
        result = invokeDoMethodOnClass(this.loader, "TesterUnweavedClass");
        assertEquals("The second result is not correct.", "Hello, Weaver #2!", result);
    }
    @Test
    public void testTransformersExecuteInOrderAdded1() throws Exception {
        this.loader.addTransformer(new ReplacementTransformer(WEAVED_REPLACEMENT_1));
        this.loader.addTransformer(new ReplacementTransformer(WEAVED_REPLACEMENT_2));
        String result = invokeDoMethodOnClass(this.loader, "TesterNeverWeavedClass");
        assertEquals("The first result is not correct.", "This will never be weaved.", result);
        result = invokeDoMethodOnClass(this.loader, "TesterUnweavedClass");
        assertEquals("The second result is not correct.", "Hello, Weaver #2!", result);
    }
    @Test
    public void testTransformersExecuteInOrderAdded2() throws Exception {
        this.loader.addTransformer(new ReplacementTransformer(WEAVED_REPLACEMENT_2));
        this.loader.addTransformer(new ReplacementTransformer(WEAVED_REPLACEMENT_1));
        String result = invokeDoMethodOnClass(this.loader, "TesterNeverWeavedClass");
        assertEquals("The first result is not correct.", "This will never be weaved.", result);
        result = invokeDoMethodOnClass(this.loader, "TesterUnweavedClass");
        assertEquals("The second result is not correct.", "Hello, Weaver #1!", result);
    }
    @Test
    public void testRemovedTransformerNoLongerInstruments1() throws Exception {
        ReplacementTransformer removed = new ReplacementTransformer(WEAVED_REPLACEMENT_1);
        this.loader.addTransformer(removed);
        this.loader.removeTransformer(removed);
        String result = invokeDoMethodOnClass(this.loader, "TesterNeverWeavedClass");
        assertEquals("The first result is not correct.", "This will never be weaved.", result);
        result = invokeDoMethodOnClass(this.loader, "TesterUnweavedClass");
        assertEquals("The second result is not correct.", "Hello, Unweaved World!", result);
    }
    @Test
    public void testRemovedTransformerNoLongerInstruments2() throws Exception {
        this.loader.addTransformer(new ReplacementTransformer(WEAVED_REPLACEMENT_1));
        ReplacementTransformer removed = new ReplacementTransformer(WEAVED_REPLACEMENT_2);
        this.loader.addTransformer(removed);
        this.loader.removeTransformer(removed);
        String result = invokeDoMethodOnClass(this.loader, "TesterNeverWeavedClass");
        assertEquals("The first result is not correct.", "This will never be weaved.", result);
        result = invokeDoMethodOnClass(this.loader, "TesterUnweavedClass");
        assertEquals("The second result is not correct.", "Hello, Weaver #1!", result);
    }
    @Test
    public void testRemovedTransformerNoLongerInstruments3() throws Exception {
        this.loader.addTransformer(new ReplacementTransformer(WEAVED_REPLACEMENT_2));
        ReplacementTransformer removed = new ReplacementTransformer(WEAVED_REPLACEMENT_1);
        this.loader.addTransformer(removed);
        this.loader.removeTransformer(removed);
        String result = invokeDoMethodOnClass(this.loader, "TesterNeverWeavedClass");
        assertEquals("The first result is not correct.", "This will never be weaved.", result);
        result = invokeDoMethodOnClass(this.loader, "TesterUnweavedClass");
        assertEquals("The second result is not correct.", "Hello, Weaver #2!", result);
    }
    @Test
    public void testCopiedClassLoaderExcludesResourcesAndTransformers() throws Exception {
        this.loader.addTransformer(new ReplacementTransformer(WEAVED_REPLACEMENT_1));
        this.loader.addTransformer(new ReplacementTransformer(WEAVED_REPLACEMENT_2));
        String result = invokeDoMethodOnClass(this.loader, "TesterNeverWeavedClass");
        assertEquals("The first result is not correct.", "This will never be weaved.", result);
        result = invokeDoMethodOnClass(this.loader, "TesterUnweavedClass");
        assertEquals("The second result is not correct.", "Hello, Weaver #2!", result);
        WebappClassLoader copiedLoader = this.loader.copyWithoutTransformers();
        result = invokeDoMethodOnClass(copiedLoader, "TesterNeverWeavedClass");
        assertEquals("The third result is not correct.", "This will never be weaved.", result);
        result = invokeDoMethodOnClass(copiedLoader, "TesterUnweavedClass");
        assertEquals("The fourth result is not correct.", "Hello, Unweaved World!", result);
        assertEquals("getAntiJARLocking did not match.",
                Boolean.valueOf(this.loader.getAntiJARLocking()),
                Boolean.valueOf(copiedLoader.getAntiJARLocking()));
        assertEquals("getClearReferencesHttpClientKeepAliveThread did not match.",
                Boolean.valueOf(this.loader.getClearReferencesHttpClientKeepAliveThread()),
                Boolean.valueOf(copiedLoader.getClearReferencesHttpClientKeepAliveThread()));
        assertEquals("getClearReferencesLogFactoryRelease did not match.",
                Boolean.valueOf(this.loader.getClearReferencesLogFactoryRelease()),
                Boolean.valueOf(copiedLoader.getClearReferencesLogFactoryRelease()));
        assertEquals("getClearReferencesStatic did not match.",
                Boolean.valueOf(this.loader.getClearReferencesStatic()),
                Boolean.valueOf(copiedLoader.getClearReferencesStatic()));
        assertEquals("getClearReferencesStopThreads did not match.",
                Boolean.valueOf(this.loader.getClearReferencesStopThreads()),
                Boolean.valueOf(copiedLoader.getClearReferencesStopThreads()));
        assertEquals("getClearReferencesStopTimerThreads did not match.",
                Boolean.valueOf(this.loader.getClearReferencesStopTimerThreads()),
                Boolean.valueOf(copiedLoader.getClearReferencesStopTimerThreads()));
        assertEquals("getContextName did not match.", this.loader.getContextName(),
                copiedLoader.getContextName());
        assertEquals("getDelegate did not match.",
                Boolean.valueOf(this.loader.getDelegate()),
                Boolean.valueOf(copiedLoader.getDelegate()));
        assertEquals("getJarPath did not match.", this.loader.getJarPath(),
                copiedLoader.getJarPath());
        assertEquals("getURLs did not match.", this.loader.getURLs().length,
                copiedLoader.getURLs().length);
        assertSame("getParent did not match.", this.loader.getParent(), copiedLoader.getParent());
    }
    private static void copyResource(String name, File file) throws Exception {
        InputStream is = TestWebappClassLoaderWeaving.class.getClassLoader()
                .getResourceAsStream(name);
        if (is == null) {
            throw new IOException("Resource " + name + " not found on classpath.");
        }
        FileOutputStream os = new FileOutputStream(file);
        try {
            for (int b = is.read(); b >= 0; b = is.read()) {
                os.write(b);
            }
        } finally {
            is.close();
            os.close();
        }
    }
    private static String invokeDoMethodOnClass(WebappClassLoader loader, String className)
            throws Exception {
        Class<?> c = loader.findClass("org.apache.catalina.loader." + className);
        assertNotNull("The loaded class should not be null.", c);
        Method m = c.getMethod("doMethod");
        Object o = c.newInstance();
        return (String) m.invoke(o);
    }
    private static class ReplacementTransformer implements ClassFileTransformer {
        private static final String CLASS_TO_WEAVE = PACKAGE_PREFIX + "/TesterUnweavedClass";
        private final byte[] replacement;
        ReplacementTransformer(byte[] replacement) {
            this.replacement = replacement;
        }
        @Override
        public byte[] transform(ClassLoader loader, String className, Class<?> x,
                                ProtectionDomain y, byte[] b) {
            if (CLASS_TO_WEAVE.equals(className)) {
                return this.replacement;
            }
            return null;
        }
    }
    /**
     * Compiled version of org.apache.catalina.loader.TesterUnweavedClass, except that
     * the doMethod method returns "Hello, Weaver #1!". Compiled with Oracle Java 1.6.0_51.
     */
    private static final byte[] WEAVED_REPLACEMENT_1 = new byte[] {
            -54, -2, -70, -66, 0, 0, 0, 50, 0, 17, 10, 0, 4, 0, 13, 8, 0, 14, 7, 0, 15, 7, 0, 16, 1,
            0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100, 101, 1, 0,
            15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 1, 0, 8, 100,
            111, 77, 101, 116, 104, 111, 100, 1, 0, 20, 40, 41, 76, 106, 97, 118, 97, 47, 108, 97,
            110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 1, 0, 10, 83, 111, 117, 114, 99, 101, 70,
            105, 108, 101, 1, 0, 24, 84, 101, 115, 116, 101, 114, 85, 110, 119, 101, 97, 118, 101,
            100, 67, 108, 97, 115, 115, 46, 106, 97, 118, 97, 12, 0, 5, 0, 6, 1, 0, 17, 72, 101,
            108, 108, 111, 44, 32, 87, 101, 97, 118, 101, 114, 32, 35, 49, 33, 1, 0, 46, 111, 114,
            103, 47, 97, 112, 97, 99, 104, 101, 47, 99, 97, 116, 97, 108, 105, 110, 97, 47, 108,
            111, 97, 100, 101, 114, 47, 84, 101, 115, 116, 101, 114, 85, 110, 119, 101, 97, 118,
            101, 100, 67, 108, 97, 115, 115, 1, 0, 16, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47,
            79, 98, 106, 101, 99, 116, 0, 33, 0, 3, 0, 4, 0, 0, 0, 0, 0, 2, 0, 1, 0, 5, 0, 6, 0, 1,
            0, 7, 0, 0, 0, 29, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 1, -79, 0, 0, 0, 1, 0, 8, 0, 0,
            0, 6, 0, 1, 0, 0, 0, 19, 0, 1, 0, 9, 0, 10, 0, 1, 0, 7, 0, 0, 0, 27, 0, 1, 0, 1, 0, 0,
            0, 3, 18, 2, -80, 0, 0, 0, 1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 22, 0, 1, 0, 11, 0, 0, 0,
            2, 0, 12
    };
    /**
     * Compiled version of org.apache.catalina.loader.TesterUnweavedClass, except that
     * the doMethod method returns "Hello, Weaver #2!". Compiled with Oracle Java 1.6.0_51.
     */
    private static final byte[] WEAVED_REPLACEMENT_2 = new byte[] {
            -54, -2, -70, -66, 0, 0, 0, 50, 0, 17, 10, 0, 4, 0, 13, 8, 0, 14, 7, 0, 15, 7, 0, 16, 1,
            0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100, 101, 1, 0,
            15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 1, 0, 8, 100,
            111, 77, 101, 116, 104, 111, 100, 1, 0, 20, 40, 41, 76, 106, 97, 118, 97, 47, 108, 97,
            110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 1, 0, 10, 83, 111, 117, 114, 99, 101, 70,
            105, 108, 101, 1, 0, 24, 84, 101, 115, 116, 101, 114, 85, 110, 119, 101, 97, 118, 101,
            100, 67, 108, 97, 115, 115, 46, 106, 97, 118, 97, 12, 0, 5, 0, 6, 1, 0, 17, 72, 101,
            108, 108, 111, 44, 32, 87, 101, 97, 118, 101, 114, 32, 35, 50, 33, 1, 0, 46, 111, 114,
            103, 47, 97, 112, 97, 99, 104, 101, 47, 99, 97, 116, 97, 108, 105, 110, 97, 47, 108,
            111, 97, 100, 101, 114, 47, 84, 101, 115, 116, 101, 114, 85, 110, 119, 101, 97, 118,
            101, 100, 67, 108, 97, 115, 115, 1, 0, 16, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47,
            79, 98, 106, 101, 99, 116, 0, 33, 0, 3, 0, 4, 0, 0, 0, 0, 0, 2, 0, 1, 0, 5, 0, 6, 0, 1,
            0, 7, 0, 0, 0, 29, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 1, -79, 0, 0, 0, 1, 0, 8, 0, 0,
            0, 6, 0, 1, 0, 0, 0, 19, 0, 1, 0, 9, 0, 10, 0, 1, 0, 7, 0, 0, 0, 27, 0, 1, 0, 1, 0, 0,
            0, 3, 18, 2, -80, 0, 0, 0, 1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 22, 0, 1, 0, 11, 0, 0, 0,
            2, 0, 12
    };
    /*
     * The WEAVED_REPLACEMENT_1 and WEAVED_REPLACEMENT_2 field contents are generated using the
     * following code. To regenerate them, alter the TesterUnweavedClass code as desired, recompile,
     * and run this main method.
     */
    public static void main(String... arguments) throws Exception {
        InputStream input = TestWebappClassLoaderWeaving.class.getClassLoader()
                .getResourceAsStream("org/apache/catalina/loader/TesterUnweavedClass.class");
        StringBuilder builder = new StringBuilder();
        builder.append("            ");
        System.out.println("    private static final byte[] WEAVED_REPLACEMENT_1 = new byte[] {");
        try {
            for (int i = 0, b = input.read(); b >= 0; i++, b = input.read()) {
                String value = "" + ((byte)b);
                if (builder.length() + value.length() > 97) {
                    builder.append(",");
                    System.out.println(builder.toString());
                    builder = new StringBuilder();
                    builder.append("            ").append(value);
                } else {
                    if (i > 0) {
                        builder.append(", ");
                    }
                    builder.append(value);
                }
            }
            System.out.println(builder.toString());
        } finally {
            input.close();
        }
        System.out.println("    }");
    }
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    public String doMethod() {
        return "This will never be weaved.";
    }
======= dd0cba7:"java/org/apache/catalina/loader/WebappClassLoader.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    public String doMethod() {
        return "Hello, Unweaved World!";
    }
      <add>
        <bug>55317</bug>: Facilitate weaving by allowing ClassFileTransformer to
        be added to WebppClassLoader. Patch by Nick Williams. (markt)
      </add>

======= 90556a9:"java/org/apache/catalina/util/ParameterMap.java"

======= 90556a9:"java/org/apache/catalina/util/ParameterMap.java"

======= 90556a9:"java/org/apache/tomcat/util/http/Parameters.java"

======= 90556a9:"java/org/apache/tomcat/util/http/Parameters.java"

    private final Map<String,ArrayList<String>> paramHashValues =
            new LinkedHashMap<>();

======= f627cc8:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri);

======= 910d4d9:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

                log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail"), e);
            log.error(sm.getString("spnegoAuthenticator.serviceLoginFail"), e);

======= f74257e:"java/org/apache/catalina/servlets/DefaultServlet.java"

        serveResource(request, response, true, fileEncoding);
======= f74257e:"java/org/apache/catalina/servlets/DefaultServlet.java"

        serveResource(request, response, false, fileEncoding);
======= f74257e:"java/org/apache/catalina/servlets/DefaultServlet.java"

     * @param request  The servlet request we are processing
     * @param content  Should the content be included?
     * @param encoding The encoding to use if it is necessary to access the
     *                 source as characters rather than as bytes
                                 boolean content,
                                 String encoding)
======= f74257e:"java/org/apache/catalina/servlets/DefaultServlet.java"

                    copy(resource, renderResult, writer, encoding);
======= f74257e:"java/org/apache/catalina/servlets/DefaultServlet.java"

     * @param encoding  The encoding to use when reading the source input stream
    protected void copy(WebResource resource, InputStream is, PrintWriter writer,
            String encoding) throws IOException {
======= f74257e:"java/org/apache/catalina/servlets/DefaultServlet.java"

        if (encoding == null) {
            reader = new InputStreamReader(resourceInputStream, encoding);
      <update>
        <bug>46727</bug>: Refactor default servlet to make it easier to
        sub-class to implement finer grained control of the file encoding. Based
        on a patch by Fred Toth. (markt)
      </update>

======= b284611:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

======= b284611:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                ConnectionList list = (ConnectionList) session.getAttribute(
                        cometRequestsAttribute);
                Request[] requests = null;
                if (list != null) {
                    requests = list.get();
                }
                            new ConnectionList(requests));
======= b284611:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                    session.setAttribute(cometRequestsAttribute,
                            new ConnectionList(newRequests));
======= b284611:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                            ConnectionList list =
                                    (ConnectionList) session.getAttribute(
                                            cometRequestsAttribute);
                            if (list != null) {
                                reqs = list.get();
                            }
======= b284611:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                                                new ConnectionList(
                                                        newConnectionInfos));
======= b284611:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

        ConnectionList list = (ConnectionList) se.getSession().getAttribute(
                cometRequestsAttribute);
        Request[] reqs = null;
        if (list != null) {
            reqs = list.get();
        }
======= b284611:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

    private static class ConnectionList implements Serializable {
        private static final long serialVersionUID = 1L;
        private transient Request[] connectionList = null;
        private ConnectionList(Request[] connectionList){
            this.connectionList = connectionList;
        }
        public Request[] get(){
            return connectionList;
        }
    }
        <bug>52558</bug>: Refactor <code>CometConnectionManagerValve</code> so
        that it does not prevent the session from being serialized in when
        running in a cluster. (markt) 
      </fix>
      <fix>

======= 66932c4:"java/org/apache/jasper/compiler/JspUtil.java"

        String returnType = expectedType.getCanonicalName();
        String targetType = returnType;
                returnType = Boolean.class.getName();
                returnType = Byte.class.getName();
                returnType = Character.class.getName();
                returnType = Short.class.getName();
                returnType = Integer.class.getName();
                returnType = Long.class.getName();
                returnType = Float.class.getName();
                returnType = Double.class.getName();
======= 66932c4:"java/org/apache/jasper/compiler/JspUtil.java"

                        + returnType

    
    <attribute name="validationQueryTimeout" required="false">
      <p>(int) The timeout in seconds before a connection validation queries fail.  This works by calling 
         <code>java.sql.Statement.setQueryTimeout(seconds)</code> on the statement that executes the <code>validationQuery</code>.
         The pool itself doesn't timeout the query, it is still up to the JDBC driver to enforce query timeouts. 
         A value less than or equal to zero will disable this feature. 
         The default value is <code>-1</code>.
      </p>
    </attribute>
======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                throw new SQLException("Validation Query Failed, enable logValidationErrors for more details.");
======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

    protected static final String PROP_VALIDATIONQUERY_TIMEOUT = "validationQueryTimeout";
======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        PROP_VALIDATIONQUERY_TIMEOUT,
======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        
        value = properties.getProperty(PROP_VALIDATIONQUERY_TIMEOUT);
        if (value != null) {
            poolProperties.setValidationQueryTimeout(Integer.parseInt(value));
        }
======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    
    /**
     * {@inheritDoc}
     */
    
    @Override
    public void setValidationQueryTimeout(int validationQueryTimeout) {
        this.poolProperties.setValidationQueryTimeout(validationQueryTimeout);
    }
======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    
    @Override
    public int getValidationQueryTimeout() {
        return getPoolProperties().getValidationQueryTimeout();
    }
    
    /**
     * {@inheritDoc}
     */
======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java"

     * The timeout in seconds before a connection validation queries fail.
     * A value less than or equal to zero will disable this feature.  Defaults to -1. 
     * @return the timeout value in seconds 
     */
    public int getValidationQueryTimeout();
    
    /**
     * The timeout in seconds before a connection validation queries fail.
     * A value less than or equal to zero will disable this feature.  Defaults to -1. 
     */
    public void setValidationQueryTimeout(int validationQueryTimeout);
    
    /**
======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    private volatile int validationQueryTimeout = -1;
======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    @Override
    public int getValidationQueryTimeout() {
        return validationQueryTimeout;
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public void setValidationQueryTimeout(int validationQueryTimeout) {
        this.validationQueryTimeout = validationQueryTimeout;
    }
    
    /**
     * {@inheritDoc}
     */
======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            
            int validationQueryTimeout = poolProperties.getValidationQueryTimeout();
            if (validationQueryTimeout > 0) {
                stmt.setQueryTimeout(validationQueryTimeout);
            }
            
======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    
    @Override
    public int getValidationQueryTimeout() {
        return getPoolProperties().getValidationQueryTimeout();
    }
======= b022c57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    @Override
    public void setValidationQueryTimeout(int validationQueryTimeout) {
        getPoolProperties().setValidationQueryTimeout(validationQueryTimeout);
    }
    
             
    <attribute    name="validationQueryTimeout"
           description="The timeout in seconds before a connection validation queries fail"
                  type="java.lang.Integer"
             writeable="false" />
    
    private static int TIMEOUT = 10;
    private static boolean isTimeoutSet;
    private static final String longQuery = "select * from test as A, test as B, test as C, test as D, test as E";
    
    @Before
    public void setUp() throws SQLException {
        DriverManager.registerDriver(new MockDriver());
        
        // use our mock driver
        this.datasource.setDriverClassName(MockDriver.class.getName());
        this.datasource.setUrl(MockDriver.url);
        
        // Required to trigger validation query's execution 
        this.datasource.setInitialSize(1);
        this.datasource.setTestOnBorrow(true);
        this.datasource.setValidationInterval(-1);
        this.datasource.setValidationQuery("SELECT 1");
        this.datasource.setValidationQueryTimeout(TIMEOUT);
        
        TIMEOUT = 10;
        isTimeoutSet = false;
    }
    
    @After
    public void tearDown() throws SQLException {
        DriverManager.deregisterDriver(new MockDriver());
    }
    
    @Test
    public void testValidationQueryTimeoutEnabled() throws Exception {
        // because testOnBorrow is true, this triggers the validation query
        this.datasource.getConnection();
        Assert.assertTrue(isTimeoutSet);
    }
    
    @Test
    public void testValidationQueryTimeoutDisabled() throws Exception {
        this.datasource.setValidationQueryTimeout(-1);
        
        // because testOnBorrow is true, this triggers the validation query
        this.datasource.getConnection();
        Assert.assertFalse(isTimeoutSet);
    }
    
    @Test
    public void testValidationQueryTimeoutWithQueryTimeoutInterceptor() throws Exception {
        int interceptorTimeout = 30;
        this.datasource.setJdbcInterceptors(
                            QueryTimeoutInterceptor.class.getName()+
                            "(queryTimeout="+ interceptorTimeout +")");
        
        // because testOnBorrow is true, this triggers the validation query
        Connection con = this.datasource.getConnection();
        Assert.assertTrue(isTimeoutSet);
        
        // increase the expected timeout to 30, which is what we set for the interceptor
        TIMEOUT = 30;
        
        // now create a statement, make sure the query timeout is set by the interceptor
        Statement st = con.createStatement();
        Assert.assertEquals(interceptorTimeout, st.getQueryTimeout());
        st.close();
        st = con.prepareStatement("");
        Assert.assertEquals(interceptorTimeout, st.getQueryTimeout());
        st.close();
        st = con.prepareCall("");
        Assert.assertEquals(interceptorTimeout, st.getQueryTimeout());
        st.close();
        con.close();
        
        // pull another connection and check it
        TIMEOUT = 10;
        isTimeoutSet = false;
        this.datasource.getConnection();
        Assert.assertTrue(isTimeoutSet);
    }
    
    // this test depends on the execution time of the validation query
    //   specifically, it needs to run for longer than 1 second to pass
    //   if this fails
    @Test(expected=SQLException.class) 
    public void testValidationQueryTimeoutOnConnection() throws Exception {
        // use our mock driver
        this.datasource.setDriverClassName("org.h2.Driver");
        this.datasource.setUrl("jdbc:h2:~/.h2/test;QUERY_TIMEOUT=0;DB_CLOSE_ON_EXIT=FALSE");
        
        // Required to trigger validation query's execution 
        this.datasource.setTestOnConnect(true);
        this.datasource.setValidationInterval(-1);
        this.datasource.setValidationQuery(longQuery);
        this.datasource.setValidationQueryTimeout(1);
        
        this.datasource.getConnection();
    }
    
    @Test(expected=SQLException.class)
    public void testValidationInvalidOnConnection() throws Exception {
        // use our mock driver
        this.datasource.setDriverClassName("org.h2.Driver");
        this.datasource.setUrl("jdbc:h2:~/.h2/test;QUERY_TIMEOUT=0;DB_CLOSE_ON_EXIT=FALSE");
        
        // Required to trigger validation query's execution 
        this.datasource.setTestOnBorrow(true);
        this.datasource.setInitialSize(1);
        this.datasource.setTestOnConnect(true);
        this.datasource.setValidationInterval(-1);
        this.datasource.setValidationQuery("SELECT");
        this.datasource.setValidationQueryTimeout(1);
        
        this.datasource.getConnection();
    }
    
    @Test
    public void testLongValidationQueryTime() throws Exception {
        // use our mock driver
        this.datasource.setDriverClassName("org.h2.Driver");
        this.datasource.setUrl("jdbc:h2:~/.h2/test;QUERY_TIMEOUT=0;DB_CLOSE_ON_EXIT=FALSE");
        Connection con = this.datasource.getConnection();
        Statement stmt = null;
        long start = 0, end = 0;
        try {
            stmt = con.createStatement();
            // set the query timeout to 2 sec
            //  this keeps this test from slowing things down too much
            stmt.setQueryTimeout(2);
            // assert that our long query takes longer than one second to run
            //  this is a requirement for other tests to run properly
            start = System.currentTimeMillis();
            stmt.execute(longQuery);
        } catch (SQLException ex) {}
        finally {
            end = System.currentTimeMillis();
        
            if (stmt != null) { stmt.close(); }
            if (con != null) { con.close(); }
            
            Assert.assertTrue(start != 0 && end != 0);
            Assert.assertTrue((end - start) > 1000);
        }
    }
    
    @Test
    public void testValidationQueryTimeoutOnBorrow() throws Exception {
        // use our mock driver
        this.datasource.setDriverClassName("org.h2.Driver");
        this.datasource.setUrl("jdbc:h2:~/.h2/test;QUERY_TIMEOUT=0;DB_CLOSE_ON_EXIT=FALSE");
        
        // Required to trigger validation query's execution 
        this.datasource.setTestOnBorrow(true);
        this.datasource.setValidationInterval(-1);
        this.datasource.setValidationQuery(longQuery);
        this.datasource.setValidationQueryTimeout(1);
        
        // assert that even though the validation query times out, we still get a connection
        Connection con = this.datasource.getConnection();
        Assert.assertNotNull(con);
        Statement st = con.createStatement();
        ResultSet rs = st.executeQuery("SELECT 1");
        rs.close();
        st.close();
        con.close();
    }
    
    /**
     * Mock Driver, Connection and Statement implementations use to verify setQueryTimeout was called.
     */
    public static class MockDriver implements java.sql.Driver {
        public static final String url = "jdbc:tomcat:mock";
        public MockDriver() {
        }
        @Override
        public boolean acceptsURL(String url) throws SQLException {
            return url!=null && url.equals(MockDriver.url);
        }
        @Override
        public Connection connect(String url, Properties info) throws SQLException {
            return new MockConnection(info);
        }
        @Override
        public int getMajorVersion() {
            return 0;
        }
        @Override
        public int getMinorVersion() {
            return 0;
        }
        @Override
        public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) throws SQLException {
            return null;
        }
        @Override
        public boolean jdbcCompliant() {
            return false;
        }
        @Override
        public Logger getParentLogger() throws SQLFeatureNotSupportedException {
            return null;
        }
    }
    
    public static class MockConnection extends org.apache.tomcat.jdbc.test.driver.Connection {
        public MockConnection(Properties info) {
            super(info);
        }
        @Override
        public Statement createStatement() throws SQLException {
            return new MockStatement();
        }
    }
    
    public static class MockStatement extends org.apache.tomcat.jdbc.test.driver.Statement {
        @Override
        public void setQueryTimeout(int seconds) throws SQLException {
            super.setQueryTimeout(seconds);
            Assert.assertEquals(TIMEOUT, seconds);
            isTimeoutSet = true;
        }
    }

======= 262c069:"java/org/apache/catalina/ha/session/DeltaSession.java"

        if (this.expiring) {
            return true;
        }
======= 262c069:"java/org/apache/catalina/ha/session/DeltaSession.java"

        // Check to see if session has already been invalidated.
        // Do not check expiring at this point as expire should not return until
        // isValid is false
        if (!isValid)
        synchronized (this) {
            // Check again, now we are inside the sync so this code only runs once
            // Double check locking - isValid needs to be volatile
            if (!isValid)
                return;
            if (manager == null)
                return;
            // Mark this session as "being expired". The flag will be unset in
            // the call to super.expire(notify)
            expiring = true;
            String expiredId = getIdInternal();
            if(notifyCluster && expiredId != null &&
                    manager instanceof DeltaManager) {
                DeltaManager dmanager = (DeltaManager)manager;
                CatalinaCluster cluster = dmanager.getCluster();
                ClusterMessage msg = dmanager.requestCompleted(expiredId, true);
                if (msg != null) {
                    cluster.send(msg);
                }
            super.expire(notify);
            if (notifyCluster) {
                if (log.isDebugEnabled())
                    log.debug(sm.getString("deltaSession.notifying",
                                           ((ClusterManager)manager).getName(),
                                           Boolean.valueOf(isPrimarySession()),
                                           expiredId));
                if ( manager instanceof DeltaManager ) {
                    ( (DeltaManager) manager).sessionExpired(expiredId);
                }
======= 262c069:"java/org/apache/catalina/session/StandardSession.java"

        if (this.expiring) {
            return true;
        }
======= 262c069:"java/org/apache/catalina/session/StandardSession.java"

        return this.isValid;
======= 262c069:"java/org/apache/catalina/session/StandardSession.java"

        // Check to see if session has already been invalidated.
        // Do not check expiring at this point as expire should not return until
        // isValid is false
        if (!isValid)
            // Double check locking - isValid needs to be volatile
            if (!isValid)
======= 262c069:"java/org/apache/catalina/session/StandardSession.java"

======= 262c069:"java/org/apache/catalina/session/StandardSession.java"

            setValid(false);
======= 262c069:"java/org/apache/catalina/session/StandardSession.java"

        return this.isValid;

======= f126b5a:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            if ("JKS".equals(keystoreType)) {

    <attribute name="ignoreExceptionOnPreLoad" required="false">
      <p>(boolean) Flag whether ignore error of connection creation while initializing the pool.
         Set to true if you want to ignore error of connection creation while initializing the pool.
         Set to false if you want to fail the initialization of the pool by throwing exception.
         The default value is <code>false</code>.
      </p>
    </attribute>
======= 4aa42d7:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            log.error("Unable to create initial connections of pool.", x);
            if (!poolProperties.isIgnoreExceptionOnPreLoad()) {
                if (jmxPool!=null) jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_INIT, getStackTrace(x));
                close(true);
                throw x;
            }
======= 4aa42d7:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

    protected static final String PROP_IGNOREEXCEPTIONONPRELOAD = "ignoreExceptionOnPreLoad";
======= 4aa42d7:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        PROP_PROPAGATEINTERRUPTSTATE,
        PROP_IGNOREEXCEPTIONONPRELOAD
======= 4aa42d7:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        value = properties.getProperty(PROP_IGNOREEXCEPTIONONPRELOAD);
        if (value != null) {
            poolProperties.setIgnoreExceptionOnPreLoad(Boolean.parseBoolean(value));
        }
======= 4aa42d7:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isIgnoreExceptionOnPreLoad() {
        return getPoolProperties().isIgnoreExceptionOnPreLoad();
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setIgnoreExceptionOnPreLoad(boolean ignoreExceptionOnPreLoad) {
        getPoolProperties().setIgnoreExceptionOnPreLoad(ignoreExceptionOnPreLoad);
    }
======= 4aa42d7:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java"

    /**
     * Set to true if you want to ignore error of connection creation while initializing the pool.
     * Set to false if you want to fail the initialization of the pool by throwing exception.
     * @param ignoreExceptionOnPreLoad set to true if you want to ignore error of connection creation while initializing the pool.
     */
    public void setIgnoreExceptionOnPreLoad(boolean ignoreExceptionOnPreLoad);
    /**
     * @see PoolConfiguration#setIgnoreExceptionOnPreLoad(boolean)
     */
    public boolean isIgnoreExceptionOnPreLoad();
======= 4aa42d7:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    private volatile boolean ignoreExceptionOnPreLoad = false;
======= 4aa42d7:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isIgnoreExceptionOnPreLoad() {
        return ignoreExceptionOnPreLoad;
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setIgnoreExceptionOnPreLoad(boolean ignoreExceptionOnPreLoad) {
        this.ignoreExceptionOnPreLoad = ignoreExceptionOnPreLoad;
    }
======= 4aa42d7:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    public boolean isIgnoreExceptionOnPreLoad() {
        return getPoolProperties().isIgnoreExceptionOnPreLoad();
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setIgnoreExceptionOnPreLoad(boolean ignoreExceptionOnPreLoad) {
        getPoolProperties().setIgnoreExceptionOnPreLoad(ignoreExceptionOnPreLoad);
    }
    /**
     * {@inheritDoc}
     */
    @Override

======= 41225cd:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

======= 41225cd:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"


======= cf1e104:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
            if (param == null) return;
            long timeout = ((Long)param).longValue();
            socketWrapper.setTimeout(timeout);
======= cf1e104:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

            resetTimeouts();
======= cf1e104:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

    // Methods called by asyncDispatch
    /**
     * Provides a mechanism for those connector implementations (currently only
     * NIO) that need to reset timeouts from Async timeouts to standard HTTP
     * timeouts once async processing completes.
     */
    protected abstract void resetTimeouts();
    // Methods called by prepareResponse()
    protected abstract void output(byte[] src, int offset, int length)
            throws IOException;
======= cf1e104:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

======= cf1e104:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

======= cf1e104:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

    protected void resetTimeouts() {
        // NO-OP. The AJP APR/native connector only uses the timeout value on
        //        time SocketWrapper for async timeouts.
    }
    @Override
======= cf1e104:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

======= cf1e104:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

======= cf1e104:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

    protected void resetTimeouts() {
        // The NIO connector uses the timeout configured on the wrapper in the
        // poller. Therefore, it needs to be reset once asycn processing has
        // finished.
        final NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socketWrapper.getSocket().getAttachment(false);
        if (!error && attach != null &&
                asyncStateMachine.isAsyncDispatching()) {
            long soTimeout = endpoint.getSoTimeout();
            //reset the timeout
            if (keepAliveTimeout > 0) {
                attach.setTimeout(keepAliveTimeout);
            } else {
                attach.setTimeout(soTimeout);
            }
        }
    }
    @Override
======= cf1e104:"java/org/apache/coyote/ajp/AjpProcessor.java"

======= cf1e104:"java/org/apache/coyote/ajp/AjpProcessor.java"

    protected void resetTimeouts() {
        // NO-OP. The AJP BIO connector only uses the timeout value on the
        //        SocketWrapper for async timeouts.
    }
    @Override

======= 7e74aee:"java/org/apache/catalina/realm/JNDIRealm.java"

                containerLog.info(sm.getString("jndiRealm.exception.retry"), e);
======= 7e74aee:"java/org/apache/catalina/realm/JNDIRealm.java"

                containerLog.info(sm.getString("jndiRealm.exception.retry"), e);
======= 7e74aee:"java/org/apache/catalina/realm/JNDIRealm.java"

                containerLog.info(sm.getString("jndiRealm.exception.retry"), e);
======= 7e74aee:"java/org/apache/catalina/realm/JNDIRealm.java"

                containerLog.info(sm.getString("jndiRealm.exception.retry"), e);
======= 7e74aee:"java/org/apache/catalina/realm/JNDIRealm.java"

                containerLog.info(sm.getString("jndiRealm.exception.retry"), e);
======= 7e74aee:"java/org/apache/catalina/realm/JNDIRealm.java"

            containerLog.info(sm.getString("jndiRealm.exception.retry"), e);

======= 6d99103:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

     * Should any response body be swallowed and not sent to the client.
     */
    private boolean swallowResponse = false;
    /**
======= 6d99103:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        swallowResponse = false;
======= 6d99103:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        // Responses with certain status codes are not permitted to include a
        // response body.
        int statusCode = response.getStatus();
        if (statusCode < 200 || statusCode == 204 || statusCode == 205 ||
                statusCode == 304) {
            // No entity body
            swallowResponse = true;
        }
        // Responses to HEAD requests are not permitted to incude a response
        // body.
        MessageBytes methodMB = request.method();
        if (methodMB.equals("HEAD")) {
            // No entity body
            swallowResponse = true;
        }
        responseMessage.appendInt(statusCode);
======= 6d99103:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

            if (!swallowResponse) {
                int len = chunk.getLength();
                // 4 - hardcoded, byte[] marshaling overhead
                // Adjust allowed size if packetSize != default (Constants.MAX_PACKET_SIZE)
                int chunkSize = Constants.MAX_SEND_SIZE + packetSize - Constants.MAX_PACKET_SIZE;
                int off = 0;
                while (len > 0) {
                    int thisTime = len;
                    if (thisTime > chunkSize) {
                        thisTime = chunkSize;
                    }
                    len -= thisTime;
                    responseMessage.reset();
                    responseMessage.appendByte(Constants.JK_AJP13_SEND_BODY_CHUNK);
                    responseMessage.appendBytes(chunk.getBytes(), chunk.getOffset() + off, thisTime);
                    responseMessage.end();
                    output(responseMessage.getBuffer(), 0, responseMessage.getLen());
                    off += thisTime;
                bytesWritten += chunk.getLength();
            }
======= 6d99103:"test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java"

======= 6d99103:"test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java"

======= 6d99103:"test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java"

    /*
     * Bug 55453
     */
    @Test
    public void test304WithBody() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctx, "bug55453", new Tester304WithBodyServlet());
        ctx.addServletMapping("/", "bug55453");
        tomcat.start();
        SimpleAjpClient ajpClient = new SimpleAjpClient();
        ajpClient.setPort(getPort());
        ajpClient.connect();
        validateCpong(ajpClient.cping());
        TesterAjpMessage forwardMessage = ajpClient.createForwardMessage("/");
        forwardMessage.end();
        TesterAjpMessage responseHeaders =
                ajpClient.sendMessage(forwardMessage, null);
        // Expect 2 messages: headers, end
        validateResponseHeaders(responseHeaders, 304);
        validateResponseEnd(ajpClient.readMessage(), true);
        // Double check the connection is still open
        validateCpong(ajpClient.cping());
        ajpClient.disconnect();
    }
======= 6d99103:"test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java"

    private static class Tester304WithBodyServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setStatus(304);
            resp.getWriter().print("Body not permitted for 304 response");
        }
    }

======= 058f044:"java/org/apache/catalina/startup/Tomcat.java"

======= 058f044:"java/org/apache/catalina/startup/Tomcat.java"

     * web application and any WEB-INF/web.xml and META-INF/context.xml packaged
     * with the application will be processed normally. Normal web fragment and
======= 058f044:"java/org/apache/catalina/startup/Tomcat.java"

        ctx.setConfigFile(getWebappConfigFile(path, url));
======= 058f044:"java/org/apache/catalina/startup/Tomcat.java"

        Logger.getLogger(getLoggerName(host, ctx)).setLevel(Level.WARNING);
    }
    private String getLoggerName(Host host, String ctx) {
        String loggerName = "org.apache.catalina.core.ContainerBase.[default].[";
            loggerName += getHost().getName();
            loggerName += host.getName();
        loggerName += "].[";
        loggerName += ctx;
        loggerName += "]";
        return loggerName;
======= 058f044:"java/org/apache/catalina/startup/Tomcat.java"

    protected URL getWebappConfigFile(String path, String url) {
        File docBase = new File(path);
        if (docBase.isDirectory()) {
            return getWebappConfigFileFromDirectory(docBase, url);
        } else {
            return getWebappConfigFileFromJar(docBase, url);
        }
    }
    private URL getWebappConfigFileFromDirectory(File docBase, String url) {
        URL result = null;
        File webAppContextXml = new File(docBase, Constants.ApplicationContextXml);
        if (webAppContextXml.exists()) {
            try {
                result = webAppContextXml.toURI().toURL();
            } catch (MalformedURLException e) {
                Logger.getLogger(getLoggerName(getHost(), url)).log(Level.WARNING,
                        "Unable to determine web application context.xml " + docBase, e);
            }
        }
        return result;
    }
    private URL getWebappConfigFileFromJar(File docBase, String url) {
        URL result = null;
        JarFile jar = null;
        try {
            jar = new JarFile(docBase);
            JarEntry entry = jar.getJarEntry(Constants.ApplicationContextXml);
            if (entry != null) {
                result = new URL("jar:" + docBase.toURI().toString() + "!/"
                        + Constants.ApplicationContextXml);
            }
        } catch (IOException e) {
            Logger.getLogger(getLoggerName(getHost(), url)).log(Level.WARNING,
                    "Unable to determine web application context.xml " + docBase, e);
        } finally {
            if (jar != null) {
                try {
                    jar.close();
                } catch (IOException e) {
                    // ignore
                }
            }
        }
        return result;
    }
======= 058f044:"test/org/apache/catalina/startup/TestTomcat.java"

======= 058f044:"test/org/apache/catalina/startup/TestTomcat.java"

    @Test
    public void testGetWebappConfigFileFromDirectory() {
        Tomcat tomcat = new Tomcat();
        assertNotNull(tomcat.getWebappConfigFile("test/deployment/dirContext", ""));
    }
    @Test
    public void testGetWebappConfigFileFromDirectoryNegative() {
        Tomcat tomcat = new Tomcat();
        assertNull(tomcat.getWebappConfigFile("test/deployment/dirNoContext", ""));
    }
    @Test
    public void testGetWebappConfigFileFromJar() {
        Tomcat tomcat = new Tomcat();
        assertNotNull(tomcat.getWebappConfigFile("test/deployment/context.war", ""));
    }
    @Test
    public void testGetWebappConfigFileFromJarNegative() {
        Tomcat tomcat = new Tomcat();
        assertNull(tomcat.getWebappConfigFile("test/deployment/noContext.war", ""));
    }
    @Test
    public void testBug51526() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appFile = new File("test/deployment/context.war");
        StandardContext context = (StandardContext) tomcat.addWebapp(null, "/test",
                appFile.getAbsolutePath());
        tomcat.start();
        assertEquals("WAR_CONTEXT", context.getSessionCookieName());
    }

======= 9a22360:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "</td>\n" +
        "</tr>\n" +

======= 8b03dcf:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

            String value = "";
                value = readTokenOrQuotedString(input, true);
            }
            if (attribute != null) {
======= 8b03dcf:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

    @Test
    public void testBug55454() throws IOException {
        String input = "text/html;;charset=UTF-8";
        StringReader sr = new StringReader(input);
        MediaType m = HttpParser.parseMediaType(sr);
        assertEquals("text", m.getType());
        assertEquals("html", m.getSubtype());
        assertTrue(m.getParameterCount() == 1);
        assertEquals("UTF-8", m.getParameterValue("charset"));
        assertEquals("UTF-8", m.getCharset());
        assertEquals("text/html; charset=UTF-8", m.toString());
    }

======= ab70f07:"java/org/apache/el/parser/AstFunction.java"

======= ab70f07:"java/org/apache/el/parser/AstFunction.java"

            // Call to a constructor or a static method
            obj = ctx.getImportHandler().resolveClass(this.localName);
            if (obj != null) {
                return ctx.getELResolver().invoke(ctx, new ELClass((Class<?>) obj), "<init>", null,
                        ((AstMethodParameters) this.children[0]).getParameters(ctx));
            }
            obj = ctx.getImportHandler().resolveStatic(this.localName);
            if (obj != null) {
                return ctx.getELResolver().invoke(ctx, new ELClass((Class<?>) obj), this.localName,
                        null, ((AstMethodParameters) this.children[0]).getParameters(ctx));
            }
======= ab70f07:"java/org/apache/el/parser/AstFunction.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testImport01() {
        ELProcessor processor = new ELProcessor();
        Object result = processor.getValue("Integer(1000)", Integer.class);
        Assert.assertEquals(Integer.valueOf(1000), result);
    }
    @Test
    public void testImport02() {
        ELProcessor processor = new ELProcessor();
        processor.getELManager().getELContext().getImportHandler()
                .importStatic("java.lang.Integer.valueOf");
        Object result = processor.getValue("valueOf(1000)", Integer.class);
        Assert.assertEquals(Integer.valueOf(1000), result);
    }

======= 7f6ea48:"java/org/apache/catalina/connector/InputBuffer.java"

        if (!coyoteRequest.isFinished() && isReady()) {
        return coyoteRequest.isFinished();
======= 7f6ea48:"java/org/apache/catalina/connector/Request.java"

        return coyoteRequest.isFinished();
======= 7f6ea48:"java/org/apache/coyote/Request.java"

    public boolean isFinished() {
        AtomicBoolean result = new AtomicBoolean(false);
        action(ActionCode.REQUEST_BODY_FULLY_READ, result);
        return result.get();
    }
    // -------------------- Input Buffer --------------------
======= 7f6ea48:"test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java"

                servlet.wlistener.onErrorInvoked || servlet.rlistener.onErrorInvoked);
======= 7f6ea48:"test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java"

    @Test
    public void testBug55438NonBlockingReadWriteEmptyRead() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        StandardContext ctx = (StandardContext) tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        NBReadWriteServlet servlet = new NBReadWriteServlet();
        String servletName = NBReadWriteServlet.class.getName();
        Tomcat.addServlet(ctx, servletName, servlet);
        ctx.addServletMapping("/", servletName);
        tomcat.start();
        Map<String, List<String>> resHeaders = new HashMap<>();
        int rc = postUrl(false, new BytesStreamer() {
            @Override
            public byte[] next() {
                return new byte[] {};
            }
            @Override
            public int getLength() {
                return 0;
            }
            @Override
            public int available() {
                return 0;
            }
        }, "http://localhost:" +
                getPort() + "/", new ByteChunk(), resHeaders, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
    }
======= 7f6ea48:"test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java"

    @WebServlet(asyncSupported = true)
    public class NBReadWriteServlet extends TesterServlet {
        private static final long serialVersionUID = 1L;
        public volatile TestReadWriteListener rwlistener;
        @Override
        protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            // step 1 - start async
            AsyncContext actx = req.startAsync();
            actx.setTimeout(Long.MAX_VALUE);
            // step 2 - notify on read
            ServletInputStream in = req.getInputStream();
            rwlistener = new TestReadWriteListener(actx);
            in.setReadListener(rwlistener);
        }
    }
        public volatile boolean onErrorInvoked = false;
======= 7f6ea48:"test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java"

            onErrorInvoked = true;
======= 7f6ea48:"test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java"

    private class TestReadWriteListener implements ReadListener {
        AsyncContext ctx;
        private final StringBuilder body = new StringBuilder();
        public TestReadWriteListener(AsyncContext ctx) {
            this.ctx = ctx;
        }
        @Override
        public void onDataAvailable() throws IOException {
            ServletInputStream in = ctx.getRequest().getInputStream();
            String s = "";
            byte[] b = new byte[8192];
            int read = 0;
            do {
                read = in.read(b);
                if (read == -1) {
                    break;
                }
                s += new String(b, 0, read);
            } while (in.isReady());
            log.info("Read [" + s + "]");
            body.append(s);
        }
        @Override
        public void onAllDataRead() throws IOException {
            log.info("onAllDataRead");
            ServletOutputStream output = ctx.getResponse().getOutputStream();
            output.setWriteListener(new WriteListener() {
                @Override
                public void onWritePossible() throws IOException {
                    ServletOutputStream output = ctx.getResponse().getOutputStream();
                    if (output.isReady()) {
                        log.info("Writing [" + body.toString() + "]");
                        output.write(body.toString().getBytes("utf-8"));
                    }
                    ctx.complete();
                }
                @Override
                public void onError(Throwable throwable) {
                    log.info("ReadWriteListener.onError");
                    throwable.printStackTrace();
                }
            });
        }
        @Override
        public void onError(Throwable throwable) {
            log.info("ReadListener.onError");
            throwable.printStackTrace();
        }
    }

======= 98ee5b4:"java/org/apache/tomcat/websocket/server/UriTemplate.java"

======= 98ee5b4:"java/org/apache/tomcat/websocket/server/UriTemplate.java"

    private final List<Segment> segments = new ArrayList<>();
======= 98ee5b4:"java/org/apache/tomcat/websocket/server/UriTemplate.java"

        Set<String> paramNames = new HashSet<>();
======= 98ee5b4:"java/org/apache/tomcat/websocket/server/UriTemplate.java"

                if (!paramNames.add(segment)) {
                    throw new IllegalArgumentException(sm.getString(
                            "uriTemplate.duplicateParameter", segment));
                }
======= 98ee5b4:"java/org/apache/tomcat/websocket/server/UriTemplate.java"

            this.segments.add(new Segment(index, segment));
======= 98ee5b4:"java/org/apache/tomcat/websocket/server/UriTemplate.java"

                candidate.getSegments().iterator();
        Iterator<Segment> targetSegments = segments.iterator();
======= 98ee5b4:"java/org/apache/tomcat/websocket/server/UriTemplate.java"

    private List<Segment> getSegments() {
      <Method name="testDuplicate01" />
    <Bug pattern="DLS_DEAD_LOCAL_STORE"/>
======= 98ee5b4:"test/org/apache/tomcat/websocket/server/TestUriTemplate.java"

    }
======= 98ee5b4:"test/org/apache/tomcat/websocket/server/TestUriTemplate.java"

    }
    public void testDuplicate01() throws Exception {
    }
    @Test
    public void testDuplicate02() throws Exception {
        UriTemplate t = new UriTemplate("/{a}/{b}");
        Map<String,String> result = t.match(new UriTemplate("/x/x"));
        Assert.assertEquals(2, result.size());
        Assert.assertEquals("x", result.get("a"));
        Assert.assertEquals("x", result.get("b"));
    }

======= 135e2c4:"java/org/apache/catalina/realm/JNDIRealm.java"

        Hashtable<?, ?> preservedEnvironment = null;
                // Preserve the current context environment parameters
                preservedEnvironment = context.getEnvironment();
======= 135e2c4:"java/org/apache/catalina/realm/JNDIRealm.java"

            restoreEnvironmentParameter(context,
                    Context.SECURITY_AUTHENTICATION, preservedEnvironment);
            restoreEnvironmentParameter(context,
                    "javax.security.sasl.server.authentication", preservedEnvironment);
            restoreEnvironmentParameter(context, "javax.security.sasl.qop",
                    preservedEnvironment);
======= 135e2c4:"java/org/apache/catalina/realm/JNDIRealm.java"

    private void restoreEnvironmentParameter(DirContext context,
            String parameterName, Hashtable<?, ?> preservedEnvironment) {
        try {
            context.removeFromEnvironment(parameterName);
            if (preservedEnvironment != null && preservedEnvironment.containsKey(parameterName)) {
                context.addToEnvironment(parameterName,
                        preservedEnvironment.get(parameterName));
            }
        } catch (NamingException e) {
            // Ignore
        }
    }

======= e19e794:"java/org/apache/catalina/session/FileStore.java"

        ClassLoader oldThreadContextCL = Thread.currentThread().getContextClassLoader();
======= e19e794:"java/org/apache/catalina/session/FileStore.java"

            if (classLoader != null) {
                Thread.currentThread().setContextClassLoader(classLoader);
            } else {
            }
            StandardSession session =
                    (StandardSession) manager.createEmptySession();
            session.readObjectData(ois);
            session.setManager(manager);
            return (session);
======= e19e794:"java/org/apache/catalina/session/FileStore.java"

            if (ois != null) {
                // Close the input stream
                try {
                    ois.close();
                } catch (IOException f) {
                    // Ignore
                }
            Thread.currentThread().setContextClassLoader(oldThreadContextCL);
======= e19e794:"java/org/apache/catalina/session/JDBCStore.java"

                ClassLoader oldThreadContextCL = Thread.currentThread().getContextClassLoader();
======= e19e794:"java/org/apache/catalina/session/JDBCStore.java"

                            Thread.currentThread().setContextClassLoader(classLoader);
======= e19e794:"java/org/apache/catalina/session/JDBCStore.java"

                    Thread.currentThread().setContextClassLoader(oldThreadContextCL);

======= 3490f73:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

        FilterRegistration.Dynamic fr = servletContext.addFilter(
        fr.setAsyncSupported(true);

======= df02b95:"java/org/apache/catalina/startup/ContextConfig.java"

                    log.warn(sm.getString("contextConfig.role.auth", roles[j]));
======= df02b95:"java/org/apache/catalina/startup/ContextConfig.java"

                log.warn(sm.getString("contextConfig.role.runas", runAs));
                    log.warn(sm.getString("contextConfig.role.link", link));

======= 7d0408e:"java/org/apache/juli/FileHandler.java"

======= 7d0408e:"java/org/apache/juli/FileHandler.java"

                setFormatter(new OneLineFormatter());
            setFormatter(new OneLineFormatter());
      <update>
        <bug>52092</bug>: JULI now uses the <code>OneLineFormatter</code> and
        <code>AsyncFileHandler</code> by default. (markt)
      </update>

======= aa15bac:"java/org/apache/catalina/core/StandardContext.java"

        // The WebResources API expects all paths to start with /. This is a
        // special case for consistency with earlier Tomcat versions.
        if ("".equals(path)) {
            path = "/";
        }

======= 6cd42af:"java/org/apache/catalina/realm/JDBCRealm.java"

                dbConnection.commit();

======= d370084:"java/org/apache/tomcat/websocket/WsSession.java"

            if (log.isDebugEnabled()) {
                log.debug(sm.getString("wsSession.sendCloseFail"), ioe);
            }

======= 7540e90:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

                        process(scanType, callback, url, true);
======= 7540e90:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

                        ClassPathEntry cpe = new ClassPathEntry(urls[i]);
                        // JARs are scanned unless the filter says not to.
                        // Directories are scanned for pluggability scans or
                        // if scanAllDirectories is enabled unless the
                        // filter says not to.
                        if ((cpe.isJar() ||
                                scanType == JarScanType.PLUGGABILITY ||
                                isScanAllDirectories()) &&
                                        jarScanFilter.check(scanType,
                                                cpe.getName())) {
                                log.debug(sm.getString(
                                        "jarScan.classloaderJarScan", urls[i]));
                                process(scanType, callback, urls[i], isWebapp);
                                        "jarScan.classloaderFail", urls[i]),
                                                ioe);
                            // JAR / directory has been skipped
                                log.trace(sm.getString(
                                        "jarScan.classloaderJarNoScan",
                                        urls[i]));
======= 7540e90:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

    private void process(JarScanType scanType, JarScannerCallback callback,
            URL url, boolean isWebapp) throws IOException {
======= 7540e90:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

                        } else if (f.isDirectory()) {
                            if (scanType == JarScanType.PLUGGABILITY) {
                            } else {
                                File metainf = new File(f.getAbsoluteFile() +
                                        File.separator + "META-INF");
                                if (metainf.isDirectory()) {
                                    callback.scan(f, isWebapp);
                                }
======= 7540e90:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

    private static class ClassPathEntry {
        private final boolean jar;
        private final String name;
        public ClassPathEntry(URL url) {
            String path = url.getPath();
            int end = path.indexOf(Constants.JAR_EXT);
            if (end != -1) {
                jar = true;
                int start = path.lastIndexOf('/', end);
                name = path.substring(start + 1, end + 4);
            } else {
                jar = false;
                if (path.endsWith("/")) {
                    path = path.substring(0, path.length() - 1);
                }
                int start = path.lastIndexOf('/');
                name = path.substring(start + 1);
            }
        public boolean isJar() {
            return jar;
        }
        public String getName() {
            return name;
        }
    }
       <p>The comma separated list of JAR file and / or directory name patterns
       to skip when scanning for TLDs. If not specified, the default is obtained
       from the <code>tomcat.util.scan.StandardJarScanFilter.jarsToSkip</code>
       system property.</p>
       <p>The comma separated list of JAR file and / or directory name patterns
       to scan when scanning for TLDs. If not specified, the default is obtained
       from the <code>tomcat.util.scan.StandardJarScanFilter.jarsToScan</code>
       system property.</p>
       <p>The comma separated list of JAR file and / or directory name patterns
       to skip when scanning for pluggable features. If not specified, the
       default is obtained from the
       <p>The comma separated list of JAR file and / or directory name patterns
       to scan when scanning for pluggable features. If not specified, the
       default is obtained from the
  used to scan the web application for JAR files and directories of class files.
  It is typically used during web application start to identify configuration
  files such as TLDs or web-fragment.xml files that must be processed as part of
  the web application initialisation.</p>
       if are expanded JAR files. The default is <code>false</code>. Tomcat
       directory assumed to be an expanded JAR file. Note that for scans for
       matches to <code>@HandlesTypes</code> annotations, all directories will
       be scanned irrespective of the presence or not of a META-INF
       sub-directory.</p>

======= 11c05b7:"java/org/apache/jasper/compiler/TagPluginManager.java"

======= 11c05b7:"java/org/apache/jasper/compiler/TagPluginManager.java"

        page.visit(new NodeVisitor(this, pageInfo));
======= 11c05b7:"java/org/apache/jasper/compiler/TagPluginManager.java"

    private void invokePlugin(Node.CustomTag n, PageInfo pageInfo) {
======= 11c05b7:"java/org/apache/jasper/compiler/TagPluginManager.java"

    private static class NodeVisitor extends Node.Visitor {
        private TagPluginManager manager;
        private PageInfo pageInfo;
        public NodeVisitor(TagPluginManager manager, PageInfo pageInfo) {
            this.manager = manager;
            this.pageInfo = pageInfo;
        }
        @Override
        public void visit(Node.CustomTag n) throws JasperException {
            manager.invokePlugin(n, pageInfo);
            visitBody(n);
        }
    }

======= 6e514c0:"java/org/apache/catalina/startup/ContextConfig.java"

======= 6e514c0:"java/org/apache/catalina/startup/ContextConfig.java"

            processServletContainerInitializers(context.getServletContext());
======= 6e514c0:"java/org/apache/catalina/startup/ContextConfig.java"

    protected void processServletContainerInitializers(ServletContext servletContext) {
        Collection<ServletContainerInitializer> detectedScis;
        try {
            WebappServiceLoader<ServletContainerInitializer> loader =
                    new WebappServiceLoader<>(servletContext);
            detectedScis = loader.load(ServletContainerInitializer.class);
        } catch (IOException e) {
            log.error(sm.getString(
                    "contextConfig.servletContainerInitializerFail",
                    context.getName()),
                e);
            ok = false;
            return;
        }
        for (ServletContainerInitializer sci : detectedScis) {
            initializerClassMap.put(sci, new HashSet<Class<?>>());
            HandlesTypes ht;
                ht = sci.getClass().getAnnotation(HandlesTypes.class);
            } catch (Exception e) {
                if (log.isDebugEnabled()) {
                    log.info(sm.getString("contextConfig.sci.debug",
                            sci.getClass().getName()),
                            e);
                } else {
                    log.info(sm.getString("contextConfig.sci.info",
                            sci.getClass().getName()));
                continue;
            if (ht == null) {
            Class<?>[] types = ht.value();
            if (types == null) {
                continue;
            for (Class<?> type : types) {
                if (type.isAnnotation()) {
                    handlesTypesAnnotations = true;
                } else {
                    handlesTypesNonAnnotations = true;
                Set<ServletContainerInitializer> scis =
                        typeInitializerMap.get(type);
                if (scis == null) {
                    scis = new HashSet<>();
                    typeInitializerMap.put(type, scis);
                }
                scis.add(sci);
======= 6e514c0:"java/org/apache/catalina/startup/ContextConfig.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * A variation of Java's JAR ServiceLoader that respects exclusion rules for web applications.
 * <p/>
 * Primarily intended for use loading ServletContainerInitializers as defined by Servlet 8.2.4.
 * This implementation does not attempt lazy loading as the container is required to
 * introspect all implementations discovered.
 * <p/>
 * If the ServletContext defines ORDERED_LIBS, then only JARs in WEB-INF/lib
 * that are named in that set will be included in the search for
 * provider configuration files; if ORDERED_LIBS is not defined then
 * all JARs will be searched for provider configuration files. Providers
 * defined by resources in the parent ClassLoader will always be returned.
 * <p/>
 * Provider classes will be loaded using the context's ClassLoader.
 *
 * @see javax.servlet.ServletContainerInitializer
 * @see java.util.ServiceLoader
 */
    private static final String LIB = "/WEB-INF/lib/";
    private static final String SERVICES = "META-INF/services/";
    private static final Charset UTF8 = Charset.forName("UTF-8");
    private final ServletContext context;
    /**
     * Construct a loader to load services from a ServletContext.
     *
     * @param context the context to use
     */
    public WebappServiceLoader(ServletContext context) {
        this.context = context;
    }
    /**
     * Load the providers for a service type.
     *
     * @param serviceType the type of service to load
     * @return an unmodifiable collection of service providers
     * @throws IOException if there was a problem loading any service
     */
    public Collection<T> load(Class<T> serviceType) throws IOException {
        String configFile = SERVICES + serviceType.getName();
        Set<String> servicesFound = new HashSet<>();
        ClassLoader loader = context.getClassLoader();
        // if the ServletContext has ORDERED_LIBS, then use that to specify the
        // set of JARs from WEB-INF/lib that should be used for loading services
        @SuppressWarnings("unchecked")
        List<String> orderedLibs = (List<String>) context.getAttribute(ServletContext.ORDERED_LIBS);
        if (orderedLibs != null) {
            // handle ordered libs directly, ...
            for (String lib : orderedLibs) {
                URL jarUrl = context.getResource(LIB + lib);
                if (jarUrl == null) {
                    // should not happen, just ignore
                    continue;
                }
                String base = jarUrl.toExternalForm();
                URL url;
                if (base.endsWith("/")) {
                    url = new URL(base + configFile);
                } else {
                    url = new URL("jar:" + base + "!/" + configFile);
                }
                try {
                    parseConfigFile(servicesFound, url);
                } catch (FileNotFoundException e) {
                    // no provider file found, this is OK
                }
            }
            // and the parent ClassLoader for all others
            loader = loader.getParent();
        }
        Enumeration<URL> resources;
        if (loader == null) {
            resources = ClassLoader.getSystemResources(configFile);
        } else {
            resources = loader.getResources(configFile);
        }
        while (resources.hasMoreElements()) {
            parseConfigFile(servicesFound, resources.nextElement());
        }
        // load the discovered services
        if (servicesFound.isEmpty()) {
            return Collections.emptyList();
        }
        return loadServices(serviceType, servicesFound);
    }
    private void parseConfigFile(Set<String> servicesFound, URL url) throws IOException {
        try (InputStream is = url.openStream()) {
            BufferedReader reader = new BufferedReader(new InputStreamReader(is, UTF8));
            String line;
            while ((line = reader.readLine()) != null) {
                int i = line.indexOf('#');
                if (i >= 0) {
                    line = line.substring(0, i);
                }
                line = line.trim();
                if (line.length() == 0) {
                    continue;
                }
                if (servicesFound.contains(line)) {
                    continue;
                }
                servicesFound.add(line);
            }
        }
    }
    private Collection<T> loadServices(Class<T> serviceType, Set<String> servicesFound) throws IOException {
        ClassLoader loader = context.getClassLoader();
        List<T> services = new ArrayList<>(servicesFound.size());
        for (String serviceClass : servicesFound) {
            try {
                Class<?> clazz = Class.forName(serviceClass, true, loader);
                services.add(serviceType.cast(clazz.newInstance()));
            } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | ClassCastException e) {
                throw new IOException(e);
            }
        }
        return Collections.unmodifiableCollection(services);
    }
======= 6e514c0:"java/org/apache/catalina/startup/ContextConfig.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testWebapp() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-fragments-empty-absolute-ordering");
        StandardContext ctxt = (StandardContext) tomcat.addContext(null, "/test", appDir.getAbsolutePath());
        ctxt.addLifecycleListener(new ContextConfig());
        tomcat.start();
        WebappServiceLoader<ServletContainerInitializer> loader =
                new WebappServiceLoader<>(ctxt.getServletContext());
        Collection<ServletContainerInitializer> initializers = loader.load(ServletContainerInitializer.class);
    }

======= 11bf498:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

        long writeTimeout = att.getWriteTimeout();
======= 11bf498:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

        long writeTimeout = att.getWriteTimeout();
======= 11bf498:"java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java"

        long writeTimeout = att.getWriteTimeout();
======= 11bf498:"java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java"

        long writeTimeout = att.getWriteTimeout();
======= 11bf498:"java/org/apache/tomcat/util/net/NioEndpoint.java"

            setWriteTimeout(soTimeout);
======= 11bf498:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        public void setWriteTimeout(long writeTimeout) {
            this.writeTimeout = writeTimeout;
        }
        public long getWriteTimeout() {return this.writeTimeout;}
        private long writeTimeout = -1;

======= ab6f21d:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

        if (wsSessions == null) {

======= 85f611e:"java/org/apache/tomcat/util/descriptor/web/JspPropertyGroup.java"

======= 85f611e:"java/org/apache/tomcat/util/descriptor/web/JspPropertyGroup.java"

    private final Collection<String> includeCodas = new ArrayList<>();
    public Collection<String> getIncludeCodas() { return includeCodas; }
    private final Collection<String> includePreludes = new ArrayList<>();
    public Collection<String> getIncludePreludes() { return includePreludes; }
======= 85f611e:"test/org/apache/jasper/compiler/TestCompiler.java"

======= 85f611e:"test/org/apache/jasper/compiler/TestCompiler.java"

    @Test
    public void testBug55262() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug55262.jsp");
        String result = res.toString();
        Pattern prelude = Pattern.compile(
                "(.*This is a prelude\\.){2}.*",
                Pattern.MULTILINE | Pattern.DOTALL);
        Pattern coda = Pattern.compile(
                "(.*This is a coda\\.){2}.*",
                Pattern.MULTILINE|Pattern.DOTALL);
        assertTrue(prelude.matcher(result).matches());
        assertTrue(coda.matcher(result).matches());
    }
======= 85f611e:"test/org/apache/jasper/servlet/TestJspCServletContext.java"

        Assert.assertEquals(2, propertyGroups.size());
        Iterator<JspPropertyGroupDescriptor> groupIterator =
                propertyGroups.iterator();
        JspPropertyGroupDescriptor groupDescriptor;
        groupDescriptor = groupIterator.next();
======= 85f611e:"test/org/apache/jasper/servlet/TestJspCServletContext.java"

        groupDescriptor = groupIterator.next();
        Assert.assertEquals(2, groupDescriptor.getIncludePreludes().size());
        Assert.assertEquals(2, groupDescriptor.getIncludeCodas().size());
======= 85f611e:"test/org/apache/jasper/servlet/TestJspCServletContext.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private JspPropertyGroup group = new JspPropertyGroup();
    @Test
    public void testBug55262() {
        group.addIncludePrelude("/prelude");
        group.addIncludePrelude("/prelude");
        group.addIncludeCoda("/coda");
        group.addIncludeCoda("/coda");
        Assert.assertEquals(2, group.getIncludePreludes().size());
        Assert.assertEquals(2, group.getIncludeCodas().size());
    }
    <jsp-property-group>
      <url-pattern>/bug5nnnn/bug55262.jsp</url-pattern>
      <include-prelude>/bug5nnnn/bug55262-prelude.jspf</include-prelude>
      <include-prelude>/bug5nnnn/bug55262-prelude.jspf</include-prelude>
      <include-coda>/bug5nnnn/bug55262-coda.jspf</include-coda>
      <include-coda>/bug5nnnn/bug55262-coda.jspf</include-coda>
      <default-content-type>text/plain</default-content-type>
    </jsp-property-group>
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  --%>
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  --%>
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  --%>

======= c6a45a6:"java/org/apache/jasper/compiler/JspConfig.java"

            Vector<String> includePreludes = new Vector<>();
            includePreludes.addAll(jspPropertyGroup.getIncludePreludes());
            Vector<String> includeCodas = new Vector<>();
            includeCodas.addAll(jspPropertyGroup.getIncludeCodas());
            JspProperty property = new JspProperty(jspPropertyGroup.getIsXml(),
                    jspPropertyGroup.getElIgnored(),
                    jspPropertyGroup.getScriptingInvalid(),
                    jspPropertyGroup.getPageEncoding(),
                    includePreludes,
                    includeCodas,
                    jspPropertyGroup.getDeferredSyntaxAllowedAsLiteral(),
                    jspPropertyGroup.getTrimDirectiveWhitespaces(),
                    jspPropertyGroup.getDefaultContentType(),
                    jspPropertyGroup.getBuffer(),
                    jspPropertyGroup.getErrorOnUndeclaredNamespace());
======= c6a45a6:"java/org/apache/jasper/compiler/JspConfig.java"


 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private JspC jspc;
    private File outputDir;
    @Before
    public void init() {
        jspc = new JspC();
        outputDir = new File("output/jspc");
    }
    @Test
    public void precompileWebapp_2_2() throws IOException {
        File appDir = new File("test/webapp-2.2");
        File webappOut = new File(outputDir, appDir.getName());
        precompile(appDir, webappOut);
        verify(webappOut);
    }
    @Test
    public void precompileWebapp_2_3() throws IOException {
        File appDir = new File("test/webapp-2.3");
        File webappOut = new File(outputDir, appDir.getName());
        precompile(appDir, webappOut);
        verify(webappOut);
    }
    @Test
    public void precompileWebapp_2_4() throws IOException {
        File appDir = new File("test/webapp-2.4");
        File webappOut = new File(outputDir, appDir.getName());
        precompile(appDir, webappOut);
        verify(webappOut);
    }
    @Test
    public void precompileWebapp_2_5() throws IOException {
        File appDir = new File("test/webapp-2.5");
        File webappOut = new File(outputDir, appDir.getName());
        precompile(appDir, webappOut);
        verify(webappOut);
    }
    @Test
    public void precompileWebapp_3_0() throws IOException {
        File appDir = new File("test/webapp-3.0");
        File webappOut = new File(outputDir, appDir.getName());
        precompile(appDir, webappOut);
        verify(webappOut);
    }
    @Test
    public void precompileWebapp_3_1() throws IOException {
        File appDir = new File("test/webapp-3.1");
        File webappOut = new File(outputDir, appDir.getName());
        precompile(appDir, webappOut);
        verify(webappOut);
    }
    private void verify(File webappOut) {
        // for now, just check some expected files exist
        Assert.assertTrue(new File(webappOut, "generated_web.xml").exists());
        Assert.assertTrue(new File(webappOut,
                "org/apache/jsp/el_002das_002dliteral_jsp.java").exists());
        Assert.assertTrue(new File(webappOut,
                "org/apache/jsp/tld_002dversions_jsp.java").exists());
    }
    private void precompile(File appDir, File webappOut) throws IOException {
        remove(webappOut);
        webappOut.mkdirs();
        jspc.setUriroot(appDir.toString());
        jspc.setOutputDir(webappOut.toString());
        jspc.setValidateXml(false);
        jspc.setWebXml(new File(webappOut, "generated_web.xml").toString());
        jspc.execute();
    }
    private void remove(File base) throws IOException{
        if (!base.exists()) {
            return;
        }
        Files.walkFileTree(base.toPath(), new SimpleFileVisitor<Path>(){
            @Override
            public FileVisitResult visitFile(Path file,
                    BasicFileAttributes attrs) throws IOException {
                Files.delete(file);
                return FileVisitResult.CONTINUE;
            }
            @Override
            public FileVisitResult postVisitDirectory(Path dir,
                    IOException exc) throws IOException {
                Files.delete(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    }
      <add>
        Create test cases for JspC. Patch by Jeremy Boynes. (markt)
      </add>

======= 186a782:"java/org/apache/jasper/JspC.java"

        tldLocationsCache = TldLocationsCache.getInstance(context);

======= 8d6537d:"java/org/apache/jasper/servlet/JspCServletContext.java"

        // Use this class's classloader as Ant will have set the TCCL to its own
        webXmlParser.setClassLoader(getClass().getClassLoader());
======= 8d6537d:"java/org/apache/tomcat/util/descriptor/web/WebXmlParser.java"

    /**
     * Sets the ClassLoader to be used for creating descriptor objects.
     * @param classLoader the ClassLoader to be used for creating descriptor objects
     */
    public void setClassLoader(ClassLoader classLoader) {
        webDigester.setClassLoader(classLoader);
        webFragmentDigester.setClassLoader(classLoader);
    }

======= 68f6f6f:"java/org/apache/coyote/http11/upgrade/AbstractProcessor.java"

======= 68f6f6f:"java/org/apache/coyote/http11/upgrade/AbstractProcessor.java"

    protected abstract Log getLog();
======= 68f6f6f:"java/org/apache/coyote/http11/upgrade/AbstractProcessor.java"

        } else if (status == SocketStatus.STOP) {
            try {
                upgradeServletInputStream.close();
            } catch (IOException ioe) {
                getLog().debug(sm.getString(
                        "abstractProcessor.isCloseFail", ioe));
            }
            try {
                upgradeServletOutputStream.close();
            } catch (IOException ioe) {
                getLog().debug(sm.getString(
                        "abstractProcessor.osCloseFail", ioe));
            }
            return SocketState.CLOSED;
======= 68f6f6f:"java/org/apache/coyote/http11/upgrade/AprProcessor.java"

    private static final Log log = LogFactory.getLog(AprProcessor.class);
    @Override
    protected Log getLog() {return log;}
======= 68f6f6f:"java/org/apache/coyote/http11/upgrade/BioProcessor.java"

    private static final Log log = LogFactory.getLog(BioProcessor.class);
    @Override
    protected Log getLog() {return log;}
======= 68f6f6f:"java/org/apache/coyote/http11/upgrade/NioProcessor.java"

    private static final Log log = LogFactory.getLog(NioProcessor.class);
    @Override
    protected Log getLog() {return log;}
======= 68f6f6f:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                        // For STOP there is no point trying to handshake as the
                        // Poller has been stopped.
                        if (socket.isHandshakeComplete() ||
                                status == SocketStatus.STOP) {
======= 68f6f6f:"java/org/apache/tomcat/util/net/NioEndpoint.java"


======= 4758796:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

        if (handler != null) {
            clearHandler(new SocketTimeoutException());
        }
======= 4758796:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

        if (sh != null) {
            if (t == null) {
                sh.onResult(new SendResult());
            } else {
                sh.onResult(new SendResult(t));
            }

======= 95ee699:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        // Add date header unless application has already set one (e.g. in a
        // Caching Filter)
        if (headers.getValue("Date") == null) {
            headers.setValue("Date").setString(
                    FastHttpDateFormat.getCurrentDate());
        }

======= 6c54031:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        if (current instanceof Node.JspText) {

======= c8376e8:"java/org/apache/jasper/compiler/JspConfig.java"

        if (ctxt.getEffectiveMajorVersion() < 2) {
        if (ctxt.getEffectiveMajorVersion() == 2) {
            if (ctxt.getEffectiveMinorVersion() < 5) {
            if (ctxt.getEffectiveMinorVersion() < 4) {

======= aa7896b:"java/org/apache/catalina/core/StandardContext.java"

======= aa7896b:"java/org/apache/catalina/core/StandardContext.java"

        return XmlIdentifiers.WEB_22_PUBLIC.equals(publicId);
======= aa7896b:"java/org/apache/tomcat/util/descriptor/web/WebXml.java"

======= aa7896b:"java/org/apache/tomcat/util/descriptor/web/WebXml.java"

        if (version == null) {
            return;
        }
        switch (version) {
            case "2.4":
                majorVersion = 2;
                minorVersion = 4;
                break;
            case "2.5":
                majorVersion = 2;
                minorVersion = 5;
                break;
            case "3.0":
                majorVersion = 3;
                break;
            case "3.1":
                majorVersion = 3;
                minorVersion = 1;
                break;
            default:
                log.warn(sm.getString("webXml.version.unknown", version));
            return;
        }
        switch (publicId) {
            case XmlIdentifiers.WEB_22_PUBLIC:
                majorVersion = 2;
                minorVersion = 2;
                this.publicId = publicId;
                break;
            case XmlIdentifiers.WEB_23_PUBLIC:
                majorVersion = 2;
                minorVersion = 3;
                this.publicId = publicId;
                break;
            default:
                log.warn(sm.getString("webXml.unrecognisedPublicId", publicId));
                break;
======= aa7896b:"java/org/apache/tomcat/util/digester/Digester.java"

======= aa7896b:"java/org/apache/tomcat/util/digester/Digester.java"

======= aa7896b:"java/org/apache/tomcat/util/digester/Digester.java"

======= aa7896b:"java/org/apache/tomcat/util/digester/Digester.java"

        reader.setProperty(
                "http://xml.org/sax/properties/lexical-handler", this);
======= aa7896b:"java/org/apache/tomcat/util/digester/Digester.java"

    public InputSource resolveEntity(String name, String publicId,
            String baseURI, String systemId) throws SAXException, IOException {
            saxLog.debug("resolveEntity('" + publicId + "', '" + systemId +
                    "', '" + baseURI + "')");
======= aa7896b:"java/org/apache/tomcat/util/digester/Digester.java"

                    log.debug(" Trying to resolve using system ID '" +
                            systemId + "'");
                // resolve systemId against baseURI if it is not absolute
                if (baseURI != null) {
                    try {
                        URI uri = new URI(systemId);
                        if (!uri.isAbsolute()) {
                            entityURL = new URI(baseURI).resolve(uri).toString();
                        }
                    } catch (URISyntaxException e) {
                        if (log.isDebugEnabled()) {
                            log.debug("Invalid URI '" + baseURI + "' or '" +
                                    systemId + "'");
                        }
                    }
                }
======= aa7896b:"java/org/apache/tomcat/util/digester/Digester.java"

    // ----------------------------------------------- LexicalHandler Methods
    @Override
    public void startDTD(String name, String publicId, String systemId)
            throws SAXException {
        setPublicId(publicId);
    }
    // ------------------------------------------------- ErrorHandler Methods
======= aa7896b:"java/org/apache/tomcat/util/digester/Digester.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testWebapp() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp/WEB-INF/web.xml"));
        Assert.assertEquals("3.1", desc.getVersion());
    }
    @Test
    public void testWebapp_2_2() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp-2.2/WEB-INF/web.xml"));
        Assert.assertEquals("2.2", desc.getVersion());
        Assert.assertEquals(XmlIdentifiers.WEB_22_PUBLIC, desc.getPublicId());
    }
    @Test
    public void testWebapp_2_3() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp-2.3/WEB-INF/web.xml"));
        Assert.assertEquals("2.3", desc.getVersion());
        Assert.assertEquals(XmlIdentifiers.WEB_23_PUBLIC, desc.getPublicId());
    }
    @Test
    public void testWebapp_2_4() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp-2.4/WEB-INF/web.xml"));
        Assert.assertEquals("2.4", desc.getVersion());
    }
    @Test
    public void testWebapp_2_5() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp-2.5/WEB-INF/web.xml"));
        Assert.assertEquals("2.5", desc.getVersion());
    }
    @Test
    public void testWebapp_3_0() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp-3.0/WEB-INF/web.xml"));
        Assert.assertEquals("3.0", desc.getVersion());
    }
    @Test
    public void testWebapp_3_1() throws Exception {
        Digester digester =
                DigesterFactory.newDigester(true, true, new WebRuleSet(false));
        digester.push(new WebXml());
        WebXml desc = (WebXml) digester.parse(
                new File("test/webapp-3.1/WEB-INF/web.xml"));
        Assert.assertEquals("3.1", desc.getVersion());
    }
======= aa7896b:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

======= aa7896b:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        // unknown input should be ignored
        Assert.assertEquals(2, webxml.getMajorVersion());
        Assert.assertEquals(5, webxml.getMinorVersion());
        Assert.assertEquals(5, webxml.getMinorVersion());
======= aa7896b:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        webxml.setPublicId(XmlIdentifiers.WEB_22_PUBLIC);
======= aa7896b:"test/org/apache/tomcat/util/descriptor/web/TestWebXml.java"

        webxml.setPublicId(XmlIdentifiers.WEB_23_PUBLIC);
    public void testParseVersion24() {
        webxml.setVersion("2.4");
    public void testParseVersion25() {
        webxml.setVersion("2.5");
    public void testParseVersion30() {
        webxml.setVersion("3.0");
    public void testParseVersion31() {
        webxml.setVersion("3.1");

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * A resolver for locally cached XML resources.
 */
    private final Class<?> base;
    private final Map<String,String> publicIds;
    private final Map<String,String> systemIds;
    /**
     * Constructor providing mappings of public and system identifiers to local
     * resources. Each map contains a mapping from a well-known identifier to a
     * resource path that will be further resolved using the base Class using
     * Class#getResource(String).
     *
     * @param base the class to use to locate local copies
     * @param publicIds mapping of public identifiers to local resources
     * @param systemIds mapping of system identifiers to local resources
     */
    public LocalResolver(Class<?> base, Map<String,String> publicIds,
            Map<String,String> systemIds) {
        this.base = base;
        this.publicIds = publicIds;
        this.systemIds = systemIds;
    }
    @Override
    public InputSource resolveEntity(String publicId, String systemId)
            throws SAXException, IOException {
        return resolveEntity(null, publicId, null, systemId);
    }
    @Override
    public InputSource resolveEntity(String name, String publicId,
            String baseURI, String systemId) throws SAXException, IOException {
        String resolved = resolve(publicId, systemId, baseURI);
        if (resolved == null) {
            return null;
        }
        URL url = base.getResource(resolved);
        if (url != null) {
            resolved = url.toExternalForm();
        }
        InputSource is = new InputSource(resolved);
        is.setPublicId(publicId);
        return is;
    }
    @Override
    public InputSource getExternalSubset(String name, String baseURI)
            throws SAXException, IOException {
        return null;
    }
    private String resolve(String publicId, String systemId, String baseURI) {
        // try resolving using the publicId
        String resolved = publicIds.get(publicId);
        if (resolved != null) {
            return resolved;
        }
        // try resolving using the systemId
        if (systemId == null) {
            return null;
        }
        systemId = resolve(baseURI, systemId);
        resolved = systemIds.get(systemId);
        if (resolved != null) {
            return resolved;
        }
        // fall back to the supplied systemId
        return systemId;
    }
    private static String resolve(String baseURI, String systemId) {
        try {
            if (baseURI == null) {
                return systemId;
            }
            URI systemUri = new URI(systemId);
            if (systemUri.isAbsolute()) {
                return systemId;
            }
            return new URI(baseURI).resolve(systemUri).toString();
        } catch (URISyntaxException e) {
            return systemId;
        }
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Defines constants for well-known Public and System identifiers documented by
 * the Servlet and JSP specifications.
 */
    // from W3C
    public static final String XML_2001_XSD = "http://www.w3.org/2001/xml.xsd";
    public static final String DATATYPES_PUBLIC = "datatypes";
    public static final String XSD_10_PUBLIC =
            "-//W3C//DTD XMLSCHEMA 200102//EN";
    // from J2EE 1.2
    public static final String WEB_22_PUBLIC =
            "-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN";
    public static final String WEB_22_SYSTEM =
            "http://java.sun.com/dtd/web-app_2_2.dtd";
    public static final String TLD_11_PUBLIC =
            "-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.1//EN";
    public static final String TLD_11_SYSTEM =
            "http://java.sun.com/dtd/web-jsptaglibrary_1_1.dtd";
    // from J2EE 1.3
    public static final String WEB_23_PUBLIC =
            "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN";
    public static final String WEB_23_SYSTEM =
            "http://java.sun.com/dtd/web-app_2_3.dtd";
    public static final String TLD_12_PUBLIC =
            "-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN";
    public static final String TLD_12_SYSTEM =
            "http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd";
    // from J2EE 1.4
    public static final String WEB_24_XSD =
            "http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd";
    public static final String TLD_20_XSD =
            "http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd";
    public static final String WEBSERVICES_11_XSD =
            "http://www.ibm.com/webservices/xsd/j2ee_web_services_1_1.xsd";
    // from JavaEE 5
    public static final String WEB_25_XSD =
            "http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd";
    public static final String TLD_21_XSD =
            "http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd";
    public static final String WEBSERVICES_12_XSD =
            "http://java.sun.com/xml/ns/javaee/javaee_web_services_1_2.xsd";
    // from JavaEE 6
    public static final String WEB_30_XSD =
            "http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd";
    public static final String WEB_FRAGMENT_30_XSD =
            "http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd";
    public static final String WEBSERVICES_13_XSD =
            "http://java.sun.com/xml/ns/javaee/javaee_web_services_1_3.xsd";
    // from JavaEE 7
    public static final String WEB_31_XSD =
            "http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd";
    public static final String WEB_FRAGMENT_31_XSD =
            "http://xmlns.jcp.org/xml/ns/javaee/web-fragment_3_1.xsd";
    public static final String WEBSERVICES_14_XSD =
            "http://xmlns.jcp.org/xml/ns/javaee/javaee_web_services_1_4.xsd";
    private XmlIdentifiers() {
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private final Map<String, String> publicIds = new HashMap<>();
    private final Map<String, String> systemIds = new HashMap<>();
    private LocalResolver resolver =
            new LocalResolver(ServletContext.class, publicIds, systemIds);
    private String WEB_22_LOCAL;
    private String WEB_31_LOCAL;
    private String WEBCOMMON_31_LOCAL;
    @Before
    public void init() {
        publicIds.put(XmlIdentifiers.WEB_22_PUBLIC,
                "/javax/servlet/resources/web-app_2_2.dtd");
        systemIds.put(XmlIdentifiers.WEB_31_XSD,
                "/javax/servlet/resources/web-app_3_1.xsd");
        WEB_22_LOCAL = getClass().getResource(
                "/javax/servlet/resources/web-app_2_2.dtd").toExternalForm();
        WEB_31_LOCAL = getClass().getResource(
                "/javax/servlet/resources/web-app_3_1.xsd").toExternalForm();
        WEBCOMMON_31_LOCAL = getClass().getResource(
                "/javax/servlet/resources/web-common_3_1.xsd").toExternalForm();
    }
    @Test
    public void unknownNullIdIsNull() throws IOException, SAXException {
        Assert.assertNull(resolver.resolveEntity(null, null));
    }
    @Test
    public void unknownPublicIdIsNull() throws IOException, SAXException {
        Assert.assertNull(resolver.resolveEntity("unknown", null));
    }
    @Test
    public void unknownSystemIdIsReturned() throws IOException, SAXException {
        InputSource source = resolver.resolveEntity(null, "unknown");
        Assert.assertEquals(null, source.getPublicId());
        Assert.assertEquals("unknown", source.getSystemId());
    }
    @Test
    public void unknownSystemIdIsResolvedAgainstBaseURI()
            throws IOException, SAXException {
        InputSource source = resolver.resolveEntity(
                null, null, "http://example.com/home.html", "unknown");
        Assert.assertEquals(null, source.getPublicId());
        Assert.assertEquals("http://example.com/unknown", source.getSystemId());
    }
    @Test
    public void publicIdIsResolved() throws IOException, SAXException {
        InputSource source = resolver.resolveEntity(
                XmlIdentifiers.WEB_22_PUBLIC, XmlIdentifiers.WEB_22_SYSTEM);
        Assert.assertEquals(XmlIdentifiers.WEB_22_PUBLIC, source.getPublicId());
        Assert.assertEquals(WEB_22_LOCAL, source.getSystemId());
    }
    @Test
    public void systemIdIsIgnoredWhenPublicIdIsResolved()
            throws IOException, SAXException {
        InputSource source = resolver.resolveEntity(
                XmlIdentifiers.WEB_22_PUBLIC, "unknown");
        Assert.assertEquals(XmlIdentifiers.WEB_22_PUBLIC, source.getPublicId());
        Assert.assertEquals(WEB_22_LOCAL, source.getSystemId());
    }
    @Test
    public void systemIdIsResolved() throws IOException, SAXException {
        InputSource source =
                resolver.resolveEntity(null, XmlIdentifiers.WEB_31_XSD);
        Assert.assertEquals(null, source.getPublicId());
        Assert.assertEquals(WEB_31_LOCAL, source.getSystemId());
    }
    @Test
    public void relativeSystemIdIsResolvedAgainstBaseURI()
            throws IOException, SAXException {
        InputSource source = resolver.resolveEntity(
                null, null, WEB_31_LOCAL, "web-common_3_1.xsd");
        Assert.assertEquals(null, source.getPublicId());
        Assert.assertEquals(WEBCOMMON_31_LOCAL, source.getSystemId());
    }
    @Test
    public void absoluteSystemIdOverridesBaseURI()
            throws IOException, SAXException {
        InputSource source = resolver.resolveEntity(null, null,
                "http://example.com/home.html", XmlIdentifiers.WEB_31_XSD);
        Assert.assertEquals(null, source.getPublicId());
        Assert.assertEquals(WEB_31_LOCAL, source.getSystemId());
    }

      manifest="${tomcat.manifests}/jsp-api.jar.manifest" />
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
            targetNamespace="http://java.sun.com/xml/ns/j2ee"
            xmlns:j2ee="http://java.sun.com/xml/ns/j2ee"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            version="2.0">
  <xsd:annotation>
    <xsd:documentation>
      @(#)jsp_2_0.xsds  1.17 03/18/03
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      This is the XML Schema for the JSP 2.0 deployment descriptor
      types.  The JSP 2.0 schema contains all the special
      structures and datatypes that are necessary to use JSP files
      from a web application.
      The contents of this schema is used by the web-app_2_4.xsd
      file to define JSP specific content.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      The following conventions apply to all J2EE
      deployment descriptor elements unless indicated otherwise.
      - In elements that specify a pathname to a file within the
        same JAR file, relative filenames (i.e., those not
        starting with "/") are considered relative to the root of
        the JAR file's namespace.  Absolute filenames (i.e., those
        starting with "/") also specify names in the root of the
        JAR file's namespace.  In general, relative names are
        preferred.  The exception is .war files where absolute
        names are preferred for consistency with the Servlet API.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:include schemaLocation="j2ee_1_4.xsd"/>
  <xsd:complexType name="jsp-configType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-configType is used to provide global configuration
        information for the JSP files in a web application. It has
        two subelements, taglib and jsp-property-group.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="taglib"
                   type="j2ee:taglibType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="jsp-property-group"
                   type="j2ee:jsp-property-groupType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="jsp-fileType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-file element contains the full path to a JSP file
        within the web application beginning with a `/'.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:restriction base="j2ee:pathType"/>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="jsp-property-groupType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-property-groupType is used to group a number of
        files so they can be given global property information.
        All files so described are deemed to be JSP files.  The
        following additional properties can be described:
            - Control whether EL is ignored
            - Control whether scripting elements are invalid
            - Indicate pageEncoding information.
            - Indicate that a resource is a JSP document (XML)
            - Prelude and Coda automatic includes.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="j2ee:descriptionGroup"/>
      <xsd:element name="url-pattern"
                   type="j2ee:url-patternType"
                   maxOccurs="unbounded"/>
      <xsd:element name="el-ignored"
                   type="j2ee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Can be used to easily set the isELIgnored
            property of a group of JSP pages.  By default, the
            EL evaluation is enabled for Web Applications using
            a Servlet 2.4 or greater web.xml, and disabled
            otherwise.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="page-encoding"
                   type="j2ee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of page-encoding are those of the
            pageEncoding page directive.  It is a
            translation-time error to name different encodings
            in the pageEncoding attribute of the page directive
            of a JSP page and in a JSP configuration element
            matching the page.  It is also a translation-time
            error to name different encodings in the prolog
            or text declaration of a document in XML syntax and
            in a JSP configuration element matching the document.
            It is legal to name the same encoding through
            mulitple mechanisms.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="scripting-invalid"
                   type="j2ee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Can be used to easily disable scripting in a
            group of JSP pages.  By default, scripting is
            enabled.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="is-xml"
                   type="j2ee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            If true, denotes that the group of resources
            that match the URL pattern are JSP documents,
            and thus must be interpreted as XML documents.
            If false, the resources are assumed to not
            be JSP documents, unless there is another
            property group that indicates otherwise.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="include-prelude"
                   type="j2ee:pathType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The include-prelude element is a context-relative
            path that must correspond to an element in the
            Web Application.  When the element is present,
            the given path will be automatically included (as
            in an include directive) at the beginning of each
            JSP page in this jsp-property-group.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="include-coda"
                   type="j2ee:pathType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The include-coda element is a context-relative
            path that must correspond to an element in the
            Web Application.  When the element is present,
            the given path will be automatically included (as
            in an include directive) at the end of each
            JSP page in this jsp-property-group.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="taglibType">
    <xsd:annotation>
      <xsd:documentation>
        The taglibType defines the syntax for declaring in
        the deployment descriptor that a tag library is
        available to the application.  This can be done
        to override implicit map entries from TLD files and
        from the container.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="taglib-uri"
                   type="j2ee:string">
        <xsd:annotation>
          <xsd:documentation>
            A taglib-uri element describes a URI identifying a
            tag library used in the web application.  The body
            of the taglib-uri element may be either an
            absolute URI specification, or a relative URI.
            There should be no entries in web.xml with the
            same taglib-uri value.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="taglib-location"
                   type="j2ee:pathType">
        <xsd:annotation>
          <xsd:documentation>
            the taglib-location element contains the location
            (as a resource relative to the root of the web
            application) where to find the Tag Library
            Description file for the tag library.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  **  The actual Sun XSD for this stripped down XSD can be found at
  **  http://java.sun.com/xml/ns/javaee/jsp_2_1.xsd
  **  This XSD contains only the functional elements for programatic use.
            targetNamespace="http://java.sun.com/xml/ns/javaee"
            xmlns:javaee="http://java.sun.com/xml/ns/javaee"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            version="2.1">
    <xsd:include schemaLocation="javaee_5.xsd" />
    <xsd:complexType name="jsp-configType">
        <xsd:sequence>
            <xsd:element name="taglib" type="javaee:taglibType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="jsp-property-group" type="javaee:jsp-property-groupType" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="jsp-fileType">
        <xsd:simpleContent>
            <xsd:restriction base="javaee:pathType" />
        </xsd:simpleContent>
    </xsd:complexType>
    <xsd:complexType name="jsp-property-groupType">
        <xsd:sequence>
            <xsd:group ref="javaee:descriptionGroup"/>
            <xsd:element name="url-pattern" type="javaee:url-patternType" maxOccurs="unbounded" />
            <xsd:element name="el-ignored" type="javaee:true-falseType" minOccurs="0" />
            <xsd:element name="page-encoding" type="javaee:string" minOccurs="0" />
            <xsd:element name="scripting-invalid" type="javaee:true-falseType" minOccurs="0" />
            <xsd:element name="is-xml" type="javaee:true-falseType" minOccurs="0" />
            <xsd:element name="include-prelude" type="javaee:pathType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="include-coda" type="javaee:pathType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="deferred-syntax-allowed-as-literal" type="javaee:true-falseType" minOccurs="0" />
            <xsd:element name="trim-directive-whitespaces" type="javaee:true-falseType" minOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="taglibType">
        <xsd:sequence>
            <xsd:element name="taglib-uri" type="javaee:string" />
            <xsd:element name="taglib-location" type="javaee:pathType" />
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
            targetNamespace="http://java.sun.com/xml/ns/javaee"
            xmlns:javaee="http://java.sun.com/xml/ns/javaee"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            version="2.2">
  <xsd:annotation>
    <xsd:documentation>
      $Id$
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
      Copyright 2003-2009 Sun Microsystems, Inc. All rights reserved.
      The contents of this file are subject to the terms of either the
      GNU General Public License Version 2 only ("GPL") or the Common
      Development and Distribution License("CDDL") (collectively, the
      "License").  You may not use this file except in compliance with
      the License. You can obtain a copy of the License at
      https://glassfish.dev.java.net/public/CDDL+GPL.html or
      glassfish/bootstrap/legal/LICENSE.txt.  See the License for the
      specific language governing permissions and limitations under the
      License.
      When distributing the software, include this License Header
      Notice in each file and include the License file at
      glassfish/bootstrap/legal/LICENSE.txt.  Sun designates this
      particular file as subject to the "Classpath" exception as
      provided by Sun in the GPL Version 2 section of the License file
      that accompanied this code.  If applicable, add the following
      below the License Header, with the fields enclosed by brackets []
      replaced by your own identifying information:
      "Portions Copyrighted [year] [name of copyright owner]"
      Contributor(s):
      If you wish your version of this file to be governed by only the
      CDDL or only the GPL Version 2, indicate your decision by adding
      "[Contributor] elects to include this software in this
      distribution under the [CDDL or GPL Version 2] license."  If you
      don't indicate a single choice of license, a recipient has the
      option to distribute your version of this file under either the
      CDDL, the GPL Version 2 or to extend the choice of license to its
      licensees as provided above.  However, if you add GPL Version 2
      code and therefore, elected the GPL Version 2 license, then the
      option applies only if the new code is made subject to such
      option by the copyright holder.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      The Apache Software Foundation elects to include this software under the
      CDDL license.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      This is the XML Schema for the JSP 2.2 deployment descriptor
      types.  The JSP 2.2 schema contains all the special
      structures and datatypes that are necessary to use JSP files
      from a web application.
      The contents of this schema is used by the web-common_3_0.xsd
      file to define JSP specific content.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      The following conventions apply to all Java EE
      deployment descriptor elements unless indicated otherwise.
      - In elements that specify a pathname to a file within the
      same JAR file, relative filenames (i.e., those not
      starting with "/") are considered relative to the root of
      the JAR file's namespace.  Absolute filenames (i.e., those
      starting with "/") also specify names in the root of the
      JAR file's namespace.  In general, relative names are
      preferred.  The exception is .war files where absolute
      names are preferred for consistency with the Servlet API.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:include schemaLocation="javaee_6.xsd"/>
  <xsd:complexType name="jsp-configType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-configType is used to provide global configuration
        information for the JSP files in a web application. It has
        two subelements, taglib and jsp-property-group.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="taglib"
                   type="javaee:taglibType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="jsp-property-group"
                   type="javaee:jsp-property-groupType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
    </xsd:sequence>
    <xsd:attribute name="id"
                   type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="jsp-fileType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-file element contains the full path to a JSP file
        within the web application beginning with a `/'.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:restriction base="javaee:pathType"/>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="jsp-property-groupType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-property-groupType is used to group a number of
        files so they can be given global property information.
        All files so described are deemed to be JSP files.  The
        following additional properties can be described:
        - Control whether EL is ignored.
        - Control whether scripting elements are invalid.
        - Indicate pageEncoding information.
        - Indicate that a resource is a JSP document (XML).
        - Prelude and Coda automatic includes.
        - Control whether the character sequence #{ is allowed
        when used as a String literal.
        - Control whether template text containing only
        whitespaces must be removed from the response output.
        - Indicate the default contentType information.
        - Indicate the default buffering model for JspWriter
        - Control whether error should be raised for the use of
        undeclared namespaces in a JSP page.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="javaee:descriptionGroup"/>
      <xsd:element name="url-pattern"
                   type="javaee:url-patternType"
                   maxOccurs="unbounded"/>
      <xsd:element name="el-ignored"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Can be used to easily set the isELIgnored
            property of a group of JSP pages.  By default, the
            EL evaluation is enabled for Web Applications using
            a Servlet 2.4 or greater web.xml, and disabled
            otherwise.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="page-encoding"
                   type="javaee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of page-encoding are those of the
            pageEncoding page directive.  It is a
            translation-time error to name different encodings
            in the pageEncoding attribute of the page directive
            of a JSP page and in a JSP configuration element
            matching the page.  It is also a translation-time
            error to name different encodings in the prolog
            or text declaration of a document in XML syntax and
            in a JSP configuration element matching the document.
            It is legal to name the same encoding through
            mulitple mechanisms.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="scripting-invalid"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Can be used to easily disable scripting in a
            group of JSP pages.  By default, scripting is
            enabled.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="is-xml"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            If true, denotes that the group of resources
            that match the URL pattern are JSP documents,
            and thus must be interpreted as XML documents.
            If false, the resources are assumed to not
            be JSP documents, unless there is another
            property group that indicates otherwise.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="include-prelude"
                   type="javaee:pathType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The include-prelude element is a context-relative
            path that must correspond to an element in the
            Web Application.  When the element is present,
            the given path will be automatically included (as
            in an include directive) at the beginning of each
            JSP page in this jsp-property-group.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="include-coda"
                   type="javaee:pathType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The include-coda element is a context-relative
            path that must correspond to an element in the
            Web Application.  When the element is present,
            the given path will be automatically included (as
            in an include directive) at the end of each
            JSP page in this jsp-property-group.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="deferred-syntax-allowed-as-literal"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The character sequence #{ is reserved for EL expressions.
            Consequently, a translation error occurs if the #{
            character sequence is used as a String literal, unless
            this element is enabled (true). Disabled (false) by
            default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="trim-directive-whitespaces"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Indicates that template text containing only whitespaces
            must be removed from the response output. It has no
            effect on JSP documents (XML syntax). Disabled (false)
            by default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="default-content-type"
                   type="javaee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of default-content-type are those of the
            contentType page directive.  It specifies the default
            response contentType if the page directive does not include
            a contentType attribute.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="buffer"
                   type="javaee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of buffer are those of the
            buffer page directive.  It specifies if buffering should be
            used for the output to response, and if so, the size of the
            buffer to use.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="error-on-undeclared-namespace"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The default behavior when a tag with unknown namespace is used
            in a JSP page (regular syntax) is to silently ignore it.  If
            set to true, then an error must be raised during the translation
            time when an undeclared tag is used in a JSP page.  Disabled
            (false) by default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id"
                   type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="taglibType">
    <xsd:annotation>
      <xsd:documentation>
        The taglibType defines the syntax for declaring in
        the deployment descriptor that a tag library is
        available to the application.  This can be done
        to override implicit map entries from TLD files and
        from the container.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="taglib-uri"
                   type="javaee:string">
        <xsd:annotation>
          <xsd:documentation>
            A taglib-uri element describes a URI identifying a
            tag library used in the web application.  The body
            of the taglib-uri element may be either an
            absolute URI specification, or a relative URI.
            There should be no entries in web.xml with the
            same taglib-uri value.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="taglib-location"
                   type="javaee:pathType">
        <xsd:annotation>
          <xsd:documentation>
            the taglib-location element contains the location
            (as a resource relative to the root of the web
            application) where to find the Tag Library
            Description file for the tag library.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id"
                   type="xsd:ID"/>
  </xsd:complexType>
            targetNamespace="http://xmlns.jcp.org/xml/ns/javaee"
            xmlns:javaee="http://xmlns.jcp.org/xml/ns/javaee"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            version="2.3">
  <xsd:annotation>
    <xsd:documentation>
      DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
      Copyright (c) 2009-2013 Oracle and/or its affiliates. All rights reserved.
      The contents of this file are subject to the terms of either the GNU
      General Public License Version 2 only ("GPL") or the Common Development
      and Distribution License("CDDL") (collectively, the "License").  You
      may not use this file except in compliance with the License.  You can
      obtain a copy of the License at
      https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
      or packager/legal/LICENSE.txt.  See the License for the specific
      language governing permissions and limitations under the License.
      When distributing the software, include this License Header Notice in each
      file and include the License file at packager/legal/LICENSE.txt.
      GPL Classpath Exception:
      Oracle designates this particular file as subject to the "Classpath"
      exception as provided by Oracle in the GPL Version 2 section of the License
      file that accompanied this code.
      Modifications:
      If applicable, add the following below the License Header, with the fields
      enclosed by brackets [] replaced by your own identifying information:
      "Portions Copyright [year] [name of copyright owner]"
      Contributor(s):
      If you wish your version of this file to be governed by only the CDDL or
      only the GPL Version 2, indicate your decision by adding "[Contributor]
      elects to include this software in this distribution under the [CDDL or GPL
      Version 2] license."  If you don't indicate a single choice of license, a
      recipient has the option to distribute your version of this file under
      either the CDDL, the GPL Version 2 or to extend the choice of license to
      its licensees as provided above.  However, if you add GPL Version 2 code
      and therefore, elected the GPL Version 2 license, then the option applies
      only if the new code is made subject to such option by the copyright
      holder.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      The Apache Software Foundation elects to include this software under the
      CDDL license.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      This is the XML Schema for the JSP 2.3 deployment descriptor
      types.  The JSP 2.3 schema contains all the special
      structures and datatypes that are necessary to use JSP files
      from a web application.
      The contents of this schema is used by the web-common_3_1.xsd
      file to define JSP specific content.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      The following conventions apply to all Java EE
      deployment descriptor elements unless indicated otherwise.
      - In elements that specify a pathname to a file within the
      same JAR file, relative filenames (i.e., those not
      starting with "/") are considered relative to the root of
      the JAR file's namespace.  Absolute filenames (i.e., those
      starting with "/") also specify names in the root of the
      JAR file's namespace.  In general, relative names are
      preferred.  The exception is .war files where absolute
      names are preferred for consistency with the Servlet API.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:include schemaLocation="javaee_7.xsd"/>
  <xsd:complexType name="jsp-configType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-configType is used to provide global configuration
        information for the JSP files in a web application. It has
        two subelements, taglib and jsp-property-group.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="taglib"
                   type="javaee:taglibType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="jsp-property-group"
                   type="javaee:jsp-property-groupType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
    </xsd:sequence>
    <xsd:attribute name="id"
                   type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="jsp-fileType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-file element contains the full path to a JSP file
        within the web application beginning with a `/'.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:restriction base="javaee:pathType"/>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="jsp-property-groupType">
    <xsd:annotation>
      <xsd:documentation>
        The jsp-property-groupType is used to group a number of
        files so they can be given global property information.
        All files so described are deemed to be JSP files.  The
        following additional properties can be described:
        - Control whether EL is ignored.
        - Control whether scripting elements are invalid.
        - Indicate pageEncoding information.
        - Indicate that a resource is a JSP document (XML).
        - Prelude and Coda automatic includes.
        - Control whether the character sequence #{ is allowed
        when used as a String literal.
        - Control whether template text containing only
        whitespaces must be removed from the response output.
        - Indicate the default contentType information.
        - Indicate the default buffering model for JspWriter
        - Control whether error should be raised for the use of
        undeclared namespaces in a JSP page.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="javaee:descriptionGroup"/>
      <xsd:element name="url-pattern"
                   type="javaee:url-patternType"
                   maxOccurs="unbounded"/>
      <xsd:element name="el-ignored"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Can be used to easily set the isELIgnored
            property of a group of JSP pages.  By default, the
            EL evaluation is enabled for Web Applications using
            a Servlet 2.4 or greater web.xml, and disabled
            otherwise.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="page-encoding"
                   type="javaee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of page-encoding are those of the
            pageEncoding page directive.  It is a
            translation-time error to name different encodings
            in the pageEncoding attribute of the page directive
            of a JSP page and in a JSP configuration element
            matching the page.  It is also a translation-time
            error to name different encodings in the prolog
            or text declaration of a document in XML syntax and
            in a JSP configuration element matching the document.
            It is legal to name the same encoding through
            mulitple mechanisms.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="scripting-invalid"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Can be used to easily disable scripting in a
            group of JSP pages.  By default, scripting is
            enabled.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="is-xml"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            If true, denotes that the group of resources
            that match the URL pattern are JSP documents,
            and thus must be interpreted as XML documents.
            If false, the resources are assumed to not
            be JSP documents, unless there is another
            property group that indicates otherwise.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="include-prelude"
                   type="javaee:pathType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The include-prelude element is a context-relative
            path that must correspond to an element in the
            Web Application.  When the element is present,
            the given path will be automatically included (as
            in an include directive) at the beginning of each
            JSP page in this jsp-property-group.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="include-coda"
                   type="javaee:pathType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The include-coda element is a context-relative
            path that must correspond to an element in the
            Web Application.  When the element is present,
            the given path will be automatically included (as
            in an include directive) at the end of each
            JSP page in this jsp-property-group.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="deferred-syntax-allowed-as-literal"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The character sequence #{ is reserved for EL expressions.
            Consequently, a translation error occurs if the #{
            character sequence is used as a String literal, unless
            this element is enabled (true). Disabled (false) by
            default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="trim-directive-whitespaces"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Indicates that template text containing only whitespaces
            must be removed from the response output. It has no
            effect on JSP documents (XML syntax). Disabled (false)
            by default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="default-content-type"
                   type="javaee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of default-content-type are those of the
            contentType page directive.  It specifies the default
            response contentType if the page directive does not include
            a contentType attribute.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="buffer"
                   type="javaee:string"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The valid values of buffer are those of the
            buffer page directive.  It specifies if buffering should be
            used for the output to response, and if so, the size of the
            buffer to use.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="error-on-undeclared-namespace"
                   type="javaee:true-falseType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The default behavior when a tag with unknown namespace is used
            in a JSP page (regular syntax) is to silently ignore it.  If
            set to true, then an error must be raised during the translation
            time when an undeclared tag is used in a JSP page.  Disabled
            (false) by default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id"
                   type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="taglibType">
    <xsd:annotation>
      <xsd:documentation>
        The taglibType defines the syntax for declaring in
        the deployment descriptor that a tag library is
        available to the application.  This can be done
        to override implicit map entries from TLD files and
        from the container.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="taglib-uri"
                   type="javaee:string">
        <xsd:annotation>
          <xsd:documentation>
            A taglib-uri element describes a URI identifying a
            tag library used in the web application.  The body
            of the taglib-uri element may be either an
            absolute URI specification, or a relative URI.
            There should be no entries in web.xml with the
            same taglib-uri value.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="taglib-location"
                   type="javaee:pathType">
        <xsd:annotation>
          <xsd:documentation>
            the taglib-location element contains the location
            (as a resource relative to the root of the web
            application) where to find the Tag Library
            Description file for the tag library.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id"
                   type="xsd:ID"/>
  </xsd:complexType>
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
   This is the DTD defining the JavaServer Pages 1.1 Tag Library
   descriptor (.tld) (XML) file format/syntax.
   A Tag Library is a JAR file containing a valid instance of a Tag Library
   Descriptor (taglib.tld) file in the META-INF subdirectory, along with the
   appropriate implementing classes, and other resources required to
   implement the tags defined therein.
   Use is subject to license terms.
  -->
            a JSP authoring tool to create names with a mnemonic
            value; for example, the it may be used as the prefered
            prefix value in taglib directives
            should be user discernable
          xmlns CDATA #FIXED
                "http://java.sun.com/j2ee/dtds/web-jsptaglibrary_1_1.dtd"
                implementation itself, and is most likely in a
                different "langage", e.g embedded SQL statements.
  by a scriptlet expression (optional)
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
   This is the DTD defining the JavaServer Pages 1.2 Tag Library
   descriptor (.tld) (XML) file format/syntax.
   A Tag Library is a JAR file containing a valid instance of a Tag Library
   Descriptor (taglib.tld) file in the META-INF subdirectory, along with the
   appropriate implementing classes, and other resources required to
   implement the tags defined therein.
   Use is subject to license terms.
  -->
          "-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN">
  <!DOCTYPE taglib
        PUBLIC "-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN"
        "http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd">
                a JSP authoring tool to create names with a mnemonic
                value; for example, the it may be used as the prefered
                prefix value in taglib directives
                is intended to be displayed by tools
                should be user discernable
                  display-name?, small-icon?, large-icon?, description?,
                  validator?, listener*, tag+) >
        xmlns CDATA #FIXED
        "http://java.sun.com/JSP/TagLibraryDescriptor"
                  javax.servlet.jsp.tagext.Tag
                  javax.servlet.jsp.tagext.TagExtraInfo
                  by tools
                  use of this tag
               small-icon?, large-icon?, description?, variable*, attribute*,
               example?) >
                implementation itself, and is most likely in a
                different "langage", e.g embedded SQL statements.
                         time) value will give the name of the
                         variable.  One of name-given or
                         name-from-attribute is required.
                         java.lang.String is default.
                         True is the default.
                         defined.  NESTED is default.
                    declare?, scope?, description?) >
  by a scriptlet expression (optional)
  by a scriptlet expression (optional)
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
     targetNamespace="http://java.sun.com/xml/ns/j2ee"
     xmlns:j2ee="http://java.sun.com/xml/ns/j2ee"
     xmlns:xsd="http://www.w3.org/2001/XMLSchema"
     xmlns:xml="http://www.w3.org/XML/1998/namespace"
     elementFormDefault="qualified"
     attributeFormDefault="unqualified"
     version="2.0">
  <xsd:annotation>
    <xsd:documentation>
      %W% %G%
    </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:documentation>
      <![CDATA[
        This is the XML Schema for the JSP Taglibrary
        descriptor.  All Taglibrary descriptors must
        indicate the tag library schema by using the Taglibrary
        namespace:
        http://java.sun.com/xml/ns/j2ee
        and by indicating the version of the schema by
        using the version element as shown below:
            <taglib xmlns="http://java.sun.com/xml/ns/j2ee"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="..."
              version="2.0">
              ...
            </taglib>
        The instance documents may indicate the published
        version of the schema using xsi:schemaLocation attribute
        for J2EE namespace with the following location:
        http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd
        ]]>
    </xsd:documentation>
  </xsd:annotation>
  <xsd:include schemaLocation="j2ee_1_4.xsd"/>
  <xsd:element name="taglib" type="j2ee:tldTaglibType">
    <xsd:annotation>
      <xsd:documentation>
        The taglib tag is the document root.
        The definition of taglib is provided
        by the tldTaglibType.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:unique name="tag-name-uniqueness">
      <xsd:annotation>
        <xsd:documentation>
          The taglib element contains, among other things, tag and
          tag-file elements.
          The name subelements of these elements must each be unique.
        </xsd:documentation>
      </xsd:annotation>
      <xsd:selector xpath="j2ee:tag|j2ee:tag-file"/>
      <xsd:field    xpath="j2ee:name"/>
    </xsd:unique>
    <xsd:unique name="function-name-uniqueness">
      <xsd:annotation>
        <xsd:documentation>
          The taglib element contains function elements.
          The name subelements of these elements must each be unique.
        </xsd:documentation>
      </xsd:annotation>
      <xsd:selector xpath="j2ee:function"/>
      <xsd:field    xpath="j2ee:name"/>
    </xsd:unique>
  </xsd:element>
  <xsd:complexType name="body-contentType">
    <xsd:annotation>
      <xsd:documentation>
        Specifies the type of body that is valid for a tag.
        This value is used by the JSP container to validate
        that a tag invocation has the correct body syntax and
        by page composition tools to assist the page author
        in providing a valid tag body.
        There are currently four values specified:
        tagdependent    The body of the tag is interpreted by the tag
                        implementation itself, and is most likely
                        in a different "language", e.g embedded SQL
                        statements.
        JSP             The body of the tag contains nested JSP
                        syntax.
        empty           The body must be empty
        scriptless      The body accepts only template text, EL
                        Expressions, and JSP action elements.  No
                        scripting elements are allowed.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:restriction base="j2ee:string">
        <xsd:enumeration value="tagdependent"/>
        <xsd:enumeration value="JSP"/>
        <xsd:enumeration value="empty"/>
        <xsd:enumeration value="scriptless"/>
      </xsd:restriction>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="extensibleType" abstract="true">
    <xsd:annotation>
      <xsd:documentation>
        The extensibleType is an abstract base type that is used to
        define the type of extension-elements. Instance documents
        must substitute a known type to define the extension by
        using xsi:type attribute to define the actual type of
        extension-elements.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="functionType">
    <xsd:annotation>
      <xsd:documentation>
        The function element is used to provide information on each
        function in the tag library that is to be exposed to the EL.
        The function element may have several subelements defining:
        description         Optional tag-specific information
        display-name        A short name that is intended to be
                            displayed by tools
        icon                Optional icon element that can be used
                            by tools
        name                A unique name for this function
        function-class      Provides the name of the Java class that
                            implements the function
        function-signature  Provides the signature, as in the Java
                            Language Specification, of the Java
                            method that is to be used to implement
                            the function.
        example             Optional informal description of an
                            example of a use of this function
        function-extension  Zero or more extensions that provide extra
                            information about this function, for tool
                            consumption
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="j2ee:descriptionGroup"/>
      <xsd:element name="name"
                   type="j2ee:tld-canonical-nameType">
        <xsd:annotation>
          <xsd:documentation>
            A unique name for this function.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="function-class"
                   type="j2ee:fully-qualified-classType">
        <xsd:annotation>
          <xsd:documentation>
            Provides the fully-qualified class name of the Java
            class containing the static method that implements
            the function.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="function-signature"
                   type="j2ee:string">
        <xsd:annotation>
          <xsd:documentation>
            Provides the signature, of the static Java method that is
            to be used to implement the function.  The syntax of the
            function-signature element is as follows:
                FunctionSignature ::= ReturnType S MethodName S?
                                      '(' S? Parameters? S? ')'
                ReturnType        ::= Type
                MethodName        ::= Identifier
                Parameters        ::=   Parameter
                                      | ( Parameter S? ',' S? Parameters )
                Parameter         ::= Type
                Where:
                     * Type is a basic type or a fully qualified Java class name
                      (including package name), as per the 'Type' production
                      in the Java Language Specification, Second Edition,
                      Chapter 18.
                    * Identifier is a Java identifier, as per the 'Identifier'
                      production in the Java Language Specification, Second
                      Edition, Chapter 18.
            Example:
            java.lang.String nickName( java.lang.String, int )
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="example"
                   type="j2ee:xsdStringType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The example element contains an informal description
            of an example of the use of this function.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="function-extension"
                   type="j2ee:tld-extensionType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            Function extensions are for tool use only and must not affect
            the behavior of a container.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="tagFileType">
    <xsd:annotation>
      <xsd:documentation>
        Defines an action in this tag library that is implemented
        as a .tag file.
        The tag-file element has two required subelements:
        description       Optional tag-specific information
        display-name      A short name that is intended to be
                          displayed by tools
        icon              Optional icon element that can be used
                          by tools
        name              The unique action name
        path              Where to find the .tag file implementing this
                          action, relative to the root of the web
                          application or the root of the JAR file for a
                          tag library packaged in a JAR.  This must
                          begin with /WEB-INF/tags if the .tag file
                          resides in the WAR, or /META-INF/tags if the
                          .tag file resides in a JAR.
        example           Optional informal description of an
                          example of a use of this tag
        tag-extension     Zero or more extensions that provide extra
                          information about this tag, for tool
                          consumption
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="j2ee:descriptionGroup"/>
      <xsd:element name="name"
                   type="j2ee:tld-canonical-nameType"/>
      <xsd:element name="path"
                   type="j2ee:pathType"/>
      <xsd:element name="example"
                   type="j2ee:xsdStringType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The example element contains an informal description
            of an example of the use of a tag.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="tag-extension"
                   type="j2ee:tld-extensionType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            Tag extensions are for tool use only and must not affect
            the behavior of a container.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="tagType">
    <xsd:annotation>
      <xsd:documentation>
        The tag defines a unique tag in this tag library.  It has one
        attribute, id.
        The tag element may have several subelements defining:
        description       Optional tag-specific information
        display-name      A short name that is intended to be
                          displayed by tools
        icon              Optional icon element that can be used
                          by tools
        name              The unique action name
        tag-class         The tag handler class implementing
                          javax.servlet.jsp.tagext.JspTag
        tei-class         An optional subclass of
                          javax.servlet.jsp.tagext.TagExtraInfo
        body-content      The body content type
        variable          Optional scripting variable information
        attribute         All attributes of this action that are
                          evaluated prior to invocation.
        dynamic-attributes Whether this tag supports additional
                           attributes with dynamic names.  If
                           true, the tag-class must implement the
                           javax.servlet.jsp.tagext.DynamicAttributes
                           interface.  Defaults to false.
        example           Optional informal description of an
                          example of a use of this tag
        tag-extension     Zero or more extensions that provide extra
                          information about this tag, for tool
                          consumption
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="j2ee:descriptionGroup"/>
      <xsd:element name="name"
                   type="j2ee:tld-canonical-nameType"/>
      <xsd:element name="tag-class"
                   type="j2ee:fully-qualified-classType">
        <xsd:annotation>
          <xsd:documentation>
            Defines the subclass of javax.serlvet.jsp.tagext.JspTag
            that implements the request time semantics for
            this tag. (required)
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="tei-class"
                   type="j2ee:fully-qualified-classType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Defines the subclass of javax.servlet.jsp.tagext.TagExtraInfo
            for this tag. (optional)
            If this is not given, the class is not consulted at
            translation time.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="body-content"
                   type="j2ee:body-contentType">
        <xsd:annotation>
          <xsd:documentation>
            Specifies the format for the body of this tag.
            The default in JSP 1.2 was "JSP" but because this
            is an invalid setting for simple tag handlers, there
            is no longer a default in JSP 2.0.  A reasonable
            default for simple tag handlers is "scriptless" if
            the tag can have a body.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="variable"
                   type="j2ee:variableType"
                   minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="attribute"
                   type="j2ee:tld-attributeType"
                   minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="dynamic-attributes"
                   type="j2ee:generic-booleanType"
                   minOccurs="0"/>
      <xsd:element name="example"
                   type="j2ee:xsdStringType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The example element contains an informal description
            of an example of the use of a tag.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="tag-extension"
                   type="j2ee:tld-extensionType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            Tag extensions are for tool use only and must not affect
            the behavior of a container.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="tld-attributeType">
    <xsd:annotation>
      <xsd:documentation>
        The attribute element defines an attribute for the nesting
        tag.  The attributre element may have several subelements
        defining:
        description     a description of the attribute
        name            the name of the attribute
        required        whether the attribute is required or
                        optional
        rtexprvalue     whether the attribute is a runtime attribute
        type            the type of the attributes
        fragment        whether this attribute is a fragment
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="description"
                   type="j2ee:descriptionType"
                   minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="name"
                   type="j2ee:java-identifierType"/>
      <xsd:element name="required"
                   type="j2ee:generic-booleanType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Defines if the nesting attribute is required or
            optional.
            If not present then the default is "false", i.e
            the attribute is optional.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:choice>
        <xsd:sequence>
          <xsd:element name="rtexprvalue"
                       type="j2ee:generic-booleanType"
                       minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>
                Defines if the nesting attribute can have scriptlet
                expressions as a value, i.e the value of the
                attribute may be dynamically calculated at request
                time, as opposed to a static value determined at
                translation time.
                If not present then the default is "false", i.e the
                attribute has a static value
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="type"
                       type="j2ee:fully-qualified-classType"
                       minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>
                Defines the Java type of the attributes value.  For
                static values (those determined at translation time)
                the type is always java.lang.String.
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:element name="fragment"
                     type="j2ee:generic-booleanType"
                     minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>
              "true" if this attribute is of type
              javax.jsp.tagext.JspFragment, representing dynamic
              content that can be re-evaluated as many times
              as needed by the tag handler.  If omitted or "false",
              the default is still type="java.lang.String"
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="tld-canonical-nameType">
    <xsd:annotation>
      <xsd:documentation>
        Defines the canonical name of a tag or attribute being
        defined.
        The name must conform to the lexical rules for an NMTOKEN.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:restriction base="j2ee:xsdNMTOKENType"/>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="tld-extensionType">
    <xsd:annotation>
      <xsd:documentation>
        The tld-extensionType is used to indicate
        extensions to a specific TLD element.
        It is used by elements to designate an extension block
        that is targeted to a specific extension designated by
        a set of extension elements that are declared by a
        namespace. The namespace identifies the extension to
        the tool that processes the extension.
        The type of the extension-element is abstract. Therefore,
        a concrete type must be specified by the TLD using
        xsi:type attribute for each extension-element.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="extension-element"
                   type="j2ee:extensibleType"
                   maxOccurs="unbounded"/>
    </xsd:sequence>
    <xsd:attribute name="namespace"
                   use="required"
                   type="xsd:anyURI"/>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="tldTaglibType">
    <xsd:annotation>
      <xsd:documentation>
        The taglib tag is the document root, it defines:
        description     a simple string describing the "use" of this taglib,
                        should be user discernable
        display-name    the display-name element contains a
                        short name that is intended to be displayed
                        by tools
        icon            optional icon that can be used by tools
        tlib-version    the version of the tag library implementation
        short-name      a simple default short name that could be
                        used by a JSP authoring tool to create
                        names with a mnemonic value; for example,
                        the it may be used as the prefered prefix
                        value in taglib directives
        uri             a uri uniquely identifying this taglib
        validator       optional TagLibraryValidator information
        listener        optional event listener specification
        tag             tags in this tag library
        tag-file        tag files in this tag library
        function        zero or more EL functions defined in this
                        tag library
        taglib-extension zero or more extensions that provide extra
                        information about this taglib, for tool
                        consumption
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="j2ee:descriptionGroup"/>
      <xsd:element name="tlib-version"
                   type="j2ee:dewey-versionType">
        <xsd:annotation>
          <xsd:documentation>
            Describes this version (number) of the taglibrary.
            It is described as a dewey decimal.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="short-name"
                   type="j2ee:tld-canonical-nameType">
        <xsd:annotation>
          <xsd:documentation>
            Defines a simple default name that could be used by
            a JSP authoring tool to create names with a
            mnemonicvalue; for example, it may be used as the
            preferred prefix value in taglib directives.  Do
            not use white space, and do not start with digits
            or underscore.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="uri"
                   type="j2ee:xsdAnyURIType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Defines a public URI that uniquely identifies this
            version of the taglibrary.  Leave it empty if it
            does not apply.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="validator"
                   type="j2ee:validatorType"
                   minOccurs="0">
      </xsd:element>
      <xsd:element name="listener"
                   type="j2ee:listenerType"
                   minOccurs="0" maxOccurs="unbounded">
      </xsd:element>
      <xsd:element name="tag"
                   type="j2ee:tagType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="tag-file"
                   type="j2ee:tagFileType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="function"
                   type="j2ee:functionType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="taglib-extension"
                   type="j2ee:tld-extensionType"
                   minOccurs="0"
                   maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            Taglib extensions are for tool use only and must not affect
            the behavior of a container.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="version"
                   type="j2ee:dewey-versionType"
                   fixed="2.0"
                   use="required">
      <xsd:annotation>
        <xsd:documentation>
          Describes the JSP version (number) this taglibrary
          requires in order to function (dewey decimal)
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="validatorType">
    <xsd:annotation>
      <xsd:documentation>
        A validator that can be used to validate
        the conformance of a JSP page to using this tag library is
        defined by a validatorType.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="description"
                   type="j2ee:descriptionType"
                   minOccurs="0"
                   maxOccurs="unbounded"/>
      <xsd:element name="validator-class"
                   type="j2ee:fully-qualified-classType">
        <xsd:annotation>
          <xsd:documentation>
            Defines the TagLibraryValidator class that can be used
            to validate the conformance of a JSP page to using this
            tag library.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="init-param"
                   type="j2ee:param-valueType"
                   minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            The init-param element contains a name/value pair as an
            initialization param.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  <xsd:complexType name="variable-scopeType">
    <xsd:annotation>
      <xsd:documentation>
        This type defines scope of the scripting variable.  See
        TagExtraInfo for details.  The allowed values are,
        "NESTED", "AT_BEGIN" and "AT_END".
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:restriction base="j2ee:string">
        <xsd:enumeration value="NESTED"/>
        <xsd:enumeration value="AT_BEGIN"/>
        <xsd:enumeration value="AT_END"/>
      </xsd:restriction>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="variableType">
    <xsd:annotation>
      <xsd:documentation>
        The variableType provides information on the scripting
        variables defined by using this tag.  It is a (translation
        time) error for a tag that has one or more variable
        subelements to have a TagExtraInfo class that returns a
        non-null value from a call to getVariableInfo().
        The subelements of variableType are of the form:
        description              Optional description of this
                                 variable
        name-given               The variable name as a constant
        name-from-attribute      The name of an attribute whose
                                 (translation time) value will
                                 give the name of the
                                 variable.  One of name-given or
                                 name-from-attribute is required.
        variable-class           Name of the class of the variable.
                                 java.lang.String is default.
        declare                  Whether the variable is declared
                                 or not.  True is the default.
        scope                    The scope of the scripting varaible
                                 defined.  NESTED is default.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="description"
                   type="j2ee:descriptionType"
                   minOccurs="0" maxOccurs="unbounded"/>
      <xsd:choice>
        <xsd:element name="name-given"
                     type="j2ee:java-identifierType">
          <xsd:annotation>
            <xsd:documentation>
              The name for the scripting variable.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="name-from-attribute"
                     type="j2ee:java-identifierType">
          <xsd:annotation>
            <xsd:documentation>
              The name of an attribute whose
              (translation-time) value will give the name of
              the variable.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:choice>
      <xsd:element name="variable-class"
                   type="j2ee:fully-qualified-classType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The optional name of the class for the scripting
            variable.  The default is java.lang.String.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="declare"
                   type="j2ee:generic-booleanType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Whether the scripting variable is to be defined
            or not.  See TagExtraInfo for details.  This
            element is optional and "true" is the default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="scope"
                   type="j2ee:variable-scopeType"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            The element is optional and "NESTED" is the default.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:ID"/>
  </xsd:complexType>
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  ** This XSD contains only the programatic elements required for an implementation.
  ** For the XSD from Sun that includes documentation and other copyrighted information
  ** please refer to http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd for a fully documented and latest
  **  XSD.
            xmlns:javaee="http://java.sun.com/xml/ns/javaee"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            version="2.1">
    <xsd:include schemaLocation="javaee_5.xsd" />
    <xsd:element name="taglib" type="javaee:tldTaglibType">
        <xsd:unique name="tag-name-uniqueness">
            <xsd:selector xpath="javaee:tag|javaee:tag-file" />
            <xsd:field xpath="javaee:name" />
        </xsd:unique>
        <xsd:unique name="function-name-uniqueness">
            <xsd:selector xpath="javaee:function" />
            <xsd:field xpath="javaee:name" />
        </xsd:unique>
    </xsd:element>
    <xsd:complexType name="body-contentType">
        <xsd:simpleContent>
            <xsd:restriction base="javaee:string">
                <xsd:enumeration value="tagdependent" />
                <xsd:enumeration value="JSP" />
                <xsd:enumeration value="empty" />
                <xsd:enumeration value="scriptless" />
            </xsd:restriction>
        </xsd:simpleContent>
    </xsd:complexType>
    <xsd:complexType name="extensibleType" abstract="true">
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="functionType">
        <xsd:sequence>
            <xsd:group ref="javaee:descriptionGroup" />
            <xsd:element name="name" type="javaee:tld-canonical-nameType"></xsd:element>
            <xsd:element name="function-class" type="javaee:fully-qualified-classType"></xsd:element>
            <xsd:element name="function-signature" type="javaee:string"></xsd:element>
            <xsd:element name="example" type="javaee:xsdStringType" minOccurs="0"></xsd:element>
            <xsd:element name="function-extension" type="javaee:tld-extensionType" minOccurs="0" maxOccurs="unbounded"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tagFileType">
        <xsd:sequence>
            <xsd:group ref="javaee:descriptionGroup" />
            <xsd:element name="name" type="javaee:tld-canonical-nameType" />
            <xsd:element name="path" type="javaee:pathType" />
            <xsd:element name="example" type="javaee:xsdStringType" minOccurs="0"></xsd:element>
            <xsd:element name="tag-extension" type="javaee:tld-extensionType" minOccurs="0" maxOccurs="unbounded"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tagType">
        <xsd:sequence>
            <xsd:group ref="javaee:descriptionGroup" />
            <xsd:element name="name" type="javaee:tld-canonical-nameType" />
            <xsd:element name="tag-class" type="javaee:fully-qualified-classType"></xsd:element>
            <xsd:element name="tei-class" type="javaee:fully-qualified-classType" minOccurs="0"></xsd:element>
            <xsd:element name="body-content" type="javaee:body-contentType"></xsd:element>
            <xsd:element name="variable" type="javaee:variableType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="attribute" type="javaee:tld-attributeType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="dynamic-attributes" type="javaee:generic-booleanType" minOccurs="0" />
            <xsd:element name="example" type="javaee:xsdStringType" minOccurs="0" />
            <xsd:element name="tag-extension" type="javaee:tld-extensionType" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tld-attributeType">
        <xsd:sequence>
            <xsd:element name="description" type="javaee:descriptionType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="name" type="javaee:java-identifierType" />
            <xsd:element name="required" type="javaee:generic-booleanType" minOccurs="0"></xsd:element>
            <xsd:choice>
                <xsd:sequence>
                    <xsd:sequence minOccurs="0">
                        <xsd:element name="rtexprvalue" type="javaee:generic-booleanType"></xsd:element>
                        <xsd:element name="type" type="javaee:fully-qualified-classType" minOccurs="0"></xsd:element>
                    </xsd:sequence>
                    <xsd:choice>
                        <xsd:element name="deferred-value" type="javaee:tld-deferred-valueType" minOccurs="0"></xsd:element>
                        <xsd:element name="deferred-method" type="javaee:tld-deferred-methodType" minOccurs="0"></xsd:element>
                    </xsd:choice>
                </xsd:sequence>
                <xsd:element name="fragment" type="javaee:generic-booleanType" minOccurs="0"></xsd:element>
            </xsd:choice>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tld-canonical-nameType">
        <xsd:simpleContent>
            <xsd:restriction base="javaee:xsdNMTOKENType" />
        </xsd:simpleContent>
    </xsd:complexType>
    <xsd:complexType name="tld-deferred-methodType">
        <xsd:sequence>
            <xsd:element name="method-signature" type="javaee:string" minOccurs="0"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tld-deferred-valueType">
        <xsd:sequence>
            <xsd:element name="type" type="javaee:fully-qualified-classType" minOccurs="0"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tld-extensionType">
        <xsd:sequence>
            <xsd:element name="extension-element" type="javaee:extensibleType" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="namespace" use="required" type="xsd:anyURI" />
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="tldTaglibType">
        <xsd:sequence>
            <xsd:group ref="javaee:descriptionGroup" />
            <xsd:element name="tlib-version" type="javaee:dewey-versionType"></xsd:element>
            <xsd:element name="short-name" type="javaee:tld-canonical-nameType">
            </xsd:element>
            <xsd:element name="uri" type="javaee:xsdAnyURIType" minOccurs="0">
            </xsd:element>
            <xsd:element name="validator" type="javaee:validatorType" minOccurs="0">
            </xsd:element>
            <xsd:element name="listener" type="javaee:listenerType" minOccurs="0" maxOccurs="unbounded"></xsd:element>
            <xsd:element name="tag" type="javaee:tagType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="tag-file" type="javaee:tagFileType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="function" type="javaee:functionType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="taglib-extension" type="javaee:tld-extensionType" minOccurs="0" maxOccurs="unbounded"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="version" type="javaee:dewey-versionType" fixed="2.1" use="required"></xsd:attribute>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="validatorType">
        <xsd:sequence>
            <xsd:element name="description" type="javaee:descriptionType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="validator-class" type="javaee:fully-qualified-classType"></xsd:element>
            <xsd:element name="init-param" type="javaee:param-valueType" minOccurs="0" maxOccurs="unbounded"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
    <xsd:complexType name="variable-scopeType">
        <xsd:simpleContent>
            <xsd:restriction base="javaee:string">
                <xsd:enumeration value="NESTED" />
                <xsd:enumeration value="AT_BEGIN" />
                <xsd:enumeration value="AT_END" />
            </xsd:restriction>
        </xsd:simpleContent>
    </xsd:complexType>
    <xsd:complexType name="variableType">
        <xsd:sequence>
            <xsd:element name="description" type="javaee:descriptionType" minOccurs="0" maxOccurs="unbounded" />
            <xsd:choice>
                <xsd:element name="name-given" type="javaee:java-identifierType"></xsd:element>
                <xsd:element name="name-from-attribute" type="javaee:java-identifierType"></xsd:element>
            </xsd:choice>
            <xsd:element name="variable-class" type="javaee:fully-qualified-classType" minOccurs="0"></xsd:element>
            <xsd:element name="declare" type="javaee:generic-booleanType" minOccurs="0"></xsd:element>
            <xsd:element name="scope" type="javaee:variable-scopeType" minOccurs="0"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:ID" />
    </xsd:complexType>
======= f554475:"java/org/apache/catalina/startup/Constants.java"

        "/javax/servlet/resources/jsp_2_0.xsd";
        "/javax/servlet/resources/jsp_2_1.xsd";
        "/javax/servlet/resources/jsp_2_2.xsd";
        "/javax/servlet/resources/jsp_2_3.xsd";
      <name>Apache License, Version 2.0</name>
      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
        javaee_5.xsd,
        javaee_6.xsd,
        javaee_7.xsd,
        javaee_web_services_1_2.xsd,
        javaee_web_services_client_1_2.xsd,
        javaee_web_services_1_3.xsd,
        javaee_web_services_client_1_3.xsd,
        javaee_web_services_1_4.xsd,
        javaee_web_services_client_1_4.xsd,
        jsp_2_2.xsd,
        jsp_2_3.xsd,
        web-app_3_0.xsd,
        web-common_3_0.xsd,
        web-fragment_3_0.xsd,
        web-app_3_1.xsd,
        web-common_3_1.xsd and
        web-fragment_3_1.xsd
        to which the CDDL version 1.0 applies.
      <fix>
        <bug>55166</bug>: Move the JSP descriptor and tag library descriptor
        schema defintion files from jsp-api.jar to servlet-api.jar so relative
        includes between the J2EE, Servlet and JSP schemas are correctly
        resolved. (markt)
      </fix>

======= b932ace:"java/org/apache/catalina/startup/ContextConfig.java"

            List<ServletContainerInitializer> detectedScis = null;
======= b932ace:"java/org/apache/catalina/startup/ContextConfig.java"

                    detectedScis = getServletContainerInitializers(is);
======= b932ace:"java/org/apache/catalina/startup/ContextConfig.java"

            if (detectedScis == null) {
            for (ServletContainerInitializer sci : detectedScis) {
                initializerClassMap.put(sci, new HashSet<Class<?>>());
                HandlesTypes ht = null;
                try {
                    ht = sci.getClass().getAnnotation(HandlesTypes.class);
                } catch (Exception e) {
                    if (log.isDebugEnabled()) {
                        log.info(sm.getString("contextConfig.sci.debug", url),
                                e);
                    } else {
                        log.info(sm.getString("contextConfig.sci.info", url));
                    }
                if (ht != null) {
                    Class<?>[] types = ht.value();
                    if (types != null) {
                        for (Class<?> type : types) {
                            if (type.isAnnotation()) {
                                handlesTypesAnnotations = true;
                            } else {
                                handlesTypesNonAnnotations = true;
                            }
                            Set<ServletContainerInitializer> scis = typeInitializerMap
                                    .get(type);
                            if (scis == null) {
                                scis = new HashSet<>();
                                typeInitializerMap.put(type, scis);
                            }
                            scis.add(sci);
     * 
    protected List<ServletContainerInitializer> getServletContainerInitializers(
        List<ServletContainerInitializer> initializers = new ArrayList<>();
                BufferedReader br = new BufferedReader(new InputStreamReader(
                        is, "UTF-8"));
                while ((line = br.readLine()) != null) {
                    line = line.trim();
                    if (line.length() > 0) {
                        int i = line.indexOf('#');
                        if (i > -1) {
                            if (i == 0) {
                                continue;
                            }
                            line = line.substring(0, i).trim();
                        }
                        initializers.add(getServletContainerInitializer(line));
                    }
======= b932ace:"java/org/apache/catalina/startup/ContextConfig.java"

        return initializers;
    }
    protected ServletContainerInitializer getServletContainerInitializer(
            String className) throws IOException {
            Class<?> clazz = Class.forName(className, true, context.getLoader()
                    .getClassLoader());
            sci = (ServletContainerInitializer) clazz.newInstance();

======= 00e4f3f:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

                        int toWrite = r.bytesProduced();
                        while (toWrite > 0) {
                            Future<Integer> f =
                                    socketChannel.write(socketWriteBuffer);
                            Integer socketWrite = f.get();
                            toWrite -= socketWrite.intValue();

======= 2eb065f:"java/org/apache/coyote/Request.java"

        localNameMB.recycle();

======= a267dbf:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                } else if (decoderMatch != null && decoderMatch.hasMatches()) {

======= a634d85:"java/org/apache/tomcat/websocket/Constants.java"

======= a634d85:"java/org/apache/tomcat/websocket/Constants.java"

    public static final String WS_PROTOCOL_HEADER_NAME_LOWER =
            WS_PROTOCOL_HEADER_NAME.toLowerCase(Locale.ENGLISH);
======= a634d85:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

            // Header names are always stored in lower case
                    Constants.WS_PROTOCOL_HEADER_NAME_LOWER);
======= a634d85:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

        // Header names are case insensitive so always use lower case
======= a634d85:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testWsSubprotocols() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        ctx.addApplicationListener(new ApplicationListener(Config.class
                .getName(), false));
        Tomcat.addServlet(ctx, "default", new DefaultServlet());
        ctx.addServletMapping("/", "default");
        tomcat.start();
        WebSocketContainer wsContainer = ContainerProvider
                .getWebSocketContainer();
        tomcat.start();
        Session wsSession = wsContainer.connectToServer(
                TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder
                        .create().preferredSubprotocols(Arrays.asList("sp3"))
                        .build(), new URI("ws://localhost:" + getPort()
                        + SubProtocolsEndpoint.PATH_BASIC));
        Assert.assertTrue(wsSession.isOpen());
        if (wsSession.getNegotiatedSubprotocol() != null) {
            Assert.assertTrue(wsSession.getNegotiatedSubprotocol().isEmpty());
        }
        wsSession.close();
        wsSession = wsContainer.connectToServer(
                TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder
                        .create().preferredSubprotocols(Arrays.asList("sp2"))
                        .build(), new URI("ws://localhost:" + getPort()
                        + SubProtocolsEndpoint.PATH_BASIC));
        Assert.assertTrue(wsSession.isOpen());
        Assert.assertEquals("sp2", wsSession.getNegotiatedSubprotocol());
        Assert.assertArrayEquals(new String[]{"sp1","sp2"},
                SubProtocolsEndpoint.subprotocols.toArray(new String[2]));
        wsSession.close();
    }
    @ServerEndpoint(value = "/echo", subprotocols = {"sp1","sp2"})
    public static class SubProtocolsEndpoint {
        public static String PATH_BASIC = "/echo";
        public static List<String> subprotocols;
        @OnOpen
        public void processOpen(@SuppressWarnings("unused") Session session,
                EndpointConfig  epc) {
            subprotocols = ((ServerEndpointConfig)epc).getSubprotocols();
        }
    }
    public static class Config extends WsListener {
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            super.contextInitialized(sce);
            ServerContainer sc = (ServerContainer) sce.getServletContext()
                    .getAttribute(Constants.
                            SERVER_CONTAINER_SERVLET_CONTEXT_ATTRIBUTE);
            try {
                sc.addEndpoint(SubProtocolsEndpoint.class);
            } catch (DeploymentException e) {
                throw new IllegalStateException(e);
            }
        }
    }

======= b069c78:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

                subprotocols(Arrays.asList(annotation.subprotocols())).

======= 19c0bd3:"java/org/apache/tomcat/websocket/WsPongMessage.java"

        byte[] dst = new byte[applicationData.limit()];
        applicationData.get(dst);
        this.applicationData = ByteBuffer.wrap(dst);
======= 19c0bd3:"java/org/apache/tomcat/websocket/WsPongMessage.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    ByteBuffer applicationData = ByteBuffer.wrap(new String("mydata")
            .getBytes());
    @Test
    public void testPingPongMessages() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        ctx.addApplicationListener(new ApplicationListener(
                TesterEchoServer.Config.class.getName(), false));
        Tomcat.addServlet(ctx, "default", new DefaultServlet());
        ctx.addServletMapping("/", "default");
        tomcat.start();
        WebSocketContainer wsContainer = ContainerProvider
                .getWebSocketContainer();
        tomcat.start();
        Session wsSession = wsContainer.connectToServer(
                TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder
                        .create().build(), new URI("ws://localhost:"
                        + getPort() + TesterEchoServer.Config.PATH_ASYNC));
        CountDownLatch latch = new CountDownLatch(1);
        TesterEndpoint tep = (TesterEndpoint) wsSession.getUserProperties()
                .get("endpoint");
        tep.setLatch(latch);
        PongMessageHandler handler = new PongMessageHandler(latch);
        wsSession.addMessageHandler(handler);
        wsSession.getBasicRemote().sendPing(applicationData);
        boolean latchResult = handler.getLatch().await(10, TimeUnit.SECONDS);
        Assert.assertTrue(latchResult);
        Assert.assertArrayEquals(applicationData.array(),
                (handler.getMessages().get(0)).getApplicationData().array());
    }
    public static class PongMessageHandler extends
            TesterSingleMessageClient.BasicHandler<PongMessage> {
        public PongMessageHandler(CountDownLatch latch) {
            super(latch);
        }
        @Override
        public void onMessage(PongMessage message) {
            getMessages().add(message);
            if (getLatch() != null) {
                getLatch().countDown();
            }
        }
    }

======= 4da2de0:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

                if(endpoint.getSoTimeout() > 0) {
                    setSocketTimeout(endpoint.getSoTimeout());
                } else {
                    setSocketTimeout(0);
                }

======= ddd73d0:"java/org/apache/tomcat/websocket/WsFrameBase.java"

======= ddd73d0:"java/org/apache/tomcat/websocket/WsFrameBase.java"

                try {
                    mhPong.onMessage(new WsPongMessage(controlBufferBinary));
                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                    wsSession.getLocal().onError(wsSession, t);
                } finally {
                    controlBufferBinary.clear();
                }
======= ddd73d0:"java/org/apache/tomcat/websocket/WsFrameBase.java"

            try {
                if (mh instanceof MessageHandler.Partial<?>) {
                    ((MessageHandler.Partial<String>) mh).onMessage(
                            messageBufferText.toString(), last);
                } else {
                    // Caller ensures last == true if this branch is used
                    ((MessageHandler.Whole<String>) mh).onMessage(
                            messageBufferText.toString());
                }
            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                wsSession.getLocal().onError(wsSession, t);
            } finally {
                messageBufferText.clear();
======= ddd73d0:"java/org/apache/tomcat/websocket/WsFrameBase.java"

            try {
                if (mh instanceof MessageHandler.Partial<?>) {
                    ((MessageHandler.Partial<ByteBuffer>) mh).onMessage(msg, last);
                } else {
                    // Caller ensures last == true if this branch is used
                    ((MessageHandler.Whole<ByteBuffer>) mh).onMessage(msg);
                }
            } catch(Throwable t) {
                ExceptionUtils.handleThrowable(t);
                wsSession.getLocal().onError(wsSession, t);

======= 21f0a5c:"java/org/apache/catalina/valves/RemoteIpValve.java"

 * <td>proxiesHeader</td>
======= 21f0a5c:"java/org/apache/catalina/valves/RemoteIpValve.java"

 *   proxiesHeader="x-forwarded-by"
======= 21f0a5c:"java/org/apache/catalina/valves/RemoteIpValve.java"

 *   proxiesHeader="x-forwarded-by"
======= 21f0a5c:"java/org/apache/catalina/valves/RemoteIpValve.java"

 *   proxiesHeader="x-forwarded-by"
======= 21f0a5c:"java/org/apache/catalina/valves/RemoteIpValve.java"

 *   proxiesHeader="x-forwarded-by"

======= df6cee7:"java/org/apache/coyote/http11/Http11Processor.java"

            if (endpoint.getSoTimeout()> 0) {
                setSocketTimeout(endpoint.getSoTimeout());
            } else {
                setSocketTimeout(0);
            }

======= 6871d4c:"java/org/apache/catalina/realm/JAASRealm.java"

======= 6871d4c:"java/org/apache/catalina/realm/JAASRealm.java"

======= 6871d4c:"java/org/apache/catalina/realm/JAASRealm.java"

======= 6871d4c:"java/org/apache/catalina/realm/JAASRealm.java"

======= 6871d4c:"java/org/apache/catalina/realm/JAASRealm.java"

    protected boolean useContextClassLoader = true;
    /**
     * Path to find a JAAS configuration file, if not set global JVM JAAS
     * configuration will be used.
     */
    protected String configFile;
    protected Configuration jaasConfiguration;
    protected volatile boolean jaasConfigurationLoaded = false;
    /**
     * Getter for the <code>configfile</code> member variable.
     */
    public String getConfigFile() {
        return configFile;
    }
    /**
     * Setter for the <code>configfile</code> member variable.
     */
    public void setConfigFile(String configFile) {
        this.configFile = configFile;
    }
======= 6871d4c:"java/org/apache/catalina/realm/JAASRealm.java"

            Configuration config = getConfig();
            loginContext = new LoginContext(
                    appName, null, callbackHandler, config);
======= 6871d4c:"java/org/apache/catalina/realm/JAASRealm.java"

    /**
     * Load custom JAAS Configuration
     */
    protected Configuration getConfig() {
        try {
            if (jaasConfigurationLoaded) {
                return jaasConfiguration;
            }
            synchronized (this) {
                if (configFile == null) {
                    jaasConfigurationLoaded = true;
                    return null;
                }
                URL resource = Thread.currentThread().getContextClassLoader().
                        getResource(configFile);
                URI uri = resource.toURI();
                Class<Configuration> sunConfigFile = (Class<Configuration>)
                        Class.forName("com.sun.security.auth.login.ConfigFile");
                Constructor<Configuration> constructor =
                        sunConfigFile.getConstructor(URI.class);
                Configuration config = constructor.newInstance(uri);
                this.jaasConfiguration = config;
                this.jaasConfigurationLoaded = true;
                return this.jaasConfiguration;
            }
        } catch (URISyntaxException ex) {
            throw new RuntimeException(ex);
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(ex);
        } catch (SecurityException ex) {
            throw new RuntimeException(ex);
        } catch (InstantiationException ex) {
            throw new RuntimeException(ex);
        } catch (IllegalAccessException ex) {
            throw new RuntimeException(ex);
        } catch (IllegalArgumentException ex) {
            throw new RuntimeException(ex);
        } catch (InvocationTargetException ex) {
            throw new RuntimeException(ex.getCause());
        } catch (ClassNotFoundException ex) {
            throw new RuntimeException(ex);
        }
    }
      <attribute name="configFile" required="false">
        <p>The name of a JAAS configuration file to use with this Realm. It will
        be searched for using <code>ClassLoader#getResource(String)</code> so it
        is possible for the configuration to be bundled within a web
        application. If not specified, the default JVM global JAAS configuration
        willbe used.</p>
      </attribute>

======= 9a01f2d:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

                NioEndpoint.KeyAttachment att =
                        (NioEndpoint.KeyAttachment) socket.getAttachment(false);
                if (att == null) {
                    throw new IOException("Key must be cancelled.");
                }
                nRead = pool.read(socket.getBufHandler().getReadBuffer(),
                        socket, selector,
                        socket.getIOChannel().socket().getSoTimeout());

======= ca956bd:"java/org/apache/catalina/core/ApplicationHttpRequest.java"

            for (int i = specialAttributes.length - 1; i >= 0; i--) {
                    break;

======= b7cad6b:"java/org/apache/catalina/valves/ErrorReportValve.java"

        for (int i = elements.length - 1; i >= 0; i--) {
                break;

======= 45f59bb:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

======= 45f59bb:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

    protected String rmiBindAddress = null;
======= 45f59bb:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

     * Get the inet address on which the Platform RMI server is exported.
     * @return The textual representation of inet address
     */
    public String getRmiBindAddress() {
        return rmiBindAddress;
    }
    /**
     * Set the inet address on which the Platform RMI server is exported.
     * @param theRmiBindAddress The textual representation of inet address
     */
    public void setRmiBindAddress(String theRmiBindAddress) {
        rmiBindAddress = theRmiBindAddress;
    }
    /**
======= 45f59bb:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

                if (rmiBindAddress != null) {
                    throw new IllegalStateException(sm.getString(
                            "jmxRemoteLifecycleListener.sslRmiBindAddress"));
                }
            // Force server bind address if required
            if (rmiBindAddress != null) {
                try {
                    ssf = new RmiServerBindSocketFactory(
                            InetAddress.getByName(rmiBindAddress));
                } catch (UnknownHostException e) {
                    log.error(sm.getString(
                            "jmxRemoteLifecycleListener.invalidRmiBindAddress",
                            rmiBindAddress), e);
                }
            }
======= 45f59bb:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

                    rmiServerPortPlatform, env, csf, ssf,
======= 45f59bb:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

            HashMap<String,Object> theEnv, RMIClientSocketFactory csf,
            RMIServerSocketFactory ssf, MBeanServer theMBeanServer) {
            LocateRegistry.createRegistry(theRmiRegistryPort, csf, ssf);
======= 45f59bb:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

            implements RMIClientSocketFactory, Serializable {
======= 45f59bb:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

    }
    public static class RmiServerBindSocketFactory
            implements RMIServerSocketFactory {
        private final InetAddress bindAddress;
        public RmiServerBindSocketFactory(InetAddress address) {
            bindAddress = address;
        }
        @Override
        public ServerSocket createServerSocket(int port) throws IOException  {
            return new ServerSocket(port, 0, bindAddress);
        }
      <attribute name="rmiBindAddress" required="false">
        <p>The address of the interface to be used by JMX/RMI server. Setting
        this option to <code>true</code> is incompatible with setting the system
        property <code>com.sun.management.jmxremote.ssl</code> to
        <code>true</code>.</p>
      </attribute>

======= d71136a:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

                new String(((MsgByte) client.received.peek()).getData()));
======= d71136a:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

                MsgByte msg = new MsgByte();
                msg.setData(MESSAGE_ONE.getBytes());
======= d71136a:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            reply.flip();
======= d71136a:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"


======= 7aea9cb:"java/org/apache/catalina/valves/AccessLogValve.java"

     * write time until first byte is written (commit time) in millis - %F
     */
    protected static class FirstByteTimeElement implements AccessLogElement {
        @Override
        public void addElement(CharArrayWriter buf, Date date, Request request, Response response, long time) {
            long commitTime = response.getCoyoteResponse().getCommitTime();
            if (commitTime == -1) {
                buf.append('-');
            } else {
                long delta = commitTime - request.getCoyoteRequest().getStartTime();
                buf.append(Long.toString(delta));
            }
        }
    }
    /**
======= 7aea9cb:"java/org/apache/catalina/valves/AccessLogValve.java"

        case 'F':
            return new FirstByteTimeElement();
======= 7aea9cb:"java/org/apache/coyote/Response.java"

    private long commitTime = -1;
======= 7aea9cb:"java/org/apache/coyote/Response.java"

        if (v && !this.commited) {
            this.commitTime = System.currentTimeMillis();
        }
    /**
     * Return the time the response was committed (based on System.currentTimeMillis).
     *
     * @return the time the response was committed
     */
    public long getCommitTime() {
        return commitTime;
    }
======= 7aea9cb:"java/org/apache/coyote/Response.java"

        setCommitted(true);
======= 7aea9cb:"java/org/apache/coyote/Response.java"

        commitTime = -1;
    <li><b>%F</b> - Time taken to commit the response, in millis</li>

======= 3a36a8f:"java/org/apache/catalina/core/StandardService.java"

        // If the Server failed to start, the mapperListener won't have been
        // started
        if (mapperListener.getState() != LifecycleState.INITIALIZED) {
            mapperListener.stop();
        }
======= 3a36a8f:"java/org/apache/catalina/startup/Catalina.java"

            log.fatal(sm.getString("catalina.serverStartFail"), e);
            try {
                getServer().destroy();
            } catch (LifecycleException e1) {
                log.debug("destroy() failed for failed Server ", e1);
            }
            return;

======= 93bcdde:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java"

======= 93bcdde:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java"

    protected void setEncoders(EndpointConfig endpointConfig)
        for (Class<? extends Encoder> encoderClazz :
                endpointConfig.getEncoders()) {
                instance.init(endpointConfig);
======= 93bcdde:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java"

    protected final void close() {
        for (EncoderEntry entry : encoderEntries) {
            entry.getEncoder().destroy();
        }
        doClose();
    }
    protected abstract void doClose();
======= 93bcdde:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplClient.java"

    protected void doClose() {
======= 93bcdde:"java/org/apache/tomcat/websocket/WsSession.java"

======= 93bcdde:"java/org/apache/tomcat/websocket/WsSession.java"

            boolean secure, EndpointConfig endpointConfig)
======= 93bcdde:"java/org/apache/tomcat/websocket/WsSession.java"

        this.wsRemoteEndpoint.setEncoders(endpointConfig);
        this.userProperties.putAll(endpointConfig.getUserProperties());
======= 93bcdde:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

                clientEndpointConfiguration);
======= 93bcdde:"java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java"

                    pathParameters, secure, endpointConfig);
======= 93bcdde:"java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java"

    protected void doClose() {
======= 93bcdde:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

======= 93bcdde:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

        session.close();
        Thread.sleep(100);
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgStringEncoder.class.getName()+":init"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgStringDecoder.class.getName()+":init"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgByteEncoder.class.getName()+":init"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgByteDecoder.class.getName()+":init"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgStringEncoder.class.getName()+":destroy"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgStringDecoder.class.getName()+":destroy"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgByteEncoder.class.getName()+":destroy"));
        Assert.assertTrue(Server.isLifeCycleEventCalled(MsgByteDecoder.class.getName()+":destroy"));
======= 93bcdde:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

        static HashMap<String, Boolean> lifeCyclesCalled = new HashMap<>(8);
======= 93bcdde:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

        public static void addLifeCycleEvent(String event){
            lifeCyclesCalled.put(event, Boolean.TRUE);
        }
        public static boolean isLifeCycleEventCalled(String event){
            Boolean called = lifeCyclesCalled.get(event);
            return called == null ? false : called.booleanValue();
        }
======= 93bcdde:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            Server.addLifeCycleEvent(getClass().getName() + ":init");
            Server.addLifeCycleEvent(getClass().getName() + ":destroy");
======= 93bcdde:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            Server.addLifeCycleEvent(getClass().getName() + ":init");
            Server.addLifeCycleEvent(getClass().getName() + ":destroy");
======= 93bcdde:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

            Server.addLifeCycleEvent(getClass().getName() + ":init");
            Server.addLifeCycleEvent(getClass().getName() + ":destroy");
======= 93bcdde:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

             Server.addLifeCycleEvent(getClass().getName() + ":init");
            Server.addLifeCycleEvent(getClass().getName() + ":destroy");

======= 366ddff:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                    boolean foundBinaryDecoderMatch = false;
                    boolean foundTextDecoderMatch = false;
======= 366ddff:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                                if (!foundBinaryDecoderMatch) {
                                    if (indexByteBuffer == -1) {
                                        indexByteBuffer = i;
                                        foundBinaryDecoderMatch = true;
                                    } else {
                                        throw new IllegalArgumentException(sm.getString(
                                                "pojoMethodMapping.duplicateMessageParam",
                                                m.getName(), m.getDeclaringClass().getName()));
                                    }
                                if (!foundTextDecoderMatch) {
                                    if (indexString == -1) {
                                        indexString = i;
                                        foundTextDecoderMatch = true;
                                    } else {
                                        throw new IllegalArgumentException(sm.getString(
                                                "pojoMethodMapping.duplicateMessageParam",
                                                m.getName(), m.getDeclaringClass().getName()));
                                    }

======= c4a50f5:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

======= c4a50f5:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

======= c4a50f5:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

            BasicCredentials credentials = null;
            try {
                credentials = new BasicCredentials(authorizationBC);
                String username = credentials.getUsername();
                String password = credentials.getPassword();
                principal = context.getRealm().authenticate(username, password);
                if (principal != null) {
                    register(request, response, principal,
                        HttpServletRequest.BASIC_AUTH, username, password);
                    return (true);
            catch (IllegalArgumentException iae) {
                if (log.isDebugEnabled()) {
                    log.debug("Invalid Authorization" + iae.getMessage());
                }
        // the request could not be authenticated, so reissue the challenge
======= c4a50f5:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

    /**
     * Parser for an HTTP Authorization header for BASIC authentication
     * as per RFC 2617 section 2, and the Base64 encoded credentials as
     * per RFC 2045 section 6.8.
     */
    protected static class BasicCredentials {
        // the only authentication method supported by this parser
        // note: we include single white space as its delimiter
        private static final String METHOD = "basic ";
        private ByteChunk authorization;
        private int initialOffset;
        private int base64blobOffset;
        private int base64blobLength;
        private String username = null;
        private String password = null;
        /**
         * Parse the HTTP Authorization header for BASIC authentication
         * as per RFC 2617 section 2, and the Base64 encoded credentials
         * as per RFC 2045 section 6.8.
         *
         * @param input The header value to parse in-place
         *
         * @throws IllegalArgumentException If the header does not conform
         *                                  to RFC 2617
         */
        public BasicCredentials(ByteChunk input)
                throws IllegalArgumentException {
            authorization = input;
            initialOffset = input.getOffset();
            parseMethod();
            byte[] decoded = parseBase64();
            parseCredentials(decoded);
        }
        /**
         * Trivial accessor.
         *
         * @return  the decoded username token as a String, which is
         *          never be <code>null</code>, but can be empty.
         */
        public String getUsername() {
            return username;
        }
        /**
         * Trivial accessor.
         *
         * @return  the decoded password token as a String, or <code>null</code>
         *          if no password was found in the credentials.
         */
        public String getPassword() {
            return password;
        }
        /*
         * The authorization method string is case-insensitive and must
         * hae at least one space character as a delimiter.
         */
        private void parseMethod() throws IllegalArgumentException {
            if (authorization.startsWithIgnoreCase(METHOD, 0)) {
                // step past the auth method name
                base64blobOffset = initialOffset + METHOD.length();
                base64blobLength = authorization.getLength() - METHOD.length();
            }
            else {
                // is this possible, or permitted?
                throw new IllegalArgumentException(
                        "Authorization header method is not \"Basic\"");
            }
        }
        /*
         * Decode the base64-user-pass token, which RFC 2617 states
         * can be longer than the 76 characters per line limit defined
         * in RFC 2045. The base64 decoder will ignore embedded line
         * break characters as well as surplus surrounding white space.
         */
        private byte[] parseBase64() throws IllegalArgumentException {
            byte[] decoded = Base64.decodeBase64(
                        authorization.getBuffer(),
                        base64blobOffset, base64blobLength);
            //  restore original offset
            authorization.setOffset(initialOffset);
            if (decoded == null) {
                throw new IllegalArgumentException(
                        "Basic Authorization credentials are not Base64");
            }
            return decoded;
        }
        /*
         * Extract the mandatory username token and separate it from the
         * optional password token. Tolerate surplus surrounding white space.
         */
        private void parseCredentials(byte[] decoded)
                throws IllegalArgumentException {
            int colon = -1;
            for (int i = 0; i < decoded.length; i++) {
                if (decoded[i] == ':') {
                    colon = i;
                    break;
                }
            }
            if (colon < 0) {
                username = new String(decoded, B2CConverter.ISO_8859_1);
                // password will remain null!
            }
            else {
                username = new String(
                            decoded, 0, colon, B2CConverter.ISO_8859_1);
                password = new String(
                            decoded, colon + 1, decoded.length - colon - 1,
                            B2CConverter.ISO_8859_1);
                // tolerate surplus white space around credentials
                if (password.length() > 1) {
                    password = password.trim();
                }
            }
            // tolerate surplus white space around credentials
            if (username.length() > 1) {
                username = username.trim();
            }
        }
    }
======= c4a50f5:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Test the BasicAuthenticator's BasicCredentials inner class and the
 * associated Base64 decoder.
 */
    private static final String NICE_METHOD = "Basic";
    private static final String USER_NAME = "userid";
    private static final String PASSWORD = "secret";
    /*
     * test cases with good BASIC Auth credentials - Base64 strings
     * can have zero, one or two trailing pad characters
     */
    @Test
    public void testGoodCredentials() throws Exception {
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    @Test
    public void testGoodCredentialsNoPassword() throws Exception {
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, null);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertNull(credentials.getPassword());
    }
    @Test
    public void testGoodCrib() throws Exception {
        final String BASE64_CRIB = "dXNlcmlkOnNlY3JldA==";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    @Test
    public void testGoodCribUserOnly() throws Exception {
        final String BASE64_CRIB = "dXNlcmlk";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertNull(credentials.getPassword());
    }
    @Test
    public void testGoodCribOnePad() throws Exception {
        final String PASSWORD1 = "secrets";
        final String BASE64_CRIB = "dXNlcmlkOnNlY3JldHM=";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD1, credentials.getPassword());
    }
    /*
     * RFC 2045 says the Base64 encoded string should be represented
     * as lines of no more than 76 characters. However, RFC 2617
     * says a base64-user-pass token is not limited to 76 char/line.
     * It also says all line breaks, including mandatory ones,
     * should be ignored during decoding.
     * This test case has a line break in the Base64 string.
     * (See also testGoodCribBase64Big below).
     */
    @Test
    public void testGoodCribLineWrap() throws Exception {
        final String USER_LONG = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                + "abcdefghijklmnopqrstuvwxyz0123456789+/AAAABBBBCCCC"
                + "DDDD";                   // 80 characters
        final String BASE64_CRIB = "QUJDREVGR0hJSktMTU5PUFFSU1RVVldY"
                + "WVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0"
                + "\n" + "NTY3ODkrL0FBQUFCQkJCQ0NDQ0REREQ=";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_LONG, credentials.getUsername());
    }
    /*
     * RFC 2045 says the Base64 encoded string should be represented
     * as lines of no more than 76 characters. However, RFC 2617
     * says a base64-user-pass token is not limited to 76 char/line.
     */
    @Test
    public void testGoodCribBase64Big() throws Exception {
        // Our decoder accepts a long token without complaint.
        final String USER_LONG = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                + "abcdefghijklmnopqrstuvwxyz0123456789+/AAAABBBBCCCC"
                + "DDDD";                   // 80 characters
        final String BASE64_CRIB = "QUJDREVGR0hJSktMTU5PUFFSU1RVVldY"
                + "WVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0"
                + "NTY3ODkrL0FBQUFCQkJCQ0NDQ0REREQ="; // no new line
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_LONG, credentials.getUsername());
    }
    /*
     * verify the parser follows RFC2617 by treating the auth-scheme
     * token as case-insensitive.
     */
    @Test
    public void testAuthMethodCaseBasic() throws Exception {
        final String METHOD = "bAsIc";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(METHOD, USER_NAME, PASSWORD);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * Confirm the Basic parser rejects an invalid authentication method.
     */
    @Test
    public void testAuthMethodBadMethod() throws Exception {
        final String METHOD = "BadMethod";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(METHOD, USER_NAME, PASSWORD);
        @SuppressWarnings("unused")
        BasicAuthenticator.BasicCredentials credentials = null;
        try {
            credentials = new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
            Assert.fail("IllegalArgumentException expected");
        }
        catch (Exception e) {
            Assert.assertTrue(e instanceof IllegalArgumentException);
            Assert.assertTrue(e.getMessage().contains("header method"));
        }
    }
    /*
     * Confirm the Basic parser tolerates excess white space after
     * the authentication method.
     *
     * RFC2617 does not define the separation syntax between the auth-scheme
     * and basic-credentials tokens. Tomcat tolerates any amount of white
     * (within the limits of HTTP header sizes).
     */
    @Test
    public void testAuthMethodExtraLeadingSpace() throws Exception {
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD + " ", USER_NAME, PASSWORD);
        final BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * invalid decoded credentials cases
     */
    @Test
    public void testWrongPassword() throws Exception {
        final String PWD_WRONG = "wrong";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PWD_WRONG);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertNotSame(PASSWORD, credentials.getPassword());
    }
    @Test
    public void testMissingUsername() throws Exception {
        final String EMPTY_USER_NAME = "";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, EMPTY_USER_NAME, PASSWORD);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(EMPTY_USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    @Test
    public void testShortUsername() throws Exception {
        final String SHORT_USER_NAME = "a";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, SHORT_USER_NAME, PASSWORD);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(SHORT_USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    @Test
    public void testShortPassword() throws Exception {
        final String SHORT_PASSWORD = "a";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, SHORT_PASSWORD);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(SHORT_PASSWORD, credentials.getPassword());
    }
    @Test
    public void testPasswordHasSpaceEmbedded() throws Exception {
        final String PASSWORD_SPACE = "abc def";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD_SPACE);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD_SPACE, credentials.getPassword());
    }
    @Test
    public void testPasswordHasColonEmbedded() throws Exception {
        final String PASSWORD_COLON = "abc:def";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD_COLON);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD_COLON, credentials.getPassword());
    }
    @Test
    public void testPasswordHasColonLeading() throws Exception {
        final String PASSWORD_COLON = ":abcdef";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD_COLON);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD_COLON, credentials.getPassword());
    }
    @Test
    public void testPasswordHasColonTrailing() throws Exception {
        final String PASSWORD_COLON = "abcdef:";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD_COLON);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD_COLON, credentials.getPassword());
    }
    /*
     * Confirm the Basic parser tolerates excess white space after
     * the base64 blob.
     *
     * RFC2617 does not define this case, but asks servers to be
     * tolerant of this kind of client deviation.
     */
    @Test
    public void testAuthMethodExtraTrailingSpace() throws Exception {
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD, "    ");
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * Confirm the Basic parser tolerates excess white space around
     * the username inside the base64 blob.
     *
     * RFC2617 does not define the separation syntax between the auth-scheme
     * and basic-credentials tokens. Tomcat should tolerate any reasonable
     * amount of white space.
     */
    @Test
    public void testUserExtraSpace() throws Exception {
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, " " + USER_NAME + " ", PASSWORD);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * Confirm the Basic parser tolerates excess white space around
     * the username within the base64 blob.
     *
     * RFC2617 does not define the separation syntax between the auth-scheme
     * and basic-credentials tokens. Tomcat should tolerate any reasonable
     * amount of white space.
     */
    @Test
    public void testPasswordExtraSpace() throws Exception {
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, USER_NAME, " " + PASSWORD + " ");
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                    AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * invalid base64 string tests
     *
     * Refer to RFC2045 section 6.8.
     */
    /*
     * non-trailing "=" should trigger premature termination of the
     * decoder, returning a truncated string that will eventually
     * result in an authentication Assert.failure.
     */
    @Test
    public void testBadBase64InlineEquals() throws Exception {
        final String BASE64_CRIB = "dXNlcmlkOnNlY3J=dAo=";
        final String TRUNCATED_PWD = "secr";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                    AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertNotSame(PASSWORD, credentials.getPassword());
        Assert.assertEquals(TRUNCATED_PWD, credentials.getPassword());
    }
    /*
     * "-" is not a legal base64 character. The RFC says it must be
     * ignored by the decoder. This will scramble the decoded string
     * and eventually result in an authentication Assert.failure.
     */
    @Test
    public void testBadBase64Char() throws Exception {
        final String BASE64_CRIB = "dXNlcmlkOnNl-3JldHM=";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                    AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertNotSame(PASSWORD, credentials.getPassword());
    }
    /*
     * "-" is not a legal base64 character. The RFC says it must be
     * ignored by the decoder. This is a very strange case because the
     * next character is a pad, which terminates the string normally.
     * It is likely (but not certain) the decoded password will be
     * damaged and subsequent authentication will fail.
     */
    @Test
    public void testBadBase64LastChar() throws Exception {
        final String BASE64_CRIB = "dXNlcmlkOnNlY3JldA-=";
        final String POSSIBLY_DAMAGED_PWD = "secret";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                    AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(POSSIBLY_DAMAGED_PWD, credentials.getPassword());
    }
    /*
     * The trailing third "=" is illegal. However, the RFC says the decoder
     * must terminate as soon as the first pad is detected, so no error
     * will be detected unless the payload has been damaged in some way.
     */
    @Test
    public void testBadBase64TooManyEquals() throws Exception {
        final String BASE64_CRIB = "dXNlcmlkOnNlY3JldA===";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                    AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * there should be a multiple of 4 encoded characters. However,
     * the RFC says the decoder should pad the input string with
     * zero bits out to the next boundary. An error will not be detected
     * unless the payload has been damaged in some way - this
     * particular crib has no damage.
     */
    @Test
    public void testBadBase64BadLength() throws Exception {
        final String BASE64_CRIB = "dXNlcmlkOnNlY3JldA";
        final BasicAuthHeader AUTH_HEADER =
                new BasicAuthHeader(NICE_METHOD, BASE64_CRIB);
        BasicAuthenticator.BasicCredentials credentials =
                new BasicAuthenticator.BasicCredentials(
                    AUTH_HEADER.getHeader());
        Assert.assertEquals(USER_NAME, credentials.getUsername());
        Assert.assertEquals(PASSWORD, credentials.getPassword());
    }
    /*
     * Encapsulate the logic to generate an HTTP header
     * for BASIC Authentication.
     * Note: only used internally, so no need to validate arguments.
     */
    private final class BasicAuthHeader {
        private  final String HTTP_AUTH = "authorization: ";
        private  final byte[] HEADER =
                HTTP_AUTH.getBytes(B2CConverter.ISO_8859_1);
        private ByteChunk authHeader;
        private int initialOffset = 0;
        /*
         * This method creates a valid base64 blob
         */
        private BasicAuthHeader(String method, String username,
                String password) {
            this(method, username, password, null);
        }
        /*
         * This method creates valid base64 blobs with optional trailing data
         */
        private BasicAuthHeader(String method, String username,
                String password, String extraBlob) {
            prefix(method);
            String userCredentials =
                    ((password == null) || (password.length() < 1))
                    ? username
                    : username + ":" + password;
            byte[] credentialsBytes =
                    userCredentials.getBytes(B2CConverter.ISO_8859_1);
            String base64auth = Base64.encodeBase64String(credentialsBytes);
            byte[] base64Bytes =
                    base64auth.getBytes(B2CConverter.ISO_8859_1);
            byte[] extraBytes =
                    ((extraBlob == null) || (extraBlob.length() < 1))
                    ? null :
                    extraBlob.getBytes(B2CConverter.ISO_8859_1);
            try {
                authHeader.append(base64Bytes, 0, base64Bytes.length);
                if (extraBytes != null) {
                    authHeader.append(extraBytes, 0, extraBytes.length);
                }
            }
            catch (IOException ioe) {
                throw new IllegalStateException("unable to extend ByteChunk:"
                        + ioe.getMessage());
            }
            // emulate tomcat server - offset points to method in header
            authHeader.setOffset(initialOffset);
        }
        /*
         * This method allows injection of cribbed base64 blobs,
         * without any validation of the contents
         */
        private BasicAuthHeader(String method, String fakeBase64) {
            prefix(method);
            byte[] fakeBytes = fakeBase64.getBytes(B2CConverter.ISO_8859_1);
            try {
                authHeader.append(fakeBytes, 0, fakeBytes.length);
            }
            catch (IOException ioe) {
                throw new IllegalStateException("unable to extend ByteChunk:"
                        + ioe.getMessage());
            }
            // emulate tomcat server - offset points to method in header
            authHeader.setOffset(initialOffset);
        }
        /*
         * construct the common authorization header
         */
        private void prefix(String method) {
            authHeader = new ByteChunk();
            authHeader.setBytes(HEADER, 0, HEADER.length);
            initialOffset = HEADER.length;
            String methodX = method + " ";
            byte[] methodBytes = methodX.getBytes(B2CConverter.ISO_8859_1);
            try {
                authHeader.append(methodBytes, 0, methodBytes.length);
            }
            catch (IOException ioe) {
                throw new IllegalStateException("unable to extend ByteChunk:"
                        + ioe.getMessage());
            }
        }
        private ByteChunk getHeader() {
            return authHeader;
        }
    }
======= c4a50f5:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

     * using white space around the username credential. The request
     * is accepted.
                NO_COOKIES, HttpServletResponse.SC_OK);
     * using white space around the password credential. The request
     * is accepted.
                NO_COOKIES, HttpServletResponse.SC_OK);
      <fix>
        <bug>55101</bug>: Make BASIC authentication more tolerant of whitespace.
        Patch provided by Brian Burch. (markt)
      </fix>

======= c7c30b6:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

            if (urlStr.startsWith("file:") || urlStr.startsWith("jndi:") ||
                urlStr.startsWith("http:") || urlStr.startsWith("https:")) {

======= f78c1a4:"java/org/apache/catalina/core/StandardContext.java"

            // Check constraints for uncovered HTTP methods
            // Needs to be after SCIs and listeners as they may programatically
            // change constraints
            if (ok) {
                checkConstraintsForUncoveredMethods();
            }
======= f78c1a4:"java/org/apache/catalina/core/StandardContext.java"

    private void checkConstraintsForUncoveredMethods() {
        // TODO - Add an option to lower the log level of any uncovered method
        //        warnings to debug
        // TODO - Implement adding constraints to deny uncovered methods
        Set<String> coveredPatterns = new HashSet<>();
        Map<String,Set<String>> urlMethodMap = new HashMap<>();
        Map<String,Set<String>> urlOmittedMethodMap = new HashMap<>();
        // First build the lists of covered patterns and those patterns that
        // might be uncovered
        for (SecurityConstraint constraint : constraints) {
            SecurityCollection[] collections = constraint.findCollections();
            for (SecurityCollection collection : collections) {
                String[] patterns = collection.findPatterns();
                String[] methods = collection.findMethods();
                String[] omittedMethods = collection.findOmittedMethods();
                // Simple case: no methods
                if (methods.length == 0 && omittedMethods.length == 0) {
                    for (String pattern : patterns) {
                        coveredPatterns.add(pattern);
                    }
                    continue;
                }
                // Pre-calculate so we don't do this for every iteration of the
                // following loop
                List<String> omNew = null;
                if (omittedMethods.length == 0) {
                    omNew = Arrays.asList(omittedMethods);
                }
                // Only need to process uncovered patterns
                for (String pattern : patterns) {
                    if (!coveredPatterns.contains(pattern)) {
                        if (methods.length == 0) {
                            // Build the interset of omitted methods for this
                            // pattern
                            Set<String> om = urlOmittedMethodMap.get(pattern);
                            if (om == null) {
                                om = new HashSet<>();
                                urlMethodMap.put(pattern, om);
                            }
                            om.retainAll(omNew);
                        } else {
                            // Build the union of methods for this pattern
                            Set<String> m = urlMethodMap.get(pattern);
                            if (m == null) {
                                m = new HashSet<>();
                                urlMethodMap.put(pattern, m);
                            }
                            for (String method : methods) {
                                m.add(method);
                            }
                        }
                    }
                }
            }
        }
        // Now check the potentially uncovered patterns
        for (Map.Entry<String, Set<String>> entry : urlMethodMap.entrySet()) {
            String pattern = entry.getKey();
            if (coveredPatterns.contains(pattern)) {
                // Fully covered. Ignore any partial coverage
                urlOmittedMethodMap.remove(pattern);
                continue;
            }
            Set<String> omittedMethods = urlOmittedMethodMap.get(pattern);
            Set<String> methods = entry.getValue();
            if (omittedMethods == null) {
                StringBuilder msg = new StringBuilder();
                for (String method : methods) {
                    msg.append(method);
                    msg.append(' ');
                }
                log.error(sm.getString("standardContext.uncoveredHttpMethod",
                        pattern, msg.toString().trim()));
                continue;
            }
            // As long as every omitted method as a corresponding method the
            // pattern is fully covered.
            omittedMethods.removeAll(methods);
            if (omittedMethods.size() > 0) {
                StringBuilder msg = new StringBuilder();
                for (String method : omittedMethods) {
                    msg.append(method);
                    msg.append(' ');
                }
                log.error(sm.getString(
                        "standardContext.uncoveredHttpOmittedMethod",
                        pattern, msg.toString().trim()));
            }
        }
    }

======= 3e2ceee:"java/org/apache/jasper/compiler/Validator.java"

                            break;
                            break;

======= 4979721:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            for (int j=0; j<mbrs.length && include; j++ )

======= 82bccd2:"java/org/apache/catalina/servlets/WebdavServlet.java"

                if (ifHeader.indexOf(token) != -1) {
                    break;
                }
======= 82bccd2:"java/org/apache/catalina/servlets/WebdavServlet.java"

                    if (ifHeader.indexOf(token) != -1) {
                        break;
                    }

======= c48a2ed:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                        break;
======= c48a2ed:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                    break;

======= 99562d3:"java/org/apache/juli/ClassLoaderLogManager.java"

        String result = null;
        // If a prefix is defined look for a prefixed property first
            result = findProperty(prefix + name);
        }
        // If there is no prefix or no property match with the prefix try just
        // the name
        if (result == null) {
            result = findProperty(name);
        }
        // Simple property replacement (mostly for folder names)
        if (result != null) {
            result = replace(result);
        return result;
    }
    private String findProperty(String name) {
        ClassLoader classLoader = Thread.currentThread()
                .getContextClassLoader();
======= 99562d3:"java/org/apache/juli/ClassLoaderLogManager.java"


 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * <p>
 * A {@link Filter} that enable client-side cross-origin requests by
 * implementing W3C's CORS (<b>C</b>ross-<b>O</b>rigin <b>R</b>esource
 * <b>S</b>haring) specification for resources. Each {@link HttpServletRequest}
 * request is inspected as per specification, and appropriate response headers
 * are added to {@link HttpServletResponse}.
 * </p>
 *
 * <p>
 * By default, it also sets following request attributes, that help to
 * determine the nature of the request downstream.
 * <ul>
 * <li><b>cors.isCorsRequest:</b> Flag to determine if the request is a CORS
 * request. Set to <code>true</code> if a CORS request; <code>false</code>
 * otherwise.</li>
 * <li><b>cors.request.origin:</b> The Origin URL, i.e. the URL of the page from
 * where the request is originated.</li>
 * <li>
 * <b>cors.request.type:</b> Type of request. Possible values:
 * <ul>
 * <li>SIMPLE: A request which is not preceded by a pre-flight request.</li>
 * <li>ACTUAL: A request which is preceded by a pre-flight request.</li>
 * <li>PRE_FLIGHT: A pre-flight request.</li>
 * <li>NOT_CORS: A normal same-origin request.</li>
 * <li>INVALID_CORS: A cross-origin request which is invalid.</li>
 * </ul>
 * </li>
 * <li><b>cors.request.headers:</b> Request headers sent as
 * 'Access-Control-Request-Headers' header, for pre-flight request.</li>
 * </ul>
 * </p>
 *
 * @see <a href="http://www.w3.org/TR/cors/">CORS specification</a>
 *
 */
    private static final Log log = LogFactory.getLog(CorsFilter.class);
    private static final StringManager sm =
            StringManager.getManager(Constants.Package);
    /**
     * A {@link Collection} of origins consisting of zero or more origins that
     * are allowed access to the resource.
     */
    private final Collection<String> allowedOrigins;
    /**
     * Determines if any origin is allowed to make request.
     */
    private boolean anyOriginAllowed;
    /**
     * A {@link Collection} of methods consisting of zero or more methods that
     * are supported by the resource.
     */
    private final Collection<String> allowedHttpMethods;
    /**
     * A {@link Collection} of headers consisting of zero or more header field
     * names that are supported by the resource.
     */
    private final Collection<String> allowedHttpHeaders;
    /**
     * A {@link Collection} of exposed headers consisting of zero or more header
     * field names of headers other than the simple response headers that the
     * resource might use and can be exposed.
     */
    private final Collection<String> exposedHeaders;
    /**
     * A supports credentials flag that indicates whether the resource supports
     * user credentials in the request. It is true when the resource does and
     * false otherwise.
     */
    private boolean supportsCredentials;
    /**
     * Indicates (in seconds) how long the results of a pre-flight request can
     * be cached in a pre-flight result cache.
     */
    private long preflightMaxAge;
    /**
     * Determines if the request should be decorated or not.
     */
    private boolean decorateRequest;
    public CorsFilter() {
        this.allowedOrigins = new HashSet<>();
        this.allowedHttpMethods = new HashSet<>();
        this.allowedHttpHeaders = new HashSet<>();
        this.exposedHeaders = new HashSet<>();
    }
    @Override
    public void doFilter(final ServletRequest servletRequest,
            final ServletResponse servletResponse, final FilterChain filterChain)
            throws IOException, ServletException {
        if (!(servletRequest instanceof HttpServletRequest) ||
                !(servletResponse instanceof HttpServletResponse)) {
            throw new ServletException(sm.getString("corsFilter.onlyHttp"));
        }
        // Safe to downcast at this point.
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        // Determines the CORS request type.
        CorsFilter.CORSRequestType requestType = checkRequestType(request);
        // Adds CORS specific attributes to request.
        if (decorateRequest) {
            CorsFilter.decorateCORSProperties(request, requestType);
        }
        switch (requestType) {
        case SIMPLE:
            // Handles a Simple CORS request.
            this.handleSimpleCORS(request, response, filterChain);
            break;
        case ACTUAL:
            // Handles an Actual CORS request.
            this.handleSimpleCORS(request, response, filterChain);
            break;
        case PRE_FLIGHT:
            // Handles a Pre-flight CORS request.
            this.handlePreflightCORS(request, response, filterChain);
            break;
        case NOT_CORS:
            // Handles a Normal request that is not a cross-origin request.
            this.handleNonCORS(request, response, filterChain);
            break;
        default:
            // Handles a CORS request that violates specification.
            this.handleInvalidCORS(request, response, filterChain);
            break;
        }
    }
    @Override
    public void init(final FilterConfig filterConfig) throws ServletException {
        // Initialize defaults
        parseAndStore(DEFAULT_ALLOWED_ORIGINS, DEFAULT_ALLOWED_HTTP_METHODS,
                DEFAULT_ALLOWED_HTTP_HEADERS, DEFAULT_EXPOSED_HEADERS,
                DEFAULT_SUPPORTS_CREDENTIALS, DEFAULT_PREFLIGHT_MAXAGE,
                DEFAULT_DECORATE_REQUEST);
        if (filterConfig != null) {
            String configAllowedOrigins = filterConfig
                    .getInitParameter(PARAM_CORS_ALLOWED_ORIGINS);
            String configAllowedHttpMethods = filterConfig
                    .getInitParameter(PARAM_CORS_ALLOWED_METHODS);
            String configAllowedHttpHeaders = filterConfig
                    .getInitParameter(PARAM_CORS_ALLOWED_HEADERS);
            String configExposedHeaders = filterConfig
                    .getInitParameter(PARAM_CORS_EXPOSED_HEADERS);
            String configSupportsCredentials = filterConfig
                    .getInitParameter(PARAM_CORS_SUPPORT_CREDENTIALS);
            String configPreflightMaxAge = filterConfig
                    .getInitParameter(PARAM_CORS_PREFLIGHT_MAXAGE);
            String configDecorateRequest = filterConfig
                    .getInitParameter(PARAM_CORS_REQUEST_DECORATE);
            parseAndStore(configAllowedOrigins, configAllowedHttpMethods,
                    configAllowedHttpHeaders, configExposedHeaders,
                    configSupportsCredentials, configPreflightMaxAge,
                    configDecorateRequest);
        }
    }
    /**
     * Handles a CORS request of type {@link CORSRequestType}.SIMPLE.
     *
     * @param request
     *            The {@link HttpServletRequest} object.
     * @param response
     *            The {@link HttpServletResponse} object.
     * @param filterChain
     *            The {@link FilterChain} object.
     * @throws IOException
     * @throws ServletException
     * @see <a href="http://www.w3.org/TR/cors/#resource-requests">Simple
     *      Cross-Origin Request, Actual Request, and Redirects</a>
     */
    protected void handleSimpleCORS(final HttpServletRequest request,
            final HttpServletResponse response, final FilterChain filterChain)
            throws IOException, ServletException {
        CorsFilter.CORSRequestType requestType = checkRequestType(request);
        if (!(requestType == CorsFilter.CORSRequestType.SIMPLE ||
                requestType == CorsFilter.CORSRequestType.ACTUAL)) {
            throw new IllegalArgumentException(
                    sm.getString("corsFilter.wrongType2",
                            CorsFilter.CORSRequestType.SIMPLE,
                            CorsFilter.CORSRequestType.ACTUAL));
        }
        final String origin = request
                .getHeader(CorsFilter.REQUEST_HEADER_ORIGIN);
        final String method = request.getMethod();
        // Section 6.1.2
        if (!isOriginAllowed(origin)) {
            handleInvalidCORS(request, response, filterChain);
            return;
        }
        if (!allowedHttpMethods.contains(method)) {
            handleInvalidCORS(request, response, filterChain);
            return;
        }
        // Section 6.1.3
        // Add a single Access-Control-Allow-Origin header.
        if (anyOriginAllowed && !supportsCredentials) {
            // If resource doesn't support credentials and if any origin is
            // allowed
            // to make CORS request, return header with '*'.
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,
                    "*");
        } else {
            // If the resource supports credentials add a single
            // Access-Control-Allow-Origin header, with the value of the Origin
            // header as value.
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,
                    origin);
        }
        // Section 6.1.3
        // If the resource supports credentials, add a single
        // Access-Control-Allow-Credentials header with the case-sensitive
        // string "true" as value.
        if (supportsCredentials) {
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS,
                    "true");
        }
        // Section 6.1.4
        // If the list of exposed headers is not empty add one or more
        // Access-Control-Expose-Headers headers, with as values the header
        // field names given in the list of exposed headers.
        if ((exposedHeaders != null) && (exposedHeaders.size() > 0)) {
            String exposedHeadersString = join(exposedHeaders, ",");
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS,
                    exposedHeadersString);
        }
        // Forward the request down the filter chain.
        filterChain.doFilter(request, response);
    }
    /**
     * Handles CORS pre-flight request.
     *
     * @param request
     *            The {@link HttpServletRequest} object.
     * @param response
     *            The {@link HttpServletResponse} object.
     * @param filterChain
     *            The {@link FilterChain} object.
     * @throws IOException
     * @throws ServletException
     */
    protected void handlePreflightCORS(final HttpServletRequest request,
            final HttpServletResponse response, final FilterChain filterChain)
            throws IOException, ServletException {
        CORSRequestType requestType = checkRequestType(request);
        if (requestType != CORSRequestType.PRE_FLIGHT) {
            throw new IllegalArgumentException(
                    sm.getString("corsFilter.wrongType1",
                            CORSRequestType.PRE_FLIGHT.name().toLowerCase()));
        }
        final String origin = request
                .getHeader(CorsFilter.REQUEST_HEADER_ORIGIN);
        // Section 6.2.2
        if (!isOriginAllowed(origin)) {
            handleInvalidCORS(request, response, filterChain);
            return;
        }
        // Section 6.2.3
        String accessControlRequestMethod = request.getHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD);
        if (accessControlRequestMethod == null ||
                !HTTP_METHODS.contains(accessControlRequestMethod.trim())) {
            handleInvalidCORS(request, response, filterChain);
            return;
        } else {
            accessControlRequestMethod = accessControlRequestMethod.trim();
        }
        // Section 6.2.4
        String accessControlRequestHeadersHeader = request.getHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS);
        List<String> accessControlRequestHeaders = new LinkedList<>();
        if (accessControlRequestHeadersHeader != null &&
                !accessControlRequestHeadersHeader.trim().isEmpty()) {
            String[] headers = accessControlRequestHeadersHeader.trim().split(
                    ",");
            for (String header : headers) {
                accessControlRequestHeaders.add(header.trim().toLowerCase());
            }
        }
        // Section 6.2.5
        if (!allowedHttpMethods.contains(accessControlRequestMethod)) {
            handleInvalidCORS(request, response, filterChain);
            return;
        }
        // Section 6.2.6
        if (!accessControlRequestHeaders.isEmpty()) {
            for (String header : accessControlRequestHeaders) {
                if (!allowedHttpHeaders.contains(header)) {
                    handleInvalidCORS(request, response, filterChain);
                    return;
                }
            }
        }
        // Section 6.2.7
        if (supportsCredentials) {
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,
                    origin);
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS,
                    "true");
        } else {
            if (anyOriginAllowed) {
                response.addHeader(
                        CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,
                        "*");
            } else {
                response.addHeader(
                        CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,
                        origin);
            }
        }
        // Section 6.2.8
        if (preflightMaxAge > 0) {
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_MAX_AGE,
                    String.valueOf(preflightMaxAge));
        }
        // Section 6.2.9
        response.addHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_METHODS,
                accessControlRequestMethod);
        // Section 6.2.10
        if ((allowedHttpHeaders != null) && (!allowedHttpHeaders.isEmpty())) {
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_HEADERS,
                    join(allowedHttpHeaders, ","));
        }
        // Do not forward the request down the filter chain.
    }
    /**
     * Handles a request, that's not a CORS request, but is a valid request i.e.
     * it is not a cross-origin request. This implementation, just forwards the
     * request down the filter chain.
     *
     * @param request
     *            The {@link HttpServletRequest} object.
     * @param response
     *            The {@link HttpServletResponse} object.
     * @param filterChain
     *            The {@link FilterChain} object.
     * @throws IOException
     * @throws ServletException
     */
    private void handleNonCORS(final HttpServletRequest request,
            final HttpServletResponse response, final FilterChain filterChain)
            throws IOException, ServletException {
        // Let request pass.
        filterChain.doFilter(request, response);
    }
    /**
     * Handles a CORS request that violates specification.
     *
     * @param request
     *            The {@link HttpServletRequest} object.
     * @param response
     *            The {@link HttpServletResponse} object.
     * @param filterChain
     *            The {@link FilterChain} object.
     */
    private void handleInvalidCORS(final HttpServletRequest request,
            final HttpServletResponse response, final FilterChain filterChain) {
        String origin = request.getHeader(CorsFilter.REQUEST_HEADER_ORIGIN);
        String method = request.getMethod();
        String accessControlRequestHeaders = request.getHeader(
                REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS);
        response.setContentType("text/plain");
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        response.resetBuffer();
        if (log.isDebugEnabled()) {
            // Debug so no need for i18n
            StringBuilder message =
                    new StringBuilder("Invalid CORS request; Origin=");
            message.append(origin);
            message.append(";Method=");
            message.append(method);
            if (accessControlRequestHeaders != null) {
                message.append(";Access-Control-Request-Headers=");
                message.append(accessControlRequestHeaders);
            }
            log.debug(message.toString());
        }
    }
    @Override
    public void destroy() {
        // NOOP
    }
    /**
     * Decorates the {@link HttpServletRequest}, with CORS attributes.
     * <ul>
     * <li><b>cors.isCorsRequest:</b> Flag to determine if request is a CORS
     * request. Set to <code>true</code> if CORS request; <code>false</code>
     * otherwise.</li>
     * <li><b>cors.request.origin:</b> The Origin URL.</li>
     * <li><b>cors.request.type:</b> Type of request. Values:
     * <code>simple</code> or <code>preflight</code> or <code>not_cors</code> or
     * <code>invalid_cors</code></li>
     * <li><b>cors.request.headers:</b> Request headers sent as
     * 'Access-Control-Request-Headers' header, for pre-flight request.</li>
     * </ul>
     *
     * @param request
     *            The {@link HttpServletRequest} object.
     * @param corsRequestType
     *            The {@link CORSRequestType} object.
     */
    protected static void decorateCORSProperties(
            final HttpServletRequest request,
            final CORSRequestType corsRequestType) {
        if (request == null) {
            throw new IllegalArgumentException(
                    sm.getString("corsFilter.nullRequest"));
        }
        if (corsRequestType == null) {
            throw new IllegalArgumentException(
                    sm.getString("corsFilter.nullRequestType"));
        }
        switch (corsRequestType) {
        case SIMPLE:
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST,
                    Boolean.TRUE);
            request.setAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN,
                    request.getHeader(CorsFilter.REQUEST_HEADER_ORIGIN));
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE,
                    corsRequestType.name().toLowerCase());
            break;
        case ACTUAL:
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST,
                    Boolean.TRUE);
            request.setAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN,
                    request.getHeader(CorsFilter.REQUEST_HEADER_ORIGIN));
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE,
                    corsRequestType.name().toLowerCase());
            break;
        case PRE_FLIGHT:
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST,
                    Boolean.TRUE);
            request.setAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN,
                    request.getHeader(CorsFilter.REQUEST_HEADER_ORIGIN));
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE,
                    corsRequestType.name().toLowerCase());
            String headers = request.getHeader(
                    REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS);
            if (headers == null) {
                headers = "";
            }
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS, headers);
            break;
        case NOT_CORS:
            request.setAttribute(
                    CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST,
                    Boolean.FALSE);
            break;
        default:
            // Don't set any attributes
            break;
        }
    }
    /**
     * Joins elements of {@link Set} into a string, where each element is
     * separated by the provided separator.
     *
     * @param elements
     *            The {@link Set} containing elements to join together.
     * @param joinSeparator
     *            The character to be used for separating elements.
     * @return The joined {@link String}; <code>null</code> if elements
     *         {@link Set} is null.
     */
    protected static String join(final Collection<String> elements,
            final String joinSeparator) {
        String separator = ",";
        if (elements == null) {
            return null;
        }
        if (joinSeparator != null) {
            separator = joinSeparator;
        }
        StringBuilder buffer = new StringBuilder();
        boolean isFirst = true;
        for (String element : elements) {
            if (!isFirst) {
                buffer.append(separator);
            } else {
                isFirst = false;
            }
            if (element != null) {
                buffer.append(element);
            }
        }
        return buffer.toString();
    }
    /**
     * Determines the request type.
     *
     * @param request
     */
    protected CORSRequestType checkRequestType(final HttpServletRequest request) {
        CORSRequestType requestType = CORSRequestType.INVALID_CORS;
        if (request == null) {
            throw new IllegalArgumentException(
                    sm.getString("corsFilter.nullRequest"));
        }
        String originHeader = request.getHeader(REQUEST_HEADER_ORIGIN);
        // Section 6.1.1 and Section 6.2.1
        if (originHeader != null) {
            if (originHeader.isEmpty()) {
                requestType = CORSRequestType.INVALID_CORS;
            } else if (!isValidOrigin(originHeader)) {
                requestType = CORSRequestType.INVALID_CORS;
            } else {
                String method = request.getMethod();
                if (method != null && HTTP_METHODS.contains(method)) {
                    if ("OPTIONS".equals(method)) {
                        String accessControlRequestMethodHeader =
                                request.getHeader(
                                        REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD);
                        if (accessControlRequestMethodHeader != null &&
                                !accessControlRequestMethodHeader.isEmpty()) {
                            requestType = CORSRequestType.PRE_FLIGHT;
                        } else if (accessControlRequestMethodHeader != null &&
                                accessControlRequestMethodHeader.isEmpty()) {
                            requestType = CORSRequestType.INVALID_CORS;
                        } else {
                            requestType = CORSRequestType.ACTUAL;
                        }
                    } else if ("GET".equals(method) || "HEAD".equals(method)) {
                        requestType = CORSRequestType.SIMPLE;
                    } else if ("POST".equals(method)) {
                        String contentType = request.getContentType();
                        if (contentType != null) {
                            contentType = contentType.toLowerCase().trim();
                            if (SIMPLE_HTTP_REQUEST_CONTENT_TYPE_VALUES
                                    .contains(contentType)) {
                                requestType = CORSRequestType.SIMPLE;
                            } else {
                                requestType = CORSRequestType.ACTUAL;
                            }
                        }
                    } else if (COMPLEX_HTTP_METHODS.contains(method)) {
                        requestType = CORSRequestType.ACTUAL;
                    }
                }
            }
        } else {
            requestType = CORSRequestType.NOT_CORS;
        }
        return requestType;
    }
    /**
     * Checks if the Origin is allowed to make a CORS request.
     *
     * @param origin
     *            The Origin.
     * @return <code>true</code> if origin is allowed; <code>false</code>
     *         otherwise.
     */
    private boolean isOriginAllowed(final String origin) {
        if (anyOriginAllowed) {
            return true;
        }
        // If 'Origin' header is a case-sensitive match of any of allowed
        // origins, then return true, else return false.
        return allowedOrigins.contains(origin);
    }
    /**
     * Parses each param-value and populates configuration variables. If a param
     * is provided, it overrides the default.
     *
     * @param allowedOrigins
     *            A {@link String} of comma separated origins.
     * @param allowedHttpMethods
     *            A {@link String} of comma separated HTTP methods.
     * @param allowedHttpHeaders
     *            A {@link String} of comma separated HTTP headers.
     * @param exposedHeaders
     *            A {@link String} of comma separated headers that needs to be
     *            exposed.
     * @param supportsCredentials
     *            "true" if support credentials needs to be enabled.
     * @param preflightMaxAge
     *            The amount of seconds the user agent is allowed to cache the
     *            result of the pre-flight request.
     * @throws ServletException
     */
    private void parseAndStore(final String allowedOrigins,
            final String allowedHttpMethods, final String allowedHttpHeaders,
            final String exposedHeaders, final String supportsCredentials,
            final String preflightMaxAge, final String decorateRequest)
                    throws ServletException {
        if (allowedOrigins != null) {
            if (allowedOrigins.trim().equals("*")) {
                this.anyOriginAllowed = true;
            } else {
                this.anyOriginAllowed = false;
                Set<String> setAllowedOrigins =
                        parseStringToSet(allowedOrigins);
                this.allowedOrigins.clear();
                this.allowedOrigins.addAll(setAllowedOrigins);
            }
        }
        if (allowedHttpMethods != null) {
            Set<String> setAllowedHttpMethods =
                    parseStringToSet(allowedHttpMethods);
            this.allowedHttpMethods.clear();
            this.allowedHttpMethods.addAll(setAllowedHttpMethods);
        }
        if (allowedHttpHeaders != null) {
            Set<String> setAllowedHttpHeaders =
                    parseStringToSet(allowedHttpHeaders);
            Set<String> lowerCaseHeaders = new HashSet<>();
            for (String header : setAllowedHttpHeaders) {
                String lowerCase = header.toLowerCase();
                lowerCaseHeaders.add(lowerCase);
            }
            this.allowedHttpHeaders.clear();
            this.allowedHttpHeaders.addAll(lowerCaseHeaders);
        }
        if (exposedHeaders != null) {
            Set<String> setExposedHeaders = parseStringToSet(exposedHeaders);
            this.exposedHeaders.clear();
            this.exposedHeaders.addAll(setExposedHeaders);
        }
        if (supportsCredentials != null) {
            // For any value other then 'true' this will be false.
            this.supportsCredentials = Boolean
                    .parseBoolean(supportsCredentials);
        }
        if (preflightMaxAge != null) {
            try {
                if (!preflightMaxAge.isEmpty()) {
                    this.preflightMaxAge = Long.parseLong(preflightMaxAge);
                } else {
                    this.preflightMaxAge = 0L;
                }
            } catch (NumberFormatException e) {
                throw new ServletException(
                        sm.getString("corsFilter.invalidPreFlightMaxAge"), e);
            }
        }
        if (decorateRequest != null) {
            // For any value other then 'true' this will be false.
            this.decorateRequest = Boolean.parseBoolean(decorateRequest);
        }
    }
    /**
     * Takes a comma separated list and returns a Set<String>.
     *
     * @param data
     *            A comma separated list of strings.
     * @return Set<String>
     */
    private Set<String> parseStringToSet(final String data) {
        String[] splits;
        if (data != null && data.length() > 0) {
            splits = data.split(",");
        } else {
            splits = new String[] {};
        }
        Set<String> set = new HashSet<>();
        if (splits.length > 0) {
            for (String split : splits) {
                set.add(split.trim());
            }
        }
        return set;
    }
    /**
     * Checks if a given origin is valid or not. Criteria:
     * <ul>
     * <li>If an encoded character is present in origin, it's not valid.</li>
     * <li>Origin should be a valid {@link URI}</li>
     * </ul>
     *
     * @param origin
     * @see <a href="http://tools.ietf.org/html/rfc952">RFC952</a>
     */
    protected static boolean isValidOrigin(String origin) {
        // Checks for encoded characters. Helps prevent CRLF injection.
        if (origin.contains("%")) {
            return false;
        }
        URI originURI;
        try {
            originURI = new URI(origin);
        } catch (URISyntaxException e) {
            return false;
        }
        // If scheme for URI is null, return false. Return true otherwise.
        return originURI.getScheme() != null;
    }
    /**
     * Determines if any origin is allowed to make CORS request.
     *
     * @return <code>true</code> if it's enabled; false otherwise.
     */
    public boolean isAnyOriginAllowed() {
        return anyOriginAllowed;
    }
    /**
     * Returns a {@link Set} of headers that should be exposed by browser.
     */
    public Collection<String> getExposedHeaders() {
        return exposedHeaders;
    }
    /**
     * Determines is supports credentials is enabled.
     */
    public boolean isSupportsCredentials() {
        return supportsCredentials;
    }
    /**
     * Returns the preflight response cache time in seconds.
     *
     * @return Time to cache in seconds.
     */
    public long getPreflightMaxAge() {
        return preflightMaxAge;
    }
    /**
     * Returns the {@link Set} of allowed origins that are allowed to make
     * requests.
     *
     * @return {@link Set}
     */
    public Collection<String> getAllowedOrigins() {
        return allowedOrigins;
    }
    /**
     * Returns a {@link Set} of HTTP methods that are allowed to make requests.
     *
     * @return {@link Set}
     */
    public Collection<String> getAllowedHttpMethods() {
        return allowedHttpMethods;
    }
    /**
     * Returns a {@link Set} of headers support by resource.
     *
     * @return {@link Set}
     */
    public Collection<String> getAllowedHttpHeaders() {
        return allowedHttpHeaders;
    }
    // -------------------------------------------------- CORS Response Headers
    /**
     * The Access-Control-Allow-Origin header indicates whether a resource can
     * be shared based by returning the value of the Origin request header in
     * the response.
     */
    public static final String RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN =
            "Access-Control-Allow-Origin";
    /**
     * The Access-Control-Allow-Credentials header indicates whether the
     * response to request can be exposed when the omit credentials flag is
     * unset. When part of the response to a preflight request it indicates that
     * the actual request can include user credentials.
     */
    public static final String RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS =
            "Access-Control-Allow-Credentials";
    /**
     * The Access-Control-Expose-Headers header indicates which headers are safe
     * to expose to the API of a CORS API specification
     */
    public static final String RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS =
            "Access-Control-Expose-Headers";
    /**
     * The Access-Control-Max-Age header indicates how long the results of a
     * preflight request can be cached in a preflight result cache.
     */
    public static final String RESPONSE_HEADER_ACCESS_CONTROL_MAX_AGE =
            "Access-Control-Max-Age";
    /**
     * The Access-Control-Allow-Methods header indicates, as part of the
     * response to a preflight request, which methods can be used during the
     * actual request.
     */
    public static final String RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_METHODS =
            "Access-Control-Allow-Methods";
    /**
     * The Access-Control-Allow-Headers header indicates, as part of the
     * response to a preflight request, which header field names can be used
     * during the actual request.
     */
    public static final String RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_HEADERS =
            "Access-Control-Allow-Headers";
    // -------------------------------------------------- CORS Request Headers
    /**
     * The Origin header indicates where the cross-origin request or preflight
     * request originates from.
     */
    public static final String REQUEST_HEADER_ORIGIN = "Origin";
    /**
     * The Access-Control-Request-Method header indicates which method will be
     * used in the actual request as part of the preflight request.
     */
    public static final String REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD =
            "Access-Control-Request-Method";
    /**
     * The Access-Control-Request-Headers header indicates which headers will be
     * used in the actual request as part of the preflight request.
     */
    public static final String REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS =
            "Access-Control-Request-Headers";
    // ----------------------------------------------------- Request attributes
    /**
     * The prefix to a CORS request attribute.
     */
    public static final String HTTP_REQUEST_ATTRIBUTE_PREFIX = "cors.";
    /**
     * Attribute that contains the origin of the request.
     */
    public static final String HTTP_REQUEST_ATTRIBUTE_ORIGIN =
            HTTP_REQUEST_ATTRIBUTE_PREFIX + "request.origin";
    /**
     * Boolean value, suggesting if the request is a CORS request or not.
     */
    public static final String HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST =
            HTTP_REQUEST_ATTRIBUTE_PREFIX + "isCorsRequest";
    /**
     * Type of CORS request, of type {@link CORSRequestType}.
     */
    public static final String HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE =
            HTTP_REQUEST_ATTRIBUTE_PREFIX + "request.type";
    /**
     * Request headers sent as 'Access-Control-Request-Headers' header, for
     * pre-flight request.
     */
    public static final String HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS =
            HTTP_REQUEST_ATTRIBUTE_PREFIX + "request.headers";
    // -------------------------------------------------------------- Constants
    /**
     * Enumerates varies types of CORS requests. Also, provides utility methods
     * to determine the request type.
     */
    protected static enum CORSRequestType {
        /**
         * A simple HTTP request, i.e. it shouldn't be pre-flighted.
         */
        SIMPLE,
        /**
         * A HTTP request that needs to be pre-flighted.
         */
        ACTUAL,
        /**
         * A pre-flight CORS request, to get meta information, before a
         * non-simple HTTP request is sent.
         */
        PRE_FLIGHT,
        /**
         * Not a CORS request, but a normal request.
         */
        NOT_CORS,
        /**
         * An invalid CORS request, i.e. it qualifies to be a CORS request, but
         * fails to be a valid one.
         */
        INVALID_CORS
    }
    /**
     * {@link Collection} of HTTP methods. Case sensitive.
     *
     * @see  <a href="http://tools.ietf.org/html/rfc2616#section-5.1.1"
     *       >http://tools.ietf.org/html/rfc2616#section-5.1.1</a>
     *
     */
    public static final Collection<String> HTTP_METHODS =
            new HashSet<>(Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT",
                    "DELETE", "TRACE", "CONNECT"));
    /**
     * {@link Collection} of non-simple HTTP methods. Case sensitive.
     */
    public static final Collection<String> COMPLEX_HTTP_METHODS =
            new HashSet<>(Arrays.asList("PUT", "DELETE", "TRACE", "CONNECT"));
    /**
     * {@link Collection} of Simple HTTP methods. Case sensitive.
     *
     * @see  <a href="http://www.w3.org/TR/cors/#terminology"
     *       >http://www.w3.org/TR/cors/#terminology</a>
     */
    public static final Collection<String> SIMPLE_HTTP_METHODS =
            new HashSet<>(Arrays.asList("GET", "POST", "HEAD"));
    /**
     * {@link Collection} of Simple HTTP request headers. Case in-sensitive.
     *
     * @see  <a href="http://www.w3.org/TR/cors/#terminology"
     *       >http://www.w3.org/TR/cors/#terminology</a>
     */
    public static final Collection<String> SIMPLE_HTTP_REQUEST_HEADERS =
            new HashSet<>(Arrays.asList("Accept", "Accept-Language",
                    "Content-Language"));
    /**
     * {@link Collection} of Simple HTTP request headers. Case in-sensitive.
     *
     * @see  <a href="http://www.w3.org/TR/cors/#terminology"
     *       >http://www.w3.org/TR/cors/#terminology</a>
     */
    public static final Collection<String> SIMPLE_HTTP_RESPONSE_HEADERS =
            new HashSet<>(Arrays.asList("Cache-Control", "Content-Language",
                    "Content-Type", "Expires", "Last-Modified", "Pragma"));
    /**
     * {@link Collection} of Simple HTTP request headers. Case in-sensitive.
     *
     * @see  <a href="http://www.w3.org/TR/cors/#terminology"
     *       >http://www.w3.org/TR/cors/#terminology</a>
     */
    public static final Collection<String> SIMPLE_HTTP_REQUEST_CONTENT_TYPE_VALUES =
            new HashSet<>(Arrays.asList("application/x-www-form-urlencoded",
                    "multipart/form-data", "text/plain"));
    // ------------------------------------------------ Configuration Defaults
    /**
     * By default, all origins are allowed to make requests.
     */
    public static final String DEFAULT_ALLOWED_ORIGINS = "*";
    /**
     * By default, following methods are supported: GET, POST, HEAD and OPTIONS.
     */
    public static final String DEFAULT_ALLOWED_HTTP_METHODS =
            "GET,POST,HEAD,OPTIONS";
    /**
     * By default, time duration to cache pre-flight response is 30 mins.
     */
    public static final String DEFAULT_PREFLIGHT_MAXAGE = "1800";
    /**
     * By default, support credentials is turned on.
     */
    public static final String DEFAULT_SUPPORTS_CREDENTIALS = "true";
    /**
     * By default, following headers are supported:
     * Origin,Accept,X-Requested-With, Content-Type,
     * Access-Control-Request-Method, and Access-Control-Request-Headers.
     */
    public static final String DEFAULT_ALLOWED_HTTP_HEADERS =
            "Origin,Accept,X-Requested-With,Content-Type," +
            "Access-Control-Request-Method,Access-Control-Request-Headers";
    /**
     * By default, none of the headers are exposed in response.
     */
    public static final String DEFAULT_EXPOSED_HEADERS = "";
    /**
     * By default, request is decorated with CORS attributes.
     */
    public static final String DEFAULT_DECORATE_REQUEST = "true";
    // ----------------------------------------Filter Config Init param-name(s)
    /**
     * Key to retrieve allowed origins from {@link FilterConfig}.
     */
    public static final String PARAM_CORS_ALLOWED_ORIGINS =
            "cors.allowed.origins";
    /**
     * Key to retrieve support credentials from {@link FilterConfig}.
     */
    public static final String PARAM_CORS_SUPPORT_CREDENTIALS =
            "cors.support.credentials";
    /**
     * Key to retrieve exposed headers from {@link FilterConfig}.
     */
    public static final String PARAM_CORS_EXPOSED_HEADERS =
            "cors.exposed.headers";
    /**
     * Key to retrieve allowed headers from {@link FilterConfig}.
     */
    public static final String PARAM_CORS_ALLOWED_HEADERS =
            "cors.allowed.headers";
    /**
     * Key to retrieve allowed methods from {@link FilterConfig}.
     */
    public static final String PARAM_CORS_ALLOWED_METHODS =
            "cors.allowed.methods";
    /**
     * Key to retrieve preflight max age from {@link FilterConfig}.
     */
    public static final String PARAM_CORS_PREFLIGHT_MAXAGE =
            "cors.preflight.maxage";
    /**
     * Key to determine if request should be decorated.
     */
    public static final String PARAM_CORS_REQUEST_DECORATE =
            "cors.request.decorate";
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private FilterChain filterChain = new TesterFilterChain();
    /**
     * Tests if a GET request is treated as simple request.
     *
     * @See http://www.w3.org/TR/cors/#simple-method
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimpleGET() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("GET");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "https://www.apache.org"));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Tests if a POST request is treated as simple request.
     *
     * @See http://www.w3.org/TR/cors/#simple-method
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimplePOST() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setContentType("text/plain");
        request.setMethod("POST");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "https://www.apache.org"));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Tests if a HEAD request is treated as simple request.
     *
     * @See http://www.w3.org/TR/cors/#simple-method
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimpleHEAD() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("HEAD");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "https://www.apache.org"));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Test the presence of specific origin in response, when '*' is not used.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimpleSpecificHeader() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("POST");
        request.setContentType("text/plain");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Tests the prsence of the origin (and not '*') in the response, when
     * supports credentials is enabled alongwith any origin, '*'.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimpleAnyOriginAndSupportsCredentials()
            throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("GET");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getFilterConfigAnyOriginAndSupportsCredentials());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS)
                .equals(
                        "true"));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Tests the presence of the origin (and not '*') in the response, when
     * supports credentials is enabled alongwith any origin, '*'.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimpleAnyOriginAndSupportsCredentialsDisabled()
            throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("GET");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getFilterConfigAnyOriginAndSupportsCredentialsDisabled());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.ANY_ORIGIN));
        Assert.assertNull(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Tests the presence of exposed headers in response, if configured.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterSimpleWithExposedHeaders() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("POST");
        request.setContentType("text/plain");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getFilterConfigWithExposedHeaders());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "https://www.apache.org"));
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS)
                .equals(TesterFilterConfigs.EXPOSED_HEADERS));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    /**
     * Checks if an OPTIONS request is processed as pre-flight.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterPreflight() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.PRE_FLIGHT.name().toLowerCase()));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS).equals(
                "Content-Type"));
    }
    /**
     * Checks if an OPTIONS request is processed as pre-flight where any origin
     * is enabled.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterPreflightAnyOrigin() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.PRE_FLIGHT.name().toLowerCase()));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS).equals(
                "Content-Type"));
    }
    /**
     * Checks if an OPTIONS request is processed as pre-flight.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test
    public void testDoFilterPreflightInvalidOrigin() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://www.example.com");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(response.getStatus(),
                HttpServletResponse.SC_FORBIDDEN);
    }
    @Test
    public void testDoFilterPreflightNegativeMaxAge() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfigNegativeMaxAge());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertNull(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_MAX_AGE));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.PRE_FLIGHT.name().toLowerCase()));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS).equals(
                "Content-Type"));
    }
    @Test
    public void testDoFilterPreflightWithCredentials() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSecureFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS)
                .equals("true"));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.PRE_FLIGHT.name().toLowerCase()));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS).equals(
                "Content-Type"));
    }
    @Test
    public void testDoFilterPreflightWithoutCredentialsAndSpecificOrigin()
            throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getFilterConfigSpecificOriginAndSupportsCredentialsDisabled());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertNull(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.PRE_FLIGHT.name().toLowerCase()));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS).equals(
                "Content-Type"));
    }
    /**
     * Negative test, when a CORS request arrives, with a null origin.
     */
    @Test
    public void testDoFilterNullOrigin() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setMethod("POST");
        request.setContentType("text/plain");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.NOT_CORS, requestType);
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertFalse(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
    }
    @Test
    public void testDoFilterInvalidCORSOriginNotAllowed() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "www.google.com");
        request.setMethod("POST");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    @Test(expected = ServletException.class)
    public void testDoFilterNullRequestNullResponse() throws IOException,
            ServletException {
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.doFilter(null, null, filterChain);
    }
    @Test(expected = ServletException.class)
    public void testDoFilterNullRequestResponse() throws IOException,
            ServletException {
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.doFilter(null, response, filterChain);
    }
    @Test(expected = ServletException.class)
    public void testDoFilterRequestNullResponse() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.doFilter(request, null, filterChain);
    }
    @Test
    public void testInitDefaultFilterConfig() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("GET");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(null);
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "https://www.apache.org"));
        Assert.assertTrue(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN).equals(
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG));
        Assert.assertTrue(request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE).equals(
                CorsFilter.CORSRequestType.SIMPLE.name().toLowerCase()));
    }
    @Test(expected = ServletException.class)
    public void testInitInvalidFilterConfig() throws ServletException {
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getFilterConfigInvalidMaxPreflightAge());
        // If we don't get an exception at this point, then all mocked objects
        // worked as expected.
    }
    /**
     * Tests if a non-simple request is given to simple request handler.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test(expected = IllegalArgumentException.class)
    public void testNotSimple() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD, "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        corsFilter.handleSimpleCORS(request, response, filterChain);
    }
    /**
     * When a non-preflight request is given to a pre-flight request handler.
     *
     * @throws IOException
     * @throws ServletException
     */
    @Test(expected = IllegalArgumentException.class)
    public void testNotPreflight() throws IOException, ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("GET");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        corsFilter.handlePreflightCORS(request, response, filterChain);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testDecorateCORSPropertiesNullRequestNullCORSRequestType() {
        CorsFilter.decorateCORSProperties(null, null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testDecorateCORSPropertiesNullRequestValidCORSRequestType() {
        CorsFilter.decorateCORSProperties(null,
                CorsFilter.CORSRequestType.SIMPLE);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testDecorateCORSPropertiesValidRequestNullRequestType() {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        CorsFilter.decorateCORSProperties(request, null);
    }
    @Test
    public void testDecorateCORSPropertiesCORSRequestTypeNotCORS() {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        CorsFilter.decorateCORSProperties(request,
                CorsFilter.CORSRequestType.NOT_CORS);
        Assert.assertFalse(((Boolean) request.getAttribute(
                CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());
    }
    @Test
    public void testDecorateCORSPropertiesCORSRequestTypeInvalidCORS() {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        CorsFilter
                .decorateCORSProperties(request,
                        CorsFilter.CORSRequestType.INVALID_CORS);
        Assert.assertNull(request
                .getAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST));
    }
    @Test
    public void testCheckSimpleRequestTypeAnyOrigin() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://www.w3.org");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.SIMPLE, requestType);
    }
    /**
     * Happy path test, when a valid CORS Simple request arrives.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckSimpleRequestType() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.SIMPLE, requestType);
    }
    /**
     * Happy path test, when a valid CORS Simple request arrives.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckActualRequestType() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setMethod("PUT");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.ACTUAL, requestType);
    }
    /**
     * Happy path test, when a valid CORS Simple request arrives.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckActualRequestTypeMethodPOSTNotSimpleHeaders()
            throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setMethod("POST");
        request.setContentType("application/json");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.ACTUAL, requestType);
    }
    /**
     * Happy path test, when a valid CORS Pre-flight request arrives.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckPreFlightRequestType() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Content-Type");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.PRE_FLIGHT, requestType);
    }
    /**
     * when a valid CORS Pre-flight request arrives, with no
     * Access-Control-Request-Method
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckPreFlightRequestTypeNoACRM() throws ServletException,
            IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.ACTUAL, requestType);
    }
    /**
     * when a valid CORS Pre-flight request arrives, with empty
     * Access-Control-Request-Method
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckPreFlightRequestTypeEmptyACRM()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    /**
     * Happy path test, when a valid CORS Pre-flight request arrives.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckPreFlightRequestTypeNoHeaders()
            throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "PUT");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.PRE_FLIGHT, requestType);
    }
    /**
     * Section 6.2.3
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckPreFlightRequestTypeInvalidRequestMethod()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "POLITE");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * Section Section 6.2.5
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckPreFlightRequestTypeUnsupportedRequestMethod()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "TRACE");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * Section Section 6.2.6
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckPreFlightRequestTypeUnsupportedRequestHeaders()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "X-ANSWER");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSecureFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * Section Section 6.2.7
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckPreFlightRequestTypeAnyOriginNoWithCredentials()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "Origin");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getFilterConfigAnyOriginAndSupportsCredentialsDisabled());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "*"));
        Assert.assertNull(response
                .getHeader(CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS));
    }
    @Test
    public void testCheckPreFlightRequestTypeOriginNotAllowed()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "www.ebay.com");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "PUT");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSecureFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * Happy path test, when a valid CORS Pre-flight request arrives.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckPreFlightRequestTypeEmptyHeaders()
            throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTP_TOMCAT_APACHE_ORG);
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
                "PUT");
        request.setHeader(
                CorsFilter.REQUEST_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
                "");
        request.setMethod("OPTIONS");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.PRE_FLIGHT, requestType);
    }
    /**
     * Negative test, when a CORS request arrives, with an empty origin.
     *
     * @throws ServletException
     */
    @Test
    public void testCheckNotCORSRequestTypeEmptyOrigin()
            throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    /**
     * Tests for failure, when a different domain is used, that's not in the
     * allowed list of origins.
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckInvalidOrigin() throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "www.example.com");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * Tests for failure, when a different sub-domain is used, that's not in the
     * allowed list of origins.
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckInvalidOriginNotAllowedSubdomain()
            throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://commons.apache.org");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * PUT is not an allowed request method.
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckInvalidRequestMethod() throws ServletException,
            IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://tomcat.apache.org");
        request.setMethod("PUT");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * When requestMethod is null
     *
     * @throws ServletException
     */
    @Test
    public void testCheckNullRequestMethod() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://tomcat.apache.org");
        request.setMethod(null);
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    /**
     * "http://tomcat.apache.org" is an allowed origin and
     * "https://tomcat.apache.org" is not, because scheme doesn't match
     *
     * @throws ServletException
     */
    @Test
    public void testCheckForSchemeVariance() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "https://tomcat.apache.org");
        request.setMethod("POST");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    /**
     * "http://tomcat.apache.org" is an allowed origin and
     * "http://tomcat.apache.org:8080" is not, because ports doesn't match
     *
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testCheckForPortVariance() throws ServletException, IOException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://tomcat.apache.org:8080");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getSpecificOriginFilterConfig());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,
                response.getStatus());
    }
    /**
     * Tests for failure, when an invalid {@link HttpServletRequest} is
     * encountered.
     *
     * @throws ServletException
     */
    @Test(expected = IllegalArgumentException.class)
    public void testCheckRequestTypeNull() throws ServletException {
        HttpServletRequest request = null;
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.checkRequestType(request);
    }
    @Test
    public void testJoin() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = ",";
        elements.add("world");
        elements.add("peace");
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue("world,peace".equals(join));
    }
    @Test
    public void testJoinSingleElement() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = ",";
        elements.add("world");
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue("world".equals(join));
    }
    @Test
    public void testJoinSepNull() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = null;
        elements.add("world");
        elements.add("peace");
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue("world,peace".equals(join));
    }
    @Test
    public void testJoinElementsNull() {
        Set<String> elements = null;
        String separator = ",";
        String join = CorsFilter.join(elements, separator);
        Assert.assertNull(join);
    }
    @Test
    public void testJoinOneNullElement() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = ",";
        elements.add(null);
        elements.add("peace");
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue(",peace".equals(join));
    }
    @Test
    public void testJoinAllNullElements() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = ",";
        elements.add(null);
        elements.add(null);
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue("".equals(join));
    }
    @Test
    public void testJoinAllEmptyElements() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = ",";
        elements.add("");
        elements.add("");
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue("".equals(join));
    }
    @Test
    public void testJoinPipeSeparator() {
        Set<String> elements = new LinkedHashSet<>();
        String separator = "|";
        elements.add("world");
        elements.add("peace");
        String join = CorsFilter.join(elements, separator);
        Assert.assertTrue("world|peace".equals(join));
    }
    @Test
    public void testWithFilterConfig() throws ServletException {
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getDefaultFilterConfig());
        Assert.assertTrue(corsFilter.getAllowedHttpHeaders().size() == 6);
        Assert.assertTrue(corsFilter.getAllowedHttpMethods().size() == 4);
        Assert.assertTrue(corsFilter.getAllowedOrigins().size() == 0);
        Assert.assertTrue(corsFilter.isAnyOriginAllowed());
        Assert.assertTrue(corsFilter.getExposedHeaders().size() == 0);
        Assert.assertTrue(corsFilter.isSupportsCredentials());
        Assert.assertTrue(corsFilter.getPreflightMaxAge() == 1800);
    }
    @Test(expected = ServletException.class)
    public void testWithFilterConfigInvalidPreflightAge()
            throws ServletException {
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getFilterConfigInvalidMaxPreflightAge());
    }
    @Test
    public void testWithStringParserEmpty() throws ServletException {
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getEmptyFilterConfig());
        Assert.assertTrue(corsFilter.getAllowedHttpHeaders().size() == 0);
        Assert.assertTrue(corsFilter.getAllowedHttpMethods().size() == 0);
        Assert.assertTrue(corsFilter.getAllowedOrigins().size() == 0);
        Assert.assertTrue(corsFilter.getExposedHeaders().size() == 0);
        Assert.assertFalse(corsFilter.isSupportsCredentials());
        Assert.assertTrue(corsFilter.getPreflightMaxAge() == 0);
    }
    /**
     * If an init param is null, it's default value will be used.
     *
     * @throws ServletException
     */
    @Test
    public void testWithStringParserNull() throws ServletException {
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getNullFilterConfig());
        Assert.assertTrue(corsFilter.getAllowedHttpHeaders().size() == 6);
        Assert.assertTrue(corsFilter.getAllowedHttpMethods().size() == 4);
        Assert.assertTrue(corsFilter.getAllowedOrigins().size() == 0);
        Assert.assertTrue(corsFilter.isAnyOriginAllowed());
        Assert.assertTrue(corsFilter.getExposedHeaders().size() == 0);
        Assert.assertTrue(corsFilter.isSupportsCredentials());
        Assert.assertTrue(corsFilter.getPreflightMaxAge() == 1800);
    }
    @Test
    public void testValidOrigin() {
        Assert.assertTrue(CorsFilter.isValidOrigin("http://www.w3.org"));
    }
    @Test
    public void testInValidOriginCRLF() {
        Assert.assertFalse(CorsFilter.isValidOrigin("http://www.w3.org\r\n"));
    }
    @Test
    public void testInValidOriginEncodedCRLF1() {
        Assert.assertFalse(CorsFilter.isValidOrigin("http://www.w3.org%0d%0a"));
    }
    @Test
    public void testInValidOriginEncodedCRLF2() {
        Assert.assertFalse(CorsFilter.isValidOrigin("http://www.w3.org%0D%0A"));
    }
    @Test
    public void testInValidOriginEncodedCRLF3() {
        Assert.assertFalse(CorsFilter
                .isValidOrigin("http://www.w3.org%0%0d%0ad%0%0d%0aa"));
    }
    @Test
    public void testCheckInvalidCRLF1() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://www.w3.org\r\n");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    @Test
    public void testCheckInvalidCRLF2() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://www.w3.org\r\n");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    @Test
    public void testCheckInvalidCRLF3() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://www.w3.org%0d%0a");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    @Test
    public void testCheckInvalidCRLF4() throws ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                "http://www.w3.org%0D%0A");
        request.setMethod("GET");
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs
                .getDefaultFilterConfig());
        CorsFilter.CORSRequestType requestType =
                corsFilter.checkRequestType(request);
        Assert.assertEquals(CorsFilter.CORSRequestType.INVALID_CORS,
                requestType);
    }
    @Test
    public void testDecorateRequestDisabled() throws IOException,
            ServletException {
        TesterHttpServletRequest request = new TesterHttpServletRequest();
        request.setHeader(CorsFilter.REQUEST_HEADER_ORIGIN,
                TesterFilterConfigs.HTTPS_WWW_APACHE_ORG);
        request.setMethod("GET");
        TesterHttpServletResponse response = new TesterHttpServletResponse();
        CorsFilter corsFilter = new CorsFilter();
        corsFilter.init(TesterFilterConfigs.getFilterConfigDecorateRequestDisabled());
        corsFilter.doFilter(request, response, filterChain);
        Assert.assertTrue(response.getHeader(
                CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(
                "https://www.apache.org"));
        Assert.assertNull(request
                .getAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST));
        Assert.assertNull(request
                .getAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_ORIGIN));
        Assert.assertNull(request
                .getAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_HEADERS));
        Assert.assertNull(request
                .getAttribute(CorsFilter.HTTP_REQUEST_ATTRIBUTE_REQUEST_TYPE));
    }
    @Test
    public void testDestroy() {
        // Nothing to test.
        // NO-OP
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    @Override
    public void doFilter(ServletRequest request, ServletResponse response)
            throws IOException, ServletException {
        // NoOp
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    public static final String HTTPS_WWW_APACHE_ORG = "https://www.apache.org";
    public static final String HTTP_TOMCAT_APACHE_ORG =
            "http://tomcat.apache.org";
    public static final String EXPOSED_HEADERS = "X-CUSTOM-HEADER";
    /**
     * Any origin
     */
    public static final String ANY_ORIGIN = "*";
    public static final TesterServletContext mockServletContext =
            new TesterServletContext();
    public static FilterConfig getDefaultFilterConfig() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS;
        final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials =
                CorsFilter.DEFAULT_SUPPORTS_CREDENTIALS;
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getFilterConfigAnyOriginAndSupportsCredentials() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + ",PUT";
        final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials = "true";
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig
            getFilterConfigAnyOriginAndSupportsCredentialsDisabled() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + ",PUT";
        final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials = "false";
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig
            getFilterConfigSpecificOriginAndSupportsCredentialsDisabled() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + ",PUT";
        final String allowedOrigins =
                HTTP_TOMCAT_APACHE_ORG + "," + HTTPS_WWW_APACHE_ORG;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials = "false";
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getFilterConfigWithExposedHeaders() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS;
        final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS;
        final String exposedHeaders = EXPOSED_HEADERS;
        final String supportCredentials =
                CorsFilter.DEFAULT_SUPPORTS_CREDENTIALS;
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getSecureFilterConfig() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + ",PUT";
        final String allowedOrigins = HTTPS_WWW_APACHE_ORG;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials = "true";
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getNullFilterConfig() {
        return generateFilterConfig(null, null, null, null, null, null, null);
    }
    public static FilterConfig getSpecificOriginFilterConfig() {
        final String allowedOrigins =
                HTTPS_WWW_APACHE_ORG + "," + HTTP_TOMCAT_APACHE_ORG;
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + ",PUT";
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials =
                CorsFilter.DEFAULT_SUPPORTS_CREDENTIALS;
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getSpecificOriginFilterConfigNegativeMaxAge() {
        final String allowedOrigins =
                HTTPS_WWW_APACHE_ORG + "," + HTTP_TOMCAT_APACHE_ORG;
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + ",PUT";
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials =
                CorsFilter.DEFAULT_SUPPORTS_CREDENTIALS;
        final String preflightMaxAge = "-1";
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getFilterConfigInvalidMaxPreflightAge() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS;
        final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials =
                CorsFilter.DEFAULT_SUPPORTS_CREDENTIALS;
        final String preflightMaxAge = "abc";
        final String decorateRequest = CorsFilter.DEFAULT_DECORATE_REQUEST;
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getEmptyFilterConfig() {
        final String allowedHttpHeaders = "";
        final String allowedHttpMethods = "";
        final String allowedOrigins = "";
        final String exposedHeaders = "";
        final String supportCredentials = "";
        final String preflightMaxAge = "";
        final String decorateRequest = "";
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    public static FilterConfig getFilterConfigDecorateRequestDisabled() {
        final String allowedHttpHeaders =
                CorsFilter.DEFAULT_ALLOWED_HTTP_HEADERS;
        final String allowedHttpMethods =
                CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS;
        final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS;
        final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;
        final String supportCredentials =
                CorsFilter.DEFAULT_SUPPORTS_CREDENTIALS;
        final String preflightMaxAge =
                CorsFilter.DEFAULT_PREFLIGHT_MAXAGE;
        final String decorateRequest = "false";
        return generateFilterConfig(allowedHttpHeaders, allowedHttpMethods,
                allowedOrigins, exposedHeaders, supportCredentials,
                preflightMaxAge, decorateRequest);
    }
    private static FilterConfig generateFilterConfig(
            final String allowedHttpHeaders, final String allowedHttpMethods,
            final String allowedOrigins, final String exposedHeaders,
            final String supportCredentials, final String preflightMaxAge,
            final String decorateRequest) {
        FilterConfig filterConfig = new FilterConfig() {
            @Override
            public String getFilterName() {
                return "cors-filter";
            }
            @Override
            public ServletContext getServletContext() {
                return mockServletContext;
            }
            @Override
            public String getInitParameter(String name) {
                if (CorsFilter.PARAM_CORS_ALLOWED_HEADERS
                        .equalsIgnoreCase(name)) {
                    return allowedHttpHeaders;
                } else if (CorsFilter.PARAM_CORS_ALLOWED_METHODS
                        .equalsIgnoreCase(name)) {
                    return allowedHttpMethods;
                } else if (CorsFilter.PARAM_CORS_ALLOWED_ORIGINS
                        .equalsIgnoreCase(name)) {
                    return allowedOrigins;
                } else if (CorsFilter.PARAM_CORS_EXPOSED_HEADERS
                        .equalsIgnoreCase(name)) {
                    return exposedHeaders;
                } else if (CorsFilter.PARAM_CORS_SUPPORT_CREDENTIALS
                        .equalsIgnoreCase(name)) {
                    return supportCredentials;
                } else if (CorsFilter.PARAM_CORS_PREFLIGHT_MAXAGE
                        .equalsIgnoreCase(name)) {
                    return preflightMaxAge;
                } else if (CorsFilter.PARAM_CORS_REQUEST_DECORATE
                        .equalsIgnoreCase(name)) {
                    return decorateRequest;
                }
                return null;
            }
            @Override
            public Enumeration<String> getInitParameterNames() {
                return null;
            }
        };
        return filterConfig;
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    private Map<String, Object> attributes = new HashMap<>();
    private Map<String, List<String>> headers = new HashMap<>();
    private String method;
    private String contentType;
    @Override
    public Object getAttribute(String name) {
        return attributes.get(name);
    }
    @Override
    public Enumeration<String> getAttributeNames() {
        return Collections.enumeration(attributes.keySet());
    }
    @Override
    public String getCharacterEncoding() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void setCharacterEncoding(String env)
            throws UnsupportedEncodingException {
    }
    @Override
    public int getContentLength() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getContentType() {
        return this.contentType;
    }
    public void setContentType(String contentType) {
        this.contentType = contentType;
    }
    @Override
    public ServletInputStream getInputStream() throws IOException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getParameter(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Enumeration<String> getParameterNames() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String[] getParameterValues(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Map<String,String[]> getParameterMap() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getProtocol() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getScheme() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getServerName() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public int getServerPort() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public BufferedReader getReader() throws IOException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getRemoteAddr() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getRemoteHost() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void setAttribute(String name, Object o) {
        attributes.put(name, o);
    }
    @Override
    public void removeAttribute(String name) {
        attributes.remove(name);
    }
    @Override
    public Locale getLocale() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Enumeration<Locale> getLocales() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isSecure() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public RequestDispatcher getRequestDispatcher(String path) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getRealPath(String path) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public int getRemotePort() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getLocalName() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getLocalAddr() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public int getLocalPort() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getAuthType() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Cookie[] getCookies() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public long getDateHeader(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getHeader(String name) {
        List<String> list = headers.get(name);
        if (list != null) {
            return list.get(0);
            // return CorsFilter.join(new HashSet<>(list), ",");
        }
        return null;
    }
    public void setHeader(String name, String value) {
        List<String> values = new ArrayList<>();
        values.add(value);
        headers.put(name, values);
    }
    @Override
    public Enumeration<String> getHeaders(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Enumeration<String> getHeaderNames() {
        return Collections.enumeration(headers.keySet());
    }
    @Override
    public int getIntHeader(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getMethod() {
        return method;
    }
    public void setMethod(String method) {
        this.method = method;
    }
    @Override
    public String getPathInfo() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getPathTranslated() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getContextPath() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getQueryString() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getRemoteUser() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isUserInRole(String role) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Principal getUserPrincipal() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getRequestedSessionId() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getRequestURI() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public StringBuffer getRequestURL() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getServletPath() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public HttpSession getSession(boolean create) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public HttpSession getSession() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isRequestedSessionIdValid() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isRequestedSessionIdFromCookie() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isRequestedSessionIdFromURL() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isRequestedSessionIdFromUrl() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public long getContentLengthLong() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public ServletContext getServletContext() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public AsyncContext startAsync() throws IllegalStateException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public AsyncContext startAsync(ServletRequest servletRequest,
            ServletResponse servletResponse) throws IllegalStateException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isAsyncStarted() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean isAsyncSupported() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public AsyncContext getAsyncContext() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public DispatcherType getDispatcherType() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String changeSessionId() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean authenticate(HttpServletResponse response)
            throws IOException, ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void login(String username, String password)
            throws ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void logout() throws ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Collection<Part> getParts() throws IOException, ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Part getPart(String name) throws IOException, ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public <T extends HttpUpgradeHandler> T upgrade(
            Class<T> httpUpgradeHandlerClass) throws IOException {
        throw new RuntimeException("Not implemented");
    }
======= 72edec7:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

======= 72edec7:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

    private PrintWriter pw;
    private List<String> headerNames = new ArrayList<>();
    private List<String> headerValues = new ArrayList<>();
    private int status;
    @Override
    public PrintWriter getWriter() throws IOException {
        if (pw == null) {
            pw = new PrintWriter(new StringWriter());
        }
        return pw;
    }
    @Override
    public String getHeader(String name) {
        int index = headerNames.indexOf(name);
        if (index != -1) {
            return headerValues.get(index);
        }
        return null;
    }
    @Override
    public void setHeader(String name, String value) {
        int index = headerNames.indexOf(name);
        if (index != -1) {
            headerValues.set(index, value);
        } else {
            headerNames.add(name);
            headerValues.add(value);
        }
    }
    @Override
    public void addHeader(String name, String value) {
        headerNames.add(name);
        headerValues.add(value);
    }
    @Override
    public int getStatus() {
        return status;
    }
    @Override
    public void setStatus(int status) {
        this.status = status;
    }
======= 72edec7:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

======= 72edec7:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

======= 72edec7:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

======= 72edec7:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

======= 72edec7:"test/org/apache/catalina/filters/TesterHttpServletResponse.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Override
    public String getContextPath() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public ServletContext getContext(String uripath) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public int getMajorVersion() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public int getMinorVersion() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getMimeType(String file) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Set<String> getResourcePaths(String path) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public URL getResource(String path) throws MalformedURLException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public InputStream getResourceAsStream(String path) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public RequestDispatcher getRequestDispatcher(String path) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public RequestDispatcher getNamedDispatcher(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Servlet getServlet(String name) throws ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Enumeration<Servlet> getServlets() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Enumeration<String> getServletNames() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void log(String msg) {
        // NOOP
    }
    @Override
    public void log(Exception exception, String msg) {
        // NOOP
    }
    @Override
    public void log(String message, Throwable throwable) {
        // NOOP
    }
    @Override
    public String getRealPath(String path) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getServerInfo() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getInitParameter(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Enumeration<String> getInitParameterNames() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Object getAttribute(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Enumeration<String> getAttributeNames() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void setAttribute(String name, Object object) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void removeAttribute(String name) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getServletContextName() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public int getEffectiveMajorVersion() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public int getEffectiveMinorVersion() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public boolean setInitParameter(String name, String value) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Dynamic addServlet(String servletName, String className) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Dynamic addServlet(String servletName, Servlet servlet) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Dynamic addServlet(String servletName,
            Class<? extends Servlet> servletClass) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public <T extends Servlet> T createServlet(Class<T> c)
            throws ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public ServletRegistration getServletRegistration(String servletName) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Map<String, ? extends ServletRegistration> getServletRegistrations() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public javax.servlet.FilterRegistration.Dynamic addFilter(
            String filterName, String className) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public javax.servlet.FilterRegistration.Dynamic addFilter(
            String filterName, Filter filter) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public javax.servlet.FilterRegistration.Dynamic addFilter(
            String filterName, Class<? extends Filter> filterClass) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public <T extends Filter> T createFilter(Class<T> c)
            throws ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public FilterRegistration getFilterRegistration(String filterName) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Map<String, ? extends FilterRegistration> getFilterRegistrations() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public SessionCookieConfig getSessionCookieConfig() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void setSessionTrackingModes(
            Set<SessionTrackingMode> sessionTrackingModes) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void addListener(String className) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public <T extends EventListener> void addListener(T t) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void addListener(Class<? extends EventListener> listenerClass) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public <T extends EventListener> T createListener(Class<T> c)
            throws ServletException {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public JspConfigDescriptor getJspConfigDescriptor() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public ClassLoader getClassLoader() {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public void declareRoles(String... roleNames) {
        throw new RuntimeException("Not implemented");
    }
    @Override
    public String getVirtualServerName() {
        throw new RuntimeException("Not implemented");
    }
  <subsection name="Introduction">
    <p>This filter is an implementation of W3C's CORS (Cross-Origin Resource
    Sharing) <a href="http://www.w3.org/TR/cors/">specification</a>, which is a
    mechanism that enables cross-origin requests.</p>
    <p>The filter works by adding required <code>Access-Control-*</code> headers
    to HttpServletResponse object. The filter also protects against HTTP
    response splitting. If request is invalid, or is not permitted, then request
    is rejected with HTTP status code 403 (Forbidden). A
    <a href="../images/cors-flowchart.png">flowchart</a> that
    demonstrates request processing by this filter is available.</p>
    <p>The minimal configuration required to use this filter is:</p>
    <source>
  &lt;filter-name&gt;CORSFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;org.apache.catalina.filters.CORSFilter&lt;/filter-class&gt;
  &lt;filter-name>CORSFilter&lt;/filter-name&gt;
  &lt;url-pattern>/*&lt;/url-pattern&gt;
    </source>
  </subsection>
  <subsection name="Filter Class Name">
    <p>The filter class name for the CORS Filter is
    <strong><code>org.apache.catalina.filters.CORSFilter</code></strong>.</p>
  </subsection>
  <subsection name="Initialisation parameters">
    <p>The CORS Filter supports following initialisation parameters:</p>
    <attributes>
      <attribute name="cors.allowed.origins" required="false">
        <p>A list of <a href="http://tools.ietf.org/html/rfc6454">origins</a>
        that are allowed to access the resource. A <code>'*'</code> can be
        specified to enable access to resource from any origin. Otherwise, a
        whitelist of comma separated origins can be provided. Eg:
        http://www.w3.org, https://www.apache.org.
        <strong>Defaults:</strong> <code>*</code> (Any origin is allowed to
        access the resource).</p>
      </attribute>
      <attribute name="cors.allowed.methods" required="false">
        <p>A comma separated list of HTTP methods that can be used to access the
        resource, using cross-origin requests. These are the methods which will
        also be included as part of 'Access-Control-Allow-Methods' header in a
        pre-flight response. Eg: <code>GET,POST</code>.
        <strong>Defaults:</strong> <code>GET,POST,HEAD,OPTIONS</code></p>
      </attribute>
      <attribute name="cors.allowed.headers" required="false">
        <p>A comma separated list of request headers that can be used when
        making an actual request. These header will also be returned as part of
        <code>'Access-Control-Allow-Headers'</code> header in a pre-flight
        response. Eg: <code>Origin,Accept</code>. <strong>Defaults:</strong>
        <code>Origin, Accept, X-Requested-With, Content-Type,
        Access-Control-Request-Method, Access-Control-Request-Headers</code></p>
      </attribute>
      <attribute name="cors.exposed.headers" required="false">
        <p>A comma separated list of headers other than the simple response
        headers that browsers are allowed to access. These are the headers which
        will also be included as part of 'Access-Control-Expose-Headers' header
        in the pre-flight response. Eg:
        <code>X-CUSTOM-HEADER-PING,X-CUSTOM-HEADER-PONG</code>.
        <strong>Default:</strong> None. Non-simple headers are not exposed by
        default.</p>
      </attribute>
      <attribute name="cors.preflight.maxage" required="false">
        <p>The amount of seconds, browser is allowed to cache the result of the
        pre-flight request. This will be included as part of
        <code>'Access-Control-Max-Age'</code> header in the pre-flight response.
        A negative value will prevent CORS Filter from adding this response
        header from pre-flight response. <strong>Defaults:</strong>
        <code>1800</code></p>
      </attribute>
      <attribute name="cors.support.credentials" required="false">
        <p>A flag that indicates whether the resource supports user credentials.
        This flag is exposed as part of
        <code>'Access-Control-Allow-Credentials'</code> header in a pre-flight
        response. It helps browser determine whether or not an actual request
        can be made using credentials. <strong>Defaults:</strong>
        <code>true</code></p>
      </attribute>
      <attribute name="cors.request.decorate" required="false">
        <p>A flag to control if CORS specific attributes should be added to
        HttpServletRequest object or not. <strong>Defaults:</strong>
        <code>true</code></p>
      </attribute>
    </attributes>
    <p>Here's an example of a more advanced configuration, that overrides
    defaults:</p>
    <source>
  &lt;filter-name&gt;CORSFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;org.apache.catalina.filters.CORSFilter&lt;/filter-class&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt;
    &lt;param-value&gt;*&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;cors.allowed.methods&lt;/param-name&gt;
    &lt;param-value&gt;GET,POST,HEAD,OPTIONS,PUT&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;cors.allowed.headers&lt;/param-name&gt;
    &lt;param-value&gt;Content-Type,X-Requested-With,accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;cors.exposed.headers&lt;/param-name&gt;
    &lt;param-value&gt;Access-Control-Allow-Origin,Access-Control-Allow-Credentials&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;cors.support.credentials&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;cors.preflight.maxage&lt;/param-name&gt;
    &lt;param-value&gt;10&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;filter-name&gt;CORS Filter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    </source>
  </subsection>
  <subsection name="CORS Filter and HttpServletRequest attributes">
    <p>CORS Filter adds information about a request, in the HttpServletRequest
    object, for consumption downstream. Following attributes are set, if
    <code>cors.request.decorate</code> initialisation parameter is
    <code>true</code>:</p>
    <ul>
      <li><strong>cors.isCorsRequest:</strong> Flag to determine if a request is
          a CORS request.</li>
      <li><strong>cors.request.origin:</strong> The Origin URL, i.e. the URL of
          the page from where the request is originated.</li>
      <li><strong>cors.request.type:</strong> Type of CORS request. Possible
          values:
        <ul>
          <li><code>SIMPLE</code>: A request which is not preceded by a
              pre-flight request.</li>
          <li><code>ACTUAL</code>: A request which is preceded by a pre-flight
              request.</li>
          <li><code>PRE_FLIGHT</code>: A pre-flight request.</li>
          <li><code>NOT_CORS</code>: A normal same-origin request.</li>
          <li><code>INVALID_CORS</code>: A cross-origin request, which is
              invalid.</li>
        </ul>
      </li>
      <li><strong>cors.request.headers:</strong> Request headers sent as
          'Access-Control-Request-Headers' header, for a pre-flight request.
          </li>
    </ul>
  </subsection>
  <subsection name="Introduction">
    <p>This filter triggers parameters parsing in a request and rejects the
    request if some parameters were skipped during parameter parsing because
    of parsing errors or request size limitations (such as
    <code>maxParameterCount</code> attribute in a
    <a href="http.html">Connector</a>).
    This filter can be used to ensure that none parameter values submitted by
    client are lost.</p>
    <p>Note that parameter parsing may consume the body of an HTTP request, so
    caution is needed if the servlet protected by this filter uses
    <code>request.getInputStream()</code> or <code>request.getReader()</code>
    calls. In general the risk of breaking a web application by adding this
    filter is not so high, because parameter parsing does check content type
    of the request before consuming the request body.</p>
    <p>Note, that for the POST requests to be parsed correctly, a
    <code>SetCharacterEncodingFilter</code> filter must be configured above
    this one. See CharacterEncoding page in the FAQ for details.</p>
    <p>The request is rejected with HTTP status code 400 (Bad Request).</p>
  </subsection>
  <subsection name="Filter Class Name">
    <p>The filter class name for the Failed Request Filter is
    <strong><code>org.apache.catalina.filters.FailedRequestFilter</code>
    </strong>.</p>
  </subsection>
  <subsection name="Initialisation parameters">
    <p>The Failed Request Filter does not support any initialization parameters.</p>
  </subsection>

======= 712a351:"java/org/apache/catalina/ant/DeployTask.java"

======= 712a351:"java/org/apache/catalina/ant/DeployTask.java"

======= 712a351:"java/org/apache/catalina/ant/DeployTask.java"

        StringBuilder sb = createQueryString("/deploy");

======= 6d789fe:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

                request.removeNote(Constants.REQ_SSOID_NOTE);

======= 6c6b25c:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

        private HandshakeStatus handshakeStatus;
        private Status resultStatus;
======= 6c6b25c:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

                handshakeStatus = sslEngine.getHandshakeStatus();
                resultStatus = Status.OK;
======= 6c6b25c:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

                            checkResult(r, true);
======= 6c6b25c:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

                            if (socketReadBuffer.position() == 0 ||
                                    resultStatus == Status.BUFFER_UNDERFLOW) {
======= 6c6b25c:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

                            checkResult(r, false);
======= 6c6b25c:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"

        private void checkResult(SSLEngineResult result, boolean wrap)
                throws SSLException {
            handshakeStatus = result.getHandshakeStatus();
            resultStatus = result.getStatus();
            if (resultStatus != Status.OK &&
                    (wrap || resultStatus != Status.BUFFER_UNDERFLOW)) {
======= 6c6b25c:"java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java"


======= cccd0ac:"java/org/apache/catalina/connector/Request.java"

                    ApplicationPart part = new ApplicationPart(item, location);
======= cccd0ac:"java/org/apache/catalina/core/ApplicationPart.java"

======= cccd0ac:"java/org/apache/catalina/core/ApplicationPart.java"

======= cccd0ac:"java/org/apache/catalina/core/ApplicationPart.java"

    private final File location;
    public ApplicationPart(FileItem fileItem, File location) {
        this.location = location;
======= cccd0ac:"java/org/apache/catalina/core/ApplicationPart.java"

            file = new File(location, fileName);

======= 65ab66e:"java/org/apache/jasper/compiler/TagPluginManager.java"

                Class<?> pluginClass =
                        ctxt.getClassLoader().loadClass(pluginClassStr);

======= 6272fca:"java/org/apache/tomcat/spdy/NetSupportSocket.java"


======= c25112b:"java/org/apache/coyote/spdy/SpdyProxyProtocol.java"

    private boolean compress = false;
======= c25112b:"java/org/apache/coyote/spdy/SpdyProxyProtocol.java"

        spdyContext.setTlsComprression(false, compress);
======= c25112b:"java/org/apache/coyote/spdy/SpdyProxyProtocol.java"

    public boolean isCompress() {
        return compress;
    }
    public void setCompress(boolean compress) {
        this.compress = compress;
    }
      <add>
        Experimental support for SDPY. Includes contributions from Sheldon Shao.
        (costin)
      </add>

======= f763975:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            // Mark the current buffer position
        }
        if (parsingRequestLinePhase == 6) {
======= f763975:"test/org/apache/catalina/startup/SimpleHttpClient.java"

    public static final String CR = "\r";
    public static final String LF = "\n";
    public static final String CRLF = CR + LF;
======= f763975:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

    /**
     * Test case for https://issues.apache.org/bugzilla/show_bug.cgi?id=54947
     */
    @Test
    public void testBug54947() {
        Bug54947Client client = new Bug54947Client();
        client.doRequest();
        assertTrue(client.isResponse200());
        assertTrue(client.isResponseBodyOK());
    }
    /**
     * Bug 54947 test client.
     */
    private class Bug54947Client extends SimpleHttpClient {
        private Exception doRequest() {
            Tomcat tomcat = getTomcatInstance();
            Context root = tomcat.addContext("", TEMP_DIR);
            Tomcat.addServlet(root, "Bug54947", new TesterServlet());
            root.addServletMapping("/test", "Bug54947");
            try {
                tomcat.start();
                setPort(tomcat.getConnector().getLocalPort());
                // Open connection
                connect();
                String[] request = new String[2];
                request[0] = "GET http://localhost:8080/test HTTP/1.1" + CR;
                request[1] = LF +
                        "Connection: close" + CRLF +
                        CRLF;
                setRequest(request);
                processRequest(); // blocks until response has been read
                // Close the connection
                disconnect();
            } catch (Exception e) {
                return e;
            }
            return null;
        }
        @Override
        public boolean isResponseBodyOK() {
            if (getResponseBody() == null) {
                return false;
            }
            if (!getResponseBody().contains("OK")) {
                return false;
            }
            return true;
        }
    }

======= 0de078e:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

======= 0de078e:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

 * Test FORM authentication for sessions that do and do not use cookies.
 *
 * 1. A client that can accept and respond to a Set-Cookie for JSESSIONID
 *    will be able to maintain its authenticated session, no matter whether
 *    the session ID is changed once, many times, or not at all.
 *
 * 2. A client that cannot accept cookies will only be able to maintain a
 *    persistent session IF the server sends the correct (current) jsessionid
 *    as a path parameter appended to ALL urls within its response. That is
 *    achievable with servlets, jsps, jstl (all of which which can ask for an
 *    encoded url to be inserted into the dynamic web page). It cannot work
 *    with static html.
 *    note: this test class uses the tomcat somaple jsps, which conform.
 *
 * 3. Therefore, any webapp that MIGHT need to authenticate a client that
 *    does not accept cookies MUST generate EVERY protected resource url
 *    dynamically (so that it will include the current session ID).
 *
 * 4. Any webapp that cannot satify case 3 MUST turn off
 *    changeSessionIdOnAuthentication for its Context and thus degrade the
 *    session fixation protection for ALL of its clients.
 *    note from MarkT: Not sure I agree with this. If the URLs aren't
 *      being encoded, then the session is going to break regardless of
 *      whether or not the session ID changes.
 *
 * Unlike a "proper browser", this unit test class does a quite lot of
 * screen-scraping and cheating of headers and urls (not very elegant,
 * but it makes no claims to generality).
 *
 */
    // these should really be singletons to be type-safe,
    // we are in a unit test and don't need to paranoid.
    protected static final boolean USE_100_CONTINUE = true;
    protected static final boolean NO_100_CONTINUE = !USE_100_CONTINUE;
    protected static final boolean CLIENT_USE_COOKIES = true;
    protected static final boolean CLIENT_NO_COOKIES = !CLIENT_USE_COOKIES;
    protected static final boolean SERVER_USE_COOKIES = true;
    protected static final boolean SERVER_NO_COOKIES = !SERVER_USE_COOKIES;
    protected static final boolean SERVER_CHANGE_SESSID = true;
    protected static final boolean SERVER_FREEZE_SESSID = !SERVER_CHANGE_SESSID;
    // minimum session timeout
    private static final int TIMEOUT_MINS = 1;
    private static final long TIMEOUT_DELAY_MSECS =
                            (((TIMEOUT_MINS * 60) + 10) * 1000);
    private FormAuthClient client;
    // first, a set of tests where the server uses a cookie to carry
    // the current session ID during and after authentication, and
    // the client is prepared to return cookies with each request
    public void testGetWithCookies() throws Exception {
        doTest("GET", "GET", NO_100_CONTINUE,
                CLIENT_USE_COOKIES, SERVER_USE_COOKIES, SERVER_CHANGE_SESSID);
    public void testPostNoContinueWithCookies() throws Exception {
        doTest("POST", "GET", NO_100_CONTINUE,
                CLIENT_USE_COOKIES, SERVER_USE_COOKIES, SERVER_CHANGE_SESSID);
    public void testPostWithContinueAndCookies() throws Exception {
        doTest("POST", "GET", USE_100_CONTINUE,
               CLIENT_USE_COOKIES, SERVER_USE_COOKIES, SERVER_CHANGE_SESSID);
    public void testPostNoContinuePostRedirectWithCookies() throws Exception {
        doTest("POST", "POST", NO_100_CONTINUE,
                CLIENT_USE_COOKIES, SERVER_USE_COOKIES, SERVER_CHANGE_SESSID);
    public void testPostWithContinuePostRedirectWithCookies() throws Exception {
        doTest("POST", "POST", USE_100_CONTINUE,
                CLIENT_USE_COOKIES, SERVER_USE_COOKIES, SERVER_CHANGE_SESSID);
    }
    // next, a set of tests where the server Context is configured to never
    // use cookies and the session ID is only carried as a url path parameter
    // Bug 53584
    @Test
    public void testGetNoServerCookies() throws Exception {
        doTest("GET", "GET", NO_100_CONTINUE,
                CLIENT_NO_COOKIES, SERVER_NO_COOKIES, SERVER_CHANGE_SESSID);
    }
    @Test
    public void testPostNoContinueNoServerCookies() throws Exception {
        doTest("POST", "GET", NO_100_CONTINUE,
                CLIENT_USE_COOKIES, SERVER_NO_COOKIES, SERVER_CHANGE_SESSID);
    }
    @Test
    public void testPostWithContinueNoServerCookies() throws Exception {
        doTest("POST", "GET", USE_100_CONTINUE,
                CLIENT_USE_COOKIES, SERVER_NO_COOKIES, SERVER_CHANGE_SESSID);
    }
    // variant of Bug 49779
    @Test
    public void testPostNoContinuePostRedirectNoServerCookies()
            throws Exception {
        doTest("POST", "POST", NO_100_CONTINUE,
                CLIENT_USE_COOKIES, SERVER_NO_COOKIES, SERVER_CHANGE_SESSID);
    // variant of Bug 49779
    @Test
    public void testPostWithContinuePostRedirectNoServerCookies()
            throws Exception {
        doTest("POST", "POST", USE_100_CONTINUE,
                CLIENT_USE_COOKIES, SERVER_NO_COOKIES, SERVER_CHANGE_SESSID);
    }
    // next, a set of tests where the server Context uses cookies,
    // but the client refuses to return them and tries to use
    // the session ID if carried as a url path parameter
    @Test
    public void testGetNoClientCookies() throws Exception {
        doTest("GET", "GET", NO_100_CONTINUE,
                CLIENT_NO_COOKIES, SERVER_USE_COOKIES, SERVER_CHANGE_SESSID);
    }
    @Test
    public void testPostNoContinueNoClientCookies() throws Exception {
        doTest("POST", "GET", NO_100_CONTINUE,
                CLIENT_NO_COOKIES, SERVER_USE_COOKIES, SERVER_CHANGE_SESSID);
    }
    @Test
    public void testPostWithContinueNoClientCookies() throws Exception {
        doTest("POST", "GET", USE_100_CONTINUE,
                CLIENT_NO_COOKIES, SERVER_USE_COOKIES, SERVER_CHANGE_SESSID);
    }
    // variant of Bug 49779
    @Test
    public void testPostNoContinuePostRedirectNoClientCookies()
            throws Exception {
        doTest("POST", "POST", NO_100_CONTINUE,
                CLIENT_NO_COOKIES, SERVER_USE_COOKIES, SERVER_CHANGE_SESSID);
    }
    // variant of Bug 49779
    @Test
    public void testPostWithContinuePostRedirectNoClientCookies()
            throws Exception {
        doTest("POST", "POST", USE_100_CONTINUE,
                CLIENT_NO_COOKIES, SERVER_USE_COOKIES, SERVER_CHANGE_SESSID);
    }
    // finally, a set of tests to explore quirky situations
    // but there is not need to replicate all the scenarios above.
    @Test
    public void testNoChangedSessidWithCookies() throws Exception {
        doTest("GET", "GET", NO_100_CONTINUE,
                CLIENT_USE_COOKIES, SERVER_USE_COOKIES,
                SERVER_FREEZE_SESSID);
    }
    @Test
    public void testNoChangedSessidWithoutCookies() throws Exception {
        doTest("GET", "GET", NO_100_CONTINUE,
                CLIENT_NO_COOKIES, SERVER_USE_COOKIES,
                SERVER_FREEZE_SESSID);
    }
    @Test
    public void testTimeoutWithoutCookies() throws Exception {
        String protectedUri = doTest("GET", "GET", NO_100_CONTINUE,
                CLIENT_NO_COOKIES, SERVER_USE_COOKIES,
                SERVER_FREEZE_SESSID);
        // wait long enough for my session to expire
        Thread.sleep(TIMEOUT_DELAY_MSECS);
        // then try to continue using the expired session to get the
        // protected resource once more.
        // should get login challenge or timeout status 408
        doTestProtected("GET", protectedUri, NO_100_CONTINUE,
                FormAuthClient.LOGIN_REQUIRED, 1);
    }
    /*
     * Choreograph the steps of the test dialogue with the server
     *  1. while not authenticated, try to access a protected resource
     *  2. respond to the login challenge with good credentials
     *  3. after successful login, follow the redirect to the original page
     *  4. repeatedly access the protected resource to demonstrate
     *     persistence of the authenticated session
     *
     * @param resourceMethod HTTP method for accessing the protected resource
     * @param redirectMethod HTTP method for the login FORM reply
     * @param useContinue whether the HTTP client should expect a 100 Continue
     * @param clientShouldUseCookies whether the client should send cookies
     * @param serverWillUseCookies whether the server should send cookies
     *
     */
    private String doTest(String resourceMethod, String redirectMethod,
            boolean useContinue, boolean clientShouldUseCookies,
            boolean serverWillUseCookies, boolean serverWillChangeSessid)
            throws Exception {
        client = new FormAuthClient(clientShouldUseCookies,
                serverWillUseCookies, serverWillChangeSessid);
        // First request for protected resource gets the login page
        client.doResourceRequest(resourceMethod, false, null, null);
        String loginUri = client.extractBodyUri(
                FormAuthClient.LOGIN_PARAM_TAG,
                FormAuthClient.LOGIN_RESOURCE);
        String originalSessionId = null;
        if (serverWillUseCookies && clientShouldUseCookies) {
            originalSessionId = client.getSessionId();
        }
        else {
            originalSessionId = client.extractPathSessionId(loginUri);
        }
        // Second request replies to the login challenge
        client.doLoginRequest(loginUri);
        assertTrue("login failed " + client.getResponseLine(),
                client.isResponse302());
        String redirectUri = client.getRedirectUri();
        // Third request - the login was successful so
        // follow the redirect to the protected resource
        client.doResourceRequest(redirectMethod, true, redirectUri, null);
        String protectedUri = client.extractBodyUri(
                FormAuthClient.RESOURCE_PARAM_TAG,
                FormAuthClient.PROTECTED_RESOURCE);
        String newSessionId = null;
        if (serverWillUseCookies && clientShouldUseCookies) {
            newSessionId = client.getSessionId();
        }
        else {
            newSessionId = client.extractPathSessionId(protectedUri);
        }
        boolean sessionIdIsChanged = !(originalSessionId.equals(newSessionId));
        assertTrue(sessionIdIsChanged == serverWillChangeSessid);
        // Subsequent requests - keep accessing the protected resource
        doTestProtected(resourceMethod, protectedUri, useContinue,
                FormAuthClient.LOGIN_SUCCESSFUL, 5);
        return protectedUri;        // in case more requests will be issued
    }
    /*
     * Repeatedly access the protected resource after the client has
     * successfully logged-in to the webapp. The current session attributes
     * will be used and cannot be changed.
     *  3. after successful login, follow the redirect to the original page
     *  4. repeatedly access the protected resource to demonstrate
     *     persistence of the authenticated session
     *
     * @param resourceMethod HTTP method for accessing the protected resource
     * @param protectedUri to access (with or withour sessionid)
     * @param useContinue whether the HTTP client should expect a 100 Continue
     * @param clientShouldUseCookies whether the client should send cookies
     * @param serverWillUseCookies whether the server should send cookies
     *
     */
    private void doTestProtected(String resourceMethod, String protectedUri,
            boolean useContinue, int phase, int repeatCount)
            throws Exception {
        // Subsequent requests - keep accessing the protected resource
        for (int i = 0; i < repeatCount; i++) {
            client.doResourceRequest(resourceMethod, false, protectedUri, null);
            assertTrue(client.isResponseBodyOK(phase));
    /*
     * Encapsulate the logic needed to run a suitably-configured tomcat
     * instance, send it an HTTP request and process the server response
     */
        protected static final String LOGIN_PARAM_TAG = "action=";
        protected static final String LOGIN_RESOURCE = "j_security_check";
        protected static final String LOGIN_REPLY =
                "j_username=tomcat&j_password=tomcat";
        protected static final String PROTECTED_RELATIVE_PATH =
                "/examples/jsp/security/protected/";
        protected static final String PROTECTED_RESOURCE = "index.jsp";
        private static final String PROTECTED_RESOURCE_URL =
                PROTECTED_RELATIVE_PATH + PROTECTED_RESOURCE;
        protected static final String RESOURCE_PARAM_TAG = "href=";
        private static final char PARAM_DELIM = '?';
        // primitive tracking of the test phases to verify the HTML body
        protected static final int LOGIN_REQUIRED = 1;
        protected static final int REDIRECTING = 2;
        protected static final int LOGIN_SUCCESSFUL = 3;
        // todo: forgot this change and making it up again!
        protected final String SESSION_PARAMETER_START =
            SESSION_PARAMETER_NAME + "=";
        private FormAuthClient(boolean clientShouldUseCookies,
                boolean serverShouldUseCookies,
                boolean serverShouldChangeSessid) throws Exception {
            setUseCookies(clientShouldUseCookies);
            ctx.setCookies(serverShouldUseCookies);
======= 0de078e:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            // perhaps this does not work until tomcat has started?
            ctx.setSessionTimeout(TIMEOUT_MINS);
            // Valve pipeline is only established after tomcat starts
            Valve[] valves = ctx.getPipeline().getValves();
            for (Valve valve : valves) {
                if (valve instanceof AuthenticatorBase) {
                    ((AuthenticatorBase)valve)
                            .setChangeSessionIdOnAuthentication(
                                                serverShouldChangeSessid);
                    break;
                }
            }
        private void doLoginRequest(String loginUri) throws Exception {
            doResourceRequest("POST", true,
                    PROTECTED_RELATIVE_PATH + loginUri, LOGIN_REPLY);
        }
        /*
         * Prepare the resource request HTTP headers and issue the request.
         * Three kinds of uri are supported:
         *   1. fully qualified uri.
         *   2. minimal uri without webapp path.
         *   3. null - use the default protected resource
         * Cookies are sent if available and supported by the test. Otherwise, the
         * caller is expected to have provided a session id as a path parameter.
         */
        private void doResourceRequest(String method, boolean isFullQualUri,
                String resourceUri, String requestTail) throws Exception {
            // build the HTTP request while assembling the uri
            requestHead.append(method).append(" ");
            if (isFullQualUri) {
                requestHead.append(resourceUri);
            }
            else {
                if (resourceUri == null) {
                    // the default relative url
                    requestHead.append(PROTECTED_RESOURCE_URL);
                }
                else {
                    requestHead.append(PROTECTED_RELATIVE_PATH)
                            .append(resourceUri);
                }
                if ("GET".equals(method)) {
                    requestHead.append("?role=bar");
                }
            // next, add the constant http headers
            // then any optional http headers
            if (getUseCookies()) {
                String sessionId = getSessionId();
                if (sessionId != null) {
                    requestHead.append("Cookie: ")
                            .append(SESSION_COOKIE_NAME)
                            .append("=").append(sessionId).append(CRLF);
                }
            // finally, for posts only, deal with the request content
                if (requestTail == null) {
                    requestTail = "role=bar";
                }
                // calculate post data length
                String len = Integer.toString(requestTail.length());
                requestHead.append("Content-length: ").append(len).append(CRLF);
            // always put an empty line after the headers
            request[1] = requestTail;
        /*
         * verify the server response html body is the page we expect,
         * based on the dialogue position within doTest.
         */
            return isResponseBodyOK(requestCount);
        }
        /*
         * verify the server response html body is the page we expect,
         * based on the dialogue position given by the caller.
         */
        public boolean isResponseBodyOK(int testPhase) {
            switch (testPhase) {
                case LOGIN_REQUIRED:
                    // First request should return in the login page
                    assertContains(getResponseBody(),
                            "<title>Login Page for Examples</title>");
                    return true;
                case REDIRECTING:
                    // Second request should result in redirect without a body
                    return true;
                default:
                    // Subsequent requests should return in the protected page.
                    // Our role parameter should be appear in the page.
                    String body = getResponseBody();
                    assertContains(body,
                            "<title>Protected Page for Examples</title>");
                    assertContains(body,
                            "<input type=\"text\" name=\"role\" value=\"bar\"");
                    return true;
            }
        }
        /*
         * Scan the server response body and extract the given
         * url, including any path elements.
         */
        private String extractBodyUri(String paramTag, String resource) {
            extractUriElements();
            List<String> elements = getResponseBodyUriElements();
            String fullPath = null;
            for (String element : elements) {
                int ix = element.indexOf(paramTag);
                if (ix > -1) {
                    ix += paramTag.length();
                    char delim = element.charAt(ix);
                    int iy = element.indexOf(resource, ix);
                    if (iy > -1) {
                        int lastCharIx = element.indexOf(delim, iy);
                        fullPath = element.substring(iy, lastCharIx);
                        // remove any trailing parameters
                        int paramDelim = fullPath.indexOf(PARAM_DELIM);
                        if (paramDelim > -1) {
                            fullPath = fullPath.substring(0, paramDelim);
                        }
                        break;
                    }
                }
            return fullPath;
    /*
     * extract the session id path element (if it exists in the given url)
     */
    private String extractPathSessionId(String url) {
        String sessionId = null;
        int iStart = url.indexOf(SESSION_PARAMETER_START);
        if (iStart > -1) {
            iStart += SESSION_PARAMETER_START.length();
            String remainder = url.substring(iStart);
            StringTokenizer parser =
                    new StringTokenizer(remainder, SESSION_PATH_PARAMETER_TAILS);
            if (parser.hasMoreElements()) {
                sessionId = parser.nextToken();
            }
            else {
                sessionId = url.substring(iStart);
            }
        }
        return sessionId;
    }
                fail("Response number " + requestCount
                        + ": body check failure.\n"

======= 76a7098:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

    public AbstractOutputBuffer() {
        // Cause loading of Constants
        int foo = Constants.HTTP_11_BYTES[0];
    }

======= 7558546:"java/org/apache/catalina/connector/Request.java"

                                if (enc == null) {
                                    encoding = Parameters.DEFAULT_ENCODING;
                                } else {
                                    encoding = enc;
                                }
======= 7558546:"test/org/apache/catalina/connector/TestRequest.java"

======= 7558546:"test/org/apache/catalina/connector/TestRequest.java"

======= 7558546:"test/org/apache/catalina/connector/TestRequest.java"

        HttpURLConnection conn = getConnection("http://localhost:" + getPort() + "/");
======= 7558546:"test/org/apache/catalina/connector/TestRequest.java"

        HttpURLConnection conn = getConnection("http://localhost:" + getPort() + "/");
======= 7558546:"test/org/apache/catalina/connector/TestRequest.java"

    @Test
    public void testBug54984() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        Context root = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        root.setAllowCasualMultipartParsing(true);
        Tomcat.addServlet(root, "Bug54984", new Bug54984Servlet());
        root.addServletMapping("/", "Bug54984");
        tomcat.start();
        HttpURLConnection conn = getConnection("http://localhost:" + getPort()
                + "/parseParametersBeforeParseParts");
        prepareRequestBug54984(conn);
        checkResponseBug54984(conn);
        conn.disconnect();
        conn = getConnection("http://localhost:" + getPort() + "/");
        prepareRequestBug54984(conn);
        checkResponseBug54984(conn);
        conn.disconnect();
    }
======= 7558546:"test/org/apache/catalina/connector/TestRequest.java"

    private HttpURLConnection getConnection(String query) throws IOException {
======= 7558546:"test/org/apache/catalina/connector/TestRequest.java"

    private static class Bug54984Servlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            req.setCharacterEncoding("UTF-8");
            if (req.getRequestURI().endsWith("parseParametersBeforeParseParts")) {
                req.getParameterNames();
            }
            req.getPart("part");
            resp.getWriter().println("Part " + req.getParameter("part"));
        }
    }
    private void prepareRequestBug54984(HttpURLConnection conn)
            throws Exception {
        String boundary = "-----" + System.currentTimeMillis();
        conn.setRequestProperty("Content-Type",
                "multipart/form-data; boundary=" + boundary);
        PrintWriter writer = null;
        try {
            writer = new PrintWriter(new OutputStreamWriter(
                    conn.getOutputStream(), "UTF-8"), true);
            writer.append("--" + boundary).append("\r\n");
            writer.append("Content-Disposition: form-data; name=\"part\"\r\n");
            writer.append("Content-Type: text/plain; charset=UTF-8\r\n");
            writer.append("\r\n");
            writer.append("").append("\r\n");
            writer.flush();
            writer.append("\r\n");
            writer.flush();
            writer.append("--" + boundary + "--").append("\r\n");
        } finally {
            if (writer != null) {
                writer.close();
            }
        }
    }
    private void checkResponseBug54984(HttpURLConnection conn)
            throws Exception {
        List<String> response = new ArrayList<>();
        int status = conn.getResponseCode();
        if (status == HttpURLConnection.HTTP_OK) {
            BufferedReader reader = null;
            try {
                reader = new BufferedReader(new InputStreamReader(
                        conn.getInputStream()));
                String line = null;
                while ((line = reader.readLine()) != null) {
                    response.add(line);
                }
                assertTrue(response.contains("Part "));
            } catch (Exception e) {
                if (reader != null) {
                    reader.close();
                }
            }
        } else {
            fail("OK status was expected: " + status);
        }
    }

======= 3960b22:"test/org/apache/catalina/connector/TestCoyoteAdapter.java"

======= 3960b22:"test/org/apache/catalina/connector/TestCoyoteAdapter.java"

======= 3960b22:"test/org/apache/catalina/connector/TestCoyoteAdapter.java"

    @Test
    public void testBug54928() throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
        AsyncServlet servlet = new AsyncServlet();
        Wrapper w = Tomcat.addServlet(ctx, "async", servlet);
        w.setAsyncSupported(true);
        ctx.addServletMapping("/async", "async");
        tomcat.start();
        SimpleHttpClient client = new SimpleHttpClient() {
            @Override
            public boolean isResponseBodyOK() {
                return true;
            }
        };
        String request = "GET /async HTTP/1.1" + SimpleHttpClient.CRLF +
                "Host: a" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF;
        client.setPort(getPort());
        client.setRequest(new String[] {request});
        client.connect();
        client.sendRequest();
        for (int i = 0; i < 10; i++) {
            System.out.println(client.readLine());
        }
        client.disconnect();
        // Wait for server thread to stop
        while (servlet.getThread().isAlive()) {
            Thread.sleep(250);
        }
    }
    private static class AsyncServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        // This is a hack that won't work generally as servlets are expected to
        // handle more than one request.
        private Thread t;
        public Thread getThread() {
            return t;
        }
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setContentType("text/plain");
            resp.setCharacterEncoding("UTF-8");
            final OutputStream os = resp.getOutputStream();
            final AsyncContext asyncCtxt = req.startAsync();
            asyncCtxt.setTimeout(3000);
            t = new Thread(new Runnable() {
                @Override
                public void run() {
                    while (true) {
                        try {
                            os.write("TEST".getBytes(B2CConverter.UTF_8));
                            os.flush();
                            Thread.sleep(1000);
                        } catch (Exception e) {
                            asyncCtxt.complete();
                            break;
                        }
                    }
                }
            });
            t.setName("testBug54928");
            t.start();
        }
    }

======= cdbf6b0:"java/org/apache/catalina/mapper/Mapper.java"

                String name;
                if (path.length() == 0) {
                    // Special case for the Context Root mapping which is
                    // treated as an exact match
                    name = "/";
                } else {
                    name = path;
                }

======= aabef09:"java/org/apache/catalina/core/ApplicationContext.java"

        JspConfigDescriptor jspConfigDescriptor = context
                .getJspConfigDescriptor();
        if (jspConfigDescriptor.getJspPropertyGroups().isEmpty()
                && jspConfigDescriptor.getTaglibs().isEmpty()) {
            return null;
        } else {
            return jspConfigDescriptor;
        }
======= aabef09:"test/org/apache/catalina/core/TestApplicationContext.java"

    @Test
    public void testGetJspConfigDescriptor() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp");
        // app dir is relative to server home
        StandardContext standardContext = (StandardContext) tomcat.addWebapp(
                null, "/test", appDir.getAbsolutePath());
        ServletContext servletContext = standardContext.getServletContext();
        Assert.assertNull(servletContext.getJspConfigDescriptor());
        tomcat.start();
        Assert.assertNotNull(servletContext.getJspConfigDescriptor());
    }

======= 41462ca:"java/org/apache/catalina/core/ApplicationContext.java"

        this.sessionCookieConfig = new ApplicationSessionCookieConfig(context);
======= 41462ca:"java/org/apache/catalina/core/ApplicationContext.java"

    private SessionCookieConfig sessionCookieConfig;
======= 41462ca:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

    /**
     * The string manager for this package.
     */
    private static final StringManager sm = StringManager
            .getManager(Constants.Package);
======= 41462ca:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

    private StandardContext context;
    public ApplicationSessionCookieConfig(StandardContext context) {
        this.context = context;
    }
======= 41462ca:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "comment",
                    context.getPath()));
        }
        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "domain name",
                    context.getPath()));
        }
        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "HttpOnly",
                    context.getPath()));
        }
        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "max age",
                    context.getPath()));
        }
        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "name",
                    context.getPath()));
        }
        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "path",
                    context.getPath()));
        }
        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
            throw new IllegalStateException(sm.getString(
                    "applicationSessionCookieConfig.ise", "secure",
                    context.getPath()));
        }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private ApplicationSessionCookieConfig applicationSessionCookieConfig;
    private final CustomContext context = new CustomContext();
    @Before
    public void setUp() throws Exception {
        applicationSessionCookieConfig = new ApplicationSessionCookieConfig(
                context);
    }
    @Test
    public void testSetCommentInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setComment("test");
        assertTrue(applicationSessionCookieConfig.getComment().equals("test"));
    }
    @Test(expected = IllegalStateException.class)
    public void testSetCommentNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setComment("test");
    }
    @Test
    public void testSetDomainInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setDomain("test");
        assertTrue(applicationSessionCookieConfig.getDomain().equals("test"));
    }
    @Test(expected = IllegalStateException.class)
    public void testSetDomainNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setDomain("test");
    }
    @Test
    public void testSetHttpOnlyInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setHttpOnly(true);
        assertTrue(applicationSessionCookieConfig.isHttpOnly());
    }
    @Test(expected = IllegalStateException.class)
    public void testSetHttpOnlyNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setHttpOnly(true);
    }
    @Test
    public void testSetMaxAgeInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setMaxAge(1);
        assertTrue(applicationSessionCookieConfig.getMaxAge() == 1);
    }
    @Test(expected = IllegalStateException.class)
    public void testSetMaxAgeNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setMaxAge(1);
    }
    @Test
    public void testSetNameInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setName("test");
        assertTrue(applicationSessionCookieConfig.getName().equals("test"));
    }
    @Test(expected = IllegalStateException.class)
    public void testSetNameNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setName("test");
    }
    @Test
    public void testSetPathInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setPath("test");
        assertTrue(applicationSessionCookieConfig.getPath().equals("test"));
    }
    @Test(expected = IllegalStateException.class)
    public void testSetPathNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setPath("test");
    }
    @Test
    public void testSetSecureInitPhase() {
        context.setState(LifecycleState.STARTING_PREP);
        applicationSessionCookieConfig.setSecure(true);
        assertTrue(applicationSessionCookieConfig.isSecure());
    }
    @Test(expected = IllegalStateException.class)
    public void testSetSecureNotInitPhase() {
        context.setState(LifecycleState.STARTED);
        applicationSessionCookieConfig.setSecure(true);
    }
    private static class CustomContext extends StandardContext {
        private LifecycleState state;
        @Override
        public LifecycleState getState() {
            return state;
        }
        @Override
        public synchronized void setState(LifecycleState state) {
            this.state = state;
        }
    }

======= 7aeab0e:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

    // Skip any LWS and return the next char
    private static int skipLws(StringReader input, boolean withReset)
            throws IOException {
        if (withReset) {
            input.mark(1);
        }
        while (c == 32 || c == 9 || c == 10 || c == 13) {
            if (withReset) {
                input.mark(1);
            }
        if (withReset) {
            input.reset();
        }
        return c;
    }
    private static SkipConstantResult skipConstant(StringReader input,
            String constant) throws IOException {
        int len = constant.length();
        int c = skipLws(input, false);
======= 7aeab0e:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        int c = skipLws(input, false);
======= 7aeab0e:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        int c = skipLws(input, false);
======= 7aeab0e:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        // Go back so first non-LWS character is available to be read again
        int c = skipLws(input, true);
======= 7aeab0e:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        int c = skipLws(input, false);
======= 7aeab0e:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

        int c = skipLws(input, false);
======= 7aeab0e:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

======= 7aeab0e:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

    private static final String[] LWS_VALUES = new String[] {
            "", " ", "\t", "\r", "\n", "\r\n", " \r", " \n", " \r\n",
            "\r ", "\n ", "\r\n ", " \r ", " \n ", " \r\n " };
======= 7aeab0e:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

        for (String lws : LWS_VALUES) {
            doTest(lws, parameters);
        }
    }
    private void doTest(String lws, Parameter... parameters)
            throws IOException {
            sb.append(p.toString(lws));
======= 7aeab0e:"test/org/apache/tomcat/util/http/parser/TestMediaType.java"

            return toString("");
        }
        public String toString(String lws) {
            sb.append(lws);
            sb.append(lws);
            sb.append(lws);
            sb.append(lws);
            sb.append(lws);

======= c06707c:"java/org/apache/catalina/loader/WebappClassLoader.java"

======= c06707c:"java/org/apache/catalina/loader/WebappClassLoader.java"

            try {
                while (iter.hasNext()) {
                    Object entry = iter.next();
                    if (loadedByThisOrChild(entry)) {
                        return true;
                    }
            } catch (ConcurrentModificationException e) {
                log.warn(sm.getString(
                        "webappClassLoader", clazz.getName(), getContextName()),
                        e);

======= 2df191f:"java/org/apache/tomcat/websocket/server/WsFilter.java"

        // Check to see if this WebSocket implementation has a matching mapping
        WsServerContainer sc = WsServerContainer.getServerContainer();
        String path;
        String pathInfo = req.getPathInfo();
        if (pathInfo == null) {
            path = req.getServletPath();
        } else {
            path = req.getServletPath() + pathInfo;
        }
        WsMappingResult mappingResult = sc.findMapping(path);
        if (mappingResult == null) {
            // No endpoint registered for the requested path. Let the
            // application handle it (it might redirect or forward for example)
            chain.doFilter(request, response);
            return;
        }
        // Validate the rest of the headers and reject the request if that
        // validation fails
======= 2df191f:"java/org/apache/tomcat/websocket/server/WsFilter.java"

======= 2df191f:"java/org/apache/tomcat/websocket/server/WsFilter.java"

======= 2df191f:"java/org/apache/tomcat/websocket/server/WsFilter.java"


======= d440ae2:"java/org/apache/jasper/tagplugins/jstl/core/ForEach.java"

        // String
        ctxt.generateJavaSource("else if (" + itemsV + " instanceof String)");
        ctxt.generateJavaSource(iterV + "=toIterator(new StringTokenizer((String)" + itemsV + ", \",\"));");
======= d440ae2:"test/org/apache/jasper/tagplugins/jstl/core/TestForEach.java"

    @Test
    public void testBug54888() throws Exception {
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug54888.jsp", res, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        String body = res.toString();
        Assert.assertTrue(body.contains("OK - 1"));
        Assert.assertTrue(body.contains("OK - 2"));
        Assert.assertTrue(body.contains("OK - 3"));
    }
======= d440ae2:"test/org/apache/jasper/tagplugins/jstl/core/TestForEach.java"

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
         pageEncoding="ISO-8859-1" session="true"
         import="java.io.Reader,java.io.StringReader" %>
  <body>
    <c:forEach items="1,2,3" var="foo">
      <p>OK - ${foo}</p>
    </c:forEach>
  </body>

======= 1631be1:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        if (tagDependentNesting > 0 || pageInfo.isELIgnored() ||
                current instanceof Node.ScriptingElement) {
======= 1631be1:"test/org/apache/jasper/compiler/TestJspDocumentParser.java"

======= 1631be1:"test/org/apache/jasper/compiler/TestJspDocumentParser.java"

        Assert.assertEquals(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, rc);
======= 1631be1:"test/org/apache/jasper/compiler/TestJspDocumentParser.java"

        Assert.assertNull(e);
    @Test
    public void testBug54801() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        // app dir is relative to server home
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug54801a.jspx", bc, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        bc.recycle();
        rc = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug54801b.jspx", bc, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
    }
    @Test
    public void testBug54821() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        // app dir is relative to server home
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug54821a.jspx", bc, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        bc.recycle();
        rc = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug54821b.jspx", bc, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
   }
======= 1631be1:"test/org/apache/jasper/compiler/TestJspDocumentParser.java"

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  // ${foo}
  out.println("Hello, world!!");
======= 1631be1:"test/org/apache/jasper/compiler/TestJspDocumentParser.java"

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  // ${foo}
  out.println("Hello, world!!");
======= 1631be1:"test/org/apache/jasper/compiler/TestJspDocumentParser.java"

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
======= 1631be1:"test/org/apache/jasper/compiler/TestJspDocumentParser.java"

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

======= 4171baf:"java/org/apache/catalina/core/AsyncContextImpl.java"

                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                            listener.getClass().getName() + "]", t);
======= 4171baf:"java/org/apache/catalina/core/AsyncContextImpl.java"

                    } catch (Throwable t) {
                        ExceptionUtils.handleThrowable(t);
                                listener.getClass().getName() + "]", t);
======= 4171baf:"java/org/apache/catalina/core/AsyncContextImpl.java"

            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                        listener.getClass().getName() + "]", t);
======= 4171baf:"java/org/apache/catalina/core/AsyncContextImpl.java"

                } catch (Throwable t2) {
                    ExceptionUtils.handleThrowable(t);
                            listener.getClass().getName() + "]", t2);
======= 4171baf:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        private int status;
======= 4171baf:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    @Test
    public void testBug54178() throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        File docBase = new File(System.getProperty("java.io.tmpdir"));
        Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
        Bug54178ServletA bug54178ServletA = new Bug54178ServletA();
        Wrapper wrapper =
            Tomcat.addServlet(ctx, "bug54178ServletA", bug54178ServletA);
        wrapper.setAsyncSupported(true);
        ctx.addServletMapping("/bug54178ServletA", "bug54178ServletA");
        Bug54178ServletB bug54178ServletB = new Bug54178ServletB();
        Tomcat.addServlet(ctx, "bug54178ServletB", bug54178ServletB);
        ctx.addServletMapping("/bug54178ServletB", "bug54178ServletB");
        tomcat.start();
        ByteChunk body = new ByteChunk();
        int rc = -1;
        try {
            rc = getUrl("http://localhost:" + getPort() + "/bug54178ServletA?" +
                    Bug54178ServletA.PARAM_NAME + "=bar",
                    body, null);
        } catch (IOException ioe) {
            // This may happen if test fails. Output the exception in case it is
            // useful and let asserts handle the failure
            ioe.printStackTrace();
        }
        assertEquals(HttpServletResponse.SC_OK, rc);
        body.recycle();
        rc = getUrl("http://localhost:" + getPort() + "/bug54178ServletB",
                body, null);
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertEquals("OK", body.toString());
    }
    private static class Bug54178ServletA extends HttpServlet {
        public static final String PARAM_NAME = "foo";
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            req.getParameter(PARAM_NAME);
            AsyncContext actxt = req.startAsync();
            actxt.addListener(new Bug54178AsyncListener());
            actxt.complete();
        }
    }
    private static class Bug54178ServletB extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setContentType("text/plain");
            PrintWriter pw = resp.getWriter();
            String result = req.getParameter(Bug54178ServletA.PARAM_NAME);
            if (result == null) {
                pw.write("OK");
            } else {
                pw.write("FAIL");
            }
        }
    }
    private static class Bug54178AsyncListener implements AsyncListener {
        @Override
        public void onComplete(AsyncEvent event) throws IOException {
            throw new RuntimeException("Testing Bug54178");
        }
        @Override
        public void onTimeout(AsyncEvent event) throws IOException {
            // NO-OP
        }
        @Override
        public void onError(AsyncEvent event) throws IOException {
            // NO-OP
        }
        @Override
        public void onStartAsync(AsyncEvent event) throws IOException {
            // NO-OP
        }
    }

======= 59a0676:"java/org/apache/catalina/core/StandardContext.java"

            String temp = getBaseName();

======= 67ed3e7:"java/org/apache/tomcat/websocket/server/WsFilter.java"

            // Not an HTTP request that includes a valid upgrade request to
======= 67ed3e7:"java/org/apache/tomcat/websocket/server/WsFilter.java"

        if (mappingResult == null) {
            // No endpoint registered for the requested path. Let the
            // application handle it (it might redirect or forward for example)
            chain.doFilter(request, response);
            return;
        }
======= 67ed3e7:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

======= 67ed3e7:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

        EnumSet<DispatcherType> types = EnumSet.of(DispatcherType.REQUEST,
                DispatcherType.FORWARD);
        fr.addMappingForUrlPatterns(types, false, "/*");
======= 67ed3e7:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

        if (templateMatches == null) {
            // No templates with an equal number of segments so there will be
            // no matches
            return null;
        }

======= e26d61d:"webapps/examples/WEB-INF/classes/websocket/chat/ChatAnnotation.java"


======= d2630df:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

======= d2630df:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

======= d2630df:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

======= d2630df:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

    private static final AsynchronousChannelGroup asynchronousChannelGroup;
    static {
        AsynchronousChannelGroup result = null;
        // Need to do this with the right thread context class loader else the
        // first web app to call this will trigger a leak
        ClassLoader original = Thread.currentThread().getContextClassLoader();
        try {
            Thread.currentThread().setContextClassLoader(
                    AsyncIOThreadFactory.class.getClassLoader());
            // These are the same settings as the default
            // AsynchronousChannelGroup
            int initialSize = Runtime.getRuntime().availableProcessors();
            ExecutorService executorService = new ThreadPoolExecutor(
                    0,
                    Integer.MAX_VALUE,
                    Long.MAX_VALUE, TimeUnit.MILLISECONDS,
                    new SynchronousQueue<Runnable>(),
                    new AsyncIOThreadFactory());
            try {
                result = AsynchronousChannelGroup.withCachedThreadPool(
                        executorService, initialSize);
            } catch (IOException e) {
                // No good reason for this to happen.
                throw new IllegalStateException(sm.getString(
                        "wsWebSocketContainer.asynchronousChannelGroupFail"));
            }
        } finally {
            Thread.currentThread().setContextClassLoader(original);
        }
        asynchronousChannelGroup = result;
    }
======= d2630df:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

            socketChannel =
                    AsynchronousSocketChannel.open(asynchronousChannelGroup);
            throw new DeploymentException(sm.getString(
                    "wsWebSocketContainer.asynchronousSocketChannelFail"), ioe);
======= d2630df:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

            throw new DeploymentException(sm.getString(
                    "wsWebSocketContainer.sslEngineFail"), e);
======= d2630df:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

    /**
     * Create threads for AsyncIO that have the right context class loader to
     * prevent memory leaks.
     */
    private static class AsyncIOThreadFactory implements ThreadFactory {
        private AtomicInteger count = new AtomicInteger(0);
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r);
            t.setName("WebSocketClient-AsyncIO-" + count.incrementAndGet());
            t.setContextClassLoader(this.getClass().getClassLoader());
            t.setDaemon(true);
            return t;
        }
    }

======= 0339fec:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

                templateMatches = new TreeSet<>(
                        TemplatePathMatchComparator.getInstance());
======= 0339fec:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

                templateMatches = new TreeSet<>(
                        TemplatePathMatchComparator.getInstance());
======= 0339fec:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

    /**
     * This Comparator implementation is thread-safe so only create a single
     * instance.
     */
        private static final TemplatePathMatchComparator INSTANCE =
                new TemplatePathMatchComparator();
        public static TemplatePathMatchComparator getInstance() {
            return INSTANCE;
        }
        private TemplatePathMatchComparator() {
            // Hide default constructor
        }
======= 0339fec:"java/org/apache/tomcat/websocket/server/WsServerContainer.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    @Test
    public void testBug54807() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        ctx.addApplicationListener(Bug54807Config.class.getName());
        Tomcat.addServlet(ctx, "default", new DefaultServlet());
        ctx.addServletMapping("/", "default");
        tomcat.start();
        Assert.assertEquals(LifecycleState.STARTED, ctx.getState());
    }
    public static class Bug54807Config extends WsListener {
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            super.contextInitialized(sce);
            WsServerContainer sc = WsServerContainer.getServerContainer();
            ServerEndpointConfig sec = ServerEndpointConfig.Builder.create(
                    TesterEchoServer.Basic.class, "/{param}").build();
            try {
                sc.addEndpoint(sec);
            } catch (DeploymentException e) {
                throw new RuntimeException(e);
            }
        }
    }

======= 3da2133:"java/org/apache/coyote/spdy/SpdyProcessor.java"

                request.unparsedURI().setBytes(frame.data, frame.off, valueLen);
                int questionPos = -1;
                int end = frame.off + valueLen;
                for(int k = frame.off; k < end; k ++) {
                    if (frame.data[k] == '?') {
                        questionPos = k;
                    }
                }
                if (questionPos >= 0) {
                    request.queryString().setBytes(frame.data, questionPos + 1, end - questionPos - 1);
                    request.requestURI().setBytes(frame.data, frame.off, questionPos - frame.off);
                } else {
                    request.requestURI().setBytes(frame.data, frame.off, valueLen);
                }

======= e97e158:"java/org/apache/catalina/startup/ContextConfig.java"

                } else {
                    // If there is no web.xml, normal folder no impact on
                    // distributable
                    fragment.setDistributable(true);

======= d025179:"java/org/apache/tomcat/websocket/server/WsServlet.java"

                ep = (Endpoint) sec.getConfigurator().getEndpointInstance(
                        sec.getEndpointClass());
        } catch (InstantiationException e) {

======= cf0c064:"java/org/apache/tomcat/websocket/WsFrameBase.java"

    private volatile boolean open = true;
======= cf0c064:"java/org/apache/tomcat/websocket/WsFrameBase.java"

                // If a close frame has been received, no further data should
                // have seen
                if (!open) {
                    throw new IOException(sm.getString("wsFrame.closed"));
                }
======= cf0c064:"java/org/apache/tomcat/websocket/WsFrameBase.java"

            open = false;
======= cf0c064:"java/org/apache/tomcat/websocket/WsFrameBase.java"

    protected boolean isOpen() {
        return open;
    }
======= cf0c064:"java/org/apache/tomcat/websocket/WsFrameClient.java"

        if (isOpen()) {
            channel.read(response, null, handler);
        }
======= cf0c064:"java/org/apache/tomcat/websocket/server/WsFrameServer.java"

            while (isOpen() && sis.isReady()) {

======= 8cf47b4:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java"

            closed = true;
            delegate = null;
======= 8cf47b4:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Interceptor that counts opened Statements. Is used by tests.
 */
    private final AtomicInteger countOpen = new AtomicInteger();
    private final AtomicInteger countClosed = new AtomicInteger();
    public int getActiveCount() {
        return countOpen.get() - countClosed.get();
    }
    @Override
    protected Object createDecorator(Object proxy, Method method,
            Object[] args, Object statement, Constructor<?> constructor,
            String sql) throws InstantiationException, IllegalAccessException,
            InvocationTargetException {
        Object result;
        StatementProxy statementProxy = new StatementProxy(
                (Statement) statement, sql);
        result = constructor.newInstance(new Object[] { statementProxy });
        statementProxy.setActualProxy(result);
        statementProxy.setConnection(proxy);
        statementProxy.setConstructor(constructor);
        countOpen.incrementAndGet();
        return result;
    }
    private class StatementProxy extends
            StatementDecoratorInterceptor.StatementProxy<Statement> {
        public StatementProxy(Statement delegate, String sql) {
            super(delegate, sql);
        }
        @Override
        public void closeInvoked() {
            countClosed.incrementAndGet();
            super.closeInvoked();
        }
    }
======= 8cf47b4:"modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestStatementCache.java"

======= 8cf47b4:"modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestStatementCache.java"

======= 8cf47b4:"modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestStatementCache.java"

    public void testStatementClose1() throws Exception {
        init();
        datasource.setJdbcInterceptors(
                TestStatementCacheInterceptor.class.getName()
                + "(prepared=true,callable=false,max=1);"
                + StatementCounterInterceptor.class.getName());
        Connection con = datasource.getConnection();
        StatementCounterInterceptor counter = findInterceptor(con, StatementCounterInterceptor.class);
        PreparedStatement ps1, ps2;
        ps1 = con.prepareStatement("select 1");
        Assert.assertEquals(1, counter.getActiveCount());
        ps1.close();
        Assert.assertEquals("Statement goes into cache, not closed", 1, counter.getActiveCount());
        ps1 = con.prepareStatement("select 1");
        Assert.assertEquals("Reusing statement from cache", 1, counter.getActiveCount());
        ps2 = con.prepareStatement("select 1");
        Assert.assertEquals("Reusing statement from cache", 2, counter.getActiveCount());
        ps2.close();
        Assert.assertEquals("Statement goes into cache, not closed", 2, counter.getActiveCount());
        ps1.close();
        // Cache has "max=1". The following tests BZ 54732.
        Assert.assertEquals("Statement does not go into cache, closed", 1, counter.getActiveCount());
        con.close();
        Assert.assertEquals("Connection returned to the pool. Statement is in cache", 1, counter.getActiveCount());
        datasource.close();
        Assert.assertEquals("Pool cleared. All statements in cache are closed", 0, counter.getActiveCount());
    }
    @Test
    public void testStatementClose2() throws Exception {
        init();
        datasource.setJdbcInterceptors(
                TestStatementCacheInterceptor.class.getName()
                + "(prepared=false,callable=false,max=10);"
                + StatementCounterInterceptor.class.getName());
        Connection con = datasource.getConnection();
        StatementCounterInterceptor counter = findInterceptor(con, StatementCounterInterceptor.class);
        PreparedStatement ps1 = con.prepareStatement("select 1");
        Assert.assertEquals(1, counter.getActiveCount());
        ps1.close();
        Assert.assertEquals("Statement is not pooled, closes immediately", 0, counter.getActiveCount());
    }
    @Test
======= 8cf47b4:"modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestStatementCache.java"

    /**
     * Helper method that finds interceptor instance in interceptor chain of a
     * proxied class.
     *
     * @param proxy
     *            Proxy class
     * @param clazz
     *            Interceptor class that we are looking for
     * @return Instance of <code>clazz</code>
     */
    private static <T extends JdbcInterceptor> T findInterceptor(Object proxy,
            Class<T> clazz) {
        JdbcInterceptor interceptor = (JdbcInterceptor) Proxy
                .getInvocationHandler(proxy);
        while (interceptor != null) {
            if (clazz.isInstance(interceptor)) {
                return clazz.cast(interceptor);
            }
            interceptor = interceptor.getNext();
        }
        return null;
    }

======= 8445d9a:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

            for (String field: fields) {
                    String name = prefix[j]
                            + field.substring(0, 1).toUpperCase(Locale.ENGLISH)
                            + field.substring(1);
                    buf.append(field);
                    if (DataSourceFactory.PROP_PASSWORD.equals(field)) {
                        buf.append("********");
                    } else {
                        buf.append(m.invoke(this, new Object[0]));
                    }
            //shouldn't happen
            log.debug("toString() call failed", x);

======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
        checkState();
        checkState();
        checkState();
======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
        checkState();
        checkState();
        checkState();
        checkState();
        checkState();
        checkState();
        checkState();
        checkState();
======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

            fireEndpointOnClose(closeReason);
======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

                fireEndpointOnClose(closeReason);
======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

    private void fireEndpointOnClose(CloseReason closeReason) {
        // Fire the onClose event
        Thread t = Thread.currentThread();
        ClassLoader cl = t.getContextClassLoader();
        t.setContextClassLoader(applicationClassLoader);
        try {
            localEndpoint.onClose(this, closeReason);
        } finally {
            t.setContextClassLoader(cl);
        }
    }
======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
        checkState();
        checkState();
        checkState();
        checkState();
======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

        checkState();
======= 12f89ff:"java/org/apache/tomcat/websocket/WsSession.java"

    private void checkState() {
        if (!isOpen()) {
            throw new IllegalStateException(sm.getString("wsSession.closed"));
        }
    }
======= 12f89ff:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

        boolean isOpen = true;
        while (isOpen && count < 8) {
            isOpen = false;
            for (Session session : setA) {
                if (session.isOpen()) {
                    isOpen = true;
                }
            }
        if (isOpen) {
            for (Session session : setA) {
                if (session.isOpen()) {
                    System.err.println("Session with ID [" + session.getId() +
                            "] is open");
                }
            }
            Assert.fail("There were open sessions");
======= 12f89ff:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

            Assert.assertEquals(expected, getOpenCount(setA));
            while (getOpenCount(setA) == expected && count < 5) {
        Assert.assertEquals(0, getOpenCount(setA));
    private int getOpenCount(Set<Session> sessions) {
        int result = 0;
        for (Session session : sessions) {
            if (session.isOpen()) {
                result++;
            }
        }
        return result;
    }

======= 80ef59a:"java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java"

                try (Writer w = getSendWriter()) {
                    ((Encoder.TextStream) encoder).encode(obj, w);
                }
                completion.onResult(new SendResult());
                try (OutputStream os = getSendStream()) {
                    ((Encoder.BinaryStream) encoder).encode(obj, os);
                }
                completion.onResult(new SendResult());

======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoEndpointBase.java"

                        methodMapping.getOnCloseArgs(pathParameters, session, closeReason));
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerBase.java"

    protected final boolean convert;
            Session session, Object[] params, int indexPayload, boolean convert,
        this.convert = convert;
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialBase.java"

            boolean convert, int indexBoolean, int indexSession) {
        super(pojo, method, session, params, indexPayload, convert,
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialBase.java"

        if (convert) {
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialBinary.java"

            Session session, Object[] params, int indexPayload, boolean convert,
        super(pojo, method, session, params, indexPayload, convert, indexBoolean,
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialText.java"

            Session session, Object[] params, int indexPayload, boolean convert,
        super(pojo, method, session, params, indexPayload, convert, indexBoolean,
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBase.java"

======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBase.java"

            boolean convert, int indexSession) {
        super(pojo, method, session, params, indexPayload, convert,
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBase.java"

            // Not decoded. Convert if required.
            if (convert) {
                payload = convert(message);
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBase.java"

    protected Object convert(T message) {
        return message;
    }
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBinary.java"

    private final boolean isForInputStream;
            int indexPayload, boolean convert, int indexSession,
            boolean isForInputStream) {
        super(pojo, method, session, params, indexPayload, convert,
                indexSession);
                } else if (BinaryStream.class.isAssignableFrom(decoderClazz)) {
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBinary.java"

        this.isForInputStream = isForInputStream;
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBinary.java"

    protected Object convert(ByteBuffer message) {
        byte[] array = new byte[message.remaining()];
        message.get(array);
        if (isForInputStream) {
            return new ByteArrayInputStream(array);
        } else {
            return array;
        }
    }
    @Override
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholePong.java"

            Session session, Object[] params, int indexPayload, boolean convert,
        super(pojo, method, session, params, indexPayload, convert, indexSession);
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeText.java"

            int indexPayload, boolean convert, int indexSession) {
        super(pojo, method, session, params, indexPayload, convert,
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeText.java"

                } else if (TextStream.class.isAssignableFrom(decoderClazz)) {
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeText.java"

    protected Object convert(String message) {
        return new StringReader(message);
    }
    @Override
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

        onOpenParams = getPathParams(onOpen, false, false);
        onCloseParams = getPathParams(onClose, false, true);
        onErrorParams = getPathParams(onError, true, false);
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

        return buildArgs(onOpenParams, pathParameters, session, null, null);
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            Session session, CloseReason closeReason) {
        return buildArgs(
                onCloseParams, pathParameters, session, null, closeReason);
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

        return buildArgs(
                onErrorParams, pathParameters, session, throwable, null);
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

    private static PojoPathParam[] getPathParams(Method m, boolean isOnError,
            boolean isClose) {
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            } else if (isClose && type.equals(CloseReason.class)) {
                result[i] = new PojoPathParam(type, null);
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            Throwable throwable, CloseReason closeReason) {
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            } else if (type.equals(CloseReason.class)) {
                result[i] = closeReason;
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

        private int indexInputStream = -1;
        private int indexReader = -1;
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                } else if (types[i] == Reader.class) {
                    if (indexReader == -1) {
                        indexReader = i;
                    } else {
                        throw new IllegalArgumentException(sm.getString(
                                "pojoMethodMapping.duplicateMessageParam",
                                m.getName(), m.getClass().getName()));
                    }
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                } else if (types[i] == InputStream.class) {
                    if (indexInputStream == -1) {
                        indexInputStream = i;
                    } else {
                        throw new IllegalArgumentException(sm.getString(
                                "pojoMethodMapping.duplicateMessageParam",
                                m.getName(), m.getClass().getName()));
                    }
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            if (indexReader != -1) {
                if (indexPayload != -1) {
                    throw new IllegalArgumentException(sm.getString(
                            "pojoMethodMapping.duplicateMessageParam",
                            m.getName(), m.getClass().getName()));
                } else {
                    indexPayload = indexReader;
                }
            }
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            if (indexInputStream != -1) {
                if (indexPayload != -1) {
                    throw new IllegalArgumentException(sm.getString(
                            "pojoMethodMapping.duplicateMessageParam",
                            m.getName(), m.getClass().getName()));
                } else {
                    indexPayload = indexInputStream;
                }
            }
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

            if(indexReader != -1 && indexBoolean != -1) {
                throw new IllegalArgumentException(sm.getString(
                        "pojoMethodMapping.partialReader",
                        m.getName(), m.getClass().getName()));
            }
            if(indexInputStream != -1 && indexBoolean != -1) {
                throw new IllegalArgumentException(sm.getString(
                        "pojoMethodMapping.partialInputStream",
                        m.getName(), m.getClass().getName()));
            }
======= 06800eb:"java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java"

                            config, params, indexByteArray, true, indexSession,
                            false);
                            indexSession, false);
                } else if (indexInputStream != -1) {
                    mh = new PojoMessageHandlerWholeBinary(pojo, m, session,
                            config, params, indexInputStream, true, indexSession,
                            true);
                } else if (indexReader != -1) {
                    mh = new PojoMessageHandlerWholeText(pojo, m, session,
                            config, params, indexReader, true, indexSession);

======= ad148dd:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

        if (!("ws".equalsIgnoreCase(scheme) ||
                "wss".equalsIgnoreCase(scheme))) {
======= ad148dd:"java/org/apache/tomcat/websocket/WsWebSocketContainer.java"

            if ("ws".equalsIgnoreCase(scheme)) {
======= ad148dd:"test/org/apache/tomcat/websocket/TestWsRemoteEndpoint.java"

        URI uri = new URI("ws://localhost:" + getPort() +
======= ad148dd:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                new URI("ws://localhost:" + getPort() +
======= ad148dd:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                new URI("ws://" + TesterEchoServer.Config.PATH_ASYNC));
======= ad148dd:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                        new URI("ws://localhost:" + getPort() +
======= ad148dd:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                new URI("ws://localhost:" + getPort() + BlockingConfig.PATH));
======= ad148dd:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                new URI("ws://localhost:" + getPort() +
======= ad148dd:"test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java"

                new URI("ws://localhost:" + getPort() +
======= ad148dd:"test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java"

        URI uri = new URI("ws://localhost:" + getPort() + "/");
======= ad148dd:"test/org/apache/tomcat/websocket/pojo/TestPojoMethodMapping.java"

        URI uri = new URI("ws://localhost:" + getPort() + "/" + PARAM_ONE +

======= dc16474:"java/org/apache/catalina/connector/Connector.java"

             this.URIEncodingLower = URIEncoding.toLowerCase(Locale.ENGLISH);
======= dc16474:"java/org/apache/tomcat/util/buf/B2CConverter.java"

                    charset.name().toLowerCase(Locale.ENGLISH), charset);
                        alias.toLowerCase(Locale.ENGLISH), charset);
======= dc16474:"java/org/apache/tomcat/util/buf/B2CConverter.java"

        String lowerCaseEnc = enc.toLowerCase(Locale.ENGLISH);
======= dc16474:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

            Integer type = fieldTypes.get(field.toLowerCase(Locale.ENGLISH));
======= dc16474:"java/org/apache/tomcat/util/http/parser/HttpParser.java"

                parameters.put(attribute.toLowerCase(Locale.ENGLISH), value);
                parameters.put(attribute.toLowerCase(Locale.ENGLISH), "");
======= dc16474:"java/org/apache/tomcat/util/http/parser/MediaType.java"

        return parameters.get(parameter.toLowerCase(Locale.ENGLISH));
======= dc16474:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

                    String name = prefix[j] + fields[i].substring(0, 1).toUpperCase(Locale.ENGLISH) +
======= dc16474:"test/org/apache/catalina/startup/SimpleHttpClient.java"

            SESSION_COOKIE_NAME.toLowerCase(Locale.ENGLISH);

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    private static final String PARAM_ONE = "abcde";
    private static final String PARAM_TWO = "12345";
    private static final String PARAM_THREE = "true";
    @Test
    public void test() throws Exception {
        // Set up utility classes
        Server server = new Server();
        SingletonConfigurator.setInstance(server);
        ServerConfigListener.setPojoClazz(Server.class);
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        ctx.addApplicationListener(ServerConfigListener.class.getName());
        WebSocketContainer wsContainer =
                ContainerProvider.getWebSocketContainer();
        tomcat.start();
        Client client = new Client();
        URI uri = new URI("http://localhost:" + getPort() + "/" + PARAM_ONE +
                "/" + PARAM_TWO + "/" + PARAM_THREE);
        Session session = wsContainer.connectToServer(client, uri);
        session.getBasicRemote().sendText("NO-OP");
        session.close();
        // Give server 5s to close
        int count = 0;
        while (count < 50) {
            if (server.isClosed()) {
                break;
            }
            count++;
            Thread.sleep(100);
        }
        if (count == 50) {
            Assert.fail("Server did not process an onClose event within 5 " +
                    "seconds of the client sending a close message");
        }
        // Check no errors
        List<String> errors = server.getErrors();
        for (String error : errors) {
            System.err.println(error);
        }
        Assert.assertEquals("Found errors", 0, errors.size());
    }
    @ClientEndpoint
    public static final class Client {
    }
    @ServerEndpoint(value="/{one}/{two}/{three}",
            configurator=SingletonConfigurator.class)
    public static final class Server {
        private final List<String> errors = new ArrayList<>();
        private volatile boolean closed;
        @OnOpen
        public void onOpen(@PathParam("one") String p1, @PathParam("two")int p2,
                @PathParam("three")boolean p3) {
            checkParams("onOpen", p1, p2, p3);
        }
        @OnMessage
        public void onMessage(@SuppressWarnings("unused") String msg,
                @PathParam("one") String p1, @PathParam("two")int p2,
                @PathParam("three")boolean p3) {
            checkParams("onMessage", p1, p2, p3);
        }
        @OnClose
        public void onClose(@PathParam("one") String p1,
                @PathParam("two")int p2, @PathParam("three")boolean p3) {
            checkParams("onClose", p1, p2, p3);
            closed = true;
        }
        public List<String> getErrors() {
            return errors;
        }
        public boolean isClosed() {
            return closed;
        }
        private void checkParams(String method, String p1, int p2, boolean p3) {
            checkParam(method, PARAM_ONE, p1);
            checkParam(method, PARAM_TWO, Integer.toString(p2));
            checkParam(method, PARAM_THREE, Boolean.toString(p3));
        }
        private void checkParam(String method, String expected, String actual) {
            if (!expected.equals(actual)) {
                errors.add("Method [" + method + "]. Expected [" + expected +
                        "] was + [" + actual + "]");
            }
        }
    }

======= 7c88af9:"java/org/apache/catalina/startup/ContextConfig.java"

    /**
     * Parses the given source and stores the parsed data in the given web.xml
     * representation. The byte stream will be closed at the end of the parse
     * operation.
     *
     * @param source Input source containing the XML data to be parsed
     * @param dest The object representation of common elements of web.xml and
     *             web-fragment.xml
     * @param fragment Specifies whether the source is web-fragment.xml or
     *                 web.xml
     */
======= 7c88af9:"java/org/apache/catalina/startup/ContextConfig.java"

            InputStream is = source.getByteStream();
            if (is != null) {
                try {
                    is.close();
                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                }
            }
======= 7c88af9:"java/org/apache/catalina/startup/ContextConfig.java"

======= 7c88af9:"java/org/apache/catalina/startup/ContextConfig.java"


======= ca205c1:"java/javax/servlet/http/Part.java"

     * If this part represents an uploaded file, gets the file name submitted
     * in the upload. Returns {@code null} if no file name is available or if
     * this part is not a file upload.
     *
     * @return the submitted file name or {@code null}.
     */
    public String getSubmittedFileName();
    /**
======= ca205c1:"java/org/apache/catalina/connector/Request.java"

                    if (part.getSubmittedFileName() == null) {
======= ca205c1:"java/org/apache/catalina/core/ApplicationPart.java"

    /**
     * Calls {@link #getSubmittedFileName()}.
     *
     * @deprecated Use {@link #getSubmittedFileName()} from Servlet 3.1 instead.
     */
    @Deprecated
    public String getFilename() {
        return getSubmittedFileName();
    }
    @Override
    public String getSubmittedFileName() {
======= ca205c1:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= ca205c1:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= ca205c1:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                filename = warPart.getSubmittedFileName();
======= ca205c1:"java/org/apache/catalina/manager/HTMLManagerServlet.java"


======= 2a03ca6:"java/org/apache/catalina/valves/AccessLogValve.java"

        String newFormat;
        if (fileDateFormat == null) {
            newFormat = "";
        } else {
            newFormat = fileDateFormat;
        }
        this.fileDateFormat = newFormat;
        synchronized (this) {
            fileDateFormatter = new SimpleDateFormat(newFormat, Locale.US);
            fileDateFormatter.setTimeZone(TimeZone.getDefault());
        }
======= 2a03ca6:"java/org/apache/catalina/valves/AccessLogValve.java"

     * Rotate the log file if necessary.
     */
    public void rotate() {
        if (rotatable) {
            // Only do a logfile switch check once a second, max.
            long systime = System.currentTimeMillis();
            if ((systime - rotationLastChecked) > 1000) {
                synchronized(this) {
                    if ((systime - rotationLastChecked) > 1000) {
                        rotationLastChecked = systime;
                        String tsDate;
                        // Check for a change of date
                        tsDate = fileDateFormatter.format(new Date(systime));
                        // If the date has changed, switch log files
                        if (!dateStamp.equals(tsDate)) {
                            close(true);
                            dateStamp = tsDate;
                            open();
                        }
                    }
                }
            }
        }
    }
    /**
======= 2a03ca6:"java/org/apache/catalina/valves/AccessLogValve.java"

        rotate();
======= 2a03ca6:"java/org/apache/catalina/valves/AccessLogValve.java"


======= fedf189:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

    private static final String[] DEFAULT_SERVER_PROTOCOLS;
    private static final String[] DEAFULT_SERVER_CIPHER_SUITES;
======= fedf189:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

        String[] ciphers = null;
        String[] protocols = null;
            String supportedCiphers[] = ssf.getSupportedCipherSuites();
            for (String cipher : supportedCiphers) {
            // There is no API to obtain the default server protocols and cipher
            // suites. Having inspected the OpenJDK code there the same results
            // can be achieved via the standard API but there is no guarantee
            // that every JVM implementation determines the defaults the same
            // way. Therefore the defaults are determined by creating a server
            // socket and requested the configured values.
            SSLServerSocket socket = (SSLServerSocket) ssf.createServerSocket();
            ciphers = socket.getEnabledCipherSuites();
            protocols = socket.getEnabledProtocols();
        } catch (IOException e) {
            // Unable to determine default ciphers/protocols so use none
        DEAFULT_SERVER_CIPHER_SUITES = ciphers;
        DEFAULT_SERVER_PROTOCOLS = protocols;
======= fedf189:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            return DEAFULT_SERVER_CIPHER_SUITES;
======= fedf189:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            return DEAFULT_SERVER_CIPHER_SUITES;
======= fedf189:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            return DEFAULT_SERVER_PROTOCOLS;

======= 28c599f:"java/javax/websocket/server/ServerContainerProvider.java"

    public static ServerContainer getServerContainer() {

======= e1d16fd:"java/org/apache/catalina/websocket/WsOutbound.java"

        outputStream.write(buffer.array(), buffer.arrayOffset(),
                buffer.limit());

======= c9e056c:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

        // Swallow any request body since we will be replacing it
        // Need to do this before headers are restored as AJP connector uses
        // content length header to determine how much data needs to be read for
        // request body
        byte[] buffer = new byte[4096];
        InputStream is = request.createInputStream();
        while (is.read(buffer) >= 0) {
            // Ignore request body
        }
======= c9e056c:"java/org/apache/catalina/authenticator/FormAuthenticator.java"


======= 1255d32:"java/org/apache/catalina/websocket/WsOutbound.java"

        // Send any partial data we have
        doFlush(false);
======= 1255d32:"java/org/apache/catalina/websocket/WsOutbound.java"

        if (closed) {
            throw new IOException(sm.getString("outbound.closed"));
        }

======= 78b3c10:"java/org/apache/catalina/manager/StatusTransformer.java"

                writer.write(" usageUsed='" + usage.getUsed() + "'/>");

======= 9ad4904:"java/org/apache/catalina/loader/WebappLoader.java"

        if (delegate && loader != null) {
            // Skip the webapp loader for now as delegation is enabled
            loader = loader.getParent();
        }
======= 9ad4904:"java/org/apache/catalina/loader/WebappLoader.java"

        if (delegate) {
            // Delegation was enabled, go back and add the webapp paths
            loader = getClassLoader();
            if (loader != null) {
                buildClassPath(servletContext, classpath, loader);
            }
        }

======= b2f0e7c:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                } else {
                    conv.recycle();

======= 81eaf63:"java/javax/servlet/http/Part.java"

 * This class represents a part as uploaded to the server as part of a
 * <code>multipart/form-data</code> request body. The part may represent either
 * an uploaded file or form data.
 *
    /**
     * Obtain an <code>InputStream</code> that can be used to retrieve the
     * contents of the file.
     */
    /**
     * Obtain the content type passed by the browser or <code>null</code> if not
     * defined.
     */
    /**
     * Obtain the name of the field in the multipart form corresponding to this
     * part.
     */
    /**
     * Obtain the size of this part.
     */
    /**
     * A convenience method to write an uploaded part to disk. The client code
     * is not concerned with whether or not the part is stored in memory, or on
     * disk in a temporary location. They just want to write the uploaded part
     * to a file.
     *
     *  This method is not guaranteed to succeed if called more than once for
     *  the same part. This allows a particular implementation to use, for
     *  example, file renaming, where possible, rather than copying all of the
     *  underlying data, thus gaining a significant performance benefit.
     *
     * @param fileName  The location into which the uploaded part should be
     *                  stored. Relative locations are relative to {@link
     *                  javax.servlet.MultipartConfigElement#getLocation()}
     */
    /**
     * Deletes the underlying storage for a part, including deleting any
     * associated temporary disk file. Although this storage will be deleted
     * automatically when the Part instance is garbage collected, this
     * method can be used to ensure that this is done at an earlier time, thus
     * preserving system resources.
     */
     * Obtains the value of the specified part header as a String. If there are
     * multiple headers with the same name, this method returns the first header
     * in the part. The header name is case insensitive.
     *
     * @param name  Header name
     * @return      The header value or <code>null</code> if the header is not
     *              present
    /**
     * Obtain all the values of the specified part header. If the part did not
     * include any headers of the specified name, this method returns an empty
     * Collection. The header name is case insensitive.
     */
    /**
     * Returns a Collection of all the header names provided for this part.
     */

======= c11952d:"java/javax/servlet/http/HttpServletRequest.java"

     * Changes the session ID of the session associated with this request. This
     * method does not create a new session object it only changes the ID of the
     * current session.
     *
     * @return the new session ID allocated to the session
     * @see HttpSessionIdListener
     * @since Servlet 3.1
     */
    public String changeSessionId();
    /**
======= c11952d:"java/javax/servlet/http/HttpServletRequestWrapper.java"

     * The default behavior of this method is to call changeSessionId() on the
     * wrapped request object.
     */
    @Override
    public String changeSessionId() {
        return this._getHttpServletRequest().changeSessionId();
    }
    /**
======= c11952d:"java/javax/servlet/http/HttpServletRequestWrapper.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Implementations of this interface are notified when an {@link HttpSession}'s
 * ID changes. To receive notification events, the implementation class must be
 * configured in the deployment descriptor for the web application, annotated
 * with {@link javax.servlet.annotation.WebListener} or registered by calling an
 * addListener method on the {@link javax.servlet.ServletContext}.
 *
 * @see HttpSessionEvent
 * @see HttpServletRequest#changeSessionId()
 * @since Servlet 3.1
 */
    /**
     * Notification that a session ID has been changed.
     *
     * @param se the notification event
     * @param oldSessionId the old session ID
     */
    public void sessionIdChanged(HttpSessionEvent se, String oldSessionId);
======= c11952d:"java/org/apache/catalina/connector/Request.java"

    /**
     * Changes the session ID of the session associated with this request.
     *
     * @return the old session ID before it was changed
     * @see javax.servlet.http.HttpSessionIdListener
     * @since Servlet 3.1
     */
    @Override
    public String changeSessionId() {
        Session session = this.getSessionInternal(false);
        if (session == null) {
            throw new IllegalStateException(
                sm.getString("coyoteRequest.changeSessionId"));
        }
        Manager manager = this.getContext().getManager();
        manager.changeSessionId(session);
        String newSessionId = session.getId();
        this.changeSessionId(newSessionId);
        return newSessionId;
    }
======= c11952d:"java/org/apache/catalina/connector/RequestFacade.java"

    @Override
    public String changeSessionId() {
        if (request == null) {
            throw new IllegalStateException(
                            sm.getString("requestFacade.nullRequest"));
        }
        return request.changeSessionId();
    }
======= c11952d:"java/org/apache/catalina/core/ApplicationContext.java"

======= c11952d:"java/org/apache/catalina/core/ApplicationContext.java"

                t instanceof HttpSessionIdListener ||
======= c11952d:"java/org/apache/catalina/core/ApplicationContext.java"

                    listener instanceof HttpSessionIdListener ||
======= c11952d:"java/org/apache/catalina/core/StandardContext.java"

======= c11952d:"java/org/apache/catalina/core/StandardContext.java"

                || (results[i] instanceof HttpSessionIdListener)
======= c11952d:"java/org/apache/catalina/ha/session/DeltaManager.java"

======= c11952d:"java/org/apache/catalina/ha/session/DeltaManager.java"

            if (notifySessionListenersOnReplication) {
                Object listeners[] = getContext().
                    getApplicationEventListeners();
                if (listeners != null && listeners.length > 0) {
                    HttpSessionEvent event =
                        new HttpSessionEvent(session.getSession());
                    for(Object listener : listeners) {
                        if (!(listener instanceof HttpSessionIdListener))
                            continue;
                        HttpSessionIdListener idListener =
                            (HttpSessionIdListener)listener;
                        try {
                            idListener.
                                sessionIdChanged(event, msg.getSessionID());
                        } catch (Throwable t) {
                            log.error(sm.getString(
                                "standardSession.sessionEvent"), t);
                        }
                    }
                }
            }
======= c11952d:"java/org/apache/catalina/session/ManagerBase.java"

======= c11952d:"java/org/apache/catalina/session/ManagerBase.java"

        Object listeners[] = context.getApplicationEventListeners();
        if (listeners != null && listeners.length > 0) {
            HttpSessionEvent event =
                new HttpSessionEvent(session.getSession());
            for(Object listener : listeners) {
                if (!(listener instanceof HttpSessionIdListener))
                    continue;
                HttpSessionIdListener idListener =
                    (HttpSessionIdListener)listener;
                try {
                    idListener.sessionIdChanged(event, oldId);
                } catch (Throwable t) {
                    log.error(sm.getString("standardSession.sessionEvent"), t);
                }
            }
        }
======= c11952d:"java/org/apache/catalina/websocket/WsHttpServletRequestWrapper.java"

    public String changeSessionId() {
        return getRequest().changeSessionId();
    }
    @Override
      <add>
        <bug>54552</bug>: Servlet 3.1. Implement
        <code>HttpSessionIdListener</code> and
        <code>HttpServletRequest#changeSessionId()</code>. Patch provided by
        Nick Williams. (markt) 
      </add>

======= ef9ed07:"java/org/apache/catalina/valves/ErrorReportValve.java"

        // Do nothing if there is no report for the specified status code and
        // no error message provided
======= ef9ed07:"java/org/apache/catalina/valves/ErrorReportValve.java"

            if (message.length() == 0) {
                return;
            } else {
                report = sm.getString("errorReportValve.noDescription");
            }
======= ef9ed07:"test/org/apache/catalina/valves/TestErrorReportValve.java"

    /**
     * Custom error/status codes should not result in a blank response.
     */
    @Test
    public void testBug54536() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctx, "bug54536", new Bug54536Servlet());
        ctx.addServletMapping("/", "bug54536");
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort(), res, null);
        Assert.assertEquals(Bug54536Servlet.ERROR_STATUS, rc);
        String body = res.toString();
        Assert.assertNotNull(body);
        Assert.assertTrue(body, body.contains(Bug54536Servlet.ERROR_MESSAGE));
    }
    private static final class Bug54536Servlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private static final int ERROR_STATUS = 999;
        private static final String ERROR_MESSAGE = "The sky is falling";
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.sendError(ERROR_STATUS, ERROR_MESSAGE);
        }
    }

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Defines the interface for the expression language interpreter. This allows
 * users to provide custom EL interpreter implementations that can optimise
 * EL processing for an application by , for example, performing code generation
 * for simple expressions.
 */
    /**
     * Returns the string representing the code that will be inserted into the
     * servlet generated for JSP. The default implementation creates a call to
     * {@link org.apache.jasper.runtime.PageContextImpl#proprietaryEvaluate(
     * String, Class, javax.servlet.jsp.PageContext,
     * org.apache.jasper.runtime.ProtectedFunctionMapper, boolean)} but other
     * implementations may produce more optimised code.
     *
     * @param expression a String containing zero or more "${}" expressions
     * @param expectedType the expected type of the interpreted result
     * @param fnmapvar Variable pointing to a function map.
     * @param xmlEscape True if the result should do XML escaping
     * @return a String representing a call to the EL interpreter.
     */
    public String interpreterCall(JspCompilationContext context,
            boolean isTagFile, String expression,
            Class<?> expectedType, String fnmapvar, boolean xmlEscape);
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Provides {@link ELInterpreter} instances for JSP compilation.
 *
 * The search order is as follows:
 * <ol>
 * <li>ELInterpreter instance or implementation class name provided as a
 *     ServletContext attribute</li>
 * <li>Implementation class named in a ServletContext initialisation parameter
 *     </li>
 * <li>Default implementation</li>
 * </ol>
 */
    public static final String EL_INTERPRETER_CLASS_NAME =
            ELInterpreter.class.getName();
    private static final ELInterpreter DEFAULT_INSTANCE =
            new DefaultELInterpreter();
    /**
     * Obtain the correct EL Interpreter for the given web application.
     */
    public static ELInterpreter getELInterpreter(ServletContext context)
            throws Exception {
        ELInterpreter result = null;
        // Search for an implementation
        // 1. ServletContext attribute (set by application or cached by a
        //    previous call to this method).
        Object attribute = context.getAttribute(EL_INTERPRETER_CLASS_NAME);
        if (attribute instanceof ELInterpreter) {
            return (ELInterpreter) attribute;
        } else if (attribute instanceof String) {
            result = createInstance(context, (String) attribute);
        }
        // 2. ServletContext init parameter
        if (result == null) {
            String className =
                    context.getInitParameter(EL_INTERPRETER_CLASS_NAME);
            if (className != null) {
                result = createInstance(context, className);
            }
        }
        // 3. Default
        if (result == null) {
            result = DEFAULT_INSTANCE;
        }
        // Cache the result for next time
        context.setAttribute(EL_INTERPRETER_CLASS_NAME, result);
        return result;
    }
    private static ELInterpreter createInstance(ServletContext context,
            String className) throws Exception {
        return (ELInterpreter) context.getClassLoader().loadClass(
                    className).newInstance();
    }
    private ELInterpreterFactory() {
        // Utility class. Hide default constructor.
    }
    public static class DefaultELInterpreter implements ELInterpreter {
        @Override
        public String interpreterCall(JspCompilationContext context,
                boolean isTagFile, String expression,
                Class<?> expectedType, String fnmapvar, boolean xmlEscape) {
            return JspUtil.interpreterCall(isTagFile, expression, expectedType,
                    fnmapvar, xmlEscape);
        }
    }
======= f8ac6a0:"java/org/apache/jasper/compiler/Generator.java"

    private final ELInterpreter elInterpreter;
======= f8ac6a0:"java/org/apache/jasper/compiler/Generator.java"

                v = elInterpreter.interpreterCall(ctxt, this.isTagFile, v,
                        expectedType, attr.getEL().getMapName(), false);
======= f8ac6a0:"java/org/apache/jasper/compiler/Generator.java"

                        + elInterpreter.interpreterCall(ctxt, this.isTagFile,
                                n.getType() + "{" + n.getText() + "}",
                                String.class, n.getEL().getMapName(), false) +
                        ");");
======= f8ac6a0:"java/org/apache/jasper/compiler/Generator.java"

                    attrValue = elInterpreter.interpreterCall(ctxt,
                            this.isTagFile, attrValue, c[0], mapName, false);
======= f8ac6a0:"java/org/apache/jasper/compiler/Generator.java"

    Generator(ServletWriter out, Compiler compiler) throws JasperException {
======= f8ac6a0:"java/org/apache/jasper/compiler/Generator.java"

        ELInterpreter elInterpreter = null;
        try {
            elInterpreter = ELInterpreterFactory.getELInterpreter(
                    compiler.getCompilationContext().getServletContext());
        } catch (Exception e) {
            err.jspError("jsp.error.el_interpreter_class.instantiation",
                    e.getMessage());
        }
        this.elInterpreter = elInterpreter;
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    public static class SimpleELInterpreter implements ELInterpreter {
        @Override
        public String interpreterCall(JspCompilationContext context,
                boolean isTagFile, String expression, Class<?> expectedType,
                String fnmapvar, boolean xmlEscape) {
            return expression;
        }
    }
    @Test
    public void testBug54239() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        Context ctx = tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ServletContext context = ctx.getServletContext();
        ELInterpreter interpreter =
                ELInterpreterFactory.getELInterpreter(context);
        Assert.assertNotNull(interpreter);
        Assert.assertTrue(interpreter instanceof DefaultELInterpreter);
        context.removeAttribute(ELInterpreter.class.getName());
        context.setAttribute(ELInterpreter.class.getName(),
                SimpleELInterpreter.class.getName());
        interpreter = ELInterpreterFactory.getELInterpreter(context);
        Assert.assertNotNull(interpreter);
        Assert.assertTrue(interpreter instanceof SimpleELInterpreter);
        context.removeAttribute(ELInterpreter.class.getName());
        SimpleELInterpreter simpleInterpreter = new SimpleELInterpreter();
        context.setAttribute(ELInterpreter.class.getName(), simpleInterpreter);
        interpreter = ELInterpreterFactory.getELInterpreter(context);
        Assert.assertNotNull(interpreter);
        Assert.assertTrue(interpreter instanceof SimpleELInterpreter);
        Assert.assertTrue(interpreter == simpleInterpreter);
        context.removeAttribute(ELInterpreter.class.getName());
        context.setInitParameter(ELInterpreter.class.getName(),
                SimpleELInterpreter.class.getName());
        interpreter = ELInterpreterFactory.getELInterpreter(context);
        Assert.assertNotNull(interpreter);
        Assert.assertTrue(interpreter instanceof SimpleELInterpreter);
        context.removeAttribute(ELInterpreter.class.getName());
    }

======= cc2f8db:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

            if (readBytes() < 0) {
                throw new IOException(
                        "Unexpected end of stream whilst reading request body");
            }
======= cc2f8db:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

        // Handle optional trailer headers

======= b68bbb8:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

     * The last timestamp used to generate a nonce. Each nonce should get a
     * unique timestamp.
     */
    protected long lastTimestamp = 0;
    protected final Object lastTimestampLock = new Object();
    /**
======= b68bbb8:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

        synchronized (lastTimestampLock) {
            if (currentTime > lastTimestamp) {
                lastTimestamp = currentTime;
            } else {
                currentTime = ++lastTimestamp;
            }
        }
======= b68bbb8:"test/org/apache/catalina/authenticator/TestDigestAuthenticator.java"

======= b68bbb8:"test/org/apache/catalina/authenticator/TestDigestAuthenticator.java"

    @Test
    public void bug54521() throws LifecycleException {
        DigestAuthenticator digestAuthenticator = new DigestAuthenticator();
        digestAuthenticator.setContainer(new TesterContext());
        digestAuthenticator.start();
        Request request = new TesterRequest();
        final int count = 1000;
        Set<String> nonces = new HashSet<>();
        for (int i = 0; i < count; i++) {
            nonces.add(digestAuthenticator.generateNonce(request));
        }
        Assert.assertEquals(count,  nonces.size());
    }
======= b68bbb8:"test/org/apache/catalina/authenticator/TestDigestAuthenticator.java"

    private static class TesterRequest extends Request {
        @Override
        public String getRemoteAddr() {
            return "127.0.0.1";
        }
    }

======= a993d7c2:"java/org/apache/catalina/core/StandardWrapper.java"

        // Make sure the Servlet is loaded with the right class loader
        ClassLoader old = Thread.currentThread().getContextClassLoader();
        ClassLoader webappClassLoader =
                ((Context) getParent()).getLoader().getClassLoader();
            Thread.currentThread().setContextClassLoader(webappClassLoader);
        } finally {
            Thread.currentThread().setContextClassLoader(old);
        return singleThreadModel;

======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

     * The socket poller.
     */
    protected AsyncTimeout asyncTimeout = null;
    public AsyncTimeout getAsyncTimeout() {
        return asyncTimeout;
    }
    /**
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            asyncTimeout = new AsyncTimeout();
            Thread timeoutThread = new Thread(asyncTimeout,
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            poller.stop();
            asyncTimeout.stop();
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        private volatile boolean asyncTimeoutRunning = true;
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            while (asyncTimeoutRunning) {
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                while (paused && asyncTimeoutRunning) {
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        protected void stop() {
            asyncTimeoutRunning = false;
        }
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        private volatile boolean pollerRunning = true;
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        protected void stop() {
            pollerRunning = false;
        }
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    this.notify();
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                            destroySocket(desc[n*2+1], true);
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            while (pollerRunning) {
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                while (pollerRunning && connectionCount < 1 &&
                        addList.size() < 1) {
                        if (getSoTimeout() > 0 && pollerRunning) {
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    if (getSoTimeout() > 0 && maintain++ > 1000 && pollerRunning) {
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        private volatile boolean sendfileRunning = true;
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            sendfileRunning = false;
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            while (sendfileRunning) {
======= bbb13f6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                            maintainTime > 1000000L && sendfileRunning) {

======= ea16bda:"java/org/apache/catalina/loader/WebappClassLoader.java"

======= ea16bda:"java/org/apache/catalina/loader/WebappClassLoader.java"

        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            log.warn(sm.getString(
                    "webappClassLoader.checkThreadLocalsForLeaksFail",
                    getContextName()), t);

======= e1e4e4e:"java/org/apache/catalina/tribes/membership/MemberImpl.java"

        StringBuilder buf = new StringBuilder(getClass().getName());
        buf.append(getName()).append("[");

======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

    private ServletContext servletContext = null;
    private ELContext elContext = null;
    private PageContext rootJspCtxt;
        if (jspContext instanceof JspContextWrapper) {
            rootJspCtxt = ((JspContextWrapper)jspContext).rootJspCtxt;
        }
        else {
            rootJspCtxt = invokingJspCtxt;
        }
======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        return rootJspCtxt.getAttribute(name, scope);
======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

            rootJspCtxt.setAttribute(name, value, scope);
======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

            o = rootJspCtxt.getAttribute(name, REQUEST_SCOPE);
                    o = rootJspCtxt.getAttribute(name, SESSION_SCOPE);
                    o = rootJspCtxt.getAttribute(name, APPLICATION_SCOPE);
======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        rootJspCtxt.removeAttribute(name, REQUEST_SCOPE);
            rootJspCtxt.removeAttribute(name, SESSION_SCOPE);
        rootJspCtxt.removeAttribute(name, APPLICATION_SCOPE);
======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

            rootJspCtxt.removeAttribute(name, scope);
======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

            return rootJspCtxt.getAttributesScope(name);
======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        return rootJspCtxt.getAttributeNamesInScope(scope);
======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        return rootJspCtxt.getOut();
        return rootJspCtxt.getSession();
======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        return rootJspCtxt.getResponse();
======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        if (servletContext == null) {
            servletContext = rootJspCtxt.getServletContext();
        }
        return servletContext;
======= ce55f25:"java/org/apache/jasper/runtime/JspContextWrapper.java"

        if (elContext == null) {
            elContext = rootJspCtxt.getELContext();
        }
        return elContext;

======= 6647531:"java/org/apache/catalina/tribes/group/GroupChannel.java"

     * @param destination Member[] - destination.length > 0
======= 6647531:"java/org/apache/catalina/tribes/group/GroupChannel.java"

     * @param destination Member[] - destination.length > 0

======= d7f744c:"java/org/apache/jasper/compiler/DefaultErrorHandler.java"

                        Integer.valueOf(details[i].getJavaLineNumber()),
                        details[i].getJavaFileName() };

======= 07a930d:"java/org/apache/catalina/realm/DataSourceRealm.java"

                                 username), e);
======= 07a930d:"java/org/apache/catalina/realm/DataSourceRealm.java"

                             username), e);
======= 07a930d:"java/org/apache/catalina/realm/DataSourceRealm.java"

                sm.getString("dataSourceRealm.getRoles.exception", username), e);
======= 07a930d:"java/org/apache/catalina/realm/DataSourceRealm.java"

                                     username), e);

======= ac78456:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                                        injections.get(fieldName),
                                continue;
======= ac78456:"test/org/apache/catalina/startup/TestContextConfig.java"

    public void testBug54448and54450() throws Exception {
======= ac78456:"test/org/apache/catalina/startup/TestContextConfig.java"

        assertPageContains("/test/testServlet",
                "envEntry1: 1 envEntry2: 2 envEntry3: 33 envEntry4: 4");
======= ac78456:"test/org/apache/catalina/startup/TesterServletWithAnnotations.java"

======= ac78456:"test/org/apache/catalina/startup/TesterServletWithAnnotations.java"

    private int envEntry1;
    private int envEntry2;
    private int envEntry3;
    private int envEntry4;
        resp.getWriter().print("envEntry1: " + envEntry1);
        resp.getWriter().print(" envEntry2: " + envEntry2);
        resp.getWriter().print(" envEntry3: " + envEntry3);
        resp.getWriter().print(" envEntry4: " + envEntry4);
    }
    public void setEnvEntry2(int envEntry2) {
        this.envEntry2 = envEntry2;
    }
    @Resource(mappedName = "3")
    public void setEnvEntry3(int envEntry3) {
        this.envEntry3 = envEntry3;
    }
    @Resource(mappedName = "4")
    public void setEnvEntry4(int envEntry4) {
        this.envEntry4 = envEntry4;
  <env-entry>
    <env-entry-name>envEntry2</env-entry-name>
    <env-entry-type>java.lang.Integer</env-entry-type>
    <env-entry-value>2</env-entry-value>
    <injection-target>
      <injection-target-class>org.apache.catalina.startup.TesterServletWithAnnotations</injection-target-class>
      <injection-target-name>envEntry2</injection-target-name>
    </injection-target>
  </env-entry>
  <env-entry>
    <env-entry-name>envEntry3</env-entry-name>
    <env-entry-type>java.lang.Integer</env-entry-type>
    <env-entry-value>33</env-entry-value>
    <injection-target>
      <injection-target-class>org.apache.catalina.startup.TesterServletWithAnnotations</injection-target-class>
      <injection-target-name>envEntry3</injection-target-name>
    </injection-target>
  </env-entry>

======= 74f5b3a:"java/org/apache/catalina/deploy/NamingResources.java"

            targetType = Introspection.convertPrimitiveType(targetType);
======= 74f5b3a:"java/org/apache/catalina/deploy/NamingResources.java"

======= 74f5b3a:"java/org/apache/catalina/startup/WebAnnotationSet.java"

                    Class<?> defaultType = field.getType();
======= 74f5b3a:"java/org/apache/catalina/startup/WebAnnotationSet.java"

                    Class<?> defaultType =
                            (method.getParameterTypes()[0]);
======= 74f5b3a:"java/org/apache/catalina/startup/WebAnnotationSet.java"

            String defaultName, Class<?> defaultType) {
======= 74f5b3a:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    private static String getType(Resource annotation, Class<?> defaultType) {
        Class<?> type = annotation.type();
        if (type == null || type.equals(Object.class)) {
        return Introspection.convertPrimitiveType(type).getCanonicalName();
======= 74f5b3a:"java/org/apache/catalina/util/Introspection.java"

    /**
     * Converts the primitive type to its corresponding wrapper.
     *
     * @param clazz
     *            Class that will be evaluated
     * @return if the parameter is a primitive type returns its wrapper;
     *         otherwise returns the same class
     */
    public static Class<?> convertPrimitiveType(Class<?> clazz) {
        if (clazz.equals(char.class)) {
            return Character.class;
        } else if (clazz.equals(int.class)) {
            return Integer.class;
        } else if (clazz.equals(boolean.class)) {
            return Boolean.class;
        } else if (clazz.equals(double.class)) {
            return Double.class;
        } else if (clazz.equals(byte.class)) {
            return Byte.class;
        } else if (clazz.equals(short.class)) {
            return Short.class;
        } else if (clazz.equals(long.class)) {
            return Long.class;
        } else if (clazz.equals(float.class)) {
            return Float.class;
        } else {
            return clazz;
        }
    }
======= 74f5b3a:"test/org/apache/catalina/startup/TestContextConfig.java"

    @Test
    public void testBug54448() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0-fragments");
        Context context = tomcat.addWebapp(null, "/test",
                appDir.getAbsolutePath());
        Tomcat.addServlet(context, "TestServlet",
                "org.apache.catalina.startup.TesterServletWithAnnotations");
        context.addServletMapping("/testServlet", "TestServlet");
        tomcat.enableNaming();
        tomcat.start();
        assertPageContains("/test/testServlet", "envEntry: 1");
    }
======= 74f5b3a:"test/org/apache/catalina/startup/TestContextConfig.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private static final long serialVersionUID = 1L;
    @Resource(mappedName = "1")
    private int envEntry;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        resp.setContentType("text/plain");
        resp.getWriter().print("envEntry: " + envEntry);
    }

======= ab44514:"java/org/apache/coyote/http11/Http11AprProtocol.java"

    /**
     * Disable SSL compression.
     */
    public boolean getSSLDisableCompression() { return ((AprEndpoint)endpoint).getSSLDisableCompression(); }
    public void setSSLDisableCompression(boolean disable) { ((AprEndpoint)endpoint).setSSLDisableCompression(disable); }
======= ab44514:"java/org/apache/tomcat/jni/SSL.java"

    /* Don't use compression even if supported */
    public static final int SSL_OP_NO_COMPRESSION                         = 0x00020000;
======= ab44514:"java/org/apache/tomcat/jni/SSL.java"

     * Return true if all the requested SSL_OP_* are supported by OpenSSL.
     * 
     * <i>Note that for versions of tcnative &lt; 1.1.25, this method will
     * return <code>true</code> if and only if <code>op</code>=
     * {@link #SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION} and tcnative
     * supports that flag.</i>
     *
     * @param Bitwise-OR of all SSL_OP_* to test.
     * 
     * @return true if all SSL_OP_* are supported by OpenSSL library.
======= ab44514:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    /**
     * Disables compression of the SSL stream. This thwarts CRIME attack
     * and possibly improves performance by not compressing uncompressible
     * content such as JPEG, etc.
     */
    protected boolean SSLDisableCompression = false;
    /**
     * Set to <code>true</code> to disable SSL compression. This thwarts CRIME
     * attack.
     */
    public void setSSLDisableCompression(boolean SSLDisableCompression) { this.SSLDisableCompression = SSLDisableCompression; }
    public boolean getSSLDisableCompression() { return SSLDisableCompression; }
======= ab44514:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            // Disable compression if requested
            if (SSLDisableCompression) {
                boolean disableCompressionSupported = false;
                try {
                    disableCompressionSupported = SSL.hasOp(SSL.SSL_OP_NO_COMPRESSION);
                    if (disableCompressionSupported)
                        SSLContext.setOptions(sslContext, SSL.SSL_OP_NO_COMPRESSION);
                } catch (UnsatisfiedLinkError e) {
                    // Ignore
                }
                if (!disableCompressionSupported) {
                    // OpenSSL does not support ciphers ordering.
                    log.warn(sm.getString("endpoint.warn.noDisableCompression",
                                          SSL.versionString()));
                }
            }
    <attribute name="SSLDisableCompression" required="false">
      <p>Disables compression if set to <code>true</code> and OpenSSL supports
      disabling comprssion. Default is <code>false</code> which inherits the
      default compression setting in OpenSSL.</p>
    </attribute>

======= c8d5d88:"java/org/apache/catalina/realm/RealmBase.java"

        String md5a1 = getDigest(username, realm);
        md5a1 = md5a1.toLowerCase(Locale.ENGLISH);

======= 297b26a:"java/org/apache/jasper/JspC.java"

        context.setClassLoader(loader);
======= 297b26a:"java/org/apache/jasper/servlet/JspCServletContext.java"

    /**
     * Web application class loader.
     */
    private ClassLoader loader;
    // ----------------------------------------------------------- Constructors
======= 297b26a:"java/org/apache/jasper/servlet/JspCServletContext.java"

        return loader;
    }
    public void setClassLoader(ClassLoader loader) {
        this.loader = loader;

======= 9f657ac:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    private String[] enabledCiphers;
    private String[] enabledProtocols;
======= 9f657ac:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        return enabledCiphers;
======= 9f657ac:"java/org/apache/tomcat/util/net/NioEndpoint.java"

            // Determine which cipher suites and protocols to enable
            enabledCiphers = sslUtil.getEnableableCiphers(sslContext);
            enabledProtocols = sslUtil.getEnableableProtocols(sslContext);
======= 9f657ac:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        engine.setEnabledCipherSuites(enabledCiphers);
        engine.setEnabledProtocols(enabledProtocols);
======= 9f657ac:"java/org/apache/tomcat/util/net/SSLUtil.java"

    /**
     * Determines the SSL cipher suites that can be enabled, based on the
     * configuration of the endpoint and the ciphers supported by the SSL
     * implementation.
     *
     * @param context An initialized context to obtain the supported ciphers from.
     *
     * @return Array of SSL cipher suites that may be enabled (which may be
     *         empty if none of the specified ciphers are supported), or
     *         the defaults for the underlying SSL implementation if 
     *         the endpoint configuration does not specify any ciphers.
     */
    public String[] getEnableableCiphers(SSLContext context);
    /**
     * Determines the SSL protocol variants that can be enabled, based on the
     * configuration of the endpoint and the ciphers supported by the SSL
     * implementation.
     *
     * @param context An initialized context to obtain the supported protocols from.
     *
     * @return Array of SSL protocol variants that may be enabled (which may be
     *         empty if none of the specified protocols are supported), or
     *         the defaults for the underlying SSL implementation if 
     *         the endpoint configuration does not specify any protocols.
     */
    public String[] getEnableableProtocols(SSLContext context);
======= 9f657ac:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

======= 9f657ac:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

    protected String[] enabledProtocols;
======= 9f657ac:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

    @Override
    public String[] getEnableableCiphers(SSLContext context) {
        String requestedCiphersStr = endpoint.getCiphers();
        if (ALLOW_ALL_SUPPORTED_CIPHERS.equals(requestedCiphersStr)) {
            return context.getSupportedSSLParameters().getCipherSuites();
        }
        if ((requestedCiphersStr == null)
                || (requestedCiphersStr.trim().length() == 0)) {
            return context.getDefaultSSLParameters().getCipherSuites();
        }
        List<String> requestedCiphers = new ArrayList<String>();
        for (String rc : requestedCiphersStr.split(",")) {
            final String cipher = rc.trim();
            if (cipher.length() > 0) {
                requestedCiphers.add(cipher);
        }
        if (requestedCiphers.isEmpty()) {
            return context.getDefaultSSLParameters().getCipherSuites();
        }
        List<String> ciphers = new ArrayList<String>(requestedCiphers);
        ciphers.retainAll(Arrays.asList(context.getSupportedSSLParameters()
                .getCipherSuites()));
        if (ciphers.isEmpty()) {
            log.warn(sm.getString("jsse.requested_ciphers_not_supported",
                    requestedCiphersStr));
        }
        if (log.isDebugEnabled()) {
            log.debug(sm.getString("jsse.enableable_ciphers", ciphers));
            if (ciphers.size() != requestedCiphers.size()) {
                List<String> skipped = new ArrayList<String>(requestedCiphers);
                skipped.removeAll(ciphers);
                log.debug(sm.getString("jsse.unsupported_ciphers", skipped));
        return ciphers.toArray(new String[ciphers.size()]);
======= 9f657ac:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            enabledCiphers = getEnableableCiphers(context);
            enabledProtocols = getEnableableProtocols(context);
======= 9f657ac:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

    @Override
    public String[] getEnableableProtocols(SSLContext context) {
        String[] requestedProtocols = endpoint.getSslEnabledProtocolsArray();
        if ((requestedProtocols == null) || (requestedProtocols.length == 0)) {
            return context.getDefaultSSLParameters().getProtocols();
        }
        List<String> protocols = new ArrayList<String>(
                Arrays.asList(requestedProtocols));
        protocols.retainAll(Arrays.asList(context.getSupportedSSLParameters()
                .getProtocols()));
        if (protocols.isEmpty()) {
            log.warn(sm.getString("jsse.requested_protocols_not_supported",
                    Arrays.asList(requestedProtocols)));
        }
        if (log.isDebugEnabled()) {
            log.debug(sm.getString("jsse.enableable_protocols", protocols));
            if (protocols.size() != requestedProtocols.length) {
                List<String> skipped = new ArrayList<String>(
                        Arrays.asList(requestedProtocols));
                skipped.removeAll(protocols);
                log.debug(sm.getString("jsse.unsupported_protocols", skipped));
        return protocols.toArray(new String[protocols.size()]);
======= 9f657ac:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

        socket.setEnabledCipherSuites(enabledCiphers);
        socket.setEnabledProtocols(enabledProtocols);
        
      <p>The comma separated list of encryption ciphers to support for HTTPS
      connections. If specified, only the ciphers that are listed and supported
      by the SSL implementation will be used. By default, the default ciphers
      for the JVM will be used. Note that this usually means that the weak
      export grade ciphers will be included in the list of available ciphers.
      The ciphers are specified using the JSSE cipher naming convention. The
      special value of <code>ALL</code> will enable all supported ciphers. This
      will include many that are not secure. <code>ALL</code> is intended for
      testing purposes only.</p>
      connections. If specified, only the protocols that are listed and
      supported by the SSL implementation will be enabled. If not specified,
      the JVM default is used. The permitted values may be obtained from the
      JVM documentation for the allowed values for 

======= 334c466:"java/org/apache/catalina/deploy/WebXml.java"

        String oldServletName = servletMappings.put(urlPattern, servletName);
        if (oldServletName != null) {
            // Duplicate mapping. As per clarification from the Servlet EG,
            // deployment should fail.
            throw new IllegalArgumentException(sm.getString(
                    "webXml.duplicateServletMapping", oldServletName,
                    servletName, urlPattern));
        }
======= 334c466:"test/org/apache/catalina/deploy/TestWebXml.java"

    @Test(expected=IllegalArgumentException.class)
    public void testBug54387a() {
        // Multiple servlets may not be mapped to the same url-pattern
        WebXml webxml = new WebXml();
        webxml.addServletMapping("/foo", "a");
        webxml.addServletMapping("/foo", "b");
    }
    @Test(expected=IllegalArgumentException.class)
    public void testBug54387b() {
        // Multiple servlets may not be mapped to the same url-pattern
        WebXml webxml = new WebXml();
        WebXml f1 = new WebXml();
        WebXml f2 = new WebXml();
        HashSet<WebXml> fragments = new HashSet<>();
        fragments.add(f1);
        fragments.add(f2);
        f1.addServletMapping("/foo", "a");
        f2.addServletMapping("/foo", "b");
        webxml.merge(fragments);
    }
    @Test
    public void testBug54387c() {
        // Multiple servlets may not be mapped to the same url-pattern but main
        // web.xml takes priority
        WebXml webxml = new WebXml();
        WebXml f1 = new WebXml();
        WebXml f2 = new WebXml();
        HashSet<WebXml> fragments = new HashSet<>();
        fragments.add(f1);
        fragments.add(f2);
        f1.addServletMapping("/foo", "a");
        f2.addServletMapping("/foo", "b");
        webxml.addServletMapping("/foo", "main");
        webxml.merge(fragments);
    }

======= 71d075e:"java/org/apache/catalina/Context.java"

======= 71d075e:"java/org/apache/catalina/Context.java"

    /**
     * Add a post construct method definition for the given class, if there is
     * an existing definition for the specified class - IllegalArgumentException
     * will be thrown.
     *
     * @param clazz Fully qualified class name
     * @param method
     *            Post construct method name
     * @throws IllegalArgumentException
     *             if the fully qualified class name or method name are
     *             <code>NULL</code>; if there is already post construct method
     *             definition for the given class
     */
    public void addPostConstructMethod(String clazz, String method);
    /**
     * Add a pre destroy method definition for the given class, if there is an
     * existing definition for the specified class - IllegalArgumentException
     * will be thrown.
     *
     * @param clazz Fully qualified class name
     * @param method
     *            Post construct method name
     * @throws IllegalArgumentException
     *             if the fully qualified class name or method name are
     *             <code>NULL</code>; if there is already pre destroy method
     *             definition for the given class
     */
    public void addPreDestroyMethod(String clazz, String method);
    /**
     * Removes the post construct method definition for the given class, if it
     * exists; otherwise, no action is taken.
     *
     * @param clazz
     *            Fully qualified class name
     */
    public void removePostConstructMethod(String clazz);
    /**
     * Removes the pre destroy method definition for the given class, if it
     * exists; otherwise, no action is taken.
     *
     * @param clazz
     *            Fully qualified class name
     */
    public void removePreDestroyMethod(String clazz);
    /**
     * Returns the method name that is specified as post construct method for
     * the given class, if it exists; otherwise <code>NULL</code> will be
     * returned.
     *
     * @param clazz
     *            Fully qualified class name
     *
     * @return the method name that is specified as post construct method for
     *         the given class, if it exists; otherwise <code>NULL</code> will
     *         be returned.
     */
    public String findPostConstructMethod(String clazz);
    /**
     * Returns the method name that is specified as pre destroy method for the
     * given class, if it exists; otherwise <code>NULL</code> will be returned.
     *
     * @param clazz
     *            Fully qualified class name
     *
     * @return the method name that is specified as pre destroy method for the
     *         given class, if it exists; otherwise <code>NULL</code> will be
     *         returned.
     */
    public String findPreDestroyMethod(String clazz);
    /**
     * Returns a map with keys - fully qualified class names of the classes that
     * have post construct methods and the values are the corresponding method
     * names. If there are no such classes an empty map will be returned.
     *
     * @return a map with keys - fully qualified class names of the classes that
     *         have post construct methods and the values are the corresponding
     *         method names.
     */
    public Map<String, String> findPostConstructMethods();
    /**
     * Returns a map with keys - fully qualified class names of the classes that
     * have pre destroy methods and the values are the corresponding method
     * names. If there are no such classes an empty map will be returned.
     *
     * @return a map with keys - fully qualified class names of the classes that
     *         have pre destroy methods and the values are the corresponding
     *         method names.
     */
    public Map<String, String> findPreDestroyMethods();
======= 71d075e:"java/org/apache/catalina/core/DefaultInstanceManager.java"

======= 71d075e:"java/org/apache/catalina/core/DefaultInstanceManager.java"

    private final Map<String, String> postConstructMethods;
    private final Map<String, String> preDestroyMethods;
======= 71d075e:"java/org/apache/catalina/core/DefaultInstanceManager.java"

        this.postConstructMethods = catalinaContext.findPostConstructMethods();
        this.preDestroyMethods = catalinaContext.findPreDestroyMethods();
======= 71d075e:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                String postConstructFromXml = postConstructMethods.get(clazz.getName());
                String preDestroyFromXml = preDestroyMethods.get(clazz.getName());
======= 71d075e:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                    postConstruct = findPostConstruct(postConstruct, postConstructFromXml, method);
                    preDestroy = findPreDestroy(preDestroy, preDestroyFromXml, method);
                } else if (postConstructFromXml != null) {
                    throw new IllegalArgumentException("Post construct method "
                        + postConstructFromXml + " for class " + clazz.getName()
                        + " is declared in deployment descriptor but cannot be found.");
                } else if (preDestroyFromXml != null) {
                    throw new IllegalArgumentException("Pre destroy method "
                        + preDestroyFromXml + " for class " + clazz.getName()
                        + " is declared in deployment descriptor but cannot be found.");
======= 71d075e:"java/org/apache/catalina/core/DefaultInstanceManager.java"

    private static Method findPostConstruct(Method currentPostConstruct,
            String postConstructFromXml, Method method) {
        return findLifecycleCallback(currentPostConstruct,
            postConstructFromXml, method, PostConstruct.class);
    }
    private static Method findPreDestroy(Method currentPreDestroy,
        String preDestroyFromXml, Method method) {
        return findLifecycleCallback(currentPreDestroy,
            preDestroyFromXml, method, PreDestroy.class);
    }
    private static Method findLifecycleCallback(Method currentMethod,
            String methodNameFromXml, Method method,
            Class<? extends Annotation> annotation) {
        Method result = currentMethod;
        if (methodNameFromXml != null) {
            if (method.getName().equals(methodNameFromXml)) {
                if (!Introspection.isValidLifecycleCallback(method)) {
                    throw new IllegalArgumentException(
                        "Invalid " + annotation.getName() + " annotation");
                }
                result = method;
            }
        } else {
            if (method.isAnnotationPresent(annotation)) {
                if (currentMethod != null ||
                    !Introspection.isValidLifecycleCallback(method)) {
                    throw new IllegalArgumentException(
                        "Invalid " + annotation.getName() + " annotation");
                }
                result = method;
            }
        }
        return result;
    }
======= 71d075e:"java/org/apache/catalina/core/StandardContext.java"

    private Map<String, String> postConstructMethods = new HashMap<>();
    private Map<String, String> preDestroyMethods = new HashMap<>();
======= 71d075e:"java/org/apache/catalina/core/StandardContext.java"

    @Override
    public void addPostConstructMethod(String clazz, String method) {
        if (clazz == null || method == null)
            throw new IllegalArgumentException(
                    sm.getString("standardContext.postconstruct.required"));
        if (postConstructMethods.get(clazz) != null)
            throw new IllegalArgumentException(sm.getString(
                    "standardContext.postconstruct.duplicate", clazz));
        postConstructMethods.put(clazz, method);
        fireContainerEvent("addPostConstructMethod", clazz);
    }
    @Override
    public void removePostConstructMethod(String clazz) {
        postConstructMethods.remove(clazz);
        fireContainerEvent("removePostConstructMethod", clazz);
    }
    @Override
    public void addPreDestroyMethod(String clazz, String method) {
        if (clazz == null || method == null)
            throw new IllegalArgumentException(
                    sm.getString("standardContext.predestroy.required"));
        if (preDestroyMethods.get(clazz) != null)
            throw new IllegalArgumentException(sm.getString(
                    "standardContext.predestroy.duplicate", clazz));
        preDestroyMethods.put(clazz, method);
        fireContainerEvent("addPreDestroyMethod", clazz);
    }
    @Override
    public void removePreDestroyMethod(String clazz) {
        preDestroyMethods.remove(clazz);
        fireContainerEvent("removePreDestroyMethod", clazz);
    }
    @Override
    public String findPostConstructMethod(String clazz) {
        return postConstructMethods.get(clazz);
    }
    @Override
    public String findPreDestroyMethod(String clazz) {
        return preDestroyMethods.get(clazz);
    }
    @Override
    public Map<String, String> findPostConstructMethods() {
        return postConstructMethods;
    }
    @Override
    public Map<String, String> findPreDestroyMethods() {
        return preDestroyMethods;
    }
======= 71d075e:"java/org/apache/catalina/deploy/WebXml.java"

    // post-construct elements
    private Map<String, String> postConstructMethods = new HashMap<>();
    public void addPostConstructMethods(String clazz, String method) {
        if (!postConstructMethods.containsKey(clazz)) {
            postConstructMethods.put(clazz, method);
        }
    }
    public Map<String, String> getPostConstructMethods() {
        return postConstructMethods;
    }
    // pre-destroy elements
    private Map<String, String> preDestroyMethods = new HashMap<>();
    public void addPreDestroyMethods(String clazz, String method) {
        if (!preDestroyMethods.containsKey(clazz)) {
            preDestroyMethods.put(clazz, method);
        }
    }
    public Map<String, String> getPreDestroyMethods() {
        return preDestroyMethods;
    }
======= 71d075e:"java/org/apache/catalina/deploy/WebXml.java"

        if (!postConstructMethods.isEmpty()) {
            for (Entry<String, String> entry : postConstructMethods
                    .entrySet()) {
                sb.append("  <post-construct>\n");
                appendElement(sb, INDENT4, "lifecycle-callback-class",
                        entry.getKey());
                appendElement(sb, INDENT4, "lifecycle-callback-method",
                        entry.getValue());
                sb.append("  </post-construct>\n");
            }
            sb.append('\n');
        }
        if (!preDestroyMethods.isEmpty()) {
            for (Entry<String, String> entry : preDestroyMethods
                    .entrySet()) {
                sb.append("  <pre-destroy>\n");
                appendElement(sb, INDENT4, "lifecycle-callback-class",
                        entry.getKey());
                appendElement(sb, INDENT4, "lifecycle-callback-method",
                        entry.getValue());
                sb.append("  </pre-destroy>\n");
            }
            sb.append('\n');
        }
======= 71d075e:"java/org/apache/catalina/deploy/WebXml.java"

        for (Entry<String, String> entry : postConstructMethods.entrySet()) {
            context.addPostConstructMethod(entry.getKey(), entry.getValue());
        }
        for (Entry<String, String> entry : preDestroyMethods.entrySet()) {
            context.addPreDestroyMethod(entry.getKey(), entry.getValue());
        }
======= 71d075e:"java/org/apache/catalina/deploy/WebXml.java"

        if (postConstructMethods.isEmpty()) {
            for (WebXml fragment : fragments) {
                if (!mergeLifecycleCallback(fragment.getPostConstructMethods(),
                        temp.getPostConstructMethods(), fragment,
                        "Post Construct Methods")) {
                    return false;
                }
            }
            postConstructMethods.putAll(temp.getPostConstructMethods());
        }
        if (preDestroyMethods.isEmpty()) {
            for (WebXml fragment : fragments) {
                if (!mergeLifecycleCallback(fragment.getPreDestroyMethods(),
                        temp.getPreDestroyMethods(), fragment,
                        "Pre Destroy Methods")) {
                    return false;
                }
            }
            preDestroyMethods.putAll(temp.getPreDestroyMethods());
        }
======= 71d075e:"java/org/apache/catalina/deploy/WebXml.java"

    private static <T> boolean mergeLifecycleCallback(
            Map<String, String> fragmentMap, Map<String, String> tempMap,
            WebXml fragment, String mapName) {
        for (Entry<String, String> entry : fragmentMap.entrySet()) {
            final String key = entry.getKey();
            final String value = entry.getValue();
            if (tempMap.containsKey(key)) {
                if (value != null && !value.equals(tempMap.get(key))) {
                    log.error(sm.getString("webXml.mergeConflictString",
                            mapName, key, fragment.getName(), fragment.getURL()));
                    return false;
                }
            } else {
                tempMap.put(key, value);
            }
        }
        return true;
    }
======= 71d075e:"java/org/apache/catalina/startup/FailedContext.java"

======= 71d075e:"java/org/apache/catalina/startup/FailedContext.java"

    @Override
    public void addPostConstructMethod(String clazz, String method) { /* NO-OP */ }
    @Override
    public void addPreDestroyMethod(String clazz, String method) { /* NO-OP */ }
    @Override
    public void removePostConstructMethod(String clazz) { /* NO-OP */ }
    @Override
    public void removePreDestroyMethod(String clazz) { /* NO-OP */ }
    @Override
    public String findPostConstructMethod(String clazz) { return null; }
    @Override
    public String findPreDestroyMethod(String clazz) { return null; }
    @Override
    public Map<String, String> findPostConstructMethods() { return null; }
    @Override
    public Map<String, String> findPreDestroyMethods() { return null; }
======= 71d075e:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/post-construct",
                new LifecycleCallbackRule("addPostConstructMethods", 2, true));
        digester.addCallParam(fullPrefix + "/post-construct/lifecycle-callback-class", 0);
        digester.addCallParam(fullPrefix + "/post-construct/lifecycle-callback-method", 1);
        digester.addRule(fullPrefix + "/pre-destroy",
                new LifecycleCallbackRule("addPreDestroyMethods", 2, false));
        digester.addCallParam(fullPrefix + "/pre-destroy/lifecycle-callback-class", 0);
        digester.addCallParam(fullPrefix + "/pre-destroy/lifecycle-callback-method", 1);
======= 71d075e:"java/org/apache/catalina/startup/WebRuleSet.java"

 * A rule that fails if more than one post construct or pre destroy methods
 * are configured per class.
 */
    private final boolean postConstruct;
    public LifecycleCallbackRule(String methodName, int paramCount,
            boolean postConstruct) {
        super(methodName, paramCount);
        this.postConstruct = postConstruct;
    }
    @Override
    public void end(String namespace, String name) throws Exception {
        Object[] params = (Object[]) digester.peekParams();
        if (params != null && params.length == 2) {
            WebXml webXml = (WebXml) digester.peek();
            if (postConstruct) {
                if (webXml.getPostConstructMethods().containsKey(params[0])) {
                    throw new IllegalArgumentException(WebRuleSet.sm.getString(
                            "webRuleSet.postconstruct.duplicate", params[0]));
                }
            } else {
                if (webXml.getPreDestroyMethods().containsKey(params[0])) {
                    throw new IllegalArgumentException(WebRuleSet.sm.getString(
                            "webRuleSet.predestroy.duplicate", params[0]));
                }
            }
        }
        super.end(namespace, name);
    }
======= 71d075e:"java/org/apache/catalina/util/Introspection.java"

======= 71d075e:"java/org/apache/catalina/util/Introspection.java"

    /**
     * Determines if a method is a valid lifecycle callback method.
     *
     * @param method
     *            The method to test
     *
     * @return <code>true</code> if the method is a valid lifecycle callback
     *         method, else <code>false</code>
     */
    public static boolean isValidLifecycleCallback(Method method) {
        if (method.getParameterTypes().length != 0
                || Modifier.isStatic(method.getModifiers())
                || method.getExceptionTypes().length > 0
                || !method.getReturnType().getName().equals("void")) {
            return false;
        }
        return true;
    }
======= 71d075e:"test/org/apache/catalina/core/TestStandardContext.java"

    @Test(expected = IllegalArgumentException.class)
    public void testAddPostConstructMethodNullClassName() {
        new StandardContext().addPostConstructMethod(null, "");
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddPostConstructMethodNullMethodName() {
        new StandardContext().addPostConstructMethod("", null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddPostConstructMethodConflicts() {
        StandardContext standardContext = new StandardContext();
        standardContext.addPostConstructMethod("a", "a");
        standardContext.addPostConstructMethod("a", "b");
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddPreDestroyMethodNullClassName() {
        new StandardContext().addPreDestroyMethod(null, "");
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddPreDestroyMethodNullMethodName() {
        new StandardContext().addPreDestroyMethod("", null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddPreDestroyMethodConflicts() {
        StandardContext standardContext = new StandardContext();
        standardContext.addPreDestroyMethod("a", "a");
        standardContext.addPreDestroyMethod("a", "b");
    }
======= 71d075e:"test/org/apache/catalina/core/TesterContext.java"

======= 71d075e:"test/org/apache/catalina/core/TesterContext.java"

    @Override
    public void addPostConstructMethod(String clazz, String method) {
        // NO-OP
    }
    @Override
    public void addPreDestroyMethod(String clazz, String method) {
        // NO-OP
    }
    @Override
    public void removePostConstructMethod(String clazz) {
        // NO-OP
    }
    @Override
    public void removePreDestroyMethod(String clazz) {
        // NO-OP
    }
    @Override
    public String findPostConstructMethod(String clazz) {
        return null;
    }
    @Override
    public String findPreDestroyMethod(String clazz) {
        return null;
    }
    @Override
    public Map<String,String> findPostConstructMethods() {
        return null;
    }
    @Override
    public Map<String,String> findPreDestroyMethods() {
        return null;
    }
======= 71d075e:"test/org/apache/catalina/deploy/TestWebXml.java"

======= 71d075e:"test/org/apache/catalina/deploy/TestWebXml.java"

        Assert.assertEquals(3, webxml.getMajorVersion());
        Assert.assertEquals(0, webxml.getMinorVersion());
        Assert.assertEquals(2, webxml.getMajorVersion());
        Assert.assertEquals(5, webxml.getMinorVersion());
        Assert.assertEquals(0, webxml.getMajorVersion());
        Assert.assertEquals(0, webxml.getMinorVersion());
        Assert.assertEquals(0, webxml.getMajorVersion());
        Assert.assertEquals(0, webxml.getMinorVersion());
        Assert.assertEquals(3, webxml.getMajorVersion());
        Assert.assertEquals(0, webxml.getMinorVersion());
        Assert.assertEquals(3, webxml.getMajorVersion());
        Assert.assertEquals(0, webxml.getMinorVersion());
        Assert.assertEquals(0, webxml.getMajorVersion());
        Assert.assertEquals(5, webxml.getMinorVersion());
        Assert.assertEquals(2, webxml.getMajorVersion());
        Assert.assertEquals(500, webxml.getMinorVersion());
======= 71d075e:"test/org/apache/catalina/deploy/TestWebXml.java"

        Assert.assertEquals(2, webxml.getMajorVersion());
        Assert.assertEquals(2, webxml.getMinorVersion());
        Assert.assertEquals("2.2", webxml.getVersion());
======= 71d075e:"test/org/apache/catalina/deploy/TestWebXml.java"

        Assert.assertEquals(2, webxml.getMajorVersion());
        Assert.assertEquals(3, webxml.getMinorVersion());
        Assert.assertEquals("2.3", webxml.getVersion());
======= 71d075e:"test/org/apache/catalina/deploy/TestWebXml.java"

        Assert.assertEquals(2, webxml.getMajorVersion());
        Assert.assertEquals(4, webxml.getMinorVersion());
        Assert.assertEquals("2.4", webxml.getVersion());
======= 71d075e:"test/org/apache/catalina/deploy/TestWebXml.java"

        Assert.assertEquals(2, webxml.getMajorVersion());
        Assert.assertEquals(5, webxml.getMinorVersion());
        Assert.assertEquals("2.5", webxml.getVersion());
======= 71d075e:"test/org/apache/catalina/deploy/TestWebXml.java"

        Assert.assertEquals(3, webxml.getMajorVersion());
        Assert.assertEquals(0, webxml.getMinorVersion());
        Assert.assertEquals("3.0", webxml.getVersion());
    }
    @Test
    public void testLifecycleMethodsWebXml() {
        WebXml webxml = new WebXml();
        webxml.addPostConstructMethods("a", "a");
        webxml.addPreDestroyMethods("b", "b");
        WebXml fragment = new WebXml();
        fragment.addPostConstructMethods("c", "c");
        fragment.addPreDestroyMethods("d", "d");
        Set<WebXml> fragments = new HashSet<>();
        fragments.add(fragment);
        webxml.merge(fragments);
        Map<String, String> postConstructMethods = webxml.getPostConstructMethods();
        Map<String, String> preDestroyMethods = webxml.getPreDestroyMethods();
        Assert.assertEquals(1, postConstructMethods.size());
        Assert.assertEquals(1, preDestroyMethods.size());
        Assert.assertEquals("a", postConstructMethods.get("a"));
        Assert.assertEquals("b", preDestroyMethods.get("b"));
    }
    @Test
    public void testLifecycleMethodsWebFragments() {
        WebXml webxml = new WebXml();
        WebXml fragment1 = new WebXml();
        fragment1.addPostConstructMethods("a", "a");
        fragment1.addPreDestroyMethods("b", "b");
        WebXml fragment2 = new WebXml();
        fragment2.addPostConstructMethods("c", "c");
        fragment2.addPreDestroyMethods("d", "d");
        Set<WebXml> fragments = new HashSet<>();
        fragments.add(fragment1);
        fragments.add(fragment2);
        webxml.merge(fragments);
        Map<String, String> postConstructMethods = webxml.getPostConstructMethods();
        Map<String, String> preDestroyMethods = webxml.getPreDestroyMethods();
        Assert.assertEquals(2, postConstructMethods.size());
        Assert.assertEquals(2, preDestroyMethods.size());
        Assert.assertEquals("a", postConstructMethods.get("a"));
        Assert.assertEquals("c", postConstructMethods.get("c"));
        Assert.assertEquals("b", preDestroyMethods.get("b"));
        Assert.assertEquals("d", preDestroyMethods.get("d"));
    }
    @Test
    public void testLifecycleMethodsWebFragmentsWithConflicts() {
        WebXml webxml = new WebXml();
        WebXml fragment1 = new WebXml();
        fragment1.addPostConstructMethods("a", "a");
        fragment1.addPreDestroyMethods("b", "a");
        WebXml fragment2 = new WebXml();
        fragment2.addPostConstructMethods("a", "b");
        Set<WebXml> fragments = new HashSet<>();
        fragments.add(fragment1);
        fragments.add(fragment2);
        Assert.assertFalse(webxml.merge(fragments));
        Assert.assertEquals(0, webxml.getPostConstructMethods().size());
        WebXml fragment3 = new WebXml();
        fragment3.addPreDestroyMethods("b", "b");
        fragments.remove(fragment2);
        fragments.add(fragment3);
        Assert.assertFalse(webxml.merge(fragments));
        Assert.assertEquals(0, webxml.getPreDestroyMethods().size());
======= 71d075e:"test/org/apache/catalina/startup/TestContextConfig.java"

======= 71d075e:"test/org/apache/catalina/startup/TestContextConfig.java"

    @Test
    public void testBug54379() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0-fragments");
        Context context =
                tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        Tomcat.addServlet(context, "TestServlet",
                "org.apache.catalina.startup.TesterServletWithLifeCycleMethods");
        context.addServletMapping("/testServlet", "TestServlet");
        tomcat.enableNaming();
        tomcat.start();
        assertPageContains("/test/testServlet", "postConstruct1()");
    }
======= 71d075e:"test/org/apache/catalina/startup/TestWebRuleSet.java"

    @Test
    public void testLifecycleMethodsDefinitions() throws Exception {
        // post-construct and pre-destroy
        parse(new WebXml(), "web-1lifecyclecallback.xml", false, true);
        // conflicting post-construct definitions
        parse(new WebXml(), "web-2lifecyclecallback.xml", false, false);
    }
======= 71d075e:"test/org/apache/catalina/startup/TestWebRuleSet.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private static final long serialVersionUID = 1L;
    private String result;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        resp.setContentType("text/plain");
        resp.getWriter().print(result);
    }
    @PostConstruct
    protected void postConstruct() {
        result = "postConstruct()";
    }
    @PreDestroy
    protected void preDestroy() {
        result = "preDestroy()";
    }
    protected void postConstruct1() {
        result = "postConstruct1()";
    }
    protected void preDestroy1() {
        result = "preDestroy1()";
    }
======= 71d075e:"test/org/apache/catalina/startup/TestWebRuleSet.java"

  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
  version="3.0"
  metadata-complete="true">
  <post-construct>
    <lifecycle-callback-class>test.TestServlet</lifecycle-callback-class>
    <lifecycle-callback-method>postConstruct</lifecycle-callback-method>
  </post-construct>
  <pre-destroy>
    <lifecycle-callback-class>test.TestServlet</lifecycle-callback-class>
    <lifecycle-callback-method>preDestroy</lifecycle-callback-method>
  </pre-destroy>
======= 71d075e:"test/org/apache/catalina/startup/TestWebRuleSet.java"

  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
  version="3.0"
  metadata-complete="true">
  <post-construct>
    <lifecycle-callback-class>test.TestServlet</lifecycle-callback-class>
    <lifecycle-callback-method>postConstruct1</lifecycle-callback-method>
  </post-construct>
  <post-construct>
    <lifecycle-callback-class>test.TestServlet</lifecycle-callback-class>
    <lifecycle-callback-method>postConstruct2</lifecycle-callback-method>
  </post-construct>
  <post-construct>
    <lifecycle-callback-class>org.apache.catalina.startup.TesterServletWithLifeCycleMethods</lifecycle-callback-class>
    <lifecycle-callback-method>postConstruct1</lifecycle-callback-method>
  </post-construct>
  <pre-destroy>
    <lifecycle-callback-class>org.apache.catalina.startup.TesterServletWithLifeCycleMethods</lifecycle-callback-class>
    <lifecycle-callback-method>preDestroy1</lifecycle-callback-method>
  </pre-destroy>

======= d83a5e5:"java/org/apache/catalina/ssi/SSIProcessor.java"

        if (firstLetter == -1) {
            return "";
        } else {
            return cmd.substring(firstLetter, lastLetter + 1);

======= 5f7af1b:"java/org/apache/catalina/websocket/StreamHandler.java"

                    doOnPong(frame.getPayLoad());
======= 5f7af1b:"java/org/apache/catalina/websocket/StreamHandler.java"

    private void doOnPong(ByteBuffer payload) {
        // Need to call onPong using the web application's class loader
        Thread t = Thread.currentThread();
        ClassLoader cl = t.getContextClassLoader();
        t.setContextClassLoader(applicationClassLoader);
        try {
            onPong(payload);
        } finally {
            t.setContextClassLoader(cl);
        }
    }
======= 5f7af1b:"java/org/apache/catalina/websocket/StreamHandler.java"

    /**
     * Intended to be overridden by sub-classes that wish to be notified
     * when a pong is received. The default implementation is a NO-OP.
     *
     * @param payload   The payload included in the pong.
     */
    protected void onPong(ByteBuffer payload) {
        // NO-OP
    }

======= 95e6056:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                        xRequest.getRemoteAddr());
                        xRequest.getRemoteHost());
                        xRequest.getProtocol());
                        Integer.valueOf(xRequest.getServerPort()));
======= 95e6056:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

======= 95e6056:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

            getCoyoteRequest().getAttributes().put(name, value);
        }
        @Override
        public Object getAttribute(String name) {
            return getCoyoteRequest().getAttributes().get(name);
======= 95e6056:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

    @Test
    public void testRequestAttributesForAccessLog() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("protocolHeader", "x-forwarded-proto");
        filterDef.addInitParameter("remoteIpHeader", "x-my-forwarded-for");
        filterDef.addInitParameter("httpServerPort", "8080");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setHeader("x-my-forwarded-for", "140.211.11.130");
        request.setHeader("x-forwarded-proto", "http");
        // TEST
        HttpServletRequest actualRequest =
                testRemoteIpFilter(filterDef, request);
        // VERIFY
        Assert.assertEquals("org.apache.catalina.AccessLog.ServerPort",
                Integer.valueOf(8080),
                actualRequest.getAttribute(AccessLog.SERVER_PORT_ATTRIBUTE));
        Assert.assertEquals("org.apache.catalina.AccessLog.RemoteAddr",
                "140.211.11.130",
                actualRequest.getAttribute(AccessLog.REMOTE_ADDR_ATTRIBUTE));
        Assert.assertEquals("org.apache.catalina.AccessLog.RemoteHost",
                "140.211.11.130",
                actualRequest.getAttribute(AccessLog.REMOTE_HOST_ATTRIBUTE));
    }
======= 95e6056:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

======= 95e6056:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

            getCoyoteRequest().getAttributes().put(name, value);
        }
        @Override
        public Object getAttribute(String name) {
            return getCoyoteRequest().getAttribute(name);
======= 95e6056:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

    @Test
    public void testRequestAttributesForAccessLog() throws Exception {
        // PREPARE
        RemoteIpValve remoteIpValve = new RemoteIpValve();
        remoteIpValve.setRemoteIpHeader("x-forwarded-for");
        remoteIpValve.setProtocolHeader("x-forwarded-proto");
        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();
        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);
        Request request = new MockRequest();
        request.setCoyoteRequest(new org.apache.coyote.Request());
        // client ip
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("192.168.0.10");
        request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-for").setString("140.211.11.130");
        // protocol
        request.setServerPort(8080);
        request.getCoyoteRequest().scheme().setString("http");
        // TEST
        remoteIpValve.invoke(request, null);
        // VERIFY
        Assert.assertEquals("org.apache.catalina.AccessLog.ServerPort",
                Integer.valueOf(8080),
                request.getAttribute(AccessLog.SERVER_PORT_ATTRIBUTE));
        Assert.assertEquals("org.apache.catalina.AccessLog.RemoteAddr",
                "140.211.11.130",
                request.getAttribute(AccessLog.REMOTE_ADDR_ATTRIBUTE));
        Assert.assertEquals("org.apache.catalina.AccessLog.RemoteHost",
                "140.211.11.130",
                request.getAttribute(AccessLog.REMOTE_HOST_ATTRIBUTE));
    }

======= 3a9990b:"java/org/apache/catalina/mapper/MapperListener.java"

                Wrapper w = (Wrapper) obj;
                // Only if the Context has started. If it has not, then it will
                // have its own "after_start" event later.
                if (w.getParent().getState().isAvailable()) {
                    registerWrapper(w);
                }
                Context c = (Context) obj;
                // Only if the Host has started. If it has not, then it will
                // have its own "after_start" event later.
                if (c.getParent().getState().isAvailable()) {
                    registerContext(c);
                }

======= f7fc27a:"java/org/apache/tomcat/util/buf/B2CConverter.java"

======= f7fc27a:"java/org/apache/tomcat/util/buf/B2CConverter.java"

    private CharsetDecoder decoder;
======= f7fc27a:"java/org/apache/tomcat/util/buf/B2CConverter.java"

        decoder.reset();
======= f7fc27a:"java/org/apache/tomcat/util/buf/B2CConverter.java"

    public void reset() throws IOException {
        // Re-create the reader and iis
        iis = new IntermediateInputStream();
        decoder = getCharset(encoding).newDecoder();
        conv = new ReadConvertor(iis, decoder);
======= f7fc27a:"java/org/apache/tomcat/util/buf/B2CConverter.java"

    public ReadConvertor(IntermediateInputStream in, CharsetDecoder decoder) {
        super(in, decoder);
======= f7fc27a:"java/org/apache/tomcat/util/buf/B2CConverter.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    private static final byte[] UTF16_MESSAGE =
            new byte[] {-2, -1, 0, 65, 0, 66, 0, 67};
    @Test
    public void testSingleMessage() throws Exception {
        testMessages(1);
    }
    @Test
    public void testTwoMessage() throws Exception {
        testMessages(2);
    }
    @Test
    public void testManyMessage() throws Exception {
        testMessages(10);
    }
    private void testMessages(int msgCount) throws Exception {
        B2CConverter conv = new B2CConverter("UTF-16");
        ByteChunk bc = new ByteChunk();
        CharChunk cc = new CharChunk();
        for (int i = 0; i < msgCount; i++) {
            bc.append(UTF16_MESSAGE, 0, UTF16_MESSAGE.length);
            // Note: The limit is the number of characters to read
            conv.convert(bc, cc, 3);
            Assert.assertEquals("ABC", cc.toString());
            bc.recycle();
            cc.recycle();
            conv.recycle();
        }
        System.out.println(cc);
    }

======= 113c0bd:"java/org/apache/catalina/core/ApplicationContext.java"

        if (filterName == null || filterName.equals("")) {
            throw new IllegalArgumentException(sm.getString(
                    "applicationContext.invalidFilterName", filterName));
        }
======= 113c0bd:"java/org/apache/catalina/core/ApplicationContext.java"

        if (servletName == null || servletName.equals("")) {
            throw new IllegalArgumentException(sm.getString(
                    "applicationContext.invalidServletName", servletName));
        }
======= 113c0bd:"java/org/apache/catalina/deploy/FilterDef.java"

======= 113c0bd:"java/org/apache/catalina/deploy/FilterDef.java"

    private static final StringManager sm =
        StringManager.getManager(Constants.Package);
======= 113c0bd:"java/org/apache/catalina/deploy/FilterDef.java"

        if (filterName == null || filterName.equals("")) {
            throw new IllegalArgumentException(
                    sm.getString("filterDef.invalidFilterName", filterName));
        }
======= 113c0bd:"java/org/apache/catalina/deploy/ServletDef.java"

======= 113c0bd:"java/org/apache/catalina/deploy/ServletDef.java"

    private static final StringManager sm =
        StringManager.getManager(Constants.Package);
======= 113c0bd:"java/org/apache/catalina/deploy/ServletDef.java"

        if (servletName == null || servletName.equals("")) {
            throw new IllegalArgumentException(
                    sm.getString("servletDef.invalidServletName", servletName));
        }
======= 113c0bd:"test/org/apache/catalina/core/TestApplicationContext.java"

======= 113c0bd:"test/org/apache/catalina/core/TestApplicationContext.java"

    @Test(expected = IllegalArgumentException.class)
    public void testAddFilterWithFilterNameNull() {
        getServletContext().addFilter(null, (Filter) null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddFilterWithFilterNameEmptyString() {
        getServletContext().addFilter("", (Filter) null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddServletWithServletNameNull() {
        getServletContext().addServlet(null, (Servlet) null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testAddServletWithServletNameEmptyString() {
        getServletContext().addServlet("", (Servlet) null);
    }
    private ServletContext getServletContext() {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        // app dir is relative to server home
        StandardContext standardContext = (StandardContext) tomcat.addWebapp(
                null, "/test", appDir.getAbsolutePath());
        return standardContext.getServletContext();
    }
======= 113c0bd:"test/org/apache/catalina/core/TestApplicationContext.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Test case for {@link FilterDef}.
 */
    @Test(expected = IllegalArgumentException.class)
    public void testSetFilterNameNull() {
        new FilterDef().setFilterName(null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testSetFilterNameEmptyString() {
        new FilterDef().setFilterName("");
    }
    @Test
    public void testSetFilterName() {
        FilterDef filterDef = new FilterDef();
        filterDef.setFilterName("test");
        Assert.assertEquals("'test' is expected as filter name",
            "test", filterDef.getFilterName());
    }
======= 113c0bd:"test/org/apache/catalina/core/TestApplicationContext.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Test case for {@link ServletDef}
 */
    @Test(expected = IllegalArgumentException.class)
    public void testSetServletNameNull() {
        new ServletDef().setServletName(null);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testSetServletNameEmptyString() {
        new ServletDef().setServletName("");
    }
    @Test
    public void testSetServletName() {
        ServletDef servletDef = new ServletDef();
        servletDef.setServletName("test");
        Assert.assertEquals("'test' is expected as servlet name",
            "test", servletDef.getServletName());
    }

======= 5418e2b:"java/org/apache/catalina/deploy/WebXml.java"

    public void createAbsoluteOrdering() {
    }
    public void addAbsoluteOrdering(String fragmentName) {
        createAbsoluteOrdering();
        createAbsoluteOrdering();
======= 5418e2b:"java/org/apache/catalina/startup/WebRuleSet.java"

            WebXml webXml = (WebXml) digester.peek();
            webXml.createAbsoluteOrdering();
            if (digester.getLogger().isDebugEnabled()) {
                digester.getLogger().debug(
                        webXml.getClass().getName() + ".setAbsoluteOrdering()");
            }
======= 5418e2b:"test/org/apache/catalina/startup/TestContextConfig.java"

======= 5418e2b:"test/org/apache/catalina/startup/TestContextConfig.java"

        assertPageContains("/test", "OK - Custom default Servlet");
======= 5418e2b:"test/org/apache/catalina/startup/TestContextConfig.java"

        assertPageContains("/test/bug51396.jsp", "<p>OK</p>");
======= 5418e2b:"test/org/apache/catalina/startup/TestContextConfig.java"

        assertPageContains("/test/bug53574", "OK");
    }
    @Test
    public void testBug54262() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0-fragments-empty-absolute-ordering");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        assertPageContains("/test/resourceA.jsp",
                "resourceA.jsp in resources.jar");
        assertPageContains("/test/resources/HelloWorldExample",
                null, HttpServletResponse.SC_NOT_FOUND);
======= 5418e2b:"test/org/apache/catalina/startup/TestContextConfig.java"

    private void assertPageContains(String pageUrl, String expectedBody)
            throws IOException {
        assertPageContains(pageUrl, expectedBody, HttpServletResponse.SC_OK);
    }
    private void assertPageContains(String pageUrl, String expectedBody,
            int expectedStatus) throws IOException {
        ByteChunk res = new ByteChunk();
        int sc = getUrl("http://localhost:" + getPort() + pageUrl, res, null);
        Assert.assertEquals(expectedStatus, sc);
        if (expectedStatus == HttpServletResponse.SC_OK) {
            String result = res.toString();
            Assert.assertTrue(result, result.indexOf(expectedBody) > -1);
        }
    }
======= 5418e2b:"test/org/apache/catalina/startup/TestContextConfig.java"

  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
  version="3.0"
  metadata-complete="false">
  <display-name>Tomcat Test Application</display-name>
  <description>
     Used as part of the Tomcat unit tests when a full web application is
     required.
  </description>
  <absolute-ordering/>

======= 5361e86:"java/org/apache/el/util/ReflectionUtil.java"

======= 5361e86:"java/org/apache/el/util/ReflectionUtil.java"

        if (nonMatchClass == null) {
            // Null will always be ambiguous
            return null;
        }
======= 5361e86:"java/org/apache/el/util/ReflectionUtil.java"

        // Short-cut. null is always assignable to an object and in EL null
        // can always be coerced to a valid value for a primitive
        if (src == null) {
            return true;
        }
======= 5361e86:"java/org/apache/el/util/ReflectionUtil.java"

                if (types[i] == null) {
                    sb.append("null, ");
                } else {
                    sb.append(types[i].getName()).append(", ");
                }
======= 5361e86:"java/org/apache/el/util/ReflectionUtil.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private static final Tester BASE = new Tester();
    /*
     * Expect failure as it is not possible to identify which method named
     * "testA()" is intended.
     */
    @Test(expected=MethodNotFoundException.class)
    public void testBug54370a() {
        ReflectionUtil.getMethod(BASE, "testA",
                new Class[] {null, String.class},
                new Object[] {null, ""});
    }
    /*
     * Expect failure as it is not possible to identify which method named
     * "testB()" is intended. Note: In EL null can always be coerced to a valid
     * value for a primative.
     */
    @Test(expected=MethodNotFoundException.class)
    public void testBug54370b() {
        ReflectionUtil.getMethod(BASE, "testB",
                new Class[] {null, String.class},
                new Object[] {null, ""});
    }
    @Test
    public void testBug54370c() {
        ReflectionUtil.getMethod(BASE, "testC",
                new Class[] {null},
                new Object[] {null});
    }
    @Test
    public void testBug54370d() {
        ReflectionUtil.getMethod(BASE, "testD",
                new Class[] {null},
                new Object[] {null});
    }
======= 5361e86:"java/org/apache/el/util/ReflectionUtil.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @SuppressWarnings("unused")
    public void testA(InputStream param1, String param2) {
        // NO-OP
    }
    @SuppressWarnings("unused")
    public void testA(Long param1, String param2) {
        // NO-OP
    }
    @SuppressWarnings("unused")
    public void testB(InputStream param1, String param2) {
        // NO-OP
    }
    @SuppressWarnings("unused")
    public void testB(long param1, String param2) {
        // NO-OP
    }
    @SuppressWarnings("unused")
    public void testC(long param1) {
        // NO-OP
    }
    @SuppressWarnings("unused")
    public void testD(String param1) {
        // NO-OP
    }

======= 94da507:"java/org/apache/jasper/util/FastRemovalDequeue.java"

        if (element == null || !element.getValid()) {

======= 0ae2f34:"java/org/apache/catalina/util/ExtensionValidator.java"

        // Primarily used for error reporting
        String jarName = null;
                jarName = jar.getName();
                if (jarName.toLowerCase(Locale.ENGLISH).endsWith(".jar") &&
                        ManifestResource mre = new ManifestResource(jarName,
                                jmanifest, ManifestResource.APPLICATION);
        } catch (IOException ioe) {
            throw new IOException("Jar: " + jarName, ioe);

======= 29c4a0e:"java/org/apache/catalina/startup/Bootstrap.java"

        } else {
            // When running as a service the call to stop will be on a new
            // thread so make sure the correct class loader is used to prevent
            // a range of class not found exceptions.
            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);

======= ffc4525:"java/org/apache/jasper/runtime/JspWriterImpl.java"

======= ffc4525:"java/org/apache/jasper/runtime/JspWriterImpl.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void bug54241a() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug54241a.jsp", res, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        String body = res.toString();
        Assert.assertTrue(body.contains("01: null"));
        Assert.assertTrue(body.contains("02: null"));
    }
    @Test
    public void bug54241b() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug5nnnn/bug54241b.jsp", res, null);
        Assert.assertEquals(res.toString(),
                HttpServletResponse.SC_INTERNAL_SERVER_ERROR, rc);
    }
======= ffc4525:"java/org/apache/jasper/runtime/JspWriterImpl.java"

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <body>
    <%
      String nullString = null;
    %>
    <!-- JspWriter.print(Object obj) is defined to print String.valueOf(obj)
         which is "null" if obj is null -->
    <p>01: <%= (Object) null %></p>
    <!-- JspWriter.print(String) is defined to print null for a null String -->
    <p>02: <%= nullString %></p>
  </body>
======= ffc4525:"java/org/apache/jasper/runtime/JspWriterImpl.java"

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  class Bug54241 {
    public String toString() {
      return null;
    }
  }
  <body>
    <%
      Bug54241 bug54241 = new Bug54241();
    %>
    <!-- JspWriter.print(Object obj) is defined to print String.valueOf(obj)
         which is obj.toString() if obj is non-null. If obj.toString is null
         then this will trigger a NullPointerException -->
    <p>01: <%= bug54241 %></p>
  </body>

======= 1c61fb1:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java"

            if ( isJmxEnabled() ) { 
                this.oname = createObjectName(name);
                if (oname!=null) registerJmx();
            }

======= b021a22:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                JdbcInterceptor interceptor = proxies[i].getInterceptorClass().newInstance();
                interceptor.setProperties(proxies[i].getProperties());
                interceptor.poolClosed(this);

======= a2d1441:"java/org/apache/catalina/valves/ErrorReportValve.java"

        if (statusCode < 400 || response.getContentWritten() > 0 ||
                !response.isError()) {
======= a2d1441:"test/org/apache/catalina/valves/TestErrorReportValve.java"

    @Test
    public void testBug54220DoNotSetNotFound() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctx, "bug54220", new Bug54220Servlet(false));
        ctx.addServletMapping("/", "bug54220");
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort(), res, null);
        Assert.assertNull(res.toString());
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
    }
    @Test
    public void testBug54220SetNotFound() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctx, "bug54220", new Bug54220Servlet(true));
        ctx.addServletMapping("/", "bug54220");
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort(), res, null);
        Assert.assertNull(res.toString());
        Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);
    }
    private static final class Bug54220Servlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private boolean setNotFound;
        private Bug54220Servlet(boolean setNotFound) {
            this.setNotFound = setNotFound;
        }
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            if (setNotFound) {
                resp.setStatus(HttpServletResponse.SC_NOT_FOUND);
            }
        }
    }

======= a81538d:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

======= a81538d:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    protected static class PoolCleaner extends TimerTask {
        protected WeakReference<ConnectionPool> pool;
            this.pool = new WeakReference<>(pool);
======= a81538d:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            ConnectionPool pool = this.pool.get();
            if (pool == null) {
                stopRunning();
            } else if (!pool.isClosed() &&
                    (System.currentTimeMillis() - lastRun) > sleepTime) {
======= a81538d:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                }
            }
        }

======= d6b4740:"java/org/apache/naming/java/javaURLContextFactory.java"

 * java.naming.factory.url.pkgs=org.apache.naming property

======= 3c13e90:"java/javax/servlet/http/HttpServletResponse.java"

     * Sends an error response to the client using the specified status code and
     * clears the output buffer. The server defaults to creating the response to
     * look like an HTML-formatted server error page containing the specified
     * message, setting the content type to "text/html", leaving cookies and
     * other headers unmodified. If an error-page declaration has been made for
     * the web application corresponding to the status code passed in, it will
     * be served back in preference to the suggested msg parameter.
======= 3c13e90:"java/javax/servlet/http/HttpServletResponse.java"

     * clears the buffer. This is equivalent to calling {@link #sendError(int,
     * String)} with the same status code and <code>null</code> for the message.

======= 7c4a841:"java/org/apache/jasper/tagplugins/jstl/Util.java"

        String result = escapeXml(buffer.toCharArray(), buffer.length());
        if (result == null) {
            return buffer;
        } else {
            return result;
        }
    }
    @SuppressWarnings("null") // escapedBuffer cannot be null
    public static String escapeXml(char[] arrayBuffer, int length) {
======= 7c4a841:"java/org/apache/jasper/tagplugins/jstl/Util.java"

            return null;
======= 7c4a841:"java/org/apache/jasper/tagplugins/jstl/core/Out.java"

======= 7c4a841:"java/org/apache/jasper/tagplugins/jstl/core/Out.java"

        String strObjectName = ctxt.getTemporaryVariableName();
        ctxt.generateJavaSource("Object " + strObjectName + "=");
        ctxt.generateJavaSource(";");
        ctxt.generateJavaSource("String " + strValName + "=null;");
        ctxt.generateJavaSource("if(!(" + strObjectName +
                " instanceof Reader) && "+ strObjectName + " != null){");
        ctxt.generateJavaSource(
                strValName + " = " + strObjectName + ".toString();");
        ctxt.generateJavaSource("String " + strDefName + " = null;");
======= 7c4a841:"java/org/apache/jasper/tagplugins/jstl/core/Out.java"

                strObjectName + ", " + strValName + ", " + strDefName + ", " +
                strEscapeXmlName + ");");
    public static boolean output(JspWriter out, Object input, String value,
            String defaultValue, boolean escapeXml) throws IOException {
        if (input instanceof Reader) {
            char[] buffer = new char[8096];
            int read = 0;
            while (read != -1) {
                read = ((Reader) input).read(buffer);
                if (read != -1) {
                    if (escapeXml) {
                        String escaped = Util.escapeXml(buffer, read);
                        if (escaped == null) {
                            out.write(buffer, 0, read);
                        } else {
                            out.print(escaped);
                        }
                    } else {
                        out.write(buffer, 0, read);
                    }
                }
            String v = value != null ? value : defaultValue;
            if (v != null) {
                if(escapeXml){
                    v = Util.escapeXml(v);
                }
                out.write(v);
                return true;
            } else {
                return false;
            }
======= 7c4a841:"test/org/apache/jasper/tagplugins/jstl/core/TestOut.java"

        Assert.assertTrue(body.contains("OK - 4"));
         pageEncoding="ISO-8859-1" session="true"
         import="java.io.Reader,java.io.StringReader"%>
    <!-- Use of body as default value -->
    <p><c:out value="${sessionScope.doesNotExist}">OK - 1</c:out></p>
    <p><c:out value="${sessionScope.doesNotExist}">${'OK - '}${1+1}</c:out></p>
    <!-- Special handling for Reader objects -->
    <%
    Reader r = new StringReader("OK - 4");
    session.setAttribute("reader", r);
    %>
    <p><c:out value="${sessionScope.reader}" /></p>

======= 9998c80:"java/org/apache/catalina/manager/StatusTransformer.java"

======= 9998c80:"java/org/apache/catalina/manager/StatusTransformer.java"

        SortedMap<String, MemoryPoolMXBean> memoryPoolMBeans = new TreeMap<>();
        for (MemoryPoolMXBean mbean: ManagementFactory.getMemoryPoolMXBeans()) {
            String sortKey = mbean.getType() + ":" + mbean.getName();
            memoryPoolMBeans.put(sortKey, mbean);
        }
======= 9998c80:"java/org/apache/catalina/manager/StatusTransformer.java"

            writer.write("<table border=\"0\"><thead><tr><th>Memory Pool</th><th>Type</th><th>Initial</th><th>Total</th><th>Maximum</th><th>Used</th></tr></thead><tbody>");
            for (MemoryPoolMXBean memoryPoolMBean : memoryPoolMBeans.values()) {
                MemoryUsage usage = memoryPoolMBean.getUsage();
                writer.write("<tr><td>");
                writer.print(memoryPoolMBean.getName());
                writer.write("</td><td>");
                writer.print(memoryPoolMBean.getType());
                writer.write("</td><td>");
                writer.print(formatSize(Long.valueOf(usage.getInit()), true));
                writer.write("</td><td>");
                writer.print(formatSize(Long.valueOf(usage.getCommitted()), true));
                writer.write("</td><td>");
                writer.print(formatSize(Long.valueOf(usage.getMax()), true));
                writer.write("</td><td>");
                writer.print(formatSize(Long.valueOf(usage.getUsed()), true));
                if (usage.getMax() > 0) {
                    writer.write(" ("
                            + (usage.getUsed() * 100 / usage.getMax()) + "%)");
                }
                writer.write("</td></tr>");
            }
            writer.write("</tbody></table>");
======= 9998c80:"java/org/apache/catalina/manager/StatusTransformer.java"

            for (MemoryPoolMXBean memoryPoolMBean : memoryPoolMBeans.values()) {
                MemoryUsage usage = memoryPoolMBean.getUsage();
                writer.write("<memorypool");
                writer.write(" name='" + memoryPoolMBean.getName() + "'");
                writer.write(" type='" + memoryPoolMBean.getType() + "'");
                writer.write(" usageInit='" + usage.getInit() + "'");
                writer.write(" usageCommitted='" + usage.getCommitted() + "'");
                writer.write(" usageMax='" + usage.getMax() + "'");
                writer.write(" usageUsed='" + usage.getInit() + "'/>");
            }
   <b>Memory Pools</b><br />
   <xsl:apply-templates select="memorypool"/>
   <hr />
  <xsl:template match="memorypool">
    <table><tr>
             <td><b>Name:</b> <xsl:value-of select="@name"/></td>
             <td><b>Type:</b> <xsl:value-of select="@type"/></td>
             <td><b>Initial:</b> <xsl:value-of select="@usageInit"/></td>
             <td><b>Committed:</b> <xsl:value-of select="@usageCommitted"/></td>
             <td><b>Maximum:</b> <xsl:value-of select="@usageMax"/></td>
             <td><b>Used:</b> <xsl:value-of select="@usageUsed"/></td>
           </tr>
    </table>
  </xsl:template>

======= 2ed3d7d:"java/org/apache/catalina/startup/RealmRuleSet.java"

    private static final int MAX_NESTED_REALM_LEVELS = Integer.getInteger(
            "org.apache.catalina.startup.RealmRuleSet.MAX_NESTED_REALM_LEVELS",
            3).intValue();
======= 2ed3d7d:"java/org/apache/catalina/startup/RealmRuleSet.java"

        String pattern = prefix;
        for (int i = 0; i < MAX_NESTED_REALM_LEVELS; i++) {
            if (i > 0) {
                pattern += "/";
            }
            pattern += "Realm";
            digester.addObjectCreate(pattern,
                                     null, // MUST be specified in the element,
                                     "className");
            digester.addSetProperties(pattern);
            if (i == 0) {
                digester.addSetNext(pattern,
                                    "setRealm",
                                    "org.apache.catalina.Realm");
            } else {
                digester.addSetNext(pattern,
                                    "addRealm",
                                    "org.apache.catalina.Realm");
            }
        }
    <property name="org.apache.catalina.startup. RealmRuleSet.MAX_NESTED_REALM_LEVELS">
      <p>The CombinedRealm allows nested Realms. This property controls the
      maximum permitted number of levels of nesting.</p>
      <p>If not specified, the default value of <code>3</code> will be used.</p>
    </property>

======= 810732d:"java/javax/servlet/http/HttpServlet.java"

                long ifModifiedSince;
                try {
                    ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
                } catch (IllegalArgumentException iae) {
                    // Invalid date header - proceed as if none was set
                    ifModifiedSince = -1;
                }

======= 8f53c89:"test/org/apache/catalina/startup/SimpleHttpClient.java"

    /*
     * Expect the server to reply with 100 Continue interim response
     */
======= 8f53c89:"test/org/apache/catalina/startup/SimpleHttpClient.java"

    public List<String> getResponseBodyUriElements() {
        return bodyUriElments;
    }
======= 8f53c89:"test/org/apache/catalina/startup/SimpleHttpClient.java"

    /*
     * Send the component parts of the request
     * (be tolerant and simply skip null entries)
     */
            if (requestPart != null) {
                if (first) {
                    first = false;
                }
                else {
                    Thread.sleep(requestPause);
                }
                writer.write(requestPart);
                writer.flush();

======= 76f84eb:"java/org/apache/catalina/core/AsyncContextImpl.java"

            request.setAttribute(ASYNC_REQUEST_URI, request.getRequestURI());
            request.setAttribute(ASYNC_PATH_INFO, request.getPathInfo());

======= 14637ef:"java/org/apache/catalina/core/AsyncContextImpl.java"

======= 14637ef:"java/org/apache/catalina/core/AsyncContextImpl.java"

                    // No listeners, trigger error handling
                    return false;
======= 14637ef:"java/org/apache/catalina/core/AsyncContextImpl.java"

        // SRV.2.3.3.3 (search for "error dispatch")
        if (servletResponse instanceof HttpServletResponse) {
            ((HttpServletResponse) servletResponse).setStatus(
                    HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
        Host host = (Host) context.getParent();
        Valve stdHostValve = host.getPipeline().getBasic();
        if (stdHostValve instanceof StandardHostValve) {
            ((StandardHostValve) stdHostValve).throwable(request,
                    request.getResponse(), t);
        }
        if (isStarted() && !request.isAsyncDispatching()) {
            complete();
        }
======= 14637ef:"java/org/apache/catalina/core/StandardHostValve.java"

        // An async error page may dispatch to another resource. This flag helps
        // ensure an infinite error handling loop is not entered
        boolean errorAtStart = response.isError();
======= 14637ef:"java/org/apache/catalina/core/StandardHostValve.java"

                if (errorAtStart) {
                    container.getLogger().error("Exception Processing " +
                            request.getRequestURI(), t);
                } else {
                    request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
                    throwable(request, response, t);
                }
            if (!(request.isAsync() || (asyncAtStart &&
                    request.getAttribute(
                            RequestDispatcher.ERROR_EXCEPTION) != null))) {
                // Protect against NPEs if context was destroyed during a
                // long running request.
                    if (!errorAtStart) {
                        // Error page processing
                        response.setSuspended(false);
                        Throwable t = (Throwable) request.getAttribute(
                                RequestDispatcher.ERROR_EXCEPTION);
                        if (t != null) {
                            throwable(request, response, t);
                        } else {
                            status(request, response);
                        }
======= 14637ef:"java/org/apache/catalina/core/StandardHostValve.java"

    protected void throwable(Request request, Response response,
======= 14637ef:"java/org/apache/coyote/AsyncStateMachine.java"

                state == AsyncState.TIMING_OUT ||
                state == AsyncState.ERROR) {
======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        alv.validateAccessLog(2, 500,
======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        doTestTimeout(Boolean.TRUE, null);
        doTestTimeout(Boolean.FALSE, null);
        doTestTimeout(Boolean.TRUE, "/nonasync");
        doTestTimeout(Boolean.FALSE, "/nonasync");
    @Test
    public void testTimeoutNoListener() throws Exception {
        // Should work
        doTestTimeout(null, null);
    }
    private void doTestTimeout(Boolean completeOnTimeout, String dispatchUrl)
======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                new TimeoutServlet(completeOnTimeout, dispatchUrl);
======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        expected.append("TimeoutServletGet-");
        if (completeOnTimeout == null) {
            expected.append("requestDestroyed");
        } else if (completeOnTimeout.booleanValue()) {
            expected.append("onTimeout-");
======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

            expected.append("onTimeout-");
======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        if (completeOnTimeout == null) {
            alvGlobal.validateAccessLog(1, 500, TimeoutServlet.ASYNC_TIMEOUT,
                    TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN +
                    REQUEST_TIME);
            alv.validateAccessLog(1, 500, TimeoutServlet.ASYNC_TIMEOUT,
                    TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN +
                    REQUEST_TIME);
        } else if (completeOnTimeout.booleanValue() && dispatchUrl != null) {
======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        private final Boolean completeOnTimeout;
        public TimeoutServlet(Boolean completeOnTimeout, String dispatchUrl) {
======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                if (completeOnTimeout != null) {
                    ac.addListener(new TrackingListener(false,
                            completeOnTimeout.booleanValue(), dispatchUrl));
                }
======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TimeoutServlet timeout = new TimeoutServlet(Boolean.TRUE, null);
======= 14637ef:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    @Test
    public void testTimeoutErrorDispatchNone() throws Exception {
        doTestTimeoutErrorDispatch(null, null);
    }
    @Test
    public void testTimeoutErrorDispatchNonAsync() throws Exception {
        doTestTimeoutErrorDispatch(Boolean.FALSE, null);
    }
    @Test
    public void testTimeoutErrorDispatchAsyncStart() throws Exception {
        doTestTimeoutErrorDispatch(
                Boolean.TRUE, ErrorPageAsyncMode.NO_COMPLETE);
    }
    @Test
    public void testTimeoutErrorDispatchAsyncComplete() throws Exception {
        doTestTimeoutErrorDispatch(Boolean.TRUE, ErrorPageAsyncMode.COMPLETE);
    }
    @Test
    public void testTimeoutErrorDispatchAsyncDispatch() throws Exception {
        doTestTimeoutErrorDispatch(Boolean.TRUE, ErrorPageAsyncMode.DISPATCH);
    }
    private void doTestTimeoutErrorDispatch(Boolean asyncError,
            ErrorPageAsyncMode mode) throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        File docBase = new File(System.getProperty("java.io.tmpdir"));
        Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
        TimeoutServlet timeout = new TimeoutServlet(null, null);
        Wrapper w1 = Tomcat.addServlet(ctx, "time", timeout);
        w1.setAsyncSupported(true);
        ctx.addServletMapping("/async", "time");
        NonAsyncServlet nonAsync = new NonAsyncServlet();
        Wrapper w2 = Tomcat.addServlet(ctx, "nonAsync", nonAsync);
        w2.setAsyncSupported(true);
        ctx.addServletMapping("/error/nonasync", "nonAsync");
        AsyncErrorPage asyncErrorPage = new AsyncErrorPage(mode);
        Wrapper w3 = Tomcat.addServlet(ctx, "asyncErrorPage", asyncErrorPage);
        w3.setAsyncSupported(true);
        ctx.addServletMapping("/error/async", "asyncErrorPage");
        if (asyncError != null) {
            ErrorPage ep = new ErrorPage();
            ep.setErrorCode(500);
            if (asyncError.booleanValue()) {
                ep.setLocation("/error/async");
            } else {
                ep.setLocation("/error/nonasync");
            }
            ctx.addErrorPage(ep);
        }
        ctx.addApplicationListener(TrackingRequestListener.class.getName());
        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        TesterAccessLogValve alvGlobal = new TesterAccessLogValve();
        tomcat.getHost().getPipeline().addValve(alvGlobal);
        tomcat.start();
        ByteChunk res = new ByteChunk();
        try {
            getUrl("http://localhost:" + getPort() + "/async", res, null);
        } catch (IOException ioe) {
            // Ignore - expected for some error conditions
        }
        StringBuilder expected = new StringBuilder();
        if (asyncError == null) {
            // No error handler - just get the 500 response
            expected.append("requestInitialized-TimeoutServletGet-");
            // Note: With an error handler the response will be reset and these
            //       will be lost
        }
        if (asyncError != null) {
            if (asyncError.booleanValue()) {
                expected.append("AsyncErrorPageGet-");
                if (mode == ErrorPageAsyncMode.NO_COMPLETE){
                    expected.append("NoOp-");
                } else if (mode == ErrorPageAsyncMode.COMPLETE) {
                    expected.append("Complete-");
                } else if (mode == ErrorPageAsyncMode.DISPATCH) {
                    expected.append("Dispatch-NonAsyncServletGet-");
                }
            } else {
                expected.append("NonAsyncServletGet-");
            }
        }
        expected.append("requestDestroyed");
        Assert.assertEquals(expected.toString(), res.toString());
        // Check the access log
        alvGlobal.validateAccessLog(1, 500, TimeoutServlet.ASYNC_TIMEOUT,
                TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN +
                REQUEST_TIME);
        alv.validateAccessLog(1, 500, TimeoutServlet.ASYNC_TIMEOUT,
                TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN +
                REQUEST_TIME);
    }
    private static enum ErrorPageAsyncMode {
        NO_COMPLETE,
        COMPLETE,
        DISPATCH
    }
    private static class AsyncErrorPage extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private final ErrorPageAsyncMode mode;
        public AsyncErrorPage(ErrorPageAsyncMode mode) {
            this.mode = mode;
        }
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            PrintWriter writer = resp.getWriter();
            writer.write("AsyncErrorPageGet-");
            resp.flushBuffer();
            final AsyncContext ctxt = req.getAsyncContext();
            switch(mode) {
                case COMPLETE:
                    writer.write("Complete-");
                    ctxt.complete();
                    break;
                case DISPATCH:
                    writer.write("Dispatch-");
                    ctxt.dispatch("/error/nonasync");
                    break;
                case NO_COMPLETE:
                    writer.write("NoOp-");
                    break;
                default:
                    // Impossible
                    break;
            }
        }
    }

======= 8fea85c:"java/org/apache/catalina/websocket/WsOutbound.java"

        sendControlMessage(data, Constants.OPCODE_PONG);
    }
    /**
     * Send a ping message to the client
     *
     * @param data      Optional message.
     *
     * @throws IOException  If an error occurs writing to the client
     */
    public synchronized void ping(ByteBuffer data) throws IOException {
        sendControlMessage(data, Constants.OPCODE_PING);
    }
    /**
     * Generic function to send either a ping or a pong.
     *
     * @param data      Optional message.
     * @param opcode    The byte to include as the opcode.
     *
     * @throws IOException  If an error occurs writing to the client
     */
    private synchronized void sendControlMessage(ByteBuffer data, byte opcode) throws IOException {
======= 8fea85c:"java/org/apache/catalina/websocket/WsOutbound.java"

        upgradeOutbound.write(0x80 | opcode);

======= 48314f9:"java/org/apache/catalina/core/NamingContextListener.java"

======= 48314f9:"java/org/apache/catalina/core/NamingContextListener.java"

                value = constructEnvEntry(env.getType(), env.getValue());
                if (value == null) {
                    logger.error(sm.getString(
                            "naming.invalidEnvEntryType", env.getName()));
                }
======= 48314f9:"java/org/apache/catalina/core/NamingContextListener.java"

    private Object constructEnvEntry(String type, String value) {
        try {
            Class<?> clazz = Class.forName(type);
            Constructor<?> c = null;
            try {
                 c = clazz.getConstructor(String.class);
                 return c.newInstance(value);
            } catch (NoSuchMethodException e) {
                // Ignore
            }
            if (value.length() != 1) {
                return null;
            }
            try {
                c = clazz.getConstructor(char.class);
                return c.newInstance(Character.valueOf(value.charAt(0)));
            } catch (NoSuchMethodException e) {
                // Ignore
            }
        } catch (Exception e) {
            // Ignore
        }
        return null;
    }
======= 48314f9:"test/org/apache/catalina/core/TestNamingContextListener.java"

    private static final String BUG49132_NAME = "TestName";
    private static final String BUG49132_VALUE = "Test Value";
    private static final String BUG54096_NameA = "envA";
    private static final String BUG54096_ValueA = "valueA";
    private static final String BUG54096_NameB = "envB";
    private static final String BUG54096_ValueB = "B";
======= 48314f9:"test/org/apache/catalina/core/TestNamingContextListener.java"

        environment.setType(BUG49132_VALUE.getClass().getName());
        environment.setName(BUG49132_NAME);
        environment.setValue(BUG49132_VALUE);
======= 48314f9:"test/org/apache/catalina/core/TestNamingContextListener.java"

                String value = (String) envCtx.lookup(BUG49132_NAME);
                if (!BUG49132_VALUE.equals(value)) {
======= 48314f9:"test/org/apache/catalina/core/TestNamingContextListener.java"

    @Test
    public void testBug54096() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        org.apache.catalina.Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        // Enable JNDI - it is disabled by default
        tomcat.enableNaming();
        ContextEnvironment environmentA = new ContextEnvironment();
        environmentA.setType(Bug54096EnvA.class.getName());
        environmentA.setName(BUG54096_NameA);
        environmentA.setValue(BUG54096_ValueA);
        ctx.getNamingResources().addEnvironment(environmentA);
        ContextEnvironment environmentB = new ContextEnvironment();
        environmentB.setType(Bug54096EnvB.class.getName());
        environmentB.setName(BUG54096_NameB);
        environmentB.setValue(BUG54096_ValueB);
        ctx.getNamingResources().addEnvironment(environmentB);
        ctx.addApplicationListener(Bug54096Listener.class.getName());
        tomcat.start();
        assertEquals(LifecycleState.STARTED, ctx.getState());
    }
    public static class Bug54096EnvA {
        private final String value;
        public Bug54096EnvA(String value) {
            this.value = value;
        }
        public String getValue() {
            return value;
        }
    }
    public static class Bug54096EnvB {
        private final char value;
        public Bug54096EnvB(char value) {
            this.value = value;
        }
        public char getValue() {
            return value;
        }
    }
    public static final class Bug54096Listener implements
            ServletContextListener {
        @Override
        public void contextDestroyed(ServletContextEvent sce) {
            // NOOP
        }
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            javax.naming.Context initCtx;
            try {
                initCtx = new InitialContext();
                javax.naming.Context envCtx =
                    (javax.naming.Context) initCtx.lookup("java:comp/env");
                // Validate entry A
                Bug54096EnvA valueA =
                        (Bug54096EnvA) envCtx.lookup(BUG54096_NameA);
                if (!BUG54096_ValueA.equals(valueA.getValue())) {
                    throw new RuntimeException();
                }
                // Validate entry B
                Bug54096EnvB valueB =
                        (Bug54096EnvB) envCtx.lookup(BUG54096_NameB);
                if (BUG54096_ValueB.charAt(0) != valueB.getValue()) {
                    throw new RuntimeException();
                }
            } catch (NamingException e) {
                throw new RuntimeException(e);
            }
        }
    }

======= 9f65875:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

======= 9f65875:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

    private Pattern noKeepAliveUserAgents = null;
    public String getNoKeepAliveUserAgents() {
        Pattern p = noKeepAliveUserAgents;
        if (p == null) {
            return null;
        } else {
            return p.pattern();
        }
    }
    public void setNoKeepAliveUserAgents(String noKeepAliveUserAgents) {
        if (noKeepAliveUserAgents == null ||
                noKeepAliveUserAgents.length() == 0) {
            this.noKeepAliveUserAgents = null;
        } else {
            this.noKeepAliveUserAgents = Pattern.compile(noKeepAliveUserAgents);
        }
    }
======= 9f65875:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

            Pattern p = noKeepAliveUserAgents;
            if (p != null) {
                MessageBytes ua =
                        request.getCoyoteRequest().getMimeHeaders().getValue(
                                "user-agent");
                if (ua != null && p.matcher(ua.toString()).matches()) {
                    response.setHeader("Connection", "close");
                }
            }
      <attribute name="alwaysUseSession" required="false">
        <p>Should a session always be used once a user is authenticated? This
        may offer some performance benefits since the session can then be used
        to cache the authenticated Principal, hence removing the need to
        authenticate the user on every request. This will also help with clients
        that assume that the server will cache the authenticated user. However
        there will also be the performance cost of creating and GC'ing the
        session. For an alternative solution see
        <code>noKeepAliveUserAgents</code>. If not set, the default value of
        <code>false</code> will be used.</p>
      </attribute>
      <attribute name="noKeepAliveUserAgents" required="false">
        <p>Some clients (not most browsers) expect the server to cache the
        authenticated user information for a connection and do not resend the
        credentials with every request. Tomcat will not do this unless an HTTP
        session is available. A session will be availble if either the
        application creates one or if <code>alwaysUseSession</code> is enabled
        for this Authenticator.</p>
        <p>As an alternative to creating a session, this attribute may be used
        to define the user agents for which HTTP keep-alive is disabled. This
        means that a connection will only used for a single request and hence
        there is no ability to cache authenticated user information per
        connection. There will be a performance cost in disabling HTTP
        keep-alive.</p>
        <p>The attribute should be a regular expression that matches the entire
        user-agent string, e.g. <code>.*Chrome.*</code>. If not specified, no
        regular expression will be defined and no user agents will have HTTP
        keep-alive disabled.</p>
      </attribute>

======= 07d343a:"java/org/apache/catalina/deploy/WebXml.java"

======= 07d343a:"java/org/apache/catalina/deploy/WebXml.java"

            // Stage 1. Make all dependencies bi-directional - this makes the
            //          next stage simpler.
                    if (!before.equals(ORDER_OTHERS)) {
                        fragments.get(before).addAfterOrdering(fragment.getName());
                    if (!after.equals(ORDER_OTHERS)) {
                        fragments.get(after).addBeforeOrdering(fragment.getName());
            // Stage 2. Make all fragments that are implicitly before/after
            //          others explicitly so. This is iterative so the next
            //          stage doesn't have to be.
                if (fragment.getBeforeOrdering().contains(ORDER_OTHERS)) {
                    makeBeforeOthersExplicit(fragment.getAfterOrdering(), fragments);
                if (fragment.getAfterOrdering().contains(ORDER_OTHERS)) {
                    makeAfterOthersExplicit(fragment.getBeforeOrdering(), fragments);
            // Stage 3. Separate into three groups
            Set<WebXml> beforeSet = new HashSet<>();
            Set<WebXml> othersSet = new HashSet<>();
            Set<WebXml> afterSet = new HashSet<>();
            for (WebXml fragment : fragments.values()) {
                if (fragment.getBeforeOrdering().contains(ORDER_OTHERS)) {
                    beforeSet.add(fragment);
                    fragment.getBeforeOrdering().remove(ORDER_OTHERS);
                } else if (fragment.getAfterOrdering().contains(ORDER_OTHERS)) {
                    afterSet.add(fragment);
                    fragment.getAfterOrdering().remove(ORDER_OTHERS);
                } else {
                    othersSet.add(fragment);
                }
            // Stage 4. Decouple the groups so the ordering requirements for
            //          each fragment in the group only refer to other fragments
            //          in the group. Ordering requirements outside the group
            //          will be handled by processing the groups in order.
            //          Note: Only after ordering requirements are considered.
            //                This is OK because of the processing in stage 1.
            decoupleOtherGroups(beforeSet);
            decoupleOtherGroups(othersSet);
            decoupleOtherGroups(afterSet);
            // Stage 5. Order each group
            //          Note: Only after ordering requirements are considered.
            //                This is OK because of the processing in stage 1.
            orderFragments(orderedFragments, beforeSet);
            orderFragments(orderedFragments, othersSet);
            orderFragments(orderedFragments, afterSet);
    private static void decoupleOtherGroups(Set<WebXml> group) {
        Set<String> names = new HashSet<>();
        for (WebXml fragment : group) {
            names.add(fragment.getName());
        }
        for (WebXml fragment : group) {
            Iterator<String> after = fragment.getAfterOrdering().iterator();
            while (after.hasNext()) {
                String entry = after.next();
                if (!names.contains(entry)) {
                    after.remove();
                }
            }
        }
    }
    private static void orderFragments(Set<WebXml> orderedFragments,
            Set<WebXml> unordered) {
        Set<WebXml> addedThisRound = new HashSet<>();
        Set<WebXml> addedLastRound = new HashSet<>();
        while (unordered.size() > 0) {
            Iterator<WebXml> source = unordered.iterator();
            while (source.hasNext()) {
                WebXml fragment = source.next();
                for (WebXml toRemove : addedLastRound) {
                    fragment.getAfterOrdering().remove(toRemove.getName());
                }
                if (fragment.getAfterOrdering().isEmpty()) {
                    addedThisRound.add(fragment);
                    orderedFragments.add(fragment);
                    source.remove();
                }
            }
            if (addedThisRound.size() == 0) {
                // Circular
                throw new IllegalArgumentException(
                        sm.getString("webXml.mergeConflictOrder"));
            }
            addedLastRound.clear();
            addedLastRound.addAll(addedThisRound);
            addedThisRound.clear();
        }
    }
    private static void makeBeforeOthersExplicit(Set<String> beforeOrdering,
            Map<String, WebXml> fragments) {
        for (String before : beforeOrdering) {
            if (!before.equals(ORDER_OTHERS)) {
                WebXml webXml = fragments.get(before);
                if (!webXml.getBeforeOrdering().contains(ORDER_OTHERS)) {
                    webXml.addBeforeOrderingOthers();
                    makeBeforeOthersExplicit(webXml.getAfterOrdering(), fragments);
                }
            }
        }
    }
    private static void makeAfterOthersExplicit(Set<String> afterOrdering,
            Map<String, WebXml> fragments) {
        for (String after : afterOrdering) {
            if (!after.equals(ORDER_OTHERS)) {
                WebXml webXml = fragments.get(after);
                if (!webXml.getAfterOrdering().contains(ORDER_OTHERS)) {
                    webXml.addAfterOrderingOthers();
                    makeAfterOthersExplicit(webXml.getBeforeOrdering(), fragments);
                }
            }
        }
    }
======= 07d343a:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

======= 07d343a:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

    private int posA;
    private int posB;
    private int posC;
    private int posD;
    private int posE;
    private int posF;
    public void setUp() {
======= 07d343a:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

        // Control the input order
        fragments = new LinkedHashMap<>();
======= 07d343a:"test/org/apache/catalina/deploy/TestWebXmlOrdering.java"

    private void doRelativeOrderingTest(RelativeOrderingTestRunner runner) {
        // Confirm we have all 720 possible input orders
        // Set<String> orders = new HashSet<>();
        // Test all possible input orders since some bugs were discovered that
        // depended on input order
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 5; j++) {
                for (int k = 0; k < 4; k++) {
                    for (int l = 0; l < 3; l++) {
                        for (int m = 0; m < 2; m++) {
                            setUp();
                            runner.init();
                            ArrayList<WebXml> source = new ArrayList<>();
                            source.addAll(fragments.values());
                            Map<String,WebXml> input =
                                    new LinkedHashMap<>();
                            WebXml one = source.remove(i);
                            input.put(one.getName(), one);
                            WebXml two = source.remove(j);
                            input.put(two.getName(), two);
                            WebXml three = source.remove(k);
                            input.put(three.getName(), three);
                            WebXml four = source.remove(l);
                            input.put(four.getName(), four);
                            WebXml five = source.remove(m);
                            input.put(five.getName(), five);
                            WebXml six = source.remove(0);
                            input.put(six.getName(), six);
                            /*
                            String order = one.getName() + two.getName() +
                                    three.getName() + four.getName() +
                                    five.getName() + six.getName();
                            orders.add(order);
                            */
                            Set<WebXml> ordered =
                                    WebXml.orderWebFragments(app, input);
                            populatePositions(ordered);
                            runner.validate(getOrder(ordered));
                        }
                    }
                }
            }
        }
        // System.out.println(orders.size());
    }
    private String getOrder(Set<WebXml> ordered) {
        StringBuilder sb = new StringBuilder(ordered.size());
        for (WebXml webXml : ordered) {
            sb.append(webXml.getName());
        }
        return sb.toString();
    }
    private void populatePositions(Set<WebXml> ordered) {
        List<WebXml> indexed = new ArrayList<>();
        indexed.addAll(ordered);
        posA = indexed.indexOf(a);
        posB = indexed.indexOf(b);
        posC = indexed.indexOf(c);
        posD = indexed.indexOf(d);
        posE = indexed.indexOf(e);
        posF = indexed.indexOf(f);
    }
        doRelativeOrderingTest(new RelativeTestRunner1());
        doRelativeOrderingTest(new RelativeTestRunner2());
    }
    @Test
    public void testOrderWebFragmentsRelative3() {
        // Third example from spec with e & f added
        doRelativeOrderingTest(new RelativeTestRunner3());
    }
    @Test
    public void testOrderWebFragmentsRelative4Bug54068() {
        // Simple sequence that failed for some inputs
        doRelativeOrderingTest(new RelativeTestRunner4());
    public void testOrderWebFragmentsRelative5Bug54068() {
        // Simple sequence that failed for some inputs
        doRelativeOrderingTest(new RelativeTestRunner5());
    }
    @Test
    public void testOrderWebFragmentsRelative6Bug54068() {
        // Simple sequence that failed for some inputs
        doRelativeOrderingTest(new RelativeTestRunner6());
    }
    @Test
    public void testOrderWebFragmentsRelative7() {
        // Reference loop (but not circular dependencies)
        doRelativeOrderingTest(new RelativeTestRunner7());
    }
    @Test
    public void testOrderWebFragmentsRelative8() {
        // More complex, trying to break the algorithm
        doRelativeOrderingTest(new RelativeTestRunner8());
    public void testOrderWebFragmentsRelative9() {
        // Variation on bug 54068
        doRelativeOrderingTest(new RelativeTestRunner9());
    }
    @Test
    public void testOrderWebFragmentsRelative10() {
        // Variation on bug 54068
        doRelativeOrderingTest(new RelativeTestRunner10());
    }
    @Test(expected=IllegalArgumentException.class)
    public void testOrderWebFragmentsrelativeCircular1() {
        WebXml.orderWebFragments(app, fragments);
    }
    @Test(expected=IllegalArgumentException.class)
    public void testOrderWebFragmentsrelativeCircular2() {
        a.addBeforeOrderingOthers();
        b.addAfterOrderingOthers();
        c.addBeforeOrdering("a");
        c.addAfterOrdering("b");
        WebXml.orderWebFragments(app, fragments);
    }
    private interface RelativeOrderingTestRunner {
        void init();
        void validate(String order);
    }
    private class RelativeTestRunner1 implements RelativeOrderingTestRunner {
        @Override
        public void init() {
            a.addAfterOrderingOthers();
            a.addAfterOrdering("c");
            b.addBeforeOrderingOthers();
            c.addAfterOrderingOthers();
            f.addBeforeOrderingOthers();
            f.addBeforeOrdering("b");
        }
        @Override
        public void validate(String order) {
            // There is some duplication in the tests below - it is easier to
            // check the tests are complete this way.
            //a.addAfterOrderingOthers();
            assertTrue(order, posA > posB);
            assertTrue(order, posA > posC);
            assertTrue(order, posA > posD);
            assertTrue(order, posA > posE);
            assertTrue(order, posA > posF);
            // a.addAfterOrdering("c");
            assertTrue(order, posA > posC);
            // b.addBeforeOrderingOthers();
            assertTrue(order, posB < posC);
            // c.addAfterOrderingOthers();
            assertTrue(order, posC > posB);
            assertTrue(order, posC > posD);
            assertTrue(order, posC > posE);
            assertTrue(order, posC > posF);
            // f.addBeforeOrderingOthers();
            assertTrue(order, posF < posA);
            assertTrue(order, posF < posB);
            assertTrue(order, posF < posC);
            assertTrue(order, posF < posD);
            assertTrue(order, posF < posE);
            // f.addBeforeOrdering("b");
            assertTrue(order, posF < posB);
        }
    }
    private class RelativeTestRunner2 implements RelativeOrderingTestRunner {
        @Override
        public void init() {
            a.addAfterOrderingOthers();
            a.addBeforeOrdering("c");
            b.addBeforeOrderingOthers();
            d.addAfterOrderingOthers();
            e.addBeforeOrderingOthers();
        }
        @Override
        public void validate(String order) {
            // There is some duplication in the tests below - it is easier to
            // check the tests are complete this way.
            // a.addAfterOrderingOthers();
            assertTrue(order, posA > posB);
            assertTrue(order, posA > posE);
            assertTrue(order, posA > posF);
            // a.addBeforeOrdering("c");
            assertTrue(order, posC > posA);
            assertTrue(order, posC > posB);
            assertTrue(order, posC > posE);
            assertTrue(order, posC > posF);
            // b.addBeforeOrderingOthers();
            assertTrue(order, posB < posA);
            assertTrue(order, posB < posC);
            assertTrue(order, posB < posD);
            assertTrue(order, posB < posF);
            // d.addAfterOrderingOthers();
            assertTrue(order, posD > posB);
            assertTrue(order, posD > posE);
            assertTrue(order, posD > posF);
            // e.addBeforeOrderingOthers();
            assertTrue(order, posE < posA);
            assertTrue(order, posE < posC);
            assertTrue(order, posE < posD);
            assertTrue(order, posE < posF);
        }
    }
    private class RelativeTestRunner3 implements RelativeOrderingTestRunner {
        @Override
        public void init() {
            a.addAfterOrdering("b");
            c.addBeforeOrderingOthers();
        }
        @Override
        public void validate(String order) {
            // There is some duplication in the tests below - it is easier to
            // check the tests are complete this way.
            // a.addAfterOrdering("b");
            assertTrue(order, posA > posB);
            // c.addBeforeOrderingOthers();
            assertTrue(order, posC < posA);
            assertTrue(order, posC < posB);
            assertTrue(order, posC < posD);
            assertTrue(order, posC < posE);
            assertTrue(order, posC < posF);
        }
    }
    private class RelativeTestRunner4 implements RelativeOrderingTestRunner {
        @Override
        public void init() {
            b.addAfterOrdering("a");
            c.addAfterOrdering("b");
        }
        @Override
        public void validate(String order) {
            // There is some duplication in the tests below - it is easier to
            // check the tests are complete this way.
            // b.addAfterOrdering("a");
            assertTrue(order, posB > posA);
            // c.addAfterOrdering("b");
            assertTrue(order, posC > posB);
        }
    }
    private class RelativeTestRunner5 implements RelativeOrderingTestRunner {
        @Override
        public void init() {
            b.addBeforeOrdering("a");
            c.addBeforeOrdering("b");
        }
        @Override
        public void validate(String order) {
            // There is some duplication in the tests below - it is easier to
            // check the tests are complete this way.
            // b.addBeforeOrdering("a");
            assertTrue(order, posB < posA);
            // c.addBeforeOrdering("b");
            assertTrue(order, posC < posB);
        }
    }
    private class RelativeTestRunner6 implements RelativeOrderingTestRunner {
        @Override
        public void init() {
            b.addBeforeOrdering("a");
            b.addAfterOrdering("c");
        }
        @Override
        public void validate(String order) {
            // There is some duplication in the tests below - it is easier to
            // check the tests are complete this way.
            // b.addBeforeOrdering("a");
            assertTrue(order, posB < posA);
            //b.addAfterOrdering("c");
            assertTrue(order, posB > posC);
        }
    }
    private class RelativeTestRunner7 implements RelativeOrderingTestRunner {
        @Override
        public void init() {
            b.addBeforeOrdering("a");
            c.addBeforeOrdering("b");
            a.addAfterOrdering("c");
        }
        @Override
        public void validate(String order) {
            // There is some duplication in the tests below - it is easier to
            // check the tests are complete this way.
            // b.addBeforeOrdering("a");
            assertTrue(order, posB < posA);
            // c.addBeforeOrdering("b");
            assertTrue(order, posC < posB);
            // a.addAfterOrdering("c");
            assertTrue(order, posA > posC);
        }
    }
    private class RelativeTestRunner8 implements RelativeOrderingTestRunner {
        @Override
        public void init() {
            a.addBeforeOrderingOthers();
            a.addBeforeOrdering("b");
            b.addBeforeOrderingOthers();
            c.addAfterOrdering("b");
            d.addAfterOrdering("c");
            e.addAfterOrderingOthers();
            f.addAfterOrderingOthers();
            f.addAfterOrdering("e");
        }
        @Override
        public void validate(String order) {
            // There is some duplication in the tests below - it is easier to
            // check the tests are complete this way.
            // a.addBeforeOrderingOthers();
            assertTrue(order, posA < posB);
            assertTrue(order, posA < posC);
            assertTrue(order, posA < posD);
            assertTrue(order, posA < posE);
            assertTrue(order, posA < posF);
            // a.addBeforeOrdering("b");
            assertTrue(order, posA < posB);
            // b.addBeforeOrderingOthers();
            assertTrue(order, posB < posC);
            assertTrue(order, posB < posD);
            assertTrue(order, posB < posE);
            assertTrue(order, posB < posF);
            // c.addAfterOrdering("b");
            assertTrue(order, posC > posB);
            // d.addAfterOrdering("c");
            assertTrue(order, posD > posC);
            // e.addAfterOrderingOthers();
            assertTrue(order, posE > posA);
            assertTrue(order, posE > posB);
            assertTrue(order, posE > posC);
            assertTrue(order, posE > posD);
            // f.addAfterOrderingOthers();
            assertTrue(order, posF > posA);
            assertTrue(order, posF > posB);
            assertTrue(order, posF > posC);
            assertTrue(order, posF > posD);
            assertTrue(order, posF > posE);
            // f.addAfterOrdering("e");
            assertTrue(order, posF > posE);
        }
    }
    private class RelativeTestRunner9 implements RelativeOrderingTestRunner {
        @Override
        public void init() {
            a.addBeforeOrderingOthers();
            b.addBeforeOrdering("a");
            c.addBeforeOrdering("b");
        }
        @Override
        public void validate(String order) {
            // There is some duplication in the tests below - it is easier to
            // check the tests are complete this way.
            // a.addBeforeOrderingOthers();
            assertTrue(order, posA < posD);
            assertTrue(order, posA < posE);
            assertTrue(order, posA < posF);
            // b.addBeforeOrdering("a");
            assertTrue(order, posB < posA);
            // c.addBeforeOrdering("b");
            assertTrue(order, posC < posB);
        }
    }
    private class RelativeTestRunner10 implements RelativeOrderingTestRunner {
        @Override
        public void init() {
            a.addAfterOrderingOthers();
            b.addAfterOrdering("a");
            c.addAfterOrdering("b");
        @Override
        public void validate(String order) {
            // There is some duplication in the tests below - it is easier to
            // check the tests are complete this way.
            // a.addAfterOrderingOthers();
            assertTrue(order, posA > posD);
            assertTrue(order, posA > posE);
            assertTrue(order, posA > posF);
            // b.addAfterOrdering("a");
            assertTrue(order, posB > posA);
            // c.addAfterOrdering("b");
            assertTrue(order, posC > posB);
        }

======= 9308b3f:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        if (statusCode < 200 || statusCode == 204 || statusCode == 205 ||
                statusCode == 304) {

======= c40ca99:"java/org/apache/jasper/runtime/PageContextImpl.java"

    protected static String XmlEscape(String s) {
        if (s == null) {
        }
        int len = s.length();
        /*
         * Look for any "bad" characters, Escape "bad" character was found
         */
        // ASCII " 34 & 38 ' 39 < 60 > 62
        for (int i = 0; i < len; i++) {
            if (c >= '\"' && c <= '>' &&
                    (c == '<' || c == '>' || c == '\'' || c == '&' || c == '"')) {
                // need to escape them and then quote the whole string
                StringBuilder sb = new StringBuilder((int) (len * 1.2));
                sb.append(s, 0, i);
                int pos = i + 1;
                for (int j = i; j < len; j++) {
                    c = s.charAt(j);
                    if (c >= '\"' && c <= '>') {
                        if (c == '<') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&lt;");
                            pos = j + 1;
                        } else if (c == '>') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&gt;");
                            pos = j + 1;
                        } else if (c == '\'') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&#039;"); // &apos;
                            pos = j + 1;
                        } else if (c == '&') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&amp;");
                            pos = j + 1;
                        } else if (c == '"') {
                            if (j > pos) {
                                sb.append(s, pos, j);
                            }
                            sb.append("&#034;"); // &quot;
                            pos = j + 1;
                        }
                    }
                }
                if (pos < len) {
                    sb.append(s, pos, len);
                }
                return sb.toString();
        return s;
======= c40ca99:"java/org/apache/jasper/runtime/PageContextImpl.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Performance tests for {@link PageContextImpl}.
 */
    private static String[] bug53867TestData = new String[] {
            "Hello World!",
            "<meta http-equiv=\"Content-Language\">",
            "This connection has limited network connectivity.",
            "Please use this web page & to access file server resources." };
    @Test
    public void testBug53867() {
        for (int i = 0; i < 10; i++) {
            doTestBug53867();
        }
    }
    private static void doTestBug53867() {
        int count = 100000;
        for (int j = 0; j < bug53867TestData.length; j++) {
            Assert.assertEquals(doTestBug53867OldVersion(bug53867TestData[j]),
                    PageContextImpl.XmlEscape(bug53867TestData[j]));
        }
        for (int i = 0; i < 100; i++) {
            for (int j = 0; j < bug53867TestData.length; j++) {
                doTestBug53867OldVersion(bug53867TestData[j]);
            }
        }
        for (int i = 0; i < 100; i++) {
            for (int j = 0; j < bug53867TestData.length; j++) {
                PageContextImpl.XmlEscape(bug53867TestData[j]);
            }
        }
        long start = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            for (int j = 0; j < bug53867TestData.length; j++) {
                doTestBug53867OldVersion(bug53867TestData[j]);
            }
        }
        System.out.println(
                "Old escape:" + (System.currentTimeMillis() - start));
        start = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            for (int j = 0; j < bug53867TestData.length; j++) {
                PageContextImpl.XmlEscape(bug53867TestData[j]);
            }
        }
        System.out.println(
                "New escape:" + (System.currentTimeMillis() - start));
    }
    private static String doTestBug53867OldVersion(String s) {
        if (s == null)
            return null;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '<') {
                sb.append("&lt;");
            } else if (c == '>') {
                sb.append("&gt;");
            } else if (c == '\'') {
                sb.append("&#039;"); // &apos;
            } else if (c == '&') {
                sb.append("&amp;");
            } else if (c == '"') {
                sb.append("&#034;"); // &quot;
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

======= 05fe671:"java/org/apache/catalina/servlets/CGIServlet.java"

    private final Hashtable<String,String> shellEnv = new Hashtable<>();

======= 874c332:"java/org/apache/coyote/AbstractProtocol.java"

                    if (status == SocketStatus.DISCONNECT &&
                            !processor.isComet()) {
                        // Do nothing here, just wait for it to get recycled
                        // Don't do this for Comet we need to generate an end
                        // event (see BZ 54022)
                    } else if (processor.isAsync() ||
                            state == SocketState.ASYNC_END) {

======= 095a403:"java/org/apache/jasper/compiler/Generator.java"

                return quoted;

======= a0ff3f9:"java/org/apache/jasper/compiler/Compiler.java"

                errDispatcher), ctxt.getJspFile(), ctxt.isTagFile());
======= a0ff3f9:"java/org/apache/jasper/compiler/PageInfo.java"

    private boolean isTagFile = false;
    PageInfo(BeanRepository beanRepository, String jspFile, boolean isTagFile) {
        this.isTagFile = isTagFile;
======= a0ff3f9:"java/org/apache/jasper/compiler/PageInfo.java"

    public boolean isTagFile() {
        return isTagFile;
    }
======= a0ff3f9:"java/org/apache/jasper/compiler/TagPluginManager.java"

        @Override
        public boolean isTagFile() {
            return pageInfo.isTagFile();
        }
======= a0ff3f9:"java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java"

    /**
     * Is the tag being used inside a tag file?
     */
    boolean isTagFile();
======= a0ff3f9:"java/org/apache/jasper/tagplugins/jstl/core/Set.java"

            String jspCtxt = null;
            if (ctxt.isTagFile()) {
                jspCtxt = "this.getJspContext()";
            } else {
                jspCtxt = "_jspx_page_context";
            }
            ctxt.generateJavaSource("    " + jspCtxt + ".setAttribute(\"" + strVar + "\"," + resultName + "," + iScope + ");");
                ctxt.generateJavaSource("    " + jspCtxt + ".removeAttribute(\"" + strVar + "\"," + iScope + ");");
                ctxt.generateJavaSource("    " + jspCtxt + ".removeAttribute(\"" + strVar + "\");");

======= d2b41b5:"java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java"

======= d2b41b5:"java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java"

                if (member instanceof StaticMember) {
                    addSuspects.put(member, Long.valueOf(System.currentTimeMillis()));
                }
======= d2b41b5:"java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java"

                    if (members[i] instanceof StaticMember) {
                        addSuspects.put(members[i], Long.valueOf(System.currentTimeMillis()));
                    }
======= d2b41b5:"java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java"

            if (addSuspects.containsKey(members[i]) && membership.getMember(members[i]) == null) {
                // avoid temporary adding member.
                continue;
            }

======= 9f04094:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

      <fix>
        <bug>54010</bug>: Remove some unnecessary code (duplicate calls to
        configure the scheme as https for AJP requests originally received over
        HTTPS). (markt)
      </fix>

======= 39c4270:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 39c4270:"java/org/apache/catalina/valves/AccessLogValve.java"

            if (request == null) {
                buf.append('-');
            } else {
                Session session = request.getSessionInternal(false);
                if (session == null) {
                } else {
                    buf.append(session.getIdInternal());

======= 88d8dd5:"java/org/apache/jasper/compiler/JspReader.java"

                       current.init(restart, singleFile);
======= 88d8dd5:"java/org/apache/jasper/compiler/JspReader.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testBug53986() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir =
            new File("test/webapp-3.0");
        tomcat.addWebapp(null, "", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = getUrl("http://localhost:" + getPort() +
                "/bug53986.jsp");
        Assert.assertTrue(res.toString().contains("OK"));
    }
======= 88d8dd5:"java/org/apache/jasper/compiler/JspReader.java"

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <body>
    <p>OK</p>
  </body>

======= a3e0f09:"java/org/apache/naming/resources/BaseDirContext.java"

======= a3e0f09:"java/org/apache/naming/resources/BaseDirContext.java"

    public final NamingEnumeration<NameClassPair> list(Name name)
======= a3e0f09:"java/org/apache/naming/resources/BaseDirContext.java"

    public final NamingEnumeration<NameClassPair> list(String name)
        throws NamingException {
        if (!aliases.isEmpty()) {
            AliasResult result = findAlias(name);
            if (result.dirContext != null) {
                return result.dirContext.list(result.aliasName);
            }
        }
        // Next do a standard lookup
        List<NamingEntry> bindings = doListBindings(name);
        // Check the alternate locations
        List<NamingEntry> altBindings = null;
        for (DirContext altDirContext : altDirContexts) {
            if (altDirContext instanceof BaseDirContext) {
                altBindings = ((BaseDirContext) altDirContext).doListBindings(
                        "/META-INF/resources" + name);
            }
            if (altBindings != null) {
                if (bindings == null) {
                    bindings = altBindings;
                } else {
                    bindings.addAll(altBindings);
                }
            }
        }
        if (bindings != null) {
            return new NamingContextEnumeration(bindings.iterator());
        }
        // Really not found
        throw new NameNotFoundException(
                sm.getString("resources.notFound", name));
    }
======= a3e0f09:"java/org/apache/naming/resources/FileDirContext.java"

======= a3e0f09:"java/org/apache/naming/resources/FileDirContext.java"

======= a3e0f09:"java/org/apache/naming/resources/FileDirContext.java"

======= a3e0f09:"java/org/apache/naming/resources/WARDirContext.java"

======= a3e0f09:"java/org/apache/naming/resources/WARDirContext.java"

======= a3e0f09:"java/org/apache/naming/resources/WARDirContext.java"


======= 7f6f99e:"java/org/apache/catalina/startup/Tomcat.java"

        servlet.setOverridable(true);
        servlet.setOverridable(true);

======= 97cefcc:"java/org/apache/catalina/Host.java"

    /**
     * Returns true of the Host is configured to automatically undeploy old
     * versions of applications deployed using parallel deployment. This only
     * takes effect is {@link #getAutoDeploy()} also returns true.
     */
    public boolean getUndeployOldVersions();
    /**
     * Set to true if the Host should automatically undeploy old versions of
     * applications deployed using parallel deployment. This only takes effect
     * if {@link #getAutoDeploy()} returns true.
     */
    public void setUndeployOldVersions(boolean undeployOldVersions);
======= 97cefcc:"java/org/apache/catalina/core/StandardHost.java"

    private boolean undeployOldVersions = false;
    public boolean getUndeployOldVersions() {
        return undeployOldVersions;
    }
    @Override
    public void setUndeployOldVersions(boolean undeployOldVersions) {
        this.undeployOldVersions = undeployOldVersions;
    }
    @Override
    <attribute name="undeployOldVersions"
               description="Determines if old versions of applications deployed using parallel deployment are automatically undeployed when no longer used. Requires autoDeploy to be enabled."
               type="boolean"/>
======= 97cefcc:"java/org/apache/catalina/startup/HostConfig.java"

======= 97cefcc:"java/org/apache/catalina/startup/HostConfig.java"

======= 97cefcc:"java/org/apache/catalina/startup/HostConfig.java"

                    deleteRedeployResources(app, resources, i, false);
======= 97cefcc:"java/org/apache/catalina/startup/HostConfig.java"

                deleteRedeployResources(app, resources, i, true);
======= 97cefcc:"java/org/apache/catalina/startup/HostConfig.java"

    private void deleteRedeployResources(DeployedApplication app,
            String[] resources, int i, boolean deleteReloadResources) {
        // Delete redeploy resources
        if (log.isInfoEnabled())
            log.info(sm.getString("hostConfig.undeploy", app.name));
        Container context = host.findChild(app.name);
        try {
            host.removeChild(context);
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            log.warn(sm.getString
                     ("hostConfig.context.remove", app.name), t);
        }
        // Delete other redeploy resources
        for (int j = i + 1; j < resources.length; j++) {
            try {
                File current = new File(resources[j]);
                current = current.getCanonicalFile();
                // Never delete per host context.xml defaults
                if (Constants.HostContextXml.equals(
                        current.getName())) {
                    continue;
                }
                // Only delete resources in the appBase or the
                // host's configBase
                if ((current.getAbsolutePath().startsWith(
                        host.getAppBaseFile().getAbsolutePath() +
                        File.separator))
                        || (current.getAbsolutePath().startsWith(
                                host.getConfigBaseFile().getAbsolutePath()))) {
                    if (log.isDebugEnabled())
                        log.debug("Delete " + current);
                    ExpandWar.delete(current);
                }
            } catch (IOException e) {
                log.warn(sm.getString
                        ("hostConfig.canonicalizing", app.name), e);
            }
        }
        // Delete reload resources (to remove any remaining .xml descriptor)
        if (deleteReloadResources) {
            String[] resources2 =
                    app.reloadResources.keySet().toArray(new String[0]);
            for (int j = 0; j < resources2.length; j++) {
                try {
                    File current = new File(resources2[j]);
                    current = current.getCanonicalFile();
                    // Never delete per host context.xml defaults
                    if (Constants.HostContextXml.equals(
                            current.getName())) {
                        continue;
                    }
                    // Only delete resources in the appBase or the host's
                    // configBase
                    if ((current.getAbsolutePath().startsWith(
                            host.getAppBaseFile().getAbsolutePath() + File.separator))
                        || ((current.getAbsolutePath().startsWith(
                                host.getConfigBaseFile().getAbsolutePath())
                             && (current.getAbsolutePath().endsWith(".xml"))))) {
                        if (log.isDebugEnabled())
                            log.debug("Delete " + current);
                        ExpandWar.delete(current);
                    }
                } catch (IOException e) {
                    log.warn(sm.getString
                            ("hostConfig.canonicalizing", app.name), e);
                }
            }
        }
        deployed.remove(app.name);
    }
======= 97cefcc:"java/org/apache/catalina/startup/HostConfig.java"

            // Check for old versions of applications that can now be undeployed
            if (host.getUndeployOldVersions()) {
                checkUndeploy();
            }
======= 97cefcc:"java/org/apache/catalina/startup/HostConfig.java"

     * Check for old versions of applications using parallel deployment that are
     * now unused (have no active sessions) and undeploy any that are found.
     */
    public void checkUndeploy() {
        // Need ordered set of names
        SortedSet<String> sortedAppNames = new TreeSet<>();
        sortedAppNames.addAll(deployed.keySet());
        if (sortedAppNames.size() < 2) {
            return;
        }
        Iterator<String> iter = sortedAppNames.iterator();
        ContextName previous = new ContextName(iter.next());
        do {
            ContextName current = new ContextName(iter.next());
            if (current.getPath().equals(previous.getPath())) {
                // Current and previous are same version - current will always
                // be a later version
                Context context = (Context) host.findChild(previous.getName());
                if (context != null) {
                    Manager manager = context.getManager();
                    if (manager != null && manager.getActiveSessions() == 0) {
                        if (log.isInfoEnabled()) {
                            log.info(sm.getString("hostConfig.undeployVersion",
                                    previous.getName()));
                        }
                        DeployedApplication app =
                                deployed.get(previous.getName());
                        String[] resources =
                                app.redeployResources.keySet().toArray(
                                        new String[0]);
                        // Version is unused - undeploy it completely
                        // The -1 is a 'trick' to ensure all redeploy resources
                        // are removed
                        deleteRedeployResources(app, resources, -1,
                                true);
                    }
                }
            }
            previous = current;
        } while (iter.hasNext());
    }
    /**
    <operation name="checkUndeploy"
               description="Undeploy any old versions of applications deployed using parallel deployment that have no active sessions"
               impact="ACTION"
               returnType="void">
    </operation>
  <p>The <a href="host.html">Host</a> may be configured (via the
  <code>undeployOldVersions</code>) to remove old versions deployed in this way
  once they are no longer in use.</p>
      <attribute name="undeployOldVersions" required="false">
        <p>This flag determines if Tomcat, as part of the auto deployment
        process, will check for old, unused versions of web applications
        deployed using parallel deployment and, if any are found, remove them.
        This flag only applies if <code>autoDeploy</code> is true. If not
        specified the default value of false will be used.</p>
      </attribute>

======= 5fccf68:"java/org/apache/jasper/compiler/JspReader.java"

     * A faster approach than calling {@link #mark()} & {@link #nextChar()}.
     * However, this approach is only safe if the mark is only used within the
     * JspReader.
     */
    private int nextChar(Mark mark) throws JasperException {
        if (!hasMoreInput()) {
            return -1;
        }
        int ch = current.stream[current.cursor];
        mark.init(current, singleFile);
        current.cursor++;
        if (ch == '\n') {
            current.line++;
            current.col = 0;
        } else {
            current.col++;
        }
        return ch;
    }
    /**
     * Search the given character, If it was found, then mark the current cursor
     * and the cursor point to next character.
     */
    private Boolean indexOf(char c, Mark mark) throws JasperException {
        if (!hasMoreInput())
            return null;
        int end = current.stream.length;
        int ch;
        int line = current.line;
        int col = current.col;
        int i = current.cursor;
        for(; i < end; i ++) {
           ch = current.stream[i];
           if (ch == c) {
               mark.update(i, line, col);
           }
           if (ch == '\n') {
                line++;
                col = 0;
            } else {
                col++;
            }
           if (ch == c) {
               current.update(i+1, line, col);
               return Boolean.TRUE;
           }
        }
        current.update(i, line, col);
        return Boolean.FALSE;
    }
    /**
======= 5fccf68:"java/org/apache/jasper/compiler/JspReader.java"

        while (!markEquals(stop)) {
        }
        setCurrent(oldstart);
======= 5fccf68:"java/org/apache/jasper/compiler/JspReader.java"

    /**
     * This method avoids a call to {@link #mark()} when doing comparison.
     */
    private boolean markEquals(Mark another) {
       return another.equals(current);
    }
     * Similar to {@link #reset(Mark)} but no new Mark will be created.
     * Therefore, the parameter mark must NOT be used in other places.
     */
    private void setCurrent(Mark mark) {
       current = mark;
    }
    /**
======= 5fccf68:"java/org/apache/jasper/compiler/JspReader.java"

       int len = string.length();
       int cursor = current.cursor;
       int streamSize = current.stream.length;
       if (cursor + len < streamSize) { //Try to scan in memory
           int line = current.line;
           int col = current.col;
           int ch;
           int i = 0;
           for(; i < len; i ++) {
               ch = current.stream[i+cursor];
               if (string.charAt(i) != ch) {
                   return false;
               }
               if (ch == '\n') {
                  line ++;
                  col = 0;
               } else {
                  col++;
               }
           }
           current.update(i+cursor, line, col);
       } else {
           Mark mark = mark();
           int ch = 0;
           int i = 0;
           do {
               ch = nextChar();
               if (((char) ch) != string.charAt(i++)) {
                   setCurrent(mark);
                   return false;
               }
           } while (i < len);
       }
       return true;
======= 5fccf68:"java/org/apache/jasper/compiler/JspReader.java"

        setCurrent(mark);
======= 5fccf68:"java/org/apache/jasper/compiler/JspReader.java"

       setCurrent(mark);
======= 5fccf68:"java/org/apache/jasper/compiler/JspReader.java"

            setCurrent(mark);
======= 5fccf68:"java/org/apache/jasper/compiler/JspReader.java"

        Mark ret = mark();
        char firstChar = limit.charAt(0);
        Boolean result = null;
        Mark restart = null;
        while((result = indexOf(firstChar, ret)) != null) {
           if (result.booleanValue()) {
               if (restart != null) {
                   restart.init(current, singleFile);
               } else {
                   restart = mark();
               }
               for (int i = 1 ; i < limlen ; i++) {
                   if (peekChar() == limit.charAt(i)) {
                       nextChar();
                   } else {
                       setCurrent(restart);
                       continue skip;
                   }
               }
               return ret;
======= 5fccf68:"java/org/apache/jasper/compiler/JspReader.java"

        Mark ret = mark();
        char firstChar = limit.charAt(0);
        for (ch = nextChar(ret) ; ch != -1 ; prev = ch, ch = nextChar(ret)) {
            } else if (ch == firstChar && prev != '\\') {
======= 5fccf68:"java/org/apache/jasper/compiler/JspReader.java"

                    setCurrent(mark);
                    setCurrent(mark);
======= 5fccf68:"java/org/apache/jasper/compiler/Mark.java"

       init(other, false);
    }
    void update(int cursor, int line, int col) {
        this.cursor = cursor;
        this.line = line;
        this.col = col;
    }
    void init(Mark other, boolean singleFile) {
        if (!singleFile) {
            this.reader = other.reader;
            this.ctxt = other.ctxt;
            this.stream = other.stream;
            this.fileId = other.fileId;
            this.fileName = other.fileName;
            this.baseDir = other.baseDir;
            this.encoding = other.encoding;
            if (includeStack == null) {
                includeStack = new Stack<>();
            } else {
                includeStack.clear();
            }
            for (int i = 0; i < other.includeStack.size(); i++ ) {
                includeStack.addElement(other.includeStack.elementAt(i));
            }

======= a81d941:"java/org/apache/catalina/websocket/StreamInbound.java"

            doOnClose(Constants.STATUS_CLOSE_NORMAL);

======= 95d7a0f:"java/org/apache/catalina/realm/RealmBase.java"

                        found = false;
                        found = true;
======= 95d7a0f:"java/org/apache/catalina/realm/RealmBase.java"

        if(results == null || results.size() == 0) {

======= 44eabba:"java/org/apache/naming/resources/FileDirContext.java"

                tempContext.setDocBase(currentFile.getPath());

======= fcc3d65:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args[0] = "<a href=\"" + URL_ENCODER.encode(contextPath + "/")

======= cd05aa1:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

                int charValue = HexUtils.getDec(buf[pos]);
                if (charValue != -1) {
                    result += charValue;
======= cd05aa1:"java/org/apache/tomcat/util/buf/HexUtils.java"

        -1, 10, 11, 12, 13, 14, 15,
======= cd05aa1:"java/org/apache/tomcat/util/buf/HexUtils.java"

        // Fast for correct values, slower for incorrect ones
        try {
            return DEC[index - '0'];
        } catch (ArrayIndexOutOfBoundsException ex) {
            return -1;
        }
======= cd05aa1:"java/org/apache/tomcat/util/buf/HexUtils.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Test cases for {@link HexUtils}.
 */
    @Test
    public void testGetDec() {
        assertEquals(0, HexUtils.getDec('0'));
        assertEquals(9, HexUtils.getDec('9'));
        assertEquals(10, HexUtils.getDec('a'));
        assertEquals(15, HexUtils.getDec('f'));
        assertEquals(10, HexUtils.getDec('A'));
        assertEquals(15, HexUtils.getDec('F'));
        assertEquals(-1, HexUtils.getDec(0));
        assertEquals(-1, HexUtils.getDec('Z'));
        assertEquals(-1, HexUtils.getDec(255));
        assertEquals(-1, HexUtils.getDec(-60));
    }

======= 6b934d8:"java/org/apache/catalina/startup/ContextConfig.java"

                    jar.nextEntry();
                    String entryName = jar.getEntryName();
                    while (entryName != null) {
                        if (entryName.startsWith("META-INF/resources/")) {
                            context.addResourceJarUrl(url);
                            break;
                        }
                        jar.nextEntry();
                        entryName = jar.getEntryName();

======= 8f169e4:"java/org/apache/catalina/core/ApplicationFilterRegistration.java"

            } else {
                context.addFilterMapBefore(filterMap);
======= 8f169e4:"java/org/apache/catalina/core/ApplicationFilterRegistration.java"

            } else {
                context.addFilterMapBefore(filterMap);

======= 3dff241:"java/org/apache/coyote/http11/filters/FlushableGZIPOutputStream.java"

        } while (!def.needsInput());

======= 15e8d8e:"java/org/apache/catalina/startup/Constants.java"

    public static final String DEFAULT_JARS_TO_SKIP =
            "tomcat.util.scan.DefaultJarScanner.jarsToSkip";
    public static final String PLUGGABILITY_JARS_TO_SKIP =
            "org.apache.catalina.startup.ContextConfig.jarsToSkip";
    public static final String TLD_JARS_TO_SKIP =
            "org.apache.catalina.startup.TldConfig.jarsToSkip";
======= 15e8d8e:"java/org/apache/catalina/startup/ContextConfig.java"

======= 15e8d8e:"java/org/apache/catalina/startup/ContextConfig.java"

    /**
     * The list of JARs that will be skipped when scanning a web application
     * for JARs. This means the JAR will not be scanned for web fragments, SCIs,
     * annotations or classes that match @HandlesTypes.
     */
    private static final Set<String> pluggabilityJarsToSkip = new HashSet<>();
======= 15e8d8e:"java/org/apache/catalina/startup/ContextConfig.java"

        // Load the list of JARS to skip
        addJarsToSkip(Constants.DEFAULT_JARS_TO_SKIP);
        addJarsToSkip(Constants.PLUGGABILITY_JARS_TO_SKIP);
    private static void addJarsToSkip(String systemPropertyName) {
        String jarList = System.getProperty(systemPropertyName);
        if (jarList != null) {
            StringTokenizer tokenizer = new StringTokenizer(jarList, ",");
            while (tokenizer.hasMoreElements()) {
                pluggabilityJarsToSkip.add(tokenizer.nextToken());
            }
        }
    }
======= 15e8d8e:"java/org/apache/catalina/startup/ContextConfig.java"

                context.getLoader().getClassLoader(), callback,
                pluggabilityJarsToSkip);
======= 15e8d8e:"java/org/apache/catalina/startup/TldConfig.java"

    static {
        // Set the default list of JARs to skip for TLDs
        StringBuilder jarList = new StringBuilder(System.getProperty(
                Constants.DEFAULT_JARS_TO_SKIP, ""));
        String tldJars = System.getProperty(Constants.TLD_JARS_TO_SKIP, "");
        if (tldJars.length() > 0) {
            if (jarList.length() > 0) {
                jarList.append(',');
            }
            jarList.append(tldJars);
        }
        if (jarList.length() > 0) {
            setNoTldJars(jarList.toString());
        }
    }
    /**
     * Sets the list of JARs that are known not to contain any TLDs.
     *
     * @param jarNames List of comma-separated names of JAR files that are
     * known not to contain any TLDs.
     */
    public static synchronized void setNoTldJars(String jarNames) {
        if (jarNames == null) {
            noTldJars = null;
        } else {
            if (noTldJars == null) {
                noTldJars = new HashSet<>();
            } else {
                noTldJars.clear();
            }
            StringTokenizer tokenizer = new StringTokenizer(jarNames, ",");
            while (tokenizer.hasMoreElements()) {
                noTldJars.add(tokenizer.nextToken());
            }
        }
    }
======= 15e8d8e:"java/org/apache/catalina/startup/TldConfig.java"

======= 15e8d8e:"java/org/apache/jasper/Constants.java"

     * Name of system property containing default list of JARs to skip when
     * scanning JARs for configuration elements such as TLDs.
     */
    public static final String DEFAULT_JAR_SKIP_PROP=
            "tomcat.util.scan.DefaultJarScanner.jarsToSkip";
    /**
     * Name of system property containing additional list of JARs to skip when
     * scanning for TLDs.
     */
    public static final String TLD_JAR_SKIP_PROP=
            "org.apache.catalina.startup.TldConfig.jarsToSkip";
    /**
======= 15e8d8e:"java/org/apache/jasper/compiler/TldLocationsCache.java"

======= 15e8d8e:"java/org/apache/jasper/compiler/TldLocationsCache.java"

    static {
        // Set the default list of JARs to skip for TLDs
        // Set the default list of JARs to skip for TLDs
        StringBuilder jarList = new StringBuilder(System.getProperty(
                Constants.DEFAULT_JAR_SKIP_PROP, ""));
        String tldJars = System.getProperty(Constants.TLD_JAR_SKIP_PROP, "");
        if (tldJars.length() > 0) {
            if (jarList.length() > 0) {
                jarList.append(',');
            }
            jarList.append(tldJars);
        }
        if (jarList.length() > 0) {
            setNoTldJars(jarList.toString());
        }
======= 15e8d8e:"java/org/apache/jasper/compiler/TldLocationsCache.java"

    public static synchronized void setNoTldJars(String jarNames) {
                noTldJars = new HashSet<>();
======= 15e8d8e:"java/org/apache/jasper/compiler/TldLocationsCache.java"

     * The mapping of the 'global' tag library URI to the location (resource
     * path) of the TLD associated with that tag library. The location is
     * returned as a String array:
     *    [0] The location
     *    [1] If the location is a jar file, this is the location of the tld.
     */
    private Hashtable<String, TldLocation> mappings;
    private volatile boolean initialized;
    private ServletContext ctxt;
    /** Constructor.
     *
     * @param ctxt the servlet context of the web application in which Jasper
     * is running
     */
    public TldLocationsCache(ServletContext ctxt) {
        this.ctxt = ctxt;
        mappings = new Hashtable<String, TldLocation>();
        initialized = false;
    }
    /**
    <property name="tomcat.util.scan. DefaultJarScanner.jarsToSkip">
      <p>The comma-separated list of filenames of JARs that Tomcat will not scan
         for configuration information when using the
         <a href="jar-scanner.html">JarScanner</a> functionality. Note that
         there are additional system properties that enable JARs to be excluded
         from specific scans rather than all scans.</p>
      <p>The coded default is that no JARs are skipped however the system
         property is set in a default Tomcat installation via the
         <code>$CATALINA_BASE/catalina.properties</code> file.</p>
    </property>
    <property name="org.apache.catalina.startup. ContextConfig.jarsToSkip">
      <p>The comma-separated list of additional filenames of JARs that Tomcat
         will not scan for Servlet 3.0 pluggability features.</p>
      <p>The coded default is that no JARs are skipped however the system
         property is set in a default Tomcat installation via the
         <code>$CATALINA_BASE/catalina.properties</code> file.</p>
    </property>
    <property name="org.apache.catalina.startup. TldConfig.jarsToSkip">
      <p>The comma-separated list of additional filenames of JARs that Tomcat
         will not scan for TLDs.</p>
      <p>The coded default is that no JARs are skipped however the system
         property is set in a default Tomcat installation via the
         <code>$CATALINA_BASE/catalina.properties</code> file.</p>
    </property>

======= 6c13431:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        comet = false;
======= 6c13431:"java/org/apache/coyote/http11/Http11NioProcessor.java"


======= e38a097:"java/org/apache/catalina/core/ApplicationJspPropertyGroupDescriptor.java"

======= e38a097:"java/org/apache/catalina/core/ApplicationJspPropertyGroupDescriptor.java"

        return jspPropertyGroup.getUrlPatterns();
======= e38a097:"java/org/apache/catalina/deploy/JspPropertyGroup.java"

======= e38a097:"java/org/apache/catalina/deploy/JspPropertyGroup.java"

    private Set<String> urlPattern = new HashSet<>();
    public void addUrlPattern(String urlPattern) {
        this.urlPattern.add(urlPattern);
    public Set<String> getUrlPatterns() { return this.urlPattern; }
======= e38a097:"java/org/apache/catalina/deploy/WebXml.java"

                for (String urlPattern : jpg.getUrlPatterns()) {
                    appendElement(sb, INDENT6, "url-pattern", urlPattern);
                }
======= e38a097:"java/org/apache/catalina/deploy/WebXml.java"

                for (String urlPattern : jspPropertyGroup.getUrlPatterns()) {
                    context.addServletMapping(urlPattern, jspServletName, true);
                }
                if(log.isDebugEnabled()) {
                    for (String urlPattern : jspPropertyGroup.getUrlPatterns()) {
                        log.debug("Skiping " + urlPattern + " , no servlet " +
                                jspServletName);
                    }
                }
======= e38a097:"java/org/apache/catalina/startup/WebRuleSet.java"

                               "addUrlPattern", 0);

======= 1efc23d:"java/org/apache/jasper/compiler/Compiler.java"

                if (key.startsWith("jar:") || key.startsWith("file:")) {

======= e37b01e:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        State state = new State(request, response, false);
======= e37b01e:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        wrequest.setContextPath(context.getPath());

======= 2a3b42d:"java/javax/servlet/ServletInputStream.java"

======= 2a3b42d:"java/javax/servlet/ServletOutputStream.java"

======= 2a3b42d:"java/javax/servlet/jsp/JspException.java"

     * @see java.lang.Exception#Exception(String, Throwable)
======= 2a3b42d:"java/javax/servlet/jsp/JspException.java"

     * @see java.lang.Exception#Exception(Throwable)
======= 2a3b42d:"java/org/apache/catalina/Executor.java"

     * @throws java.util.concurrent.RejectedExecutionException if this task
======= 2a3b42d:"java/org/apache/catalina/Manager.java"

     * @deprecated Use {@link #setContext(Context)}. This method will be removed in
======= 2a3b42d:"java/org/apache/catalina/Manager.java"

     * @param context The newly associated Context
======= 2a3b42d:"java/org/apache/catalina/tribes/ErrorHandler.java"

     * @see Channel#send(Member[], java.io.Serializable, int, ErrorHandler)
     * @see Channel#send(Member[], java.io.Serializable, int, ErrorHandler)
======= 2a3b42d:"java/org/apache/naming/SelectorContext.java"

     * @exception javax.naming.directory.InvalidAttributesException if object did not
======= 2a3b42d:"java/org/apache/naming/SelectorContext.java"

     * @exception javax.naming.directory.InvalidAttributesException if object did not
======= 2a3b42d:"java/org/apache/naming/SelectorContext.java"

     * @exception javax.naming.directory.InvalidAttributesException if object did not
======= 2a3b42d:"java/org/apache/naming/SelectorContext.java"

     * @exception javax.naming.directory.InvalidAttributesException if object did not
======= 2a3b42d:"java/org/apache/naming/SelectorContext.java"

     * @exception javax.naming.directory.InvalidAttributesException if creation of the
======= 2a3b42d:"java/org/apache/naming/SelectorContext.java"

     * @exception javax.naming.directory.InvalidAttributesException if creation of the
======= 2a3b42d:"java/org/apache/tomcat/util/http/fileupload/FileItem.java"

 * #parseRequest(RequestContext)}), you may
======= 2a3b42d:"webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java"

     * @param responseWrapper The associated response wrapper
     * @param originalOutput the output stream

======= a2ca744:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

======= a2ca744:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"


======= f9b0182:"java/org/apache/catalina/startup/ContextConfig.java"

            convertJsps(webXml);
======= f9b0182:"test/org/apache/catalina/startup/TestContextConfig.java"

======= f9b0182:"test/org/apache/catalina/startup/TestContextConfig.java"

    @Test
    public void testBug53574() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug53574", res, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        String body = res.toString();
        Assert.assertTrue(body.contains("OK"));
    }
======= f9b0182:"test/org/apache/catalina/startup/TestContextConfig.java"

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <body>
    <p>OK</p>
  </body>
  <servlet>
    <servlet-name>Bug53574</servlet-name>
    <jsp-file>/WEB-INF/jsp/bug53574.jsp</jsp-file>
  </servlet>
  <servlet-mapping>
    <servlet-name>Bug53574</servlet-name>
    <url-pattern>/bug53574</url-pattern>
  </servlet-mapping>

======= 5a6b27b:"java/org/apache/jasper/runtime/PageContextImpl.java"

            baseOut.clear();
======= 5a6b27b:"java/org/apache/jasper/runtime/PageContextImpl.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testDoForward() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug53545.jsp", res, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        String body = res.toString();
        Assert.assertTrue(body.contains("OK"));
        Assert.assertFalse(body.contains("FAIL"));
    }
======= 5a6b27b:"java/org/apache/jasper/runtime/PageContextImpl.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    private static final long serialVersionUID = 1L;
======= 5a6b27b:"java/org/apache/jasper/runtime/PageContextImpl.java"

    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"
    version="2.0">
    <tlib-version>1.0</tlib-version>
    <short-name>bug53545</short-name>
    <tag>
      <name>test</name>
      <tag-class>org.apache.tomcat.unittest.tags.Bug53545</tag-class>
      <body-content>scriptless</body-content>
    </tag>
======= 5a6b27b:"java/org/apache/jasper/runtime/PageContextImpl.java"

  <body>
    <p>OK</p>
  </body>
======= 5a6b27b:"java/org/apache/jasper/runtime/PageContextImpl.java"

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
         pageEncoding="ISO-8859-1"%>
  <body>
    <p>FAIL</p>
    <bug53545:test>
      <p>FAIL</p>
      <bug53545:test>
        <p>FAIL</p>
        <jsp:forward page="bug53545.html"/>
        <p>FAIL</p>
      </bug53545:test>
      <p>FAIL</p>
    </bug53545:test>
    <p>FAIL</p>
  </body>

======= 432bd0f:"java/org/apache/naming/resources/VirtualDirContext.java"

    @Override
    protected String doGetRealPath(String path) {
        File file = file(path);
        if (null != file) {
            return file.getAbsolutePath();
        } else {
            return null;
        }
    }

======= 82e5dce:"java/org/apache/coyote/http11/Http11AprProtocol.java"

     * SSL honor cipher order.
     * Set to <code>true</code> to enforce the <i>server's</i> cipher order
     * instead of the default which is to allow the client to choose a
     * preferred cipher.
     */
    public boolean getSSLHonorCipherOrder() { return ((AprEndpoint)endpoint).getSSLHonorCipherOrder(); }
    public void setSSLHonorCipherOrder(boolean SSLHonorCipherOrder) { ((AprEndpoint)endpoint).setSSLHonorCipherOrder(SSLHonorCipherOrder); }
    /**
======= 82e5dce:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    protected boolean SSLHonorCipherOrder = false;
    /**
     * Set to <code>true</code> to enforce the <i>server's</i> cipher order
     * instead of the default which is to allow the client to choose a
     * preferred cipher.
     */
    public void setSSLHonorCipherOrder(boolean SSLHonorCipherOrder) { this.SSLHonorCipherOrder = SSLHonorCipherOrder; }
    public boolean getSSLHonorCipherOrder() { return SSLHonorCipherOrder; }
======= 82e5dce:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            // Set cipher order: client (default) or server
            if (SSLHonorCipherOrder) {
                boolean orderCiphersSupported = false;
                try {
                    orderCiphersSupported = SSL.hasOp(SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
                    if (orderCiphersSupported)
                        SSLContext.setOptions(sslContext, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
                } catch (UnsatisfiedLinkError e) {
                    // Ignore
                }
                if (!orderCiphersSupported) {
                    // OpenSSL does not support ciphers ordering.
                    log.warn(sm.getString("endpoint.warn.noHonorCipherOrder",
                                          SSL.versionString()));
                }
            }
    <attribute name="SSLHonorCipherOrder" required="false">
      <p>Set to <code>true</code> to enforce the server's cipher order
      (from the <code>SSLCipherSuite</code> setting) instead of allowing
      the client to choose the cipher (which is the default).</p>
    </attribute>

======= af45441:"java/org/apache/catalina/websocket/WebSocketServlet.java"

                "Sec-WebSocket-Protocol");

======= 57b56f2:"java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java"

======= 57b56f2:"java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java"

        data.setMessage(new XByteBuffer(TCP_PING_DATA, false));

======= eb9f94e:"java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java"

        TcpFailureDetector tcpFailureDetector =
                failureDetector != null ? failureDetector.get() : null;
        if (tcpFailureDetector != null) {
            tcpFailureDetector.checkMembers(true);
            StaticMembershipInterceptor smi =
                    staticOnly && staticMembers != null ? staticMembers.get() : null;
            if (smi != null) {

======= 7db08d3:"java/org/apache/catalina/startup/ContextConfig.java"

        String superClassName = cacheEntry.getSuperclassName();
======= 7db08d3:"java/org/apache/catalina/startup/ContextConfig.java"

======= 7db08d3:"java/org/apache/catalina/startup/ContextConfig.java"

        public final String superclassName;
        public final String[] interfaceNames;
            superclassName = javaClass.getSuperclassName();
            interfaceNames = javaClass.getInterfaceNames();
        }
        public String getSuperclassName() {
            return superclassName;
        public String[] getInterfaceNames() {
            return interfaceNames;

======= 9a80d06:"java/org/apache/catalina/connector/Response.java"

        String absolute;
        try {
            absolute = toAbsolute(url);
        } catch (IllegalArgumentException iae) {
            // Relative URL
            return url;
        }
======= 9a80d06:"java/org/apache/catalina/connector/Response.java"

            // Can't go above the server root
======= 9a80d06:"java/org/apache/catalina/connector/Response.java"

        // Add the query string and/or fragment (if present) back in
======= 9a80d06:"test/org/apache/catalina/connector/TestResponse.java"

    @Test
    public void testBug53469a() throws Exception {
        Request req = new TesterMockRequest();
        Response resp = new Response();
        resp.setRequest(req);
        String result = resp.encodeURL("../bar.html");
        Assert.assertEquals("../bar.html", result);
    }
    @Test
    public void testBug53469b() throws Exception {
        Request req = new TesterMockRequest();
        Response resp = new Response();
        resp.setRequest(req);
        String result = resp.encodeURL("../../../../bar.html");
        Assert.assertEquals("../../../../bar.html", result);
    }

======= 3ea8285:"java/org/apache/catalina/tribes/group/GroupChannel.java"

                    // Ignore. Probably triggered by a call to stopHeartbeat().
                    // In the highly unlikely event it was a different trigger,
                    // simply ignore it and continue.
======= 3ea8285:"java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java"

                } catch (InterruptedException x) {
                    Thread.currentThread().interrupt();
                String msg;
                if (suggestedviewId == null && !coordMsgReceived.get()) {
                    if (Thread.interrupted()) {
                        msg = "Election abandoned, waiting interrupted.";
                    } else {
                        msg = "Election abandoned, waiting timed out.";
                    }
                    msg = "Election abandoned, received a message";
                fireInterceptorEvent(new CoordinationEvent(
                        CoordinationEvent.EVT_ELECT_ABANDONED, this, msg));
            }
======= 3ea8285:"java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java"

                    // Ignore. Probably triggered by a call to stop().
                    // In the highly unlikely event it was a different trigger,
                    // simply ignore it and continue.
======= 3ea8285:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

                    if (errorCounter==0 && doRunReceiver) log.warn("Error receiving mcast package. Sleeping 500ms",x);
                    else if (log.isDebugEnabled()) log.debug("Error receiving mcast package"+(doRunReceiver?". Sleeping 500ms":"."),x);
                    if (doRunReceiver) {
                        try { Thread.sleep(500); } catch ( Exception ignore ){}
                        if ( (++errorCounter)>=recoveryCounter ) {
                            errorCounter=0;
                            RecoveryThread.recover(McastServiceImpl.this);
======= 3ea8285:"java/org/apache/juli/AsyncFileHandler.java"

            // Allow thread to be interrupted and back out of the publish
            // operation. No further action required.
======= 3ea8285:"java/org/apache/juli/AsyncFileHandler.java"

                } catch (InterruptedException x) {
                    // Ignore the attempt to interrupt the thread.
                } catch (Exception x) {
            }
======= 3ea8285:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                        // Ignore
======= 3ea8285:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"

                } catch (InterruptedException ignore) {
                    // Ignore
======= 3ea8285:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"

                } catch (InterruptedException ignore) {
                    // Ignore
======= 3ea8285:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

      <fix>
        <bug>53529</bug>: Clean-up the handling of
        <code>InterruptedException</code> throughout the code base. (markt)
      </fix>

======= eac6366:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            if (Boolean.FALSE.equals(con.getPoolProperties().getDefaultAutoCommit())) {

======= f54bb45:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java"

     * This parameter is only looked at if the {@link #getDefaultAutoCommit()} returns false
======= f54bb45:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java"

     * This parameter is only looked at if the {@link #getDefaultAutoCommit()} returns false

======= 4c03dff:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

======= 4c03dff:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

            int sendOptions = channelSendOptions;
            if (msg instanceof SessionMessage
                    && ((SessionMessage)msg).getEventType() == SessionMessage.EVT_ALL_SESSION_DATA) {
                sendOptions = Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK;
            }
                    channel.send(new Member[] {dest}, msg, sendOptions);
                    channel.send(destmembers,msg, sendOptions);

======= 4aef8e3:"java/org/apache/catalina/core/ApplicationContext.java"

    private final ConcurrentHashMap<String,String> parameters =
======= 4aef8e3:"java/org/apache/catalina/core/ApplicationContext.java"

        if (readOnlyAttributes.containsKey(name)){
        }
        value = attributes.remove(name);
        if (value == null) {
======= 4aef8e3:"java/org/apache/catalina/core/ApplicationContext.java"

        return parameters.putIfAbsent(name, value) == null;
======= 4aef8e3:"java/org/apache/catalina/ha/context/ReplicatedContext.java"

            Object obj = tomcatAttributes.get(name);
            if (obj == null) {
            } else {
                return obj;
            }

  <!-- Note: Extensions are always matched in a case-insensitive manner.    -->
======= f8e173b:"java/org/apache/catalina/core/StandardContext.java"

            mimeMappings.put(extension.toLowerCase(Locale.ENGLISH), mimeType);
======= f8e173b:"java/org/apache/catalina/core/StandardContext.java"

        return (mimeMappings.get(extension.toLowerCase(Locale.ENGLISH)));
      <add>
        <bug>45995</bug>: Align Tomcat with Apache httpd and perform MIME type
        mapping based on file extension in a case insensitive manner. (markt)
      </add>

======= 6213b38:"java/org/apache/catalina/core/StandardContext.java"

     * HTTP status code (as an Integer). Note status code zero is used for the
     * default error page.
======= 6213b38:"java/org/apache/catalina/core/StandardHostValve.java"

        if (errorPage == null) {
            // Look for a default error page
            errorPage = context.findErrorPage(0);
        }
======= 6213b38:"java/org/apache/catalina/deploy/ErrorPage.java"

     * The error (status) code for which this error page is active. Note that
     * status code 0 is used for the default error page.
======= 6213b38:"java/org/apache/catalina/deploy/ErrorPage.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    @Test
    public void testErrorPageHandling() throws Exception {
        // Set up a container
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        File docBase = new File(System.getProperty("java.io.tmpdir"));
        Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
        // Add the error page
        Tomcat.addServlet(ctx, "error", new ErrorServlet());
        ctx.addServletMapping("/error", "error");
        // Add the error handling page
        Tomcat.addServlet(ctx, "report", new ReportServlet());
        ctx.addServletMapping("/report/*", "report");
        // And the handling for 500 responses
        ErrorPage errorPage500 = new ErrorPage();
        errorPage500.setErrorCode(Response.SC_INTERNAL_SERVER_ERROR);
        errorPage500.setLocation("/report/500");
        ctx.addErrorPage(errorPage500);
        // And the default error handling
        ErrorPage errorPageDefault = new ErrorPage();
        errorPageDefault.setLocation("/report/default");
        ctx.addErrorPage(errorPageDefault);
        tomcat.start();
        doTestErrorPageHandling(500, "/500");
        doTestErrorPageHandling(501, "/default");
    }
    private void doTestErrorPageHandling(int error, String report)
            throws Exception {
        // Request a page that triggers an error
        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/error?errorCode=" + error, bc, null);
        Assert.assertEquals(error, rc);
        Assert.assertEquals(report, bc.toString());
    }
    private static class ErrorServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            int error =
                    Integer.valueOf(req.getParameter("errorCode")).intValue();
            resp.sendError(error);
        }
    }
    private static class ReportServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            String pathInfo = req.getPathInfo();
            resp.setContentType("text/plain");
            resp.getWriter().print(pathInfo);
        }
    }

======= 4de4325:"java/org/apache/catalina/core/ApplicationContext.java"

                URI uri = new URI("jndi", null, "", -1,
                        getJNDIUri(hostName, fullPath), null, null);
======= 4de4325:"test/org/apache/catalina/core/TestApplicationContext.java"

======= 4de4325:"test/org/apache/catalina/core/TestApplicationContext.java"

    @Test
    public void testBug53467() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        // app dir is relative to server home
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug53467].jsp", res, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        Assert.assertTrue(res.toString().contains("<p>OK</p>"));
    }
======= 4de4325:"test/org/apache/catalina/core/TestApplicationContext.java"

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <body>
    <p>OK</p>
  </body>

======= ff9a272:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java"

        if (original.getKeyProperty("path")!=null || properties.get("context")!=null) {
            //this ensures that if the registration came from tomcat, we're not losing
            //the unique domain, but putting that into as an engine attribute

======= 7ecd402:"java/org/apache/catalina/startup/WebRuleSet.java"

======= 7ecd402:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/ejb-local-ref/mapped-name",
                         new MappedNameRule());
======= 7ecd402:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/ejb-ref/mapped-name",
                         new MappedNameRule());
======= 7ecd402:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/env-entry/mapped-name",
                         new MappedNameRule());
======= 7ecd402:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/resource-env-ref/mapped-name",
                         new MappedNameRule());
======= 7ecd402:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/message-destination/mapped-name",
                         new MappedNameRule());
======= 7ecd402:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/message-destination-ref/mapped-name",
                         new MappedNameRule());
======= 7ecd402:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/resource-ref/mapped-name",
                         new MappedNameRule());
======= 7ecd402:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(fullPrefix + "/service-ref/mapped-name",
                         new MappedNameRule());
======= 7ecd402:"java/org/apache/catalina/startup/WebRuleSet.java"

 * A Rule that sets mapped name on the ResourceBase.
 */
    public MappedNameRule() {
        // NO-OP
    }
    /**
     * Process the body text of this element.
     *
     * @param namespace the namespace URI of the matching element, or an
     *   empty string if the parser is not namespace aware or the element has
     *   no namespace
     * @param name the local name if the parser is namespace aware, or just
     *   the element name otherwise
     * @param text The body text of this element
     */
    @Override
    public void body(String namespace, String name, String text)
            throws Exception {
        ResourceBase resourceBase = (ResourceBase) digester.peek();
        resourceBase.setProperty("mappedName", text.trim());
    }
======= 7ecd402:"test/org/apache/naming/resources/TestNamingContext.java"

    @Test
    public void testBug53465() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        tomcat.enableNaming();
        File appDir =
            new File("test/webapp-3.0");
        // app dir is relative to server home
        org.apache.catalina.Context ctxt =
                tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug53465.jsp", bc, null);
        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
        Assert.assertTrue(bc.toString().contains("<p>10</p>"));
        ContextEnvironment ce =
                ctxt.getNamingResources().findEnvironment("bug53465");
        Assert.assertEquals("Bug53465MappedName", ce.getProperty("mappedName"));
    }
  <env-entry>
    <description>Resource for testing bug 53465</description>
    <env-entry-name>bug53465</env-entry-name>
    <env-entry-value>10</env-entry-value>
    <env-entry-type>java.lang.Integer</env-entry-type>
    <mapped-name>Bug53465MappedName</mapped-name>
  </env-entry>

======= 294c52b:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("else throw new ServletException(t);");
======= 294c52b:"java/org/apache/jasper/runtime/JspFactoryImpl.java"

            if (ex instanceof RuntimeException) {
                throw (RuntimeException) ex;
            }

      <attribute name="objectName" required="false">
        <p>(String) Define a valid <code>javax.management.ObjectName</code> string that will be used to register this object with the platform mbean server
           The default value is <code>null</code> and the object will be registered using 
           tomcat.jdbc:type=org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReportJmx,name=the-name-of-the-pool
        </p>
      </attribute>
======= 4e010fc:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    /**
     * Default domain for objects registering with an mbean server
     */
    public static final String POOL_JMX_DOMAIN = "tomcat.jdbc";
    public static final String POOL_JMX_TYPE_PREFIX = POOL_JMX_DOMAIN+":type=";
======= 4e010fc:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java"

        String domain = ConnectionPool.POOL_JMX_DOMAIN;
======= 4e010fc:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReportJmx.java"

    public static final String objectNameAttribute = "objectName";
======= 4e010fc:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReportJmx.java"

    public ObjectName getObjectName(Class<?> clazz, String poolName) throws MalformedObjectNameException {
        ObjectName oname = null;
        if (getProperties().containsKey(objectNameAttribute)) {
            oname = new ObjectName(getProperties().get(objectNameAttribute).getValue());
        } else {
            oname = new ObjectName(ConnectionPool.POOL_JMX_TYPE_PREFIX+clazz.getName()+",name=" + poolName);
        }
======= 4e010fc:"modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestSlowQueryReport.java"

                new SlowQueryReportJmx().getObjectName(SlowQueryReportJmx.class, pool.getName()),

======= 553259c:"java/org/apache/catalina/connector/Connector.java"

        if (protocolHandler.isAprRequired() &&
                !AprLifecycleListener.isAprAvailable()) {
            throw new LifecycleException(
                    sm.getString("coyoteConnector.protocolHandlerNoApr",
                            getProtocolHandlerClassName()));
        }
======= 553259c:"java/org/apache/coyote/AbstractProtocol.java"

    @Override
    public boolean isAprRequired() {
        return false;
    }
======= 553259c:"java/org/apache/coyote/ProtocolHandler.java"

    /**
     * Requires APR/native library
     */
    public boolean isAprRequired();
======= 553259c:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    @Override
    public boolean isAprRequired() {
        // Override since this protocol implementation requires the APR/native
        // library
        return true;
    }
    // ------------------------------------------------------------ Constructor
======= 553259c:"java/org/apache/coyote/http11/Http11AprProtocol.java"

    @Override
    public boolean isAprRequired() {
        // Override since this protocol implementation requires the APR/native
        // library
        return true;
    }

======= 8a13b39:"java/javax/el/BeanELResolver.java"

                                    owner.getName(), descriptor.getName() }));
======= 8a13b39:"java/javax/el/BeanELResolver.java"

                                    owner.getName(), descriptor.getName() }));
======= 8a13b39:"java/javax/el/BeanELResolver.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testBug53421() {
        ExpressionFactory factory = ExpressionFactory.newInstance();
        ELContext context = new ELContextImpl();
        Bean bean = new Bean();
        ValueExpression varBean =
            factory.createValueExpression(bean, Bean.class);
        context.getVariableMapper().setVariable("bean", varBean);
        ValueExpression ve = factory.createValueExpression(
                context, "${bean.valueA}", String.class);
        Exception e = null;
        try {
            ve.getValue(context);
        } catch (PropertyNotFoundException pnfe) {
            e = pnfe;
        }
        Assert.assertTrue("Wrong exception type",
                e instanceof PropertyNotFoundException);
        String type = Bean.class.getName();
        @SuppressWarnings("null") // Assert above prevents msg being null
        String msg = e.getMessage();
        Assert.assertTrue("No reference to type [" + type +
                "] where property cannot be found in [" + msg + "]",
                msg.contains(type));
    }
    private static class Bean {
        @SuppressWarnings("unused")
        public void setValueA(String valueA) {
            // NOOP
        }
    }

======= 91a13d2:"java/org/apache/catalina/core/ContainerBase.java"

======= 91a13d2:"java/org/apache/catalina/core/ContainerBase.java"

     * The container event listeners for this Container. Implemented as a
     * CopyOnWriteArrayList since listeners may invoke methods to add/remove
     * tmeselves or other listeners and with a ReadWriteLock that would trigger
     * a deadlock.
    protected List<ContainerListener> listeners =
            new CopyOnWriteArrayList<ContainerListener>();
======= 91a13d2:"java/org/apache/catalina/core/ContainerBase.java"

        listeners.add(listener);
======= 91a13d2:"java/org/apache/catalina/core/ContainerBase.java"

        ContainerListener[] results =
            new ContainerListener[0];
        return listeners.toArray(results);
======= 91a13d2:"java/org/apache/catalina/core/ContainerBase.java"

        listeners.remove(listener);
======= 91a13d2:"java/org/apache/catalina/core/ContainerBase.java"

        if (listeners.size() < 1)
            return;
        ContainerEvent event = new ContainerEvent(this, type, data);
        // Note for each uses an iterator internally so this is safe
        for (ContainerListener listener : listeners) {
            listener.containerEvent(event);

======= ce24a10:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        if (error || status==SocketStatus.STOP) {
======= ce24a10:"java/org/apache/coyote/http11/Http11NioProcessor.java"

        if (error || status==SocketStatus.STOP) {

======= bf41254:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

                    // Some clients (older Android) use an absolute URI for
                    // DIGEST but a relative URI in the request line.
                    // request. 2.3.5 < fixed Android version <= 4.0.3
                    String host = request.getHeader("host");
                    String scheme = request.getScheme();
                    if (host != null && !uriQuery.startsWith(scheme)) {
                        StringBuilder absolute = new StringBuilder();
                        absolute.append(scheme);
                        absolute.append("://");
                        absolute.append(host);
                        absolute.append(uriQuery);
                        if (!uri.equals(absolute.toString())) {
                            return false;
                        }
                    } else {
                        return false;
                    }
======= bf41254:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

                // RFC 2617 says nc must be 8 digits long. Older Android clients
                // use 6. 2.3.5 < fixed Android version <= 4.0.3
                if (nc.length() < 6 || nc.length() > 8) {

======= 37e8c59:"java/org/apache/catalina/startup/ContextConfig.java"

            HandlesTypes ht = null;
            try {
                ht = sci.getClass().getAnnotation(HandlesTypes.class);
            } catch (Exception e) {
                if (log.isDebugEnabled()) {
                    log.info(sm.getString("contextConfig.sci.debug", url), e);
                } else {
                    log.info(sm.getString("contextConfig.sci.info", url));
                }
            }

======= 2bf1556:"java/org/apache/catalina/manager/StatusTransformer.java"

                writer.write(" requestBytesReceived=\"0\"");
        is received, the next stage will br "Parse and Prepare Requst". If no
        <xs:attribute name="requestBytesReceived" type="xs:long" use="required"/>

======= d73c07a:"java/org/apache/catalina/core/ContainerBase.java"

        private final ThreadGroup group;
        private final AtomicInteger threadNumber = new AtomicInteger(1);
        private final String namePrefix;

======= 0290e57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

    protected static final String PROP_COMMITONRETURN = "commitOnReturn";
    protected static final String PROP_ROLLBACKONRETURN = "rollbackOnReturn";
    protected static final String PROP_USEDISPOSABLECONNECTIONFACADE = "useDisposableConnectionFacade";
    protected static final String PROP_LOGVALIDATIONERRORS = "logValidationErrors";
    protected static final String PROP_PROPAGATEINTERRUPTSTATE = "propagateInterruptState";
======= 0290e57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        PROP_ALTERNATE_USERNAME_ALLOWED,
        PROP_COMMITONRETURN,
        PROP_ROLLBACKONRETURN,
        PROP_USEDISPOSABLECONNECTIONFACADE,
        PROP_LOGVALIDATIONERRORS,
        PROP_PROPAGATEINTERRUPTSTATE
======= 0290e57:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        value = properties.getProperty(PROP_COMMITONRETURN);
        if (value != null) {
            poolProperties.setCommitOnReturn(Boolean.parseBoolean(value));
        }
        value = properties.getProperty(PROP_ROLLBACKONRETURN);
        if (value != null) {
            poolProperties.setRollbackOnReturn(Boolean.parseBoolean(value));
        }
        value = properties.getProperty(PROP_USEDISPOSABLECONNECTIONFACADE);
        if (value != null) {
            poolProperties.setUseDisposableConnectionFacade(Boolean.parseBoolean(value));
        }
        value = properties.getProperty(PROP_LOGVALIDATIONERRORS);
        if (value != null) {
            poolProperties.setLogValidationErrors(Boolean.parseBoolean(value));
        }
        value = properties.getProperty(PROP_PROPAGATEINTERRUPTSTATE);
        if (value != null) {
            poolProperties.setPropagateInterruptState(Boolean.parseBoolean(value));
        }

======= cf703d2:"java/org/apache/naming/resources/BaseDirContext.java"

            // Skip blanks introduced by regexp split and/or poor input
            kvp = kvp.trim();
            if(0 == kvp.length())
                continue;
            if (kv.length != 2)
                throw new IllegalArgumentException(
                        sm.getString("resources.invalidAliasMapping", kvp));
            // Trim whitespace from key and value
            kv[0] = kv[0].trim();
            kv[1] = kv[1].trim();
            if(kv[0].length() == 0 || kv[1].length() == 0)
======= cf703d2:"test/org/apache/naming/resources/TestNamingContext.java"

======= cf703d2:"test/org/apache/naming/resources/TestNamingContext.java"

======= cf703d2:"test/org/apache/naming/resources/TestNamingContext.java"

    // Recursively deletes a directory and its contents
    private boolean rmdir(File dir)
    {
        if(!dir.exists()) return false;
        if(!dir.isDirectory()) return false;
        File[] files = dir.listFiles();
        if(null != files) {
            for(int i=0; i<files.length; ++i) {
                if(files[i].isDirectory())
                {
                    if(!rmdir(files[i])) {
                        return false;
                    }
                } else {
                    if(!files[i].delete()) {
                        return false;
                    }
                }
            }
        }
        return dir.delete();
    }
    @Test
    public void testAliases() throws Exception
    {
        // Some sample text
        String foxText = "The quick brown fox jumps over the lazy dog";
        String loremIpsum = "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.";
        // Set up a temporary docBase and some alternates that we can
        // set up as aliases.
        File tmpDir = new File(System.getProperty("java.io.tmpdir"),
                               "tomcat-unit-test." + TestNamingContext.class.getName());
        if(tmpDir.exists())
        {
            // Remove any old test files
            if(tmpDir.isDirectory()) {
                if(!rmdir(tmpDir))
                    throw new IOException("Could not delete old temp directory: " + tmpDir);
            } else {
                if(!tmpDir.delete())
                    throw new IOException("Could not delete old temp file: " + tmpDir);
            }
        }
        File docBase = new File(tmpDir, "docBase");
        File alternate1 = new File(tmpDir, "alternate1");
        File alternate2 = new File(tmpDir, "alternate2");
        
        if(!tmpDir.mkdirs())
            throw new IOException("Could not create temp directory " + tmpDir);
        if(!docBase.mkdir())
            throw new IOException("Could not create temp directory " + docBase);
        if(!alternate1.mkdir())
            throw new IOException("Could not create temp directory " + alternate1);
        if(!alternate2.mkdir())
            throw new IOException("Could not create temp directory " + alternate2);
        // Create a file in each alternate directory that we can attempt to access
        FileOutputStream fos = new FileOutputStream(new File(alternate1, "test1.txt"));
        fos.write(foxText.getBytes("UTF-8"));
        fos.flush(); fos.close();
        fos = new FileOutputStream(new File(alternate2, "test2.txt"));
        fos.write(loremIpsum.getBytes("UTF-8"));
        fos.flush(); fos.close();
        // Finally, create the Context
        FileDirContext ctx = new FileDirContext();
        ctx.setDocBase(docBase.getCanonicalPath());
        ctx.setAliases("/a1=" + alternate1.getCanonicalPath()
                       +",/a2=" + alternate2.getCanonicalPath());
        // Check first alias
        Object file = ctx.lookup("/a1/test1.txt");
        Assert.assertNotNull(file);
        Assert.assertTrue(file instanceof Resource);
        
        byte[] buffer = new byte[4096];
        Resource res = (Resource)file;
        int len = res.streamContent().read(buffer);
        String contents = new String(buffer, 0, len, "UTF-8");
        assertEquals(foxText, contents);
        // Check second alias
        file = ctx.lookup("/a2/test2.txt");
        Assert.assertNotNull(file);
        Assert.assertTrue(file instanceof Resource);
        
        res = (Resource)file;
        len = res.streamContent().read(buffer);
        contents = new String(buffer, 0, len, "UTF-8");
        assertEquals(loremIpsum, contents);
        // Test aliases with spaces around the separators
        ctx.setAliases("   /a1= " + alternate1.getCanonicalPath()
                       + "\n\n"
                       +", /a2 =\n" + alternate2.getCanonicalPath()
                       + ",");
        // Check first alias
        file = ctx.lookup("/a1/test1.txt");
        Assert.assertNotNull(file);
        Assert.assertTrue(file instanceof Resource);
        res = (Resource)file;
        len = res.streamContent().read(buffer);
        contents = new String(buffer, 0, len, "UTF-8");
        assertEquals(foxText, contents);
        // Check second alias
        file = ctx.lookup("/a2/test2.txt");
        Assert.assertNotNull(file);
        Assert.assertTrue(file instanceof Resource);
        
        res = (Resource)file;
        len = res.streamContent().read(buffer);
        contents = new String(buffer, 0, len, "UTF-8");
        assertEquals(loremIpsum, contents);
        // Clean-up
        if(!rmdir(tmpDir))
            throw new IOException("Could not clean-up temp directory" + tmpDir);
    }
        <p>Whitespace is permitted around both the <code>,</code> and
        <code>=</code> delimiters, and will be trimmed. Therefore, an aliases
        attribute with the value <code>"/aliasPath1 = docBase1,<br/>
        /aliasPath2= docBase2"</code> is equivalent to
        <code>"/aliasPath1=docBase1,/aliasPath2=docBase2"</code></p>

======= 1412935:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                try {
                    con.connect();
                } catch (Exception x) {
                    release(con);
                    setToNull = true;
                    if (x instanceof SQLException) {
                        throw (SQLException)x;
                    } else {
                        SQLException ex  = new SQLException(x.getMessage());
                        ex.initCause(x);
                        throw ex;
                    }
                }
======= 1412935:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            if (driver==null) {
                if (log.isDebugEnabled()) {
                    log.debug("Instantiating driver using class: "+poolProperties.getDriverClassName()+" [url="+poolProperties.getUrl()+"]");
                }
            }

======= 957d33b:"java/org/apache/jasper/JspC.java"

======= 957d33b:"java/org/apache/jasper/JspC.java"

======= 957d33b:"java/org/apache/jasper/JspC.java"

======= 957d33b:"java/org/apache/jasper/JspC.java"

            } catch (BuildException je) {
                System.err.println(je);
                if (jspc.dieLevel != NO_DIE_LEVEL) {
                    System.exit(jspc.dieLevel);
                }
======= 957d33b:"java/org/apache/jasper/JspC.java"

======= 957d33b:"java/org/apache/jasper/JspC.java"

    @Override
    public void execute() {
======= 957d33b:"java/org/apache/jasper/JspC.java"

            throw new BuildException(ioe);
======= 957d33b:"java/org/apache/jasper/JspC.java"

            throw new BuildException(je);

======= ea77dfb:"java/org/apache/catalina/session/ManagerBase.java"

            throw new TooManyActiveSessionsException(
                    sm.getString("managerBase.createSession.ise"),
                    maxActiveSessions);
======= ea77dfb:"java/org/apache/catalina/session/ManagerBase.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * An exception that indicates the maximum number of active sessions has been
 * reached and the server is refusing to create any new sessions.
 */
    extends IllegalStateException
    private static final long serialVersionUID = 1L;
    /**
     * The maximum number of active sessions the server will tolerate.
     */
    private final int maxActiveSessions;
    /**
     * Creates a new TooManyActiveSessionsException.
     * 
     * @param message A description for the exception.
     * @param maxActive The maximum number of active sessions allowed by the
     *                  session manager.
     */
    public TooManyActiveSessionsException(String message,
                                          int maxActive)
    {
        super(message);
        
        maxActiveSessions = maxActive;
    }
    
    /**
     * Gets the maximum number of sessions allowed by the session manager.
     *
     * @return The maximum number of sessions allowed by the session manager.
     */
    public int getMaxActiveSessions()
    {
        return maxActiveSessions;
    }

======= b82c47e:"java/org/apache/catalina/startup/ContextConfig.java"

        boolean servletNamesSet = false;
======= b82c47e:"java/org/apache/catalina/startup/ContextConfig.java"

                servletNamesSet = servletNames.length > 0;
======= b82c47e:"java/org/apache/catalina/startup/ContextConfig.java"

            if (urlPatternsSet || servletNamesSet) {
                filterMap.setFilterName(filterName);
                fragment.addFilterMapping(filterMap);
            }

======= d713894:"java/org/apache/catalina/websocket/StreamInbound.java"

    private final ClassLoader applicationClassLoader;
    public StreamInbound() {
        applicationClassLoader = Thread.currentThread().getContextClassLoader();
    }
======= d713894:"java/org/apache/catalina/websocket/StreamInbound.java"

                    doOnBinaryData(wsIs);
                    doOnTextData(r);
======= d713894:"java/org/apache/catalina/websocket/StreamInbound.java"

    private void doOnBinaryData(InputStream is) throws IOException {
        // Need to call onClose using the web application's class loader
        Thread t = Thread.currentThread();
        ClassLoader cl = t.getContextClassLoader();
        t.setContextClassLoader(applicationClassLoader);
        try {
            onBinaryData(is);
        } finally {
            t.setContextClassLoader(cl);
        }
    }
    private void doOnTextData(Reader r) throws IOException {
        // Need to call onClose using the web application's class loader
        Thread t = Thread.currentThread();
        ClassLoader cl = t.getContextClassLoader();
        t.setContextClassLoader(applicationClassLoader);
        try {
            onTextData(r);
        } finally {
            t.setContextClassLoader(cl);
        }
    }
            doOnClose(status);
======= d713894:"java/org/apache/catalina/websocket/StreamInbound.java"

            doOnClose(Constants.OPCODE_CLOSE);
        }
    }
    private void doOnClose(int status) {
        // Need to call onClose using the web application's class loader
        Thread t = Thread.currentThread();
        ClassLoader cl = t.getContextClassLoader();
        t.setContextClassLoader(applicationClassLoader);
        try {
            onClose(status);
        } finally {
            t.setContextClassLoader(cl);
    public final void onUpgradeComplete() {
        // Need to call onOpen using the web application's class loader
        Thread t = Thread.currentThread();
        ClassLoader cl = t.getContextClassLoader();
        t.setContextClassLoader(applicationClassLoader);
        try {
            onOpen(outbound);
        } finally {
            t.setContextClassLoader(cl);
        }
======= d713894:"test/org/apache/catalina/websocket/TestWebSocket.java"

======= d713894:"test/org/apache/catalina/websocket/TestWebSocket.java"

======= d713894:"test/org/apache/catalina/websocket/TestWebSocket.java"

======= d713894:"test/org/apache/catalina/websocket/TestWebSocket.java"

    @Test
    public void testBug53339() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        tomcat.enableNaming();
        // Must have a real docBase - just use temp
        Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctx, "Bug53339", new Bug53339Servlet());
        ctx.addServletMapping("/*", "Bug53339");
        // Create the resource
        ContextEnvironment env = new ContextEnvironment();
        env.setName(Bug53339WsInbound.JNDI_NAME);
        env.setType(String.class.getName());
        env.setValue(Bug53339WsInbound.TEST_MESSAGE);
        ctx.getNamingResources().addEnvironment(env);
        tomcat.start();
        WebSocketClient client= new WebSocketClient(getPort());
        // Send the WebSocket handshake
        client.writer.write("GET / HTTP/1.1" + CRLF);
        client.writer.write("Host: foo" + CRLF);
        client.writer.write("Upgrade: websocket" + CRLF);
        client.writer.write("Connection: upgrade" + CRLF);
        client.writer.write("Sec-WebSocket-Version: 13" + CRLF);
        client.writer.write("Sec-WebSocket-Key: TODO" + CRLF);
        client.writer.write(CRLF);
        client.writer.flush();
        // Make sure we got an upgrade response
        String responseLine = client.reader.readLine();
        assertTrue(responseLine.startsWith("HTTP/1.1 101"));
        // Swallow the headers
        String responseHeaderLine = client.reader.readLine();
        while (!responseHeaderLine.equals("")) {
            responseHeaderLine = client.reader.readLine();
        }
        // Now we can do WebSocket
        String msg = client.readMessage();
        assertEquals(Bug53339WsInbound.TEST_MESSAGE, msg);
        // Finished with the socket
        client.close();
    }
    private static class Bug53339Servlet extends WebSocketServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected StreamInbound createWebSocketInbound(String subProtocol) {
            return new Bug53339WsInbound();
        }
    }
    private static class Bug53339WsInbound extends MessageInbound {
        public static final String TEST_MESSAGE = "Test Message";
        public static final String JNDI_NAME = "Bug53339Message";
        @Override
        protected void onOpen(WsOutbound outbound) {
            String msg = "Error";
            try {
                javax.naming.Context initCtx = new InitialContext();
                msg = (String) initCtx.lookup(
                        "java:comp/env/" + JNDI_NAME);
            } catch (NamingException e) {
                // Ignore - the test checks if the message is sent
                e.printStackTrace(); // for debug purposes if the test fails
            }
            CharBuffer cb = CharBuffer.wrap("" + msg);
            try {
                outbound.writeTextMessage(cb);
            } catch (IOException e) {
                // Ignore - the test checks if the message is sent
            }
        }
        @Override
        protected void onBinaryMessage(ByteBuffer message) throws IOException {
            // Ignore
        }
        @Override
        protected void onTextMessage(CharBuffer message) throws IOException {
            // Ignore
        }
    }

======= a1c6165:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                false, false, 200, false, 200);
======= a1c6165:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                false, true, 401, false, 200);
    }
    /*
     * Try to access a protected resource in a webapp that
     * has a BASIC login method defined. Verify the server is
     * prepared to accept non-standard case for the auth scheme.
     * The access should be challenged, authenticated and then permitted.
     */
    @Test
    public void testAuthMethodCaseBasic() throws Exception {
        doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED,
                true, true, 401, false, 200);
======= a1c6165:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                false, true, 401, false, 200);
                false, true, 401, false, 200);
======= a1c6165:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

                false, true, 401, false, 200);
======= a1c6165:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

            boolean verifyAuthSchemeCase,
======= a1c6165:"test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java"

        String authScheme = verifyAuthSchemeCase ? "bAsIc " : "Basic ";
        String authLine = authScheme + base64auth;

======= c6b691d:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        if (request.getAsyncContext() != null) {
            // An async request was started during the forward, don't close the
            // response as it may be written to during the async handling
            return;
        }
======= c6b691d:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

======= c6b691d:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    @Test
    public void testBug53337() throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        File docBase = new File(System.getProperty("java.io.tmpdir"));
        Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
        Wrapper a = Tomcat.addServlet(ctx, "ServletA", new Bug53337ServletA());
        a.setAsyncSupported(true);
        Wrapper b = Tomcat.addServlet(ctx, "ServletB", new Bug53337ServletB());
        b.setAsyncSupported(true);
        Tomcat.addServlet(ctx, "ServletC", new Bug53337ServletC());
        ctx.addServletMapping("/ServletA", "ServletA");
        ctx.addServletMapping("/ServletB", "ServletB");
        ctx.addServletMapping("/ServletC", "ServletC");
        tomcat.start();
        StringBuilder url = new StringBuilder(48);
        url.append("http://localhost:");
        url.append(getPort());
        url.append("/ServletA");
        ByteChunk body = new ByteChunk();
        int rc = getUrl(url.toString(), body, null);
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertEquals("OK", body.toString());
    }
    private static class Bug53337ServletA extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            RequestDispatcher rd = req.getRequestDispatcher("/ServletB");
            rd.forward(req, resp);
        }
    }
    private static class Bug53337ServletB extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(final HttpServletRequest req,
                final HttpServletResponse resp)
                throws ServletException, IOException {
            final AsyncContext async = req.startAsync();
            // Just for debugging
            async.setTimeout(100000);
            ExecutorService executor = Executors.newSingleThreadExecutor();
            executor.submit(new Runnable() {
                @Override
                public void run() {
                    async.dispatch("/ServletC");
                }
            });
            executor.shutdown();
        }
    }
    private static class Bug53337ServletC extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setContentType("text/plain");
            resp.getWriter().print("OK");
        }
    }

======= 6ce3128:"java/org/apache/catalina/startup/Tomcat.java"

======= 6ce3128:"java/org/apache/catalina/startup/Tomcat.java"

                if (!instanceInitialized) {
                    instanceInitialized = true;
======= 6ce3128:"test/org/apache/catalina/startup/TestTomcat.java"

======= 6ce3128:"test/org/apache/catalina/startup/TestTomcat.java"

     * Simple servlet to test initialization of servlet instances.
     */
    private static class InitCount extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private AtomicInteger callCount = new AtomicInteger(0);
        @Override
        public void init() throws ServletException {
            super.init();
            callCount.incrementAndGet();
        }
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setContentType("text/plain");
            resp.getWriter().print("OK");
        }
        public int getCallCount() {
            return callCount.intValue();
        }
    }
    /**
======= 6ce3128:"test/org/apache/catalina/startup/TestTomcat.java"

    @Test
    public void testBug53301() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        org.apache.catalina.Context ctx =
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        InitCount initCount = new InitCount();
        Tomcat.addServlet(ctx, "initCount", initCount);
        ctx.addServletMapping("/", "initCount");
        tomcat.start();
        ByteChunk res = getUrl("http://localhost:" + getPort() + "/");
        assertEquals("OK", res.toString());
        assertEquals(1, initCount.getCallCount());
    }

======= ad3b503:"java/org/apache/catalina/deploy/ServletDef.java"

     * @deprecated
    @Deprecated
======= ad3b503:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addObjectCreate(fullPrefix + "/servlet/security-role-ref",
                                 "org.apache.catalina.deploy.SecurityRoleRef");
        digester.addSetNext(fullPrefix + "/servlet/security-role-ref",
                            "addSecurityRoleRef",
                            "org.apache.catalina.deploy.SecurityRoleRef");
        digester.addCallMethod(fullPrefix + "/servlet/security-role-ref/role-link",
                               "setLink", 0);
        digester.addCallMethod(fullPrefix + "/servlet/security-role-ref/role-name",
                               "setName", 0);

======= 84342f5:"java/org/apache/catalina/core/ContainerBase.java"

======= 84342f5:"java/org/apache/catalina/core/ContainerBase.java"

                startStopQueue,
                new StartStopThreadFactory(getName() + "-startStop-"));
======= 84342f5:"java/org/apache/catalina/core/ContainerBase.java"

    private static class StartStopThreadFactory implements ThreadFactory {
        private ThreadGroup group;
        private AtomicInteger threadNumber = new AtomicInteger(1);
        private String namePrefix;
        
        public StartStopThreadFactory(String namePrefix) {
            SecurityManager s = System.getSecurityManager();
            group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
            this.namePrefix = namePrefix;
        }
        
        @Override
        public Thread newThread(Runnable r) {
            Thread thread = new Thread(group, r, namePrefix + threadNumber.getAndIncrement());
            thread.setDaemon(true);
            return thread;
        }
    }

======= e90cd4b:"java/org/apache/tomcat/util/scan/FileUrlJar.java"

        jarConn.setUseCaches(false);

======= 280beac:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);
======= 280beac:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        boolean connectionClosePresent = false;
            // If the response code supports an entity body and we're on
            // HTTP 1.1 then we chunk unless we have a Connection: close header
            connectionClosePresent = isConnectionClose(headers);
            if (entityBody && http11 && !connectionClosePresent) {
======= 280beac:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

            // Avoid adding the close header twice
            if (!connectionClosePresent) {
                headers.addValue(Constants.CONNECTION).setString(
                        Constants.CLOSE);
            }
======= 280beac:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

    private boolean isConnectionClose(MimeHeaders headers) {
        MessageBytes connection = headers.getValue(Constants.CONNECTION);
        if (connection == null) {
            return false;
        }
        return connection.equals(Constants.CLOSE);
    }
======= 280beac:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

======= 280beac:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

    @Test
    public void testChunking11NoContentLength() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctxt = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctxt, "NoContentLengthFlushingServlet",
                new NoContentLengthFlushingServlet());
        ctxt.addServletMapping("/test", "NoContentLengthFlushingServlet");
        tomcat.start();
        ByteChunk responseBody = new ByteChunk();
        Map<String,List<String>> responseHeaders =
                new HashMap<String,List<String>>();
        int rc = getUrl("http://localhost:" + getPort() + "/test", responseBody,
                responseHeaders);
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertTrue(responseHeaders.containsKey("Transfer-Encoding"));
        List<String> encodings = responseHeaders.get("Transfer-Encoding");
        assertEquals(1, encodings.size());
        assertEquals("chunked", encodings.get(0));
    }
    @Test
    public void testNoChunking11NoContentLengthConnectionClose()
            throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctxt = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctxt, "NoContentLengthConnectionCloseFlushingServlet",
                new NoContentLengthConnectionCloseFlushingServlet());
        ctxt.addServletMapping("/test",
                "NoContentLengthConnectionCloseFlushingServlet");
        tomcat.start();
        ByteChunk responseBody = new ByteChunk();
        Map<String,List<String>> responseHeaders =
                new HashMap<String,List<String>>();
        int rc = getUrl("http://localhost:" + getPort() + "/test", responseBody,
                responseHeaders);
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertTrue(responseHeaders.containsKey("Connection"));
        List<String> connections = responseHeaders.get("Connection");
        assertEquals(1, connections.size());
        assertEquals("close", connections.get(0));
        assertFalse(responseHeaders.containsKey("Transfer-Encoding"));
        assertEquals("OK", responseBody.toString());
    }
    // flushes with no content-length set
    // should result in chunking on HTTP 1.1
    private static final class NoContentLengthFlushingServlet
            extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setStatus(HttpServletResponse.SC_OK);
            resp.setContentType("text/plain");
            resp.getWriter().write("OK");
            resp.flushBuffer();
        }
    }
    // flushes with no content-length set but sets Connection: close header
    // should no result in chunking on HTTP 1.1
    private static final class NoContentLengthConnectionCloseFlushingServlet
            extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.setStatus(HttpServletResponse.SC_OK);
            resp.setContentType("text/event-stream");
            resp.addHeader("Connection", "close");
            resp.flushBuffer();
            resp.getWriter().write("OK");
            resp.flushBuffer();
        }
    }

======= 13100e9:"java/org/apache/catalina/core/DefaultInstanceManager.java"

======= 13100e9:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                            String fieldName = getName(method);
======= 13100e9:"java/org/apache/catalina/core/DefaultInstanceManager.java"

        // Note: method signature has already been checked for correctness.
        // The method name always starts with "set".
        return Introspector.decapitalize(setter.getName().substring(3));

======= 39c8e18:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                        if (injections != null && methodName.startsWith("set")
                                && methodName.length() > 3
                        		&& method.getParameterTypes().length == 1
                        		&& method.getReturnType().getName().equals("void")) {

======= 5d12129:"java/org/apache/catalina/loader/WebappClassLoader.java"

        boolean isClassResource = path.endsWith(".class");
======= 5d12129:"java/org/apache/catalina/loader/WebappClassLoader.java"

                /* Only cache the binary content if there is some content
                 * available and either:
                 * a) It is a class file since the binary content is only cached
                 *    until the class has been loaded
                 *    or
                 * b) The file needs conversion to address encoding issues (see
                 *    below)
                 *
                 * In all other cases do not cache the content to prevent
                 * excessive memory usage if large resources are present (see
                 * https://issues.apache.org/bugzilla/show_bug.cgi?id=53081).
                 */
                if (binaryStream != null &&
                        (isClassResource || fileNeedConvert)) {
======= 5d12129:"java/org/apache/catalina/loader/WebappClassLoader.java"

            else {
                try {
                    return entry.source.openStream();
                } catch (IOException ioe) {
                    // Ignore
                }
            }
        return null;

======= de1f763:"java/org/apache/catalina/core/DefaultInstanceManager.java"

======= de1f763:"java/org/apache/catalina/core/DefaultInstanceManager.java"

            Map<String, String> injections = assembleInjectionsFromClassHierarchy(clazz);
======= de1f763:"java/org/apache/catalina/core/DefaultInstanceManager.java"

    private Map<String, String> assembleInjectionsFromClassHierarchy(Class<?> clazz) {
        Map<String, String> injections = new HashMap<String, String>();
        Map<String, String> currentInjections = null;
        while (clazz != null) {
            currentInjections = this.injectionMap.get(clazz.getName());
            if (currentInjections != null) {
                injections.putAll(currentInjections);
            }
            clazz = clazz.getSuperclass();
        }
        return injections;
    }

======= 098a647:"java/org/apache/catalina/websocket/StreamInbound.java"

======= 098a647:"java/org/apache/catalina/websocket/StreamInbound.java"

    /**
     * This default implementation sets the read timeout to infinite and expects
     * the WebSocket application to close the connection when it is no longer
     * required. Applications wishing to set an explicit timeout may override
     * this method and return a value of their choice.
     *
     * @return  The read timeout in milliseconds or -1 for infinite
     */
    @Override
    public int getReadTimeout() {
        return -1;
    }
======= 098a647:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

                        socket.getSocket().longValue(),
                        proto.endpoint.getKeepAliveTimeout());
======= 098a647:"java/org/apache/coyote/http11/Http11AprProtocol.java"

                        socket.getSocket().longValue(),
                        proto.endpoint.getKeepAliveTimeout());
======= 098a647:"java/org/apache/coyote/http11/Http11AprProtocol.java"

                        socket.getSocket().longValue(),
                        proto.endpoint.getSoTimeout());
                        socket.getSocket().longValue(),
                        (processor.getUpgradeInbound().getReadTimeout()));
======= 098a647:"java/org/apache/coyote/http11/upgrade/UpgradeAprProcessor.java"

        Socket.timeoutSet(wrapper.getSocket().longValue(),
                upgradeInbound.getReadTimeout());
======= 098a647:"java/org/apache/coyote/http11/upgrade/UpgradeBioProcessor.java"

        int timeout = upgradeInbound.getReadTimeout();
        if (timeout < 0) {
            timeout = 0;
        }
        wrapper.getSocket().setSoTimeout(timeout);
======= 098a647:"java/org/apache/coyote/http11/upgrade/UpgradeInbound.java"

    /**
     * Allow the upgraded protocol to define the read timeout to be used with
     * the upgraded connection.
     *
     * @return  The read timeout in milliseconds or -1 for infinite
     */
    int getReadTimeout();
======= 098a647:"java/org/apache/coyote/http11/upgrade/UpgradeNioProcessor.java"

        wrapper.setTimeout(upgradeInbound.getReadTimeout());
======= 098a647:"java/org/apache/tomcat/util/net/AprEndpoint.java"

         * Add specified socket and associated pool to the poller. The socket
         * will be added to a temporary array, and polled first after a maximum
         * amount of time equal to pollTime (in most cases, latency will be much
         * lower, however).
         * @param socket    to add to the poller
         * @param timeout   read timeout (in milliseconds) to use with this
         *                  socket. Use -1 for infinite timeout
        public void add(long socket, int timeout) {
======= 098a647:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                addSocketTimeout[addCount] = timeout;
======= 098a647:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                    int timeout = addSocketTimeout[i];
                                    if (timeout > 0) {
                                        // Convert milliseconds to microseconds
                                        timeout = timeout * 1000;
                                    }
                                            Poll.APR_POLLIN, timeout);
======= 098a647:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                    getPoller().add(state.socket,
                                            getKeepAliveTimeout());
======= 098a647:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                        getPoller().add(socket.getSocket().longValue(),
                                getSoTimeout());

======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    private AtomicLong poolVersion = new AtomicLong(Long.MIN_VALUE);
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            //idle = new LinkedTransferQueue<PooledConnection>();
            //idle = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(),false);
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        if (con.getConnectionVersion() < getPoolVersion()) return true;
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        checkIdle(false);
    }
    public void checkIdle(boolean ignoreMinSize) {
            while ( (ignoreMinSize || (idle.size()>=getPoolProperties().getMinIdle())) && unlocked.hasNext()) {
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                    if (shouldReleaseIdle(now, con, time)) {
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    protected boolean shouldReleaseIdle(long now, PooledConnection con, long time) {
        if (con.getConnectionVersion() < getPoolVersion()) return true;
        else return (con.getReleaseTime()>0) && ((now - time) > con.getReleaseTime()) && (getSize()>getPoolProperties().getMinIdle());
    }
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

     * Purges all connections in the pool.
     * For connections currently in use, these connections will be
     * purged when returned on the pool. This call also
     * purges connections that are idle and in the pool
     * To only purge used/active connections see {@link #purgeOnReturn()}
     */
    public void purge() {
        purgeOnReturn();
        checkIdle(true);
    }
    /**
     * Purges connections when they are returned from the pool.
     * This call does not purge idle connections until they are used.
     * To purge idle connections see {@link #purge()}
     */
    public void purgeOnReturn() {
        poolVersion.incrementAndGet();
    }
    /**
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    public long getPoolVersion() {
        return poolVersion.get();
    }
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    /**
     * {@inheritDoc}
     */
    public void purge()  {
        try {
            createPool().purge();
        }catch (SQLException x) {
            log.error("Unable to purge pool.",x);
        }
    }
    /**
     * {@inheritDoc}
     */
    public void purgeOnReturn() {
        try {
            createPool().purgeOnReturn();
        }catch (SQLException x) {
            log.error("Unable to purge pool.",x);
        }
    }
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

    private volatile long connectionVersion=0;
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        connectionVersion = parent.getPoolVersion();
    }
    public long getConnectionVersion() {
        return connectionVersion;
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public void purge() {
        pool.purge();
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void purgeOnReturn() {
        pool.purgeOnReturn();
    }
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPoolMBean.java"

    /**
     * Purges all connections in the pool.
     * For connections currently in use, these connections will be
     * purged when returned on the pool. This call also
     * purges connections that are idle and in the pool
     * To only purge used/active connections see {@link #purgeOnReturn()}
     */
    public void purge();
    /**
     * Purges connections when they are returned from the pool.
     * This call does not purge idle connections until they are used.
     * To purge idle connections see {@link #purge()}
     */
    public void purgeOnReturn();
======= f170929:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPoolMBean.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * @author Filip Hanik
 * @version 1.0
 */
    public PoolPurgeTest(String name) {
        super(name);
    }
    static final int expectedSize = 2;
    @Override
    public org.apache.tomcat.jdbc.pool.DataSource createDefaultDataSource() {
        // TODO Auto-generated method stub
        org.apache.tomcat.jdbc.pool.DataSource ds = super.createDefaultDataSource();
        ds.getPoolProperties().setDriverClassName(Driver.class.getName());
        ds.getPoolProperties().setUrl(Driver.url);
        ds.getPoolProperties().setInitialSize(expectedSize);
        ds.getPoolProperties().setMaxIdle(expectedSize);
        ds.getPoolProperties().setMinIdle(expectedSize);
        ds.getPoolProperties().setMaxActive(expectedSize);
        ds.getPoolProperties().setTimeBetweenEvictionRunsMillis(30000);
        ds.getPoolProperties().setMaxAge(Long.MAX_VALUE);
        return ds;
    }
    @Override
    protected void tearDown() throws Exception {
        Driver.reset();
        super.tearDown();
    }
    public void testPoolPurge() throws Exception {
        init();
        this.datasource.getConnection().close();
        assertEquals("Nr of connections should be "+expectedSize, expectedSize , datasource.getSize());
        this.datasource.purge();
        assertEquals("Nr of connections should be 0", 0 , datasource.getSize());
        tearDown();
    }
    public void testPoolPurgeWithActive() throws Exception {
        init();
        java.sql.Connection con = datasource.getConnection();
        assertEquals("Nr of connections should be "+expectedSize, expectedSize , datasource.getSize());
        this.datasource.purge();
        assertEquals("Nr of connections should be "+(expectedSize-1), (expectedSize-1) , datasource.getSize());
        con.close();
        assertEquals("Nr of connections should be 0", 0 , datasource.getSize());
        tearDown();
    }
    public void testPoolPurgeOnReturn() throws Exception {
        init();
        java.sql.Connection con = datasource.getConnection();
        assertEquals("Nr of connections should be "+expectedSize, expectedSize , datasource.getSize());
        this.datasource.purgeOnReturn();
        assertEquals("Nr of connections should be "+expectedSize, expectedSize , datasource.getSize());
        con.close();
        assertEquals("Nr of connections should be "+(expectedSize-1), (expectedSize-1) , datasource.getSize());
        tearDown();
    }

======= 111dc8e:"java/org/apache/catalina/websocket/WebSocketServlet.java"

======= 111dc8e:"java/org/apache/catalina/websocket/WebSocketServlet.java"

        // Small hack until the Servlet API provides a way to do this.
        ServletRequest inner = req;
        // Unwrap the request
        while (inner instanceof ServletRequestWrapper) {
            inner = ((ServletRequestWrapper) inner).getRequest();
        }
        if (inner instanceof RequestFacade) {
            ((RequestFacade) req).doUpgrade(inbound);
        } else {
            resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }

======= be365e5:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

        return getMaxThreadsExecutor(running);
    }
    protected int getMaxThreadsExecutor(boolean useExecutor) {
        if (useExecutor && executor != null) {
======= be365e5:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

            setMaxConnections(getMaxThreadsExecutor(true));
      <strong>maxThreads</strong> unless an <a href="executir.html">Executor</a>
      is used in which case the default will be the value of maxThreads from the
      executor. For NIO the default is <code>10000</code>.
      <strong>maxThreads</strong> unless an <a href="executir.html">Executor</a>
      is used in which case the default will be the value of maxThreads from the
      executor. For NIO the default is <code>10000</code>.

======= 48b9153:"java/org/apache/catalina/ha/session/DeltaSession.java"

        /**
         * If this returns true, to replicate that an object has been accessed
         * @return boolean
         */
        @Override
        public boolean isAccessReplicate() {
            long replDelta = System.currentTimeMillis() - getLastTimeReplicated();
            if (maxInactiveInterval >=0 && replDelta > (maxInactiveInterval * 1000)) {
                return true;
            }
            return false;
        }
        /**
         * Access to an existing object.
         */
        @Override
        public void accessEntry() {
            this.access();
            this.setPrimarySession(false);
            this.endAccess();
        }
======= 48b9153:"java/org/apache/catalina/ha/session/DeltaSession.java"

    @Override
    public long getLastTimeReplicated() {
======= 48b9153:"java/org/apache/catalina/ha/session/DeltaSession.java"

    @Override
    public void setLastTimeReplicated(long lastTimeReplicated) {
======= 48b9153:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            //check to see if we need to replicate this object isDirty()||complete || isAccessReplicate()
            boolean isDirty = ((value instanceof ReplicatedMapEntry) && ((ReplicatedMapEntry) value).isDirty());
            boolean isAccess = ((value instanceof ReplicatedMapEntry) && ((ReplicatedMapEntry) value).isAccessReplicate());
            boolean repl = complete || isDirty || isAccess;
======= 48b9153:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            boolean diff = ((value instanceof ReplicatedMapEntry) && ((ReplicatedMapEntry) value).isDiffable());
            if (diff && isDirty) {
======= 48b9153:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            if (msg == null && isAccess) {
                //construct a access message
                msg = new MapMessage(mapContextName, MapMessage.MSG_ACCESS,
                        false, (Serializable) entry.getKey(), null, null, entry.getPrimary(),
                        entry.getBackupNodes());
            }
======= 48b9153:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    if ((entry.getValue() instanceof ReplicatedMapEntry)) {
                        ((ReplicatedMapEntry)entry.getValue()).setLastTimeReplicated(System.currentTimeMillis());
                    }
======= 48b9153:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        if (mapmsg.getMsgType() == MapMessage.MSG_ACCESS) {
            MapEntry<K, V> entry = innerMap.get(mapmsg.getKey());
            if (entry != null) {
                entry.setBackupNodes(mapmsg.getBackupNodes());
                entry.setPrimary(mapmsg.getPrimary());
                if (entry.getValue() instanceof ReplicatedMapEntry) {
                    ((ReplicatedMapEntry) entry.getValue()).accessEntry();
                }
            }
        }
======= 48b9153:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        public static final int MSG_ACCESS = 11;
======= 48b9153:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                case MSG_ACCESS: return "MSG_ACCESS";
======= 48b9153:"java/org/apache/catalina/tribes/tipis/ReplicatedMapEntry.java"

    /**
     * Return the last replicate time.
     * @return
     */
    public long getLastTimeReplicated();
    /**
     * Set the last replicate time.
     * @param lastTimeReplicated
     */
    public void setLastTimeReplicated(long lastTimeReplicated);
    /**
     * If this returns true, to replicate that an object has been accessed
     * @return boolean
     */
    public boolean isAccessReplicate();
    /**
     * Access to an existing object.
     */
    public void accessEntry();

======= df88ecb:"java/org/apache/catalina/core/AprLifecycleListener.java"

                    + minor + "." + patch,
                    Library.APR_MAJOR_VERSION + "."
                    + Library.APR_MINOR_VERSION + "."
                    + Library.APR_PATCH_VERSION));

======= 518662f:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        initializePoolCleaner(properties);
======= 518662f:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    public void initializePoolCleaner(PoolConfiguration properties) {
        //if the evictor thread is supposed to run, start it now
        if (properties.isPoolSweeperEnabled()) {
            poolCleaner = new PoolCleaner(this, properties.getTimeBetweenEvictionRunsMillis());
            poolCleaner.start();
        } //end if
    }
======= 518662f:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    private volatile Properties dbProperties = new Properties();
    private volatile String url = null;
    private volatile String driverClassName = null;
    private volatile Boolean defaultAutoCommit = null;
    private volatile Boolean defaultReadOnly = null;
    private volatile int defaultTransactionIsolation = DataSourceFactory.UNKNOWN_TRANSACTIONISOLATION;
    private volatile String defaultCatalog = null;
    private volatile String connectionProperties;
    private volatile int initialSize = 10;
    private volatile int maxActive = DEFAULT_MAX_ACTIVE;
    private volatile int maxIdle = maxActive;
    private volatile int minIdle = initialSize;
    private volatile int maxWait = 30000;
    private volatile String validationQuery;
    private volatile String validatorClassName;
    private volatile Validator validator;
    private volatile boolean testOnBorrow = false;
    private volatile boolean testOnReturn = false;
    private volatile boolean testWhileIdle = false;
    private volatile int timeBetweenEvictionRunsMillis = 5000;
    private volatile int numTestsPerEvictionRun;
    private volatile int minEvictableIdleTimeMillis = 60000;
    private volatile boolean accessToUnderlyingConnectionAllowed = true;
    private volatile boolean removeAbandoned = false;
    private volatile int removeAbandonedTimeout = 60;
    private volatile boolean logAbandoned = false;
    private volatile String name = "Tomcat Connection Pool["+(poolCounter.addAndGet(1))+"-"+System.identityHashCode(PoolProperties.class)+"]";
    private volatile String password;
    private volatile String username;
    private volatile long validationInterval = 30000;
    private volatile boolean jmxEnabled = true;
    private volatile String initSQL;
    private volatile boolean testOnConnect =false;
    private volatile String jdbcInterceptors=null;
    private volatile boolean fairQueue = true;
    private volatile boolean useEquals = true;
    private volatile int abandonWhenPercentageFull = 0;
    private volatile long maxAge = 0;
    private volatile boolean useLock = false;
    private volatile InterceptorDefinition[] interceptors = null;
    private volatile int suspectTimeout = 0;
    private volatile Object dataSource = null;
    private volatile String dataSourceJNDI = null;
    private volatile boolean alternateUsernameAllowed = false;
    private volatile boolean commitOnReturn = false;
    private volatile boolean rollbackOnReturn = false;
    private volatile boolean useDisposableConnectionFacade = true;
    private volatile boolean logValidationErrors = false;
    private volatile boolean propagateInterruptState = false;
======= 518662f:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        // noop - this pool is already running
        throw new UnsupportedOperationException();
        getPoolProperties().setInitSQL(initSQL);
        // noop - this pool is already running
        throw new UnsupportedOperationException();
        // noop - this pool is already running and obviously jmx enabled
        throw new UnsupportedOperationException();
        getPoolProperties().setLogAbandoned(logAbandoned);
        getPoolProperties().setMaxActive(maxActive);
        getPoolProperties().setMaxIdle(maxIdle);
        getPoolProperties().setMaxWait(maxWait);
        boolean wasEnabled = getPoolProperties().isPoolSweeperEnabled();
        getPoolProperties().setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        boolean shouldBeEnabled = getPoolProperties().isPoolSweeperEnabled();
        //make sure pool cleaner starts when it should
        if (!wasEnabled && shouldBeEnabled) pool.initializePoolCleaner(getPoolProperties());
        getPoolProperties().setMinIdle(minIdle);
        getPoolProperties().setNumTestsPerEvictionRun(numTestsPerEvictionRun);
        getPoolProperties().setPassword(password);
        boolean wasEnabled = getPoolProperties().isPoolSweeperEnabled();
        getPoolProperties().setRemoveAbandoned(removeAbandoned);
        boolean shouldBeEnabled = getPoolProperties().isPoolSweeperEnabled();
        //make sure pool cleaner starts when it should
        if (!wasEnabled && shouldBeEnabled) pool.initializePoolCleaner(getPoolProperties());
        boolean wasEnabled = getPoolProperties().isPoolSweeperEnabled();
        getPoolProperties().setRemoveAbandonedTimeout(removeAbandonedTimeout);
        boolean shouldBeEnabled = getPoolProperties().isPoolSweeperEnabled();
        //make sure pool cleaner starts when it should
        if (!wasEnabled && shouldBeEnabled) pool.initializePoolCleaner(getPoolProperties());
        getPoolProperties().setTestOnBorrow(testOnBorrow);
        getPoolProperties().setTestOnConnect(testOnConnect);
        getPoolProperties().setTestOnReturn(testOnReturn);
        boolean wasEnabled = getPoolProperties().isPoolSweeperEnabled();
        getPoolProperties().setTestWhileIdle(testWhileIdle);
        boolean shouldBeEnabled = getPoolProperties().isPoolSweeperEnabled();
        //make sure pool cleaner starts when it should
        if (!wasEnabled && shouldBeEnabled) pool.initializePoolCleaner(getPoolProperties());
        boolean wasEnabled = getPoolProperties().isPoolSweeperEnabled();
        getPoolProperties().setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
        boolean shouldBeEnabled = getPoolProperties().isPoolSweeperEnabled();
        //make sure pool cleaner starts when it should
        if (!wasEnabled && shouldBeEnabled) pool.initializePoolCleaner(getPoolProperties());
        getPoolProperties().setUrl(url);
        getPoolProperties().setUseEquals(useEquals);
        getPoolProperties().setUseLock(useLock);
        getPoolProperties().setUsername(username);
        getPoolProperties().setValidationInterval(validationInterval);
        getPoolProperties().setValidationQuery(validationQuery);
======= 518662f:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        getPoolProperties().setSuspectTimeout(seconds);
======= 518662f:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        getPoolProperties().setDataSourceJNDI(jndiDS);
======= 518662f:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        getPoolProperties().setAlternateUsernameAllowed(alternateUsernameAllowed);
======= 518662f:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

        getPoolProperties().setValidator(validator);

======= 7da5fa9:"java/javax/el/ExpressionFactory.java"

======= 7da5fa9:"java/javax/el/ExpressionFactory.java"

    private static final CacheValue nullTcclFactory = new CacheValue();
    private static ConcurrentMap<CacheKey, CacheValue> factoryCache
        = new ConcurrentHashMap<CacheKey, CacheValue>();
======= 7da5fa9:"java/javax/el/ExpressionFactory.java"

        CacheValue cacheValue;
        Class<?> clazz;
        if (tccl == null) {
            cacheValue = nullTcclFactory;
        } else {
            CacheKey key = new CacheKey(tccl);
            cacheValue = factoryCache.get(key);
            if (cacheValue == null) {
                CacheValue newCacheValue = new CacheValue();
                cacheValue = factoryCache.putIfAbsent(key, newCacheValue);
                if (cacheValue == null) {
                    cacheValue = newCacheValue;
                }
            }
        }
        final Lock readLock = cacheValue.getLock().readLock();
        readLock.lock();
            clazz = cacheValue.getFactoryClass();
        } finally {
            readLock.unlock();
        }
        if (clazz == null) {
            String className = null;
            try {
                final Lock writeLock = cacheValue.getLock().writeLock();
                writeLock.lock();
                try {
                    className = cacheValue.getFactoryClassName();
                    if (className == null) {
                        className = discoverClassName(tccl);
                        cacheValue.setFactoryClassName(className);
                    }
                    if (tccl == null) {
                        clazz = Class.forName(className);
                    } else {
                        clazz = tccl.loadClass(className);
                    }
                    cacheValue.setFactoryClass(clazz);
                } finally {
                    writeLock.unlock();
                }
            } catch (ClassNotFoundException e) {
                throw new ELException(
                    "Unable to find ExpressionFactory of type: " + className,
                    e);
        }
        try {
======= 7da5fa9:"java/javax/el/ExpressionFactory.java"

                    "Unable to create ExpressionFactory of type: " + clazz.getName(),
                    "Unable to create ExpressionFactory of type: " + clazz.getName(),
                    "Unable to create ExpressionFactory of type: " + clazz.getName(),
======= 7da5fa9:"java/javax/el/ExpressionFactory.java"

                    "Unable to create ExpressionFactory of type: " + clazz.getName(),
======= 7da5fa9:"java/javax/el/ExpressionFactory.java"

     * Key used to cache ExpressionFactory discovery information per class
     * loader. The class loader reference is never {@code null}, because
     * {@code null} tccl is handled separately.
     */
    private static class CacheKey {
        private final int hash;
        private final WeakReference<ClassLoader> ref;
        public CacheKey(ClassLoader cl) {
            hash = cl.hashCode();
            ref = new WeakReference<ClassLoader>(cl);
        }
        @Override
        public int hashCode() {
            return hash;
        }
        @Override
        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof CacheKey)) {
                return false;
            }
            ClassLoader thisCl = ref.get();
            if (thisCl == null) {
                return false;
            }
            return thisCl == ((CacheKey) obj).ref.get();
        }
    }
    private static class CacheValue {
        private final ReadWriteLock lock = new ReentrantReadWriteLock();
        private String className;
        private WeakReference<Class<?>> ref;
        public CacheValue() {
        }
        public ReadWriteLock getLock() {
            return lock;
        }
        public String getFactoryClassName() {
            return className;
        }
        public void setFactoryClassName(String className) {
            this.className = className;
        }
        public Class<?> getFactoryClass() {
            return ref != null ? ref.get() : null;
        }
        public void setFactoryClass(Class<?> clazz) {
            ref = new WeakReference<Class<?>>(clazz);
        }
    }
    /**

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void bug53001() {
        ExpressionFactory factory = ExpressionFactory.newInstance();
        ELContext context = new ELContextImpl();
        ResourceBundle rb = new TesterResourceBundle();
        ValueExpression var =
            factory.createValueExpression(rb, ResourceBundle.class);
        context.getVariableMapper().setVariable("rb", var);
        ValueExpression ve = factory.createValueExpression(
                context, "${rb.keys}", String.class);
        MethodExpression me = factory.createMethodExpression(
                context, "${rb.getKeys()}", Enumeration.class, null);
        // Ensure we are specification compliant
        String result1 = (String) ve.getValue(context);
        Assert.assertEquals("???keys???", result1);
        // Check that the method expression does return the keys
        Object result2 = me.invoke(context, null);
        Assert.assertTrue(result2 instanceof Enumeration);
        @SuppressWarnings("unchecked")
        Enumeration<String> e = (Enumeration<String>) result2;
        Assert.assertTrue(e.hasMoreElements());
        Assert.assertEquals("key2", e.nextElement());
        Assert.assertTrue(e.hasMoreElements());
        Assert.assertEquals("key1", e.nextElement());
        Assert.assertFalse(e.hasMoreElements());
    }
    private static class TesterResourceBundle extends ListResourceBundle {
        @Override
        protected Object[][] getContents() {
            return contents;
        }
        private static final Object[][] contents = {
            {"key1","value1"},
            {"key2","value2"}
        };
    }

======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    private static final String SEPARATOR = "/";
======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        Class<?> classClass = null;
            classClass = loadClass(context, applicationListeners[i]);
            if (classClass == null) {
                continue;
            }
            loadClassAnnotation(context, classClass);
            loadFieldsAnnotation(context, classClass);
            loadMethodsAnnotation(context, classClass);
======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        Class<?> classClass = null;
            classClass = loadClass(context, (filterDefs[i]).getFilterClass());
            if (classClass == null) {
                continue;
            }
            loadClassAnnotation(context, classClass);
            loadFieldsAnnotation(context, classClass);
            loadMethodsAnnotation(context, classClass);
======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

                classClass = loadClass(context, wrapper.getServletClass());
                loadClassAnnotation(context, classClass);
                loadFieldsAnnotation(context, classClass);
                loadMethodsAnnotation(context, classClass);
======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    protected static void loadClassAnnotation(Context context,
            Class<?> classClass) {
======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    }
    protected static void loadFieldsAnnotation(Context context,
            Class<?> classClass) {
        // Initialize the annotations
        Field[] fields = getDeclaredFields(classClass);
        if (fields != null && fields.length > 0) {
            for (Field field : fields) {
                if (field.isAnnotationPresent(Resource.class)) {
                    Resource annotation = field.getAnnotation(Resource.class);
                    String defaultName =
                            classClass.getName() + SEPARATOR + field.getName();
                    String defaultType = field.getType().getCanonicalName();
                    addResource(context, annotation, defaultName, defaultType);
                }
            }
        }
    protected static void loadMethodsAnnotation(Context context,
            Class<?> classClass) {
        // Initialize the annotations
        Method[] methods = getDeclaredMethods(classClass);
        if (methods != null && methods.length > 0) {
            for (Method method : methods) {
                if (method.isAnnotationPresent(Resource.class)) {
                    Resource annotation = method.getAnnotation(Resource.class);
                    checkBeanNamingConventions(method);
                    String defaultName = classClass.getName() + SEPARATOR +
                            DefaultInstanceManager.getName(method);
                    String defaultType =
                            (method.getParameterTypes()[0]).getCanonicalName();
                    addResource(context, annotation, defaultName, defaultType);
                }
            }
        }
    }
======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        addResource(context, annotation, null, null);
    }
    protected static void addResource(Context context, Resource annotation,
            String defaultName, String defaultType) {
        String name = getName(annotation, defaultName);
        String type = getType(annotation, defaultType);
        if (type.equals("java.lang.String") ||
                type.equals("java.lang.Character") ||
                type.equals("java.lang.Integer") ||
                type.equals("java.lang.Boolean") ||
                type.equals("java.lang.Double") ||
                type.equals("java.lang.Byte") ||
                type.equals("java.lang.Short") ||
                type.equals("java.lang.Long") ||
                type.equals("java.lang.Float")) {
            resource.setName(name);
            resource.setType(type);
======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        } else if (type.equals("javax.xml.rpc.Service")) {
            service.setName(name);
            service.setType(type);
        } else if (type.equals("javax.sql.DataSource") ||
                type.equals("javax.jms.ConnectionFactory") ||
                type.equals("javax.jms.QueueConnectionFactory") ||
                type.equals("javax.jms.TopicConnectionFactory") ||
                type.equals("javax.mail.Session") ||
                type.equals("java.net.URL") ||
                type.equals("javax.resource.cci.ConnectionFactory") ||
                type.equals("org.omg.CORBA_2_3.ORB") ||
                type.endsWith("ConnectionFactory")) {
            resource.setName(name);
            resource.setType(type);
======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

        } else if (type.equals("javax.jms.Queue") ||
                type.equals("javax.jms.Topic")) {
            resource.setName(name);
            resource.setType(type);
        } else if (type.equals("javax.resource.cci.InteractionSpec") ||
                type.equals("javax.transaction.UserTransaction") ||
            resource.setName(name);
            resource.setType(type);
======= 67a926c:"java/org/apache/catalina/startup/WebAnnotationSet.java"

    }
    private static void checkBeanNamingConventions(Method method) {
        if (!method.getName().startsWith("set")
                || method.getName().length() < 4
                || method.getParameterTypes().length != 1
                || !method.getReturnType().getName().equals("void")) {
            throw new IllegalArgumentException("Invalid method resource injection annotation.");
        }
    private static String getType(Resource annotation, String defaultType) {
        String type = annotation.type().getCanonicalName();
        if (type == null || type.equals("java.lang.Object")) {
            if (defaultType != null) {
                type = defaultType;
            }
        }
        return type;
    }
    private static String getName(Resource annotation, String defaultName) {
        String name = annotation.name();
        if (name == null || name.equals("")) {
            if (defaultName != null) {
                name = defaultName;
            }
        }
        return name;
    }
    private static Field[] getDeclaredFields(Class<?> classClass) {
        Field[] fields = null;
        if (Globals.IS_SECURITY_ENABLED) {
            final Class<?> clazz = classClass;
            fields = AccessController.doPrivileged(
                    new PrivilegedAction<Field[]>(){
                @Override
                public Field[] run(){
                    return clazz.getDeclaredFields();
                }
            });
        } else {
            fields = classClass.getDeclaredFields();
        }
        return fields;
    }
    private static Method[] getDeclaredMethods(Class<?> classClass) {
        Method[] methods = null;
        if (Globals.IS_SECURITY_ENABLED) {
            final Class<?> clazz = classClass;
            methods = AccessController.doPrivileged(
                    new PrivilegedAction<Method[]>(){
                @Override
                public Method[] run(){
                    return clazz.getDeclaredMethods();
                }
            });
        } else {
            methods = classClass.getDeclaredMethods();
        }
        return methods;
    }
    private static Class<?> loadClass(Context context, String fileString) {
        ClassLoader classLoader = context.getLoader().getClassLoader();
        Class<?> classClass = null;
        try {
            classClass = classLoader.loadClass(fileString);
        } catch (ClassNotFoundException e) {
            // We do nothing
        } catch (NoClassDefFoundError e) {
            // We do nothing
        }
        return classClass;
    }

======= 6a8e480:"java/org/apache/catalina/core/StandardServer.java"

            ClassLoader cl = getCatalina().getParentClassLoader();
            while (cl != null && cl != ClassLoader.getSystemClassLoader()) {

    <attribute name="propagateInterruptState" required="false">
      <p>(boolean) Set this to true to propagate the interrupt state for a thread that has been interrupted (not clearing the interrupt state). Default value is <code>false</code> for backwards compatibility.
      </p>
    </attribute>
    
======= fe16ac2:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                if (!getPoolProperties().getPropagateInterruptState()) {
                    Thread.interrupted();
                }
======= fe16ac2:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                if (!getPoolProperties().getPropagateInterruptState()) {
                    Thread.interrupted();
                }
======= fe16ac2:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getPropagateInterruptState() {
        return getPoolProperties().getPropagateInterruptState();
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setPropagateInterruptState(boolean propagateInterruptState) {
        getPoolProperties().setPropagateInterruptState(propagateInterruptState);
    }
======= fe16ac2:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java"

    /**
     * Returns true if the pool is configured to propagate interrupt state of a thread.
     * A thread waiting for a connection, can have its wait interrupted, and by default
     * will clear the interrupt flag and throw a {@link PoolExhaustedException}
     * @return true if the pool is configured to propagate and not clear the thread interrupt state
     */
    public boolean getPropagateInterruptState();
    /**
     * Configure the pool to propagate interrupt state for interrupted threads waiting for a connection
     * A thread waiting for a connection, can have its wait interrupted, and by default
     * will clear the interrupt flag and throw a {@link PoolExhaustedException}
     * If set to true, this behavior will change, while the {@link PoolExhaustedException} is still thrown, the threads interrupted state is still set.
     * @param propagateInterruptState - set to true to not clear, but propagate, a threads interrupted state.
     */
    public void setPropagateInterruptState(boolean propagateInterruptState);
======= fe16ac2:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    protected boolean propagateInterruptState = false;
======= fe16ac2:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getPropagateInterruptState() {
        return propagateInterruptState;
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setPropagateInterruptState(boolean propagateInterruptState) {
        this.propagateInterruptState = propagateInterruptState;
    }
======= fe16ac2:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

======= fe16ac2:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getPropagateInterruptState() {
        return getPoolProperties().getPropagateInterruptState();
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setPropagateInterruptState(boolean propagateInterruptState) {
        getPoolProperties().setPropagateInterruptState(propagateInterruptState);
    }

======= d5cee34:"java/org/apache/catalina/core/StandardPipeline.java"

        if (valve instanceof Lifecycle) {
            // Stop this valve if necessary
            if (getState().isAvailable()) {
            try {
                ((Lifecycle) valve).destroy();
            } catch (LifecycleException e) {
                log.error("StandardPipeline.removeValve: destroy: ", e);
            }

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Test DigestAuthenticator and NonLoginAuthenticator when a
 * SingleSignOn Valve is active.
 *
 * <p>
 * In the absence of SSO support, a webapp using NonLoginAuthenticator
 * simply cannot access protected resources. These tests exercise the
 * the way successfully authenticating a different webapp under the
 * DigestAuthenticator triggers the additional SSO logic for both webapps.
 *
 * <p>
 * Note: these tests are intended to exercise the SSO logic of the
 * Authenticator, but not to comprehensively test all of its logic paths.
 * That is the responsibility of the non-SSO test suite.
 */
    private static final String USER = "user";
    private static final String PWD = "pwd";
    private static final String ROLE = "role";
    private static final String HTTP_PREFIX = "http://localhost:";
    private static final String CONTEXT_PATH_NOLOGIN = "/nologin";
    private static final String CONTEXT_PATH_DIGEST = "/digest";
    private static final String URI_PROTECTED = "/protected";
    private static final String URI_PUBLIC = "/anyoneCanAccess";
    private static final int SHORT_TIMEOUT_SECS = 4;
    private static final long SHORT_TIMEOUT_DELAY_MSECS =
                                    ((SHORT_TIMEOUT_SECS + 3) * 1000);
    private static final int LONG_TIMEOUT_SECS = 10;
    private static final long LONG_TIMEOUT_DELAY_MSECS =
                                    ((LONG_TIMEOUT_SECS + 2) * 1000);
    private static final String CLIENT_AUTH_HEADER = "authorization";
    private static final String OPAQUE = "opaque";
    private static final String NONCE = "nonce";
    private static final String REALM = "realm";
    private static final String CNONCE = "cnonce";
    private static String NC1 = "00000001";
    private static String NC2 = "00000002";
    private static String QOP = "auth";
    private static String SERVER_COOKIES = "Set-Cookie";
    private static String BROWSER_COOKIES = "Cookie";
    private List<String> cookies;
    /**
     * Try to access an unprotected resource without an
     * established SSO session.
     * This should be permitted.
     */
    @Test
    public void testAcceptPublicNonLogin() throws Exception {
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PUBLIC,
                       true, false, 200);
    }
    /*
     * Try to access a protected resource without an established
     * SSO session.
     * This should be rejected with SC_FORBIDDEN 403 status.
     */
    @Test
    public void testRejectProtectedNonLogin() throws Exception {
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                       false, true, 403);
    }
    /**
     * Logon to access a protected resource using DIGEST authentication,
     * which will establish an SSO session.
     * Wait until the SSO session times-out, then try to re-access
     * the resource.
     * This should be rejected with SC_FORBIDDEN 401 status, which
     * will then be followed by successful re-authentication.
     */
    @Test
    public void testDigestLoginSessionTimeout() throws Exception {
        doTestDigest(USER, PWD, CONTEXT_PATH_DIGEST + URI_PROTECTED,
                     true, 401, true, true, NC1, CNONCE, QOP, true);
        // wait long enough for my session to expire
        Thread.sleep(LONG_TIMEOUT_DELAY_MSECS);
        // must change the client nonce to succeed
        doTestDigest(USER, PWD, CONTEXT_PATH_DIGEST + URI_PROTECTED,
                     true, 401, true, true, NC2, CNONCE, QOP, true);
   }
    /*
     * Logon to access a protected resource using DIGEST authentication,
     * which will establish an SSO session.
     * Immediately try to access a protected resource in the NonLogin
     * webapp, but without sending the SSO session cookie.
     * This should be rejected with SC_FORBIDDEN 403 status.
     */
    @Test
    public void testDigestLoginRejectProtectedWithoutCookies() throws Exception {
        doTestDigest(USER, PWD, CONTEXT_PATH_DIGEST + URI_PROTECTED,
                     true, 401, true, true, NC1, CNONCE, QOP, true);
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                       false, true, 403);
    }
    /*
     * Logon to access a protected resource using DIGEST authentication,
     * which will establish an SSO session.
     * Immediately try to access a protected resource in the NonLogin
     * webapp while sending the SSO session cookie provided by the
     * first webapp.
     * This should be successful with SC_OK 200 status.
     */
    @Test
    public void testDigestLoginAcceptProtectedWithCookies() throws Exception {
        doTestDigest(USER, PWD, CONTEXT_PATH_DIGEST + URI_PROTECTED,
                true, 401, true, true, NC1, CNONCE, QOP, true);
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                        true, false, 200);
    }
    /*
     * Logon to access a protected resource using DIGEST authentication,
     * which will establish an SSO session.
     * Immediately try to access a protected resource in the NonLogin
     * webapp while sending the SSO session cookie provided by the
     * first webapp.
     * This should be successful with SC_OK 200 status.
     *
     * Then, wait long enough for the DIGEST session to expire. (The SSO
     * session should remain active because the NonLogin session has
     * not yet expired).
     *
     * Try to access the protected resource again, before the SSO session
     * has expired.
     * This should be successful with SC_OK 200 status.
     *
     * Finally, wait for the non-login session to expire and try again..
     * This should be rejected with SC_FORBIDDEN 403 status.
     *
     * (see bugfix https://issues.apache.org/bugzilla/show_bug.cgi?id=52303)
     */
    @Test
    public void testDigestExpiredAcceptProtectedWithCookies() throws Exception {
        doTestDigest(USER, PWD, CONTEXT_PATH_DIGEST + URI_PROTECTED,
                true, 401, true, true, NC1, CNONCE, QOP, true);
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                        true, false, 200);
        // wait long enough for the BASIC session to expire,
        // but not long enough for NonLogin session expiry
        Thread.sleep(SHORT_TIMEOUT_DELAY_MSECS);
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                        true, false, 200);
        // wait long enough for my NonLogin session to expire
        // and tear down the SSO session at the same time.
        Thread.sleep(LONG_TIMEOUT_DELAY_MSECS);
        doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED,
                        false, true, 403);
    }
    public void doTestNonLogin(String uri, boolean addCookies,
            boolean expectedReject, int expectedRC)
            throws Exception {
        Map<String,List<String>> reqHeaders =
                new HashMap<String,List<String>>();
        Map<String,List<String>> respHeaders =
                new HashMap<String,List<String>>();
        ByteChunk bc = new ByteChunk();
        if (addCookies) {
            addCookies(reqHeaders);
        }
        int rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders,
                respHeaders);
        if (expectedReject) {
            assertEquals(expectedRC, rc);
            assertTrue(bc.getLength() > 0);
        }
        else {
            assertEquals(200, rc);
            assertEquals("OK", bc.toString());
            saveCookies(respHeaders);
        }
    public void doTestDigest(String user, String pwd, String uri,
            boolean expectedReject1, int expectedRC1,
            boolean useServerNonce, boolean useServerOpaque,
            String nc1, String cnonce,
            String qop, boolean req2expect200)
            throws Exception {
        String digestUri= uri;
        List<String> auth = new ArrayList<String>();
        Map<String,List<String>> reqHeaders1 =
                new HashMap<String,List<String>>();
        Map<String,List<String>> respHeaders1 =
                new HashMap<String,List<String>>();
        // the first access attempt should be challenged
        auth.add(buildDigestResponse(user, pwd, digestUri, REALM, "null",
                "null", nc1, cnonce, qop));
        reqHeaders1.put(CLIENT_AUTH_HEADER, auth);
        ByteChunk bc = new ByteChunk();
        int rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders1,
                respHeaders1);
        if (expectedReject1) {
            assertEquals(expectedRC1, rc);
            assertTrue(bc.getLength() > 0);
        }
        else {
            assertEquals(200, rc);
            assertEquals("OK", bc.toString());
            saveCookies(respHeaders1);
            return;
        }
        // Second request should succeed (if we use the server nonce)
        Map<String,List<String>> reqHeaders2 =
                new HashMap<String,List<String>>();
        Map<String,List<String>> respHeaders2 =
                new HashMap<String,List<String>>();
        auth.clear();
        if (useServerNonce) {
            if (useServerOpaque) {
                auth.add(buildDigestResponse(user, pwd, digestUri,
                        getAuthToken(respHeaders1, REALM),
                        getAuthToken(respHeaders1, NONCE),
                        getAuthToken(respHeaders1, OPAQUE),
                        nc1, cnonce, qop));
            } else {
                auth.add(buildDigestResponse(user, pwd, digestUri,
                        getAuthToken(respHeaders1, REALM),
                        getAuthToken(respHeaders1, NONCE),
                        "null", nc1, cnonce, qop));
            }
        } else {
            auth.add(buildDigestResponse(user, pwd, digestUri,
                    getAuthToken(respHeaders2, REALM),
                    "null", getAuthToken(respHeaders1, OPAQUE),
                    nc1, cnonce, QOP));
        }
        reqHeaders2.put(CLIENT_AUTH_HEADER, auth);
        bc.recycle();
        rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders2,
                respHeaders2);
        if (req2expect200) {
            assertEquals(200, rc);
            assertEquals("OK", bc.toString());
            saveCookies(respHeaders2);
        } else {
            assertEquals(401, rc);
            assertTrue((bc.getLength() > 0));
        }
    }
    @Override
    public void setUp() throws Exception {
        super.setUp();
        // create a tomcat server using the default in-memory Realm
        Tomcat tomcat = getTomcatInstance();
        // associate the SingeSignOn Valve before the Contexts
        SingleSignOn sso = new SingleSignOn();
        tomcat.getHost().getPipeline().addValve(sso);
        // add the test user and role to the Realm
        tomcat.addUser(USER, PWD);
        tomcat.addRole(USER, ROLE);
        // setup both NonLogin, Login and digest webapps
        setUpNonLogin(tomcat);
        setUpDigest(tomcat);
        tomcat.start();
    }
    private void setUpNonLogin(Tomcat tomcat) throws Exception {
        // Must have a real docBase for webapps - just use temp
        Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN,
                System.getProperty("java.io.tmpdir"));
        ctxt.setSessionTimeout(LONG_TIMEOUT_SECS);
        // Add protected servlet
        Tomcat.addServlet(ctxt, "TesterServlet1", new TesterServlet());
        ctxt.addServletMapping(URI_PROTECTED, "TesterServlet1");
        SecurityCollection collection1 = new SecurityCollection();
        collection1.addPattern(URI_PROTECTED);
        SecurityConstraint sc1 = new SecurityConstraint();
        sc1.addAuthRole(ROLE);
        sc1.addCollection(collection1);
        ctxt.addConstraint(sc1);
        // Add unprotected servlet
        Tomcat.addServlet(ctxt, "TesterServlet2", new TesterServlet());
        ctxt.addServletMapping(URI_PUBLIC, "TesterServlet2");
        SecurityCollection collection2 = new SecurityCollection();
        collection2.addPattern(URI_PUBLIC);
        SecurityConstraint sc2 = new SecurityConstraint();
        // do not add a role - which signals access permitted without one
        sc2.addCollection(collection2);
        ctxt.addConstraint(sc2);
        // Configure the appropriate authenticator
        LoginConfig lc = new LoginConfig();
        lc.setAuthMethod("NONE");
        ctxt.setLoginConfig(lc);
        ctxt.getPipeline().addValve(new NonLoginAuthenticator());
    }
    private void setUpDigest(Tomcat tomcat) throws Exception {
        // Must have a real docBase for webapps - just use temp
        Context ctxt = tomcat.addContext(CONTEXT_PATH_DIGEST,
                System.getProperty("java.io.tmpdir"));
        ctxt.setSessionTimeout(SHORT_TIMEOUT_SECS);
        // Add protected servlet
        Tomcat.addServlet(ctxt, "TesterServlet3", new TesterServlet());
        ctxt.addServletMapping(URI_PROTECTED, "TesterServlet3");
        SecurityCollection collection = new SecurityCollection();
        collection.addPattern(URI_PROTECTED);
        SecurityConstraint sc = new SecurityConstraint();
        sc.addAuthRole(ROLE);
        sc.addCollection(collection);
        ctxt.addConstraint(sc);
        // Configure the appropriate authenticator
        LoginConfig lc = new LoginConfig();
        lc.setAuthMethod("DIGEST");
        ctxt.setLoginConfig(lc);
        ctxt.getPipeline().addValve(new DigestAuthenticator());
    }
    protected static String getAuthToken(
            Map<String,List<String>> respHeaders, String token) {
        final String AUTH_PREFIX = "=\"";
        final String AUTH_SUFFIX = "\"";
        List<String> authHeaders =
            respHeaders.get(AuthenticatorBase.AUTH_HEADER_NAME);
        // Assume there is only one
        String authHeader = authHeaders.iterator().next();
        String searchFor = token + AUTH_PREFIX;
        int start = authHeader.indexOf(searchFor) + searchFor.length();
        int end = authHeader.indexOf(AUTH_SUFFIX, start);
        return authHeader.substring(start, end);
    }
    /*
     * Notes from RFC2617
     * H(data) = MD5(data)
     * KD(secret, data) = H(concat(secret, ":", data))
     * A1 = unq(username-value) ":" unq(realm-value) ":" passwd
     * A2 = Method ":" digest-uri-value
     * request-digest  = <"> < KD ( H(A1),     unq(nonce-value)
                                    ":" nc-value
                                    ":" unq(cnonce-value)
                                    ":" unq(qop-value)
                                    ":" H(A2)
                                   ) <">
     */
    private static String buildDigestResponse(String user, String pwd,
            String uri, String realm, String nonce, String opaque, String nc,
            String cnonce, String qop) throws NoSuchAlgorithmException {
        String a1 = user + ":" + realm + ":" + pwd;
        String a2 = "GET:" + uri;
        String md5a1 = digest(a1);
        String md5a2 = digest(a2);
        String response;
        if (qop == null) {
            response = md5a1 + ":" + nonce + ":" + md5a2;
        } else {
            response = md5a1 + ":" + nonce + ":" + nc + ":" + cnonce + ":" +
                    qop + ":" + md5a2;
        }
        String md5response = digest(response);
        StringBuilder auth = new StringBuilder();
        auth.append("Digest username=\"");
        auth.append(user);
        auth.append("\", realm=\"");
        auth.append(realm);
        auth.append("\", nonce=\"");
        auth.append(nonce);
        auth.append("\", uri=\"");
        auth.append(uri);
        auth.append("\", opaque=\"");
        auth.append(opaque);
        auth.append("\", response=\"");
        auth.append(md5response);
        auth.append("\"");
        if (qop != null) {
            auth.append(", qop=\"");
            auth.append(qop);
            auth.append("\"");
        }
        if (nc != null) {
            auth.append(", nc=\"");
            auth.append(nc);
            auth.append("\"");
        }
        if (cnonce != null) {
            auth.append(", cnonce=\"");
            auth.append(cnonce);
            auth.append("\"");
        }
        return auth.toString();
    }
    private static String digest(String input) throws NoSuchAlgorithmException {
        // This is slow but should be OK as this is only a test
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        MD5Encoder encoder = new MD5Encoder();
        md5.update(input.getBytes());
        return encoder.encode(md5.digest());
    }
    /*
     * extract and save the server cookies from the incoming response
     */
    protected void saveCookies(Map<String,List<String>> respHeaders) {
        // we only save the Cookie values, not header prefix
        cookies = respHeaders.get(SERVER_COOKIES);
    }
    /*
     * add all saved cookies to the outgoing request
     */
    protected void addCookies(Map<String,List<String>> reqHeaders) {
        if ((cookies != null) && (cookies.size() > 0)) {
            reqHeaders.put(BROWSER_COOKIES + ":", cookies);
        }
    }

======= e092870:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public void setLogValidationErrors(boolean logValidationErrors) {
        getPoolProperties().setLogValidationErrors(logValidationErrors);
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getLogValidationErrors() {
        return getPoolProperties().getLogValidationErrors();
    }
======= e092870:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java"

    /**
     * Set to true if you wish that errors from validation should be logged as error messages.
     * @param logValidationErrors set to true to log validation errors
     */
    public void setLogValidationErrors(boolean logValidationErrors);
    /**
     * Returns true if errors that happen during validation will be logged
     * @return true if errors that happen during validation will be logged
     */
    public boolean getLogValidationErrors();
======= e092870:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    protected boolean useDisposableConnectionFacade = false;
    protected boolean logValidationErrors = false;
======= e092870:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public void setLogValidationErrors(boolean logValidationErrors) {
        this.logValidationErrors = logValidationErrors;
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getLogValidationErrors() {
        return this.logValidationErrors;
    }
======= e092870:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

                if (getPoolProperties().getLogValidationErrors()) {
                    log.error("Custom validation through "+poolProperties.getValidator()+" failed.");
                }
======= e092870:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        } catch (Exception ex) {
            if (getPoolProperties().getLogValidationErrors()) {
                log.warn("SQL Validation error", ex);
            } else if (log.isDebugEnabled()) {
                log.debug("Unable to validate object:",ex);
            }
======= e092870:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    /**
     * {@inheritDoc}
     */
    @Override
    public void setLogValidationErrors(boolean logValidationErrors) {
        getPoolProperties().setLogValidationErrors(logValidationErrors);
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public boolean getLogValidationErrors() {
        return getPoolProperties().getLogValidationErrors();
    }

======= 9d687eb:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                if (jmxPool!=null) {
                    jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.POOL_EMPTY, "Pool empty - no wait.");
                }
                throw new PoolExhaustedException("[" + Thread.currentThread().getName()+"] " +
                    if (jmxPool!=null) {
                        jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.POOL_EMPTY, "Pool empty - timeout.");
                    }
                    throw new PoolExhaustedException("[" + Thread.currentThread().getName()+"] " +
======= 9d687eb:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    public PoolExhaustedException() {
    }
    public PoolExhaustedException(String reason) {
        super(reason);
    }
    public PoolExhaustedException(Throwable cause) {
        super(cause);
    }
    public PoolExhaustedException(String reason, String SQLState) {
        super(reason, SQLState);
    }
    public PoolExhaustedException(String reason, Throwable cause) {
        super(reason, cause);
    }
    public PoolExhaustedException(String reason, String SQLState, int vendorCode) {
        super(reason, SQLState, vendorCode);
    }
    public PoolExhaustedException(String reason, String sqlState, Throwable cause) {
        super(reason, sqlState, cause);
    }
    public PoolExhaustedException(String reason, String sqlState, int vendorCode, Throwable cause) {
        super(reason, sqlState, vendorCode, cause);
    }
======= 9d687eb:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    public static final String POOL_EMPTY = "POOL EMPTY";

======= 0eb38b8:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java"

            if (log.isWarnEnabled()) {
                log.warn("Failed Query Report SQL="+sql+"; time="+delta+" ms;");
            }
======= 0eb38b8:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java"

            if (log.isWarnEnabled()) {
                log.warn("Slow Query Report SQL="+sql+"; time="+delta+" ms;");
            }

======= dcb8808:"java/org/apache/tomcat/util/net/NioEndpoint.java"

            if (attachment == null) {
                return false;
            }

======= 9f8c8d6:"java/org/apache/catalina/session/StandardManager.java"

        BufferedOutputStream bos = null;
        boolean error = false;
            bos = new BufferedOutputStream(fos);
            oos = new ObjectOutputStream(bos);
            error = true;
            throw e;
        } finally {
            if (error) {
                if (oos != null) {
                    try {
                        oos.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }
                }
                if (bos != null) {
                    try {
                        bos.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }
                }
                if (fos != null) {
                    try {
                        fos.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }

======= adbf442:"java/org/apache/catalina/loader/WebappClassLoader.java"

======= adbf442:"java/org/apache/catalina/loader/WebappClassLoader.java"

                    if (thread.getClass().getName().startsWith("java.util.Timer") &&
======= adbf442:"java/org/apache/catalina/loader/WebappClassLoader.java"

                        Field targetField = null;
                        try {
                            targetField = thread.getClass().getDeclaredField("target");
                        }catch (NoSuchFieldException nfe){
                            targetField = thread.getClass().getDeclaredField("runnable");
                        }
                        if (null != targetField){
                            targetField.setAccessible(true);
                            Object target = targetField.get(thread);
                            if (target != null &&
                                    target.getClass().getCanonicalName() != null
                                    && target.getClass().getCanonicalName().equals(
                                    "java.util.concurrent.ThreadPoolExecutor.Worker")) {
                                Field executorField =
                                    target.getClass().getDeclaredField("this$0");
                                executorField.setAccessible(true);
                                Object executor = executorField.get(target);
                                if (executor instanceof ThreadPoolExecutor) {
                                    ((ThreadPoolExecutor) executor).shutdownNow();
                                }
======= adbf442:"java/org/apache/catalina/loader/WebappClassLoader.java"

            try {
                Field newTasksMayBeScheduledField =
                    thread.getClass().getDeclaredField("newTasksMayBeScheduled");
                newTasksMayBeScheduledField.setAccessible(true);
                Field queueField = thread.getClass().getDeclaredField("queue");
                queueField.setAccessible(true);
                Object queue = queueField.get(thread);
                Method clearMethod = queue.getClass().getDeclaredMethod("clear");
                clearMethod.setAccessible(true);
                synchronized(queue) {
                    newTasksMayBeScheduledField.setBoolean(thread, false);
                    clearMethod.invoke(queue);
                    queue.notify();  // In case queue was already empty.
                }
            }catch (NoSuchFieldException nfe){
                Method cancelMethod = thread.getClass().getDeclaredMethod("cancel");
                if (null != cancelMethod){
                    synchronized(thread) {
                        cancelMethod.setAccessible(true);
                        cancelMethod.invoke(thread);
                    }
                }
======= adbf442:"java/org/apache/catalina/loader/WebappClassLoader.java"

            Class<?> tlmClass = Class.forName("java.lang.ThreadLocal$ThreadLocalMap");
            Method expungeStaleEntriesMethod = tlmClass.getDeclaredMethod("expungeStaleEntries");
            expungeStaleEntriesMethod.setAccessible(true);
                    if (null != threadLocalMap){
                        expungeStaleEntriesMethod.invoke(threadLocalMap);
                        checkThreadLocalMapForLeaks(threadLocalMap, tableField);
                    }
                    threadLocalMap =inheritableThreadLocalsField.get(threads[i]);
                    if (null != threadLocalMap){
                        expungeStaleEntriesMethod.invoke(threadLocalMap);
                        checkThreadLocalMapForLeaks(threadLocalMap, tableField);
                    }
======= adbf442:"java/org/apache/catalina/loader/WebappClassLoader.java"

        } catch (InvocationTargetException e) {
            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                    contextName), e);
        } catch (NoSuchMethodException e) {
            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                    contextName), e);
======= adbf442:"java/org/apache/catalina/loader/WebappClassLoader.java"

            if (cl == this) {
======= adbf442:"java/org/apache/catalina/loader/WebappClassLoader.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testTimerThreadLeak() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        if (ctx instanceof StandardContext) {
            ((StandardContext) ctx).setClearReferencesStopThreads(true);
        }
        Tomcat.addServlet(ctx, "taskServlet", new ExecutorServlet());
        ctx.addServletMapping("/", "taskServlet");
        tomcat.start();
        // This will trigger the timer & thread creation
        getUrl("http://localhost:" + getPort() + "/");
        // Stop the context
        ctx.stop();
        // If the thread still exists, we have a thread/memory leak
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ie) {
            // ignore
        }
        Assert.assertTrue(ExecutorServlet.tpe.isShutdown());
        Assert.assertTrue(ExecutorServlet.tpe.isTerminated());
    }
    static class ExecutorServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        int nTasks = 5;
        long n = 1000L;
        int tpSize = 10;
        public static ThreadPoolExecutor tpe;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            resp.getWriter().println(
                    "The current thread served " + this + " servlet");
            tpe = new ThreadPoolExecutor(tpSize, tpSize, 50000L,
                    TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
            Task[] tasks = new Task[nTasks];
            for (int i = 0; i < nTasks; i++) {
                tasks[i] = new Task("Task " + i);
                tpe.execute(tasks[i]);
            }
            resp.getWriter().println("Started " + nTasks +
                    " never ending tasks using the ThreadPoolExecutor");
            resp.getWriter().flush();
        }
        class Task implements Runnable {
            String _id;
            public Task(String id) {
                this._id = id;
            }
            @Override
            public void run() {
                try {
                    while (!Thread.currentThread().isInterrupted()) {
                        Thread.sleep(20000);
                        System.out.println(Thread.currentThread().getClass()
                                + " [" + Thread.currentThread().getName()
                                + "] executing " + this._id);
                    }
                } catch (InterruptedException e) {
                    System.out.println(Thread.currentThread().getClass() + " ["
                            + Thread.currentThread().getName() + "] EXITING");
                }
            }
        }
    }
======= adbf442:"java/org/apache/catalina/loader/WebappClassLoader.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    @Test
    public void testThreadLocalLeak() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
        Context ctx = tomcat.addContext("",
                System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctx, "leakServlet", new LeakingServlet());
        ctx.addServletMapping("/leak1", "leakServlet");
        Tomcat.addServlet(ctx, "leakServlet2", new LeakingServlet2());
        ctx.addServletMapping("/leak2", "leakServlet2");
        tomcat.start();
        // This will trigger the timer & thread creation
        ByteChunk chunk = getUrl("http://localhost:" + getPort() + "/leak1");
        System.out.print("First Threadlocal test response " + chunk.toString());
        chunk = getUrl("http://localhost:" + getPort() + "/leak2");
        System.out
                .print("Second Threadlocal test response " + chunk.toString());
        // Stop the context
        ctx.stop();
        // If the thread still exists, we have a thread/memory leak
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ie) {
            // ignore
        }
    }
    class LeakingServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private ThreadLocal<MyCounter> myThreadLocal = new ThreadLocal<MyCounter>();
        @Override
        protected void doGet(HttpServletRequest request,
                HttpServletResponse response) throws ServletException,
                IOException {
            MyCounter counter = myThreadLocal.get();
            if (counter == null) {
                counter = new MyCounter();
                myThreadLocal.set(counter);
            }
            response.getWriter().println(
                    "The current thread served this servlet "
                            + counter.getCount() + " times");
            counter.increment();
        }
        @Override
        public void destroy() {
            super.destroy();
            // normally not needed, just to make my point
            myThreadLocal = null;
        }
    }
    class LeakingServlet2 extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest request,
                HttpServletResponse response) throws ServletException,
                IOException {
            List<MyCounter> counterList = ThreadScopedHolder.getFromHolder();
            MyCounter counter;
            if (counterList == null) {
                counter = new MyCounter();
                ThreadScopedHolder.saveInHolder(Arrays.asList(counter));
            } else {
                counter = counterList.get(0);
            }
            response.getWriter().println(
                    "The current thread served this servlet "
                            + counter.getCount() + " times");
            counter.increment();
        }
    }
    static class ThreadScopedHolder {
        private final static ThreadLocal<List<MyCounter>> threadLocal =
                new ThreadLocal<List<MyCounter>>();
        public static void saveInHolder(List<MyCounter> o) {
            threadLocal.set(o);
        }
        public static List<MyCounter> getFromHolder() {
            return threadLocal.get();
        }
    }
    class MyCounter {
        private int count = 0;
        public void increment() {
            count++;
        }
        public int getCount() {
            return count;
        }
    }

======= faf26da:"java/org/apache/jasper/compiler/Generator.java"

======= faf26da:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("Object _jspx_saved_JspContext = this.jspContext.getELContext().getContext(javax.servlet.jsp.JspContext.class);");
======= faf26da:"java/org/apache/jasper/compiler/Generator.java"

            // restore nested JspContext on ELContext
            out.printil("jspContext.getELContext().putContext(javax.servlet.jsp.JspContext.class,_jspx_saved_JspContext);");

======= 401c703:"java/org/apache/catalina/realm/RealmBase.java"

    /**
     * The name of the class to use for retrieving user names from X509
     * certificates.
     */
    protected String x509UsernameRetrieverClassName;
    /**
     * The object that will extract user names from X509 client certificates.
     */
    protected X509UsernameRetriever x509UsernameRetriever;
======= 401c703:"java/org/apache/catalina/realm/RealmBase.java"

    /**
     * Gets the name of the class that will be used to extract user names
     * from X509 client certificates.
     * @return The name of the class that will be used to extract user names
     *         from X509 client certificates.
     */
    public String getX509UsernameRetrieverClassName()
    {
        return x509UsernameRetrieverClassName;
    }
    /**
     * Sets the name of the class that will be used to extract user names
     * from X509 client certificates. The class must implement
     * {@see X509UsernameRetriever}.
     *
     * @param className The name of the class that will be used to extract user names
     *                  from X509 client certificates.
     */
    public void setX509UsernameRetrieverClassName(String className)
    {
        this.x509UsernameRetrieverClassName = className;
    }
======= 401c703:"java/org/apache/catalina/realm/RealmBase.java"

        
        x509UsernameRetriever = createUsernameRetriever(x509UsernameRetrieverClassName);
======= 401c703:"java/org/apache/catalina/realm/RealmBase.java"

        String username = x509UsernameRetriever.getUsername(usercert);
        if(log.isDebugEnabled())
            log.debug(sm.getString("realmBase.gotX509Username", username));
        return(getPrincipal(username));
======= 401c703:"java/org/apache/catalina/realm/RealmBase.java"

    private static X509UsernameRetriever createUsernameRetriever(String className)
        throws LifecycleException {
        if(null == className || "".equals(className.trim()))
            return new X509SubjectDnRetriever();
        try {
            @SuppressWarnings("unchecked")
            Class<? extends X509UsernameRetriever> clazz = (Class<? extends X509UsernameRetriever>)Class.forName(className);
            return (X509UsernameRetriever)clazz.newInstance();
        } catch (ClassNotFoundException e) {
            throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.ClassNotFoundException", className), e);
        } catch (InstantiationException e) {
            throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.InstantiationException", className), e);
        } catch (IllegalAccessException e) {
            throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.IllegalAccessException", className), e);
        } catch (ClassCastException e) {
            throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.ClassCastException", className), e);
        }
    }
======= 401c703:"java/org/apache/catalina/realm/RealmBase.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * An X509UsernameRetriever that returns a certificate's entire
 * SubjectDN as the username.
 */
    implements X509UsernameRetriever {
    public String getUsername(X509Certificate clientCert) {
        return clientCert.getSubjectDN().getName();
    }
======= 401c703:"java/org/apache/catalina/realm/RealmBase.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Provides an interface for retrieving a user name from an X509Certificate.
 */
    /**
     * Gets a user name from an X509Certificate.
     *
     * @param cert The certificate containing the user name.
     * @return An appropriate user name obtained from one or more fields
     *         in the certificate.
     */
    public String getUsername(X509Certificate clientCert);
      <attribute name="X509UsernameRetrieverClassName" required="false">
        <p>When using X509 client certificates, this specifies the class name
        that will be used to retrieve the user name from the certificate.
        The class must implement the
        <code>org.apache.catalina.realm.X509UsernameRetriever</code>
        interface. The default is to use the certificate's SubjectDN
        as the username.</p>
      </attribute>
      <attribute name="X509UsernameRetrieverClassName" required="false">
        <p>When using X509 client certificates, this specifies the class name
        that will be used to retrieve the user name from the certificate.
        The class must implement the
        <code>org.apache.catalina.realm.X509UsernameRetriever</code>
        interface. The default is to use the certificate's SubjectDN
        as the username.</p>
      </attribute>
      <attribute name="X509UsernameRetrieverClassName" required="false">
        <p>When using X509 client certificates, this specifies the class name
        that will be used to retrieve the user name from the certificate.
        The class must implement the
        <code>org.apache.catalina.realm.X509UsernameRetriever</code>
        interface. The default is to use the certificate's SubjectDN
        as the username.</p>
      </attribute>
      <attribute name="X509UsernameRetrieverClassName" required="false">
        <p>When using X509 client certificates, this specifies the class name
        that will be used to retrieve the user name from the certificate.
        The class must implement the
        <code>org.apache.catalina.realm.X509UsernameRetriever</code>
        interface. The default is to use the certificate's SubjectDN
        as the username.</p>
      </attribute>
      <attribute name="X509UsernameRetrieverClassName" required="false">
        <p>When using X509 client certificates, this specifies the class name
        that will be used to retrieve the user name from the certificate.
        The class must implement the
        <code>org.apache.catalina.realm.X509UsernameRetriever</code>
        interface. The default is to use the certificate's SubjectDN
        as the username.</p>
      </attribute>
      <attribute name="X509UsernameRetrieverClassName" required="false">
        <p>When using X509 client certificates, this specifies the class name
        that will be used to retrieve the user name from the certificate.
        The class must implement the
        <code>org.apache.catalina.realm.X509UsernameRetriever</code>
        interface. The default is to use the certificate's SubjectDN
        as the username.</p>
      </attribute>

======= 78c02a7:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * @param file  The JAR file to be checked
    protected boolean validateJarFile(File file)
        JarFile jarFile = null;
        try {
            jarFile = new JarFile(file);
            for (int i = 0; i < triggers.length; i++) {
                Class<?> clazz = null;
                try {
                    if (parent != null) {
                        clazz = parent.loadClass(triggers[i]);
                    } else {
                        clazz = Class.forName(triggers[i]);
                    }
                } catch (Exception e) {
                    clazz = null;
                }
                if (clazz == null)
                    continue;
                String name = triggers[i].replace('.', '/') + ".class";
                if (log.isDebugEnabled())
                    log.debug(" Checking for " + name);
                JarEntry jarEntry = jarFile.getJarEntry(name);
                if (jarEntry != null) {
                    log.info("validateJarFile(" + file +
                        ") - jar not loaded. See Servlet Spec 2.3, "
                        + "section 9.7.2. Offending class: " + name);
                    return false;
            return true;
        } finally {
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException ioe) {
                    // Ignore
                }

======= 7cec4ff:"java/org/apache/naming/NamingContext.java"

                (sm.getString("namingContext.nameNotBound", name, name.get(0)));
======= 7cec4ff:"java/org/apache/naming/NamingContext.java"

                (sm.getString("namingContext.nameNotBound", name, name.get(0)));
======= 7cec4ff:"java/org/apache/naming/NamingContext.java"

                (sm.getString("namingContext.nameNotBound", name, name.get(0)));
======= 7cec4ff:"java/org/apache/naming/NamingContext.java"

                (sm.getString("namingContext.nameNotBound", name, name.get(0)));
======= 7cec4ff:"java/org/apache/naming/NamingContext.java"

                (sm.getString("namingContext.nameNotBound", name, name.get(0)));
======= 7cec4ff:"java/org/apache/naming/NamingContext.java"

                throw new NameNotFoundException(sm.getString(
                        "namingContext.nameNotBound", name, name.get(0)));

======= 35958df:"java/org/apache/jasper/JspC.java"

            File uriRootF = new File(uriRoot);
            if (!uriRootF.isDirectory()) {
                throw new JasperException(
                    Localizer.getMessage("jsp.error.jspc.uriroot_not_dir"));
            }
            if(context == null) {
                scanFiles(uriRootF);

======= 4f75b2d:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"

                    if (writeTimeout < 0) {
                        att.awaitWriteLatch(Long.MAX_VALUE,TimeUnit.MILLISECONDS);
                    } else {
                        att.awaitWriteLatch(writeTimeout,TimeUnit.MILLISECONDS);
                    }

======= 1f4663d:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

 * When Tomcat is started, a database connection is created and used for all the
 * log activity. When Tomcat is shutdown, the database connection is closed.
======= 1f4663d:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

      <fix>
        <bug>52767</bug>: Remove reference to MySQL specific autoReconnect
        property in <code>JDBCAccessLogValve</code>. (markt)
      </fix>

======= a01418d:"java/org/apache/catalina/authenticator/NonLoginAuthenticator.java"

        Principal principal = request.getPrincipal();

======= 6399c83:"java/javax/el/ExpressionFactory.java"

            InputStreamReader isr = null;
                isr = new InputStreamReader(is, "UTF-8");
                br = new BufferedReader(isr);
======= 6399c83:"java/javax/el/ExpressionFactory.java"

                    if (isr != null) {
                        isr.close();
                    }
                } catch (IOException ioe) {/*Ignore*/}
                try {

======= 2b1d195:"java/org/apache/jasper/compiler/JDTCompiler.java"

                InputStreamReader isr = null;
                    isr = new InputStreamReader(is,
                            ctxt.getOptions().getJavaEncoding());
                    reader = new BufferedReader(isr);
======= 2b1d195:"java/org/apache/jasper/compiler/JDTCompiler.java"

                    if (isr != null) {
                        try {
                            isr.close();
                        } catch (IOException ioe) {/*Ignore*/}
                    }

======= 683d5c1:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                CometEventImpl cometEvent = request.getEvent();
                } finally {
                    try {
                        cometEvent.close();
                    } catch (IOException e) {
                        container.getLogger().warn(sm.getString(
                                "cometConnectionManagerValve.event"), e);
                    }

======= 8293a6e:"java/org/apache/catalina/startup/HostConfig.java"

        FileOutputStream fos = null;
======= 8293a6e:"java/org/apache/catalina/startup/HostConfig.java"

                    fos = new FileOutputStream(xml);
                    ostream = new BufferedOutputStream(fos, 1024);
======= 8293a6e:"java/org/apache/catalina/startup/HostConfig.java"

======= 8293a6e:"java/org/apache/catalina/startup/HostConfig.java"

                    } catch (IOException ioe) {
                        // Ignore
                if (fos != null) {
                    try {
                        fos.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }
                    fos = null;
                }
                    } catch (IOException ioe) {
                        // Ignore
======= 8293a6e:"java/org/apache/catalina/startup/HostConfig.java"

                    } catch (IOException ioe) {
                        // Ignore;

======= a30ce07:"java/org/apache/catalina/users/MemoryUserDatabase.java"

======= a30ce07:"java/org/apache/catalina/users/MemoryUserDatabase.java"

======= a30ce07:"java/org/apache/catalina/users/MemoryUserDatabase.java"

======= a30ce07:"java/org/apache/catalina/users/MemoryUserDatabase.java"

======= a30ce07:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                FileInputStream fis = null;
                    fis =  new FileInputStream(file);
                } finally {
                    if (fis != null) {
                        try {
                            fis.close();
                        } catch (IOException ioe) {
                            // Ignore
                        }

======= bf0287e:"java/org/apache/jasper/compiler/JspUtil.java"

======= bf0287e:"java/org/apache/jasper/compiler/JspUtil.java"

            className = Constants.TAG_FILE_PACKAGE_NAME + ".web";
======= bf0287e:"java/org/apache/jasper/compiler/JspUtil.java"

        StringBuilder base =
                new StringBuilder(Constants.TAG_FILE_PACKAGE_NAME + ".meta.");

======= 7c51f61:"java/org/apache/catalina/startup/Catalina.java"

            FileInputStream fis = null;
                fis = new FileInputStream(file);
            } finally {
                if (fis != null) {
                    try {
                        fis.close();
                    } catch (IOException e) {
                        // Ignore
                    }
                }
======= 7c51f61:"java/org/apache/catalina/startup/Catalina.java"

        if (s.getPort()>0) {
            Socket socket = null;
            OutputStream stream = null;
            try {
                socket = new Socket(s.getAddress(), s.getPort());
                stream = socket.getOutputStream();
            } catch (IOException e) {
                log.error("Catalina.stop: ", e);
            } finally {
                if (stream != null) {
                    try {
                        stream.close();
                    } catch (IOException e) {
                        // Ignore
                    }
                }
                if (socket != null) {
                    try {
                        socket.close();
                    } catch (IOException e) {
                        // Ignore
                    }
                }
        } else {
            log.error(sm.getString("catalina.stopServer"));
======= 7c51f61:"java/org/apache/catalina/startup/Catalina.java"

======= 7c51f61:"java/org/apache/catalina/startup/Catalina.java"

        } finally {
            try {
                inputStream.close();
            } catch (IOException e) {
                // Ignore
            }

======= 55baca6:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

======= 55baca6:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"


======= 833e6b1:"java/org/apache/catalina/filters/ExpiresFilter.java"

 *          &lt;param-name&gt;ExpiresByType application/javascript&lt;/param-name&gt;
======= 833e6b1:"java/org/apache/catalina/filters/ExpiresFilter.java"

 *       application/javascript=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]]}]
    &lt;param-name&gt;ExpiresByType application/javascript&lt;/param-name&gt;

======= 2e7f5ab:"java/org/apache/jasper/compiler/JDTCompiler.java"

            @SuppressWarnings("unused") // New method added to interface in
                                        // later JDT versions
            public boolean ignoreOptionalProblems() {
                return false;
            }

======= 3fe64a5:"java/org/apache/catalina/mbeans/MBeanDumper.java"

                        } else if (cause instanceof NullPointerException) {
                            log.debug("Error getting attribute " + oname +
                                    " " + attName, rme);

======= 34b1a7e:"java/org/apache/catalina/startup/ContextConfig.java"

            ServletContext sContext = context.getServletContext();
======= 34b1a7e:"java/org/apache/catalina/startup/ContextConfig.java"

                    // Hack required by Eclipse's "serve modules without
                    // publishing" feature since this backs WEB-INF/classes by
                    // multiple locations rather than one.
======= 34b1a7e:"java/org/apache/catalina/startup/ContextConfig.java"

                                File webInfClassDir = new File(
                                processAnnotationsFile(webInfClassDir, webXml);
                            } else {
                                String resource =
                                        "/WEB-INF/classes/" + binding.getName();
                                try {
                                    URL url = sContext.getResource(resource);
                                    processAnnotationsUrl(url, webXml);
                                } catch (MalformedURLException e) {
                                    log.error(sm.getString(
                                            "contextConfig.webinfClassesUrl",
                                            resource), e);
                                }
======= 34b1a7e:"java/org/apache/catalina/startup/ContextConfig.java"

                    sContext.setAttribute(
                           mergedWebXml);

======= bf9bf39:"java/org/apache/el/lang/ELSupport.java"

        } else if (isBigDecimalOp(obj0, obj1)) {
        } else if (isDoubleOp(obj0, obj1)) {
        } else if (isBigIntegerOp(obj0, obj1)) {
        } else         if (isLongOp(obj0, obj1)) {
        } else if (obj0 instanceof Boolean || obj1 instanceof Boolean) {
            return coerceToBoolean(obj0).equals(coerceToBoolean(obj1));
        } else if (obj0.getClass().isEnum()) {
            return obj0.equals(coerceToEnum(obj1, obj0.getClass()));
        } else if (obj1.getClass().isEnum()) {
            return obj1.equals(coerceToEnum(obj0, obj1.getClass()));
        } else if (obj0 instanceof String || obj1 instanceof String) {
            int lexCompare = coerceToString(obj0).compareTo(coerceToString(obj1));
            return (lexCompare == 0) ? true : false;
======= bf9bf39:"test/org/apache/el/lang/TestELSupport.java"

    public void testEquals() {
        assertTrue(ELSupport.equals("01", Long.valueOf(1)));
    }
    @Test

======= 4b6d583:"java/org/apache/catalina/core/StandardServer.java"

======= 4b6d583:"java/org/apache/catalina/core/StandardServer.java"

======= 4b6d583:"java/org/apache/catalina/core/StandardServer.java"

        // Populate the extension validator with JARs from common and shared
        // class loaders
        if (getCatalina() != null) {
            ClassLoader cl =
                    getCatalina().getParentClassLoader();
            // Walk the class loader hierarchy. Stop at the system class loader.
            // This will add the shared (if present) and common class loaders
            while (cl != ClassLoader.getSystemClassLoader()) {
                if (cl instanceof URLClassLoader) {
                    URL[] urls = ((URLClassLoader) cl).getURLs();
                    for (URL url : urls) {
                        if (url.getProtocol().equals("file")) {
                            try {
                                File f = new File (url.toURI());
                                if (f.isFile() &&
                                        f.getName().endsWith(".jar")) {
                                    ExtensionValidator.addSystemResource(f);
                                }
                            } catch (URISyntaxException e) {
                                // Ignore
                            } catch (IOException e) {
                                // Ignore
                            }
                        }
                    }
                }
                cl = cl.getParent();
            }
        }
======= 4b6d583:"java/org/apache/catalina/util/ExtensionValidator.java"


======= 6f766be:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

            endOfStream = false;

======= fbf9166:"java/org/apache/catalina/mbeans/MBeanDumper.java"

======= fbf9166:"java/org/apache/catalina/mbeans/MBeanDumper.java"

                    } catch (JMRuntimeException rme) {
                        Throwable cause = rme.getCause();
                        if (cause instanceof UnsupportedOperationException) {
                            log.debug("Error getting attribute " + oname +
                                    " " + attName, rme);
                        } else {
                            log.error("Error getting attribute " + oname +
                                    " " + attName, rme);
                        }
                        continue;
                                " " + attName, t);

======= 660513c:"java/org/apache/catalina/core/StandardHostValve.java"


======= 2fd117b:"java/org/apache/catalina/connector/OutputBuffer.java"

        reset(false);
    }
    public void reset(boolean resetWriterStreamFlags) {
======= 2fd117b:"java/org/apache/catalina/connector/OutputBuffer.java"

        if (resetWriterStreamFlags) {
            gotEnc = false;
            enc = null;
        }
======= 2fd117b:"java/org/apache/catalina/connector/Response.java"

        outputBuffer.reset(resetWriterStreamFlags);
======= 2fd117b:"test/org/apache/catalina/connector/TestOutputBuffer.java"

    @Test
    public void testBug52577() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        Context root = tomcat.addContext("", TEMP_DIR);
        Bug52577Servlet bug52577 = new Bug52577Servlet();
        Tomcat.addServlet(root, "bug52577", bug52577);
        root.addServletMapping("/", "bug52577");
        tomcat.start();
        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() + "/", bc, null, null);
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertEquals("OK", bc.toString());
    }
======= 2fd117b:"test/org/apache/catalina/connector/TestOutputBuffer.java"

    private static class Bug52577Servlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            Writer w = resp.getWriter();
            w.write("OK");
            resp.resetBuffer();
            w.write("OK");
        }
    }

======= 49a52cb:"java/org/apache/catalina/core/StandardEngine.java"

    @Override
    protected void initInternal() throws LifecycleException {
        // Ensure that a Realm is present before any attempt is made to start
        // one. This will create the default NullRealm if necessary.
        getRealm();
        super.initInternal();
    }

======= f4896de:"java/org/apache/catalina/startup/ContextConfig.java"

======= f4896de:"java/org/apache/catalina/startup/ContextConfig.java"

            new LinkedHashMap<ServletContainerInitializer, Set<Class<?>>>();
            new HashMap<Class<?>, Set<ServletContainerInitializer>>();
    /**
     * Cache of JavaClass objects (byte code) by fully qualified class name.
     * Only populated if it is necessary to scan the super types and interfaces
     * as part of the processing for {@link HandlesTypes}.
     */
    protected final Map<String,JavaClassCacheEntry> javaClassCache =
            new HashMap<String,JavaClassCacheEntry>();
    /**
     * Flag that indicates if at least one {@link HandlesTypes} entry is present
     * that represents an annotation.
     */
    protected boolean handlesTypesAnnotations = false;
    /**
     * Flag that indicates if at least one {@link HandlesTypes} entry is present
     * that represents a non-annotation.
     */
    protected boolean handlesTypesNonAnnotations = false;
======= f4896de:"java/org/apache/catalina/startup/ContextConfig.java"

                // Cache, if used, is no longer required so clear it
                javaClassCache.clear();
======= f4896de:"java/org/apache/catalina/startup/ContextConfig.java"

                        if (type.isAnnotation()) {
                            handlesTypesAnnotations = true;
                        } else {
                            handlesTypesNonAnnotations = true;
                        }
======= f4896de:"java/org/apache/catalina/startup/ContextConfig.java"

        if (handlesTypesNonAnnotations) {
            // This *might* be match for a HandlesType.
            populateJavaClassCache(className, javaClass);
            JavaClassCacheEntry entry = javaClassCache.get(className);
            if (entry.getSciSet() == null) {
                populateSCIsForCacheEntry(entry);
            }
            if (entry.getSciSet().size() > 0) {
                // Need to try and load the class
                clazz = loadClass(className);
                if (clazz == null) {
                    // Can't load the class so no point continuing
                    return;
                }
                for (ServletContainerInitializer sci :
                        entry.getSciSet()) {
                    Set<Class<?>> classes = initializerClassMap.get(sci);
                    if (classes == null) {
                        classes = new HashSet<Class<?>>();
                        initializerClassMap.put(sci, classes);
                    }
                    classes.add(clazz);
                }
            }
        }
        if (handlesTypesAnnotations) {
            for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry :
                    typeInitializerMap.entrySet()) {
                if (entry.getKey().isAnnotation()) {
                    AnnotationEntry[] annotationEntries =
                            javaClass.getAnnotationEntries();
                    for (AnnotationEntry annotationEntry : annotationEntries) {
                        if (entry.getKey().getName().equals(
                                getClassName(annotationEntry.getAnnotationType()))) {
                            if (clazz == null) {
                                clazz = loadClass(className);
                                if (clazz == null) {
                                    // Can't load the class so no point
                                    // continuing
                                    return;
                                }
                            }
                            for (ServletContainerInitializer sci : entry.getValue()) {
                                initializerClassMap.get(sci).add(clazz);
                            }
                            break;
                        }
                    }
                }
            }
        }
    }
    private void populateJavaClassCache(String className, JavaClass javaClass) {
        if (javaClassCache.containsKey(className)) {
            return;
        }
        // Add this class to the cache
        javaClassCache.put(className, new JavaClassCacheEntry(javaClass));
        populateJavaClassCache(javaClass.getSuperclassName());
        for (String iterface : javaClass.getInterfaceNames()) {
            populateJavaClassCache(iterface);
        }
    }
    private void populateJavaClassCache(String className) {
        if (!javaClassCache.containsKey(className)) {
            String name = className.replace('.', '/') + ".class";
            InputStream is =
                    context.getLoader().getClassLoader().getResourceAsStream(name);
            ClassParser parser = new ClassParser(is, null);
            try {
                JavaClass clazz = parser.parse();
                populateJavaClassCache(clazz.getClassName(), clazz);
            } catch (ClassFormatException e) {
                log.debug(sm.getString("contextConfig.invalidSciHandlesTypes",
                        className), e);
            } catch (IOException e) {
                log.debug(sm.getString("contextConfig.invalidSciHandlesTypes",
                        className), e);
            }
        }
    }
    private void populateSCIsForCacheEntry(JavaClassCacheEntry cacheEntry) {
        Set<ServletContainerInitializer> result =
                new HashSet<ServletContainerInitializer>();
        JavaClass javaClass = cacheEntry.getJavaClass();
        // Super class
        String superClassName = javaClass.getSuperclassName();
        JavaClassCacheEntry superClassCacheEntry =
                javaClassCache.get(superClassName);
        // Avoid an infinite loop with java.lang.Object
        if (cacheEntry.equals(superClassCacheEntry)) {
            cacheEntry.setSciSet(new HashSet<ServletContainerInitializer>());
            return;
        }
        // May be null of the class is not present or could not be loaded.
        if (superClassCacheEntry != null) {
            if (superClassCacheEntry.getSciSet() == null) {
                populateSCIsForCacheEntry(superClassCacheEntry);
            }
            result.addAll(superClassCacheEntry.getSciSet());
        }
        result.addAll(getSCIsForClass(superClassName));
        // Interfaces
        for (String interfaceName : javaClass.getInterfaceNames()) {
            JavaClassCacheEntry interfaceEntry =
                    javaClassCache.get(interfaceName);
            // A null could mean that the class not present in application or
            // that there is nothing of interest. Either way, nothing to do here
            // so move along
            if (interfaceEntry != null) {
                if (interfaceEntry.getSciSet() == null) {
                    populateSCIsForCacheEntry(interfaceEntry);
                }
                result.addAll(interfaceEntry.getSciSet());
            }
            result.addAll(getSCIsForClass(interfaceName));
        }
        cacheEntry.setSciSet(result);
    }
    private Set<ServletContainerInitializer> getSCIsForClass(String className) {
        for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry :
                typeInitializerMap.entrySet()) {
            Class<?> clazz = entry.getKey();
            if (!clazz.isAnnotation()) {
                if (clazz.getName().equals(className)) {
                    return entry.getValue();
                }
            }
        }
        return Collections.emptySet();
    }
    private Class<?> loadClass(String className) {
        Class<?> clazz = null;
            return null;
            return null;
            return null;
            return null;
        return clazz;
======= f4896de:"java/org/apache/catalina/startup/ContextConfig.java"

    private static class JavaClassCacheEntry {
        private final JavaClass javaClass;
        private Set<ServletContainerInitializer> sciSet = null;
        public JavaClassCacheEntry(JavaClass javaClass) {
            this.javaClass = javaClass;
        }
        public JavaClass getJavaClass() {
            return javaClass;
        }
        public Set<ServletContainerInitializer> getSciSet() {
            return sciSet;
        }
        public void setSciSet(Set<ServletContainerInitializer> sciSet) {
            this.sciSet = sciSet;
        }
    }
======= f4896de:"java/org/apache/tomcat/util/bcel/classfile/JavaClass.java"

     * @return Names of implemented interfaces.
     */
    public String[] getInterfaceNames() {
        return interface_names;
    }
    /**
     * returns the super class name of this class. In the case that this class is
     * java.lang.Object, it will return itself (java.lang.Object). This is probably incorrect
     * but isn't fixed at this time to not break existing clients.
     *
     * @return Superclass name.
     */
    public String getSuperclassName() {
        return superclass_name;
    }
    /**
======= f4896de:"test/org/apache/catalina/startup/TestContextConfigAnnotation.java"

        config.handlesTypesAnnotations = true;
        config.handlesTypesNonAnnotations = true;

======= f2edc92:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        byteCount = 0;

======= ee0562d:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        checkLengthBeforeWrite(length);
======= ee0562d:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        checkLengthBeforeWrite(end-start);
======= ee0562d:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        checkLengthBeforeWrite(b.length);
======= ee0562d:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        checkLengthBeforeWrite(len);
======= ee0562d:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

    /**
     * Checks to see if there is enough space in the buffer to write the
     * requested number of bytes.
     */
    private void checkLengthBeforeWrite(int length)
            throws IllegalStateException {
        if (pos + length > buf.length) {
            throw new IllegalStateException(
                    sm.getString("iob.responseheadertoolarge.error"));
        }
    }

======= 3277494:"java/org/apache/catalina/startup/ContextConfig.java"

======= 3277494:"java/org/apache/catalina/startup/ContextConfig.java"

                    NamingEnumeration<Binding> listBindings = null;
                        try {
                            listBindings = context.getResources().listBindings(
                                    "/WEB-INF/classes");
                        } catch (NameNotFoundException ignore) {
                            // Safe to ignore
                        }
                        while (listBindings != null &&
                                listBindings.hasMoreElements()) {
                                File webInfCLassDir = new File(
  metadata-complete="false">

======= 2dd8a40:"java/org/apache/catalina/startup/TldRuleSet.java"

            tldConfig.addApplicationListener(text.trim());

======= 9722128:"java/org/apache/catalina/ant/AbstractCatalinaTask.java"

======= 9722128:"java/org/apache/catalina/ant/AbstractCatalinaTask.java"

                Base64.encode(input.getBytes(B2CConverter.ISO_8859_1));
======= 9722128:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

======= 9722128:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

======= 9722128:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

                    ipTimeKey.getBytes(B2CConverter.ISO_8859_1));
======= 9722128:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

                        serverIpTimeKey.getBytes(B2CConverter.ISO_8859_1));
======= 9722128:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

                buffer = md5Helper.digest(a2.getBytes(B2CConverter.ISO_8859_1));
======= 9722128:"java/org/apache/catalina/realm/JNDIRealm.java"

======= 9722128:"java/org/apache/catalina/realm/JNDIRealm.java"

======= 9722128:"java/org/apache/catalina/realm/JNDIRealm.java"

                    md.update(credentials.getBytes(B2CConverter.ISO_8859_1));
======= 9722128:"java/org/apache/catalina/realm/JNDIRealm.java"

                    md.update(credentials.getBytes(B2CConverter.ISO_8859_1));
                        pwbc.append(password.getBytes(B2CConverter.ISO_8859_1),
======= 9722128:"java/org/apache/catalina/realm/RealmBase.java"

            return B2CConverter.ISO_8859_1;
======= 9722128:"java/org/apache/catalina/servlets/WebdavServlet.java"

======= 9722128:"java/org/apache/catalina/servlets/WebdavServlet.java"

======= 9722128:"java/org/apache/catalina/servlets/WebdavServlet.java"

                    lockTokenStr.getBytes(B2CConverter.ISO_8859_1)));
======= 9722128:"java/org/apache/catalina/util/RequestUtil.java"

        // encoding is not specified, use ISO-8859-1
                bytes = str.getBytes(B2CConverter.ISO_8859_1);
======= 9722128:"java/org/apache/catalina/valves/AccessLogValve.java"

            charset = B2CConverter.ISO_8859_1;
======= 9722128:"java/org/apache/catalina/valves/SSLValve.java"

======= 9722128:"java/org/apache/catalina/valves/SSLValve.java"

======= 9722128:"java/org/apache/catalina/valves/SSLValve.java"

                    strcerts.getBytes(B2CConverter.ISO_8859_1));
======= 9722128:"java/org/apache/coyote/http11/filters/BufferedInputFilter.java"

======= 9722128:"java/org/apache/coyote/http11/filters/BufferedInputFilter.java"

        ENCODING.setBytes(ENCODING_NAME.getBytes(B2CConverter.ISO_8859_1), 0,
======= 9722128:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

======= 9722128:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

        ENCODING.setBytes(ENCODING_NAME.getBytes(B2CConverter.ISO_8859_1), 0,
======= 9722128:"java/org/apache/coyote/http11/filters/IdentityInputFilter.java"

======= 9722128:"java/org/apache/coyote/http11/filters/IdentityInputFilter.java"

        ENCODING.setBytes(ENCODING_NAME.getBytes(B2CConverter.ISO_8859_1), 0,
======= 9722128:"java/org/apache/coyote/http11/filters/VoidInputFilter.java"

======= 9722128:"java/org/apache/coyote/http11/filters/VoidInputFilter.java"

        ENCODING.setBytes(ENCODING_NAME.getBytes(B2CConverter.ISO_8859_1), 0,
======= 9722128:"java/org/apache/jasper/Constants.java"

======= 9722128:"java/org/apache/jasper/Constants.java"

    /**
     * Retain reference to default character set so we don't have to look it up.
     */
    public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
======= 9722128:"java/org/apache/jasper/compiler/SmapUtil.java"

======= 9722128:"java/org/apache/jasper/compiler/SmapUtil.java"

                    smap[i+1].getBytes(Constants.ISO_8859_1));
======= 9722128:"java/org/apache/naming/resources/Constants.java"

======= 9722128:"java/org/apache/naming/resources/Constants.java"

    /**
     * Retain reference to default character set so we don't have to look it up.
     */
    public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
======= 9722128:"java/org/apache/naming/resources/ProxyDirContext.java"

======= 9722128:"java/org/apache/naming/resources/ProxyDirContext.java"

                (object.toString().getBytes(Constants.ISO_8859_1)));
======= 9722128:"java/org/apache/naming/resources/ProxyDirContext.java"

                        (object.toString().getBytes(Constants.ISO_8859_1)));
======= 9722128:"java/org/apache/naming/resources/ProxyDirContext.java"

                        (object.toString().getBytes(Constants.ISO_8859_1)));
======= 9722128:"java/org/apache/tomcat/util/buf/MessageBytes.java"

======= 9722128:"java/org/apache/tomcat/util/buf/MessageBytes.java"

        byte bb[] = strValue.getBytes(B2CConverter.ISO_8859_1);

======= b553519:"java/org/apache/catalina/loader/WebappLoader.java"

======= b553519:"java/org/apache/catalina/loader/WebappLoader.java"

                    repository = utf8Decode(repository.substring(7));
                    repository = utf8Decode(repository.substring(5));
======= b553519:"java/org/apache/catalina/loader/WebappLoader.java"

    private String utf8Decode(String input) {
        String result = null;
        try {
            result = URLDecoder.decode(input, "UTF-8");
        } catch (UnsupportedEncodingException uee) {
            // Impossible. All JVMs are required to support UTF-8.
        }
        return result;
    }

======= bd478e5:"java/org/apache/catalina/manager/JMXProxyServlet.java"

======= bd478e5:"java/org/apache/catalina/manager/JMXProxyServlet.java"

        qry = request.getParameter("invoke");
        if(qry != null) {
            String opName=request.getParameter("op");
            String ps = request.getParameter("ps");
            String[] valuesStr;
            if (ps == null) {
                valuesStr = new String[0];
            } else {
                valuesStr = request.getParameter("ps").split(",");
            }
            invokeOperation( writer, qry, opName,valuesStr );
            return;
        }
======= bd478e5:"java/org/apache/catalina/manager/JMXProxyServlet.java"

            writer.println("Error");
            ex.printStackTrace(writer);
======= bd478e5:"java/org/apache/catalina/manager/JMXProxyServlet.java"

            writer.println("Error");
            ex.printStackTrace(writer);
======= bd478e5:"java/org/apache/catalina/manager/JMXProxyServlet.java"

        } catch (Exception ex) {
            writer.println("Error");
            ex.printStackTrace(writer);
======= bd478e5:"java/org/apache/catalina/manager/JMXProxyServlet.java"

    private void invokeOperation(PrintWriter writer, String onameStr, String op,
            String[] valuesStr) {
        try {
            ObjectName oname=new ObjectName( onameStr );
            MBeanOperationInfo methodInfo = registry.getMethodInfo(oname,op);
            MBeanParameterInfo[] signature = methodInfo.getSignature();
            String[] signatureTypes = new String[signature.length];
            Object[] values = new Object[signature.length];
            for (int i = 0; i < signature.length; i++) {
               MBeanParameterInfo pi = signature[i];
               signatureTypes[i] = pi.getType();
               values[i] = registry.convertValue(pi.getType(), valuesStr[i] );
           }
            Object retVal = mBeanServer.invoke(oname,op,values,signatureTypes);
            writer.println("OK - Operation " + op + " returned:");
            output("", writer, retVal);
        } catch( Exception ex ) {
            writer.println("Error");
            ex.printStackTrace(writer);
        }
    }
    private void output(String indent, PrintWriter writer, Object result) {
        if (result instanceof Object[]) {
            for (Object obj : (Object[]) result) {
                output("  " + indent, writer, obj);
            }
        } else {
            writer.println(indent + result.toString());
        }
    }
  <subsection name="JMX Invoke command">
    <p>The <code>invoke</code> command enables methods to be called on MBeans. The
    general form of the command is:</p>
    <p>For exmaple, to call the <code>findConnectors()</code> method of the
    <strong>Service</strong> use:</p>
  </subsection>

======= 53615e5:"java/org/apache/catalina/startup/ContextConfig.java"

======= 53615e5:"java/org/apache/catalina/startup/ContextConfig.java"

======= 53615e5:"java/org/apache/catalina/startup/ContextConfig.java"

======= 53615e5:"java/org/apache/catalina/startup/ContextConfig.java"

                URL url = new URL(globalWebXml.getSystemId());
                globalTimeStamp = url.openConnection().getLastModified();
            } catch (MalformedURLException e) {
                globalTimeStamp = -1;
            } catch (IOException e) {
                URL url = new URL(hostWebXml.getSystemId());
                hostTimeStamp = url.openConnection().getLastModified();
            } catch (MalformedURLException e) {
                hostTimeStamp = -1;
            } catch (IOException e) {

======= 3c8f40f:"java/org/apache/el/parser/AstValue.java"

            values = ((AstMethodParameters) this.jjtGetChild(
                    this.jjtGetNumChildren() - 1)).getParameters(ctx);
======= 3c8f40f:"java/org/apache/el/parser/AstValue.java"

        // Assumption is that method parameters, if present, will be the last
        // child
        int len = children.length;
        if (len > 2) {
            if (this.jjtGetChild(len - 1) instanceof AstMethodParameters) {
                return true;
            }
======= 3c8f40f:"test/org/apache/el/TestMethodExpressionImpl.java"

    @Test
    public void testBug52445a() {
        MethodExpression me = factory.createMethodExpression(context,
                "${beanA.setBean(beanBB)}", null ,
                new Class<?>[] { TesterBeanB.class });
        me.invoke(context, null);
        MethodExpression me1 = factory.createMethodExpression(context,
                "${beanA.bean.sayHello()}", null, null);
        String actual = (String) me1.invoke(context, null);
        assertEquals("Hello from BB", actual);
    }

======= c38ed95:"java/org/apache/catalina/startup/Tomcat.java"

 * behavior of the <pre>addWebapp</pre> methods, you may want to call two
 * methods of this class: {@link #noDefaultWebXmlPath()} and
 * {@link #getDefaultWebXmlListener()}.
======= c38ed95:"java/org/apache/catalina/startup/Tomcat.java"

======= c38ed95:"java/org/apache/catalina/startup/Tomcat.java"

======= c38ed95:"java/org/apache/catalina/startup/Tomcat.java"

            engine.setRealm(createDefaultRealm());
======= c38ed95:"java/org/apache/catalina/startup/Tomcat.java"

======= c38ed95:"java/org/apache/catalina/startup/Tomcat.java"

     * Create an in-memory realm. You can replace it for contexts with a real
     * one. The Realm created here will be added to the Engine by default and
     * may be replaced at the Engine level or over-ridden (as per normal Tomcat
     * behaviour) at the Host or Context level.
    protected Realm createDefaultRealm() {
        return new RealmBase() {
======= c38ed95:"test/org/apache/catalina/mbeans/TestRegistration.java"

            "Tomcat:type=Realm,realmPath=/realm0",

======= ee2a461:"java/org/apache/catalina/loader/WebappClassLoader.java"

        "javax.servlet.Servlet", "javax.el.Expression"       // Servlet API
======= ee2a461:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (name.startsWith("javax.el")) {
            // Must never load javax.el.* classes
            return false;
        }

======= f277b14:"java/org/apache/el/parser/AstIdentifier.java"

======= f277b14:"java/org/apache/el/parser/AstIdentifier.java"

    @Override
    public ValueReference getValueReference(EvaluationContext ctx) {
        VariableMapper varMapper = ctx.getVariableMapper();
        if (varMapper == null) {
            return null;
        }
        ValueExpression expr = varMapper.resolveVariable(this.image);
        if (expr == null) {
            return null;
        }
        return expr.getValueReference(ctx);
    }
======= f277b14:"test/org/apache/el/TestValueExpressionImpl.java"

    public void testGetValueReferenceVariable() {
        ExpressionFactory factory = ExpressionFactory.newInstance();
        ELContext context = new ELContextImpl();
        TesterBeanB beanB = new TesterBeanB();
        beanB.setName("Tomcat");
        ValueExpression var =
            factory.createValueExpression(beanB, TesterBeanB.class);
        context.getVariableMapper().setVariable("beanB", var);
        ValueExpression var2 = factory.createValueExpression(
                context, "${beanB.name}", String.class);
        context.getVariableMapper().setVariable("foo", var2);
        ValueExpression ve = factory.createValueExpression(
                context, "${foo}", ValueExpression.class);
        // Now check the value reference
        ValueReference vr = ve.getValueReference(context);
        assertNotNull(vr);
        assertEquals(beanB, vr.getBase());
        assertEquals("name", vr.getProperty());
    }
    @Test

======= 9c7ec4c:"java/org/apache/catalina/connector/OutputBuffer.java"

        // Flush the convertor if one is in use
        if (gotEnc && conv != null) {
            conv.flushBuffer();
        }
======= 9c7ec4c:"java/org/apache/catalina/connector/OutputBuffer.java"

======= 9c7ec4c:"java/org/apache/catalina/connector/OutputBuffer.java"

======= 9c7ec4c:"java/org/apache/catalina/connector/OutputBuffer.java"

======= 9c7ec4c:"java/org/apache/catalina/connector/OutputBuffer.java"

======= 9c7ec4c:"java/org/apache/catalina/connector/OutputBuffer.java"

        // If a Writer wasbeing used, there may be unflushed bytes in the
        // convertor
        if (gotEnc && conv != null) {
            conv.recycle();
        }

======= 3787242:"java/org/apache/catalina/startup/Tomcat.java"

        silence(host, contextPath);
======= 3787242:"java/org/apache/catalina/startup/Tomcat.java"

        silence(host, url);
======= 3787242:"java/org/apache/catalina/startup/Tomcat.java"

    private void silence(Host host, String ctx) {
        base += host.getName();

======= addd522:"java/org/apache/catalina/startup/ContextConfig.java"

            log.debug(sm.getString("contextConfig.invalidSciHandlesTypes",
            log.debug(sm.getString("contextConfig.invalidSciHandlesTypes",
            log.debug(sm.getString("contextConfig.invalidSciHandlesTypes",

======= 9f52382:"java/org/apache/catalina/valves/AccessLogValve.java"

            if (length <= 0) {
                // Protect against nulls and unexpected types as these values
                // may be set by untrusted applications
                Object start = request.getAttribute(
                        "org.apache.tomcat.sendfile.start");
                if (start instanceof Long) {
                    Object end = request.getAttribute(
                            "org.apache.tomcat.sendfile.end");
                    if (end instanceof Long) {
                        length = ((Long) end).longValue() -
                                ((Long) start).longValue();
                    }
                }
            }
    <p>If sendfile is used, the response bytes will be written asynchronously
    in a separate thread and the access log valve will not know how many bytes
    were actually written. In this case, the number of bytes that was passed to
    the sendfile thread for writing will be recorded in the access log valve.
    </p>

======= 8b6d341:"java/org/apache/catalina/authenticator/NonLoginAuthenticator.java"

======= 8b6d341:"java/org/apache/catalina/authenticator/NonLoginAuthenticator.java"

     * Authenticate the user making this request, based on the fact that no
     * <code>login-config</code> has been defined for the container.
     * This implementation means "login the user even though there is no
     * self-contained way to establish a security Principal for that user".
     * 
     * This method is called by the AuthenticatorBase super class to
     * establish a Principal for the user BEFORE the container security
     * constraints are examined, i.e. it is not yet known whether the user
     * will eventually be permitted to access the requested resource.
     * Therefore, it is necessary to always return <code>true</code> to
     * indicate the user has not failed authentication.
     * There are two cases:
     *
     *  - without SingleSignon: a Session instance does not yet exist
     *    and there is no <code>auth-method</code> to authenticate the
     *    user, so leave Request's Principal as null.
     *    note: AuthenticatorBase will later examine the security constraints
     *          to determine whether the resource is accessible by a user
     *          without a security Principal and Role (i.e. unauthenticated).
     *
     * - with SingleSignon: if the user has already authenticated via
     *   another container (using its own login configuration), then
     *   associate this Session with the SSOEntry so it inherits the
     *   already-established security Principal and associated Roles.
     *   note: This particular session will become a full member of the
     *         SingleSignOnEntry Session collection and so will potentially
     *         keep the SSOE "alive", even if all the other properly
     *         authenticated Sessions expire first... until it expires too.
     *
     * @param request  Request we are processing
     * @param response Response we are creating
     * @param config   Login configuration describing how authentication
     *                 should be performed
     * @return boolean to indicate whether the user is authenticated
======= 8b6d341:"java/org/apache/catalina/authenticator/NonLoginAuthenticator.java"

        Principal principal = request.getUserPrincipal();
        if (principal != null) {
            // excellent... we have already authenticated the client somehow,
            // probably from another container that has a login-config
            if (containerLog.isDebugEnabled())
                containerLog.debug("Already authenticated as '"
                          + principal.getName() + "'");
            // create a new session (only if necessary)
            Session session = request.getSessionInternal(true);
            // save the inherited Principal (if necessary) in this
            // session so it can remain authenticated until it expires
            session.setPrincipal(principal);
            session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal);
            // is there an SSO session cookie?
            String ssoId =
                    (String) request.getNote(Constants.REQ_SSOID_NOTE);
            if (ssoId != null) {
                if (containerLog.isDebugEnabled())
                    containerLog.debug("User authenticated by existing SSO");
                // Associate session with the existing SSO ID if necessary
                associate(ssoId, session);
            }
            // user was already authenticated, with or without a cookie
            return true;
        // No Principal means the user is not already authenticated
        // and so will not be assigned any roles. It is safe to
        // to say the user is now authenticated because access to
        // protected resources will only be allowed with a matching role.
        // i.e. SC_FORBIDDEN (403 status) will be generated later.
        if (containerLog.isDebugEnabled())
            containerLog.debug("User authenticated without any roles");
        return true;
    /**
     * Return the authentication method, which is vendor-specific and
     * not defined by HttpServletRequest.
     */

======= 34b011b:"java/org/apache/tomcat/util/http/Parameters.java"

                if (valueStart == -1) {
                    // &&
                    if (log.isDebugEnabled()) {
                        log.debug(sm.getString("parameters.emptyChunk"));
                    }
                    // Do not flag as error
                    continue;
                }
                // &=foo&
======= 34b011b:"java/org/apache/tomcat/util/http/Parameters.java"

            if (valueStart >= 0) {
                tmpValue.setBytes(bytes, valueStart, valueEnd - valueStart);
            } else {
                tmpValue.setBytes(bytes, 0, 0);
            }
======= 34b011b:"java/org/apache/tomcat/util/http/Parameters.java"

                    if (valueStart >= 0) {
                        origValue.append(bytes, valueStart, valueEnd - valueStart);
                    } else {
                        origValue.append(bytes, 0, 0);
                    }
======= 34b011b:"java/org/apache/tomcat/util/http/Parameters.java"

                if (valueStart >= 0) {
                    if (decodeValue) {
                        urlDecode(tmpValue);
                    }
                    tmpValue.setCharset(charset);
                    value = tmpValue.toString();
                } else {
                    value = "";

======= 6f3cafe:"java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java"

    private volatile int size = 0;

======= 8983419:"java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java"

    private volatile boolean checkLock = false;
    // Flags used to detect unexpected state
    private volatile boolean inAdd = false;
    private volatile boolean inRemove = false;
    private volatile boolean inMutex = false;

======= d69fb8e:"java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java"

    private volatile boolean enabled = true;
======= d69fb8e:"java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java"

        if (!enable) {

======= 33e48db:"java/org/apache/catalina/startup/ContextConfig.java"

            if (originalDocBase.toLowerCase(Locale.ENGLISH).endsWith(".war")) {

======= 22e7e15:"java/org/apache/catalina/core/ApplicationJspConfigDescriptor.java"

======= 22e7e15:"java/org/apache/catalina/core/ApplicationJspConfigDescriptor.java"

        new LinkedHashSet<JspPropertyGroupDescriptor>();
======= 22e7e15:"java/org/apache/catalina/deploy/WebXml.java"

        new LinkedHashSet<JspPropertyGroup>();

======= 9403e4f:"java/org/apache/catalina/tribes/transport/nio/NioReceiver.java"

        // Avoid NPEs if selector is set to null on stop.
        Selector selector = this.selector;
======= 9403e4f:"java/org/apache/catalina/tribes/transport/nio/NioReceiver.java"

                Iterator<SelectionKey> it = selector.selectedKeys().iterator();
======= 9403e4f:"java/org/apache/catalina/tribes/transport/nio/NioReceiver.java"

                    it.remove();

======= 63f708a:"java/org/apache/catalina/connector/Connector.java"

======= 63f708a:"java/org/apache/catalina/connector/Connector.java"

    protected int port = -1;
======= 63f708a:"java/org/apache/catalina/connector/Connector.java"

======= 63f708a:"java/org/apache/catalina/connector/Connector.java"

     * Return the port number on which this connector is configured to listen
     * for requests. The special value of 0 means select a random free port
     * when the socket is bound.
======= 63f708a:"java/org/apache/catalina/connector/Connector.java"

     * Return the port number on which this connector is listening to requests.
     * If the special value for {@link #port} of zero is used then this method
     * will report the actual port bound.
     */
    public int getLocalPort() {
        return ((Integer) getProperty("localPort")).intValue();
    }
    /**
======= 63f708a:"java/org/apache/catalina/connector/Connector.java"

        int port = getPort();
        if (port > 0) {
            sb.append(getPort());
        } else {
            sb.append("auto-");
            sb.append(getProperty("nameIndex"));
        }
======= 63f708a:"java/org/apache/catalina/connector/Connector.java"

        if (getPort() < 0) {
======= 63f708a:"java/org/apache/catalina/connector/Connector.java"

        int port = getPort();
        if (port > 0) {
            sb.append(getPort());
        } else {
            sb.append("auto-");
            sb.append(getProperty("nameIndex"));
        }
    <attribute   name="localPort"
          description="The port number on which this connector is listening to requests. If the special value for port of zero is used then this method will report the actual port bound."
                type="int"/>
          description="The port number on which this connector is configured to listen for requests. The special value of 0 means select a random free port when the socket is bound."
======= 63f708a:"java/org/apache/coyote/AbstractProtocol.java"

     * Counter used to generate unique JMX names for connectors using automatic
     * port binding.
     */
    private static final AtomicInteger nameCounter = new AtomicInteger(0);
    /**
======= 63f708a:"java/org/apache/coyote/AbstractProtocol.java"

     * Unique ID for this connector. Only used if the connector is configured
     * to use a random port as the port will change if stop(), start() is
     * called.
     */
    private int nameIndex = 0;
    /**
======= 63f708a:"java/org/apache/coyote/AbstractProtocol.java"

    public int getLocalPort() { return endpoint.getLocalPort(); }
======= 63f708a:"java/org/apache/coyote/AbstractProtocol.java"

    public synchronized int getNameIndex() {
        if (nameIndex == 0) {
            nameIndex = nameCounter.incrementAndGet();
        }
        return nameIndex;
    }
======= 63f708a:"java/org/apache/coyote/AbstractProtocol.java"

        int port = getLocalPort();
        if (port > 0) {
            name.append(port);
        } else {
            name.append("auto-");
            name.append(getNameIndex());
        }
======= 63f708a:"java/org/apache/coyote/AbstractProtocol.java"

        int port = getPort();
        if (port > 0) {
            name.append(getPort());
        } else {
            name.append("auto-");
            name.append(getNameIndex());
        }
======= 63f708a:"java/org/apache/coyote/AbstractProtocol.java"

======= 63f708a:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    public abstract int getLocalPort();
======= 63f708a:"java/org/apache/tomcat/util/net/AprEndpoint.java"

======= 63f708a:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    /**
     * Port in use.
     */
    @Override
    public int getLocalPort() {
        long s = serverSock;
        if (s == 0) {
            return -1;
        } else {
            long sa;
            try {
                sa = Address.get(Socket.APR_LOCAL, s);
                Sockaddr addr = Address.getInfo(sa);
                return addr.port;
            } catch (Exception e) {
                return -1;
            }
        }
    }
    // --------------------------------------------------------- Public Methods
======= 63f708a:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

    /**
     * Port in use.
     */
    @Override
    public int getLocalPort() {
        ServerSocket s = serverSocket;
        if (s == null) {
            return -1;
        } else {
            return s.getLocalPort();
        }
    }
======= 63f708a:"java/org/apache/tomcat/util/net/NioEndpoint.java"

======= 63f708a:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    /**
     * Port in use.
     */
    @Override
    public int getLocalPort() {
        ServerSocketChannel ssc = serverSock;
        if (ssc == null) {
            return -1;
        } else {
            ServerSocket s = ssc.socket();
            if (s == null) {
                return -1;
            } else {
                return s.getLocalPort();
            }
        }
    }
======= 63f708a:"test/org/apache/catalina/authenticator/TestFormAuthenticator.java"

            // Port only known after Tomcat starts
            setPort(getPort());
======= 63f708a:"test/org/apache/catalina/connector/TestConnector.java"

======= 63f708a:"test/org/apache/catalina/connector/TestConnector.java"

    @Test
    public void testPort() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        Connector connector1 = tomcat.getConnector();
        connector1.setPort(0);
        Connector connector2 = new Connector();
        connector2.setPort(0);
        tomcat.getService().addConnector(connector2);
        tomcat.start();
        int localPort1 = connector1.getLocalPort();
        int localPort2 = connector2.getLocalPort();
        assertTrue(localPort1 > 0);
        assertTrue(localPort2 > 0);
    }
======= 63f708a:"test/org/apache/catalina/connector/TestRequest.java"

======= 63f708a:"test/org/apache/catalina/connector/TestRequest.java"

======= 63f708a:"test/org/apache/catalina/connector/TestRequest.java"

            setPort(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/catalina/connector/TestRequest.java"

======= 63f708a:"test/org/apache/catalina/connector/TestRequest.java"

            setPort(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/catalina/core/TestStandardContext.java"

        Bug46243Client client =
                new Bug46243Client(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/catalina/core/TestStandardContext.java"

        public Bug46243Client(int port) {
            setPort(port);
        }
======= 63f708a:"test/org/apache/catalina/core/TestStandardContext.java"

======= 63f708a:"test/org/apache/catalina/core/TestStandardContext.java"

            setPort(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/catalina/core/TestSwallowAbortedUploads.java"

======= 63f708a:"test/org/apache/catalina/core/TestSwallowAbortedUploads.java"

======= 63f708a:"test/org/apache/catalina/core/TestSwallowAbortedUploads.java"

            setPort(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/catalina/core/TestSwallowAbortedUploads.java"

            setPort(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/catalina/filters/TestExpiresFilter.java"

                    "http://localhost:" + tomcat.getConnector().getLocalPort() +
======= 63f708a:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

        HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(
                "http://localhost:" + tomcat.getConnector().getLocalPort() +
                "/test").openConnection();
======= 63f708a:"test/org/apache/catalina/mbeans/TestRegistration.java"

        expected.addAll(Arrays.asList(connectorMBeanNames("auto-1", protocol)));
======= 63f708a:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

        TestCustomErrorClient client =
                new TestCustomErrorClient(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

        TestCustomErrorClient client =
                new TestCustomErrorClient(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

        public TestCustomErrorClient(int port) {
            setPort(port);
        }
======= 63f708a:"test/org/apache/catalina/startup/SimpleHttpClient.java"

    protected void setPort(int thePort) {
======= 63f708a:"test/org/apache/catalina/startup/TomcatBaseTest.java"

======= 63f708a:"test/org/apache/catalina/startup/TomcatBaseTest.java"

        return tomcat.getConnector().getLocalPort();
======= 63f708a:"test/org/apache/catalina/startup/TomcatBaseTest.java"

        // Use random free port
        connector.setPort(0);
======= 63f708a:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        Client client = new Client(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        Client client = new Client(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        Client client = new Client(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        Client client = new Client(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        Client client = new Client(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        final Client client = new Client(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/coyote/http11/TestAbstractHttp11Processor.java"

        public Client(int port) {
            setPort(port);
        }
======= 63f708a:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

======= 63f708a:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

                setPort(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

======= 63f708a:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

======= 63f708a:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

======= 63f708a:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

======= 63f708a:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

======= 63f708a:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

                setPort(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java"

        TrailerClient client =
                new TrailerClient(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java"

        TrailerClient client =
                new TrailerClient(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java"

        TrailerClient client =
                new TrailerClient(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java"

        public TrailerClient(int port) {
            setPort(port);
        }
======= 63f708a:"test/org/apache/tomcat/util/http/TestCookiesAllowEquals.java"

            setPort(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/tomcat/util/http/TestCookiesAllowHttpSeps.java"

            setPort(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/tomcat/util/http/TestCookiesAllowNameOnly.java"

            setPort(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/tomcat/util/http/TestCookiesDisallowEquals.java"

            setPort(tomcat.getConnector().getLocalPort());
======= 63f708a:"test/org/apache/tomcat/util/net/TestXxxEndpoint.java"

        int port = getPort();
      to a particular port number on a particular IP address. If the special
      value of 0 (zero) is used, then Tomcat will select a free port at random
      to use for this connector. This is typically only useful in embedded and
      testing applications.</p>
      to a particular port number on a particular IP address. If the special
      value of 0 (zero) is used, then Tomcat will select a free port at random
      to use for this connector. This is typically only useful in embedded and
      testing applications.</p>

======= f3a7cd9:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

        newHost.object = realHost.object;
======= f3a7cd9:"test/org/apache/tomcat/util/http/mapper/TestMapper.java"

        mapper.addHostAlias("iowejoiejfoiew", "iowejoiejfoiew_alias");
======= f3a7cd9:"test/org/apache/tomcat/util/http/mapper/TestMapper.java"

        // Check we have the right number
        // (added 17 including one host alias but one is a duplicate)
        assertEquals(16, mapper.hosts.length);
        final int iowPos = 3;
        assertEquals("blah7", mapper.hosts[iowPos].object);
======= f3a7cd9:"test/org/apache/tomcat/util/http/mapper/TestMapper.java"

        // Check that host alias has the same data
        Mapper.Host host = mapper.hosts[iowPos];
        Mapper.Host alias = mapper.hosts[iowPos + 1];
        assertEquals("iowejoiejfoiew", host.name);
        assertEquals("iowejoiejfoiew_alias", alias.name);
        assertEquals(host.contextList, alias.contextList);
        assertEquals(host.object, alias.object);
======= f3a7cd9:"test/org/apache/tomcat/util/http/mapper/TestMapper.java"

        MessageBytes alias = MessageBytes.newInstance();
        alias.setString("iowejoiejfoiew_alias");
======= f3a7cd9:"test/org/apache/tomcat/util/http/mapper/TestMapper.java"

        mappingData.recycle();
        uri.setString("/foo/bar/bla/bobou/foo");
        uri.toChars();
        uri.getCharChunk().setLimit(-1);
        mapper.map(alias, uri, null, mappingData);
        assertEquals("blah7", mappingData.host);
        assertEquals("context3", mappingData.context);
        assertEquals("wrapper7", mappingData.wrapper);
        assertEquals("/foo/bar/bla", mappingData.contextPath.toString());
        assertEquals("/bobou", mappingData.wrapperPath.toString());
        assertEquals("/foo", mappingData.pathInfo.toString());
        assertTrue(mappingData.redirectPath.isNull());

======= 574af73:"java/org/apache/catalina/loader/WebappClassLoader.java"

 * <strong>IMPLEMENTATION NOTE</strong> - By default, this class loader follows
 * the delegation model required by the specification. The system class
 * from the webapp repositories. The <code>delegate</code> property
 * allows an application to modify this behavior to move the parent class loader
 * ahead of the local repositories.
======= 574af73:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * found locally. Note that the default, <code>false</code>, is
     * the behavior called for by the servlet specification.
======= 574af73:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * If this flag is true, this class loader delegates
     * to the parent class loader
     * <strong>before</strong> searching its own repositories, as
     * in an ordinary (non-servlet) chain of of Java class loaders.
     * If set to <code>false</code> (the default),
     * this class loader will search its own repositories first, and
     * delegate to the parent only if the class or resource is not
     * found locally, as per the servlet specification.

======= c2001ce:"java/org/apache/catalina/core/AprLifecycleListener.java"

======= c2001ce:"java/org/apache/catalina/core/AprLifecycleListener.java"

    protected static String FIPSMode = "off"; // default off, valid only when SSLEngine="on"
    protected static boolean fipsModeActive = false;
======= c2001ce:"java/org/apache/catalina/core/AprLifecycleListener.java"

                        log.error(sm.getString("aprListener.sslInit"), t);
======= c2001ce:"java/org/apache/catalina/core/AprLifecycleListener.java"

        fipsModeActive = false;
======= c2001ce:"java/org/apache/catalina/core/AprLifecycleListener.java"

======= c2001ce:"java/org/apache/catalina/core/AprLifecycleListener.java"

        if("on".equalsIgnoreCase(AprLifecycleListener.FIPSMode)) {
            log.info(sm.getString("aprListener.initializingFIPS"));
            int result = SSL.fipsModeSet(1);
            // success is defined as return value = 1
            if(1 == result) {
                fipsModeActive = true;
                log.info(sm.getString("aprListener.initializeFIPSSuccess"));
            } else {
                // This case should be handled by the native method,
                // but we'll make absolutely sure, here.
                log.error(sm.getString("aprListener.initializeFIPSFailed"));
                throw new IllegalStateException(sm.getString("aprListener.initializeFIPSFailed"));
            }
        }
======= c2001ce:"java/org/apache/catalina/core/AprLifecycleListener.java"

        // Ensure that the SSLEngine is consistent with that used for SSL init
        if(sslInitialized)
            throw new IllegalStateException(sm.getString("aprListener.tooLateForSSLEngine"));
======= c2001ce:"java/org/apache/catalina/core/AprLifecycleListener.java"

        // Ensure that the random seed is consistent with that used for SSL init
        if(sslInitialized)
            throw new IllegalStateException(sm.getString("aprListener.tooLateForSSLRandomSeed"));
    public void setFIPSMode(String FIPSMode)
    {
        // Ensure that the FIPS mode is consistent with that used for SSL init
        if(sslInitialized)
            throw new IllegalStateException(sm.getString("aprListener.tooLateForFIPSMode"));
        AprLifecycleListener.FIPSMode = FIPSMode;
    }
    public boolean isFIPSModeActive()
    {
        return fipsModeActive;
    }
======= c2001ce:"java/org/apache/tomcat/jni/SSL.java"

     * Enable/Disable FIPS Mode.
     *
     * @param mode 1 - enable, 0 - disable
     *
     * @return FIPS_mode_set return code
     */
    public static native int fipsModeSet(int mode);
    /**

======= b7f5c7e:"java/org/apache/catalina/core/ApplicationContext.java"

                resources.lookup(normPath);

======= d7af36d:"java/org/apache/catalina/mbeans/MBeanFactory.java"

            if (configFile.isFile()) {
                context.setConfigFile(configFile.toURI().toURL());
            }

======= 62ff013:"java/org/apache/jasper/JspCompilationContext.java"

            } catch (FileNotFoundException fnfe) {
                // Re-throw to let caller handle this - will result in a 404
                throw fnfe;
======= 62ff013:"java/org/apache/jasper/compiler/JspUtil.java"

======= 62ff013:"java/org/apache/jasper/compiler/JspUtil.java"

                throw new FileNotFoundException(Localizer.getMessage(
                        "jsp.error.file.not.found", fname));
======= 62ff013:"java/org/apache/jasper/compiler/JspUtil.java"

            throw new FileNotFoundException(Localizer.getMessage(
                    "jsp.error.file.not.found", fname));

======= b90c0a1:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                ((Context) request.getMappingData().context).logAccess(
                        request, response,
                        System.currentTimeMillis() - req.getStartTime(),
                        false);
======= b90c0a1:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                if (postParseSuccess &&
                        request.getMappingData().context != null) {
                    // If context is null this was the start of a comet request
                    // that failed and has already been logged.
======= b90c0a1:"test/org/apache/catalina/comet/TestCometProcessor.java"

======= b90c0a1:"test/org/apache/catalina/comet/TestCometProcessor.java"

        doSimpleCometTest(null);
    }
    @Test
    public void testSimpleCometClientBeginFail() throws Exception {
        doSimpleCometTest(SimpleCometServlet.FAIL_ON_BEGIN);
    }
    @Test
    public void testSimpleCometClientReadFail() throws Exception {
        doSimpleCometTest(SimpleCometServlet.FAIL_ON_READ);
    }
    @Test
    public void testSimpleCometClientEndFail() throws Exception {
        doSimpleCometTest(SimpleCometServlet.FAIL_ON_END);
    }
    private void doSimpleCometTest(String initParam) throws Exception {
======= b90c0a1:"test/org/apache/catalina/comet/TestCometProcessor.java"

        Wrapper w = Tomcat.addServlet(root, "comet", new SimpleCometServlet());
        if (initParam != null) {
            w.addInitParameter(initParam, "true");
        }
        TesterAccessLogValve alv = new TesterAccessLogValve();
        root.getPipeline().addValve(alv);
======= b90c0a1:"test/org/apache/catalina/comet/TestCometProcessor.java"

        if (initParam == null) {
            // Normal response expected
            // Validate response
            assertEquals("HTTP/1.1 200 OK", response[0]);
            assertEquals("Server: Apache-Coyote/1.1", response[1]);
            assertTrue(response[2].startsWith("Set-Cookie: JSESSIONID="));
            assertEquals("Content-Type: text/plain;charset=ISO-8859-1", response[3]);
            assertEquals("Transfer-Encoding: chunked", response[4]);
            assertTrue(response[5].startsWith("Date: "));
            assertEquals("", response[6]);
            assertEquals("7", response[7]);
            assertEquals("BEGIN", response[8]);
            assertEquals("", response[9]);
            assertEquals("17", response[10]);
            assertEquals("Client: READ: 4 bytes", response[11]);
            assertEquals("", response[12]);
            assertEquals("17", response[13]);
            assertEquals("Client: READ: 4 bytes", response[14]);
            assertEquals("", response[15]);
            assertEquals("17", response[16]);
            assertEquals("Client: READ: 4 bytes", response[17]);
            assertEquals("", response[18]);
            assertEquals("17", response[19]);
            assertEquals("Client: READ: 4 bytes", response[20]);
            assertEquals("", response[21]);
            assertEquals("d", response[22]);
            assertEquals("Client: END", response[23]);
            assertEquals("", response[24]);
            assertEquals("0", response[25]);
            // Expect 26 lines
            assertEquals(26, response.length);
        } else {
            // Failure expected only expected for the fail on begin
            // Failure at any later stage and the reponse headers (including the
            // 200 response code will already have been sent to the client
            if (initParam == SimpleCometServlet.FAIL_ON_BEGIN) {
                assertEquals("HTTP/1.1 500 Internal Server Error", response[0]);
                alv.validateAccessLog(1, 500, 0, 1000);
            } else {
                assertEquals("HTTP/1.1 200 OK", response[0]);
                alv.validateAccessLog(1, 200, 0, 5000);
            }
        }
======= b90c0a1:"test/org/apache/catalina/comet/TestCometProcessor.java"

        public static final String FAIL_ON_BEGIN = "failOnBegin";
        public static final String FAIL_ON_READ = "failOnRead";
        public static final String FAIL_ON_END = "failOnEnd";
        private boolean failOnBegin = false;
        private boolean failOnRead = false;
        private boolean failOnEnd = false;
        @Override
        public void init() throws ServletException {
            failOnBegin = Boolean.valueOf(getServletConfig().getInitParameter(
                    FAIL_ON_BEGIN)).booleanValue();
            failOnRead = Boolean.valueOf(getServletConfig().getInitParameter(
                    FAIL_ON_READ)).booleanValue();
            failOnEnd = Boolean.valueOf(getServletConfig().getInitParameter(
                    FAIL_ON_END)).booleanValue();
        }
======= b90c0a1:"test/org/apache/catalina/comet/TestCometProcessor.java"

                if (failOnBegin) {
                    throw new IOException("Fail on begin");
                }
                if (failOnRead) {
                    throw new IOException("Fail on read");
                }
======= b90c0a1:"test/org/apache/catalina/comet/TestCometProcessor.java"

                if (failOnEnd) {
                    throw new IOException("Fail on end");
                }

======= e70797e:"java/org/apache/catalina/connector/Response.java"

        if (location.startsWith("//")) {
            // Scheme relative
            redirectURLCC.recycle();
            // Add the scheme
            String scheme = request.getScheme();
                try {
                redirectURLCC.append(scheme, 0, scheme.length());
                redirectURLCC.append(':');
                redirectURLCC.append(location, 0, location.length());
                return redirectURLCC.toString();
            } catch (IOException e) {
                IllegalArgumentException iae =
                    new IllegalArgumentException(location);
                iae.initCause(e);
                throw iae;
            }
        } else if (leadingSlash || !hasScheme(location)) {

======= 3ab3757:"java/org/apache/catalina/Context.java"

    /**
     * Configures if a response body is included when a redirect response is
     * sent to the client.
     */
    public void setSendRedirectBody(boolean enable);
    
    /**
     * Dtermines if the context is configured to included a response body as
     * part of a redirect response.
     */
    public boolean getSendRedirectBody();
======= 3ab3757:"java/org/apache/catalina/connector/Response.java"

            if (getContext().getSendRedirectBody()) {
                PrintWriter writer = getWriter();
                writer.print(sm.getString("coyoteResponse.sendRedirect.note",
                        RequestUtil.filter(absolute)));
                flushBuffer();
            }
======= 3ab3757:"java/org/apache/catalina/core/StandardContext.java"

    private boolean sendRedirectBody = false;
    
    
    @Override
    public boolean getSendRedirectBody() {
        return sendRedirectBody;
    }
    @Override
    public void setSendRedirectBody(boolean sendRedirectBody) {
        this.sendRedirectBody = sendRedirectBody;
    }
      <attribute name="sendRedirectBody" required="false">
        <p>If <code>true</code>, redirect responses will include a short
        response body that includes details of the redirect as recommended by
        RFC 2616. This is disabled by default since including a response body
        may cause problems for some application component such as compression
        filters.</p>
      </attribute>
      

======= d6d1c6f:"java/org/apache/catalina/filters/RemoteAddrFilter.java"

        processCometEvent(event.getHttpServletRequest().getRemoteAddr(),
======= d6d1c6f:"java/org/apache/catalina/filters/RemoteAddrFilter.java"


======= b080c7e:"webapps/examples/WEB-INF/classes/async/Async0.java"


======= a450d2c:"java/org/apache/catalina/core/StandardWrapperValve.java"

        
        if (wrapper == null) {
            // Context has been shutdown. Nothing to do here.
            return;
        }

======= 136097e:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                long s = System.currentTimeMillis() + 10000;
                while (acceptors[i].isAlive() && serverSock != 0) {

======= 18792f4:"java/org/apache/catalina/connector/CoyoteAdapter.java"

======= 18792f4:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        } finally {
======= 18792f4:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

======= 18792f4:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

======= 18792f4:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        if (error) {
            adapter.log(request, response, 0);
        }
======= 18792f4:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

======= 18792f4:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

======= 18792f4:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

            if (!error && !cping && endpoint.isPaused()) {
======= 18792f4:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

            if (!error && !cping && endpoint.isPaused()) {
======= 18792f4:"java/org/apache/coyote/ajp/AjpProcessor.java"

            if (!error && !cping && endpoint.isPaused()) {
======= 18792f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

======= 18792f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

======= 18792f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

======= 18792f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

======= 18792f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

======= 18792f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        
        if (error) {
            adapter.log(request, response, 0);
        }
======= 18792f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

======= 18792f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

            // Can't add a 500 to the access log since that has already been
            // written in the Adapter.service method.

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private static final long serialVersionUID = 1L;
    private final Random random = new Random();
    @Override
    public String getAlgorithm() {
        return "INSECURE";
    }
    @Override
    public synchronized void setSeed(byte[] seed) {
        // Not implemented
    }
    @Override
    public synchronized void setSeed(long seed) {
        // The super class constructor calls this method earlier than our
        // fields are initialized. Ignore the call.
        if (random == null) {
            return;
        }
        random.setSeed(seed);
    }
    @Override
    public synchronized void nextBytes(byte[] bytes) {
        random.nextBytes(bytes);
    }
    @Override
    public byte[] generateSeed(int numBytes) {
        byte[] value = new byte[numBytes];
        nextBytes(value);
        return value;
    }
======= 73a6e56:"test/org/apache/catalina/startup/TomcatBaseTest.java"

======= 73a6e56:"test/org/apache/catalina/startup/TomcatBaseTest.java"

        tomcat = new TomcatWithFastSessionIDs();
======= 73a6e56:"test/org/apache/catalina/startup/TomcatBaseTest.java"

    private static class TomcatWithFastSessionIDs extends Tomcat {
        @Override
        public void start() throws LifecycleException {
            // Use fats, insecure session ID generation for all tests
            Server server = getServer();
            for (Service service : server.findServices()) {
                Container e = service.getContainer();
                for (Container h : e.findChildren()) {
                    for (Container c : h.findChildren()) {
                        StandardManager m = (StandardManager) c.getManager();
                        if (m == null) {
                            m = new StandardManager();
                            m.setSecureRandomClass(
                                    "org.apache.catalina.startup.FastNonSecureRandom");
                            c.setManager(m);
                        }
                    }
                }
            }
            super.start();
        }
    }

======= 66f2d5b:"java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java"

======= 66f2d5b:"java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java"

======= 66f2d5b:"java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java"

        super();
======= 66f2d5b:"java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java"

     * @param keyType Ignored
     * @param issuers Ignored
     * @param socket Ignored
======= 66f2d5b:"java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java"

    /**
     * Choose an alias to authenticate the client side of a secure socket,
     * given the public key type and the list of certificate issuer authorities
     * recognized by the peer (if any).
     *
     * @param keyType The key algorithm type name(s), ordered with the
     * most-preferred key type first
     * @param issuers The list of acceptable CA issuer subject names, or null
     * if it does not matter which issuers are used
     * @param engine Ignored
     *
     * @return The alias name for the desired key, or null if there are no
     * matches
     */
    @Override
    public String chooseEngineClientAlias(String[] keyType, Principal[] issuers,
            SSLEngine engine) {
        return delegate.chooseClientAlias(keyType, issuers, null);
    }
    /**
     * Returns this key manager's server key alias that was provided in the
     * constructor.
     *
     * @param keyType Ignored
     * @param issuers Ignored
     * @param engine Ignored
     *
     * @return Alias name for the desired key
     */
    @Override
    public String chooseEngineServerAlias(String keyType, Principal[] issuers,
            SSLEngine engine) {
        return serverKeyAlias;
    }

======= bfabec5:"java/javax/el/BeanELResolver.java"

                if (m.isVarArgs() && methodName.equals(m.getName()) && 
                            paramCount > m.getParameterTypes().length - 2 ) {
======= bfabec5:"java/javax/el/BeanELResolver.java"

                for (int i = 0; (i < varArgIndex); i++) {
                // Last parameter is the varargs
                final Object varargs = Array.newInstance(
                    varArgClass,
                    (paramCount - varArgIndex));
                    Array.set(varargs, i - varArgIndex,
                parameters[varArgIndex] = varargs;
======= bfabec5:"java/javax/el/BeanELResolver.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    public static class Foo {
        public String joinDelimited(String delim, String... strings) {
            StringBuilder result = new StringBuilder();
            if (strings != null) {
                for (String s : strings) {
                    if (delim != null && result.length() > 0) {
                        result.append(delim);
                    }
                    result.append(s);
                }
            }
            return result.toString();
        }
        public String join(String... strings) {
            return joinDelimited(null, strings);
        }
    }
    private Foo foo;
    private ELContext elContext;
    private BeanELResolver beanELResolver;
    @Before
    public void setup() {
        foo = new Foo();
        beanELResolver = new BeanELResolver();
        elContext = new ELContext() {
            private VariableMapper variableMapper = new VariableMapper() {
                private Map<String, ValueExpression> vars =
                    new HashMap<String, ValueExpression>();
                @Override
                public ValueExpression setVariable(String arg0,
                        ValueExpression arg1) {
                    return vars.put(arg0, arg1);
                }
                @Override
                public ValueExpression resolveVariable(String arg0) {
                    return vars.get(arg0);
                }
            };
            private FunctionMapper functionMapper = new FunctionMapper() {
                @Override
                public Method resolveFunction(String arg0, String arg1) {
                    return null;
                }
            };
            @Override
            public VariableMapper getVariableMapper() {
                return variableMapper;
            }
            @Override
            public FunctionMapper getFunctionMapper() {
                return functionMapper;
            }
            @Override
            public ELResolver getELResolver() {
                return beanELResolver;
            }
        };
    }
    /**
     * Tests varargs that come after an opening argument.
     */
    @Test
    public void testJoinDelimited() {
        Assert.assertEquals(foo.joinDelimited("-", "foo", "bar", "baz"),
            beanELResolver.invoke(elContext, foo, "joinDelimited", null,
                    new Object[] { "-", "foo", "bar", "baz" }));
    }
    /**
     * Tests varargs that constitute a method's only parameters, as well as
     * bogus results due to improper matching of ANY vararg method, and
     * depending on the order in which reflected methods are encountered.
     */
    @Test
    public void testJoin() {
        Assert.assertEquals(foo.join("foo", "bar", "baz"),
            beanELResolver.invoke(elContext, foo, "join", null,
                    new Object[] { "foo", "bar", "baz" }));
    }

======= feff880:"java/org/apache/catalina/startup/ExpandWar.java"

======= feff880:"java/org/apache/catalina/startup/ExpandWar.java"

                if(null == input)
                    throw new ZipException(sm.getString("expandWar.missingJarEntry", jarEntry.getName()));

======= 423fd89:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

     * Protect against the memory leak caused when the
     * <code>sun.java2d.Disposer</code> class is loaded by a web application.
     * Defaults to <code>false</code> because a new Thread is launched.
     */
    private boolean java2dDisposerProtection = false;
    public boolean isJava2DDisposerProtection() {
        return java2dDisposerProtection;
    }
    public void setJava2DDisposerProtection(boolean java2dDisposerProtection) {
        this.java2dDisposerProtection = java2dDisposerProtection;
    }
    /**
======= 423fd89:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

                // Trigger the creation of the "Java2D Disposer" thread.
                // See https://issues.apache.org/bugzilla/show_bug.cgi?id=51687
                if(java2dDisposerProtection) {
                    try {
                        Class.forName("sun.java2d.Disposer");
                    }
                    catch (ClassNotFoundException cnfe) {
                        // Ignore this case: we must be running on a
                        // non-Sun-based JRE.
                    }
                }
      <attribute name="java2DDisposerProtection" required="false">
        <p>Enables protection so that loading the
        <code>sun.java2d.Disposer</code> class by a web application does not
        result in a memory leak.
        Defaults to <code>false</code> because a thread is launched.</p>
      </attribute>

======= 9425437:"java/org/apache/coyote/http11/AbstractHttp11JsseProtocol.java"

    private String sslImplementationName = null;
    public String getSslImplementationName() { return sslImplementationName; }
    public void setSslImplementationName(String s) {
        this.sslImplementationName = s;
======= 9425437:"java/org/apache/coyote/http11/AbstractHttp11JsseProtocol.java"

        sslImplementation = SSLImplementation.getInstance(sslImplementationName);
======= 9425437:"test/org/apache/tomcat/util/net/TestCustomSsl.java"

        connector.setProperty("sslImplementationName", 
    <attribute name="sslImplementationName" required="false">

======= 58429a8:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                            if (wakeupCounter.getAndSet(-1) > 0) {
                            } else {

======= a2538ce:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

        // Swallow the unread body packet if present
        if (first && request.getContentLengthLong() > 0) {
            receive();
        }
======= a2538ce:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

                    // Unexpected packet type. Unread body packets should have
                    // been swallowed in finish().
                    if (log.isDebugEnabled()) {
                        log.debug("Unexpected message: " + type);
                    error = true;
                    break;
======= a2538ce:"java/org/apache/coyote/ajp/AjpNioProcessor.java"

                    // Unexpected packet type. Unread body packets should have
                    // been swallowed in finish().
                    if (log.isDebugEnabled()) {
                        log.debug("Unexpected message: " + type);
                    error = true;
                    break;
======= a2538ce:"java/org/apache/coyote/ajp/AjpProcessor.java"

                    // Unexpected packet type. Unread body packets should have
                    // been swallowed in finish().
                    if (log.isDebugEnabled()) {
                        log.debug("Unexpected message: " + type);
                    error = true;
                    break;

======= 3513acc:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

                saved.setMethod("GET");
======= 3513acc:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

                saved.setMethod("GET");

======= 196a8f5:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"


======= 87a32d6:"java/org/apache/catalina/ha/session/BackupManager.java"

     * Timeout for RPC messages.
     */
    private long rpcTimeout = DEFAULT_REPL_TIMEOUT;
    /**
======= 87a32d6:"java/org/apache/catalina/ha/session/BackupManager.java"

                                                          rpcTimeout,
======= 87a32d6:"java/org/apache/catalina/ha/session/BackupManager.java"

    public void setRpcTimeout(long rpcTimeout) {
        this.rpcTimeout = rpcTimeout;
    }
    public long getRpcTimeout() {
        return rpcTimeout;
    }
======= 87a32d6:"java/org/apache/catalina/ha/session/BackupManager.java"

        result.rpcTimeout = rpcTimeout;
    <attribute
      name="rpcTimeout"
      description="Timeout for RPC messages, how long we will wait for a reply"
      type="long"/>
======= 87a32d6:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        // No destination.
        if (channel.getMembers().length == 0 ) return;
            if (resp.length > 0) {
                for (int i = 0; i < resp.length; i++) {
                    mapMemberAdded(resp[i].getSource());
                    messageReceived(resp[i].getMessage(), resp[i].getSource());
                }
            } else {
                log.warn("broadcast 0 replies, probably a timeout.");
      <attribute name="rpcTimeout" required="false">
        Timeout for RPC message used for broadcast and transfer state from 
        another map.
        Default value is <code>15000</code> milliseconds.
      </attribute>

======= 4587f13:"java/org/apache/catalina/core/StandardContext.java"

        if (!dir.mkdirs() && !dir.isDirectory()) {
======= 4587f13:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                        }
                                        File parentFile = resourceFile.getParentFile();
                                        if (!parentFile.mkdirs() && !parentFile.exists()) {
                                            // Ignore the error (like the IOExceptions below)
                                        }
======= 4587f13:"java/org/apache/catalina/loader/WebappLoader.java"

                if (!classRepository.mkdirs() &&
                        !classRepository.isDirectory()) {
                    throw new IOException(
                            sm.getString("webappLoader.mkdirFailure"));
======= 4587f13:"java/org/apache/catalina/loader/WebappLoader.java"

                if (!destDir.mkdirs() && !destDir.isDirectory()) {
                    throw new IOException(
                            sm.getString("webappLoader.mkdirFailure"));
======= 4587f13:"java/org/apache/catalina/manager/ManagerServlet.java"

            if (!deployedPath.mkdirs() && !deployedPath.isDirectory()) {
======= 4587f13:"java/org/apache/catalina/manager/ManagerServlet.java"

                        if (!configBase.mkdirs() && !configBase.isDirectory()) {
======= 4587f13:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

        if (!appBaseFile.mkdirs() && !appBaseFile.isDirectory()) {
            writer.println(smClient.getString(
                    "hostManagerServlet.appBaseCreateFail",
                    appBaseFile.toString(), name));
            return;
======= 4587f13:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

        if (!configBase.mkdirs() && !configBase.isDirectory()) {
            return null;
======= 4587f13:"java/org/apache/catalina/servlets/CGIServlet.java"

            if (!dir.mkdirs() && !dir.isDirectory()) {
                if (debug >= 2) {
                    log("expandCGIScript: failed to create directories for '" +
                            dir.getAbsolutePath() + "'");
                }
======= 4587f13:"java/org/apache/catalina/session/FileStore.java"

    private File directory() throws IOException {
======= 4587f13:"java/org/apache/catalina/session/FileStore.java"

            if (!file.delete() && file.exists()) {
                throw new IOException(
                        sm.getString("fileStore.deleteFailed", file));
            }
            if (!file.mkdirs() && !file.isDirectory()) {
                throw new IOException(
                        sm.getString("fileStore.createFailed", file));
            }
======= 4587f13:"java/org/apache/catalina/session/FileStore.java"

    private File file(String id) throws IOException {
======= 4587f13:"java/org/apache/catalina/startup/ExpandWar.java"

                    if (!parent.mkdirs() && !parent.isDirectory()) {
                        throw new IOException(
                                sm.getString("expandWar.createFailed", parent));
                    }
======= 4587f13:"java/org/apache/catalina/startup/HostConfig.java"

                if (!dirs[i].mkdirs() && !dirs[i].isDirectory()) {
======= 4587f13:"java/org/apache/catalina/valves/AccessLogValve.java"

        if (!dir.mkdirs() && !dir.isDirectory()) {
            log.error(sm.getString("accessLogValve.openDirFail", dir));
======= 4587f13:"java/org/apache/catalina/valves/AccessLogValve.java"

        if (!parent.mkdirs() && !parent.isDirectory()) {
            log.error(sm.getString("accessLogValve.openDirFail", parent));
======= 4587f13:"java/org/apache/jasper/JspCompilationContext.java"

            return (outDirFile.mkdirs() || outDirFile.isDirectory());
======= 4587f13:"java/org/apache/juli/FileHandler.java"

        if (!dir.mkdirs() && !dir.isDirectory()) {
======= 4587f13:"java/org/apache/juli/FileHandler.java"

            if (!parent.mkdirs() && !parent.isDirectory()) {
                reportError("Unable to create [" + parent + "]", null,
                        ErrorManager.OPEN_FAILURE);
                writer = null;
                return;
======= 4587f13:"test/org/apache/catalina/connector/TestCoyoteAdapter.java"

        if (!foo.mkdirs() && !foo.isDirectory()) {
======= 4587f13:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        if (!foo.mkdirs() && !foo.isDirectory()) {
======= 4587f13:"test/org/apache/catalina/core/TestStandardContext.java"

        if (!docBase.mkdirs() && !docBase.isDirectory()) {
======= 4587f13:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

        if (!webInf.mkdirs() && !webInf.isDirectory()) {
======= 4587f13:"test/org/apache/catalina/servlets/TestDefaultServlet.java"

        if (!webInf.mkdirs() && !webInf.isDirectory()) {
======= 4587f13:"test/org/apache/catalina/startup/TomcatBaseTest.java"

        if (!tempDir.mkdirs() && !tempDir.isDirectory()) {

======= 25f02b4:"java/org/apache/catalina/startup/Tomcat.java"

======= 25f02b4:"java/org/apache/catalina/startup/Tomcat.java"

======= 25f02b4:"test/org/apache/catalina/startup/TestTomcat.java"

======= 25f02b4:"test/org/apache/catalina/startup/TestTomcat.java"

     * Simple servlet to test in-line registration.
======= 25f02b4:"test/org/apache/catalina/startup/TestTomcat.java"

     * Simple servlet to test the default session manager.
     */
    public static class HelloWorldSession extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        public void doGet(HttpServletRequest req, HttpServletResponse res) 
                throws IOException {
            HttpSession s = req.getSession(true);
            s.getId();
            res.getWriter().write("Hello world");
        }
    }
    /**
======= 25f02b4:"test/org/apache/catalina/startup/TestTomcat.java"

    public void testSession() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        
        // Must have a real docBase - just use temp
        org.apache.catalina.Context ctx = 
            tomcat.addContext("", System.getProperty("java.io.tmpdir"));
        // You can customize the context by calling 
        // its API
        
        Tomcat.addServlet(ctx, "myServlet", new HelloWorldSession());
        ctx.addServletMapping("/", "myServlet");
        
        tomcat.start();
        
        ByteChunk res = getUrl("http://localhost:" + getPort() + "/");
        assertEquals("Hello world", res.toString());
    }
    @Test

======= 517fd9b:"java/org/apache/catalina/connector/Connector.java"

            log.error(sm.getString(
                    "coyoteConnector.protocolHandlerInstantiationFailed", e), e);

======= 0cdbfa6:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

    /**
     * Protect against the memory leak caused when the first call to
     * <code>java.awt.Toolkit.getDefaultToolkit()</code> is triggered
     * by a web application. Defaults to <code>false</code> because a new
     * Thread is launched.
     */
    private boolean awtThreadProtection = false;
    public boolean isAWTThreadProtection() { return awtThreadProtection; }
    public void setAWTThreadProtection(boolean awtThreadProtection) {
      this.awtThreadProtection = awtThreadProtection;
    }
======= 0cdbfa6:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

                // Trigger the creation of the AWT (AWT-Windows, AWT-XAWT,
                // etc.) thread
                if (awtThreadProtection) {
                  java.awt.Toolkit.getDefaultToolkit();
                }
      <attribute name="AWTThreadProtection" required="false">
        <p>Enables protection so that calls to
        <code>java.awt.Toolkit.getDefaultToolkit()</code> triggered by a web
        application do not result in a memory leak.
        Defaults to <code>false</code> because an AWT thread is launched.</p>
      </attribute>

======= bf4a544:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

                        socket.getSocket().longValue(), true);
======= bf4a544:"java/org/apache/coyote/http11/Http11AprProtocol.java"

                        socket.getSocket().longValue(), true);
======= bf4a544:"java/org/apache/coyote/http11/Http11AprProtocol.java"

                        socket.getSocket().longValue(), false);
======= bf4a544:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        // Need two pollsets since the socketTimeout and the keep-alive timeout
        // can have different values.
        private long connectionPollset = 0;
        private long keepAlivePollset = 0;
        private long pool = 0;
        private long[] desc;
        private long[] addSocket;
        private boolean[] addSocketKeepAlive;
        
        private volatile int addCount = 0;
        private boolean comet = true;
        private boolean separateKeepAlive = false;
======= bf4a544:"java/org/apache/tomcat/util/net/AprEndpoint.java"

         * Create the poller. With some versions of APR, the maximum poller size
         * will be 62 (recompiling APR is necessary to remove this limitation).
            int keepAliveTimeout = getKeepAliveTimeout();
            int socketTimeout = socketProperties.getSoTimeout();
            if (keepAliveTimeout > 0 && !comet) {
                separateKeepAlive = true;
            connectionPollset = allocatePoller(size, pool, socketTimeout);
            if (separateKeepAlive) {
                keepAlivePollset = allocatePoller(size, pool, keepAliveTimeout);
            }
            if (connectionPollset == 0 && size > 1024) {
                connectionPollset = allocatePoller(size, pool, socketTimeout);
                if (separateKeepAlive) {
                    keepAlivePollset =
                        allocatePoller(size, pool, keepAliveTimeout);
                }
            if (connectionPollset == 0) {
                connectionPollset = allocatePoller(size, pool, socketTimeout);
                if (separateKeepAlive) {
                    keepAlivePollset =
                        allocatePoller(size, pool, keepAliveTimeout);
                }
            addSocket = new long[size];
            addSocketKeepAlive = new boolean[size];
======= bf4a544:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    processSocket(addSocket[i], SocketStatus.STOP);
                    destroySocket(addSocket[i]);
            // Close all sockets still in the pollers
            closePollset(connectionPollset);
            if (separateKeepAlive) {
                closePollset(keepAlivePollset);
======= bf4a544:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        private void closePollset(long pollset) {
            int rv = Poll.pollset(pollset, desc);
            if (rv > 0) {
                for (int n = 0; n < rv; n++) {
                    if (comet) {
                        processSocket(desc[n*2+1], SocketStatus.STOP);
                    } else {
                        destroySocket(desc[n*2+1]);
                    }
                }
            }
        }
======= bf4a544:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        public void add(long socket, boolean keepAlive) {
                if (addCount >= addSocket.length) {
======= bf4a544:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                addSocket[addCount] = socket;
                addSocketKeepAlive[addCount] = keepAlive;
======= bf4a544:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                    int rv;
                                    if (separateKeepAlive && addSocketKeepAlive[i]) {
                                        rv = Poll.add(keepAlivePollset,
                                                addSocket[i], Poll.APR_POLLIN);
                                    } else {
                                        rv = Poll.add(connectionPollset,
                                                addSocket[i], Poll.APR_POLLIN);
                                    }
                                            processSocket(addSocket[i], SocketStatus.ERROR);
                                            destroySocket(addSocket[i]);
======= bf4a544:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    // Poll for the specified interval
                    if (doPoll(connectionPollset)) {
                        continue;
                    if (separateKeepAlive && doPoll(keepAlivePollset)) {
                        continue;
                    }
                    // Check timeouts (much less frequently that polling)
                    if (maintainTime > 1000000L && running) {
                        if (socketProperties.getSoTimeout() > 0) {
                            doTimeout(connectionPollset);
                        }
                        if (separateKeepAlive) {
                            doTimeout(keepAlivePollset);
======= bf4a544:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        private boolean doPoll(long pollset) {
            int rv = Poll.poll(pollset, pollTime, desc, true);
            if (rv > 0) {
                keepAliveCount -= rv;
                for (int n = 0; n < rv; n++) {
                    // Check for failed sockets and hand this socket off to a worker
                    if (((desc[n*2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP)
                            || ((desc[n*2] & Poll.APR_POLLERR) == Poll.APR_POLLERR)
                            || (comet && (!processSocket(desc[n*2+1], SocketStatus.OPEN)))
                            || (!comet && (!processSocket(desc[n*2+1])))) {
                        // Close socket and clear pool
                        if (comet) {
                            processSocket(desc[n*2+1], SocketStatus.DISCONNECT);
                        } else {
                            destroySocket(desc[n*2+1]);
                        }
                        return true;
                    }
                }
            } else if (rv < 0) {
                int errn = -rv;
                /* Any non timeup or interrupted error is critical */
                if ((errn != Status.TIMEUP) && (errn != Status.EINTR)) {
                    if (errn >  Status.APR_OS_START_USERERR) {
                        errn -=  Status.APR_OS_START_USERERR;
                    }
                    log.error(sm.getString("endpoint.poll.fail", "" + errn, Error.strerror(errn)));
                    // Handle poll critical failure
                    synchronized (this) {
                        destroy();
                        init();
                    }
                    return true;
                }
            }
            return false;
        }
        private void doTimeout(long pollset) {
            int rv = Poll.maintain(pollset, desc, true);
            if (rv > 0) {
                keepAliveCount -= rv;
                for (int n = 0; n < rv; n++) {
                    // Close socket and clear pool
                    if (comet) {
                        processSocket(desc[n], SocketStatus.TIMEOUT);
                    } else {
                        destroySocket(desc[n]);
                    }
                }
            }
        }
    }
======= bf4a544:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                    getPoller().add(state.socket, true);
======= bf4a544:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                        getPoller().add(socket.getSocket().longValue(), false);

======= 5d55842:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                    ((Host) request.mappingData.host).logAccess(

======= c4d1631:"java/org/apache/catalina/startup/HostConfig.java"

        if (!appBase().isDirectory()) {
            log.error(sm.getString(
                    "hostConfig.appBase", host.getName(), appBase().getPath()));
            host.setDeployOnStartup(false);
            host.setAutoDeploy(false);
        }

======= 7562fc1:"java/org/apache/catalina/util/RequestUtil.java"

     * @param encoding The encoding to use; encoding must not be null.
     * If an unsupported encoding is specified the parameters will not be
======= 7562fc1:"java/org/apache/catalina/util/RequestUtil.java"

            // given string so that the encoding is not lost.
                bytes = data.getBytes(B2CConverter.getCharset(encoding));

======= 841e9fc:"java/org/apache/jasper/compiler/DefaultErrorHandler.java"

======= 841e9fc:"java/org/apache/jasper/compiler/DefaultErrorHandler.java"

                buf.append(Constants.NEWLINE);
                buf.append(Constants.NEWLINE);
                buf.append(Constants.NEWLINE);
                buf.append(Constants.NEWLINE);
                buf.append(Constants.NEWLINE);
                buf.append(Constants.NEWLINE);
                buf.append(Constants.NEWLINE);
        buf.append(Constants.NEWLINE);
        buf.append(Constants.NEWLINE);
        buf.append("Stacktrace:");
======= 841e9fc:"java/org/apache/jasper/compiler/ErrorDispatcher.java"

======= 841e9fc:"java/org/apache/jasper/compiler/ErrorDispatcher.java"

                errMsgBuf.append(Constants.NEWLINE);

======= bb7072c:"java/org/apache/naming/resources/DirContextURLConnection.java"

                // Strip off the hostname and the contextpath (note that context
                // path may contain '/'
                if (context instanceof ProxyDirContext) {
                    String cp = ((ProxyDirContext)context).getContextPath();
                    String h = ((ProxyDirContext)context).getHostName();
                    if ("".equals(cp)) {
                        start = h.length() + 2;
                    } else {
                        start = h.length() + cp.length() + 2;
                    }
                } else {
                }

======= cd2fecd:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

======= cd2fecd:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

     * <code>com.sun.jndi.ldap.LdapPoolManager</code> class spawns a thread when
     * it is initialized if the system property
======= cd2fecd:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

    /**
     * The first access to {@link DriverManager} will trigger the loading of
     * all {@link java.sql.Driver}s in the the current class loader. The web
     * application level memory leak protection can take care of this in most
     * cases but triggering the loading here has fewer side-effects. 
     */
    private boolean driverManagerProtection = true;
    public boolean isDriverManagerProtection() {
        return driverManagerProtection;
    }
    public void setDriverManagerProtection(boolean driverManagerProtection) {
        this.driverManagerProtection = driverManagerProtection;
    }
======= cd2fecd:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

                 * First call to this loads all drivers in the current class
                 * loader
                 */
                if (driverManagerProtection) {
                    DriverManager.getDrivers();
                }
                /*
      <attribute name="driverManagerProtection" required="false">
        <p>The first use of <code>java.sql.DriverManager</code> will trigger the
        loading of JDBNC Driver in the the current class loader. The web
        application level memory leak protection can take care of this in most
        cases but triggering the loading here has fewer side-effects. The
        default is <code>true</code></p>
      </attribute>

======= 7ffca5b:"java/org/apache/coyote/http11/Http11NioProtocol.java"

            Http11NioProcessor processor =
                connections.remove(socket.getSocket());

======= 8c41e9c:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            connection = driver.connect(driverURL, properties);

======= ed0588b:"java/org/apache/catalina/util/LifecycleBase.java"

======= ed0588b:"java/org/apache/catalina/util/LifecycleBase.java"

        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            throw new LifecycleException(
                    sm.getString("lifecycleBase.initFail",toString()), t);
======= ed0588b:"java/org/apache/catalina/util/LifecycleBase.java"

        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            throw new LifecycleException(
                    sm.getString("lifecycleBase.startFail",toString()), t);
======= ed0588b:"java/org/apache/catalina/util/LifecycleBase.java"

        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            throw new LifecycleException(
                    sm.getString("lifecycleBase.stopFail",toString()), t);
======= ed0588b:"java/org/apache/catalina/util/LifecycleBase.java"

        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            throw new LifecycleException(
                    sm.getString("lifecycleBase.destroyFail",toString()), t);
        <bug>51610</bug>: If an unchecked exception occurs during a lifecycle
        transition (e.g. web application start) ensure that the component is
        put into the failed state. (markt)
      </fix>
      <fix>

======= 29e9966:"java/org/apache/catalina/session/StoreBase.java"

                if (manager instanceof PersistentManagerBase) {
                    isLoaded = ((PersistentManagerBase) manager).isLoaded(keys[i]);
                } else {
                    try {
                        if (manager.findSession(keys[i]) != null) {
                            isLoaded = true;
                        }
                    } catch (IOException ioe) {
                        // Ignore - session will be expired
      <fix>
        <bug>51614</bug>: Avoid two times calls of store.load() and 
        session.expire() in PersistentManager. (kfujino)
      </fix>

======= 77213bb:"java/org/apache/catalina/valves/AccessLogValve.java"

    protected AccessLogElement createAccessLogElement(String header, char pattern) {
======= 77213bb:"java/org/apache/catalina/valves/AccessLogValve.java"

    protected AccessLogElement createAccessLogElement(char pattern) {
      <fix>
        <bug>51588</bug>: Make it easier to extend the AccessLogValve to add
        support for custom elements. (markt)
      </fix>

======= 0b340ac:"java/org/apache/catalina/startup/ContextConfig.java"

        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            log.warn(sm.getString("contextConfig.invalidSciHandlesTypes",
                    className), t);
            return;
      <fix>
        <bug>51586</bug>: Expand error handling to cover anything that is
        recoverable (or might be recoverable) when loading classes during
        HandlesTypes processing. (markt)
      </fix>

======= 6200dd9:"java/org/apache/coyote/http11/AbstractInputBuffer.java"

    protected static final boolean[] HTTP_TOKEN_CHAR = new boolean[128];
======= 6200dd9:"java/org/apache/coyote/http11/AbstractInputBuffer.java"

    static {
        for (int i = 0; i < 128; i++) {
            if (i < 32) {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == 127) {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '(') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == ')') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '<') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '>') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '@') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == ',') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == ';') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == ':') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '\\') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '\"') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '/') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '[') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == ']') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '?') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '=') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '{') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '}') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == ' ') {
                HTTP_TOKEN_CHAR[i] = false;
            } else if (i == '\t') {
                HTTP_TOKEN_CHAR[i] = false;
            } else {
                HTTP_TOKEN_CHAR[i] = true;
            }
        }
    }
======= 6200dd9:"java/org/apache/coyote/http11/AbstractInputBuffer.java"

    public abstract boolean parseRequestLine(boolean useAvailableDataOnly) throws IOException;
    
    public abstract boolean parseHeaders() throws IOException;
    
    protected abstract boolean fill(boolean block) throws IOException; 
======= 6200dd9:"java/org/apache/coyote/http11/AbstractInputBuffer.java"

======= 6200dd9:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

======= 6200dd9:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

    private static final Log log =
        LogFactory.getLog(InternalAprInputBuffer.class);
======= 6200dd9:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

            } else if (!HTTP_TOKEN_CHAR[buf[pos]]) {
                // If a non-token header is detected, skip the line and
                // ignore the header
                skipLine(start);
                return true;
======= 6200dd9:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

    private void skipLine(int start) throws IOException {
        boolean eol = false;
        int lastRealByte = start;
        if (pos - 1 > start) {
            lastRealByte = pos - 1;
        }
        
        while (!eol) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill())
                    throw new EOFException(sm.getString("iib.eof.error"));
            }
            if (buf[pos] == Constants.CR) {
                // Skip
            } else if (buf[pos] == Constants.LF) {
                eol = true;
            } else {
                lastRealByte = pos;
            }
            pos++;
        }
        if (log.isDebugEnabled()) {
            log.debug(sm.getString("iib.invalidheader", new String(buf, start,
                    lastRealByte - start + 1, Charset.forName("ISO-8859-1"))));
        }
    }
    
    
======= 6200dd9:"java/org/apache/coyote/http11/InternalInputBuffer.java"

======= 6200dd9:"java/org/apache/coyote/http11/InternalInputBuffer.java"

    private static final Log log = LogFactory.getLog(InternalInputBuffer.class);
======= 6200dd9:"java/org/apache/coyote/http11/InternalInputBuffer.java"

            } else if (!HTTP_TOKEN_CHAR[buf[pos]]) {
                // If a non-token header is detected, skip the line and
                // ignore the header
                skipLine(start);
                return true;
======= 6200dd9:"java/org/apache/coyote/http11/InternalInputBuffer.java"

    private void skipLine(int start) throws IOException {
        boolean eol = false;
        int lastRealByte = start;
        if (pos - 1 > start) {
            lastRealByte = pos - 1;
        }
        
        while (!eol) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill())
                    throw new EOFException(sm.getString("iib.eof.error"));
            }
            if (buf[pos] == Constants.CR) {
                // Skip
            } else if (buf[pos] == Constants.LF) {
                eol = true;
            } else {
                lastRealByte = pos;
            }
            pos++;
        }
        if (log.isDebugEnabled()) {
            log.debug(sm.getString("iib.invalidheader", new String(buf, start,
                    lastRealByte - start + 1, Charset.forName("ISO-8859-1"))));
        }
    }
======= 6200dd9:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

======= 6200dd9:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

======= 6200dd9:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

    enum HeaderParsePosition {HEADER_START, HEADER_NAME, HEADER_VALUE,
        HEADER_MULTI_LINE, HEADER_SKIPLINE}
======= 6200dd9:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            } else if (!HTTP_TOKEN_CHAR[buf[pos]]) {
                // If a non-token header is detected, skip the line and
                // ignore the header
                return skipLine();
======= 6200dd9:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

        while (headerParsePos == HeaderParsePosition.HEADER_SKIPLINE) {
            return skipLine();
        }
======= 6200dd9:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

    private HeaderParseStatus skipLine() throws IOException {
        headerParsePos = HeaderParsePosition.HEADER_SKIPLINE;
        boolean eol = false;
        // Reading bytes until the end of the line
        while (!eol) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill(true,false)) {
                    return HeaderParseStatus.NEED_MORE_DATA;
                }
            }
            if (buf[pos] == Constants.CR) {
                // Skip
            } else if (buf[pos] == Constants.LF) {
                eol = true;
            } else {
                headerData.lastSignificantChar = pos;
            }
            pos++;
        }
        if (log.isDebugEnabled()) {
            log.debug(sm.getString("iib.invalidheader", new String(buf,
                    headerData.start,
                    headerData.lastSignificantChar - headerData.start + 1,
                    DEFAULT_CHARSET)));
        }
        headerParsePos = HeaderParsePosition.HEADER_START;
        return HeaderParseStatus.HAVE_MORE_HEADERS;
    }
======= 6200dd9:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

======= 6200dd9:"test/org/apache/coyote/http11/TestInternalInputBuffer.java"

    @Test
    public void testBug51557NoColon() {
        
        Bug51557Client client = new Bug51557Client("X-Bug51557NoColon");
        client.setPort(getPort());
        
        client.doRequest();
        assertTrue(client.isResponse200());
        assertEquals("abcd", client.getResponseBody());
        assertTrue(client.isResponseBodyOK());
    }
    
    @Test
    public void testBug51557Separators() throws Exception {
        char httpSeparators[] = new char[] {
                '\t', ' ', '\"', '(', ')', ',', '/', ':', ';', '<',
                '=', '>', '?', '@', '[', '\\', ']', '{', '}' };
        
        for (char s : httpSeparators) {
            doTestBug51557Char(s);
            tearDown();
            setUp();
        }
    }
    @Test
    public void testBug51557Ctl() throws Exception {
        for (int i = 0; i < 31; i++) {
            doTestBug51557Char((char) i);
            tearDown();
            setUp();
        }
        doTestBug51557Char((char) 127);
    }
    @Test
    public void testBug51557Continuation() {
        
        Bug51557Client client = new Bug51557Client("X-Bug=51557NoColon",
                "foo" + SimpleHttpClient.CRLF + " bar");
        client.setPort(getPort());
        
        client.doRequest();
        assertTrue(client.isResponse200());
        assertEquals("abcd", client.getResponseBody());
        assertTrue(client.isResponseBodyOK());
    }
    
    @Test
    public void testBug51557BoundaryStart() {
        
        Bug51557Client client = new Bug51557Client("=X-Bug51557",
                "invalid");
        client.setPort(getPort());
        
        client.doRequest();
        assertTrue(client.isResponse200());
        assertEquals("abcd", client.getResponseBody());
        assertTrue(client.isResponseBodyOK());
    }
    
    @Test
    public void testBug51557BoundaryEnd() {
        
        Bug51557Client client = new Bug51557Client("X-Bug51557=",
                "invalid");
        client.setPort(getPort());
        
        client.doRequest();
        assertTrue(client.isResponse200());
        assertEquals("abcd", client.getResponseBody());
        assertTrue(client.isResponseBodyOK());
    }
    
    private void doTestBug51557Char(char s) {
        Bug51557Client client =
            new Bug51557Client("X-Bug" + s + "51557", "invalid");
        client.setPort(getPort());
        client.doRequest();
        assertTrue(client.isResponse200());
        assertEquals("abcd", client.getResponseBody());
        assertTrue(client.isResponseBodyOK());
    }
    
    /**
     * Bug 51557 test client.
     */
    private class Bug51557Client extends SimpleHttpClient {
        private String headerName;
        private String headerLine;
        public Bug51557Client(String headerName) {
            this.headerName = headerName;
            this.headerLine = headerName;
        }
        public Bug51557Client(String headerName, String headerValue) {
            this.headerName = headerName;
            this.headerLine = headerName + ": " + headerValue;
        }
        private Exception doRequest() {
        
            Tomcat tomcat = getTomcatInstance();
            
            Context root = tomcat.addContext("", TEMP_DIR);
            Tomcat.addServlet(root, "Bug51557",
                    new Bug51557Servlet(headerName));
            root.addServletMapping("/test", "Bug51557");
            try {
                tomcat.start();
                // Open connection
                connect();
                
                String[] request = new String[1];
                request[0] =
                    "GET http://localhost:8080/test HTTP/1.1" + CRLF +
                    headerLine + CRLF +
                    "X-Bug51557: abcd" + CRLF +
                    "Connection: close" + CRLF +
                    CRLF;
                
                setRequest(request);
                processRequest(); // blocks until response has been read
                
                // Close the connection
                disconnect();
            } catch (Exception e) {
                return e;
            }
            return null;
        }
        @Override
        public boolean isResponseBodyOK() {
            if (getResponseBody() == null) {
                return false;
            }
            if (!getResponseBody().contains("abcd")) {
                return false;
            }
            return true;
        }
        
    }
    private static class Bug51557Servlet extends HttpServlet {
        
        private static final long serialVersionUID = 1L;
        private String invalidHeaderName;
        /**
         * @param invalidHeaderName The header name should be invalid and
         *                          therefore ignored by the header parsing code
         */
        public Bug51557Servlet(String invalidHeaderName) {
            this.invalidHeaderName = invalidHeaderName;
        }
        /**
         * Only interested in the request headers from a GET request
         */
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            // Just echo the header value back as plain text
            resp.setContentType("text/plain");
            
            PrintWriter out = resp.getWriter();
            
            processHeaders(invalidHeaderName, req, out);
            processHeaders("X-Bug51557", req, out);
        }
        
        private void processHeaders(String header, HttpServletRequest req,
                PrintWriter out) {
            Enumeration<String> values = req.getHeaders(header);
            while (values.hasMoreElements()) {
                out.println(values.nextElement());
            }
        }
    }
      <fix>
        <bug>51557</bug>: Ignore HTTP headers that do not comply with RFC 2616
        and use header names that are not tokens. (markt)
      </fix>

======= 00a1fdf:"java/org/apache/catalina/valves/ExtendedAccessLogValve.java"

 * <li><code>x-threadname</code>: Current request thread name (can compare later with stacktraces)</li>
======= 00a1fdf:"java/org/apache/catalina/valves/ExtendedAccessLogValve.java"

        if ("threadname".equals(token)) {
            return new ThreadNameElement();
        }
        Move the SetCharacterEncoding filter from the examples web application
      <add>
        Add x-threadname pattern format token to ExtendedAccessLogValve to log
        the current request thread name. Based on a patch from Felix Schumacher.
        (timw)
      </add>
    <li><b>%I</b> - Current request thread name (can compare later with stacktraces)</li>
    <li><b>x-threadname</b> - Current request thread name (can compare later with stacktraces)</li>

======= 95d67fe:"java/org/apache/catalina/Lifecycle.java"

======= 95d67fe:"java/org/apache/catalina/Lifecycle.java"

 *            start()
 *  -----------------------------
 *  |                           |
 *  | init()                    |
 * NEW ->-- INITIALIZING        |
 * | |           |              |     ------------------<-----------------------
 * | |           |auto          |     |                                        |
 * | |          \|/    start() \|/   \|/     auto          auto         stop() |
 * | |      INITIALIZED -->-- STARTING_PREP -->- STARTING -->- STARTED -->---  |
 * | |         |                                                  |         |  |
 * | |         |                                                  |         |  |
 * | |         |                                                  |         |  |
 * | |destroy()|                                                  |         |  |
 * | -->-----<--       auto                    auto               |         |  |
 * |     |       ---------<----- MUST_STOP ---------------------<--         |  |
 * |     |       |                                                          |  |
 * |    \|/      ---------------------------<--------------------------------  ^
 * |     |       |                                                             |
 * |     |      \|/            auto                 auto              start()  |
 * |     |  STOPPING_PREP ------>----- STOPPING ------>----- STOPPED ---->------
 * |     |                                ^                  |  |  ^
 * |     |               stop()           |                  |  |  |
 * |     |       --------------------------                  |  |  |
 * |     |       |                                  auto     |  |  |
 * |     |       |                  MUST_DESTROY------<-------  |  |
 * |     |       |                    |                         |  |
 * |     |       |                    |auto                     |  |
 * |     |       |    destroy()      \|/              destroy() |  |
 * |     |    FAILED ---->------ DESTROYING ---<-----------------  |
 * |     |                        ^     |                          |
 * |     |     destroy()          |     |auto                      |
 * |     -------->-----------------    \|/                         |
======= 95d67fe:"java/org/apache/catalina/Lifecycle.java"

 * TODO: Not all components may transition from STOPPED to STARTING_PREP. These
 *       components should use MUST_DESTROY to signal this.
======= 95d67fe:"java/org/apache/catalina/util/LifecycleBase.java"

                !state.equals(LifecycleState.NEW) &&
                !state.equals(LifecycleState.INITIALIZED)) {
      <fix>
        <bug>51555</bug>: Allow destroy() to be called on Lifecycle components
        that are in the initialized state. (markt)
      </fix>

======= 8baaa98:"java/org/apache/catalina/connector/ResponseFacade.java"

                (sm.getString("coyoteResponse.setBufferSize.ise"));
======= 8baaa98:"java/org/apache/catalina/connector/ResponseFacade.java"

                (sm.getString("coyoteResponse.resetBuffer.ise"));
======= 8baaa98:"java/org/apache/catalina/connector/ResponseFacade.java"

                (sm.getString("coyoteResponse.reset.ise"));
======= 8baaa98:"java/org/apache/catalina/connector/ResponseFacade.java"

                (sm.getString("coyoteResponse.sendError.ise"));
======= 8baaa98:"java/org/apache/catalina/connector/ResponseFacade.java"

                (sm.getString("coyoteResponse.sendError.ise"));
======= 8baaa98:"java/org/apache/catalina/connector/ResponseFacade.java"

                (sm.getString("coyoteResponse.sendRedirect.ise"));
        <bug>41709</bug>: Provide exception messages where no message is
        provided currently for IllegalStateExcpetions triggered by calling
        HttpServletResponse methods when the reponse is committed. (markt)
      </fix>
      <fix>

======= 4d9fcc0:"java/org/apache/tomcat/jni/SSL.java"

    public static final int SSL_PROTOCOL_ALL   = (SSL_PROTOCOL_SSLV3|SSL_PROTOCOL_TLSV1);

======= bcee77d:"java/org/apache/jasper/compiler/Compiler.java"

                String key = include.getKey();
                URL includeUrl;
                if (key.startsWith("jar:")) {
                    includeUrl = new URL(key);
                } else {
                    includeUrl = ctxt.getResource(include.getKey());
                }
  <subsection name="Jasper">
    <changelog>
      <fix>
        <bug>51532</bug>: JSP files with dependencies in JARs were recompiled on
        every access leading to poor performance. (markt)
      </fix>
    </changelog>
  </subsection>

======= 400745e:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

            synchronized (cache) {
                cache.put(key, null);
            }
            synchronized (cache) {
                return cache.containsKey(key);
            }
======= 400745e:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    /**
     * When this test fails, it tends to enter a long running loop but it will
     * eventually finish (after ~70s on a 8-core Windows box).
     */
    public void testLruCacheConcurrency() throws Exception {
        int threadCount = 2;
        long iterationCount = 100000L;
        
        assertTrue(threadCount > 1);
        LruCache<String> cache = new LruCache<String>(threadCount - 1);
        
        LruTestThread[] threads = new LruTestThread[threadCount];
        for (int i = 0; i < threadCount; i++) {
            threads[i] = new LruTestThread(cache, iterationCount);
        }
        
        for (int i = 0; i < threadCount; i++) {
            threads[i].start();
        }
        for (int i = 0; i < threadCount; i++) {
            threads[i].join();
        }
        for (int i = 0; i < threadCount; i++) {
            assertTrue(threads[i].getResult());
        }
    }
    private static class LruTestThread extends Thread {
        private final LruCache<String> cache;
        private long iterationCount = 0;
        private volatile boolean result = false;
        public LruTestThread(LruCache<String> cache, long iterationCount) {
            this.cache = cache;
            this.iterationCount = iterationCount;
        }
        public boolean getResult() {
            return result;
        }
        @Override
        public void run() {
            String test = getName();
            try {
                for (long i = 0; i < iterationCount; i++) {
                    cache.add(test + i);
                    if (!cache.contains(test + i)) {
                        // Expected
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
                return;
            }
            result = true;
        }
    }
        <bug>51509</bug>: Fix potential concurrency issue in CSRF prevention
        filter that may lead to some requests failing that should not. (markt)
      </fix>
      <fix>

======= 5de2739:"java/org/apache/catalina/startup/WebRuleSet.java"

            digester.addCallMethod(fullPrefix + "/absolute-ordering/others",
      <fix>
        <bug>51518</bug>: Correct error in web.xml parsing rules for the
        &lt;others/&gt; tag when using absolute ordering. (markt)
      </fix>

======= a3f3379:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

            if ((socketRef != 0) && Socket.sendbb(socketRef, 0, outputBuffer.position()) < 0) {
        if (explicit && !finished &&  (socketRef != 0)) {

======= 1e79993:"java/org/apache/catalina/connector/Connector.java"

        // Validate settings before starting
        if (getPort() < 1) {
            throw new LifecycleException(sm.getString(
                    "coyoteConnector.invalidPort", Integer.valueOf(getPort())));
        }
  ${If} $TomcatPortShutdown == ""
    MessageBox MB_ICONEXCLAMATION|MB_OK 'The shutdown port may not be empty'
    Abort "Config not right"
    Goto exit
  ${EndIf}
  ${If} $TomcatPortHttp == ""
    MessageBox MB_ICONEXCLAMATION|MB_OK 'The HTTP port may not be empty'
    Abort "Config not right"
    Goto exit
  ${EndIf}
  ${If} $TomcatPortAjp == ""
    MessageBox MB_ICONEXCLAMATION|MB_OK 'The AJP port may not be empty'
    Abort "Config not right"
    Goto exit
  ${EndIf}
      <fix>
        <bug>51503</bug>: Add additional validation that prevents a connector
        from starting if it does not have a port > 0. (markt)
      </fix>
    </changelog>
  </subsection>
  <subsection>
    <changelog>
      <fix>
        <bug>51503</bug>: Add additional validation to Windows installer that
        ensure that the shutdown port, HTTP port and AJP port are all specified
        during the install process. (markt)
      </fix>

======= 6ee5a22:"java/org/apache/tomcat/jni/Library.java"

    /* TCN_FULL_VERSION */
    public static int TCN_FULL_VERSION   = 0;
======= 6ee5a22:"java/org/apache/tomcat/jni/Library.java"

            TCN_FULL_VERSION   = TCN_MAJOR_VERSION * 1000 +
                                 TCN_MINOR_VERSION * 100 +
                                 TCN_PATCH_VERSION;
======= 6ee5a22:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            int value;
            // This branch can be removed, once the required version is at least 1.1.21.
            if (Library.TCN_FULL_VERSION <= 1120) {
                value = SSL.SSL_PROTOCOL_ALL;
                if ("SSLv2".equalsIgnoreCase(SSLProtocol)) {
                    value = SSL.SSL_PROTOCOL_SSLV2;
                } else if ("SSLv3".equalsIgnoreCase(SSLProtocol)) {
                    value = SSL.SSL_PROTOCOL_SSLV3;
                } else if ("TLSv1".equalsIgnoreCase(SSLProtocol)) {
                    value = SSL.SSL_PROTOCOL_TLSV1;
                } else if ("SSLv2+SSLv3".equalsIgnoreCase(SSLProtocol)) {
                    value = SSL.SSL_PROTOCOL_SSLV2 | SSL.SSL_PROTOCOL_SSLV3;
                } else if ("all".equalsIgnoreCase(SSLProtocol) ||
                        SSLProtocol == null || SSLProtocol.length() == 0) {
                    // NOOP, use the default defined above
                } else {
                    // Protocol not recognized, fail to start as it is safer than
                    // continuing with the default which might enable more than the
                    // is required
                    throw new Exception(sm.getString(
                            "endpoint.apr.invalidSslProtocol", SSLProtocol));
                }
                value = SSL.SSL_PROTOCOL_NONE;
                if (SSLProtocol == null || SSLProtocol.length() == 0) {
                    value = SSL.SSL_PROTOCOL_ALL;
                } else {
                        for (String protocol : SSLProtocol.split("\\+")) {
                        protocol = protocol.trim();
                        if ("SSLv2".equalsIgnoreCase(protocol)) {
                            value |= SSL.SSL_PROTOCOL_SSLV2;
                        } else if ("SSLv3".equalsIgnoreCase(protocol)) {
                            value |= SSL.SSL_PROTOCOL_SSLV3;
                        } else if ("TLSv1".equalsIgnoreCase(protocol)) {
                            value |= SSL.SSL_PROTOCOL_TLSV1;
                        } else if ("all".equalsIgnoreCase(protocol)) {
                            value |= SSL.SSL_PROTOCOL_ALL;
                        } else {
                            // Protocol not recognized, fail to start as it is safer than
                            // continuing with the default which might enable more than the
                            // is required
                            throw new Exception(sm.getString(
                                    "endpoint.apr.invalidSslProtocol", SSLProtocol));
                        }
                    }
                }
        <bug>51477</bug>Support all SSL protocol combinations in the APR/native
        connector. This only works when using the native library version 1.1.21
        or later, which is not yet released. (rjung)
      </update>
      <update>
        library, the APR/native connector will be used. If the native library
        that the APR/native connector has different settings for HTTPS than the
      value is <code>all</code>, with other acceptable values being <code>SSLv2</code>,
      <code>SSLv3</code>, <code>TLSv1</code> and <code>SSLv2+SSLv3</code>.
      Starting with version 1.1.21 of the Tomcat native
      library any combination of the three protocols concatenated with a
      plus sign will be supported. Note that the protocol <code>SSLv2</code>
      is inherently unsafe.</p>

======= 871dabd:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 871dabd:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 871dabd:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * Character set used by the log file. If it is <code>null</code>, the
     * system default character set will be used. An empty string will be
     * treated as <code>null</code> when this property is assigned.
     */
    protected String encoding = null;
======= 871dabd:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * Return the character set name that is used to write the log file.
     *
     * @return Character set name, or <code>null</code> if the system default
     *  character set is used.
     */
    public String getEncoding() {
        return encoding;
    }
    /**
     * Set the character set that is used to write the log file.
     * 
     * @param encoding The name of the character set.
     */
    public void setEncoding(String encoding) {
        if (encoding != null && encoding.length() > 0) {
            this.encoding = encoding;
        } else {
            this.encoding = null;
        }
    }
======= 871dabd:"java/org/apache/catalina/valves/AccessLogValve.java"

            Charset charset = null;
            if (encoding != null) {
                try {
                    charset = B2CConverter.getCharset(encoding);
                } catch (UnsupportedEncodingException ex) {
                    log.error(sm.getString(
                            "accessLogValve.unsupportedEncoding", encoding), ex);
                }
            }
            if (charset == null) {
                charset = Charset.defaultCharset();
            }
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
                    new FileOutputStream(pathname, true), charset), 128000),
                    false);
      <add>
        <bug>46252</bug>: Allow to specify character set to be used to write
        the access log in AccessLogValve. (kkolinko)
      </add>
      <attribute name="encoding" required="false">
        <p>Character set used to write the log file. An empty string means
        to use the system default character set. Default value: use the
        system default character set.
        </p>
      </attribute>

======= 3a95db4:"java/org/apache/catalina/core/StandardContextValve.java"

                // Protect against NPEs if context was destroyed during a long
                // running request.
                StandardContext c = context;
                if (c != null && c.getState().isAvailable()) {
                    context.fireRequestDestroyEvent(request);
                }
      <fix>
        <bug>51494</bug>: Prevent an NPE when a long running request completes
        if the associated web application was destroyed while the request was
        processing. (markt)
      </fix>

======= acc5619:"java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java"

     * @param data  Data to decompress
     * @return      Decompressed data
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        int length = 0;
        while (length > -1) {
            bout.write(tmp, 0, length);
            length = gin.read(tmp);
        }
        return bout.toByteArray();
======= acc5619:"test/org/apache/catalina/tribes/group/interceptors/TestGzipInterceptor.java"

    public void testSmallerThanBufferSize() throws Exception {
        doCompressDecompress(GzipInterceptor.DEFAULT_BUFFER_SIZE / 2);
    }
    public void testJustSmallerThanBufferSize() throws Exception {
        doCompressDecompress(GzipInterceptor.DEFAULT_BUFFER_SIZE -1);
    }
    public void testExactBufferSize() throws Exception {
        doCompressDecompress(GzipInterceptor.DEFAULT_BUFFER_SIZE);
    }
    public void testJustLargerThanBufferSize() throws Exception {
        doCompressDecompress(GzipInterceptor.DEFAULT_BUFFER_SIZE + 1);
    }
    public void testFactor2BufferSize() throws Exception {
        doCompressDecompress(GzipInterceptor.DEFAULT_BUFFER_SIZE * 2);
    }
    public void testFactor4BufferSize() throws Exception {
        doCompressDecompress(GzipInterceptor.DEFAULT_BUFFER_SIZE * 4);
    }
    public void testMuchLargerThanBufferSize() throws Exception {
        doCompressDecompress(GzipInterceptor.DEFAULT_BUFFER_SIZE * 10 + 1000);
    }
    private void doCompressDecompress(int size) throws Exception {
        byte[] data = new byte[size];
        Arrays.fill(data, (byte)1);

======= ec00abf:"java/org/apache/catalina/security/SecurityConfig.java"

    // FIX ME package "javax." was removed to prevent HotSpot
    // fatal internal errors
======= ec00abf:"java/org/apache/catalina/security/SecurityConfig.java"

                if (packageList.length() > 0) {
                    definition = definition + ',' + packageList;
                }
            } else {
                definition = packageList;
            Security.setProperty(properties, definition);
      <fix>
        <bug>51473</bug>: Fix concatenation of values in
        <code>SecurityConfig.setSecurityProperty()</code>. (kkolinko)
      </fix>

======= eb98373:"java/org/apache/catalina/core/StandardContext.java"

            t.start();
      <fix>
        <bug>51467</bug>: Invoke Thread.start() rather than Thread.run() so that
        listeners and filters are stopped in a separate thread rather than the
        current thread. Patch provided by Felix Schumacher. (markt)  
      </fix>

======= 6020bf6:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

        // Don't start host if already started
======= 6020bf6:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

     * Stop the host with the specified name.
======= 6020bf6:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

        // Prevent stopping our own host
        // Don't stop host if already stopped
      <fix>
        <bug>51466</bug>: Correct comment typos in HostManagerServlet. Patch
        provided by Felix Schumacher. (markt)
      </fix>

======= df9bc17:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

        if (!authRequired && context.getPreemptiveAuthentication()) {
        if (!authRequired && context.getPreemptiveAuthentication()) {
      <fix>
        <bug>51453</bug>: Fix a regression in the preemptive authentication
        support (enhancement <bug>12428</bug>) that could trigger authentication
        even if preemptive authentication was disabled. (markt) 
      </fix>

======= 92af111:"java/org/apache/el/lang/ExpressionBuilder.java"

======= 92af111:"java/org/apache/el/lang/ExpressionBuilder.java"

            } catch (Exception e) {
                throw new ELException(
                        MessageFactory.get("error.parseFail", expr), e);
      <add>
        Broaden the exception handling in the EL Parser so that more failures to
        parse an expression include the failed expression in the exception
        message. Hopefully, this will help track down the cause of
        <bug>51088</bug>. (markt)
      </add>

======= 6dffc54:"java/org/apache/catalina/core/StandardContextValve.java"

            error(response, HttpServletResponse.SC_NOT_FOUND);
======= 6dffc54:"java/org/apache/catalina/core/StandardContextValve.java"

            error(response, HttpServletResponse.SC_NOT_FOUND);
                error(response, HttpServletResponse.SC_NOT_FOUND);
        // Acknowledge the request
        try {
            response.sendAcknowledgement();
        } catch (IOException ioe) {
            container.getLogger().error(sm.getString(
                    "standardContextValve.acknowledgeException"), ioe);
            request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, ioe);
            error(response, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            return;
        }
        
======= 6dffc54:"java/org/apache/catalina/core/StandardContextValve.java"

     * Report an error for the specified resource.  FIXME:  We
    private void error(HttpServletResponse response, int status) {
            response.sendError(status);
======= 6dffc54:"java/org/apache/catalina/core/StandardWrapperValve.java"

      <fix>
        <bug>51436</bug>: Send 100 (Continue) response earlier to enable
        ServletRequestListener implementations to read the request body. Based
        on a patch by Simon Olofsson. (markt)
      </fix>

======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

    protected static final StringManager sm =
        StringManager.getManager(Constants.Package);
======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
        check();
======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
        check();
======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

        context = null;
        dispatch = null;
        event = null;
        hasOriginalRequestAndResponse = true;
        instanceManager = null;
        listeners.clear();
        request = null;
======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

        check();
        check();
======= d36c5d9:"java/org/apache/catalina/core/AsyncContextImpl.java"

    private void check() {
        if (request == null) {
            // AsyncContext has been recycled and should not be being used
            throw new IllegalStateException(sm.getString(
                    "asyncContextImpl.requestEnded"));
        }
    }

======= 3d85a85:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            StringManager smClient) {
        List<Session> sessions = getSessionsForName(cn, smClient);
        if (sessions == null || sessions.isEmpty()) return null;
        for(Session session : sessions) {
            if (session.getId().equals(id)) {
                return session;
        return null;
      <fix>
        <bug>51447</bug>: Viewing a back up session in the HTML Manager web
        application no longer changes the session to a primary session. Based on
        a patch provided by Eiji Takahashi. (markt)
      </fix>

======= f83c07e:"java/org/apache/catalina/startup/Tomcat.java"

 * There are a variety of 'add' methods to configure servlets and webapps. These
 * methods, by default, create a simple in-memory security realm and apply it.
 * If you need more complex security processing, you can define a subclass of
 * this class.
 * 
 * This class provides a set of convenience methods for configuring webapp
 * contexts, all overloads of the method <pre>addWebapp</pre>. These methods
 * create a webapp context, configure it, and then add it to a {@link Host}.
 * They do not use a global default web.xml; rather, they add a lifecycle
 * listener that adds the standard DefaultServlet, JSP processing, and welcome
 * files.
 * 
 * In complex cases, you may prefer to use the ordinary Tomcat API to create
 * webapp contexts; for example, you might need to install a custom Loader
 * before the call to {@link Host#addChild(Container)}. To replicate the basic
 * behavior of the <pre>addWebapp</pre> methods, you may want to call three
 * methods of this class: {@link #getDefaultRealm()}, 
 * {@link #noDefaultWebXmlPath()}, and {@link #getDefaultWebXmlListener()}. 
 * 
 * {@link #getDefaultRealm()} returns the simple security realm.
 * 
 * {@link #getDefaultWebXmlListener()} returns a {@link LifecycleListener} that
 * adds the standard DefaultServlet, JSP processing, and welcome files. If you
 * add this listener, you must prevent Tomcat from applying any standard global
 * web.xml with ...
 * 
 * {@link #noDefaultWebXmlPath()} returns a dummy pathname to configure to
 * prevent {@link ContextConfig} from trying to apply a global web.xml file. 
 * 
======= f83c07e:"java/org/apache/catalina/startup/Tomcat.java"

    private Map<String, List<String>> userRoles =
        new HashMap<String, List<String>>();
    private Map<String, Principal> userPrincipals =
        new HashMap<String, Principal>();
======= f83c07e:"java/org/apache/catalina/startup/Tomcat.java"

    
    /**
     * Return a listener that provides the required configuration items for JSP
     * processing. From the standard Tomcat global web.xml. Pass this to
     * {@link Context#addLifecycleListener(LifecycleListener)} and then pass the
     * result of {@link #noDefaultWebXmlPath()} to 
     * {@link ContextConfig#setDefaultWebXml(String)}. 
     * @return a listener object that configures default JSP processing.
     */
    public LifecycleListener getDefaultWebXmlListener() {
        return new DefaultWebXmlListener();
    }
    
    /**
     * @return a pathname to pass to
     * {@link ContextConfig#setDefaultWebXml(String)} when using
     * {@link #getDefaultWebXmlListener()}.
     */
    public String noDefaultWebXmlPath() {
        return "org/apache/catalin/startup/NO_DEFAULT_XML";
    }
    
    /**
     * For complex configurations, this accessor allows callers of this class
     * to obtain the simple realm created by default.
     * @return the simple in-memory realm created by default.
     */
    public Realm getDefaultRealm() {
        if (defaultRealm == null) {
            initSimpleAuth();
        }
        return defaultRealm;
    }
      <add>
        <bug>51418</bug>: Provide more control over Context creation when
        embedding Tomcat. Based on a patch by Benson Margulies. (markt)
      </add>

======= f2dd57b:"java/org/apache/juli/FileHandler.java"

                // Ignore and fallback to defaults
                setFormatter(new SimpleFormatter());
      <add>
        <bug>51403</bug>: Avoid NPE in JULI FileHandler if formatter is
        misconfigured. (kkolinko)
      </add>

======= 7c274bb:"java/org/apache/catalina/startup/WebRuleSet.java"

    protected SetSessionConfig sessionConfig = new SetSessionConfig();
    protected SetLoginConfig loginConfig = new SetLoginConfig();
    protected SetJspConfig jspConfig = new SetJspConfig();
======= 7c274bb:"java/org/apache/catalina/startup/WebRuleSet.java"

      <fix>
        <bug>51401</bug>: Correctly initialise shared WebRuleSet instance used
        by the digesters that parse web.xml and prevent incorrect warnings about
        multiple occurrences of elements that are only allowed to appear once in
        web.xml and web-fragment.xml. (kfujino)
      </fix>

======= f75418b:"java/org/apache/catalina/startup/ContextConfig.java"

        Map<String,String> jspInitParams;
        if (jspServlet == null) {
            jspInitParams = new HashMap<String,String>();
            Wrapper w = (Wrapper) context.findChild("jsp");
            if (w != null) {
                String[] params = w.findInitParameters();
                for (String param : params) {
                    jspInitParams.put(param, w.findInitParameter(param));
                }
            }
        } else {
            jspInitParams = jspServlet.getParameterMap();
        }
                convertJsp(servletDef, jspInitParams);
    private void convertJsp(ServletDef servletDef,
            Map<String,String> jspInitParams) {
======= f75418b:"java/org/apache/catalina/startup/ContextConfig.java"

        for (Map.Entry<String, String> initParam: jspInitParams.entrySet()) {
======= f75418b:"test/org/apache/catalina/startup/TestContextConfig.java"

    public void testBug51396() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir =  new File("test/webapp-3.0-fragments");
        // app dir is relative to server home
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        
        tomcat.start();
        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug51396.jsp", bc, null);
        
        assertEquals(HttpServletResponse.SC_OK, rc);
        assertTrue(bc.toString().contains("<p>OK</p>"));
    }
  <!-- Bug 51396 -->
  <servlet>
    <servlet-name>bug51396</servlet-name>
    <jsp-file>/bug51396.jsp</jsp-file>
  </servlet>
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <body>
    <p>OK</p>
  </body>
      <fix>
        <bug>51396</bug>: Correctly handle jsp-file entries in web.xml when the
        JSP servlet has been configured via code when embedding Tomcat. (markt)
      </fix>

======= 7d6c439:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 7d6c439:"java/org/apache/catalina/valves/AccessLogValve.java"

 * <li><b>%t{format}</b> - Date and time, in any format supported by SimpleDateFormat
======= 7d6c439:"java/org/apache/catalina/valves/AccessLogValve.java"

        "org.apache.catalina.valves.AccessLogValve/2.2";
======= 7d6c439:"java/org/apache/catalina/valves/AccessLogValve.java"

    /**
     * The size of our global date format cache
     */
    private static final int globalCacheSize = 300;
    /**
     * The size of our thread local date format cache
     */
    private static final int localCacheSize = 60;
    /**
     * <p>Cache structure for formatted timestamps based on seconds.</p>
     *
     * <p>The cache consists of entries for a consecutive range of
     * seconds. The length of the range is configurable. It is
     * implemented based on a cyclic buffer. New entries shift the range.</p>
     *
     * <p>There is one cache for the CLF format (the access log standard
     * format) and a HashMap of caches for additional formats used by
     * SimpleDateFormat.</p>
     *
     * <p>The cache is not threadsafe. It can be used without synchronization
     * via thread local instances, or with synchronization as a global cache.</p>
     *
     * <p>This class uses a small thread local first level cache and a bigger
     * synchronized global second level cache.</p>
     */
    private static class DateFormatCache {
        private class Cache {
            /* CLF log format */
            private static final String cLFFormat = "dd/MMM/yyy:HH:mm:ss";
            /* Second used to retrieve CLF format in most recent invocation */
            private long previousSeconds = 0L;
            /* Value of CLF format retrieved in most recent invocation */
            private String previousFormat = "";
            /* First second contained in cache */
            private long first = 0L;
            /* Last second contained in cache */
            private long last = 0L;
            /* Index of "first" in the cyclic cache */
            private int offset = 0;
            /* Helper object to be able to call SimpleDateFormat.format(). */
            private final Date currentDate = new Date();
            private String cache[];
            private SimpleDateFormat formatter;
            private boolean isCLF = false;
            private Cache parent = null;
            private Cache(String format, Cache parent) {
                cache = new String[cacheSize];
                for (int i = 0; i < cacheSize; i++) {
                    cache[i] = null;
                }
                if (format == null) {
                    isCLF = true;
                    format = cLFFormat;
                }
                formatter = new SimpleDateFormat(format);
                formatter.setTimeZone(TimeZone.getDefault());
                this.parent = parent;
            }
            private String getFormat(long time) {
                long seconds = time / 1000;
                /* First step: if we have seen this timestamp
                   during the previous call, and we need CLF, return the previous value. */
                if (seconds == previousSeconds) {
                    return previousFormat;
                }
                /* Second step: Try to locate in cache */
                previousSeconds = seconds;
                int index = (offset + (int)(seconds - first)) % cacheSize;
                if (index < 0) {
                    index += cacheSize;
                }
                if (seconds >= first && seconds <= last) {
                    if (cache[index] != null) {
                        /* Found, so remember for next call and return.*/
                        previousFormat = cache[index];
                        return previousFormat;
                    }
                /* Third step: not found in cache, adjust cache and add item */
                } else if (seconds >= last + cacheSize || seconds <= first - cacheSize) {
                    first = seconds;
                    last = first + cacheSize - 1;
                    index = 0;
                    offset = 0;
                    for (int i = 1; i < cacheSize; i++) {
                        cache[i] = null;
                    }
                } else if (seconds > last) {
                    for (int i = 1; i < seconds - last; i++) {
                        cache[(index + cacheSize - i) % cacheSize] = null;
                    }
                    first = seconds - cacheSize;
                    last = seconds;
                } else if (seconds < first) {
                    for (int i = 1; i < first - seconds; i++) {
                        cache[(index + i) % cacheSize] = null;
                    }
                    first = seconds;
                    last = seconds + cacheSize;
                }
                /* Last step: format new timestamp either using
                 * parent cache or locally. */
                if (parent != null) {
                    synchronized(parent) {
                        previousFormat = parent.getFormat(time);
                    }
                } else {
                    currentDate.setTime(time);
                    previousFormat = formatter.format(currentDate);
                    if (isCLF) {
                        StringBuilder current = new StringBuilder(32);
                        current.append('[');
                        current.append(previousFormat);
                        current.append(' ');
                        current.append(getTimeZone(currentDate));
                        current.append(']');
                        previousFormat = current.toString();
                    }
                }
                cache[index] = previousFormat;
                return previousFormat;
            }
        }
        private String type;
        /* Number of cached entries */
        private int cacheSize = 0;
        private DateFormatCache parent;
        private Cache cLFCache;
        private HashMap<String, Cache> formatCache = new HashMap<String, Cache>();
        private DateFormatCache(int size, DateFormatCache parent) {
            if (parent == null) {
                type = "main";
            } else {
                type = "child";
            }
            cacheSize = size;
            this.parent = parent;
            Cache parentCache = null;
            if (parent != null) {
                synchronized(parent) {
                    parentCache = parent.getCache(null);
                }
            }
            cLFCache = new Cache(null, parentCache);
        }
        private Cache getCache(String format) {
            Cache cache;
            if (format == null) {
                cache = cLFCache;
            } else {
                cache = formatCache.get(format);
                if (cache == null) {
                    Cache parentCache = null;
                    if (parent != null) {
                        synchronized(parent) {
                            parentCache = parent.getCache(format);
                        }
                    }
                    cache = new Cache(format, parentCache);
                    formatCache.put(format, cache);
                }
            }
            return cache;
        }
        public String getFormat(String format, long time) {
            return getCache(format).getFormat(time);
    /**
     * Global date format cache.
     */
    private static final DateFormatCache globalDateCache =
            new DateFormatCache(globalCacheSize, null);
    /**
     * Thread local date format cache.
     */
    private static final ThreadLocal<DateFormatCache> localDateCache =
            new ThreadLocal<DateFormatCache>() {
        protected DateFormatCache initialValue() {
            return new DateFormatCache(localCacheSize, globalDateCache);
        }
    };
    private static final ThreadLocal<Date> localDate =
            new ThreadLocal<Date>() {
        protected Date initialValue() {
            return new Date();
    /**
     * The list of our format types.
     */
    private static enum formatType {
        CLF, SEC, MSEC, MSEC_FRAC, SDF
    }
======= 7d6c439:"java/org/apache/catalina/valves/AccessLogValve.java"

        /**
         * XXX This is a bit silly, but we want to have start and stop time and
         * duration consistent. It would be better to keep start and stop
         * simply in the request and/or response object and remove time
         * (duration) from the interface.
         */
        long start = request.getCoyoteRequest().getStartTime();
        Date date = getDate(start + time);
======= 7d6c439:"java/org/apache/catalina/valves/AccessLogValve.java"

    private static Date getDate(long systime) {
        Date date = localDate.get();
        date.setTime(systime);
        return date;
======= 7d6c439:"java/org/apache/catalina/valves/AccessLogValve.java"

        dateStamp = fileDateFormatter.format(new Date(System.currentTimeMillis()));
======= 7d6c439:"java/org/apache/catalina/valves/AccessLogValve.java"

     * write date and time, in configurable format (default CLF) - %t or %t{format}
        /**
         * Format prefix specifying request start time
         */
        private static final String requestStartPrefix = "begin";
        /**
         * Format prefix specifying response end time
         */
        private static final String responseEndPrefix = "end";
        /**
         * Separator between optional prefix and rest of format
         */
        private static final String prefixSeparator = ":";
        /**
         * Special format for seconds since epoch
         */
        private static final String secFormat = "sec";
        /**
         * Special format for milliseconds since epoch
         */
        private static final String msecFormat = "msec";
        /**
         * Special format for millisecond part of timestamp
         */
        private static final String msecFractionFormat = "msec_frac";
        /**
         * The pattern we use to replace "S" millisecond formatting
         * of SimpleDateFormat by our own handling
         */
        private static final String msecPattern = "####";
        /* Our format description string, null if CLF */
        private String format = null;
        /* Whether to use begin of request or end of response as the timestamp */
        private boolean usesBegin = false;
        /* The format type */
        private formatType type = formatType.CLF;
        /* Whether we need to postprocess by adding milliseconds */
        private boolean usesMsecs = false;
        protected DateAndTimeElement() {
            this(null);
        }
        /**
         * Replace the millisecond formatting character 'S' by
         * some dummy characters in order to make the resulting
         * formatted time stamps cacheable. We replace the dummy
         * chars later with the actual milliseconds because that's
         * relatively cheap.
         */
        private void tidyFormat() {
            boolean escape = false;
            StringBuilder result = new StringBuilder();
            int len = format.length();
            char x;
            for (int i = 0; i < len; i++) {
                x = format.charAt(i);
                if (escape || x != 'S') {
                    result.append(x);
                } else {
                    result.append(msecPattern);
                    usesMsecs = true;
                }
                if (x == '\'') {
                    escape = !escape;
                }
            }
            format = result.toString();
        }
        protected DateAndTimeElement(String header) {
            format = header;
            if (format != null) {
                if (format.equals(requestStartPrefix)) {
                    usesBegin = true;
                    format = "";
                } else if (format.startsWith(requestStartPrefix + prefixSeparator)) {
                    usesBegin = true;
                    format = format.substring(6);
                } else if (format.equals(responseEndPrefix)) {
                    usesBegin = false;
                    format = "";
                } else if (format.startsWith(responseEndPrefix + prefixSeparator)) {
                    usesBegin = false;
                    format = format.substring(4);
                }
                if (format.length() == 0) {
                    type = formatType.CLF;
                } else if (format.equals(secFormat)) {
                    type = formatType.SEC;
                } else if (format.equals(msecFormat)) {
                    type = formatType.MSEC;
                } else if (format.equals(msecFractionFormat)) {
                    type = formatType.MSEC_FRAC;
                } else {
                    type = formatType.SDF;
                    tidyFormat();
                }
            }
        }
            long timestamp = date.getTime();
            if (usesBegin) {
                timestamp -= time;
            }
            switch (type) {
            case CLF:
                buf.append(localDateCache.get().getFormat(null, timestamp));
                break;
            case SEC:
                buf.append(timestamp / 1000);
                break;
            case MSEC:
                buf.append(timestamp);
                break;
            case MSEC_FRAC:
                long frac = timestamp % 1000;
                if (frac < 100) {
                    if (frac < 10) {
                        buf.append("00");
                    } else {
                        buf.append("0");
                    }
                }
                buf.append(frac);
                break;
            case SDF:
                String temp = localDateCache.get().getFormat(format, timestamp);
                if (usesMsecs) {
                    String msec = Long.toString(timestamp % 1000);
                    temp = temp.replace(msecPattern, msec);
                }
                buf.append(temp);
                break;
======= 7d6c439:"java/org/apache/catalina/valves/AccessLogValve.java"

        case 't':
            return new DateAndTimeElement(header);
      <fix>
        <bug>49165</bug>: Allow any time stamp formats supported by SimpleDateFormat
        in AccessLogValve. Support logging begin and/or end of request. (rjung)
      </fix>

======= 9f8b983:"java/org/apache/catalina/startup/ContextConfig.java"

                match = false;
======= 9f8b983:"test/org/apache/catalina/startup/TestContextConfigAnnotation.java"

======= 9f8b983:"test/org/apache/catalina/startup/TestContextConfigAnnotation.java"

    public void testCheckHandleTypes() throws Exception {
        ContextConfig config = new ContextConfig();
        
        // Need a Context, Loader and ClassLoader for checkHandleTypes
        StandardContext context = new StandardContext();
        context.setLoader(new TesterLoader());
        config.context = context;
        // Add an SCI that has no interest in any type
        SCI sciNone = new SCI();
        config.initializerClassMap.put(sciNone, new HashSet<Class<?>>());
        
        // Add an SCI with an interest in Servlets
        SCI sciServlet = new SCI();
        config.initializerClassMap.put(sciServlet, new HashSet<Class<?>>());
        config.typeInitializerMap.put(Servlet.class,
                new HashSet<ServletContainerInitializer>());
        config.typeInitializerMap.get(Servlet.class).add(sciServlet);
        
        // Add an SCI with an interest in Objects - i.e. everything
        SCI sciObject = new SCI();
        config.initializerClassMap.put(sciObject, new HashSet<Class<?>>());
        config.typeInitializerMap.put(Object.class,
                new HashSet<ServletContainerInitializer>());
        config.typeInitializerMap.get(Object.class).add(sciObject);
        // Scan Servlet, Filter, Servlet, Listener
        WebXml ignore = new WebXml();
        File file = paramClassResource(
                "org/apache/catalina/startup/ParamServlet");
        config.processAnnotationsFile(file, ignore);
        file = paramClassResource("org/apache/catalina/startup/ParamFilter");
        config.processAnnotationsFile(file, ignore);
        file = paramClassResource("org/apache/catalina/startup/TesterServlet");
        config.processAnnotationsFile(file, ignore);
        file = paramClassResource("org/apache/catalina/startup/TestListener");
        config.processAnnotationsFile(file, ignore);
        
        // Check right number of classes were noted to be handled
        assertEquals(0, config.initializerClassMap.get(sciNone).size());
        assertEquals(2, config.initializerClassMap.get(sciServlet).size());
        assertEquals(4, config.initializerClassMap.get(sciObject).size());
    }
    private static final class SCI implements ServletContainerInitializer {
        @Override
        public void onStartup(Set<Class<?>> c, ServletContext ctx)
                throws ServletException {
            // NO-OP. Just need a class that implements SCI.
        }
    }
    
    private static final class TesterLoader implements Loader {
        @Override
        public void backgroundProcess() {}
        @Override
        public ClassLoader getClassLoader() {
            return this.getClass().getClassLoader();
        }
        @Override
        public Container getContainer() { return null; }
        @Override
        public void setContainer(Container container) {}
        @Override
        public boolean getDelegate() { return false; }
        @Override
        public void setDelegate(boolean delegate) {}
        @Override
        public String getInfo() { return null; }
        @Override
        public boolean getReloadable() { return false; }
        @Override
        public void setReloadable(boolean reloadable) {}
        @Override
        public void addPropertyChangeListener(PropertyChangeListener l) {
        }
        @Override
        public void addRepository(String repository) {}
        @Override
        public String[] findRepositories() { return null; }
        @Override
        public boolean modified() { return false; }
        @Override
        public void removePropertyChangeListener(PropertyChangeListener l) {}
    }
      <fix>
        <bug>51386</bug>: Correct code for processing @HandlesTypes annotations
        so only types of interest are reported to a ServletContainerInitializer.
        (markt)
      </fix>

======= 874048a:"java/org/apache/catalina/ssi/ExpressionParseTree.java"

======= 874048a:"java/org/apache/catalina/ssi/ExpressionParseTree.java"

            
            int val2Len = val2.length();
            if (val2Len > 1 && val2.charAt(0) == '/' &&
                    val2.charAt(val2Len - 1) == '/') {
                // Treat as a regular expression
                String expr = val2.substring(1, val2Len - 1);
                Pattern pattern = Pattern.compile(expr);
                // Regular expressions will only ever be used with EqualNode
                // so return zero for equal and non-zero for not equal
                if (pattern.matcher(val1).find()) {
                    return 0;
                } else {
                    return -1;
                }
            }
        <bug>48956</bug>: Add regular expression support for SSI. (markt)
      </add>
      <add>

======= 2b8e6cf:"java/org/apache/catalina/manager/Constants.java"

            " <td colspan=\"8\" class=\"title\">{0}</td>\n" +
======= 2b8e6cf:"java/org/apache/catalina/manager/Constants.java"

            " <td class=\"header-center\"><small>{7}</small></td>\n" +
            " <td class=\"header-center\"><small>{8}</small></td>\n" +
======= 2b8e6cf:"java/org/apache/catalina/manager/Constants.java"

            " <td class=\"row-center\"><small>{6}</small></td>\n" +
            " <td class=\"row-center\"><small>{7}</small></td>\n" +
======= 2b8e6cf:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= 2b8e6cf:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args = new Object[9];
======= 2b8e6cf:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[7] = sm.getString("htmlManagerServlet.serverHostname");
        args[8] = sm.getString("htmlManagerServlet.serverIPAddress");
        args = new Object[8];
        try {
            InetAddress address = InetAddress.getLocalHost();
            args[6] = address.getHostName();
            args[7] = address.getHostAddress();
        } catch (UnknownHostException e) {
            args[6] = "-";
            args[7] = "-";
        }
======= 2b8e6cf:"java/org/apache/catalina/manager/StatusManagerServlet.java"

======= 2b8e6cf:"java/org/apache/catalina/manager/StatusManagerServlet.java"

        args = new Object[9];
======= 2b8e6cf:"java/org/apache/catalina/manager/StatusManagerServlet.java"

        args[7] = sm.getString("htmlManagerServlet.serverHostname");
        args[8] = sm.getString("htmlManagerServlet.serverIPAddress");
        args = new Object[8];
        try {
            InetAddress address = InetAddress.getLocalHost();
            args[6] = address.getHostName();
            args[7] = address.getHostAddress();
         } catch (UnknownHostException e) {
            args[6] = "-";
            args[7] = "-";
        }
      <add>
        <bug>43538</bug>: Add host name and IP address to the HTML Manager
        application. Patch by Dennis Lundberg. (markt)
      </add>

======= 4e5571f:"java/org/apache/catalina/ha/session/DeltaManager.java"

        session.setMaxInactiveInterval(getMaxInactiveInterval(), false);
======= 4e5571f:"java/org/apache/catalina/ha/session/DeltaSession.java"

        if(notifyCluster && expiredId != null && manager != null &&
  <subsection name="Cluster">
    <changelog>
      <fix>
        <bug>51306</bug>: Avoid NPE when handleSESSION_EXPIRED is processed 
        while handleSESSION_CREATED is being processed. (kfujino)
      </fix>
    </changelog>
  </subsection>

======= 71b18c8:"java/org/apache/catalina/servlets/WebdavServlet.java"

            if (toRenew != null) {
                // At least one of the tokens of the locks must have been given
                tokenList = toRenew.tokens.elements();
                while (tokenList.hasMoreElements()) {
                    String token = tokenList.nextElement();
                    if (ifHeader.indexOf(token) != -1) {
                        toRenew.expiresAt = lock.expiresAt;
                        lock = toRenew;
                    }
      <fix>
        Prevent possible NPE when processing WebDAV locks. (markt)
      </fix>

======= 4892b57:"java/org/apache/catalina/startup/Embedded.java"

======= 4892b57:"java/org/apache/catalina/startup/Embedded.java"

======= 4892b57:"java/org/apache/catalina/startup/Embedded.java"

======= 4892b57:"java/org/apache/catalina/startup/Embedded.java"

        <bug>51249</bug>: Further improve system property replacement code
        in ClassLoaderLogManager of Tomcat JULI to cover some corner cases.
        (kkolinko)
      </fix>
      <fix>
        <bug>51344</bug>: Fix problem with Lifecycle re-factoring for deprecated
        embedded class that prevented events being triggered. (markt) 

======= 1fe28a6:"java/org/apache/catalina/startup/ContextConfig.java"

        WebRuleSet ruleSet;
            ruleSet = webFragmentRuleSet;
            ruleSet = webRuleSet;
        // Sync on the ruleSet since the same ruleSet is shared across all four
        // digesters
        synchronized(ruleSet) {
======= 1fe28a6:"java/org/apache/catalina/startup/ContextConfig.java"

                ruleSet.recycle();
      <fix>
        <bug>51340</bug>: Fix thread-safety issue when parsing multiple web.xml
        files in parallel. Apache Tomcat does not do this but products that
        embed it may. (markt)
      </fix>

======= 1bbbdb2:"java/org/apache/catalina/connector/OutputBuffer.java"

        doFlush = false;
======= 1bbbdb2:"java/org/apache/catalina/connector/OutputBuffer.java"

        try {
            doFlush = true;
            if (initial) {
                coyoteResponse.sendHeaders();
                initial = false;
            }
            if (bb.getLength() > 0) {
                bb.flushBuffer();
            }
        } finally {
            doFlush = false;
  <subsection name="Catalina">
    <changelog>
      <fix>
        <bug>51324</bug>: Improve handling of exceptions when flushing the
        response buffer to ensure that the doFlush flag does not get stuck in
        the enabled state. Patch provided by Jeremy Norris. (markt)
      </fix>
    </changelog>
  </subsection>

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        AbstractCatalinaTask {
    /**
     * The context path of the web application we are managing.
     */
    protected String path = null;
    public String getPath() {
        return (this.path);
    }
    public void setPath(String path) {
        this.path = path;
    }
    /**
     * The context version of the web application we are managing.
     */
    protected String version = null;
    public String getVersion() {
        return (this.version);
    }
    public void setVersion(String version) {
        this.version = version;
    }
    
    // --------------------------------------------------------- Public Methods
    /**
     * Create query string for the specified command.
     * 
     * @param command Command to be executed
     *
     * @exception BuildException if an error occurs
     */
    public StringBuilder createQueryString(String command) throws BuildException {
        StringBuilder buffer = new StringBuilder();
        try {
            buffer.append(command);
            if (path == null) {
                throw new BuildException("Must specify 'path' attribute");
            } else {
                buffer.append("?path=");
                buffer.append(URLEncoder.encode(this.path, getCharset()));
                if (this.version != null) {
                    buffer.append("&version=");
                    buffer.append(URLEncoder.encode(this.version, getCharset()));
                }
            }
        } catch (UnsupportedEncodingException e) {
            throw new BuildException
                ("Invalid 'charset' attribute: " + getCharset());
        }
        return buffer;
    }
======= d19daf5:"java/org/apache/catalina/ant/ReloadTask.java"

======= d19daf5:"java/org/apache/catalina/ant/ReloadTask.java"

======= d19daf5:"java/org/apache/catalina/ant/ReloadTask.java"

        execute(createQueryString("/reload").toString());
======= d19daf5:"java/org/apache/catalina/ant/SessionsTask.java"

======= d19daf5:"java/org/apache/catalina/ant/SessionsTask.java"

    protected String idle = null;
    
    public String getIdle() {
        return this.idle;
    
    public void setIdle(String idle) {
        this.idle = idle;
    
    @Override
    public StringBuilder createQueryString(String command) {
        StringBuilder buffer = super.createQueryString(command);
        if (path != null && idle != null) {
            buffer.append("&idle=");
            buffer.append(this.idle);
        }
        return buffer;
    }
    
======= d19daf5:"java/org/apache/catalina/ant/SessionsTask.java"

        execute(createQueryString("/sessions").toString());
======= d19daf5:"java/org/apache/catalina/ant/StartTask.java"

======= d19daf5:"java/org/apache/catalina/ant/StartTask.java"

======= d19daf5:"java/org/apache/catalina/ant/StartTask.java"

        execute(createQueryString("/start").toString());
======= d19daf5:"java/org/apache/catalina/ant/StopTask.java"

======= d19daf5:"java/org/apache/catalina/ant/StopTask.java"

======= d19daf5:"java/org/apache/catalina/ant/StopTask.java"

        execute(createQueryString("/stop").toString());
    
======= d19daf5:"java/org/apache/catalina/ant/UndeployTask.java"

======= d19daf5:"java/org/apache/catalina/ant/UndeployTask.java"

======= d19daf5:"java/org/apache/catalina/ant/UndeployTask.java"

        execute(createQueryString("/undeploy").toString());
        <bug>51251</bug>: Add web application version support to the Ant tasks.
        Based on a patch provided by Eiji Takahashi. (markt) 
      </fix>
      <fix>

======= 5109678:"java/org/apache/catalina/startup/ContextConfig.java"

======= 5109678:"java/org/apache/catalina/startup/ContextConfig.java"

======= 5109678:"java/org/apache/catalina/startup/ContextConfig.java"

            Jar jar = null;
                    jar = JarFactory.newInstance(url);
                    is = jar.getInputStream(SCI_LOCATION);
======= 5109678:"java/org/apache/catalina/startup/ContextConfig.java"

                if (jar != null) {
                    jar.close();
======= 5109678:"java/org/apache/catalina/startup/ContextConfig.java"

            Jar jar = null;
                    jar = JarFactory.newInstance(url);
                    if (jar.entryExists("META-INF/resources/")) {
======= 5109678:"java/org/apache/catalina/startup/ContextConfig.java"

                if (jar != null) {
                    jar.close();
======= 5109678:"java/org/apache/catalina/startup/ContextConfig.java"

        Jar jar = null;
        InputStream is;
            jar = JarFactory.newInstance(url);
            jar.nextEntry();
            String entryName = jar.getEntryName();
            while (entryName != null) {
                    is = null;
                        is = jar.getEntryInputStream();
                        processAnnotationsStream(is, fragment);
                    } finally {
                        if (is != null) {
                            try {
                                is.close();
                            } catch (IOException ioe) {
                                // Ignore
                            }
                        }
                jar.nextEntry();
                entryName = jar.getEntryName();
            if (jar != null) {
                jar.close();
======= 5109678:"java/org/apache/catalina/startup/ContextConfig.java"

            URL url = jarConn.getURL();
            Jar jar = null;
            InputStream is = null;
                jar = JarFactory.newInstance(url);
                is = jar.getInputStream(FRAGMENT_LOCATION);
                if (is == null) {
                    source.setByteStream(is);
                if (is != null) {
                        is.close();
                    } catch (IOException ioe) {
                        // Ignore
                if (jar != null) {
                    jar.close();
                }
                fragment.setURL(url);
======= 5109678:"java/org/apache/catalina/startup/TldConfig.java"

======= 5109678:"java/org/apache/catalina/startup/TldConfig.java"

======= 5109678:"java/org/apache/catalina/startup/TldConfig.java"

        Jar jar = null;
        InputStream is;
        
            jar = JarFactory.newInstance(jarConn.getURL());
            
            jar.nextEntry();
            String entryName = jar.getEntryName();
            while (entryName != null) {
                if (entryName.startsWith("META-INF/") &&
                        entryName.endsWith(".tld")) {
                    is = null;
                    try {
                        is = jar.getEntryInputStream();
                        XmlErrorHandler handler = tldScanStream(is);
                        handler.logFindings(log, jarConn.getURL() + entryName);
                    } finally {
                        if (is != null) {
                            try {
                                is.close();
                            } catch (IOException ioe) {
                                // Ignore
                            }
                        }
                    }
                jar.nextEntry();
                entryName = jar.getEntryName();
            log.warn(sm.getString("tldConfig.jarFail", jarConn.getURL()), ioe);
            if (jar != null) {
                jar.close();
======= 5109678:"java/org/apache/jasper/compiler/TldLocationsCache.java"

======= 5109678:"java/org/apache/jasper/compiler/TldLocationsCache.java"

======= 5109678:"java/org/apache/jasper/compiler/TldLocationsCache.java"

        Jar jar = null;
        InputStream is;
        boolean foundTld = false;
        
            jar = JarFactory.newInstance(jarConn.getURL());
            
            jar.nextEntry();
            String entryName = jar.getEntryName();
            while (entryName != null) {
                if (entryName.startsWith("META-INF/") &&
                        entryName.endsWith(".tld")) {
                    is = null;
                    try {
                        is = jar.getEntryInputStream();
                        foundTld = true;
                        tldScanStream(resourcePath, entryName, is);
                    } finally {
                        if (is != null) {
                            try {
                                is.close();
                            } catch (IOException ioe) {
                                // Ignore
                            }
                        }
                    }
                jar.nextEntry();
                entryName = jar.getEntryName();
            if (jar != null) {
                jar.close();
======= 5109678:"java/org/apache/jasper/compiler/TldLocationsCache.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Implementation of {@link Jar} that is optimised for file based JAR URLs (e.g
 * URLs of the form jar:file:...).
 */
    private JarFile jarFile;
    private Enumeration<JarEntry> entries;
    private JarEntry entry = null;
    public FileUrlJar(URL url) throws IOException {
        JarURLConnection jarConn = (JarURLConnection) url.openConnection();
        jarFile = jarConn.getJarFile();
    }
    @Override
    public boolean entryExists(String name) {
        ZipEntry entry = jarFile.getEntry(name);
        return entry != null;
    }
    @Override
    public InputStream getInputStream(String name) throws IOException {
        ZipEntry entry = jarFile.getEntry(name);
        if (entry == null) {
            return null;
        } else {
            return jarFile.getInputStream(entry);
        }
    }
    @Override
    public void close() {
        if (jarFile != null) {
            try {
                jarFile.close();
            } catch (IOException e) {
                // Ignore
            }
        }
    }
    @Override
    public void nextEntry() {
        if (entries == null) {
            entries = jarFile.entries();
        }
        if (entries.hasMoreElements()) {
            entry = entries.nextElement();
        } else {
            entry = null;
        }
    }
    @Override
    public String getEntryName() {
        if (entry == null) {
            return null;
        } else {
            return entry.getName();
        }
    }
    @Override
    public InputStream getEntryInputStream() throws IOException {
        if (entry == null) {
            return null;
        } else {
            return jarFile.getInputStream(entry);
        }
    }
    @Override
    public void reset() throws IOException {
        entries = null;
        entry = null;
    }
======= 5109678:"java/org/apache/jasper/compiler/TldLocationsCache.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Provides an abstraction for use by the various classes that need to scan
 * JARs. The classes provided by the JRE for accessing JARs ({@link JarFile} and
 * {@link JarInputStream}) have significantly different performance
 * characteristics depending on the form of the URL used to access the JAR.
 * For file based JAR {@link URL}s, {@link JarFile} is faster but for non-file
 * based {@link URL}s, {@link JarFile} creates a copy of the JAR in the
 * temporary directory so {@link JarInputStream} is faster.
 */
    /**
     * Determines if a specific entry exists within the JAR.
     * 
     * @param name  Entry to look for
     * @return      <code>true</code> if the specified entry exists else
     *               <code>false</code>
     */
    boolean entryExists(String name) throws IOException;
    
    
    /**
     * Obtain an {@link InputStream} for a given entry in a JAR. The caller is
     * responsible for closing the stream.
     * 
     * @param name  Entry to obtain an {@link InputStream} for
     * @return      An {@link InputStream} for the specified entry or null if
     *              the entry does not exist
     */
    InputStream getInputStream(String name) throws IOException;
    /**
     * Close any resources associated with this JAR.
     */
    void close();
    
    /**
     * Moves the internal pointer to the next entry in the JAR.
     */
    void nextEntry();
    
    /**
     * Obtains the name of the current entry.
     * 
     * @return  The entry name
     */
    String getEntryName();
    
    /**
     * Obtains the input stream for the current entry.
     * 
     * @return  The input stream
     * @throws IOException  If the stream cannot be obtained
     */
    InputStream getEntryInputStream() throws IOException;
    
    /**
     * Resets the internal pointer used to track JAR entries to the beginning of
     * the JAR.
     * 
     * @throws IOException  If the pointer cannot be reset
     */
    void reset() throws IOException;
======= 5109678:"java/org/apache/jasper/compiler/TldLocationsCache.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Provide a mechanism to obtain objects that implement {@link Jar}.
 */
    private JarFactory() {
        // Factory class. Hide public constructor.
    }
    public static Jar newInstance(URL url) throws IOException {
        String jarUrl = url.toString();
        if (jarUrl.startsWith("jar:file:")) {
            return new FileUrlJar(url);
        } else {
            return new UrlJar(url);
        }
    }
======= 5109678:"java/org/apache/jasper/compiler/TldLocationsCache.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Implementation of {@link Jar} that is optimised for non-file based JAR URLs
 * (e.g. JNDI based URLs of the form jar:jndi:...).
 */
    private NonClosingJarInputStream jarInputStream = null;
    private URL url = null;
    private JarEntry entry = null;
    public UrlJar(URL url) throws IOException {
        this.url = url;
        this.jarInputStream = createJarInputStream();
    }
    @Override
    public boolean entryExists(String name) throws IOException {
        JarEntry entry = jarInputStream.getNextJarEntry();
        while (entry != null) {
            if (name.equals(entry.getName())) {
                break;
            }
            entry = jarInputStream.getNextJarEntry();
        }
        
        return entry != null;
    }
    @Override
    public InputStream getInputStream(String name) throws IOException {
        JarEntry entry = jarInputStream.getNextJarEntry();
        while (entry != null) {
            if (name.equals(entry.getName())) {
                break;
            }
            entry = jarInputStream.getNextJarEntry();
        }
        
        if (entry == null) {
            return null;
        } else {
            return jarInputStream;
        }
    }
    @Override
    public void close() {
        if (jarInputStream != null) {
            try {
                jarInputStream.reallyClose();
            } catch (IOException ioe) {
                // Ignore
            }
        }
    }
    private NonClosingJarInputStream createJarInputStream() throws IOException {
        JarURLConnection jarConn = (JarURLConnection) url.openConnection();
        URL resourceURL = jarConn.getJarFileURL();
        URLConnection resourceConn = resourceURL.openConnection();
        resourceConn.setUseCaches(false);
        return new NonClosingJarInputStream(resourceConn.getInputStream());
    }
    @Override
    public void nextEntry() {
        try {
            entry = jarInputStream.getNextJarEntry();
        } catch (IOException ioe) {
            entry = null;
        }
    }
    @Override
    public String getEntryName() {
        if (entry == null) {
            return null;
        } else {
            return entry.getName();
        }
    }
    @Override
    public InputStream getEntryInputStream() throws IOException {
        return jarInputStream;
    }
    @Override
    public void reset() throws IOException {
        close();
        jarInputStream = createJarInputStream();
    }
        <bug>51276</bug>: Provide an abstraction for accessing content in JARs
        so the most efficient method can be selected depending on the type of
        URL used to identify the JAR. This improves startup time when JARs are
        located in $CATALINA_BASE/lib. (mark)
      </fix>
      <fix>

======= 5b0919c:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

        
        String loginPage = config.getLoginPage();
        if (loginPage == null || loginPage.length() == 0) {
            String msg = sm.getString("formAuthenticator.noLoginPage",
                    context.getName());
            log.warn(msg);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                    msg);
            return;
        }
        
            context.getServletContext().getRequestDispatcher(loginPage);
======= 5b0919c:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

        
        String errorPage = config.getErrorPage();
        if (errorPage == null || errorPage.length() == 0) {
            String msg = sm.getString("formAuthenticator.noErrorPage",
                    context.getName());
            log.warn(msg);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                    msg);
            return;
        }
      <fix>
        <bug>51277</bug>: Improve error message if an application is deployed
        with an incomplete FORM authentication configuration. (markt)
      </fix>

======= 73f9592:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

======= 73f9592:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    private volatile LimitLatch connectionLimitLatch = null;
======= 73f9592:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    public void setMaxConnections(int maxCon) {
        this.maxConnections = maxCon;
        LimitLatch latch = this.connectionLimitLatch;
        // Update the latch that enforces this
        latch.setLimit(maxCon);
    }
======= 73f9592:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    protected LimitLatch initializeConnectionLatch() {
        if (connectionLimitLatch==null) {
            connectionLimitLatch = new LimitLatch(getMaxConnections());
        return connectionLimitLatch;
        LimitLatch latch = connectionLimitLatch;
        connectionLimitLatch = null;
    protected void countUpOrAwaitConnection() throws InterruptedException {
        LimitLatch latch = connectionLimitLatch;
        if (latch!=null) latch.countUpOrAwait();
        LimitLatch latch = connectionLimitLatch;
======= 73f9592:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    countUpOrAwaitConnection();
======= 73f9592:"java/org/apache/tomcat/util/net/AprEndpoint.java"

======= 73f9592:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

                    countUpOrAwaitConnection();
                    
======= 73f9592:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

======= 73f9592:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                    countUpOrAwaitConnection();
======= 73f9592:"java/org/apache/tomcat/util/net/NioEndpoint.java"

======= 73f9592:"java/org/apache/tomcat/util/threads/CounterLatch.java"

======= 73f9592:"java/org/apache/tomcat/util/threads/CounterLatch.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Shared latch that allows the latch to be acquired a limited number of times
 * after which all subsequent requests to acquire the latch will be placed in a
 * FIFO queue until one of the shares is returned.
 */
    private class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 1L;
        public Sync() {
        }
        @Override
        protected int tryAcquireShared(int ignored) {
            long newCount = count.incrementAndGet();
            if (!released && newCount > limit) {
                // Limit exceeded
                count.decrementAndGet();
                return -1;
            } else {
                return 1;
            }
        }
        @Override
        protected boolean tryReleaseShared(int arg) {
            count.decrementAndGet();
            return true;
        }
    }
    private final Sync sync;
    private final AtomicLong count;
    private volatile long limit;
    private volatile boolean released = false;
    
    /**
     * Instantiates a LimitLatch object with an initial limit.
     * @param limit - maximum number of concurrent acquisitions of this latch
     */
    public LimitLatch(long limit) {
        this.limit = limit;
        this.count = new AtomicLong(0);
        this.sync = new Sync();
    }
    /**
     * Obtain the current limit.
     */
    public long getLimit() {
        return limit;
    }
    /**
     * Sets a new limit. If the limit is decreased there may be a period where
     * more shares of the latch are acquired than the limit. In this case no
     * more shares of the latch will be issued until sufficient shares have been
     * returned to reduce the number of acquired shares of the latch to below
     * the new limit. If the limit is increased, threads currently in the queue
     * may not be issued one of the newly available shares until the next
     * request is made for a latch.
     * 
     * @param limit The new limit
     */
    public void setLimit(long limit) {
        this.limit = limit;
    }
    /**
     * Acquires a shared latch if one is available or waits for one if no shared
     * latch is current available.
     */
    public void countUpOrAwait() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    /**
     * Releases a shared latch, making it available for another thread to use.
     * @return the previous counter value
     */
    public long countDown() {
        sync.releaseShared(0);
        return count.get();
    }
    
    /**
     * Releases all waiting threads and causes the {@link #limit} to be ignored
     * until {@link #reset()} is called.
     */
    public boolean releaseAll() {
        released = true;
        return sync.releaseShared(0);
    }
    
    /**
     * Resets the latch and initializes the shared acquisition counter to zero.
     * @see #releaseAll()
     */
    public void reset() {
        this.count.set(0);
        released = false;
    }
    
    /**
     * Returns <code>true</code> if there is at least one thread waiting to
     * acquire the shared lock, otherwise returns <code>false</code>.
     */
    public boolean hasQueuedThreads() {
        return sync.hasQueuedThreads();
    }
    /**
     * Provide access to the list of threads waiting to acquire this limited
     * shared latch.
     */
    public Collection<Thread> getQueuedThreads() {
        return sync.getQueuedThreads();
    }
======= 73f9592:"test/org/apache/tomcat/util/threads/TestCounterLatch.java"

======= 73f9592:"test/org/apache/tomcat/util/threads/TestCounterLatch.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    private volatile LimitLatch latch = null;
    @Override
    public void tearDown() {
        LimitLatch temp = latch;
        if (temp!=null) temp.releaseAll();
        latch = null;
    }
    public void testNoThreads() throws Exception {
        latch = new LimitLatch(0);
        assertEquals("No threads should be waiting", false,
                latch.hasQueuedThreads());
    }
    public void testOneThreadNoWait() throws Exception {
        latch = new LimitLatch(1);
        assertEquals("No threads should be waiting", false,
                latch.hasQueuedThreads());
        Thread testThread = new TestThread();
        testThread.start();
        Thread.sleep(50);
        assertEquals("0 threads should be waiting", 0,
                latch.getQueuedThreads().size());
        latch.countUpOrAwait();
        Thread.sleep(50);
        assertEquals("No threads should be waiting", false,
                latch.hasQueuedThreads());
    }
    public void testOneThreadWaitCountUp() throws Exception {
        latch = new LimitLatch(1);
        assertEquals("No threads should be waiting", false,
                latch.hasQueuedThreads());
        Thread testThread = new TestThread();
        latch.countUpOrAwait();
        testThread.start();
        Thread.sleep(50);
        assertEquals("1 threads should be waiting", 1,
                latch.getQueuedThreads().size());
        latch.countDown();
        Thread.sleep(50);
        assertEquals("No threads should be waiting", false,
                latch.hasQueuedThreads());
    }
    public void testOneRelease() throws Exception {
        latch = new LimitLatch(1);
        assertEquals("No threads should be waiting", false,
                latch.hasQueuedThreads());
        Thread testThread = new TestThread();
        latch.countUpOrAwait();
        testThread.start();
        Thread.sleep(50);
        assertEquals("1 threads should be waiting", 1,
                latch.getQueuedThreads().size());
        latch.releaseAll();
        Thread.sleep(50);
        assertEquals("No threads should be waiting", false,
                latch.hasQueuedThreads());
    }
    public void testTenWait() throws Exception {
        latch = new LimitLatch(10);
        assertEquals("No threads should be waiting", false,
                latch.hasQueuedThreads());
        Thread[] testThread = new TestThread[30];
        for (int i = 0; i < 30; i++) {
            testThread[i] = new TestThread(1000);
            testThread[i].start();
        }
        Thread.sleep(50);
        assertEquals("20 threads should be waiting", 20,
                latch.getQueuedThreads().size());
        Thread.sleep(1000);
        assertEquals("10 threads should be waiting", 10,
                latch.getQueuedThreads().size());
        Thread.sleep(1000);
        assertEquals("No threads should be waiting", false,
                latch.hasQueuedThreads());
    }
    private class TestThread extends Thread {
        
        private int holdTime;
        
        public TestThread() {
            this(100);
        }
        
        public TestThread(int holdTime) {
            this.holdTime = holdTime;
        }
 
        @Override
        public void run() {
            try {
                latch.countUpOrAwait();
                Thread.sleep(holdTime);
                latch.countDown();
            } catch (InterruptedException x) {
                x.printStackTrace();
            }
        }
    }
      <fix>
        <bug>51240</bug>: Ensure that maxConnections limit is enforced when
        multiple acceptor threads are configured. (markt)
      </fix>

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Ant task that implements the <code>/findleaks</code> command, supported by
 * the Tomcat manager application.
 */
    private boolean statusLine = true;
    /**
     * Sets the statusLine parameter that controls if the response includes a
     * status line or not.
     */
    public void setStatusLine(boolean statusLine) {
        this.statusLine = statusLine;
    }
    /**
     * Returns the statusLine parameter that controls if the response includes a
     * status line or not.
     */
    public boolean getStatusLine() {
        return statusLine;
    }
    /**
     * Execute the requested operation.
     *
     * @exception BuildException if an error occurs
     */
    @Override
    public void execute() throws BuildException {
        super.execute();
        execute("/findleaks?statusLine=" + Boolean.toString(statusLine));
    }
======= 1cd5e7b:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        super.findleaks(false, printWriter, smClient);
        String writerText = stringWriter.toString();
        if (writerText.length() > 0) {
            if (!writerText.startsWith("FAIL -")) {
                msg.append(smClient.getString(
                        "htmlManagerServlet.findleaksList"));
            }
            msg.append(writerText);
======= 1cd5e7b:"java/org/apache/catalina/manager/ManagerServlet.java"

        
        boolean statusLine = false;
        if ("true".equals(request.getParameter("statusLine"))) {
            statusLine = true;
        }
======= 1cd5e7b:"java/org/apache/catalina/manager/ManagerServlet.java"

            findleaks(statusLine, writer, smClient);
======= 1cd5e7b:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void findleaks(boolean statusLine, PrintWriter writer,
            StringManager smClient) {
======= 1cd5e7b:"java/org/apache/catalina/manager/ManagerServlet.java"

        if (results.length > 0) {
            if (statusLine) {
                writer.println(
                        smClient.getString("managerServlet.findleaksList"));
            }
            for (String result : results) {
                if ("".equals(result)) {
                    result = "/";
                }
                writer.println(result);
        } else if (statusLine) {
            writer.println(smClient.getString("managerServlet.findleaksNone"));
  &lt;taskdef name="findleaks" classname="org.apache.catalina.ant.FindLeaksTask"/&gt;

======= 4161179:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

     * with IE.
    protected boolean securePagesWithPragma = false;
======= 4161179:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

            !request.isSecure() &&
                // Note: These can cause problems with downloading files with IE
        <bug>27122</bug>: Remove a workaround for a very old and since fixed
        Mozilla bug and change the default value of the securePagesWithPragma
        attribute of the Authenticator Valves to false. These changes should
        reduce the likelihood of issues when downloading files with IE. (markt) 
      </fix>
      <fix>
        If not set, the default value of <code>false</code> will be used.</p>
        If not set, the default value of <code>false</code> will be used.</p>
        If not set, the default value of <code>false</code> will be used.</p>
        If not set, the default value of <code>false</code> will be used.</p>
        If not set, the default value of <code>false</code> will be used.</p>

======= 4bdd8d0:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    public ConnectionPool createPool() throws SQLException {
        if (pool != null) {
            return pool;
        } else {
            return pCreatePool();
        }
    }
    
    /**
     * Sets up the connection pool, by creating a pooling driver.
     * @return Driver
     * @throws SQLException
     */
    private synchronized ConnectionPool pCreatePool() throws SQLException {

======= 9bb6e4f:"java/org/apache/catalina/startup/HostConfig.java"

                if ( (!dirs[i].isDirectory()) && (!dirs[i].mkdirs())) {
        <bug>35054</bug>: Check that a file is not specified for a Host&apos;s
        appBase and log an error if it is. (markt)
      </fix>
      <fix>

======= c46e56c:"java/org/apache/jasper/compiler/Generator.java"

    private static final boolean POOL_TAGS_WITH_EXTENDS =
        Boolean.getBoolean("org.apache.jasper.compiler.Generator.VAR_EXPRESSIONFACTORY");
======= c46e56c:"java/org/apache/jasper/compiler/Generator.java"

        if (pageInfo.getExtends(false) == null || POOL_TAGS_WITH_EXTENDS) {
  <subsection name="Jasper">
    <changelog>
      <add>
        <bug>51220</bug>: Add a system property to enable tag pooling with JSPs
        that use a custom base class. Based on a patch by Dan Mikusa. (markt)
      </add>
    </changelog>
  </subsection>
    <property name="org.apache.jasper.compiler. Generator.POOL_TAGS_WITH_EXTENDS">
      <p>By default, JSPs that use their own base class via the extends
      attribute of the page directive, will have Tag pooling disabled since
      Jasper cannot guarantee that the necessary initialisation will have taken
      place. This can have a negative impact on performance. Providing the
      alternative base class calls _jspInit() from Servlet.init(), setting  this
      property to <code>true</code> will enable pooling with an alternative base
      class. If the alternative base class does not call _jspInit() and this
      property is <code>true</code>, NPEs will occur when attempting to use
      tags.</p>
      <p>If not specified, the default value of <code>false</code> will be used.
      </p>
    </property>

      <fix>
        <bug>51229</bug>: Fix bugs in the Servlet 3.0 asynchronous examples.
        Patch provided by Eiji Takahashi. (markt)
      </fix>
======= 55d8b72:"webapps/examples/WEB-INF/classes/async/Async0.java"

            req.getAsyncContext().complete();
   <a href="<%=response.encodeURL("/examples/async/stockticker")%>"> StockTicker </a>

======= b24b17c:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java"

        private volatile int nrOfInvocations;
        private volatile long maxInvocationTime = Long.MIN_VALUE;
        private volatile long maxInvocationDate;
        private volatile long minInvocationTime = Long.MAX_VALUE;
        private volatile long minInvocationDate;
        private volatile long totalInvocationTime;
        private volatile long failures;
        private volatile int prepareCount;
        private volatile long prepareTime;

======= 2bb247a:"modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

                            definitions[i+1].addProperty(new InterceptorProperty(propName,propValue));

======= de7f0e1:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        " <td class=\"row-left\" bgcolor=\"{13}\">\n" +
======= de7f0e1:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        " </tr><tr>\n" +
        " <td class=\"row-left\" bgcolor=\"{13}\">\n" +
        "  <form method=\"POST\" action=\"{8}\">\n" +
        "  <small>\n" +
        "  &nbsp;<input type=\"submit\" value=\"{9}\">&nbsp;{10}&nbsp;<input type=\"text\" name=\"idle\" size=\"5\" value=\"{11}\">&nbsp;{12}&nbsp;\n" +
        "  </small>\n" +
        "  </form>\n" +
        " </td>\n" +
        "</tr>\n";
      <fix>
        <bug>51156</bug>: Ensure session expiration option is available in
        Manager application was running web applications that were defined in
        server.xml. (markt)
      </fix>

======= f477068:"java/javax/servlet/jsp/el/ELException.java"

 * @deprecated As of JSP 2.1, replaced by javax.el.ELException
======= f477068:"java/javax/servlet/jsp/el/ELParseException.java"

 * @deprecated As of JSP 2.1, replaced by javax.el.ELException
======= f477068:"java/javax/servlet/jsp/el/Expression.java"

 * @deprecated As of JSP 2.1, replaced by javax.el.ValueExpression
======= f477068:"java/javax/servlet/jsp/el/ExpressionEvaluator.java"

 * @deprecated As of JSP 2.1, replaced by javax.el.ExpressionFactory
======= f477068:"java/javax/servlet/jsp/el/FunctionMapper.java"

 * @deprecated As of JSP 2.1, replaced by javax.el.FunctionMapper
======= f477068:"java/javax/servlet/jsp/el/VariableResolver.java"

 * @deprecated As of JSP 2.1, replaced by javax.el.ELResolver
      <fix>
        <bug>51155</bug>: Add comments to @deprecated tags that have none. Patch
        provided by sebb. (markt)
      </fix>

======= 01e1850:"java/javax/servlet/ServletContext.java"

======= 01e1850:"java/javax/servlet/ServletContext.java"

======= 01e1850:"java/javax/servlet/ServletContext.java"

======= 01e1850:"java/javax/servlet/ServletContext.java"

      <fix>
        <bug>51154</bug>: Remove duplicate @deprecated tags in ServletContext
        Javadoc. Patch provided by sebb. (markt)
      </fix>

======= 0559491:"java/org/apache/catalina/ha/session/DeltaSession.java"

            if (addDeltaRequest && deltaRequest != null && !exclude(name)) {
                deltaRequest.setAttribute(name, value);
            }
======= 0559491:"java/org/apache/catalina/ha/session/DeltaSession.java"

            if (addDeltaRequest && deltaRequest != null && !exclude(name)) {
                deltaRequest.removeAttribute(name);
            }
  <subsection name="Cluster">
    <changelog>
      <fix>
        <bug>50950</bug>: Correct possible NotSerializableException for an
        authenticated session when running with a security manager. (markt)
      </fix>
    </changelog>
  </subsection>

======= 343a609:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

======= 343a609:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

                lc = new LoginContext(getLoginConfigName());
======= 343a609:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

            final GSSManager manager = GSSManager.getInstance();
            final PrivilegedExceptionAction<GSSCredential> action =
                new PrivilegedExceptionAction<GSSCredential>() {
                    @Override
                    public GSSCredential run() throws GSSException {
                        return manager.createCredential(null,
                                GSSCredential.DEFAULT_LIFETIME,
                                new Oid("1.3.6.1.5.5.2"),
                                GSSCredential.ACCEPT_ONLY);
                    }
                };
            gssContext = manager.createContext(Subject.doAs(lc.getSubject(), action));
======= 343a609:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

                    isStoreDelegatedCredential());
======= 343a609:"java/org/apache/catalina/authenticator/SpnegoAuthenticator.java"

        } catch (PrivilegedActionException e) {
            log.error(sm.getString("spnegoAuthenticator.serviceLoginFail", e));
            response.setHeader("WWW-Authenticate", "Negotiate");
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
            return false;
      <fix>
        <bug>51099</bug>: Correctly implement non-default login configurations
        (configured via the loginConfigName attribute) for the the SPNEGO
        authenticator. (fhanik/markt)
      </fix>

======= 2ffa0f7:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

    protected String loginModuleName = null;
======= 2ffa0f7:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

        
        loginModuleName = System.getProperty(
                "com.sun.management.jmxremote.login.config");
======= 2ffa0f7:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

                env.put("jmx.remote.x.login.config", loginModuleName);
        <bug>51119</bug>: Add JAAS authentication support to the
        JMXRemoteLifecycleListener. Patch provided by Neil Laurance. (markt) 
      </add>
      <add>

======= 2cdbcd5:"java/org/apache/jasper/runtime/BodyContentImpl.java"

        cb = new char[Constants.DEFAULT_TAG_BUFFER_SIZE];
        bufferSize = cb.length;
======= 2cdbcd5:"java/org/apache/jasper/runtime/BodyContentImpl.java"

                cb = new char[Constants.DEFAULT_TAG_BUFFER_SIZE];
                bufferSize = cb.length;
======= 2cdbcd5:"java/org/apache/jasper/runtime/BodyContentImpl.java"

        char[] tmp = new char[cb.length + len];
        bufferSize = cb.length;
      <add>
        <bug>51124</bug>: Refactor BodyContentImpl to assist in determining the
        root cause of this bug. Based on a patch by Ramiro. (markt)
      </add>

======= 2dc54c4:"java/org/apache/catalina/startup/Tomcat.java"

        return addContext(host, contextPath, contextPath, dir);
    }
    public Context addContext(Host host, String contextPath, String contextName,
            String dir) {
        ctx.setName(contextName);
        ctx.setPath(contextPath);
======= 2dc54c4:"java/org/apache/catalina/startup/Tomcat.java"

        return addWebapp(host, url, url, path);
    }
    public Context addWebapp(Host host, String url, String name, String path) {
        ctx.setName(name);
        ctx.setPath(url);
      <add>
        <bug>51136</bug>: Provide methods that enable the name of a Context on
        Context creation when using Tomcat in an embedded scenario. Based on a
        patch provided by David Calavera. (markt)
      </add>

======= 75d28d4:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                        return;
      <fix>
        <bug>51095</bug>: Don&apos;t trigger a NullPointerException when the SSL
        handshake fails with the HTTP-APR connector. Patch provided by Mike
        Glazer. (markt)
      </fix>

======= 3a847c7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            } else if ("all".equalsIgnoreCase(SSLProtocol) ||
                    SSLProtocol == null || SSLProtocol.length() == 0) {
                // NOOP, use the default defined above
            } else {
                // Protocol not recognized, fail to start as it is safer than
                // continuing with the default which might enable more than the
                // is required
                throw new Exception(sm.getString(
                        "endpoint.apr.invalidSslProtocol", SSLProtocol));
      <fix>
        <bug>51073</bug>: Throw an exception and do not start the APR connector
        if it is configured for SSL and an invalid value is provided for
        SSLProtocol. (markt)
      </fix>

======= dc3758e:"java/org/apache/catalina/Session.java"

     * Set the session identifier for this session and notifies any associated
     * listeners that a new session has been created.
======= dc3758e:"java/org/apache/catalina/Session.java"

     * Set the session identifier for this session and optionally notifies any
     * associated listeners that a new session has been created.
     *
     * @param id        The new session identifier
     * @param notify    Should any associated listeners be notified that a new
     *                      session has been created? 
     */
    public void setId(String id, boolean notify);
    /**
======= dc3758e:"java/org/apache/catalina/ha/session/DeltaManager.java"

        session.setId(msg.getSessionID(), notifySessionListenersOnReplication);
======= dc3758e:"java/org/apache/catalina/ha/session/DeltaManager.java"

            session.setId(newSessionID, notifyListenersOnReplication);
======= dc3758e:"java/org/apache/catalina/ha/session/DeltaSession.java"

     * {@inheritDoc}
    @Override
    public void setId(String id, boolean notify) {
        super.setId(id, notify);
======= dc3758e:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

        catalinaSession.setId(newSessionID, false);
======= dc3758e:"java/org/apache/catalina/manager/DummyProxySession.java"

    public void setId(String id, boolean notify) {
        this.sessionId = id;
        // Ignore notify
    }
    @Override
======= dc3758e:"java/org/apache/catalina/session/ManagerBase.java"

        session.setId(generateSessionId(), false);
======= dc3758e:"java/org/apache/catalina/session/StandardSession.java"

        setId(id, true);
    }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setId(String id, boolean notify) {
======= dc3758e:"java/org/apache/catalina/session/StandardSession.java"

        
        if (notify) {
            tellNew();
        }
      <fix>
        <bug>51042</bug>: Don&apos;t trigger session creation listeners when a
        session ID is changed as part of the authentication process. (markt)
      </fix>

======= dc3dff4:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                ((Context) request.getMappingData().context).logAccess(
                        request, response,
                        System.currentTimeMillis() - req.getStartTime(),
                        false);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    // Time for a request to process (need to allow for threads to start etc.)
    private static final long REQUEST_TIME = 500;
    // Timeout thread (where used) checks for timeout every second
    private static final long TIMEOUT_MARGIN = 1000;
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() >
                Bug49528Servlet.THREAD_SLEEP_TIME);
        assertTrue(entry.toString(), entry.getTime() <
                Bug49528Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() >
        Bug49567Servlet.THREAD_SLEEP_TIME);
        assertTrue(entry.toString(), entry.getTime() <
                Bug49567Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        
        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(2, entries.size());
        for (Entry entry : entries) {
            assertEquals(200, entry.getStatus());
            assertTrue(entry.toString(), entry.getTime() >
                    AsyncStartNoCompleteServlet.ASYNC_TIMEOUT);
            assertTrue(entry.toString(), entry.getTime() <
                    AsyncStartNoCompleteServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN +
                            REQUEST_TIME);
        }
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() < REQUEST_TIME);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        public static final long THREAD_SLEEP_TIME = 1000;
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                        Thread.sleep(THREAD_SLEEP_TIME);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        public static final long THREAD_SLEEP_TIME = 1000;
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                                Thread.sleep(THREAD_SLEEP_TIME);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        public static final long ASYNC_TIMEOUT = 1000;
        
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

            actxt.setTimeout(ASYNC_TIMEOUT);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() >
                TimeoutServlet.ASYNC_TIMEOUT);
        assertTrue(entry.toString(), entry.getTime() <
                TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        public static final long ASYNC_TIMEOUT = 3000;
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                ac.setTimeout(ASYNC_TIMEOUT);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        
        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() > 0);
        assertTrue(entry.toString(), entry.getTime() < REQUEST_TIME);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() >
                TimeoutServlet.ASYNC_TIMEOUT);
        assertTrue(entry.toString(), entry.getTime() <
                TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        
        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() > 0);
        assertTrue(entry.toString(), entry.getTime() < REQUEST_TIME);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() >
        AsyncStartRunnable.THREAD_SLEEP_TIME);
        assertTrue(entry.toString(), entry.getTime() <
                AsyncStartRunnable.THREAD_SLEEP_TIME + REQUEST_TIME);
        public static final long THREAD_SLEEP_TIME = 3000;
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                        Thread.sleep(THREAD_SLEEP_TIME);
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TesterAccessLogValve alv = new TesterAccessLogValve();
        ctx.getPipeline().addValve(alv);
        
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        
        // Check the access log
        List<Entry> entries = alv.getEntries();
        assertEquals(1, entries.size());
        Entry entry = entries.get(0);
        assertEquals(200, entry.getStatus());
        assertTrue(entry.toString(), entry.getTime() >
        Bug50753Servlet.THREAD_SLEEP_TIME);
        assertTrue(entry.toString(), entry.getTime() <
                Bug50753Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);
        public static final long THREAD_SLEEP_TIME = 5000;
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                        Thread.sleep(THREAD_SLEEP_TIME); 
======= dc3dff4:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private List<Entry> entries = new ArrayList<Entry>();
    public TesterAccessLogValve() {
        // Async requests are supported
        super(true);
    }
    @Override
    public void log(Request request, Response response, long time) {
        entries.add(new Entry(request.getRequestURI(), response.getStatus(),
                time));
    }
    @Override
    public void setRequestAttributesEnabled(boolean requestAttributesEnabled) {
        // NOOP - test code
    }
    @Override
    public boolean getRequestAttributesEnabled() {
        // Always false - test code
        return false;
    }
    @Override
    public void invoke(Request request, Response response) throws IOException,
            ServletException {
        // Just invoke next - access logging happens via log() method
        getNext().invoke(request, response);
    }
    public List<Entry> getEntries() {
        return entries;
    }
    public static class Entry {
        private String uri;
        private int status;
        private long time;
        public Entry(String uri, int status, long time) {
            this.uri = uri;
            this.status = status;
            this.time = time;
        }
        public String getUri() {
            return uri;
        }
        public int getStatus() {
            return status;
        }
        public long getTime() {
            return time;
        }
        @Override
        public String toString() {
            return "Uri: " + uri + ", Status: " + status + ", Time: " + time;
        }
    }
      <fix>
        <bug>51038</bug>: Ensure that asynchronous requests are included in
        access logs. (markt)
      </fix>

======= 62ddb9e:"java/org/apache/catalina/startup/ContextConfig.java"

            WebXml fragment = new WebXml();
======= 62ddb9e:"java/org/apache/catalina/startup/ContextConfig.java"

======= 62ddb9e:"java/org/apache/catalina/startup/ContextConfig.java"

                fragment.setURL(file.toURI().toURL());
                if (fragment.getName() == null) {
                    fragment.setName(fragment.getURL().toString());
                fragments.put(fragment.getName(), fragment);
======= 62ddb9e:"java/org/apache/tomcat/util/scan/StandardJarScanner.java"

        } else if (isScanAllDirectories()){
            int start = path.lastIndexOf('/');
            name = path.substring(start + 1);
      <fix>
        <bug>50997</bug>: Relax the requirement that directories must have a
        name ending in <code>.jar</code> to be treated as an expanded JAR file
        by the default JarScanner. Based on patch by Rodion Zhitomirsky. (markt)
      </fix>

======= e34f848:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            if (SSLCertificateFile == null) {
                // This is required
                throw new Exception(sm.getString("endpoint.apr.noSslCertFile"));
            }
        <bug>50927</bug>: Improve error message when SSLCertificateFile is not
        specified when using APR with SSL. Based on a patch provided by sebb.
        (markt)
      </fix>
      <fix>

======= 0c96676:"java/javax/servlet/http/HttpUtils.java"

            throw new IllegalArgumentException(e.getMessage(), e);
======= 0c96676:"java/javax/servlet/http/HttpUtils.java"

            throw new IllegalArgumentException(e.getMessage(), e);
======= 0c96676:"java/org/apache/catalina/connector/CoyoteInputStream.java"

                    throw new RuntimeException(e.getMessage(), e);
======= 0c96676:"java/org/apache/catalina/connector/CoyoteInputStream.java"

                    throw new RuntimeException(e.getMessage(), e);
======= 0c96676:"java/org/apache/catalina/connector/CoyoteInputStream.java"

                    throw new RuntimeException(e.getMessage() ,e);
======= 0c96676:"java/org/apache/catalina/connector/CoyoteInputStream.java"

                    throw new RuntimeException(e.getMessage(), e);
======= 0c96676:"java/org/apache/catalina/connector/CoyoteInputStream.java"

                    throw new RuntimeException(e.getMessage(), e);
======= 0c96676:"java/org/apache/catalina/realm/JDBCRealm.java"

                throw new SQLException(e.getMessage(), e);
======= 0c96676:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

                throw new SQLException(e.getMessage(), e);
======= 0c96676:"java/org/apache/naming/resources/WARDirContext.java"

                throw new IOException(e.getMessage(), e);
======= 0c96676:"java/org/apache/tomcat/util/digester/NodeCreateRule.java"

                throw new SAXException(e.getMessage(), e);
======= 0c96676:"java/org/apache/tomcat/util/digester/NodeCreateRule.java"

                throw new SAXException(e.getMessage(), e);
======= 0c96676:"java/org/apache/tomcat/util/digester/NodeCreateRule.java"

                throw new SAXException(e.getMessage(), e);
======= 0c96676:"java/org/apache/tomcat/util/digester/NodeCreateRule.java"

                throw new SAXException(e.getMessage(), e);
      <fix>
        <bug>50929</bug>When wrapping an exception, include the root cause.
        Patch provided by sebb. (markt) 
      </fix>

======= c8ea62e:"java/org/apache/coyote/ajp/AjpProcessor.java"

            if (endpoint.isPaused()) {
                // 503 - Service unavailable
                response.setStatus(503);
                adapter.log(request, response, 0);
                error = true;
            }
======= c8ea62e:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                    if (endpoint.isPaused()) {
                        // 503 - Service unavailable
                        response.setStatus(503);
                        adapter.log(request, response, 0);
                        error = true;
                    } else {
                        break;
                    }
                if (!endpoint.isPaused()) {
                    request.setStartTime(System.currentTimeMillis());
                    keptAlive = true;
                    if (!disableUploadTimeout) {
                        Socket.timeoutSet(socketRef,
                                connectionUploadTimeout * 1000);
                    }
                    inputBuffer.parseHeaders();
======= c8ea62e:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                    if (endpoint.isPaused()) {
                        // 503 - Service unavailable
                        response.setStatus(503);
                        adapter.log(request, response, 0);
                        error = true;
                    } else {
                        break;
                    }
                if (!endpoint.isPaused()) {
                    keptAlive = true;
                    if ( !inputBuffer.parseHeaders() ) {
                        //we've read part of the request, don't recycle it
                        //instead associate it with the socket
                        openSocket = true;
                        recycle = false;
                        break;
                    }
                    request.setStartTime(System.currentTimeMillis());
                    if (!disableUploadTimeout) { //only for body, not for request headers
                        socket.getIOChannel().socket().setSoTimeout(
                                connectionUploadTimeout);
                    }
======= c8ea62e:"java/org/apache/coyote/http11/Http11Processor.java"

                if (endpoint.isPaused()) {
                    // 503 - Service unavailable
                    response.setStatus(503);
                    adapter.log(request, response, 0);
                    error = true;
                    request.setStartTime(System.currentTimeMillis());
                    keptAlive = true;
                    if (disableUploadTimeout) {
                        socket.getSocket().setSoTimeout(soTimeout);
                    } else {
                        socket.getSocket().setSoTimeout(connectionUploadTimeout);
                    }
                    inputBuffer.parseHeaders();
======= c8ea62e:"java/org/apache/coyote/http11/Http11Processor.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Test cases for {@link Connector}. 
 */
    public void testStop() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        
        Context root = tomcat.addContext("", TEMP_DIR);
        Wrapper w =
            Tomcat.addServlet(root, "tester", new TesterServlet());
        w.setAsyncSupported(true);
        root.addServletMapping("/", "tester");
        Connector connector = tomcat.getConnector();
        
        tomcat.start();
        ByteChunk bc = new ByteChunk();
        int rc = getUrl("http://localhost:" + getPort() + "/", bc, null, null);
        
        assertEquals(200, rc);
        assertEquals("OK", bc.toString());
        
        rc = -1;
        bc.recycle();
        connector.stop();
        rc = getUrl("http://localhost:" + getPort() + "/", bc, 1000,
                null, null);
        assertEquals(503, rc);
    }
======= c8ea62e:"java/org/apache/coyote/http11/Http11Processor.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    private static final long serialVersionUID = 1L;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        
        resp.setContentType("text/plain");
        PrintWriter out = resp.getWriter();
        out.print("OK");
    }
======= c8ea62e:"test/org/apache/catalina/startup/TomcatBaseTest.java"

    public static final String TEMP_DIR = System.getProperty("java.io.tmpdir");
======= c8ea62e:"test/org/apache/catalina/startup/TomcatBaseTest.java"

        return getUrl(path, out, 1000000, reqHead, resHead);
    }
    
    public static int getUrl(String path, ByteChunk out, int readTimeout,
            Map<String, List<String>> reqHead,
            Map<String, List<String>> resHead) throws IOException {
        connection.setUseCaches(false);
        connection.setReadTimeout(readTimeout);
      <fix>
        <bug>50903</bug>: When a connector is stopped, ensure that requests that
        are currently in a keep-alive state and waiting for client data are not
        processed. Requests where processing has started will continue to
        completion. (markt) 
      </fix>

======= 552c4b7:"java/org/apache/catalina/valves/SSLValve.java"

======= 552c4b7:"java/org/apache/catalina/valves/SSLValve.java"

======= 552c4b7:"java/org/apache/catalina/valves/SSLValve.java"

    private static final Log log = LogFactory.getLog(SSLValve.class);
======= 552c4b7:"java/org/apache/catalina/valves/SSLValve.java"

            String providerName = (String) request.getConnector().getProperty(
                    "clientCertProvider");
                CertificateFactory cf;
                if (providerName == null) {
                    cf = CertificateFactory.getInstance("X.509");    
                } else {
                    cf = CertificateFactory.getInstance("X.509", providerName);
                }
            } catch (NoSuchProviderException e) {
                log.error(sm.getString(
                        "sslValve.invalidProvider", providerName), e);
======= 552c4b7:"java/org/apache/coyote/AbstractProtocolHandler.java"

    /**
     * When client certificate information is presented in a form other than
     * instances of {@link java.security.cert.X509Certificate} it needs to be
     * converted before it can be used and this property controls which JSSE
     * provider is used to perform the conversion. For example it is used with
     * the AJP connectors, the HTTP APR connector and with the
     * {@link org.apache.catalina.valves.SSLValve}. If not specified, the
     * default provider will be used. 
     */
    protected String clientCertProvider = null;
    public String getClientCertProvider() { return clientCertProvider; }
    public void setClientCertProvider(String s) { this.clientCertProvider = s; }
======= 552c4b7:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

======= 552c4b7:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

    /**
     * When client certificate information is presented in a form other than
     * instances of {@link java.security.cert.X509Certificate} it needs to be
     * converted before it can be used and this property controls which JSSE
     * provider is used to perform the conversion. For example it is used with
     * the AJP connectors, the HTTP APR connector and with the
     * {@link org.apache.catalina.valves.SSLValve}. If not specified, the
     * default provider will be used. 
     */
    protected String clientCertProvider = null;
    public String getClientCertProvider() { return clientCertProvider; }
    public void setClientCertProvider(String s) { this.clientCertProvider = s; }
======= 552c4b7:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

                   CertificateFactory cf;
                   if (clientCertProvider == null) {
                       cf = CertificateFactory.getInstance("X.509");
                   } else {
                       cf = CertificateFactory.getInstance("X.509",
                               clientCertProvider);
                   }
======= 552c4b7:"java/org/apache/coyote/ajp/AbstractAjpProcessor.java"

               } catch (NoSuchProviderException e) {
                   getLog().error(sm.getString("ajpprocessor.certs.fail"), e);
                   return;
======= 552c4b7:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

            processor.setClientCertProvider(proto.getClientCertProvider());
======= 552c4b7:"java/org/apache/coyote/ajp/AjpProtocol.java"

            processor.setClientCertProvider(proto.getClientCertProvider());
======= 552c4b7:"java/org/apache/coyote/http11/Http11AprProcessor.java"

    /**
     * When client certificate information is presented in a form other than
     * instances of {@link java.security.cert.X509Certificate} it needs to be
     * converted before it can be used and this property controls which JSSE
     * provider is used to perform the conversion. For example it is used with
     * the AJP connectors, the HTTP APR connector and with the
     * {@link org.apache.catalina.valves.SSLValve}. If not specified, the
     * default provider will be used. 
     */
    protected String clientCertProvider = null;
    public String getClientCertProvider() { return clientCertProvider; }
    public void setClientCertProvider(String s) { this.clientCertProvider = s; }
======= 552c4b7:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                        CertificateFactory cf;
                        if (clientCertProvider == null) {
                            cf = CertificateFactory.getInstance("X.509"); 
                        } else {
                            cf = CertificateFactory.getInstance("X.509",
                                    clientCertProvider); 
                        }
======= 552c4b7:"java/org/apache/coyote/http11/Http11AprProtocol.java"

            processor.setClientCertProvider(proto.getClientCertProvider());
  <subsection name="Coyote">
    <changelog>
      <add>
        <bug>50887</bug>: Add support for configuring the JSSE provider used to
        convert client certificates. Based on a patch by pknopp. (markt)
      </add>
    </changelog>
  </subsection>
    <attribute name="clientCertProvider" required="false">
      <p>When client certificate information is presented in a form other than
      instances of <code>java.security.cert.X509Certificate</code> it needs to
      be converted before it can be used and this property controls which JSSE
      provider is used to perform the conversion. For example it is used with
      the AJP connectors, the <a href="http.html">HTTP APR connector</a> and
      with the <a href="valve.html#SSL_Authenticator_Valve">
      org.apache.catalina.valves.SSLValve</a>.If not specified, the default
      provider will be used.</p>
    </attribute>
    <attribute name="clientCertProvider" required="false">
      <p>When client certificate information is presented in a form other than
      instances of <code>java.security.cert.X509Certificate</code> it needs to
      be converted before it can be used and this property controls which JSSE
      provider is used to perform the conversion. For example it is used with
      the <a href="ajp.html">AJP connectors</a>, the HTTP APR connector and
      with the <a href="valve.html#SSL_Authenticator_Valve">
      org.apache.catalina.valves.SSLValve</a>. If not specified, the default
      provider will be used.</p>
    </attribute>

======= 5d61212:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

                clazz = Class.forName(className, false, tccl);
      <fix>
        <bug>50895</bug>: Don&apos;t initialize classes created during the
        compilation stage. (markt)
      </fix>

======= 1211dbe:"java/org/apache/catalina/core/StandardContext.java"

        // Binding thread
        ClassLoader oldCCL = bindThread();
======= 1211dbe:"java/org/apache/catalina/deploy/NamingResources.java"

======= 1211dbe:"java/org/apache/catalina/deploy/NamingResources.java"

======= 1211dbe:"java/org/apache/catalina/deploy/NamingResources.java"

        cleanUp();
    /**
     * Close those resources that an explicit close may help clean-up faster.
     */
    private void cleanUp() {
        if (resources.size() == 0) {
            return;
        }
        javax.naming.Context ctxt;
        try {
            if (container instanceof Server) {
                ctxt = ((Server) container).getGlobalNamingContext();
            } else {
                ctxt = ContextBindings.getClassLoader();
                ctxt = (javax.naming.Context) ctxt.lookup("comp/env");
            }
        } catch (NamingException e) {
            log.warn(sm.getString("namingResources.cleanupNoContext",
                    container), e);
            return;
        }
        for (ContextResource cr: resources.values()) {
            if (DataSource.class.getName().equals(cr.getType())) {
                String name = cr.getName();
                DataSource ds;
                try {
                     ds = (DataSource) ctxt.lookup(name);
                } catch (NamingException e) {
                    log.warn(sm.getString("namingResources.cleanupNoResource",
                            cr.getName(), container), e);
                    continue;
                }
                cleanUp(ds, name);
            }
        }
    }
    /**
     * Closing a database connection pool will close it's open connections. This
     * will happen on GC but that leaves db connections open that may cause
     * issues.
     * @param ds    The DataSource to close.
     */
    private void cleanUp(DataSource ds, String name) {
        // Look for a zero-arg close() method
        Method m = null;
        try {
            m = ds.getClass().getMethod("close", (Class<?>[]) null);
        } catch (SecurityException e) {
            log.debug(sm.getString("namingResources.cleanupCloseSecurity", name,
                    container));
            return;
        } catch (NoSuchMethodException e) {
            log.debug(sm.getString("namingResources.cleanupNoClose", name,
                    container));
            return;
        }
        if (m != null) {
            try {
                m.invoke(ds, (Object[]) null);
            } catch (IllegalArgumentException e) {
                log.warn(sm.getString("namingResources.cleanupCloseFailed",
                        name, container), e);
            } catch (IllegalAccessException e) {
                log.warn(sm.getString("namingResources.cleanupCloseFailed",
                        name, container), e);
            } catch (InvocationTargetException e) {
                log.warn(sm.getString("namingResources.cleanupCloseFailed",
                        name, container), e);
            }
        }
    }
      <add>
        <bug>25060</bug>: Close Apache Commons DBCP datasources when the
        associated JNDI naming context is stopped (e.g. for a non-global
        DataSource resource on web application reload) to close remaining
        database connections immediately rather than waiting for garbage 
        collection. (markt)
      </add>
      <add>
      </add>
      <add>
      </add>

======= f622e3a:"java/org/apache/catalina/loader/WebappLoader.java"

                DirContextURLStreamHandlerFactory.getInstance();
======= f622e3a:"java/org/apache/naming/resources/Constants.java"

======= f622e3a:"java/org/apache/naming/resources/DirContextURLStreamHandlerFactory.java"

 * Factory for Stream handlers to a JNDI directory context that also supports
 * users specifying additional stream handler.
        implements URLStreamHandlerFactory {
    // Singleton
    private static DirContextURLStreamHandlerFactory instance =
        new DirContextURLStreamHandlerFactory();
    public static DirContextURLStreamHandlerFactory getInstance() {
        return instance;
    }
    public static void addUserFactory(URLStreamHandlerFactory factory) {
        instance.userFactories.add(factory);
    }
    private List<URLStreamHandlerFactory> userFactories =
        new CopyOnWriteArrayList<URLStreamHandlerFactory>();
    private DirContextURLStreamHandlerFactory() {
        // Hide the default constructor
======= f622e3a:"java/org/apache/naming/resources/DirContextURLStreamHandlerFactory.java"

            for (URLStreamHandlerFactory factory : userFactories) {
                URLStreamHandler handler =
                    factory.createURLStreamHandler(protocol);
                if (handler != null) {
                    return handler;
                }
            }
======= f622e3a:"java/org/apache/naming/resources/DirContextURLStreamHandlerFactory.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    public void testUserSuppliedFactory() throws Exception {
        
        URL url = null;
        
        // Initially unknown
        try {
            url = new URL("foo://www.apache.org");
        } catch (MalformedURLException ignore) {
            // Ignore
        }
        assertNull(url);
        
        // Set the factory
        URL.setURLStreamHandlerFactory(
                DirContextURLStreamHandlerFactory.getInstance());
        // Still unknown
        try {
            url = new URL("foo://www.apache.org");
        } catch (MalformedURLException ignore) {
            // Ignore
        }
        assertNull(url);
        // Register a user factory
        DirContextURLStreamHandlerFactory.addUserFactory(
                new FooURLStreamHandlerFactory());
        
        // Now it works
        try {
            url = new URL("foo://www.apache.org");
        } catch (MalformedURLException ignore) {
            // Ignore
        }
        assertNotNull(url);
    }
    
    public static class FooURLStreamHandlerFactory
            implements URLStreamHandlerFactory {
        @Override
        public URLStreamHandler createURLStreamHandler(String protocol) {
            if ("foo".equals(protocol)) {
                // This is good enough for this test but not for actual use
                return new DirContextURLStreamHandler();
            } else {
                return null;
            }
        }
    }
        <bug>26701</bug>: Provide a mechanism for users to register their own
        <code>URLStreamHandlerFactory</code> objects. (markt)
      </fix>
      <fix>

======= b24b0c0:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

        if (log.isDebugEnabled()) {
            String name = (principal == null) ? "none" : principal.getName(); 
            log.debug("Authenticated '" + name + "' with type '" + authType +
                    "'");
        }
  <subsection name="Catalina">
    <changelog>
      <fix>
        <bug>50855</bug>: Fix NPE on HttpServletRequest.logout() when debug
        logging is enabled. (markt)
      </fix>
    </changelog>
  </subsection>

======= ef547fb:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        try {
            PooledConnection pc = borrowConnection(0, null, null);
            if (pc!=null) {
                return new ConnectionFuture(pc);
            } 
        }catch (SQLException x) {
            if (x.getMessage().indexOf("NoWait")<0) {
                throw x;
            }
        }

======= 4a4d86e:"java/org/apache/naming/resources/DirContextURLConnection.java"

        throw new FileNotFoundException(
                getURL() == null ? "null" : getURL().toString());
======= 4a4d86e:"java/org/apache/naming/resources/DirContextURLConnection.java"

            throw new FileNotFoundException(
                    getURL() == null ? "null" : getURL().toString());
======= 4a4d86e:"java/org/apache/naming/resources/DirContextURLConnection.java"

            throw new FileNotFoundException(
                    getURL() == null ? "null" : getURL().toString());
======= 4a4d86e:"java/org/apache/naming/resources/DirContextURLConnection.java"

                throw new FileNotFoundException(
                        getURL() == null ? "null" : getURL().toString());
        <bug>27988</bug>: Improve reporting of missing files. (markt)
      </fix>
      <fix>

======= e1bf740:"java/org/apache/catalina/ant/JMXGetTask.java"

======= e1bf740:"java/org/apache/catalina/ant/JMXGetTask.java"

                " in bean " + bean );
        try {
            execute("/jmxproxy/?get=" + URLEncoder.encode(bean, getCharset()) 
                    + "&att=" + URLEncoder.encode(attribute, getCharset()));
        } catch (UnsupportedEncodingException e) {
            throw new BuildException
                ("Invalid 'charset' attribute: " + getCharset());
        }
======= e1bf740:"java/org/apache/catalina/ant/JMXQueryTask.java"

======= e1bf740:"java/org/apache/catalina/ant/JMXQueryTask.java"

        String queryString;
        if (query == null) {
            queryString = "";
        } else {
            try {
                queryString = "?qry=" + URLEncoder.encode(query, getCharset());
            } catch (UnsupportedEncodingException e) {
                throw new BuildException
                    ("Invalid 'charset' attribute: " + getCharset());
            }
        }
======= e1bf740:"java/org/apache/catalina/ant/JMXSetTask.java"

======= e1bf740:"java/org/apache/catalina/ant/JMXSetTask.java"

        try {
            execute("/jmxproxy/?set=" + URLEncoder.encode(bean, getCharset()) 
                    + "&att=" + URLEncoder.encode(attribute, getCharset()) 
                    + "&val=" + URLEncoder.encode(value, getCharset()));
        } catch (UnsupportedEncodingException e) {
            throw new BuildException
                ("Invalid 'charset' attribute: " + getCharset());
        }
======= e1bf740:"java/org/apache/catalina/ant/ResourcesTask.java"

======= e1bf740:"java/org/apache/catalina/ant/ResourcesTask.java"

            try {
                execute("/resources?type=" +
                        URLEncoder.encode(type, getCharset()));
            } catch (UnsupportedEncodingException e) {
                throw new BuildException
                    ("Invalid 'charset' attribute: " + getCharset());
            }
======= e1bf740:"java/org/apache/catalina/ant/UndeployTask.java"

======= e1bf740:"java/org/apache/catalina/ant/UndeployTask.java"

        try {
            execute("/undeploy?path=" +
                    URLEncoder.encode(this.path, getCharset()));
        } catch (UnsupportedEncodingException e) {
            throw new BuildException
                ("Invalid 'charset' attribute: " + getCharset());
        }
  <subsection name="Catalina">
    <changelog>
      <fix>
        <bug>28852</bug>: Add URL encoding where missing to parameters in URLs
        presented by Ant tasks to the Manager application. Based on a patch by
        Stephane Bailliez. (mark) 
      </fix>
    </changelog>
  </subsection>

======= 4b4ef0c:"java/org/apache/catalina/startup/CatalinaProperties.java"

                // Remove leading/trailing whitespace as that can lead to hard
                // to diagnose failures
                System.setProperty(name.trim(), value.trim());
        <bug>31027</bug>: Trim whitespace from names and values obtained from
        <code>$CATALINA_BASE/conf/catalina.properties</code> to avoid hard to
        diagnose errors on startup. (markt)
      </fix>
      <fix>

======= 92ff888:"java/org/apache/catalina/Lifecycle.java"

 * The valid state transitions for components that support {@link Lifecycle}
 * are:
======= 92ff888:"java/org/apache/catalina/Lifecycle.java"

 * |  |                                   ^                  |  |  ^
 * |  |                  stop()           |                  |  |  |
 * |  |          --------------------------                  |  |  |
 * |  |          |                  MUST_DESTROY------<-------  |  |
======= 92ff888:"java/org/apache/catalina/Lifecycle.java"

     * Get the life cycle listeners associated with this life cycle. If this 
     * component has no listeners registered, a zero-length array is returned.
======= 92ff888:"java/org/apache/catalina/Lifecycle.java"

     * Prepare for the beginning of active use of the public methods other than
     * property getters/setters and life cycle methods of this component. This
     * method should be called before any of the public methods other than
     * property getters/setters and life cycle methods of this component are
     * utilized. The following {@link LifecycleEvent}s will be fired in the
     * following order:
======= 92ff888:"java/org/apache/catalina/Lifecycle.java"

     *                    and that the public methods other than property
     *                    getters/setters and life cycle methods may be 
     *                    used.</li>
======= 92ff888:"java/org/apache/catalina/Lifecycle.java"

     * Gracefully terminate the active use of the public methods other than
     * property getters/setters and life cycle methods of this component. Once
     * the STOP_EVENT is fired, the public methods other than property
     * getters/setters and life cycle methods should not be used. The following
     * {@link LifecycleEvent}s will be fired in the following order:
======= 92ff888:"java/org/apache/catalina/Lifecycle.java"

     *                   and that the public methods other than property
     *                   getters/setters and life cycle methods may no longer be
     *                   used.</li>
     * Note that if transitioning from {@link LifecycleState#FAILED} then the
     * three events above will be fired but the component will transition
     * directly from {@link LifecycleState#FAILED} to
     * {@link LifecycleState#STOPPING}, bypassing
     * {@link LifecycleState#STOPPING_PREP}
     * 
======= 92ff888:"java/org/apache/catalina/LifecycleListener.java"

 * Lifecycle interface. The listener will be fired after the associated state
 * change has taken place.
======= 92ff888:"java/org/apache/catalina/LifecycleState.java"

    MUST_DESTROY(false, null);
======= 92ff888:"java/org/apache/catalina/LifecycleState.java"

     * May the public methods other than property getters/setters and lifecycle
     * methods be called for a component in this state? It returns
     * <code>true</code> for any component in any of the following states:
     * <ul>
     * <li>{@link #STARTING}</li>
     * <li>{@link #STARTED}</li>
     * <li>{@link #STOPPING_PREP}</li>
     * <li>{@link #MUST_STOP}</li>
     * </ul>
======= 92ff888:"java/org/apache/catalina/util/LifecycleBase.java"

        if (state.equals(LifecycleState.FAILED)) {
            // Don't transition to STOPPING_PREP as that would briefly mark the
            // component as available but do ensure the BEFORE_STOP_EVENT is
            // fired
            fireLifecycleEvent(BEFORE_STOP_EVENT, null);
        } else {
            setStateInternal(LifecycleState.STOPPING_PREP, null, false);
        }
======= 92ff888:"java/org/apache/catalina/util/LifecycleBase.java"

            // stopInternal() permits STOPPING_PREP to STOPPING and FAILED to
            // STOPPING
                            state == LifecycleState.STOPPING) ||
                    (this.state == LifecycleState.FAILED &&
      <fix>
        <bug>50836</bug>: Better documentation of the meaning of
        <code>Lifecycle.isAvailable()</code> and correct a couple of cases where
        this could incorrectly return true. (markt)
      </fix>

======= dcda15d:"java/org/apache/coyote/http11/Http11NioProcessor.java"

======= dcda15d:"java/org/apache/coyote/http11/Http11NioProcessor.java"

======= dcda15d:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                SecureNioChannel sslChannel = (SecureNioChannel) socket;
                SSLEngine engine = sslChannel.getSslEngine();
                if (!engine.getNeedClientAuth() && !engine.getWantClientAuth()) {
                    // Need to re-negotiate SSL connection
                    engine.setNeedClientAuth(true);
                    try {
                        sslChannel.rehandshake();
                        sslSupport = (new JSSEFactory()).getSSLSupport(
                                engine.getSession());
                    } catch (IOException ioe) {
                        log.warn(sm.getString("http11processor.socket.sslreneg",
                                ioe));
                    }
                }
                    // use force=false since re-negotiation is handled above
                    // (and it is a NO-OP for NIO anyway)
                    Object sslO = sslSupport.getPeerCertificateChain(false);
======= dcda15d:"java/org/apache/tomcat/util/net/NioChannel.java"

    public boolean isHandshakeComplete() {
======= dcda15d:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

    protected boolean handshakeComplete = false;
    protected HandshakeStatus handshakeStatus; //gets set by begin handshake
======= dcda15d:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

        handshakeComplete = false;
        handshakeStatus = sslEngine.getHandshakeStatus();
======= dcda15d:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

        if ( handshakeComplete ) return 0; //we have done our initial handshake
        while (!handshakeComplete) {
            switch ( handshakeStatus ) {
                    handshakeComplete = !netOutBuffer.hasRemaining();
                    return handshakeComplete?0:SelectionKey.OP_WRITE; 
                        if (handshakeStatus == HandshakeStatus.NEED_TASK) 
                            handshakeStatus = tasks();
                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {
======= dcda15d:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

                        if (handshakeStatus == HandshakeStatus.NEED_TASK) 
                            handshakeStatus = tasks();
                        throw new IOException("Invalid handshake status:"+handshakeStatus+" during handshake UNWRAP.");
                    handshakeStatus = tasks();
                default: throw new IllegalStateException("Invalid handshake status:"+handshakeStatus);
        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);
======= dcda15d:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

        handshakeStatus = result.getHandshakeStatus();
======= dcda15d:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

            handshakeStatus = result.getHandshakeStatus();
                handshakeStatus = tasks();
                   handshakeStatus == HandshakeStatus.NEED_UNWRAP;
    public void rehandshake() throws IOException {
        int readBufLimit = getBufHandler().getReadBuffer().limit();
        try {
            // Expand read buffer to maximum to allow handshaking to take place
            getBufHandler().getReadBuffer().limit(
                    getBufHandler().getReadBuffer().capacity());
            sslEngine.getSession().invalidate();
            sslEngine.beginHandshake();
            handshakeComplete = false;
            handshakeStatus = sslEngine.getHandshakeStatus();
            while (!handshakeComplete) {
                handshake(true, true);
                if (handshakeStatus == HandshakeStatus.NEED_UNWRAP)  {
                    handshakeUnwrap(true);
                }
            }
        } finally {
            // Restore the pre-handshak value
            getBufHandler().getReadBuffer().limit(readBufLimit);
        }
    }
======= dcda15d:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

        if (!handshakeComplete) throw new IllegalStateException("Handshake incomplete, you must complete handshake before reading data.");
======= dcda15d:"java/org/apache/tomcat/util/net/SecureNioChannel.java"

    public boolean isHandshakeComplete() {
        return handshakeComplete;
      <add>
        <bug>49284</bug>: Add SSL re-negotiation support to the HTTP NIO
        connector. (markt)
      </add>

======= 9d542ed:"java/org/apache/catalina/core/StandardContext.java"

        // If in state NEW when destroy is called, the object name will never
        // have been set so the notification can't be created
        if (getObjectName() != null) { 
            // Send j2ee.object.deleted notification 
            Notification notification = 
                new Notification("j2ee.object.deleted", this.getObjectName(), 
                                 sequenceNumber.getAndIncrement());
            broadcaster.sendNotification(notification);
        }
======= 9d542ed:"test/org/apache/catalina/startup/TestTomcat.java"

    public void testBug50826() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        String contextPath = "/examples";
        
        File appDir = new File(getBuildDirectory(), "webapps" + contextPath);
        // app dir is relative to server home
        tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath());
        Exception e = null;
        try {
            tomcat.destroy();
        } catch (Exception ex) {
            ex.printStackTrace();
            e = ex;
        }
        assertNull(e);
    }
        The new Crawler Session Manager Valve ensures that crawlers are
      <fix>
        <bug>50826</bug>: Avoid <code>IllegalArgumentException</code> if an
        embedded Tomcat instance that includes at least one Context is destroyed
        without ever being started. (markt)
      </fix>

======= f22600c:"java/org/apache/catalina/realm/JNDIRealm.java"

     * <code>roleBase</code>.
     */
    protected MessageFormat roleBaseFormat = null;
    /**
     * The MessageFormat object associated with the current
======= f22600c:"java/org/apache/catalina/realm/JNDIRealm.java"

        if (roleBase == null)
            roleBaseFormat = null;
        else
            roleBaseFormat = new MessageFormat(roleBase);
======= f22600c:"java/org/apache/catalina/realm/JNDIRealm.java"

        String base = null;
        if (roleBaseFormat != null) {
            NameParser np = context.getNameParser("");
            Name name = np.parse(dn);
            String nameParts[] = new String[name.size()];
            for (int i = 0; i < name.size(); i++) {
                nameParts[i] = name.get(i);
            }
            base = roleBaseFormat.format(nameParts);
        }
            results = context.search(base, filter, controls);
      <add>
        <bug>21669</bug>: Add the ability to specify the roleBase for the JNDI
        Realm as relative to the users DN. Based on a patch by Art W. (markt)
      </add>
        <p>The base directory entry for performing role searches. If not
        specified the top-level element in the directory context will be used.
        If specified it may optionally include pattern replacements
        &quot;{0}&quot;..&quot;{n}&quot; corrosponding to the name parts of the
        user's distinguished name (as returned by
        <code>javax.naming.Name.get()</code>).</p>

======= a085c4a:"java/org/apache/catalina/realm/JNDIRealm.java"

    /**
     * When searching for user roles, should the search be performed as the user
     * currently being authenticated? If false, {@link #connectionName} and
     * {@link #connectionPassword} will be used if specified, else an anonymous
     * connection will be used. 
     */
    protected boolean roleSearchAsUser = false;
    
======= a085c4a:"java/org/apache/catalina/realm/JNDIRealm.java"

        NamingEnumeration<SearchResult> results = null;
        try {
            if (roleSearchAsUser) {
                userCredentialsAdd(context, dn, user.getPassword());
            }
            results = context.search(roleBase, filter, controls);
        } finally {
            if (roleSearchAsUser) {
                userCredentialsRemove(context);
            }
        }
      <add>
        <bug>19444</bug>: Add an option to the JNDI realm to allow role searches
        to be performed by the authenticated user. (markt)
      </add>
      <attribute name="roleSearchAsUser" required="false">
        <p> When searching for user roles, should the search be performed as the
        user currently being authenticated? If false,
        <code>connectionName</code>} and <code>connectionPassword</code> will be
        used if specified, else an anonymous. If not specified, the default
        value of <code>false</code> is used.</p>
      </attribute>

======= 514e713:"java/org/apache/catalina/connector/OutputBuffer.java"

        // The request should have been completely read by the time the response
        // is closed. Further reads of the input a) are pointless and b) really
        // confuse AJP (bug 50189) so close the input buffer to prevent them.
        Request req = (Request) coyoteResponse.getRequest().getNote(
                CoyoteAdapter.ADAPTER_NOTES);
        req.inputBuffer.close();
        
        <bug>50189</bug>: Once the application has finished writing to the
        response, prevent further reads from the request since this causes
        various problems in the connectors which do not expect this. (markt)
      </fix>
      <fix>

======= a9c3193:"java/org/apache/naming/resources/BaseDirContext.java"

======= a9c3193:"java/org/apache/naming/resources/BaseDirContext.java"

        List<NamingEntry> bindings = doListBindings(name);
        List<NamingEntry> altBindings = null;
            if (altDirContext instanceof BaseDirContext) {
                altBindings = ((BaseDirContext) altDirContext).doListBindings(
            }
            if (altBindings != null) {
                if (bindings == null) {
                    bindings = altBindings;
                } else {
                    bindings.addAll(altBindings);
        }
        if (bindings != null) {
            return new NamingContextBindingsEnumeration(bindings.iterator(),
                    this);
======= a9c3193:"java/org/apache/naming/resources/BaseDirContext.java"

    protected abstract List<NamingEntry> doListBindings(String name)
======= a9c3193:"java/org/apache/naming/resources/FileDirContext.java"

======= a9c3193:"java/org/apache/naming/resources/FileDirContext.java"

======= a9c3193:"java/org/apache/naming/resources/FileDirContext.java"

    protected List<NamingEntry> doListBindings(String name)
======= a9c3193:"java/org/apache/naming/resources/FileDirContext.java"

        return list(file);
======= a9c3193:"java/org/apache/naming/resources/FileDirContext.java"

    protected List<NamingEntry> list(File file) {
        List<NamingEntry> entries = new ArrayList<NamingEntry>();
======= a9c3193:"java/org/apache/naming/resources/VirtualDirContext.java"

    protected List<NamingEntry> list(File file) {
        List<NamingEntry> entries = super.list(file);
======= a9c3193:"java/org/apache/naming/resources/WARDirContext.java"

======= a9c3193:"java/org/apache/naming/resources/WARDirContext.java"

======= a9c3193:"java/org/apache/naming/resources/WARDirContext.java"

    protected List<NamingEntry> doListBindings(String strName)
            return list(entries);
        return list(entry);
      <fix>
        <bug>50802</bug>: Ensure that
        <code>ServletContext.getResourcePaths()</code> includes static resources
        packaged in JAR files in its output. (markt)
      </fix>

======= b56bf50:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

  <subsection name="Coyote">
    <changelog>
      <fix>
        <bug>50780</bug>: Fix memory leak in APR implementation of AJP
        connector introduced by the refactoring for <bug>49884</bug>. (markt) 
      </fix>
    </changelog>
  </subsection>

======= 3810b04:"java/org/apache/catalina/Context.java"

    
    /**
     * Configure whether or not requests listeners will be fired on forwards for
     * this Context.
     */
    public void setFireRequestListenersOnForwards(boolean enable);
    /**
     * Determine whether or not requests listeners will be fired on forwards for
     * this Context.
     */
    public boolean getFireRequestListenersOnForwards();
    
======= 3810b04:"java/org/apache/catalina/core/ApplicationDispatcher.java"

            boolean doInvoke = true;
            
            if (context.getFireRequestListenersOnForwards() &&
                    !context.fireRequestInitEvent(request)) {
                doInvoke = false;
            if (doInvoke) {
                if (disInt != DispatcherType.ERROR) {
                    state.outerRequest.setAttribute
                        (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,
                         getCombinedPath());
                    state.outerRequest.setAttribute
                        (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,
                         DispatcherType.FORWARD);
                    invoke(state.outerRequest, response, state);
                } else {
                    invoke(state.outerRequest, response, state);
                }
                
                if (context.getFireRequestListenersOnForwards()) {
                    context.fireRequestDestroyEvent(request);
                }
            }
        }
======= 3810b04:"java/org/apache/catalina/core/StandardContext.java"

    
    private boolean fireRequestListenersOnForwards = false;
    @Override
    public void setFireRequestListenersOnForwards(boolean enable) {
        fireRequestListenersOnForwards = enable;
    }
    @Override
    public boolean getFireRequestListenersOnForwards() {
        return fireRequestListenersOnForwards;
    }
        <bug>50789</bug>: Provide an option to enable ServletRequestListeners
        for forwards as required by some CDI frameworks. (markt)
      </fix>
      <fix>
      <attribute name="fireRequestListenersOnForwards" required="false">
        <p>Set to <code>true</code> to fire any configured
        ServletRequestListeners  when Tomcat forwards a request. This is
        primarily of use to users of CDI frameworks that use
        ServletRequestListeners to configure the necessary environment for a
        request. If not specified, the default value of <code>false</code> is
        used.</p>
      </attribute>

======= cfab791:"java/javax/el/BeanELResolver.java"

                if (methodName.equals(m.getName()) && 
                        m.getParameterTypes().length == paramCount) {
======= cfab791:"java/org/apache/el/parser/AstValue.java"

                base = resolver.invoke(ctx, base, suffix, null,
                        mps.getParameters(ctx));
======= cfab791:"test/org/apache/el/TestMethodExpressionImpl.java"

    
    public void testBug50790a() throws Exception {
        ValueExpression ve = factory.createValueExpression(context,
                "#{beanAA.name.contains(beanA.name)}", java.lang.Boolean.class);
        Boolean actual = (Boolean) ve.getValue(context);
        assertEquals(Boolean.TRUE, actual);
    }
    public void testBug50790b() throws Exception {
        ValueExpression ve = factory.createValueExpression(context,
                "#{beanA.name.contains(beanAA.name)}", java.lang.Boolean.class);
        Boolean actual = (Boolean) ve.getValue(context);
        assertEquals(Boolean.FALSE, actual);
    }
      <fix>
        <bug>50790</bug>: Improve method resolution in EL expressions. (markt)
      </fix>

======= 72418ba:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            if (!request.isAsync() && !comet) {
                // Error or timeout - need to tell listeners the request is over
                // Have to test this first since state may change while in this
                // method and this is only required if entering this methos in
                // this state 
                Context ctxt = (Context) request.getMappingData().context;
                if (ctxt != null) {
                    ctxt.fireRequestDestroyEvent(request);
                }
            }
======= 72418ba:"java/org/apache/catalina/core/StandardContext.java"

======= 72418ba:"java/org/apache/catalina/core/StandardContext.java"

            ServletRequestEvent event = 
                    new ServletRequestEvent(getServletContext(), request);
            for (int i = 0; i < instances.length; i++) {
                if (instances[i] == null)
                    continue;
                if (!(instances[i] instanceof ServletRequestListener))
                    continue;
                ServletRequestListener listener =
                    (ServletRequestListener) instances[i];
                try {
                    listener.requestInitialized(event);
                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                    getLogger().error(sm.getString(
                            "standardContext.requestListener.requestInit",
                            instances[i].getClass().getName()), t);
                    request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
                    return false;
======= 72418ba:"java/org/apache/catalina/core/StandardContext.java"

            ServletRequestEvent event = 
                new ServletRequestEvent(getServletContext(), request);
            for (int i = 0; i < instances.length; i++) {
                int j = (instances.length -1) -i;
                if (instances[j] == null)
                    continue;
                if (!(instances[j] instanceof ServletRequestListener))
                    continue;
                ServletRequestListener listener =
                    (ServletRequestListener) instances[j];
                
                try {
                    listener.requestDestroyed(event);
                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                    getLogger().error(sm.getString(
                            "standardContext.requestListener.requestInit",
                            instances[j].getClass().getName()), t);
                    request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
                    return false;
======= 72418ba:"java/org/apache/catalina/core/StandardContextValve.java"

======= 72418ba:"java/org/apache/catalina/core/StandardContextValve.java"

        // Don't fire listeners during async processing
        boolean asyncAtStart = request.isAsync(); 
        if (asyncAtStart || context.fireRequestInitEvent(request)) {
            // If the request was async at the start and an error occurred then
            // the async error handling will kick-in and that will fire the
            // request destroyed event *after* the error handling has taken
            // place
            if (!(request.isAsync() || (asyncAtStart && request.getAttribute(
                        RequestDispatcher.ERROR_EXCEPTION) != null))) {
                context.fireRequestDestroyEvent(request);
            }
======= 72418ba:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

======= 72418ba:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

======= 72418ba:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        ctx.addApplicationListener(TrackingRequestListener.class.getName());
        StringBuilder expected = new StringBuilder("requestInitialized-");
======= 72418ba:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        expected.append("requestDestroyed");
======= 72418ba:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        ctx.addApplicationListener(TrackingRequestListener.class.getName());
======= 72418ba:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        StringBuilder expected = new StringBuilder("requestInitialized-");
        expected.append("requestDestroyed");
======= 72418ba:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    public static class TrackingRequestListener
            implements ServletRequestListener {
        @Override
        public void requestDestroyed(ServletRequestEvent sre) {
            // Need the response and it isn't available via the Servlet API
            Request r = (Request) sre.getServletRequest();
            try {
                r.getResponse().getWriter().print("requestDestroyed");
            } catch (IOException e) {
                // Test will fail if this happens
                e.printStackTrace();
            }
        }
        @Override
        public void requestInitialized(ServletRequestEvent sre) {
            // Need the response and it isn't available via the Servlet API
            Request r = (Request) sre.getServletRequest();
            try {
                r.getResponse().getWriter().print("requestInitialized-");
            } catch (IOException e) {
                // Test will fail if this happens
                e.printStackTrace();
            }
        }
    }
======= 72418ba:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        ctx.addApplicationListener(TrackingRequestListener.class.getName());
======= 72418ba:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        StringBuilder expected = new StringBuilder("requestInitialized-");
======= 72418ba:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        expected.append("ErrorServletGet-onError-onComplete-requestDestroyed");
      <fix>
        <bug>50793</bug>: When processing Servlet 3.0 async requests, ensure
        that the requestInitialized and requestDestroyed events are only fired
        once per request at the correct times. (markt)
      </fix>

======= 4b21973:"java/org/apache/catalina/ant/RolesTask.java"

======= 4b21973:"java/org/apache/catalina/manager/ManagerServlet.java"

======= 4b21973:"java/org/apache/catalina/manager/ManagerServlet.java"

======= 4b21973:"java/org/apache/catalina/manager/ManagerServlet.java"

======= 4b21973:"java/org/apache/catalina/manager/ManagerServlet.java"

======= 4b21973:"java/org/apache/catalina/manager/ManagerServlet.java"

  <subsection name="Wep applications">
    <changelog>
      <fix>
        <bug>50713</bug>: Remove roles command from the Manager application.
        (markt)
      </fix>
    </changelog>
  </subsection>
        <rev>1068549</rev> <bug>50667</bug>: Allow RPC callers to get
        confirmation when sending a reply. (fhanik)

======= a073ac8:"java/org/apache/catalina/core/StandardContext.java"

        Map<String,String> mergedParams = new HashMap<String,String>();
            mergedParams.put(names[i], findParameter(names[i]));
                if (mergedParams.get(params[i].getName()) == null) {
                    mergedParams.put(params[i].getName(),
                mergedParams.put(params[i].getName(), params[i].getValue());
        
        ServletContext sc = getServletContext();
        for (Map.Entry<String,String> entry : mergedParams.entrySet()) {
            sc.setInitParameter(entry.getKey(), entry.getValue());
        }
        <bug>50700</bug>: Ensure that the override attribute of context
        parameters is correctly followed. (markt)
      </fix>
      <fix>

======= 877a3df:"java/org/apache/catalina/ha/session/DeltaRequest.java"

    public static final int TYPE_AUTHTYPE = 4;
======= 877a3df:"java/org/apache/catalina/ha/session/DeltaRequest.java"

    public static final String NAME_AUTHTYPE = "__SET__AUTHTYPE__";
======= 877a3df:"java/org/apache/catalina/ha/session/DeltaRequest.java"

    public void setAuthType(String authType) {
        int action = (authType==null)?ACTION_REMOVE:ACTION_SET;
        addAction(TYPE_AUTHTYPE,action,NAME_AUTHTYPE, authType);
    }
======= 877a3df:"java/org/apache/catalina/ha/session/DeltaRequest.java"

                case TYPE_AUTHTYPE: {
                    String authType = null;
                    if ( info.getAction() == ACTION_SET ) {
                        authType = (String)info.getValue();
                    }
                    session.setAuthType(authType,false);
                    break;
                }//case
======= 877a3df:"java/org/apache/catalina/ha/session/DeltaSession.java"

     * Set the authentication type used to authenticate our cached
     * Principal, if any.
     *
     * @param authType The new cached authentication type
     */
    @Override
    public void setAuthType(String authType) {
        setAuthType(authType, true);
    }
    public void setAuthType(String authType, boolean addDeltaRequest) {
        try { 
            lock();
            super.setAuthType(authType);
            if (addDeltaRequest && (deltaRequest != null))
                deltaRequest.setAuthType(authType);
        } finally {
            unlock();
        }
    }
    /**
  <subsection name="Cluster">
    <changelog>
      <fix>
        <bug>50771</bug>: Ensure HttpServletRequest#getAuthType() returns the 
        name of the authentication scheme if request has already been 
        authenticated. (kfujino)
      </fix>
    </changelog>
  </subsection>

======= d0f3899:"java/org/apache/jasper/compiler/Generator.java"

                // UTF-8 is up to 4 bytes per character
                // String constants are limited to 64k bytes
                // Limit string constants here to 16k characters
                int textIndex = 0;
                int textLength = text.length();
                while (textIndex < textLength) {
                    int len = 0;
                    if (textLength - textIndex > 16384) {
                        len = 16384;
                    } else {
                        len = textLength - textIndex;
                    }
                    String output = text.substring(textIndex, textIndex + len);
                    String charArrayName = textMap.get(output);
                    if (charArrayName == null) {
                        charArrayName = "_jspx_char_array_" + charArrayCount++;
                        textMap.put(output, charArrayName);
                        caOut.printin("static char[] ");
                        caOut.print(charArrayName);
                        caOut.print(" = ");
                        caOut.print(quote(output));
                        caOut.println(".toCharArray();");
                    }
    
                    n.setBeginJavaLine(out.getJavaLine());
                    out.printil("out.write(" + charArrayName + ");");
                    n.setEndJavaLine(out.getJavaLine());
                    
                    textIndex = textIndex + len;
      <fix>
        <bug>50726</bug>: Ensure that the use of the genStringAsCharArray does
        not result in String constants that are too long for valid Java code.
        (markt)
      </fix>

======= 50f16fe:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            if (poolProperties.getValidator().validate(connection, validateAction)) {
                this.lastValidated = now;
                return true;
            } else {
                return false;
            }

======= 0313ded:"java/org/apache/catalina/realm/JNDIRealm.java"

        // If no attributes are requested, no need to look for them
        if (attrIds == null || attrIds.length > 0) {
            return new User(username, dn, null, null);
        }
        <bug>50751</bug>: When authenticating with the JNDI Realm, only attempt
        to read user attributes from the directory if attributes are required.
        (markt)
      </fix>
      <fix>

======= 272e30c:"java/org/apache/catalina/startup/Embedded.java"

                log.debug( "INITIAL_CONTEXT_FACTORY already set " + value );
      <fix>
        <bug>50752</bug>: Fix typo in debug message in deprecated Embedded
        class. (markt)
      </fix>

======= e4bc803:"java/org/apache/jasper/compiler/WebXml.java"

======= e4bc803:"java/org/apache/jasper/compiler/WebXml.java"

    private InputStream stream;
    private InputSource source;
======= e4bc803:"java/org/apache/jasper/compiler/WebXml.java"

            source = new InputSource(new StringReader(webXml));
        if (source == null) {
======= e4bc803:"java/org/apache/jasper/compiler/WebXml.java"

                    stream = uri.openStream();
                    source = new InputSource(stream);
======= e4bc803:"java/org/apache/jasper/compiler/WebXml.java"

        if (source == null) {
                stream = uri.openStream();
                source = new InputSource(stream);
        if (source == null) {
            source.setSystemId(systemId);
======= e4bc803:"java/org/apache/jasper/compiler/WebXml.java"

        return source;
        if (stream != null) {
                stream.close();
  <subsection name="Jasper">
    <changelog>
      <fix>
        <bug>50720</bug>: Ensure that the use of non-ISO-8859-1 character sets
        for web.xml does not trigger an error when Jasper parses the web.xml
        file. (markt)
      </fix>
    </changelog>
  </subsection>

======= 5c9e352:"java/org/apache/catalina/util/RequestUtil.java"

                if (ix + 2 > len) {
======= 5c9e352:"test/org/apache/catalina/util/TestRequestUtil.java"

    public void testURLDecodeStringInvalid() {
======= 5c9e352:"test/org/apache/catalina/util/TestRequestUtil.java"

    
    public void testURLDecodeStringValidIso88591Start() {
        String result = RequestUtil.URLDecode("%41xxxx", "ISO-8859-1");
        assertEquals("Axxxx", result);
    }
    public void testURLDecodeStringValidIso88591Middle() {
        String result = RequestUtil.URLDecode("xx%41xx", "ISO-8859-1");
        assertEquals("xxAxx", result);
    }
    public void testURLDecodeStringValidIso88591End() {
        String result = RequestUtil.URLDecode("xxxx%41", "ISO-8859-1");
        assertEquals("xxxxA", result);
    }
    public void testURLDecodeStringValidUtf8Start() {
        String result = RequestUtil.URLDecode("%c3%aaxxxx", "UTF-8");
        assertEquals("\u00eaxxxx", result);
    }
    public void testURLDecodeStringValidUtf8Middle() {
        String result = RequestUtil.URLDecode("xx%c3%aaxx", "UTF-8");
        assertEquals("xx\u00eaxx", result);
    }
    public void testURLDecodeStringValidUtf8End() {
        String result = RequestUtil.URLDecode("xxxx%c3%aa", "UTF-8");
        assertEquals("xxxx\u00ea", result);
    }
        <bug>50721</bug>: Correctly handle URL decoding where the URL ends in
        %nn. Patch provided by Christof Marti. (markt)
      </fix>
      <fix>
        point the response is committed when a writer is being used. (markt)

======= 9f41c91:"java/org/apache/catalina/core/ApplicationContextFacade.java"

      <fix>
       <bug>50709</bug>: Make <code>ApplicationContextFacade</code> non-final to
       enable extension. (markt)
      </fix>

======= 6ac4a27:"java/org/apache/catalina/core/StandardServer.java"

    private volatile boolean stopAwait = false;
    /**
     * Thread that currently is inside our await() method.
     */
    private volatile Thread awaitThread = null;
    /**
     * Server socket that is used to wait for the shutdown command.
     */
    private volatile ServerSocket awaitSocket = null;
======= 6ac4a27:"java/org/apache/catalina/core/StandardServer.java"

        Thread t = awaitThread;
        if (t != null) {
            ServerSocket s = awaitSocket;
            if (s != null) {
                awaitSocket = null;
                try {
                    s.close();
                } catch (IOException e) {
                    // Ignored
                }
            }
            t.interrupt();
            try {
                t.join(1000);
            } catch (InterruptedException e) {
                // Ignored
            }
        }
======= 6ac4a27:"java/org/apache/catalina/core/StandardServer.java"

            try {
                awaitThread = Thread.currentThread();
                while(!stopAwait) {
                    try {
                        Thread.sleep( 10000 );
                    } catch( InterruptedException ex ) {
                    }
            } finally {
                awaitThread = null;
            return;
            awaitSocket = new ServerSocket(port, 1,
                    InetAddress.getByName(address));
            return;
        try {
            awaitThread = Thread.currentThread();
            // Loop waiting for a connection and a valid command
            while (!stopAwait) {
                ServerSocket serverSocket = awaitSocket;
                if (serverSocket == null) {
                    break;
                }
    
                // Wait for the next connection
                Socket socket = null;
                StringBuilder command = new StringBuilder();
                    InputStream stream;
                    try {
                        socket = serverSocket.accept();
                        socket.setSoTimeout(10 * 1000);  // Ten seconds
                        stream = socket.getInputStream();
                    } catch (AccessControlException ace) {
                        log.warn("StandardServer.accept security exception: "
                                + ace.getMessage(), ace);
                        continue;
                    } catch (IOException e) {
                        if (stopAwait) {
                            // Wait was aborted with socket.close()
                            break;
                        }
                        log.error("StandardServer.await: accept: ", e);
                        break;
                    }
                    // Read a set of characters from the socket
                    int expected = 1024; // Cut off to avoid DoS attack
                    while (expected < shutdown.length()) {
                        if (random == null)
                            random = new Random();
                        expected += (random.nextInt() % 1024);
                    }
                    while (expected > 0) {
                        int ch = -1;
                        try {
                            ch = stream.read();
                        } catch (IOException e) {
                            log.warn("StandardServer.await: read: ", e);
                            ch = -1;
                        }
                        if (ch < 32)  // Control character or EOF terminates loop
                            break;
                        command.append((char) ch);
                        expected--;
                    }
                } finally {
                    // Close the socket now that we are done with it
                    try {
                        if (socket != null) {
                            socket.close();
                        }
                    } catch (IOException e) {
                        // Ignore
                    }
                // Match against our command string
                boolean match = command.toString().equals(shutdown);
                if (match) {
                    log.info(sm.getString("standardServer.shutdownViaPort"));
                } else
                    log.warn("StandardServer.await: Invalid command '"
                            + command.toString() + "' received");
        } finally {
            ServerSocket serverSocket = awaitSocket;
            awaitThread = null;
            awaitSocket = null;
            // Close the server socket and return
            if (serverSocket != null) {
                try {
                    serverSocket.close();
                } catch (IOException e) {
                    // Ignore
                }
======= 6ac4a27:"java/org/apache/catalina/core/StandardServer.java"

        if (awaitThread != null)
======= 6ac4a27:"java/org/apache/catalina/startup/Catalina.java"

======= 6ac4a27:"java/org/apache/catalina/startup/Catalina.java"

        Server s = getServer();
        if( s == null ) {
======= 6ac4a27:"java/org/apache/catalina/startup/Catalina.java"

            try {
                s.stop();
            } catch (LifecycleException e) {
                log.error("Catalina.stop: ", e);
            }
            return;
        s = getServer();
            if (s.getPort()>0) {
                Socket socket = new Socket(s.getAddress(), s.getPort());
======= 6ac4a27:"java/org/apache/catalina/startup/Catalina.java"

            Server s = getServer();
            LifecycleState state = s.getState();
            if (LifecycleState.STOPPING_PREP.compareTo(state) <= 0
                    && LifecycleState.DESTROYED.compareTo(state) >= 0) {
                // Nothing to do. stop() was already called
            } else {
                s.stop();
            }
        <bug>50673</bug>: Improve Catalina shutdown when running as a service.
        Do not call System.exit(). (kkolinko)
      </fix>
      <fix>
        <bug>50683</bug>: Ensure annotations are scanned when
        <code>unpackWARs</code> is set to <code>false</code> in the Host
        where a web application is deployed. (markt)

======= 0084470:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

        this.headerBufferSize = headerBufferSize;
======= 0084470:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

    /**
     * Maximum allowed size of the HTTP request line plus headers.
     */
    private final int headerBufferSize;
    /**
     * Known size of the NioChannel read buffer.
     */
    private int socketReadBufferSize;
    /**
     * Additional size we allocate to the buffer to be more effective when
     * skipping empty lines that may precede the request.
     */
    private static final int skipBlankLinesSize = 1024;
    /**
     * How many bytes in the buffer are occupied by skipped blank lines that
     * precede the request.
     */
    private int skipBlankLinesBytes;
======= 0084470:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

        socketReadBufferSize = socket.getBufHandler().getReadBuffer().capacity();
        int bufLength = skipBlankLinesSize + headerBufferSize
                + socketReadBufferSize;
        if (buf == null || buf.length < bufLength) {
            buf = new byte[bufLength];
        }
======= 0084470:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

                    // Ignore bytes that were read
                    pos = lastValid = 0;
            if (pos >= skipBlankLinesSize) {
                // Move data, to have enough space for further reading
                // of headers and body
                System.arraycopy(buf, pos, buf, 0, lastValid - pos);
                lastValid -= pos;
                pos = 0;
            skipBlankLinesBytes = pos;
            parsingRequestLineStart = pos;
======= 0084470:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            if (parsingHeader) {
                throw new IllegalArgumentException(
                        sm.getString("iib.requestheadertoolarge.error"));
            }
            // Should not happen
            log.warn("Expanding buffer size. Old size: " + buf.length
                    + ", new size: " + newsize, new Exception());
======= 0084470:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            // Checking that
            // (1) Headers plus request line size does not exceed its limit
            // (2) There are enough bytes to avoid expanding the buffer when
            // reading body
            // Technically, (2) is technical limitation, (1) is logical
            // limitation to enforce the meaning of headerBufferSize
            // From the way how buf is allocated and how blank lines are being
            // read, it should be enough to check (1) only.
            if (end - skipBlankLinesBytes > headerBufferSize
                    || buf.length - end < socketReadBufferSize) {
                throw new IllegalArgumentException(
                        sm.getString("iib.requestheadertoolarge.error"));
            }
======= 0084470:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            lastValid = pos = end;
      <fix>
        <bug>50631</bug>: InternalNioInputBuffer should honor
        <code>maxHttpHeadSize</code>. (kkolinko)
      </fix>

======= b4e9488:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

======= b4e9488:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

    private static final org.apache.juli.logging.Log log =
        org.apache.juli.logging.LogFactory.getLog(JSSESocketFactory.class);
    private static final boolean RFC_5746_SUPPORTED;
    private static final String defaultProtocol = "TLS";
    private static final String defaultKeystoreType = "JKS";
======= b4e9488:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

    static {
        boolean result = false;
        SSLContext context;
        try {
            context = SSLContext.getInstance("TLS");
            context.init(null, null, new SecureRandom());
            SSLServerSocketFactory ssf = context.getServerSocketFactory();
            String ciphers[] = ssf.getSupportedCipherSuites();
            for (String cipher : ciphers) {
                if ("TLS_EMPTY_RENEGOTIATION_INFO_SCSV".equals(cipher)) {
                    result = true;
                    break;
                }
            }
        } catch (NoSuchAlgorithmException e) {
            // Assume no RFC 5746 support
        } catch (KeyManagementException e) {
            // Assume no RFC 5746 support
        }
        RFC_5746_SUPPORTED = result;
    }
======= b4e9488:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

        if (!allowUnsafeLegacyRenegotiation && !RFC_5746_SUPPORTED) {
            // Prevent further handshakes by removing all cipher suites
        <bug>50325</bug>: When the JVM indicates support for RFC 5746, disable
        Tomcat&apos;s <code>allowUnsafeLegacyRenegotiation</code> configuration
        attribute and use the JVM configuration to control renegotiation.
        (markt)
      </fix>
      <fix>
      request. If not specified, a default of <code>false</code> is used. This
      attribute only has an effect if the JVM does not support RFC 5746 as
      indicated by the presence of the pseudo-ciphersuite
      TLS_EMPTY_RENEGOTIATION_INFO_SCSV. This is available JRE/JDK 6 update 22
      onwards. Where RFC 5746 is supported the renegotiation - including support
      for unsafe legacy renegotiation - is controlled by the JVM configuration.
      </p>

======= d21437e:"java/org/apache/naming/resources/WARDirContext.java"

        else
            attrs.setCollection(true);
      <fix>
        <bug>50683</bug>: Ensure annotations are scanned when upackWars is set
        to <code>false</code> in the Host where a web application is deployed.
        (markt)
      </fix>

======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            return Boolean.parseBoolean(s);
            return Byte.parseByte(s);
======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            return Double.parseDouble(s);
            return Float.parseFloat(s);
            return Integer.parseInt(s);
            return Short.parseShort(s);
            return Long.parseLong(s);
======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return Byte.valueOf((byte) 0);
                return Byte.valueOf(s);
                return Character.valueOf((char) 0);
                return Character.valueOf(s.charAt(0));
                return Double.valueOf(0);
                return Double.valueOf(s);
                return Float.valueOf(0);
                return Float.valueOf(s);
                return Integer.valueOf(0);
                return Integer.valueOf(s);
                return Short.valueOf((short) 0);
                return Short.valueOf(s);
                return Long.valueOf(0);
                return Long.valueOf(s);
======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                return Byte.valueOf(s);
                return s.length() > 0 ? Character.valueOf(s.charAt(0)) : null;
                return Short.valueOf(s);
                return Integer.valueOf(s);
                return Float.valueOf(s);
                return Long.valueOf(s);
                return Double.valueOf(s);
======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

        return Byte.toString(b);
        return Boolean.toString(b);
        return Short.toString(s);
        return Integer.toString(i);
        return Float.toString(f);
        return Long.toString(l);
        return Double.toString(d);
        return Character.toString(c);
======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

                    tmpval[i] = Character.valueOf(values[i].charAt(0));
======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { Integer.valueOf(value) });
======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { Short.valueOf(value) });
======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { Long.valueOf(value) });
======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { Double.valueOf(value) });
======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { Float.valueOf(value) });
======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { Character.valueOf(value) });
======= 20ace41:"java/org/apache/jasper/runtime/JspRuntimeLibrary.java"

            method.invoke(bean, new Object[] { Byte.valueOf(value) });
      <fix>
        <bug>46819</bug>: Remove redundant object instantiations in
        JspRuntimeLibrary. Patch provided by Anthony Whitford. (markt)
      </fix>

======= af4549f:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                    if (jarResource != null) {
                        // Add TLD
                        pageInfo.addDependant(jarResource.getEntry(location.getName()).toString());
                        // Add Tag
                        pageInfo.addDependant(jarResource.getEntry(tagFilePath.substring(1)).toString());
                    }
                    else {
                        pageInfo.addDependant(tagFilePath);
                    }
      <fix>
        <bug>50680</bug>: Prevent an NPE when using tag files from an exploded
        JAR file, e.g. from within an IDE. Patch provided by Larry Isaacs.
        (markt)
      </fix>

======= 2377f51:"java/org/apache/catalina/ha/ClusterDeployer.java"

======= 2377f51:"java/org/apache/catalina/ha/ClusterDeployer.java"

     * members of the cluster with the specified context name.
     * @param contextName The context name to which this application should
     * @param wepapp    A WAR file or unpacked directory structure containing
     *                  the web application to be installed
     * @exception IllegalArgumentException if the specified context name
     *  is malformed
     * @exception IllegalStateException if the specified context name
    public void install(String contextName, File webapp) throws IOException;
     * name.  If this application is successfully removed, a
     * @param contextName The context name of the application to be removed
     * @exception IllegalArgumentException if the specified context name
     *  is malformed
     * @exception IllegalArgumentException if the specified context name does
    public void remove(String contextName, boolean undeploy) throws IOException;
======= 2377f51:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

======= 2377f51:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

======= 2377f51:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

 * applications in WAR from within the cluster.
======= 2377f51:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                            fmsg.getContextName(), fmsg.getFileName()));
======= 2377f51:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                        String contextName = fmsg.getContextName();
                        if (!isServiced(contextName)) {
                            addServiced(contextName);
                                remove(contextName);
                                check(contextName);
                                removeServiced(contextName);
                                        "farmWarDeployer.deployEnd",
                                        contextName));
                                    "farmWarDeployer.servicingDeploy",
                                    contextName, name));
======= 2377f51:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

                    String contextName = umsg.getContextName();
                                contextName));
                    if (!isServiced(contextName)) {
                        addServiced(contextName);
                            remove(contextName);
                            removeServiced(contextName);
                                    "farmWarDeployer.undeployEnd",
                                    contextName));
                                "farmWarDeployer.servicingUneploy",
                                contextName));
======= 2377f51:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

        File writeToFile = new File(getTempDir(), msg.getFileName());
======= 2377f51:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     * cluster with the specified context name.
     * @param contextName
     *            The context name to which this application should be installed
     * @param webapp
     *            A WAR file or unpacked directory structure containing the web
     *            application to be installed
     *                if the specified context name is malformed
     *                if the specified context name is already deployed
    public void install(String contextName, File webapp) throws IOException {
        FileMessageFactory factory =
            FileMessageFactory.getInstance(webapp, false);
        FileMessage msg = new FileMessage(localMember, webapp.getName(),
                contextName);
            log.debug(sm.getString("farmWarDeployer.sendStart", contextName,
                    webapp));
                            contextName, webapp, members[i]));
                    "farmWarDeployer.sendEnd", contextName, webapp));
     * name. If this application is successfully removed, a ContainerEvent of
     * @param contextName
     *            The context name of the application to be removed
     *                if the specified context name is malformed
     *                if the specified context name does not identify a
    public void remove(String contextName, boolean undeploy)
            log.info(sm.getString("farmWarDeployer.removeStart", contextName));
                .currentTimeMillis(), "Undeploy:" + contextName + ":"
                + System.currentTimeMillis(), contextName, undeploy);
            log.debug(sm.getString("farmWarDeployer.removeTxMsg", contextName));
                if (!isServiced(contextName)) {
                    addServiced(contextName);
                        remove(contextName);
                        removeServiced(contextName);
                            contextName));
                        contextName), ex);
======= 2377f51:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            ContextName cn = new ContextName(deployWar.getName());
                log.info(sm.getString("farmWarDeployer.modInstall",
                        cn.getName(), deployWar.getAbsolutePath()));
                remove(cn.getName(), false);
            install(cn.getName(), deployWar);
======= 2377f51:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            ContextName cn = new ContextName(removeWar.getName());
                        cn.getName()));
            remove(cn.getName(), true);
======= 2377f51:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

    protected void remove(String contextName) throws Exception {
        Context context = (Context) host.findChild(contextName);
                log.debug(sm.getString("farmWarDeployer.undeployLocal",
                        contextName));
======= 2377f51:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            check(contextName);
======= 2377f51:"java/org/apache/catalina/ha/deploy/FileMessage.java"

    private String contextName;
                       String contextName) {
        this.contextName=contextName;
======= 2377f51:"java/org/apache/catalina/ha/deploy/FileMessage.java"

    public String getContextName() {
        return contextName;
======= 2377f51:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

            log.warn("Receive Message again -- Sender ActTimeout too short [ name: "
                    + msg.getContextName()
======= 2377f51:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

            log.warn("Receive Message again -- Sender ActTimeout too short [ name: "
                    + msg.getContextName()
======= 2377f51:"java/org/apache/catalina/ha/deploy/UndeployMessage.java"

    private String contextName;
======= 2377f51:"java/org/apache/catalina/ha/deploy/UndeployMessage.java"

                           String contextName,
        this.contextName = contextName;
======= 2377f51:"java/org/apache/catalina/ha/deploy/UndeployMessage.java"

    public String getContextName() {
        return contextName;
    public void setContextPath(String contextName) {
        this.contextName = contextName;
      <fix>
        <bug>50679</bug>: Update the FarmWarDeployer to support parallel
        deployment. (markt)
      </fix>

======= 5c13d8c:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

======= 5c13d8c:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

======= 5c13d8c:"java/org/apache/catalina/core/StandardContext.java"

     * If an HttpClient keep-alive timer thread has been started by this web
     * application and is still running, should Tomcat change the context class
     * loader from the current {@link WebappClassLoader} to
     * {@link WebappClassLoader#parent} to prevent a memory leak? Note that the
     * keep-alive timer thread will stop on its own once the keep-alives all
     * expire however, on a busy system that might not happen for some time.
     */
    private boolean clearReferencesHttpClientKeepAliveThread = true;
    /**
======= 5c13d8c:"java/org/apache/catalina/core/StandardContext.java"

    /**
     * Return the clearReferencesHttpClientKeepAliveThread flag for this
     * Context.
     */
    public boolean getClearReferencesHttpClientKeepAliveThread() {
        return (this.clearReferencesHttpClientKeepAliveThread);
    }
    /**
     * Set the clearReferencesHttpClientKeepAliveThread feature for this
     * Context.
     *
     * @param clearReferencesHttpClientKeepAliveThread The new flag value
     */
    public void setClearReferencesHttpClientKeepAliveThread(
            boolean clearReferencesHttpClientKeepAliveThread) {
        this.clearReferencesHttpClientKeepAliveThread =
            clearReferencesHttpClientKeepAliveThread;
    }
======= 5c13d8c:"java/org/apache/catalina/loader/WebappClassLoader.java"

    private static final String JVN_THREAD_GROUP_SYSTEM = "system";
    
        JVM_THREAD_GROUP_NAMES.add(JVN_THREAD_GROUP_SYSTEM);
======= 5c13d8c:"java/org/apache/catalina/loader/WebappClassLoader.java"

    /**
     * If an HttpClient keep-alive timer thread has been started by this web
     * application and is still running, should Tomcat change the context class
     * loader from the current {@link WebappClassLoader} to
     * {@link WebappClassLoader#parent} to prevent a memory leak? Note that the
     * keep-alive timer thread will stop on its own once the keep-alives all
     * expire however, on a busy system that might not happen for some time.
     */
    private boolean clearReferencesHttpClientKeepAliveThread = true;
======= 5c13d8c:"java/org/apache/catalina/loader/WebappClassLoader.java"

     /**
      * Return the clearReferencesHttpClientKeepAliveThread flag for this
      * Context.
      */
     public boolean getClearReferencesHttpClientKeepAliveThread() {
         return (this.clearReferencesHttpClientKeepAliveThread);
     }
     /**
      * Set the clearReferencesHttpClientKeepAliveThread feature for this
      * Context.
      *
      * @param clearReferencesHttpClientKeepAliveThread The new flag value
      */
     public void setClearReferencesHttpClientKeepAliveThread(
             boolean clearReferencesHttpClientKeepAliveThread) {
         this.clearReferencesHttpClientKeepAliveThread =
             clearReferencesHttpClientKeepAliveThread;
     }
     
======= 5c13d8c:"java/org/apache/catalina/loader/WebappClassLoader.java"

                    // JVM controlled threads
                        // HttpClient keep-alive threads
                        if (clearReferencesHttpClientKeepAliveThread &&
                                thread.getName().equals("Keep-Alive-Timer")) {
                            thread.setContextClassLoader(parent);
                            log.debug(sm.getString(
                                    "webappClassLoader.checkThreadsHttpClient"));
                        }
                    
                        // Don't warn about remaining JVM controlled threads
======= 5c13d8c:"java/org/apache/catalina/loader/WebappLoader.java"

                classLoader.setClearReferencesHttpClientKeepAliveThread(
                        ((StandardContext) container).getClearReferencesHttpClientKeepAliveThread());
      <fix>
        <bug>50642</bug>: Move the HttpClient keep-alive thread memory leak
        protection from the JreMemoryLeakPreventionListener to the
        WebappClassLoader since the thread that triggers the memory leak is
        created on demand. (markt)
      </fix>
      <attribute name="clearReferencesHttpClientKeepAliveThread" required = "false">
        <p>If <code>true</code> and an HttpClient keep-alive timer thread has
        been started by this web application and is still running, Tomcat will
        change the context class loader for that thread from the current
        <code>WebappClassLoader</code> to
        <code>WebappClassLoader#parent</code> to prevent a memory leak. Note
        that the keep-alive timer thread will stop on its own once the
        keep-alives all expire however, on a busy system that might not happen
        for some time. If not specified, the default value of
        <code>true</code> will be used.</p>
      </attribute>

======= 0119483:"java/org/apache/catalina/tribes/ByteMessage.java"

        in.readFully(message);
      <fix>
        <bug>50646</bug>: Ensure larger Tribes messages are fully read. Patch
        provided by Olivier Costet. (markt)
      </fix>

======= 3898ed0:"java/org/apache/catalina/core/StandardContext.java"

    protected ClassLoader bindThread() {
======= 3898ed0:"java/org/apache/catalina/core/StandardContext.java"

    protected void unbindThread(ClassLoader oldContextClassLoader) {
      <fix>
        <bug>50629</bug>: Make <code>StandardContext.bindThread()</code> and
        <code>StandardContext.unbindThread()</code> protected to allow use by
        sub-classes. (markt)
      </fix>

======= fbd0110:"java/org/apache/catalina/connector/Request.java"

======= fbd0110:"java/org/apache/catalina/connector/Request.java"

    private static final Log log = LogFactory.getLog(Connector.class);
    
======= fbd0110:"java/org/apache/catalina/connector/Request.java"

            try {
                session.endAccess();
            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                log.warn(sm.getString("coyoteRequest.sessionEndAccessFail"), t);
            }

======= c0cd721:"java/org/apache/catalina/servlets/CGIServlet.java"

======= c0cd721:"java/org/apache/catalina/servlets/CGIServlet.java"

    /** additional arguments for the executable */
    private List<String> cgiExecutableArgs = null;
======= c0cd721:"java/org/apache/catalina/servlets/CGIServlet.java"

        if (getServletConfig().getInitParameter("executable-arg-1") != null) {
            List<String> args = new ArrayList<String>();
            for (int i = 1;; i++) {
                String arg = getServletConfig().getInitParameter(
                        "executable-arg-" + i);
                if (arg == null) {
                    break;
                }
                args.add(arg);
            }
            cgiExecutableArgs = args;
        }
======= c0cd721:"java/org/apache/catalina/servlets/CGIServlet.java"

            List<String> cmdAndArgs = new ArrayList<String>();
            if (cgiExecutable.length() != 0) {
                cmdAndArgs.add(cgiExecutable);
            }
            if (cgiExecutableArgs != null) {
                cmdAndArgs.addAll(cgiExecutableArgs);
            cmdAndArgs.add(command);
            cmdAndArgs.addAll(params);
                proc = rt.exec(
                        cmdAndArgs.toArray(new String[cmdAndArgs.size()]),
                        hashToStringArray(env), wd);
      <fix>
        <bug>50606</bug>: Improve CGIServlet: Provide support for specifying
        empty value for the <code>executable</code> init-param. Provide support
        for explicit additional arguments for the executable. Those were
        broken when implementing fix for bug <bug>49657</bug>. (kkolinko)
      </fix>

======= 5cb0b7a:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            idle.offer(create(true));
======= 5cb0b7a:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        PooledConnection con = create(false);
======= 5cb0b7a:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    protected PooledConnection create(boolean incrementCounter) {
        if (incrementCounter) size.incrementAndGet();
======= 5cb0b7a:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * 
 * @author Jeremy Norris
 * https://issues.apache.org/bugzilla/show_bug.cgi?id=50613
 *
 */
    protected volatile DataSource ds = null;
    public TestSizePreservation() {
    }
    private void initSimplePoolProperties() {
        PoolConfiguration p = new DefaultProperties();
        ds = new org.apache.tomcat.jdbc.pool.DataSource();
        ds.setPoolProperties(p);
        ds.getPoolProperties().setDriverClassName(Driver.class.getName());
        ds.getPoolProperties().setUrl(Driver.url);
        ds.getPoolProperties().setFairQueue(true);
        ds.getPoolProperties().setJmxEnabled(false);
        ds.getPoolProperties().setTestWhileIdle(true);
        ds.getPoolProperties().setTestOnBorrow(false);
        ds.getPoolProperties().setTestOnReturn(false);
        ds.getPoolProperties().setValidationInterval(30000);
        ds.getPoolProperties().setTimeBetweenEvictionRunsMillis(30000);
        ds.getPoolProperties().setInitialSize(100);
        ds.getPoolProperties().setMaxActive(100);
        ds.getPoolProperties().setMinIdle(0);
        ds.getPoolProperties().setMaxIdle(0);
        ds.getPoolProperties().setMaxWait(10000);
        ds.getPoolProperties().setRemoveAbandonedTimeout(10);
        ds.getPoolProperties().setMinEvictableIdleTimeMillis(10000);
        ds.getPoolProperties().setLogAbandoned(false);
        ds.getPoolProperties().setRemoveAbandoned(false);
        ds.getPoolProperties().setUseLock(true);
    }
    private void initEvictingPool() {
        initSimplePoolProperties();
        ds.getPoolProperties().setTimeBetweenEvictionRunsMillis(25);
        ds.getPoolProperties().setMinEvictableIdleTimeMillis(750);
        ds.getPoolProperties().setRemoveAbandoned(true);
        ds.getPoolProperties().setRemoveAbandonedTimeout(1);
    }
    public void testSimple() throws Exception {
        initSimplePoolProperties();
        common();
        ds.close(true);
        Driver.reset();
    }
    public void testEvicting() throws Exception {
        initEvictingPool();
        common();
        ds.close(true);
        Driver.reset();
    }
    private void common() throws Exception {
        ds.getConnection().close();
        final int iterations = 1000;
        final AtomicInteger loopcount = new AtomicInteger(0);
        final Runnable run = new Runnable() {
            public void run() {
                try {
                    while (loopcount.incrementAndGet() < iterations) {
                        Connection c = ds.getConnection();
                        Thread.sleep(1000);
                        c.close();
                    }
                } catch (Exception x) {
                    x.printStackTrace();
                }
            }
        };
        Thread[] threads = new Thread[200];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(run);
        }
        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }
        try {
            while (loopcount.get() < iterations) {
                Thread.sleep(250);
            }
        } catch (Exception x) {
            loopcount.set(iterations); // stops the test
            x.printStackTrace();
        }
        for (int i = 0; i < threads.length; i++) {
            threads[i].join();
        }
        System.out.println("Pool size:"+ds.getPool().getSize());
        assertTrue("Size validity check: ", ds.getPool().getSize() >= 0);
    }

======= d95db3f:"java/org/apache/catalina/core/ApplicationTaglibDescriptor.java"

======= d95db3f:"java/org/apache/catalina/deploy/LoginConfig.java"

======= d95db3f:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

======= d95db3f:"java/org/apache/el/parser/SimpleNode.java"

======= d95db3f:"java/org/apache/naming/NamingEntry.java"

        if (obj instanceof NamingEntry) {
======= d95db3f:"java/org/apache/tomcat/util/net/URL.java"

      <fix>
        <bug>50601</bug>: Code clean-up. Patch provided by sebb. (markt)
      </fix>

======= de188ad:"java/org/apache/catalina/ant/AbstractCatalinaTask.java"

    protected String url = "http://localhost:8080/manager/text";
      <code>http://localhost:8080/manager/text</code> (which corresponds
      to a standard installation of Tomcat 7).
  <property name="url"      value="http://localhost:8080/manager/text"/>
  <property name="manager.url"   value="http://localhost:8080/manager/text"/>
      <fix>
        <bug>50598</bug>: Correct URL for Manager text interface. (markt)
      </fix>
                <code>http://localhost:8080/manager/text</code>.

======= 30468b7:"java/org/apache/catalina/core/ApplicationFilterConfig.java"

            // Allocate a new filter instance if necessary
            if (filterDef.getFilter() == null) {
                getFilter();
            }
      <fix>
        <bug>50597</bug>: Don&apos;t instantiate a new instance of a Filter if
        an instance was provided via the
        <code>ServletContext.addFilter(String, Filter)</code> method. Patch
        provided by Ismael Juma. (markt)
      </fix>

======= d269ce3:"java/org/apache/catalina/ha/deploy/WarWatcher.java"

                i.remove();
      <fix>
        <bug>50600</bug>: Prevent a <code>ConcurrentModificationException</code>
        when removing a WAR file via the FarmWarDeployer. (markt)
      </fix>

======= 35a84d1:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                ((Context) request.getMappingData().context).logAccess(request,
                        response,
                        System.currentTimeMillis() - req.getStartTime(), false);
======= 35a84d1:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        boolean create = false;
        
            create = true;
======= 35a84d1:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        if (create) {
            request.recycle();
            response.recycle();
        }
======= 35a84d1:"java/org/apache/catalina/valves/AccessLogValve.java"

        getNext().invoke(request, response);       
        if (!getState().isAvailable() || !getEnabled() ||
                logElements == null || condition != null
======= 35a84d1:"java/org/apache/catalina/valves/AccessLogValve.java"

            // Don't need to flush since trigger for log message is after the
            // response has been committed
            long length = response.getBytesWritten(false);
======= 35a84d1:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

    public void invoke(Request request, Response response) throws IOException,
            ServletException {
        if (!getState().isAvailable()) {
            return;
        }
======= 35a84d1:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        byteCount = 0;
======= 35a84d1:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

      <fix>
        <bug>50582</bug>: Refactor access logging so chunked encoding is not
        forced for all requests if bytes sent is logged. (markt)
      </fix>

======= d8f8be1:"java/org/apache/catalina/ha/tcp/ReplicationValve.java"

        Pattern f = filter;
        return f != null && f.matcher(uri).matches();
      <fix>
        <bug>50591</bug>: Fix NPE in ReplicationValve. (kkolinko)
      </fix>

======= 51650a1:"java/org/apache/catalina/users/MemoryUserDatabase.java"

        if (groupname == null || groupname.length() == 0) {
            String msg = sm.getString("memoryUserDatabase.nullGroup");
            log.warn(msg);
            throw new IllegalArgumentException(msg);
        }
======= 51650a1:"java/org/apache/catalina/users/MemoryUserDatabase.java"

        if (rolename == null || rolename.length() == 0) {
            String msg = sm.getString("memoryUserDatabase.nullRole");
            log.warn(msg);
            throw new IllegalArgumentException(msg);
        }
======= 51650a1:"java/org/apache/catalina/users/MemoryUserDatabase.java"

        if (username == null || username.length() == 0) {
            String msg = sm.getString("memoryUserDatabase.nullUser");
            log.warn(msg);
            throw new IllegalArgumentException(msg);
        }
======= 51650a1:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                     new MemoryGroupCreationFactory(this), true);
                     new MemoryRoleCreationFactory(this), true);
                     new MemoryUserCreationFactory(this), true);
      <add>
        <bug>18797</bug>: Provide protection against <code>null</code> or zero
        length names being provided for users, roles and groups in the
        <code>MemoryRealm</code> and <code>UserDatabaseRealm</code>. (markt)
      </add>

======= 164fd40:"java/org/apache/catalina/startup/Catalina.java"

        System.setOut(new SystemLogHandler(System.out));
        System.setErr(new SystemLogHandler(System.err));
======= 164fd40:"java/org/apache/catalina/startup/Embedded.java"

            System.setOut(new SystemLogHandler(System.out));
            System.setErr(new SystemLogHandler(System.err));
      <fix>
        <bug>18462</bug>: Don&apos;t merge <code>stdout</code> and
        <code>stderr</code> internally so users retain the option to treat the
        separately. (markt)
      </fix>

======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

                out.printil("public java.lang.String getServletInfo() {");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("private void _jspInit(javax.servlet.ServletConfig config) {");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("private static final javax.servlet.jsp.JspFactory _jspxFactory =");
        out.printil("        javax.servlet.jsp.JspFactory.getDefaultFactory();");
        out.printil("private static java.util.List<java.lang.String> _jspx_dependants;");
            out.printin("_jspx_dependants = new java.util.ArrayList<java.lang.String>(");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("public java.util.List<java.lang.String> getDependants() {");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

            out.printin("                 javax.servlet.SingleThreadModel");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

        out.println("(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)");
        out.println("        throws java.io.IOException, javax.servlet.ServletException {");
        out.printil("final javax.servlet.jsp.PageContext pageContext;");
            out.printil("javax.servlet.http.HttpSession session = null;");
            out.printil("java.lang.Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);");
            out.printil("response.setStatus(javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR);");
        out.printil("final javax.servlet.ServletContext application;");
        out.printil("final javax.servlet.ServletConfig config;");
        out.printil("javax.servlet.jsp.JspWriter out = null;");
        out.printil("final java.lang.Object page = this;");
        out.printil("javax.servlet.jsp.JspWriter _jspx_out = null;");
        out.printil("javax.servlet.jsp.PageContext _jspx_page_context = null;");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

                out.printil("throw new javax.servlet.jsp.SkipPageException();");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

            String scopename = "javax.servlet.jsp.PageContext.PAGE_SCOPE"; // Default to page
                scopename = "javax.servlet.jsp.PageContext.REQUEST_SCOPE";
                scopename = "javax.servlet.jsp.PageContext.SESSION_SCOPE";
                scopename = "javax.servlet.jsp.PageContext.APPLICATION_SCOPE";
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

                    out.printil("} catch (java.lang.ClassNotFoundException exc) {");
                    out.printil("} catch (java.lang.Exception exc) {");
                    out.printin("throw new javax.servlet.ServletException(");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

                out.print("javax.servlet.jsp.PageContext _jspx_page_context");
                out.printil("        throws java.lang.Throwable {");
                    out.printil("javax.servlet.jsp.PageContext pageContext = _jspx_page_context;");
                out.printil("javax.servlet.jsp.JspWriter out = _jspx_page_context.getOut();");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

                        nvp = " + (java.lang.Boolean.valueOf(" + omit + ")?\"\":\" " +
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("jspContext.getELContext().putContext(javax.servlet.jsp.JspContext.class,getJspContext());");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("jspContext.getELContext().putContext(javax.servlet.jsp.JspContext.class,getJspContext());");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

                out.printil("throw new javax.servlet.jsp.SkipPageException();");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

                out.printil("} catch (java.lang.Throwable _jspx_exception) {");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

                    sb.append("new java.lang.Class[] {");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

            String scopeName = "javax.servlet.jsp.PageContext.PAGE_SCOPE"; // Default to page
                scopeName = "javax.servlet.jsp.PageContext.REQUEST_SCOPE";
                scopeName = "javax.servlet.jsp.PageContext.SESSION_SCOPE";
                scopeName = "javax.servlet.jsp.PageContext.APPLICATION_SCOPE";
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

                        out.printil("java.lang.String "
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

                    out.printil("java.lang.String " + varName + " = "
                out.printil("java.lang.String " + varName + " = \"\";");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("javax.servlet.http.HttpSession session = _jspx_page_context.getSession();");
            out.printil("javax.servlet.ServletContext application = _jspx_page_context.getServletContext();");
            out.printil("javax.servlet.http.HttpServletRequest request = (javax.servlet.http.HttpServletRequest)_jspx_page_context.getRequest();");
            out.printil("javax.servlet.http.HttpServletResponse response = (javax.servlet.http.HttpServletResponse)_jspx_page_context.getResponse();");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("} catch (java.lang.Throwable t) {");
        out.printil("if (!(t instanceof javax.servlet.jsp.SkipPageException)){");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("private javax.servlet.jsp.JspContext jspContext;");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("public void doTag() throws javax.servlet.jsp.JspException, java.io.IOException {");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("javax.servlet.jsp.PageContext _jspx_page_context = (javax.servlet.jsp.PageContext)jspContext;");
        out.printil("javax.servlet.http.HttpServletRequest request = "
                + "(javax.servlet.http.HttpServletRequest) _jspx_page_context.getRequest();");
        out.printil("javax.servlet.http.HttpServletResponse response = "
                + "(javax.servlet.http.HttpServletResponse) _jspx_page_context.getResponse();");
        out.printil("javax.servlet.http.HttpSession session = _jspx_page_context.getSession();");
        out.printil("javax.servlet.ServletContext application = _jspx_page_context.getServletContext();");
        out.printil("javax.servlet.ServletConfig config = _jspx_page_context.getServletConfig();");
        out.printil("javax.servlet.jsp.JspWriter out = jspContext.getOut();");
        out.printil("jspContext.getELContext().putContext(javax.servlet.jsp.JspContext.class,jspContext);");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("} catch( java.lang.Throwable t ) {");
        out.printil("if( t instanceof javax.servlet.jsp.SkipPageException )");
        out.printil("    throw (javax.servlet.jsp.SkipPageException) t;");
        out.printil("if( t instanceof java.lang.IllegalStateException )");
        out.printil("    throw (java.lang.IllegalStateException) t;");
        out.printil("if( t instanceof javax.servlet.jsp.JspException )");
        out.printil("    throw (javax.servlet.jsp.JspException) t;");
        out.printil("throw new javax.servlet.jsp.JspException(t);");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("jspContext.getELContext().putContext(javax.servlet.jsp.JspContext.class,super.getJspContext());");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("public void setJspContext(javax.servlet.jsp.JspContext ctx, java.util.Map aliasMap) {");
            out.printil("public void setJspContext(javax.servlet.jsp.JspContext ctx) {");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("public javax.servlet.jsp.JspContext getJspContext() {");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("public void setDynamicAttribute(java.lang.String uri, java.lang.String localName, java.lang.Object value) throws javax.servlet.jsp.JspException {");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

                    + "( int discriminator, javax.servlet.jsp.JspContext jspContext, "
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

            out.println(result.getId() + "( " + "javax.servlet.jsp.JspWriter out ) ");
            out.printil("throws java.lang.Throwable");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("throws javax.servlet.jsp.JspException");
            out.printil("javax.servlet.jsp.JspWriter out = null;");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("this.jspContext.getELContext().putContext(javax.servlet.jsp.JspContext.class,this.jspContext);");
======= e69347b:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("catch( java.lang.Throwable e ) {");
            out.printil("if (e instanceof javax.servlet.jsp.SkipPageException)");
            out.printil("    throw (javax.servlet.jsp.SkipPageException) e;");
            out.printil("throw new javax.servlet.jsp.JspException( e );");
======= e69347b:"java/org/apache/jasper/compiler/JspUtil.java"

                        + ".class, " + "(javax.servlet.jsp.PageContext)" + jspCtxt + ", "
======= e69347b:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(java.lang.Boolean) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", java.lang.Boolean.class)";
                return "new java.lang.Boolean(false)";
                return "new java.lang.Boolean(" + Boolean.valueOf(s).toString() + ")";
======= e69347b:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(java.lang.Byte) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", java.lang.Byte.class)";
                return "new java.lang.Byte((byte) 0)";
                return "new java.lang.Byte((byte)" + Byte.valueOf(s).toString() + ")";
======= e69347b:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(java.lang.Character) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", java.lang.Character.class)";
                return "new java.lang.Character((char) 0)";
                return "new java.lang.Character((char) " + (int) ch + ")";
======= e69347b:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(java.lang.Double) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                return "new java.lang.Double(0)";
                return "new java.lang.Double(" + Double.valueOf(s).toString() + ")";
======= e69347b:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(java.lang.Float) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", java.lang.Float.class)";
                return "new java.lang.Float(0)";
                return "new java.lang.Float(" + Float.valueOf(s).toString() + "f)";
======= e69347b:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(java.lang.Integer) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", java.lang.Integer.class)";
                return "new java.lang.Integer(0)";
                return "new java.lang.Integer(" + Integer.valueOf(s).toString() + ")";
======= e69347b:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(java.lang.Short) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", java.lang.Short.class)";
                return "new java.lang.Short((short) 0)";
                return "new java.lang.Short(\"" + Short.valueOf(s).toString() + "\")";
======= e69347b:"java/org/apache/jasper/compiler/JspUtil.java"

            return "(java.lang.Long) org.apache.jasper.runtime.JspRuntimeLibrary.coerce("
                    + s + ", java.lang.Long.class)";
                return "new java.lang.Long(0)";
                return "new java.lang.Long(" + Long.valueOf(s).toString() + "l)";
======= e69347b:"java/org/apache/jasper/compiler/JspUtil.java"

            return "java.lang.Void.TYPE";
      <update>
        <bug>15688</bug>: Use fully-qualified class names in generated jsp files
        to avoid naming conflicts with user imports. (markt)
      </update>

======= 0ccff07:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        if (properties.getMaxActive()<1) {
            log.warn("maxActive is smaller than 1, setting maxActive to: "+PoolProperties.DEFAULT_MAX_ACTIVE);
            properties.setMaxActive(PoolProperties.DEFAULT_MAX_ACTIVE);
        }
======= 0ccff07:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    public static final int DEFAULT_MAX_ACTIVE = 100;
    
======= 0ccff07:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    protected int maxActive = DEFAULT_MAX_ACTIVE;

======= fd990a4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java"

    @Override
======= fd990a4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java"

    @Override
    @Override
======= fd990a4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java"

    @Override
======= fd990a4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    @Override

      <fix>
        <bug>21157</bug>: Ensure cookies are written before the response is
        commited in the Cookie example. Patch provided by Stefan Radzom. (markt)
      </fix>
======= 4ce656a:"webapps/examples/WEB-INF/classes/CookieExample.java"

        
        String cookieName = request.getParameter("cookiename");
        String cookieValue = request.getParameter("cookievalue");
        Cookie aCookie = null;
        if (cookieName != null && cookieValue != null) {
            aCookie = new Cookie(cookieName, cookieValue);
            response.addCookie(aCookie);
        }
======= 4ce656a:"webapps/examples/WEB-INF/classes/CookieExample.java"

        if (aCookie != null) {

======= a6b37af:"java/org/apache/catalina/ant/BaseRedirectorHelperTask.java"

            if (redirectOutput && redirectOutPrintStream != null) {
      <fix>
        <bug>50552</bug>: Avoid NPE that hides error message when using Ant
        tasks. (schultz)
      </fix>

======= 06b8609:"java/org/apache/naming/java/javaURLContextFactory.java"

    @SuppressWarnings("unchecked")
    @Override
======= 06b8609:"java/org/apache/naming/java/javaURLContextFactory.java"

    @SuppressWarnings("unchecked")
    @Override
======= 06b8609:"java/org/apache/naming/java/javaURLContextFactory.java"

            synchronized(javaURLContextFactory.class) {
  <Match>
    <Class name="org.apache.naming.java.javaURLContextFactory" />
    <Bug code="Nm" />
  </Match>
      <fix>
        <bug>50554</bug>: Code clean up. (markt)
      </fix>

======= 869c6f4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        PooledConnection pc = this.borrowConnection(0, null, null);
        if (pc!=null) {
            return new ConnectionFuture(pc);
        } 
======= 869c6f4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        volatile PooledConnection pc = null;
        public ConnectionFuture(PooledConnection pc) {
            this.pc = pc;
        }
            if (pc!=null) {
                return false;
            } else if ((!cancelled.get()) && cancelled.compareAndSet(false, true)) {
======= 869c6f4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            PooledConnection pc = this.pc!=null?this.pc:pcFuture.get(timeout,unit);
======= 869c6f4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            return pc==null && (pcFuture.isCancelled() || cancelled.get());
            return pc!=null || pcFuture.isDone();
======= 869c6f4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * @author Filip Hanik
 * @version 1.0
 */
    public Async0IdleTestBug50477(String name) {
        super(name);
    }
    
 
    public void testAsync0Idle0Size() throws Exception {
        System.out.println("[testPoolThreads20Connections10FairAsync] Starting fairness - Tomcat JDBC - Fair - Async");
        init();
        this.datasource.getPoolProperties().setMaxActive(10);
        this.datasource.getPoolProperties().setFairQueue(true);
        this.datasource.getPoolProperties().setInitialSize(0);
        try {
            Future<Connection> cf = ((DataSourceProxy)datasource).getConnectionAsync();
            Connection con  = cf.get(5, TimeUnit.SECONDS);
        }finally {
            tearDown();
        }
    }

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ 
 * <p>Object factory for resource links for shared data sources.</p>
 * 
 * @author Filip Hanik
 * @version $Id: ResourceLinkFactory.java 939311 2010-04-29 14:01:02Z kkolinko $
 */
    implements ObjectFactory {
    // -------------------------------------------------- ObjectFactory Methods
    /**
     * Create a new DataSource instance.
     * 
     * @param obj The reference object describing the DataSource
     */
    public Object getObjectInstance(Object obj, Name name, Context nameCtx,
                                    Hashtable<?,?> environment)
        throws NamingException {
        Object result = super.getObjectInstance(obj, name, nameCtx, environment);
        // Can we process this request?
        if (result!=null) {
            Reference ref = (Reference) obj;
    
            RefAddr userAttr = ref.get("username");
            RefAddr passAttr = ref.get("password");
            if (userAttr.getContent()!=null && passAttr.getContent()!=null) {
                result = wrapDataSource(result,userAttr.getContent().toString(), passAttr.getContent().toString());
            }
        }
        return result;
    }
    
    protected Object wrapDataSource(Object datasource, String username, String password) throws NamingException {
        try {
            Class<?> proxyClass = Proxy.getProxyClass(datasource.getClass().getClassLoader(), datasource.getClass().getInterfaces());
            Constructor<?> proxyConstructor = proxyClass.getConstructor(new Class[] { InvocationHandler.class });
            DataSourceHandler handler = new DataSourceHandler((DataSource)datasource, username, password);
            return proxyConstructor.newInstance(handler);    
        }catch (Exception x) {
            if (x instanceof NamingException) throw (NamingException)x;
            else {
                NamingException nx = new NamingException(x.getMessage());
                nx.initCause(x);
                throw nx;
            }
        }
    }
    
    /**
     * Simple wrapper class that will allow a user to configure a ResourceLink for a data source
     * so that when {@link javax.sql.DataSource#getConnection()} is called, it will invoke 
     * {@link javax.sql.DataSource#getConnection(String, String)} with the preconfigured username and password.
     */
    public static class DataSourceHandler implements InvocationHandler {
        DataSource ds; 
        String username; 
        String password;
        public DataSourceHandler(DataSource ds, String username, String password) {
            this.ds = ds;
            this.username = username;
            this.password = password;
        }
        
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            
            if ("getConnection".equals(method.getName()) && args.length==0) {
                args = new String[] {username,password};
            } else if ("unwrap".equals(method.getName())) {
                return unwrap((Class<?>)args[0]);
            }
            try {
                return method.invoke(ds,args);
            }catch (Throwable t) {
                if (t instanceof InvocationTargetException) {
                    InvocationTargetException it = (InvocationTargetException)t;
                    throw it.getCause()!=null?it.getCause():it;
                } else {
                    throw t;
                }
            }
        }
        
        public Object unwrap(Class<?> iface) throws SQLException {
            if (iface == DataSource.class) {
                return ds;
            } else {
                throw new SQLException("Not a wrapper of "+iface.getName());
            }
        }
        
    }
    
    
      <fix><bug>49543</bug> Allow Tomcat to use shared data sources with 
       per application credentials. (fhanik)
      </fix>
      <attribute name="factory" required="false">
        <p>The fully qualified Java class name for the class creating these objects.
        This class should implement the <code>javax.naming.spi.ObjectFactory</code> interface.</p>
      </attribute>
    
    <p>When the attribute <code>factory=&quot;org.apache.naming.factory.DataSourceLinkFactory&quot;</code> the resource link can be used with
       two additional attributes to allow a shared data source to be used with different credentials.
       When these two additional attributes are used in combination with the <code>javax.sql.DataSource</code>
       type, different contexts can share a global data source with different credentials.
       Under the hood, what happens is that a call to <a href="http://download.oracle.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection()"><code>getConnection()</code></a>
       is simply translated to a call <a href="http://download.oracle.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection(java.lang.String,%20java.lang.String)">
       <code>getConnection(username, password)</code></a> on the global data source. This is an easy way to get code to be transparent to what schemas are being used,
       yet be able to control connections (or pools) in the global configuration. 
    </p>
    <attributes>
      <attribute name="username" required="false">
        <p></p>
      </attribute>
      <attribute name="password" required="false">
        <p></p>
      </attribute>
    </attributes>
    <p>Shared Data Source Example</p>
  ...
  &lt;Resource name=&quot;sharedDataSource&quot;
            global=&quot;sharedDataSource&quot;
            type=&quot;javax.sql.DataSource&quot;
            username=&quot;bar&quot;
            password=&quot;barpass&quot;
            
            ...
  ...
  ...
  &lt;ResourceLink 
            name=&quot;appDataSource&quot;
            global=&quot;sharedDataSource&quot;
            type=&quot;javax.sql.DataSource&quot;
            factory=&quot;org.apache.naming.factory.DataSourceLinkFactory&quot;
            username=&quot;foo&quot;
            password=&quot;foopass&quot;
  ...
  ...
  &lt;ResourceLink 
            name=&quot;appDataSource&quot;
            global=&quot;sharedDataSource&quot;
            type=&quot;javax.sql.DataSource&quot;
  ...
    <p>When a request for <code>getConnection()</code> is made in the <code>/foo</code> context, the request is translated into
       <code>getConnection(&quot;foo&quot;,&quot;foopass&quot;)</code>, while a request in the <code>/bar</code> gets passed straight through.</p>

======= 5c2742c:"java/org/apache/naming/resources/ProxyDirContext.java"

            boolean result = cache.unload(name);
            // To ensure correct operation, particularly of WebDAV, unload
            // the resource with and without a trailing /
            if (name.endsWith("/")) {
                cache.unload(name.substring(0, name.length() -1));
            } else {
                cache.unload(name + "/");
            }
            return result;
      <fix>
        <bug>50550</bug>: When a new directory is created (e.g. via WebDAV)
        ensure that a subsequent request for that directory does not result in a
        404 response. (markt)
      </fix>

======= ce64f9b:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                    if (remoteHost == null) {
                        remoteHost = Address.getip(sa);
                    }
      <fix>
        <bug>47319</bug>: Return the client&apos;s IP address rather than null
        for calls to <code>getRemoteHost()</code> when the APR connector is
        used with <code>enableLookups=&quot;true&quot;</code> but the IP address
        is not resolveable. (markt)
      </fix>

======= a0ef3e6:"java/org/apache/catalina/ha/session/DeltaManager.java"

                msg.setTimestamp(System.currentTimeMillis());
======= a0ef3e6:"java/org/apache/catalina/ha/session/DeltaManager.java"

        msg.setTimestamp(System.currentTimeMillis());
      <fix>
        <bug>50547</bug>: Add time stamp for CHANGE_SESSION_ID message and 
        SESSION_EXPIRED message. (kfujino)
      </fix>

======= 3541fc6:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            StringBuffer concatRemoteIpHeaderValue = new StringBuffer();
            for (Enumeration<String> e = request.getHeaders(remoteIpHeader); e.hasMoreElements();) {
                if (concatRemoteIpHeaderValue.length() > 0) {
                    concatRemoteIpHeaderValue.append(", ");
                }
                concatRemoteIpHeaderValue.append(e.nextElement());
            }
            String[] remoteIpHeaderValue = commaDelimitedListToStringArray(concatRemoteIpHeaderValue.toString());
======= 3541fc6:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                        + concatRemoteIpHeaderValue + "', original[" + protocolHeader + "]='"
                        + xRequest.getHeader(remoteIpHeader) + "', new[" + proxiesHeader + "]='" + xRequest.getHeader(proxiesHeader) + "'");
======= 3541fc6:"java/org/apache/catalina/valves/RemoteIpValve.java"

======= 3541fc6:"java/org/apache/catalina/valves/RemoteIpValve.java"

            StringBuffer concatRemoteIpHeaderValue = new StringBuffer();
            for (Enumeration<String> e = request.getHeaders(remoteIpHeader); e.hasMoreElements();) {
                if (concatRemoteIpHeaderValue.length() > 0) {
                    concatRemoteIpHeaderValue.append(", ");
                }
                concatRemoteIpHeaderValue.append(e.nextElement());
            }
            String[] remoteIpHeaderValue = commaDelimitedListToStringArray(concatRemoteIpHeaderValue.toString());
======= 3541fc6:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

        public void addHeader(String name, String value) {
            getCoyoteRequest().getMimeHeaders().addValue(name).setString(value);
        }
======= 3541fc6:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

        request.addHeader("x-forwarded-for", "140.211.11.130, 192.168.0.10, 192.168.0.11");
======= 3541fc6:"test/org/apache/catalina/filters/TestRemoteIpFilter.java"

        request.addHeader("x-forwarded-for", "140.211.11.130");
        request.addHeader("x-forwarded-for", "proxy1");
        request.addHeader("x-forwarded-for", "proxy2");
======= 3541fc6:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

        request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-for").setString("140.211.11.130");
        request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-for").setString("proxy1");
        request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-for").setString("proxy2");
      <fix>
        <bug>50453</bug>: Correctly handle multiple <code>X-Forwarded-For</code>
        headers in the RemoteIpFilter and RemoteIpValve. Patch provided by Jim
        Riggs. (markt)
      </fix>

======= 688e61e:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                        // Attachment may be null if another thread has called
                        // cancelledKey()
                        if (attachment == null) {
                            iterator.remove();
                        } else {
                            attachment.access();
                            iterator.remove();
                            processKey(sk, attachment);
                        }
      <fix>
        <bug>50467</bug>: Protected against NPE triggered by a race condition
        that causes the NIO poller to fail, preventing the processing of further
        requests. (markt)
      </fix>

======= 76b6415:"java/org/apache/catalina/realm/JNDIRealm.java"

    /**
     * The sizeLimit (also known as the countLimit) to use when the realm is
     * configured with {@link #userSearch}. Zero for no limit.
     */
    protected long sizeLimit = 0;
    /**
     * The timeLimit (in milliseconds) to use when the realm is configured with
     * {@link #userSearch}. Zero for no limit.
     */
    protected int timeLimit = 0;
======= 76b6415:"java/org/apache/catalina/realm/JNDIRealm.java"

    public long getSizeLimit() {
        return sizeLimit;
    }
    public void setSizeLimit(long sizeLimit) {
        this.sizeLimit = sizeLimit;
    }
    public int getTimeLimit() {
        return timeLimit;
    }
    public void setTimeLimit(int timeLimit) {
        this.timeLimit = timeLimit;
    }
======= 76b6415:"java/org/apache/catalina/realm/JNDIRealm.java"

        constraints.setCountLimit(sizeLimit);
        constraints.setTimeLimit(timeLimit);
      <add>
        <bug>50541</bug>: Add support for setting the size limit and time limit
        for LDAP seaches when using the JNDI Realm with <code>userSearch</code>.
        (markt)
      </add>
      <attribute name="sizeLimit" required="false">
        <p>Specifies the maximum number of records to return when using the
        <code>userSearch</code> attribute. If not specified, the default of
        <code>0</code> is used which indicates no limit.</p>
      </attribute>
      <attribute name="timeLimit" required="false">
        <p>Specifies the time (in milliseconds) to wait for records to be
        returned when using the <code>userSearch</code> attribute. If not
        specified, the default of <code>0</code> is used which indicates no
        limit.</p>
      </attribute>

======= b19fb3b:"java/org/apache/el/lang/ELArithmetic.java"

        else if (DOUBLE.matches(obj0, obj1)) {
            if (BIGINTEGER.matches(obj0, obj1))
                delegate = BIGDECIMAL;
            else
                delegate = DOUBLE;
        } else if (BIGINTEGER.matches(obj0, obj1))
======= b19fb3b:"java/org/apache/el/lang/ELArithmetic.java"

            delegate = DOUBLE;
======= b19fb3b:"java/org/apache/el/lang/ELArithmetic.java"

        else if (DOUBLE.matches(obj0, obj1)) {
            if (BIGINTEGER.matches(obj0, obj1))
                delegate = BIGDECIMAL;
            else
                delegate = DOUBLE;
        } else if (BIGINTEGER.matches(obj0, obj1))
======= b19fb3b:"java/org/apache/el/lang/ELArithmetic.java"

        else if (DOUBLE.matches(obj0, obj1)) {
            if (BIGINTEGER.matches(obj0, obj1))
                delegate = BIGDECIMAL;
            else
                delegate = DOUBLE;
        } else if (BIGINTEGER.matches(obj0, obj1))
======= b19fb3b:"java/org/apache/el/lang/ELArithmetic.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private final String a = "1.1";
    private final BigInteger b = new BigInteger("1000000000000000000000");
    public void testAdd() throws Exception {
        assertEquals("1000000000000000000001.1",
                String.valueOf(ELArithmetic.add(a, b)));
    }
    public void testSubtract() throws Exception {
        assertEquals("-999999999999999999998.9",
                String.valueOf(ELArithmetic.subtract(a, b)));
    }
    public void testMultiply() throws Exception {
        assertEquals("1100000000000000000000.0",
                String.valueOf(ELArithmetic.multiply(a, b)));
    }
    public void testDivide() throws Exception {
        assertEquals("0.0",
                String.valueOf(ELArithmetic.divide(a, b)));
    }
    public void testMod() throws Exception {
        assertEquals("1.1",
                String.valueOf(ELArithmetic.mod(a, b)));
    }
      <fix>
        <bug>50500</bug>: Use correct coercions (as per the EL spec) for
        arithmetic operations involving string values containing &apos;.&apos;,
        &apos;e&apos; or &apos;E&apos;. Based on a patch by Brian Weisleder.
        (markt)
      </fix>

    <attribute name="alternateUsernameAllowed" required="false">
      <p>(boolean) By default, the jdbc-pool will ignore the 
         <a href="http://download.oracle.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection(java.lang.String,%20java.lang.String)"><code>DataSource.getConnection(username,password)</code></a>
         call, and simply return a previously pooled connection under the globally configured properties <code>username</code> and <code>password</code>, for performance reasons.
         The pool can however be used with different credentials each time a connection is used. Should you request a connection with the credentials user1/password1 and the connection
         was previously connected using user2/password2, the connection will be closed, and reopened with the requested credentials. This way, the pool size is still managed
         on a global level, and not on a per schema level. To enable the functionality described in the 
         <a href="http://download.oracle.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection(java.lang.String,%20java.lang.String)"><code>DataSource.getConnection(username,password)</code></a>
         call, simply set the property <code>alternateUsernameAllowed</code> to true. <br/>
         The default value is <code>false</code>.<br/>
         This property was added as an enhancement to <a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=50025">bug 50025</a>.
      </p>
    </attribute>
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

        PooledConnection con = borrowConnection(-1,null,null);
       
    /**
     * Borrows a connection from the pool. If a connection is available (in the
     * idle queue) or the pool has not reached {@link PoolProperties#maxActive
     * maxActive} connections a connection is returned immediately. If no
     * connection is available, the pool will attempt to fetch a connection for
     * {@link PoolProperties#maxWait maxWait} milliseconds.
     * 
     * @return Connection - a java.sql.Connection/javax.sql.PooledConnection
     *         reflection proxy, wrapping the underlying object.
     * @throws SQLException
     *             - if the wait times out or a failure occurs creating a
     *             connection
     */
    public Connection getConnection(String username, String password) throws SQLException {
        // check out a connection
        PooledConnection con = borrowConnection(-1, username, password);
        return setupConnection(con);
    }
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                initialPool[i] = this.borrowConnection(0, null, null); //don't wait, should be no contention
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    private PooledConnection borrowConnection(int wait, String username, String password) throws SQLException {
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                PooledConnection result = borrowConnection(now, con, username, password);
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                    return createConnection(now, con, username, password);
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    protected PooledConnection createConnection(long now, PooledConnection notUsed, String username, String password) throws SQLException {
        if (username!=null) con.getAttributes().put(con.PROP_USER, username);
        if (password!=null) con.getAttributes().put(con.PROP_PASSWORD, password);
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

    protected PooledConnection borrowConnection(long now, PooledConnection con, String username, String password) throws SQLException {
            boolean usercheck = con.checkUser(username, password);
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

            
            if (usercheck) {
                if ((!con.isDiscarded()) && con.validate(PooledConnection.VALIDATE_BORROW)) {
                    //set the timestamp
                    con.setTimestamp(now);
                    if (getPoolProperties().isLogAbandoned()) {
                        //set the stack trace for this pool
                        con.setStackTrace(getThreadDump());
                    }
                    if (!busy.offer(con)) {
                        log.debug("Connection doesn't fit into busy array, connection will not be traceable.");
                    }
                    return con;
            //is either has another principal, is discarded or validation failed.
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java"

                        pc = borrowConnection(System.currentTimeMillis(),pc, null, null);
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

    protected static final String PROP_ALTERNATE_USERNAME_ALLOWED = "alternateUsernameAllowed";
    
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        PROP_ALTERNATE_USERNAME_ALLOWED
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        
        value = properties.getProperty(PROP_ALTERNATE_USERNAME_ALLOWED);
        if (value != null) {
            poolProperties.setAlternateUsernameAllowed(Boolean.parseBoolean(value));
        }
        
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

        if (this.getPoolProperties().isAlternateUsernameAllowed()) {
            if (pool == null)
                return createPool().getConnection(username,password);
            return pool.getConnection(username,password);
        } else {
            return getConnection();
        }
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java"

    /** 
     * {@inheritDoc}
     */
    public boolean isAlternateUsernameAllowed() {
        return getPoolProperties().isAlternateUsernameAllowed();
    }
    /** 
     * {@inheritDoc}
     */
    public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed) {
        getPoolProperties().setAlternateUsernameAllowed(alternateUsernameAllowed);
    }
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java"

    /**
     * Returns true if the call {@link DataSource#getConnection(String, String) getConnection(username,password)} is 
     * allowed. This is used for when the pool is used by an application accessing multiple schemas.
     * There is a performance impact turning this option on.
     * @return true if {@link DataSource#getConnection(String, String) getConnection(username,password)} is honored, false if it is ignored.
     */
    public boolean isAlternateUsernameAllowed();
    
    /**
     * Set to true if the call {@link DataSource#getConnection(String, String) getConnection(username,password)} is 
     * allowed and honored.. This is used for when the pool is used by an application accessing multiple schemas.
     * There is a performance impact turning this option on, even when not used due to username checks.
     * @param alternateUsernameAllowed - set true if {@link DataSource#getConnection(String, String) getConnection(username,password)} is honored, 
     * false if it is to be ignored.
     */
    public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed);
    
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    protected boolean alternateUsernameAllowed = false;
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    
    /** 
     * {@inheritDoc}
     */
    public boolean isAlternateUsernameAllowed() {
        return alternateUsernameAllowed;
    }
    
    /** 
     * {@inheritDoc}
     */
    public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed) {
        this.alternateUsernameAllowed = alternateUsernameAllowed;
    }
    
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

    public static final String PROP_USER = "user";
    
    public static final String PROP_PASSWORD = "password";
    
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

    public boolean checkUser(String username, String password) {
        if (!getPoolProperties().isAlternateUsernameAllowed()) return true;
        
        if (username==null) username = poolProperties.getUsername();
        if (password==null) password = poolProperties.getPassword();
        
        String storedUsr = (String)getAttributes().get(PROP_USER);
        String storedPwd = (String)getAttributes().get(PROP_PASSWORD);
        
        boolean result = (username==null && storedUsr==null);
        result = (result || (username!=null && username.equals(storedUsr)));
                
        result = result && ((password==null && storedPwd==null) || (password!=null && password.equals(storedPwd)));
        
        if (username==null)  getAttributes().remove(PROP_USER); else getAttributes().put(PROP_USER, username);
        if (password==null)  getAttributes().remove(PROP_PASSWORD); else getAttributes().put(PROP_PASSWORD, password);
        
        return result;
    }
    
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        String usr = null;
        String pwd = null;
        if (getAttributes().containsKey(PROP_USER)) {
            usr = (String) getAttributes().get(PROP_USER);
        } else {
            usr = poolProperties.getUsername();
            getAttributes().put(PROP_USER, usr);
        }
        if (getAttributes().containsKey(PROP_PASSWORD)) {
            pwd = (String) getAttributes().get(PROP_PASSWORD);
        } else {
            pwd = poolProperties.getPassword();
            getAttributes().put(PROP_PASSWORD, pwd);
        }
            if (usr!=null && pwd!=null) {
                xaConnection = xds.getXAConnection(usr, pwd);
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

            if (usr!=null && pwd!=null) {
                connection = ds.getConnection(usr, pwd);
            if (usr!=null && pwd!=null) {
                connection = ds.getPooledConnection(usr, pwd).getConnection();
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        String usr = null;
        String pwd = null;
        if (getAttributes().containsKey(PROP_USER)) {
            usr = (String) getAttributes().get(PROP_USER);
        } else {
            usr = poolProperties.getUsername();
            getAttributes().put(PROP_USER, usr);
        if (getAttributes().containsKey(PROP_PASSWORD)) {
            pwd = (String) getAttributes().get(PROP_PASSWORD);
        } else {
            pwd = poolProperties.getPassword();
            getAttributes().put(PROP_PASSWORD, pwd);
        Properties properties = clone(poolProperties.getDbProperties());
        if (usr != null) properties.setProperty(PROP_USER, usr);
        if (pwd != null) properties.setProperty(PROP_PASSWORD, pwd);
            connection = connection = driver.connect(driverURL, properties);
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

    private Properties clone(Properties p) {
        Properties c = new Properties();
        c.putAll(p);
        return c;
    }
    
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

    
    /** 
     * {@inheritDoc}
     */
    public boolean isAlternateUsernameAllowed() {
        return getPoolProperties().isAlternateUsernameAllowed();
    }
    
    /** 
     * {@inheritDoc}
     */
    public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed) {
        //noop
    }
======= 59b17c1:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    private static final int iterations = (new Random(System.currentTimeMillis())).nextInt(100000)+1000;
    public AlternateUsernameTest(String name) {
        super(name);
    }
    
    public void testGeneric() throws Exception {
        
        this.init();
        this.datasource.setDriverClassName(Driver.class.getName());
        this.datasource.setUrl("jdbc:tomcat:test");
        this.datasource.setAlternateUsernameAllowed(true);
        this.datasource.getConnection().close();
        int withoutuser =10;
        int withuser = withoutuser;
        TestRunner[] runners = new TestRunner[withuser+withoutuser];
        for (int i=0; i<withuser; i++) {
            TestRunner with = new TestRunner("foo","bar",datasource.getPoolProperties().getUsername(),datasource.getPoolProperties().getPassword());
            TestRunner without = new TestRunner(null,null,datasource.getPoolProperties().getUsername(),datasource.getPoolProperties().getPassword());
            runners[i] = with;
            runners[i+withuser] = without;
        }
        ExecutorService svc = Executors.newFixedThreadPool(withuser+withoutuser);
        List<Future<TestResult>> results =  svc.invokeAll(Arrays.asList(runners));
        int failures = 0;
        int total = 0;
        for (int i=0; i<withuser; i++) {
            failures += results.get(i).get().failures;
            total+=results.get(i).get().iterations;
            failures += results.get(i+withuser).get().failures;
            total+=results.get(i+withuser).get().iterations;
        }
        assertEquals("Nr of failures was:"+failures,0, failures);
        svc.shutdownNow();
        this.datasource.close();
        System.out.println("Nr of connect() calls:"+Driver.connectCount.get());
        System.out.println("Nr of disconnect() calls:"+Driver.disconnectCount.get());
        System.out.println("Nr of iterations:"+total);
    }
    
    public static class TestResult {
        public int iterations;
        public int failures;
        public String lastMessage;
    }
    
    public class TestRunner implements Callable<TestResult> {
        String username;
        String password;
        volatile boolean done = false;
        TestResult result = null;
        boolean useuser = true;
        
        public TestRunner(String user, String pass, String guser, String gpass) {
            username = user==null?guser : user;
            password = pass==null?gpass : pass;
            useuser = user!=null;
        }
        
        public TestResult call() {
            TestResult test = new TestResult();
            PooledConnection pcon = null;
            for (int i=0; (!done) && (i<iterations); i++) {
                test.iterations = i+1;
                try {
                    
                    
                    pcon = useuser ? (PooledConnection)AlternateUsernameTest.this.datasource.getConnection(username, password) :
                                     (PooledConnection)AlternateUsernameTest.this.datasource.getConnection();
                    
                    Connection con = (Connection)pcon.getConnection();
                    
                    assertTrue("Username mismatch: Requested User:"+username+" Actual user:"+con.getUsername(), con.getUsername().equals(username));
                    assertTrue("Password mismatch: Requested Password:"+password+" Actual password:"+con.getPassword(), con.getPassword().equals(password));
                }catch (SQLException x) {
                    test.failures++;
                    test.lastMessage = x.getMessage();
                    done = true;
                    x.printStackTrace();
                }catch (Exception x) {
                    test.failures++;
                    test.lastMessage = x.getMessage();
                    x.printStackTrace();
                } finally {
                    if (pcon!=null) {
                        try {pcon.close(); }catch (Exception ignore) {}
                        pcon = null;
                    }
                }
            }
            done = true;
            result = test;
            return result;
        }
    }
======= 59b17c1:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/driver/Connection.java"

    Properties info;
    
    public Connection(Properties info) {
        this.info = info;
    }
    
    public String getUsername() {
        return info.getProperty(PooledConnection.PROP_USER);
    }
    
    public String getPassword() {
        return info.getProperty(PooledConnection.PROP_PASSWORD);
    }
    
======= 59b17c1:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/driver/Driver.java"

        return new org.apache.tomcat.jdbc.test.driver.Connection(info);

======= 701d5dc:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

                if(host != null && host instanceof Host && clusterName!=null && 
                        !(clusterName.startsWith(host.getName() +"#"))) {
                }
      <fix>
        <bug>50503</bug>: When web application has a version, Engine level 
        Clustering works correctly. (kfujino)
      </fix>

======= 73531cb:"java/org/apache/jasper/compiler/Generator.java"

        out.println("(final HttpServletRequest request, final HttpServletResponse response)");
        out.printil("final PageContext pageContext;");
======= 73531cb:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("final ServletContext application;");
        out.printil("final ServletConfig config;");
        out.printil("final Object page = this;");
======= 73531cb:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("pageContext = _jspxFactory.getPageContext(this, request, response,");
      <add>
        <bug>13731</bug>: Make variables in <code>_jspService()</code> method
        final where possible. (markt)
      </add>

======= 71ad1bd:"java/org/apache/catalina/startup/Catalina.java"

======= 71ad1bd:"java/org/apache/catalina/startup/Catalina.java"

        } catch (SAXParseException spe) {
            log.warn("Catalina.start using " + getConfigFile() + ": " +
                    spe.getMessage());
            return;
            log.warn("Catalina.start using " + getConfigFile() + ": " , e);
======= 71ad1bd:"java/org/apache/tomcat/util/digester/Digester.java"

                    locator.getColumnNumber() + ") : " + message;
======= 71ad1bd:"java/org/apache/tomcat/util/digester/ObjectCreateRule.java"

        if (realClassName == null) {
            throw new NullPointerException("No class name specified for " +
                    namespace + " " + name);
        }
        <bug>10972</bug>: Improve error message if the className attribute is
        missing on an element in server.xml where it is required. (markt)
      </update>
      <update>

======= ca34a30:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

     * Should a session always be used once a user is authenticated? This may
     * offer some performance benefits since the session can then be used to
     * cache the authenticated Principal, hence removing the need to
     * authenticate the user via the Realm on every request. This may be of help
     * for combinations such as BASIC authentication used with the JNDIRealm or
     * DataSourceRealms. However there will also be the performance cost of
     * creating and GC'ing the session. By default, a session will not be
     * created. 
     */
    protected boolean alwaysUseSession = false;
    /**
======= ca34a30:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

        if (session != null) {
            if (changeSessionIdOnAuthentication) {
                Manager manager = request.getContext().getManager();
                manager.changeSessionId(session);
                request.changeSessionId(session.getId());
            }
        } else if (alwaysUseSession) {
            session = request.getSessionInternal(true);
      <add>
        <bug>10526</bug>: Add an option to the <code>Authenticator</code>s to
        force the creation of a session on authentication which may offer some
        performance benefits. (markt)
      </add>
      <attribute name="alwaysUseSession" required="false">
        <p>Should a session always be used once a user is authenticated? This
        may offer some performance benefits since the session can then be used
        to cache the authenticated Principal, hence removing the need to
        authenticate the user via the Realm on every request. This may be of
        help for combinations such as BASIC authentication used with the
        JNDIRealm or DataSourceRealms. However there will also be the
        performance cost of creating and GC'ing the session. If not set, the
        default value of <code>false</code> will be used.</p>
      </attribute>

======= 5614817:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

======= 5614817:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

            log.debug("Message " + msg + " data " + HexUtils.toHexString(msg.getData())
======= 5614817:"java/org/apache/coyote/ajp/AjpMessage.java"

======= 5614817:"java/org/apache/coyote/ajp/AjpMessage.java"

            log.debug(msg + ": " + HexUtils.toHexString(buf) + " " + pos +"/" + (len + 4));
======= 5614817:"java/org/apache/tomcat/util/buf/HexUtils.java"

    /**
     * Table for byte to hex string translation.
     */
    private static final char[] hex = "0123456789abcdef".toCharArray();
======= 5614817:"java/org/apache/tomcat/util/buf/HexUtils.java"

    public static String toHexString(byte[] bytes)
    {
        if(null == bytes) return null;
        StringBuilder sb = new StringBuilder(bytes.length << 1);
        for(int i=0; i<bytes.length; ++i)
            sb.append(hex[(bytes[i] & 0xf0) >> 4])
                .append(hex[(bytes[i] & 0x0f)])
                ;
        return sb.toString();
    }

======= 345e6b5:"java/org/apache/jasper/compiler/JspDocumentParser.java"

======= 345e6b5:"java/org/apache/jasper/compiler/JspDocumentParser.java"

            fatalError(new EnableDTDValidationException(
                    "jsp.error.enable_dtd_validation", null));
======= 345e6b5:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        @Override
        public synchronized Throwable fillInStackTrace() {
            // This class does not provide a stack trace
            return this;
        }
======= 345e6b5:"java/org/apache/naming/resources/ImmutableNameNotFoundException.java"

    @Override
    public synchronized Throwable fillInStackTrace() {
        // This class does not provide a stack trace
        return this;
    }

======= 4117b78:"java/org/apache/catalina/Session.java"

     * Return the creation time for this session, bypassing the session validity
     * checks.
     */
    public long getCreationTimeInternal();
    /**
======= 4117b78:"java/org/apache/catalina/manager/DummyProxySession.java"

    public long getCreationTimeInternal() {
        return 0;
    }
    @Override
======= 4117b78:"java/org/apache/catalina/session/ManagerBase.java"

            int timeAlive =
                (int) (timeNow - session.getCreationTimeInternal())/1000;
======= 4117b78:"java/org/apache/catalina/session/StandardSession.java"

     * Return the time when this session was created, in milliseconds since
     * midnight, January 1, 1970 GMT, bypassing the session validation checks.
     */
    @Override
    public long getCreationTimeInternal() {
        return this.creationTime;
    }
    /**
      <fix>
        <bug>50448</bug>: Fix possible <code>IllegalStateException</code>
        caused by recent session management refactoring. (markt)
      </fix>

======= 4ed7b7e:"java/javax/el/CompositeELResolver.java"

======= 4ed7b7e:"java/javax/el/CompositeELResolver.java"

                if (resolvers[i] instanceof ScopedAttributeELResolver) {
                    // Special case since this will always return Object.class
                    Object value =
                        resolvers[i].getValue(context, base, property);
                    if (value != null) {
                        return value.getClass();
                    }
                }
======= 4ed7b7e:"java/javax/el/CompositeELResolver.java"

    public void testBug50408() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir =  new File("test/webapp-3.0");
        // app dir is relative to server home
        StandardContext ctxt = (StandardContext) tomcat.addWebapp(null,
                "/test", appDir.getAbsolutePath());
        
        // This test needs the JSTL libraries
        File lib = new File("webapps/examples/WEB-INF/lib");
        ctxt.setAliases("/WEB-INF/lib=" + lib.getCanonicalPath());
        
        tomcat.start();
        int rc = getUrl("http://localhost:" + getPort() +
                "/test/bug50408.jsp", new ByteChunk(), null);
        
        assertEquals(HttpServletResponse.SC_OK, rc);
    }
======= 4ed7b7e:"java/javax/el/CompositeELResolver.java"

 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <body>
    <c:forEach items="${pageContext.response.headerNames}" var="name">
      <c:forEach items="${pageContext.response.getHeaders(name)}" var="value">
        <p>${name} : ${value}</p>
      </c:forEach>
    </c:forEach>
  </body>
  <subsection name="Jasper">
    <changelog>
      <fix>
        <bug>50408</bug>: Fix <code>NoSuchMethodException</code> when using
        scoped variables with EL method invocation. (markt)
      </fix>
    </changelog>
  </subsection>

======= e34b164:"java/org/apache/catalina/connector/Connector.java"

======= e34b164:"java/org/apache/catalina/connector/Connector.java"

 * Implementation of a Coyote connector.
======= e34b164:"java/org/apache/catalina/connector/Connector.java"

    protected String parseBodyMethods = "POST";
    protected HashSet parseBodyMethodsSet;
======= e34b164:"java/org/apache/catalina/connector/Connector.java"

    public String getParseBodyMethods()
    {
        return (this.parseBodyMethods);
    }
    public void setParseBodyMethods(String methods)
    {
        HashSet methodSet = new HashSet();
        if(null != methods)
            methodSet.addAll(Arrays.asList(methods.split("\\s*,\\s*")));
        if(methodSet.contains("TRACE"))
            throw new IllegalArgumentException("TRACE method MUST NOT include an entity (see RFC 2616 Section 9.6)");
        this.parseBodyMethods = methods;
        this.parseBodyMethodsSet = methodSet;
    }
    public boolean isParseBodyMethod(String method)
    {
        return parseBodyMethodsSet.contains(method);
    }
======= e34b164:"java/org/apache/catalina/connector/Connector.java"

        // Make sure parseBodyMethodsSet has a default
        if(null == parseBodyMethodsSet)
            setParseBodyMethods(getParseBodyMethods());
======= e34b164:"java/org/apache/catalina/connector/Request.java"

        if(!getConnector().isParseBodyMethod(getMethod()))
======= e34b164:"test/org/apache/catalina/connector/TestRequest.java"

======= e34b164:"test/org/apache/catalina/connector/TestRequest.java"

    /**
     * Test case for https://issues.apache.org/bugzilla/show_bug.cgi?id=48692
     * PUT requests should be able to fetch request parameters coming from
     * the request body (when properly configured using the new parseBodyMethod
     * setting).
     */
    public void testBug48692() {
        Bug48692Client client = new Bug48692Client();
        client.setPort(getPort());
        // Make sure GET works properly
        client.doRequest("GET", "foo=bar", null, null, false);
        assertTrue("Non-200 response for GET request",
                   client.isResponse200());
        assertEquals("Incorrect response for GET request",
                     "foo=bar",
                     client.getResponseBody());
        client.reset();
        //
        // Make sure POST works properly
        //
        // POST with separate GET and POST parameters
        client.doRequest("POST", "foo=bar", "application/x-www-form-urlencoded", "bar=baz", true);
        assertTrue("Non-200 response for POST request",
                   client.isResponse200());
        assertEquals("Incorrect response for POST request",
                     "bar=baz,foo=bar",
                     client.getResponseBody());
        client.reset();
        // POST with overlapping GET and POST parameters
        client.doRequest("POST", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", true);
        assertTrue("Non-200 response for POST request",
                   client.isResponse200());
        assertEquals("Incorrect response for POST request",
                     "bar=baz,bar=foo,foo=bar,foo=baz",
                     client.getResponseBody());
        client.reset();
        // PUT without POST-style parsing
        client.doRequest("PUT", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", false);
        assertTrue("Non-200 response for PUT/noparse request",
                   client.isResponse200());
        assertEquals("Incorrect response for PUT request",
                     "bar=foo,foo=bar",
                     client.getResponseBody());
        client.reset();
        // PUT with POST-style parsing
        client.doRequest("PUT", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", true);
        assertTrue("Non-200 response for PUT request",
                   client.isResponse200());
        assertEquals("Incorrect response for PUT/parse request",
                     "bar=baz,bar=foo,foo=bar,foo=baz",
                     client.getResponseBody());
        client.reset();
        /*
        private Exception doRequest(String method,
                                    String queryString,
                                    String contentType,
                                    String requestBody,
                                    boolean allowBody) {
        */
    }
    /**
     *
     */
    private static class EchoParametersServlet extends HttpServlet {
        
        private static final long serialVersionUID = 1L;
        /**
         * Only interested in the parameters and values for requests.
         * Note: echos parameters in alphabetical order.
         */
        @Override
        protected void service(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
            // Just echo the parameters and values back as plain text
            resp.setContentType("text/plain");
            resp.setCharacterEncoding("UTF-8");
            PrintWriter out = resp.getWriter();
            
            TreeMap<String,String[]> parameters = new TreeMap<String,String[]>(req.getParameterMap());
            boolean first = true;
            
            for(String name: parameters.keySet()) {
                String[] values = req.getParameterValues(name);
                java.util.Arrays.sort(values);
                for(int i=0; i<values.length; ++i)
                {
                    if(first)
                        first = false;
                    else
                        out.print(",");
                    out.print(name + "=" + values[i]);
                }
            }
        }
    }
    /**
     * Bug 48692 test client: test for allowing PUT request bodies.
     */
    private class Bug48692Client extends SimpleHttpClient {
        private boolean init;
        
        private synchronized void init() throws Exception {
            if (init) return;
            
            Tomcat tomcat = getTomcatInstance();
            Context root = tomcat.addContext("", TEMP_DIR);
            Tomcat.addServlet(root, "EchoParameters", new EchoParametersServlet());
            root.addServletMapping("/echo", "EchoParameters");
            tomcat.start();
            
            init = true;
        }
        
        private Exception doRequest(String method,
                                    String queryString,
                                    String contentType,
                                    String requestBody,
                                    boolean allowBody) {
            Tomcat tomcat = getTomcatInstance();
            
            try {
                init();
                if(allowBody)
                    tomcat.getConnector().setParseBodyMethods(method);
                else
                    tomcat.getConnector().setParseBodyMethods(""); // never parse
                // Open connection
                connect();
                // Re-encode the request body so that bytes = characters
                if(null != requestBody)
                    requestBody = new String(requestBody.getBytes("UTF-8"), "ASCII");
                // Send specified request body using method
                String[] request = {
                    (
                     method + " http://localhost:" + getPort() + "/echo"
                     + (null == queryString ? "" : ("?" + queryString))
                     + " HTTP/1.1" + CRLF
                     + "Host: localhost" + CRLF
                     + (null == contentType ? ""
                        : ("Content-Type: " + contentType + CRLF))
                     + "Connection: close" + CRLF
                     + (null == requestBody ? "" : "Content-Length: " + requestBody.length() + CRLF)
                     + CRLF
                     + (null == requestBody ? "" : requestBody)
                     )
                };
                setRequest(request);
                processRequest(); // blocks until response has been read
                
                // Close the connection
                disconnect();
            } catch (Exception e) {
                return e;
            }
            return null;
        }
        @Override
        public boolean isResponseBodyOK() {
            return false; // Don't care
        }
    }
    <author email="schultz@apache.org">Christopher Schultz</author>
      <update>
        <bug>48692</bug>: Provide option to parse
        <code>application/x-www-form-urlencoded</code> PUT requests. (schultz)
      </update>
    <attribute name="parseBodyMethods" required="false">
      <p>A comma-separated list of HTTP methods for which request
      bodies will be parsed for request parameters identically
      to POST. This is useful in RESTful applications that want to
      support POST-style semantics for PUT requests.
      Note that any setting other than <code>POST</code> causes Tomcat
      to behave in a way that violates the servlet specification.
      The HTTP method TRACE is specifically forbidden here in accordance
      with the HTTP specification.
      The default is <code>POST</code></p>
    </attribute>
    <attribute name="parseBodyMethods" required="false">
      <p>A comma-separated list of HTTP methods for which request
      bodies will be parsed for request parameters identically
      to POST. This is useful in RESTful applications that want to
      support POST-style semantics for PUT requests.
      Note that any setting other than <code>POST</code> causes Tomcat
      to behave in a way that violates the servlet specification.
      The HTTP method TRACE is specifically forbidden here in accordance
      with the HTTP specification.
      The default is <code>POST</code></p>
    </attribute>

======= 07b72f1:"java/org/apache/catalina/startup/Embedded.java"

        setState(LifecycleState.STOPPING);
      <fix>
        <bug>50358</bug>: Set the correct LifecycleState when stopping instances
        of the deprecated Embedded class. (markt) 
      </fix>

======= 4cbb52f:"java/javax/servlet/GenericServlet.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/ServletContextAttributeEvent.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/ServletContextEvent.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/ServletException.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/ServletRequestAttributeEvent.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/ServletRequestEvent.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/UnavailableException.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/http/HttpServlet.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/http/HttpSessionBindingEvent.java"

    private static final long serialVersionUID = 1L;
    /* The name to which the object is being bound or unbound */
======= 4cbb52f:"java/javax/servlet/http/HttpSessionEvent.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/jsp/JspException.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/jsp/JspTagException.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/jsp/SkipPageException.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/jsp/el/ELException.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/jsp/el/ELParseException.java"

 private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/javax/servlet/jsp/tagext/TagSupport.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/ha/deploy/FileMessage.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/ha/deploy/UndeployMessage.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/manager/StatusManagerServlet.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/session/StandardSession.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/ssi/SSIServlet.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/ssi/SSIStopProcessingException.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/tribes/ChannelException.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/tribes/RemoteProcessException.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/tribes/UniqueId.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/tribes/io/ChannelData.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/tribes/tipis/ReplicatedMap.java"

    private static final long serialVersionUID = 1L;
    //--------------------------------------------------------------------------
    //              CONSTRUCTORS / DESTRUCTORS
    //--------------------------------------------------------------------------
======= 4cbb52f:"java/org/apache/catalina/tribes/util/ExecutorFactory.java"

        private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/catalina/util/ParameterMap.java"

    private static final long serialVersionUID = 1L;
    // ----------------------------------------------------------- Constructors
======= 4cbb52f:"java/org/apache/catalina/util/ResourceSet.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/jasper/JasperException.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/jasper/compiler/JspDocumentParser.java"

            extends SAXParseException {
        private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/jasper/runtime/HttpJspBase.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/juli/logging/LogConfigurationException.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/naming/EjbRef.java"

    private static final long serialVersionUID = 1L;
    
======= 4cbb52f:"java/org/apache/naming/HandlerRef.java"

    private static final long serialVersionUID = 1L;
    
======= 4cbb52f:"java/org/apache/naming/JndiPermission.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/naming/ResourceEnvRef.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/naming/ResourceLinkRef.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/naming/ServiceRef.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/naming/TransactionRef.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/tomcat/util/buf/CharChunk.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/tomcat/util/buf/MessageBytes.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/tomcat/util/modeler/BaseAttributeFilter.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/tomcat/util/modeler/FixedNotificationFilter.java"

    private static final long serialVersionUID = 1L;
======= 4cbb52f:"java/org/apache/tomcat/util/modeler/ManagedBean.java"

    private static final long serialVersionUID = 1L;
    
======= 4cbb52f:"java/org/apache/tomcat/util/net/URL.java"

    private static final long serialVersionUID = 1L;
    
======= 4cbb52f:"test/org/apache/catalina/tribes/demos/MapDemo.java"

    public static class SimpleTableDemo extends JPanel
            implements ActionListener {
        private static final long serialVersionUID = 1L;
======= 4cbb52f:"test/org/apache/catalina/tribes/demos/MapDemo.java"

            private static final long serialVersionUID = 1L;
======= 4cbb52f:"test/org/apache/catalina/tribes/demos/MapDemo.java"

        private static final long serialVersionUID = 1L;
======= 4cbb52f:"webapps/examples/WEB-INF/jsp/applet/Clock2.java"

    private static final long serialVersionUID = 1L;

======= ddbbfc1:"java/org/apache/catalina/loader/WebappClassLoader.java"

                if (ccl == this) {
======= ddbbfc1:"java/org/apache/catalina/loader/WebappClassLoader.java"

                        if (this.equals(key) ||
                                isLoadedByThisWebAppClassLoader(key)) {
======= ddbbfc1:"java/org/apache/catalina/loader/WebappClassLoader.java"

                        if (this.equals(value) ||
                                isLoadedByThisWebAppClassLoader(value)) {
                                args[1] = getPrettyClassName(key.getClass());
======= ddbbfc1:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                args[3] = getPrettyClassName(value.getClass());
======= ddbbfc1:"java/org/apache/catalina/loader/WebappClassLoader.java"

    private String getPrettyClassName(Class<?> clazz) {
        String name = clazz.getCanonicalName();
        if (name==null){
            name = clazz.getName();
        }
        return name;
    }
    
    /**
     * @param o object to test
     * @return <code>true</code> if o has been loaded by the current classloader
     * or one of its descendants.
     */
    private boolean isLoadedByThisWebAppClassLoader(Object o) {
        if (o == null) {
            return false;
        }
        ClassLoader cl = o.getClass().getClassLoader();
        while (cl != null) {
            if(cl == this) {
                return true;
            }
            cl = cl.getParent();
        }
        return false;
    }
        
      <add>
        <bug>48837</bug>: Extend thread local memory leak detection to include
        classes loaded by subordinate class loaders to the web
        application&apos;s class loader such as the Jasper class loader. Based
        on a patch by Sylvain Laurent. (markt)
      </add>

======= 5a84fdb:"java/org/apache/coyote/ajp/AbstractAjpProtocol.java"

    public int getMinSpareThreads() { return endpoint.getMinSpareThreads(); }
    public void setMinSpareThreads(int minSpareThreads) { endpoint.setMinSpareThreads(minSpareThreads); }
======= 5a84fdb:"java/org/apache/coyote/http11/AbstractHttp11Protocol.java"

    public int getMinSpareThreads() { return endpoint.getMinSpareThreads(); }
    public void setMinSpareThreads(int minSpareThreads) { endpoint.setMinSpareThreads(minSpareThreads); }
  <subsection name="Coyote">
    <changelog>
      <add>
        <bug>50108</bug>: Add get/set methods for Connector property
        minSpareThreads. Patch provided by Eiji Takahashi. (markt)
      </add>
    </changelog>
  </subsection>

======= 46e7d1e:"java/org/apache/coyote/http11/Http11NioProtocol.java"

                    if (state == SocketState.OPEN || state == SocketState.CLOSED) {
                        if (processor.isAsync()) {
                            att.setAsync(true); // Re-enable timeouts
                        } else {
                            // Comet
                            if (log.isDebugEnabled()) log.debug("Keeping processor["+processor);
                            //add correct poller events here based on Comet stuff
                            socket.getPoller().add(socket,att.getCometOps());
                        }
                        // state == SocketState.ASYNC_END
                        // No further work required
======= 46e7d1e:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                    } else if ((ka.interestOps()&SelectionKey.OP_READ) == SelectionKey.OP_READ ||
======= 46e7d1e:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                    } else if (ka.isAsync() || ka.getComet()) {
      <fix>
        <bug>50207</bug>: Ensure Comet timeout events are triggered. This bug
        was a regression triggered by the fix for <bug>49884</bug>. (markt)
      </fix>

======= 278a36a:"java/org/apache/catalina/manager/JspHelper.java"

        if (in_seconds < 0) {
            buff.append('-');
            in_seconds = -in_seconds;
        }
======= 278a36a:"java/org/apache/catalina/manager/StatusTransformer.java"

            StringBuilder buff = new StringBuilder();
            if (bytes < 0) {
                buff.append('-');
                bytes = -bytes;
            }
            buff.append(mbytes).append('.');
            if (rest < 10) {
                buff.append('0');
            }
            buff.append(rest).append(" MB");
            return buff.toString();
      <fix>
        <bug>50316</bug>: Fix display of negative values in Manager application.
        (kkolinko)
      </fix>

======= 991702c:"java/org/apache/coyote/AsyncStateMachine.java"

        } else if (state == AsyncState.STARTED ||
                state == AsyncState.TIMING_OUT) {
======= 991702c:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        doTestTimeout(true, null);
        doTestTimeout(false, null);
    }
    public void testTimeoutListenerDispatch() throws Exception {
        doTestTimeout(true, "/nonasync");
    private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl)
    throws Exception {
======= 991702c:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TimeoutServlet timeout =
            new TimeoutServlet(completeOnTimeout, dispatchUrl);
        if (dispatchUrl != null) {
            NonAsyncServlet nonAsync = new NonAsyncServlet();
            Tomcat.addServlet(ctx, "nonasync", nonAsync);
            ctx.addServletMapping(dispatchUrl, "nonasync");
        }
======= 991702c:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        if (dispatchUrl == null) {
            expected.append("onComplete-");
        } else {
            expected.append("NonAsyncServletGet-");
        }
======= 991702c:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        private String dispatchUrl;
        public TimeoutServlet(boolean completeOnTimeout, String dispatchUrl) {
            this.dispatchUrl = dispatchUrl;
======= 991702c:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                ac.addListener(new TrackingListener(
                        false, completeOnTimeout, dispatchUrl));
======= 991702c:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                    new TrackingListener(completeOnError, true, null); 
======= 991702c:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        TimeoutServlet timeout = new TimeoutServlet(true, null);
======= 991702c:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

            TrackingListener listener = new TrackingListener(false, true, null); 
======= 991702c:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        private String dispatchUrl;
                boolean completeOnTimeout, String dispatchUrl) {
            this.dispatchUrl = dispatchUrl;
======= 991702c:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                if (dispatchUrl == null) {
                    event.getAsyncContext().complete();
                } else {
                    event.getAsyncContext().dispatch(dispatchUrl);
                }
      <fix>
        <bug>50308</bug>: Allow asynchronous request processing to call
        <code>AsyncContext.dispatch()</code> once the asynchronous request has
        timed out. (markt)
      </fix>

======= ade20d2:"java/org/apache/catalina/core/StandardWrapper.java"

        StringBuilder keyProperties = new StringBuilder(",WebModule=//");
      <fix>
        <bug>50310</bug>: Fix display of Servlet information in Manager
        application. (markt)
      </fix>

======= 7b89af8:"java/javax/el/CompositeELResolver.java"

        this.resolvers = new ELResolver[8];
      <fix>
        <bug>50293</bug>: Increase the size of internal ELResolver array from 2 
        to 8 since in typical usage there are at least 5 resolvers. Based on a
        patch by Robert Goff. (markt)
      </fix>

======= e075c4b:"java/org/apache/jasper/el/ELContextImpl.java"

======= e075c4b:"java/org/apache/jasper/el/ELContextImpl.java"

    private FunctionMapper functionMapper = NullFunctionMapper;
======= e075c4b:"java/org/apache/jasper/el/ELResolverImpl.java"

    private final static ELResolver DefaultResolver;
        if (Constants.IS_SECURITY_ENABLED) {
            DefaultResolver = null;
        } else {
            DefaultResolver = new CompositeELResolver();
            ((CompositeELResolver) DefaultResolver).add(new MapELResolver());
            ((CompositeELResolver) DefaultResolver).add(new ResourceBundleELResolver());
            ((CompositeELResolver) DefaultResolver).add(new ListELResolver());
            ((CompositeELResolver) DefaultResolver).add(new ArrayELResolver());
            ((CompositeELResolver) DefaultResolver).add(new BeanELResolver());
        }
    private final ELResolver elResolver;
        this.elResolver = getDefaultResolver();
======= e075c4b:"java/org/apache/jasper/el/ELResolverImpl.java"

            return elResolver.getValue(context, base, property);
======= e075c4b:"java/org/apache/jasper/el/ELResolverImpl.java"

            return elResolver.getType(context, base, property);
======= e075c4b:"java/org/apache/jasper/el/ELResolverImpl.java"

            elResolver.setValue(context, base, property, value);
======= e075c4b:"java/org/apache/jasper/el/ELResolverImpl.java"

        return elResolver.isReadOnly(context, base, property);
        return elResolver.getFeatureDescriptors(context, base);
======= e075c4b:"java/org/apache/jasper/el/ELResolverImpl.java"

        return elResolver.getCommonPropertyType(context, base);
      <fix>
        <bug>50192</bug>: Improve performance for EL when running under a
        security manager. Based on a patch by Robert Goff. (markt) 
      </fix>

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Interface implemented by session managers that do not keep a complete copy
 * of all sessions on the local node but do know where every session is. The
 * BackupManager is an example of such a Manager. Sessions can be primary
 * (master copy on this node), backup (backup copy on this node) or proxy (only
 * the session ID on this node). The identity of the primary and backup nodes
 * are known for all sessions, including proxy sessions.
 */
    /**
     * Returns the total session count for primary, backup and proxy.
     * 
     * @return  The total session count across the cluster.
     */
    public int getActiveSessionsFull();
    /**
     * Returns the list of all sessions IDS (primary, backup and proxy).
     * 
     * @return  The complete set of sessions IDs across the cluster.
     */
    public Set<String> getSessionIdsFull();
======= 96020cb:"java/org/apache/catalina/ha/session/BackupManager.java"

======= 96020cb:"java/org/apache/catalina/ha/session/BackupManager.java"

        implements MapOwner, DistributedManager {
======= 96020cb:"java/org/apache/catalina/ha/session/BackupManager.java"

    @Override
    @Override
======= 96020cb:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= 96020cb:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                if (manager instanceof DistributedManager && showProxySessions) {
                            ((DistributedManager)manager).getActiveSessionsFull());
======= 96020cb:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        if (manager instanceof DistributedManager && showProxySessions) {
                ((DistributedManager) manager).getSessionIdsFull();
      <fix>
        <bug>50230</bug>: Add new DistributedManager interface that is
        implemented by the Backup Manager to remove circular dependency between
        tomcat-catalina-ha and tomcat-catalina modules. Also allows third-party
        distributed Manager implementations to report full session information
        through the HTML Manager. (markt)
      </fix>

======= 7e7283d:"java/org/apache/naming/NamingContext.java"

                    if(entry.value instanceof ResourceRef) {
                        boolean singleton = Boolean.parseBoolean(
                                    (String) ((ResourceRef) entry.value).get(
                                        "singleton").getContent());
                        if (singleton) {
                            entry.type = NamingEntry.ENTRY;
                            entry.value = obj;
                        }
      <fix>
        <bug>50252</bug>: Prevent ClassCastException when using a
        &lt;ResourceLink&gt;. Patch provided by Eiji Takahashi. (markt)
      </fix>

======= 84efb0a:"java/org/apache/catalina/tribes/transport/bio/BioReceiver.java"

            getExecutor().execute(task);
======= 84efb0a:"java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java"

            log.error("Unable to service bio socket", x);
======= 84efb0a:"java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java"

        <bug>50183</bug>: BIO sender was not scheduling tasks to the executor
        during normal operation. Patch provided by Ariel. (markt)
      </fix>
      <fix>
        (markt)

======= 476921f:"java/org/apache/catalina/core/StandardContext.java"

        if(this.getState().equals(LifecycleState.STARTED))
            fireContainerEvent(ADD_WELCOME_FILE_EVENT, name);
======= 476921f:"java/org/apache/catalina/core/StandardContext.java"

        if(this.getState().equals(LifecycleState.STARTED))
            fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name);
======= 476921f:"java/org/apache/catalina/core/StandardWrapper.java"

======= 476921f:"java/org/apache/catalina/core/StandardWrapper.java"

        if(parent.getState().equals(LifecycleState.STARTED))
            fireContainerEvent(ADD_MAPPING_EVENT, mapping);
======= 476921f:"java/org/apache/catalina/core/StandardWrapper.java"

        if(parent.getState().equals(LifecycleState.STARTED))
            fireContainerEvent(REMOVE_MAPPING_EVENT, mapping);
      <fix>
        <bug>50169</bug>: Ensure that when a Container is started that it
        doesn&apos;t try and register with the mapper unless its parent has
        already started. Patch provided by Eiji Takahashi. (markt)
      </fix>

======= 4ca3db3:"java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java"

            ClassLoader loader = Thread.currentThread().getContextClassLoader();
            try
            {
                // Use the system classloader as the victim for all this
                // ClassLoader pinning we're about to do.
                Thread.currentThread().setContextClassLoader(
                        ClassLoader.getSystemClassLoader());
                /*
                 * Several components end up calling:
                 * sun.awt.AppContext.getAppContext()
                 * 
                 * Those libraries / components known to trigger memory leaks
                 * due to eventual calls to getAppContext() are:
                 * - Google Web Toolkit via its use of javax.imageio
                 * - Tomcat via its use of java.beans.Introspector.flushCaches()
                 *   in 1.6.0_15 onwards
                 * - others TBD
                 */
                
                // Trigger a call to sun.awt.AppContext.getAppContext(). This
                // will pin the system class loader in memory but that shouldn't
                // be an issue.
                if (appContextProtection) {
                    ImageIO.getCacheDirectory();
                }
                
                /*
                 * Several components end up calling:
                 * sun.misc.GC.requestLatency(long)
                 * 
                 * Those libraries / components known to trigger memory leaks
                 * due to eventual calls to requestLatency(long) are:
                 * - javax.management.remote.rmi.RMIConnectorServer.start()
                 */
                if (gcDaemonProtection) {
                    try {
                        Class<?> clazz = Class.forName("sun.misc.GC");
                        Method method = clazz.getDeclaredMethod(
                                "requestLatency",
                                new Class[] {long.class});
                        method.invoke(null, Long.valueOf(3600000));
                    } catch (ClassNotFoundException e) {
                        if (System.getProperty("java.vendor").startsWith(
                                "Sun")) {
                            log.error(sm.getString(
                                    "jreLeakListener.gcDaemonFail"), e);
                        } else {
                            log.debug(sm.getString(
                                    "jreLeakListener.gcDaemonFail"), e);
                        }
                    } catch (SecurityException e) {
                        log.error(sm.getString("jreLeakListener.gcDaemonFail"),
                                e);
                    } catch (NoSuchMethodException e) {
                        log.error(sm.getString("jreLeakListener.gcDaemonFail"),
                                e);
                    } catch (IllegalArgumentException e) {
                        log.error(sm.getString("jreLeakListener.gcDaemonFail"),
                                e);
                    } catch (IllegalAccessException e) {
                        log.error(sm.getString("jreLeakListener.gcDaemonFail"),
                                e);
                    } catch (InvocationTargetException e) {
                        log.error(sm.getString("jreLeakListener.gcDaemonFail"),
                                e);
    
                /*
                 * When a servlet opens a connection using a URL it will use
                 * sun.net.www.http.HttpClient which keeps a static reference to
                 * a keep-alive cache which is loaded using the web application
                 * class loader.
                 */
                if (keepAliveProtection) {
                    try {
                        Class.forName("sun.net.www.http.HttpClient");
                    } catch (ClassNotFoundException e) {
                        if (System.getProperty("java.vendor").startsWith(
                                "Sun")) {
                            log.error(sm.getString(
                                    "jreLeakListener.keepAliveFail"), e);
                        } else {
                            log.debug(sm.getString(
                                    "jreLeakListener.keepAliveFail"), e);
                        }
                
                /*
                 * Calling getPolicy retains a static reference to the context 
                 * class loader.
                 */
                if (securityPolicyProtection) {
                    try {
                        // Policy.getPolicy();
                        Class<?> policyClass = Class
                                .forName("javax.security.auth.Policy");
                        Method method = policyClass.getMethod("getPolicy");
                        method.invoke(null);
                    } catch(ClassNotFoundException e) {
                        // Ignore. The class is deprecated.
                    } catch(SecurityException e) {
                        // Ignore. Don't need call to getPolicy() to be
                        // successful, just need to trigger static initializer.
                    } catch (NoSuchMethodException e) {
                        log.warn(sm.getString("jreLeakListener.authPolicyFail"),
                                e);
                    } catch (IllegalArgumentException e) {
                        log.warn(sm.getString("jreLeakListener.authPolicyFail"),
                                e);
                    } catch (IllegalAccessException e) {
                        log.warn(sm.getString("jreLeakListener.authPolicyFail"),
                                e);
                    } catch (InvocationTargetException e) {
                        log.warn(sm.getString("jreLeakListener.authPolicyFail"),
                                e);
                    }
    
                /*
                 * Creating a MessageDigest during web application startup
                 * initializes the Java Cryptography Architecture. Under certain
                 * conditions this starts a Token poller thread with TCCL equal
                 * to the web application class loader.
                 * 
                 * Instead we initialize JCA right now.
                 */
                if (tokenPollerProtection) {
                    java.security.Security.getProviders();
                
                /*
                 * Several components end up opening JarURLConnections without
                 * first disabling caching. This effectively locks the file.
                 * Whilst more noticeable and harder to ignore on Windows, it
                 * affects all operating systems.
                 * 
                 * Those libraries/components known to trigger this issue
                 * include:
                 * - log4j versions 1.2.15 and earlier
                 * - javax.xml.bind.JAXBContext.newInstance()
                 */
                
                // Set the default URL caching policy to not to cache
                if (urlCacheProtection) {
                    try {
                        // Doesn't matter that this JAR doesn't exist - just as
                        // long as the URL is well-formed
                        URL url = new URL("jar:file://dummy.jar!/");
                        URLConnection uConn = url.openConnection();
                        uConn.setDefaultUseCaches(false);
                    } catch (MalformedURLException e) {
                        log.error(sm.getString(
                                "jreLeakListener.jarUrlConnCacheFail"), e);
                    } catch (IOException e) {
                        log.error(sm.getString(
                                "jreLeakListener.jarUrlConnCacheFail"), e);
                    }
                
                /*
                 * Haven't got to the root of what is going on with this leak
                 * but if a web app is the first to make the calls below the web
                 * application class loader will be pinned in memory.
                 */
                if (xmlParsingProtection) {
                    DocumentBuilderFactory factory =
                        DocumentBuilderFactory.newInstance();
                    try {
                        factory.newDocumentBuilder();
                    } catch (ParserConfigurationException e) {
                        log.error(sm.getString("jreLeakListener.xmlParseFail"),
                                e);
                    }
                }
            } finally {
                Thread.currentThread().setContextClassLoader(loader);
      <add>
        <bug>50222</bug>: Modify memory leak prevention code so it pins the
        system class loader in memory rather than than the common class loader,
        which is better for embedded systems. Patch provided by Christopher
        Schultz. (markt) 
      </add>

======= afdc055:"java/org/apache/catalina/tribes/group/RpcChannel.java"

    private int replyMessageOptions = 0;
======= afdc055:"java/org/apache/catalina/tribes/group/RpcChannel.java"

                channel.send(new Member[] {sender}, rmsg,
                        replyMessageOptions & ~Channel.SEND_OPTIONS_SYNCHRONIZED_ACK);
======= afdc055:"java/org/apache/catalina/tribes/group/RpcChannel.java"

    public int getReplyMessageOptions() {
        return replyMessageOptions;
    }
    public void setReplyMessageOptions(int replyMessageOptions) {
        this.replyMessageOptions = replyMessageOptions;
    }
        
      <fix>
        <bug>50184</bug>: Add an option to the RpcChannel to enable the Channel
        send options to be set for the reply message. Based on a patch by Ariel.
        (markt))
      </fix>

======= b5c24f9:"java/org/apache/catalina/session/StoreBase.java"

                boolean isLoaded = false;
                try {
                    if (manager.findSession(keys[i]) != null) {
                        isLoaded = true;
                    }
                } catch (IOException ioe) {
                    // Ignore - session will be expired
                }
                if (isLoaded) {
      <fix>
        <bug>50232</bug>: Remove dependency between StoreBase and
        PersistentManager and associated code clean-up. Patch provided by
        Tiago Batista. (markt)
      </fix>

======= 6eae969:"java/org/apache/catalina/Lifecycle.java"

 * |  |       FAILED ---->------ DESTROYING ---<-----------------  |
 * |  |                           ^     |                          |
 * |  |        destroy()          |     |auto                      |
 * |  -----------------------------    \|/                         |
 * |                                 DESTROYED                     |
======= 6eae969:"java/org/apache/catalina/Lifecycle.java"

     * The LifecycleEvent type for the "component after destroy" event.
    public static final String AFTER_DESTROY_EVENT = "after_destroy";
    /**
     * The LifecycleEvent type for the "component before destroy" event.
     */
    public static final String BEFORE_DESTROY_EVENT = "before_destroy";
======= 6eae969:"java/org/apache/catalina/LifecycleState.java"

    DESTROYING(false, Lifecycle.BEFORE_DESTROY_EVENT),
    DESTROYED(false, Lifecycle.AFTER_DESTROY_EVENT),
======= 6eae969:"java/org/apache/catalina/core/AprLifecycleListener.java"

        } else if (Lifecycle.AFTER_DESTROY_EVENT.equals(event.getType())) {
======= 6eae969:"java/org/apache/catalina/core/ContainerBase.java"

            // child.destroy() may have already been called which would have
            // triggered this call. If that is the case, no need to destroy the
            // child again.
            if (!LifecycleState.DESTROYING.equals(child.getState())) {
                child.destroy();
            }
======= 6eae969:"java/org/apache/catalina/startup/ContextConfig.java"

        } else if (event.getType().equals(Lifecycle.AFTER_DESTROY_EVENT)) {
======= 6eae969:"java/org/apache/catalina/util/LifecycleBase.java"

        if (LifecycleState.DESTROYING.equals(state) ||
                LifecycleState.DESTROYED.equals(state)) {
======= 6eae969:"java/org/apache/catalina/util/LifecycleBase.java"

            invalidTransition(Lifecycle.BEFORE_DESTROY_EVENT);
        setState(LifecycleState.DESTROYING);
        
      <fix>
        <bug>50168</bug>: Separate the <code>Lifecycle.DESTROY_EVENT</code> into
        <code>Lifecycle.BEFORE_DESTROY_EVENT</code> and
        <code>Lifecycle.AFTER_DESTROY_EVENT</code>. Use the additional state to
        ensure that <code>Context</code> objects are only destroyed once.
        (markt)
      </fix>

======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

        // NO-OP
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    public void setManagerClassName(
            @SuppressWarnings("unused") String managerClassName) {
        log.warn("setManagerClassName is deprecated, use nested <Manager> " +
                 "element inside the <Cluster> element instead, this request " +
                 "will be ignored.");
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

                    valve.setCluster(this);
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

                IntrospectionUtils.callMethodN(getContainer(), "removeValve",
                    new Object[] { valve },
                    new Class[] { org.apache.catalina.Valve.class });
                valve.setCluster(this);
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

            for (Iterator<ClusterListener> iter = clusterListeners.iterator();
                    iter.hasNext();) {
            if (!accepted && notifyLifecycleListenerOnFailure) {
                if (log.isDebugEnabled()) {
                    log.debug("Message " + message.toString() + " from type "
                            + message.getClass().getName()
                            + " transfered but no listener registered");
                }
    @Override
======= f77368f:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Override
        // NO-OP
    @Override

======= 7184011:"java/org/apache/juli/FileHandler.java"

     * Determines whether the logfile is rotatable
     */
    private boolean rotatable = true;
    /**
======= 7184011:"java/org/apache/juli/FileHandler.java"

        if (rotatable && !date.equals(tsDate)) {
======= 7184011:"java/org/apache/juli/FileHandler.java"

        rotatable = Boolean.parseBoolean(getProperty(className + ".rotatable", "true"));
======= 7184011:"java/org/apache/juli/FileHandler.java"

                prefix + (rotatable ? date : "") + suffix;

======= 53c5d85:"java/org/apache/catalina/connector/MapperListener.java"

        addListeners(engine);
======= 53c5d85:"java/org/apache/catalina/connector/MapperListener.java"

    @Override
            addListeners(child);
            // If child is started then it is too late for life-cycle listener
            // to register the child so register it here
            if (child.getState().isAvailable()) {
                if (child instanceof Host) {
                    registerHost((Host) child);
                } else if (child instanceof Context) {
                    registerContext((Context) child);
                } else if (child instanceof Wrapper) {
                    registerWrapper((Wrapper) child);
                }
            // No need to unregister - life-cycle listener will handle this when
            // the child stops
======= 53c5d85:"java/org/apache/catalina/connector/MapperListener.java"

                    defaultHost, connector));
======= 53c5d85:"java/org/apache/catalina/connector/MapperListener.java"

            log.debug(sm.getString("mapperListener.registerHost",
                    host.getName(), domain, connector));
======= 53c5d85:"java/org/apache/catalina/connector/MapperListener.java"

                    domain, connector));
======= 53c5d85:"java/org/apache/catalina/connector/MapperListener.java"

        String wrapperName = wrapper.getName();
======= 53c5d85:"java/org/apache/catalina/connector/MapperListener.java"

        
        if(log.isDebugEnabled()) {
            log.debug(sm.getString("mapperListener.unregisterWrapper",
                    wrapperName, contextName, connector));
        }
======= 53c5d85:"java/org/apache/catalina/connector/MapperListener.java"

            log.debug(sm.getString("mapperListener.registerContext",
                    contextName, connector));
======= 53c5d85:"java/org/apache/catalina/connector/MapperListener.java"

            log.debug(sm.getString("mapperListener.unregisterContext",
                    contextName, connector));
======= 53c5d85:"java/org/apache/catalina/connector/MapperListener.java"

                    wrapperName, contextName, connector));
======= 53c5d85:"java/org/apache/catalina/connector/MapperListener.java"

    /**
     * Add this mapper to the container and all child containers
     * 
     * @param container
     */
    private void addListeners(Container container) {
        container.addContainerListener(this);
        container.addLifecycleListener(this);
        for (Container child : container.findChildren()) {
            addListeners(child);
        }
    }
    <operation name="findContainerListenerNames"
               description="Return the set of container listener class names configured for this application."
               impact="INFO"
               returnType="[Ljava.lang.String;">    
    </operation>
    
    <operation name="findLifecycleListenerNames"
               description="Return the set of lifecycle listener class names configured for this application."
               impact="INFO"
               returnType="[Ljava.lang.String;">    
    </operation>
    
======= 53c5d85:"java/org/apache/catalina/mbeans/ContainerMBean.java"

======= 53c5d85:"java/org/apache/catalina/mbeans/ContainerMBean.java"

======= 53c5d85:"java/org/apache/catalina/mbeans/ContainerMBean.java"

    
    /**
     * List the class name of each of the lifecycle listeners added to this
     * container.
     */
    public String[] findLifecycleListenerNames() throws MBeanException {
        ContainerBase container = null;
        List<String> result = new ArrayList<String>();
        try {
            container = (ContainerBase) getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        LifecycleListener[] listeners = container.findLifecycleListeners();
        for(LifecycleListener listener: listeners){
            result.add(listener.getClass().getName());
        }
        return result.toArray(new String[result.size()]);
    }
    
    /**
     * List the class name of each of the container listeners added to this
     * container.
     */
    public String[] findContainerListenerNames() throws MBeanException {
        ContainerBase container = null;
        List<String> result = new ArrayList<String>();
        try {
            container = (ContainerBase) getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        ContainerListener[] listeners = container.findContainerListeners();
        for(ContainerListener listener: listeners){
            result.add(listener.getClass().getName());
        }
        return result.toArray(new String[result.size()]);
    }
      <fix>
        <bug>50157</bug>: Ensure MapperListener is only added to a container
        object once. (markt)
      </fix>
      <add>
        Improve debug logging for MapperListener registration. (markt)
      </add>
      <add>
        Expose names of LifecycleListeners and ContainerListers for
        StandardContext via JMX. (markt)
      </add>

======= 509ab5d:"java/org/apache/catalina/startup/ContextConfig.java"

        
        boolean isWebXMLservletDef;
        if (servletDef == null) {
            isWebXMLservletDef = false;
        } else {
            isWebXMLservletDef = true;
======= 509ab5d:"java/org/apache/catalina/startup/ContextConfig.java"

        if (urlPatterns != null) {
======= 509ab5d:"java/org/apache/catalina/startup/ContextConfig.java"

        boolean isWebXMLfilterDef;
        if (filterDef == null) {
            isWebXMLfilterDef = false;
        } else {
            isWebXMLfilterDef = true;
======= 509ab5d:"java/org/apache/catalina/startup/ContextConfig.java"

                urlPatternsSet = urlPatterns.length > 0;
======= 509ab5d:"java/org/apache/catalina/startup/ContextConfig.java"

                dispatchTypesSet = dispatcherTypes.length > 0;

======= 9d955f4:"java/org/apache/catalina/security/SecurityUtil.java"

======= 9d955f4:"java/org/apache/catalina/security/SecurityUtil.java"

    private static final Map<Object,Method[]> objectCache =
        new ConcurrentHashMap<Object,Method[]>();
======= 9d955f4:"java/org/apache/catalina/security/SecurityUtil.java"

        Method[] methodsCache = objectCache.get(targetObject);
        if(methodsCache == null) {
            method = createMethodAndCacheIt(methodsCache,
                                            methodName,
                                            targetObject,
                                            targetType);                     
        } else {
            if (method == null) {
======= 9d955f4:"java/org/apache/catalina/security/SecurityUtil.java"

        
        Method[] methodsCache = objectCache.get(targetObject);
        if(methodsCache == null) {
            method = createMethodAndCacheIt(methodsCache,
                                            methodName,
                                            targetObject,
                                            targetType);                     
        } else {
            if (method == null) {
======= 9d955f4:"java/org/apache/catalina/security/SecurityUtil.java"

                    @Override
      <fix>
        <bug>50138</bug>: Fix threading issues in
        <code>org.apache.catalina.security.SecurityUtil</code>. (markt)
      </fix>

======= 44f568f:"java/org/apache/catalina/mbeans/MBeanFactory.java"

            engine.removeChild(host);
  <subsection name="Catalina">
    <changelog>
      <fix>
        <bug>50107</bug>: When removing a Host via JMX, do not attempt to
        destroy the host&apos;s pipeline twice. Patch provided by Eiji
        Takahashi. (markt)
      </fix>
    </changelog>
  </subsection>
      <fix>
        <bug>50105</bug>: When processing composite EL expressions use
        <code>Enum.name()</code> rather than <code>Enum.toString()</code> as
        required by the EL specification. (markt)
      </fix>

======= e6c1d55:"java/org/apache/el/parser/AstCompositeExpression.java"

======= e6c1d55:"java/org/apache/el/parser/AstCompositeExpression.java"

                    sb.append(ELSupport.coerceToString(obj));
======= e6c1d55:"test/org/apache/el/TestValueExpressionImpl.java"

    public void testBug50105() {
        ExpressionFactory factory = ExpressionFactory.newInstance();
        ELContext context = new ELContextImpl();
        
        TesterEnum testEnum = TesterEnum.APPLE;
        
        ValueExpression var =
            factory.createValueExpression(testEnum, TesterEnum.class);
        context.getVariableMapper().setVariable("testEnum", var);
        // When coercing an Enum to a String, name() should always be used.
        ValueExpression ve1 = factory.createValueExpression(
                context, "${testEnum}", String.class);
        String result1 = (String) ve1.getValue(context);
        assertEquals("APPLE", result1);
        
        ValueExpression ve2 = factory.createValueExpression(
                context, "foo${testEnum}bar", String.class);
        String result2 = (String) ve2.getValue(context);
        assertEquals("fooAPPLEbar", result2);
    }
======= e6c1d55:"test/org/apache/el/TestValueExpressionImpl.java"

    APPLE, ORANGE;
    
    @Override
    public String toString() {
        return "This is a " + this.name();
    }
  <subsection name="Jasper">
    <changelog>
      <bug>50105</bug>: When processing composite EL expressions use
      <code>Enum.name()</code> rather than <code>Enum.toString()</code> as
      required by the EL specification. (markt)
    </changelog>
  </subsection>

======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        StringManager smClient = getStringManager(request);
        
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                doSessions(path, request, response, smClient);
                message = smClient.getString("managerServlet.exception",
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                smClient.getString("managerServlet.postCommand", command);
                smClient.getString("managerServlet.unknownCommand", command);
        list(request, response, message, smClient);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        StringManager smClient = getStringManager(request);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            message = upload(request, smClient);
            message = deployInternal(deployConfig, deployPath, deployWar,
                    smClient);
            message = reload(path, smClient);
            message = undeploy(path, smClient);
            message = expireSessions(path, request, smClient);
            message = start(path, smClient);
            message = stop(path, smClient);
            message = findleaks(smClient);
        list(request, response, message, smClient);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String upload(HttpServletRequest request, StringManager smClient)
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                    message = smClient.getString(
                            "htmlManagerServlet.deployUploadNoFile");
                    message = smClient.getString(
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                    message = smClient.getString(
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                    message = smClient.getString(
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            message = smClient.getString
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String deployInternal(String config, String path, String war,
            StringManager smClient) {
        super.deploy(printWriter, config, path, war, false, smClient);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                     String message,
                     StringManager smClient) throws IOException {
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[1] = smClient.getString("htmlManagerServlet.title");
        args[0] = smClient.getString("htmlManagerServlet.messageLabel");
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[0] = smClient.getString("htmlManagerServlet.manager");
        args[2] = smClient.getString("htmlManagerServlet.list");
             smClient.getString("htmlManagerServlet.helpHtmlManagerFile"));
        args[4] = smClient.getString("htmlManagerServlet.helpHtmlManager");
             smClient.getString("htmlManagerServlet.helpManagerFile"));
        args[6] = smClient.getString("htmlManagerServlet.helpManager");
        args[8] = smClient.getString("statusServlet.title");
        args[0] = smClient.getString("htmlManagerServlet.appsTitle");
        args[1] = smClient.getString("htmlManagerServlet.appsPath");
        args[2] = smClient.getString("htmlManagerServlet.appsName");
        args[3] = smClient.getString("htmlManagerServlet.appsAvailable");
        args[4] = smClient.getString("htmlManagerServlet.appsSessions");
        args[5] = smClient.getString("htmlManagerServlet.appsTasks");
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        String appsStart = smClient.getString("htmlManagerServlet.appsStart");
        String appsStop = smClient.getString("htmlManagerServlet.appsStop");
        String appsReload = smClient.getString("htmlManagerServlet.appsReload");
        String appsUndeploy = smClient.getString("htmlManagerServlet.appsUndeploy");
        String appsExpire = smClient.getString("htmlManagerServlet.appsExpire");
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args[10] = smClient.getString(
                        "htmlManagerServlet.expire.explain");
                    args[11] = smClient.getString(
                            "htmlManagerServlet.noManager");
                args[12] = smClient.getString("htmlManagerServlet.expire.unit");
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args[0] = smClient.getString("htmlManagerServlet.deployTitle");
        args[1] = smClient.getString("htmlManagerServlet.deployServer");
        args[3] = smClient.getString("htmlManagerServlet.deployPath");
        args[4] = smClient.getString("htmlManagerServlet.deployConfig");
        args[5] = smClient.getString("htmlManagerServlet.deployWar");
        args[6] = smClient.getString("htmlManagerServlet.deployButton");
        args[0] = smClient.getString("htmlManagerServlet.deployUpload");
        args[2] = smClient.getString("htmlManagerServlet.deployUploadFile");
        args[3] = smClient.getString("htmlManagerServlet.deployButton");
        args[0] = smClient.getString("htmlManagerServlet.diagnosticsTitle");
        args[1] = smClient.getString("htmlManagerServlet.diagnosticsLeak");
        args[3] = smClient.getString("htmlManagerServlet.diagnosticsLeakWarning");
        args[4] = smClient.getString("htmlManagerServlet.diagnosticsLeakButton");
        args[0] = smClient.getString("htmlManagerServlet.serverTitle");
        args[1] = smClient.getString("htmlManagerServlet.serverVersion");
        args[2] = smClient.getString("htmlManagerServlet.serverJVMVersion");
        args[3] = smClient.getString("htmlManagerServlet.serverJVMVendor");
        args[4] = smClient.getString("htmlManagerServlet.serverOSName");
        args[5] = smClient.getString("htmlManagerServlet.serverOSVersion");
        args[6] = smClient.getString("htmlManagerServlet.serverOSArch");
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String reload(String path, StringManager smClient) {
        super.reload(printWriter, path, smClient);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String undeploy(String path, StringManager smClient) {
        super.undeploy(printWriter, path, smClient);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    public String sessions(String path, int idle, StringManager smClient) {
        super.sessions(printWriter, path, idle, smClient);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    public String sessions(String path, StringManager smClient) {
        return sessions(path, -1, smClient);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    public String start(String path, StringManager smClient) {
        super.start(printWriter, path, smClient);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String stop(String path, StringManager smClient) {
        super.stop(printWriter, path, smClient);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String findleaks(StringManager smClient) {
        super.findleaks(printWriter, smClient);
            msg.append(smClient.getString("htmlManagerServlet.findleaksList"));
            msg.append(smClient.getString("htmlManagerServlet.findleaksNone"));
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected String expireSessions(String path, HttpServletRequest req,
            StringManager smClient) {
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        return sessions(path, idle, smClient);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected void doSessions(String path, HttpServletRequest req,
            HttpServletResponse resp, StringManager smClient)
            throws ServletException, IOException {
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            displaySessionDetailPage(req, resp, path, sessionId, smClient);
            int i = invalidateSessions(path, sessionIds, smClient);
            boolean removed =
                removeSessionAttribute(path, sessionId, name, smClient);
        displaySessionsListPage(path, req, resp, smClient);
    protected List<Session> getSessionsForPath(String path,
            StringManager smClient) {
            throw new IllegalArgumentException(smClient.getString(
                    "managerServlet.invalidPath", RequestUtil.filter(path)));
            throw new IllegalArgumentException(smClient.getString(
                    "managerServlet.noContext", RequestUtil.filter(path)));
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected Session getSessionForPathAndId(String path, String id,
            StringManager smClient) throws IOException {
            throw new IllegalArgumentException(smClient.getString(
                    "managerServlet.invalidPath", RequestUtil.filter(path)));
            throw new IllegalArgumentException(smClient.getString(
                    "managerServlet.noContext", RequestUtil.filter(path)));
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected void displaySessionsListPage(String path, HttpServletRequest req,
            HttpServletResponse resp, StringManager smClient)
            throws ServletException, IOException {
        List<Session> sessions = getSessionsForPath(path, smClient);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected void displaySessionDetailPage(HttpServletRequest req,
            HttpServletResponse resp, String path, String sessionId,
            StringManager smClient) throws ServletException, IOException {
        Session session = getSessionForPathAndId(path, sessionId, smClient);
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    public int invalidateSessions(String path, String[] sessionIds,
            StringManager smClient) throws IOException {
            HttpSession session = getSessionForPathAndId(path, sessionId, smClient).getSession();
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    public boolean removeSessionAttribute(String path, String sessionId,
            String attributeName, StringManager smClient) throws IOException {
        HttpSession session = getSessionForPathAndId(path, sessionId, smClient).getSession();
======= 7357867:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    public int setSessionMaxInactiveInterval(String path, String sessionId,
            int maxInactiveInterval, StringManager smClient) throws IOException {
        HttpSession session = getSessionForPathAndId(path, sessionId, smClient).getSession();
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

        StringManager smClient = getStringManager(request);
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString("managerServlet.noCommand"));
                deploy(writer, config, path, war, update, smClient);
                deploy(writer, path, tag, smClient);
            list(writer, smClient);
            reload(writer, path, smClient);
            resources(writer, type, smClient);
            roles(writer, smClient);
            save(writer, path, smClient);
            serverinfo(writer, smClient);
            expireSessions(writer, path, request, smClient);
            expireSessions(writer, path, request, smClient);
            start(writer, path, smClient);
            stop(writer, path, smClient);
            undeploy(writer, path, smClient);
            findleaks(writer, smClient);
            writer.println(smClient.getString("managerServlet.unknownCommand",
                    command));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

        StringManager smClient = getStringManager(request);
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString("managerServlet.noCommand"));
            deploy(writer, path, tag, update, request, smClient);
            writer.println(smClient.getString("managerServlet.unknownCommand",
                    command));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            throw new UnavailableException(
                    sm.getString("managerServlet.noWrapper"));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void findleaks(PrintWriter writer, StringManager smClient) {
            writer.println(smClient.getString("managerServlet.findleaksFail"));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected synchronized void save(PrintWriter writer, String path,
            StringManager smClient) {
            writer.println(smClient.getString("managerServlet.saveFail",
                    server));
                writer.println(smClient.getString("managerServlet.saved"));
                writer.println(smClient.getString("managerServlet.exception",
                        e.toString()));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(smClient.getString("managerServlet.noContext",
                        path));
                writer.println(smClient.getString("managerServlet.savedContext",
                        path));
                writer.println(smClient.getString("managerServlet.exception",
                        e.toString()));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

         String tag, boolean update, HttpServletRequest request,
         StringManager smClient) {
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString(
                    "managerServlet.invalidPath", path));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                undeploy(writer, displayPath, smClient);
            writer.println(smClient.getString("managerServlet.alreadyContext",
                    displayPath));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString("managerServlet.exception",
                    e.toString()));
            writer.println(smClient.getString(
                    "managerServlet.deployed", displayPath));
            writer.println(smClient.getString(
                    "managerServlet.deployFailed", displayPath));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void deploy(PrintWriter writer, String path, String tag,
            StringManager smClient) {
            writer.println(smClient.getString(
                    "managerServlet.invalidPath", path));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            undeploy(writer, displayPath, smClient);
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString("managerServlet.exception",
                    e.toString()));
            writer.println(smClient.getString("managerServlet.deployed",
                    displayPath));
            writer.println(smClient.getString("managerServlet.deployFailed",
                    displayPath));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            String path, String war, boolean update,  StringManager smClient) {
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString("managerServlet.invalidPath",
                    RequestUtil.filter(path)));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                undeploy(writer, displayPath, smClient);
            writer.println(smClient.getString("managerServlet.alreadyContext",
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(smClient.getString(
                        "managerServlet.deployed", displayPath));
                writer.println(smClient.getString(
                        "managerServlet.deployedButNotStarted", displayPath));
                writer.println(smClient.getString(
                        "managerServlet.deployFailed", displayPath));
            writer.println(smClient.getString("managerServlet.exception",
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void list(PrintWriter writer, StringManager smClient) {
        writer.println(smClient.getString("managerServlet.listed",
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                    writer.println(smClient.getString("managerServlet.listitem",
                            displayPath,
                            "running",
                            "" + context.getManager().findSessions().length,
                            context.getDocBase()));
                    writer.println(smClient.getString("managerServlet.listitem",
                            displayPath,
                            "stopped",
                            "0",
                            context.getDocBase()));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void reload(PrintWriter writer, String path,
            StringManager smClient) {
            writer.println(smClient.getString("managerServlet.invalidPath",
                    RequestUtil.filter(path)));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(smClient.getString("managerServlet.noContext",
                        RequestUtil.filter(displayPath)));
                writer.println(smClient.getString("managerServlet.noSelf"));
                (smClient.getString("managerServlet.reloaded", displayPath));
            writer.println(smClient.getString("managerServlet.exception",
                    t.toString()));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void resources(PrintWriter writer, String type,
            StringManager smClient) {
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString("managerServlet.noGlobal"));
            writer.println(smClient.getString("managerServlet.resourcesType",
                    type));
            writer.println(smClient.getString("managerServlet.resourcesAll"));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString("managerServlet.exception",
                    t.toString()));
        printResources(writer, "", global, type, clazz, smClient);
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                                  String type, Class<?> clazz,
                                  StringManager smClient) {
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                         (javax.naming.Context) item.getObject(), type, clazz,
                         smClient);
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString("managerServlet.exception",
                    t.toString()));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void roles(PrintWriter writer,  StringManager smClient) {
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString(
                    "managerServlet.userDatabaseError"));
            writer.println(smClient.getString(
                    "managerServlet.userDatabaseMissing"));
        writer.println(smClient.getString("managerServlet.rolesList"));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void serverinfo(PrintWriter writer,  StringManager smClient) {
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString("managerServlet.exception",
                    t.toString()));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void sessions(PrintWriter writer, String path, int idle,
            StringManager smClient) {
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString("managerServlet.invalidPath",
                    RequestUtil.filter(path)));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(smClient.getString("managerServlet.noContext",
                        RequestUtil.filter(displayPath)));
                writer.println(smClient.getString("managerServlet.noManager",
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString("managerServlet.sessions",
                    displayPath));
            writer.println(smClient.getString(
                    "managerServlet.sessiondefaultmax",
                    "" + maxInactiveInterval));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(smClient.getString(
                        "managerServlet.sessiontimeout",
                        "<" + histoInterval, "" + timeout[0]));
                    writer.println(smClient.getString(
                            "managerServlet.sessiontimeout",
                            "" + (i)*histoInterval + " - <" + (i+1)*histoInterval,
                            "" + timeout[i]));
                writer.println(smClient.getString(
                        "managerServlet.sessiontimeout",
                        ">=" + maxCount*histoInterval,
                        "" + timeout[maxCount-1]));
                writer.println(smClient.getString(
                        "managerServlet.sessiontimeout.unlimited",
                        "" + notimeout));
                writer.println(smClient.getString(
                        "managerServlet.sessiontimeout.expired",
                        "" + idle,"" + expired));
            writer.println(smClient.getString("managerServlet.exception",
                    t.toString()));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void sessions(PrintWriter writer, String path,
            StringManager smClient) {
        sessions(writer, path, -1, smClient);
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void expireSessions(PrintWriter writer, String path,
            HttpServletRequest req, StringManager smClient) {
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

        sessions(writer, path, idle, smClient);
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void start(PrintWriter writer, String path,
            StringManager smClient) {
            writer.println(smClient.getString("managerServlet.invalidPath",
                    RequestUtil.filter(path)));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(smClient.getString("managerServlet.noContext", 
                        RequestUtil.filter(displayPath)));
                writer.println(smClient.getString("managerServlet.started",
                        displayPath));
                writer.println(smClient.getString("managerServlet.startFailed",
                        displayPath));
            getServletContext().log(sm.getString("managerServlet.startFailed",
                    displayPath), t);
            writer.println(smClient.getString("managerServlet.startFailed",
                    displayPath));
            writer.println(smClient.getString("managerServlet.exception",
                    t.toString()));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void stop(PrintWriter writer, String path,
            StringManager smClient) {
            writer.println(smClient.getString("managerServlet.invalidPath",
                    RequestUtil.filter(path)));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(smClient.getString("managerServlet.noContext",
                        RequestUtil.filter(displayPath)));
                writer.println(smClient.getString("managerServlet.noSelf"));
            writer.println(smClient.getString(
                    "managerServlet.stopped", displayPath));
            writer.println(smClient.getString("managerServlet.exception",
                    t.toString()));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected void undeploy(PrintWriter writer, String path,
            StringManager smClient) {
            writer.println(smClient.getString("managerServlet.invalidPath",
                    RequestUtil.filter(path)));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(smClient.getString("managerServlet.noContext",
                        RequestUtil.filter(displayPath)));
                writer.println(smClient.getString("managerServlet.notDeployed",
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

            writer.println(smClient.getString("managerServlet.undeployed",
                    displayPath));
            writer.println(smClient.getString("managerServlet.exception",
                    t.toString()));
======= 7357867:"java/org/apache/catalina/manager/ManagerServlet.java"

    protected StringManager getStringManager(HttpServletRequest req) {
        Enumeration<Locale> requestedLocales = req.getLocales();
        while (requestedLocales.hasMoreElements()) {
            Locale locale = requestedLocales.nextElement();
            StringManager result = StringManager.getManager(Constants.Package,
                    locale);
            if (result.getLocale().equals(locale)) {
                return result;
            }
        }
        // Return the default
        return sm;
    }
======= 7357867:"java/org/apache/tomcat/util/res/StringManager.java"

======= 7357867:"java/org/apache/tomcat/util/res/StringManager.java"

    private StringManager(String packageName, Locale locale) {
            bnd = ResourceBundle.getBundle(bundleName, locale);
======= 7357867:"java/org/apache/tomcat/util/res/StringManager.java"

                    bnd = ResourceBundle.getBundle(bundleName, locale, cl);
======= 7357867:"java/org/apache/tomcat/util/res/StringManager.java"

            this.locale = bundle.getLocale();
            this.locale = null;
======= 7357867:"java/org/apache/tomcat/util/res/StringManager.java"

            //   str = "[cannot find message associated with key '" + key +
            //         "' due to " + mre + "]";
======= 7357867:"java/org/apache/tomcat/util/res/StringManager.java"

    /**
     * Identify the Locale this StringManager is associated with
     */
    public Locale getLocale() {
        return locale;
    }
    private static final Map<String, Map<Locale,StringManager>> managers =
        new Hashtable<String, Map<Locale,StringManager>>();
======= 7357867:"java/org/apache/tomcat/util/res/StringManager.java"

    public synchronized static final StringManager getManager(
            String packageName) {
        return getManager(packageName, Locale.getDefault());
    }
    /**
     * Get the StringManager for a particular package and Locale. If a manager
     * for a package/Locale combination already exists, it will be reused, else
     * a new StringManager will be created and returned.
     *
     * @param packageName The package name
     * @param locale      The Locale
     */
    public synchronized static final StringManager getManager(
            String packageName, Locale locale) {
        Map<Locale,StringManager> map = managers.get(packageName);
        if (map == null) {
            map = new Hashtable<Locale, StringManager>();
            managers.put(packageName, map);
        }
        
        StringManager mgr = map.get(locale);
            mgr = new StringManager(packageName, locale);
            map.put(locale, mgr);

======= 9e7ce59:"java/org/apache/catalina/startup/ContextConfig.java"

        } catch (ClassFormatError e) {
            log.warn(sm.getString("contextConfig.invalidSciHandlesTypes",
                    className), e);
            return;
      <fix>
        <bug>50087</bug>: Catch ClassFormatErrors when scanning for annotations.
        (markt)
      </fix>

======= 79cf689:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                    // Use same classloader and classpath for compiling tag files
                    tempWrapper.getJspEngineContext().setClassLoader(
                            ctxt.getClassLoader());
                    tempWrapper.getJspEngineContext().setClassPath(ctxt.getClassPath());
      <fix>
        <bug>50066</bug>: Fix building of recursive tag files when the file
        depends on a JAR file. Patch provided by Sylvain Laurent. (markt)
      </fix>

======= 4d7f111:"java/org/apache/catalina/startup/ContextConfig.java"

                webXml.configureContext(context);
      <fix>
        <bug>500063</bug>: Correct regression in fix for <bug>50059</bug> that
        causes applications marked as meta-data complete to return 404s for all
        requests. Patch provided by heyoulin. (markt)
      </fix>

======= 6ce21f4:"java/org/apache/catalina/core/StandardContext.java"

        // If set from server.xml, getObjectKeyPropertiesNameOnly() will
        // trigger an NPE. Initial registration takes place on INIT. 
        if (getState() != LifecycleState.NEW) {
            unregister(onameNamingResources);
            onameNamingResources = register(namingResources,
                    "type=NamingResources," + getObjectKeyPropertiesNameOnly());
        }
        <bug>50027</bug>: Avoid NPE on start when a Context is defined in
        server.xml with one or more JNDI resources. (markt)
      </fix>
      <fix>

======= da36bd1:"java/org/apache/catalina/startup/ContextConfig.java"

        if (webXmlVersion >= 3) {
======= da36bd1:"java/org/apache/catalina/startup/ContextConfig.java"

            // Only need to process fragments and annotations if metadata is
            // not complete
            Set<WebXml> orderedFragments = null;
            if  (!webXml.isMetadataComplete()) {
                // Step 2. Order the fragments.
                orderedFragments = WebXml.orderWebFragments(webXml, fragments);
    
                // Step 3. Look for ServletContainerInitializer implementations
                ok = processServletContainerInitializers(orderedFragments);
    
                // Step 4. Process /WEB-INF/classes for annotations
                // This will add any matching classes to the typeInitializerMap
                if (ok) {
                    URL webinfClasses;
                    try {
                        webinfClasses = context.getServletContext().getResource(
                                "/WEB-INF/classes");
                        processAnnotationsUrl(webinfClasses, webXml);
                    } catch (MalformedURLException e) {
                        log.error(sm.getString(
                                "contextConfig.webinfClassesUrl"), e);
                    }
    
                // Step 5. Process JARs for annotations - only need to process
                // those fragments we are going to use
                // This will add any matching classes to the typeInitializerMap
                if (ok) {
                    processAnnotations(orderedFragments);
                }
    
                // Step 6. Merge web-fragment.xml files into the main web.xml
                // file.
                if (ok) {
                    ok = webXml.merge(orderedFragments);
                }
    
                // Step 6.5 Convert explicitly mentioned jsps to servlets
                if (!false) {
                    convertJsps(webXml);
    
                // Step 7. Apply merged web.xml to Context
                if (ok) {
                    webXml.configureContext(context);
    
                    // Step 7a. Make the merged web.xml available to other
                    // components, specifically Jasper, to save those components
                    // from having to re-generate it.
                    // TODO Use a ServletContainerInitializer for Jasper
                    String mergedWebXml = webXml.toXml();
                    context.getServletContext().setAttribute(
                           org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML,
                            mergedWebXml);
                    if (context.getLogEffectiveWebXml()) {
                        log.info("web.xml:\n" + mergedWebXml);
                    }
                }
            } else {
                ok = true;
            // Always need to look for static resources
                if (orderedFragments != null) {
                    for (WebXml fragment : orderedFragments) {
                        resourceJars.add(fragment);
                    }
======= da36bd1:"java/org/apache/catalina/startup/ContextConfig.java"

            // Only look for ServletContainerInitializer if metadata is not
            // complete
            if (!webXml.isMetadataComplete()) {
                // Step 9. Apply the ServletContainerInitializer config to the
                // context
                if (ok) {
                    for (Map.Entry<ServletContainerInitializer,
                            Set<Class<?>>> entry : 
                                initializerClassMap.entrySet()) {
                        if (entry.getValue().isEmpty()) {
                            context.addServletContainerInitializer(
                                    entry.getKey(), null);
                        } else {
                            context.addServletContainerInitializer(
                                    entry.getKey(), entry.getValue());
                        }
      <fix>
        <bug>50059</bug>: JARs should always be searched for static resources
        even if the web application is marked as meta-data complete. (markt)
      </fix>

======= c4a3427:"java/javax/el/ValueReference.java"

    private final Object base;
    private final Object property;
======= c4a3427:"java/javax/servlet/AsyncEvent.java"

    private final AsyncContext context;
    private final ServletRequest request;
    private final ServletResponse response;
    private final Throwable throwable;
        this.request = null;
        this.response = null;
        this.throwable = null;
======= c4a3427:"java/javax/servlet/AsyncEvent.java"

        this.throwable = null;
        this.request = null;
        this.response = null;
======= c4a3427:"java/javax/servlet/HttpConstraintElement.java"

    private final EmptyRoleSemantic emptyRoleSemantic;// = EmptyRoleSemantic.PERMIT;
    private final TransportGuarantee transportGuarantee;// = TransportGuarantee.NONE;
    private final String[] rolesAllowed;// = new String[0];
        this.emptyRoleSemantic = EmptyRoleSemantic.PERMIT;
        this.transportGuarantee = TransportGuarantee.NONE;
        this.rolesAllowed = new String[0];
======= c4a3427:"java/javax/servlet/HttpConstraintElement.java"

        this.transportGuarantee = TransportGuarantee.NONE;
        this.rolesAllowed = new String[0];
======= c4a3427:"java/javax/servlet/HttpConstraintElement.java"

        this.emptyRoleSemantic = EmptyRoleSemantic.PERMIT;
======= c4a3427:"java/javax/servlet/HttpMethodConstraintElement.java"

    private final String methodName;
======= c4a3427:"java/javax/servlet/MultipartConfigElement.java"

    private final String location;// = "";
    private final long maxFileSize;// = -1;
    private final long maxRequestSize;// = -1;
    private final int fileSizeThreshold;// = 0;
        } else {
            this.location = "";
        this.maxFileSize = -1;
        this.maxRequestSize = -1;
        this.fileSizeThreshold = 0;
======= c4a3427:"java/javax/servlet/MultipartConfigElement.java"

        } else {
            this.location = "";
======= c4a3427:"java/javax/servlet/ServletContextAttributeEvent.java"

    private final String name;
    private final Object value;
======= c4a3427:"java/javax/servlet/ServletRequestAttributeEvent.java"

    private final String name;
    private final Object value;
======= c4a3427:"java/javax/servlet/ServletRequestEvent.java"

    private final ServletRequest request;
======= c4a3427:"java/javax/servlet/ServletSecurityElement.java"

    private final Map<String,HttpMethodConstraintElement> methodConstraints =
======= c4a3427:"java/javax/servlet/UnavailableException.java"

    private final Servlet servlet; // what's unavailable
    private final boolean permanent; // needs admin action?
    private final int seconds; // unavailability estimate
======= c4a3427:"java/javax/servlet/UnavailableException.java"

        this.seconds = 0;
======= c4a3427:"java/javax/servlet/UnavailableException.java"

        seconds = 0;
        servlet = null;
======= c4a3427:"java/javax/servlet/UnavailableException.java"

        servlet = null;
======= c4a3427:"java/javax/servlet/http/HttpSessionBindingEvent.java"

    private final String name;
    private final Object value;
======= c4a3427:"java/javax/servlet/http/HttpSessionBindingEvent.java"

        this.value = null;
======= c4a3427:"java/javax/servlet/jsp/ErrorData.java"

    private final Throwable throwable;
    private final int statusCode;
    private final String uri;
    private final String servletName;
======= c4a3427:"java/javax/servlet/jsp/tagext/BodyContent.java"

    private final JspWriter enclosingWriter;
======= c4a3427:"java/javax/servlet/jsp/tagext/FunctionInfo.java"

    private final String name;
    private final String functionClass;
    private final String functionSignature;
======= c4a3427:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

        this(name, required, type, reqTime, false);
======= c4a3427:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

        this(name, required, type, reqTime, fragment, null, false, false, null, null);
======= c4a3427:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

        this.name = name;
        this.required = required;
        this.type = type;
        this.reqTime = reqTime;
        this.fragment = fragment;
======= c4a3427:"java/javax/servlet/jsp/tagext/TagAttributeInfo.java"

    private final String name;
    private final String type;
    private final boolean reqTime;
    private final boolean required;
    private final boolean fragment;
    private final String description;
    private final boolean deferredValue;
    private final boolean deferredMethod;
    private final String expectedTypeName;
    private final String methodSignature;
======= c4a3427:"java/javax/servlet/jsp/tagext/TagData.java"

    private final Hashtable<String, Object> attributes;        // the tagname/value map
======= c4a3427:"java/javax/servlet/jsp/tagext/TagExtraInfo.java"

    private  TagInfo tagInfo;
======= c4a3427:"java/javax/servlet/jsp/tagext/TagFileInfo.java"

    private final String name;
    private final String path;
    private final TagInfo tagInfo;
======= c4a3427:"java/javax/servlet/jsp/tagext/TagVariableInfo.java"

    private final String nameGiven; // <name-given>
    private final String nameFromAttribute; // <name-from-attribute>
    private final String className; // <class>
    private final boolean declare; // <declare>
    private final int scope; // <scope>
======= c4a3427:"java/javax/servlet/jsp/tagext/ValidationMessage.java"

    private final String id;
    private final String message;
======= c4a3427:"java/javax/servlet/jsp/tagext/VariableInfo.java"

    private final String varName;
    private final String className;
    private final boolean declare;
    private final int scope;
      <update>
        <bug>50017</bug>: Code clean-up. No functional change. Patch provided by
        sebb. (markt)
      </update>

======= 469a916:"java/org/apache/catalina/Authenticator.java"

======= 469a916:"java/org/apache/catalina/Authenticator.java"

    public void login(String userName, String password, Request request)
            throws ServletException;
    public void logout(Request request) throws ServletException;
======= 469a916:"java/org/apache/catalina/Realm.java"

     * @param wrapper wrapper context for evaluating role
    public boolean hasRole(Wrapper wrapper, Principal principal, String role);
======= 469a916:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

    public void login(String username, String password, Request request)
            throws ServletException {
        Principal principal = doLogin(request, username, password);
        register(request, request.getResponse(), principal,
                    getAuthMethod(), username, password);
    }
    protected abstract String getAuthMethod();
    protected Principal doLogin(Request request, String username,
            String password) throws ServletException {
        Principal p = context.getRealm().authenticate(username, password);
        if (p == null) {
            throw new ServletException(sm.getString("authenticator.loginFail"));
        }
        return p;
    }
    public void logout(Request request) throws ServletException {
        register(request, request.getResponse(), null,
                null, null, null);
    }
======= 469a916:"java/org/apache/catalina/authenticator/BasicAuthenticator.java"

    @Override
    protected String getAuthMethod() {
        return Constants.BASIC_METHOD;
    }
======= 469a916:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

    @Override
    protected String getAuthMethod() {
        return Constants.DIGEST_METHOD;
    }
======= 469a916:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

    @Override
    protected String getAuthMethod() {
        return Constants.FORM_METHOD;
    }
======= 469a916:"java/org/apache/catalina/authenticator/NonLoginAuthenticator.java"

    @Override
    protected String getAuthMethod() {
        return "NONE";
    }
======= 469a916:"java/org/apache/catalina/authenticator/SSLAuthenticator.java"

    @Override
    protected String getAuthMethod() {
        return Constants.CERT_METHOD;
    }
======= 469a916:"java/org/apache/catalina/connector/Request.java"

        return (realm.hasRole(wrapper, userPrincipal, role));
======= 469a916:"java/org/apache/catalina/connector/Request.java"

        if (context.getAuthenticator() == null) {
            throw new ServletException("no authenticator");
        context.getAuthenticator().login(username, password, this);
======= 469a916:"java/org/apache/catalina/connector/Request.java"

        context.getAuthenticator().logout(this);
======= 469a916:"java/org/apache/catalina/realm/RealmBase.java"

======= 469a916:"java/org/apache/catalina/realm/RealmBase.java"

                    if (hasRole(null, principal, roles[j])) {
======= 469a916:"java/org/apache/catalina/realm/RealmBase.java"

    @Override
    public boolean hasRole(Wrapper wrapper, Principal principal, String role) {
        // Check for a role alias defined in a <security-role-ref> element
        if (wrapper != null) {
            String realRole = wrapper.findSecurityReference(role);
            if (realRole != null)
                role = realRole;
        }
======= 469a916:"java/org/apache/catalina/realm/UserDatabaseRealm.java"

======= 469a916:"java/org/apache/catalina/realm/UserDatabaseRealm.java"

    public boolean hasRole(Wrapper wrapper, Principal principal, String role) {
        // Check for a role alias defined in a <security-role-ref> element
        if (wrapper != null) {
            String realRole = wrapper.findSecurityReference(role);
            if (realRole != null)
                role = realRole;
        }
======= 469a916:"java/org/apache/catalina/realm/UserDatabaseRealm.java"

            return super.hasRole(null, principal, role);
      <fix>
        <bug>50016</bug>: Re-factor <code>isUserInRole()</code> and
        <code>login()/logout()</code> methods to support JACC implementations
        and to improve encapsulation. Patch provided by David Jencks. (markt)
      </fix>

======= 2db864e:"java/org/apache/catalina/core/ApplicationContext.java"

======= 2db864e:"java/org/apache/catalina/core/ApplicationContext.java"

    private Map<String,String> parameters =
        new ConcurrentHashMap<String,String>();
======= 2db864e:"java/org/apache/catalina/core/ApplicationContext.java"

======= 2db864e:"java/org/apache/catalina/core/ApplicationContext.java"

======= 2db864e:"java/org/apache/catalina/core/ApplicationContext.java"

======= 2db864e:"java/org/apache/catalina/core/ApplicationContext.java"

======= 2db864e:"java/org/apache/catalina/core/StandardContext.java"

            // Set up the context init params
            mergeParameters();
======= 2db864e:"java/org/apache/catalina/core/StandardContext.java"

    
    /**
     * Merge the context initialization parameters specified in the application
     * deployment descriptor with the application parameters described in the
     * server configuration, respecting the <code>override</code> property of
     * the application parameters appropriately.
     */
    private void mergeParameters() {
        ServletContext sc = getServletContext();
        
        String names[] = findParameters();
        for (int i = 0; i < names.length; i++) {
            sc.setInitParameter(names[i], findParameter(names[i]));
        }
        ApplicationParameter params[] = findApplicationParameters();
        for (int i = 0; i < params.length; i++) {
            if (params[i].getOverride()) {
                if (sc.getInitParameter(params[i].getName()) == null) {
                    sc.setInitParameter(params[i].getName(),
                            params[i].getValue());
                }
            } else {
                sc.setInitParameter(params[i].getName(), params[i].getValue());
            }
        }
    }
      <fix>
        <bug>49987</bug>: Fix thread safety issue with population of servlet
        context initialization parameters. (markt)
      </fix>

======= 2570d6ff:"java/org/apache/jasper/servlet/JspServletWrapper.java"

    /** Whether the servlet needs reloading on next access */
    private volatile boolean reload = true;
    /** Timestamp of last time servlet resource was modified */
    private volatile long servletClassLastModifiedTime;
======= 2570d6ff:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        // DCL on 'reload' requires that 'reload' be volatile
        // (this also forces a read memory barrier, ensuring the 
        // new servlet object is read consistently)
======= 2570d6ff:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                    final Servlet servlet;
======= 2570d6ff:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                    // Volatile 'reload' forces in order write of 'theServlet' and new servlet object
======= 2570d6ff:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        // DCL requires servletClassLastModifiedTime be volatile
        // to force read and write barriers on access/set
        // (and to get atomic write of long)

======= 0ae33cb:"java/org/apache/tomcat/util/http/FastHttpDateFormat.java"

    private static final int CACHE_SIZE = 
    private static final SimpleDateFormat format = 
    private static final SimpleDateFormat formats[] = {
    private static final TimeZone gmtZone = TimeZone.getTimeZone("GMT");
======= 0ae33cb:"java/org/apache/tomcat/util/http/FastHttpDateFormat.java"

    private static volatile long currentDateGenerated = 0L;
    private static String currentDate = null;
    private static final ConcurrentHashMap<Long, String> formatCache = 
    private static final ConcurrentHashMap<String, Long> parseCache = 
======= 0ae33cb:"java/org/apache/tomcat/util/http/FastHttpDateFormat.java"

                    currentDateGenerated = now;

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    /**
     * The string manager for this package.
     */
    protected static final StringManager sm = StringManager.getManager(Constants.Package);
    
    protected abstract Log getLog();
    
    protected ObjectName tpOname = null;
    protected ObjectName rgOname = null;
    protected AbstractEndpoint endpoint = null;
    
    /**
     * The adapter, used to call the connector.
     */
    protected Adapter adapter;
    
    protected HashMap<String, Object> attributes = new HashMap<String, Object>();
    
    /** 
     * Pass config info
     */
    @Override
    public void setAttribute(String name, Object value) {
        if (getLog().isTraceEnabled()) {
            getLog().trace(sm.getString("ajpprotocol.setattribute", name, value));
        }
        attributes.put(name, value);
    }
    @Override
    public Object getAttribute(String key) {
        if (getLog().isTraceEnabled()) {
            getLog().trace(sm.getString("ajpprotocol.getattribute", key));
        }
        return attributes.get(key);
    }
    @Override
    public Iterator<String> getAttributeNames() {
        return attributes.keySet().iterator();
    }
    /**
     * Set a property.
     */
    public boolean setProperty(String name, String value) {
        setAttribute(name, value); //store all settings
        if ( name!=null && (name.startsWith("socket.") ||name.startsWith("selectorPool.")) ){
            return endpoint.setProperty(name, value);
        } else {
            return endpoint.setProperty(name,value); //make sure we at least try to set all properties
        }
        
    }
    /**
     * Get a property
     */
    public String getProperty(String name) {
        return (String)getAttribute(name);
    }
    /**
     * The adapter, used to call the connector
     */
    @Override
    public void setAdapter(Adapter adapter) {
        this.adapter = adapter;
    }
    @Override
    public Adapter getAdapter() {
        return adapter;
    }
    @Override
    public void pause() throws Exception {
        try {
            endpoint.pause();
        } catch (Exception ex) {
            getLog().error(sm.getString("ajpprotocol.endpoint.pauseerror"), ex);
            throw ex;
        }
        if (getLog().isInfoEnabled())
            getLog().info(sm.getString("ajpprotocol.pause", getName()));
    }
    @Override
    public void resume() throws Exception {
        try {
            endpoint.resume();
        } catch (Exception ex) {
            getLog().error(sm.getString("ajpprotocol.endpoint.resumeerror"), ex);
            throw ex;
        }
        if (getLog().isInfoEnabled())
            getLog().info(sm.getString("ajpprotocol.resume", getName()));
    }
    @Override
    public void stop() throws Exception {
        try {
            endpoint.stop();
        } catch (Exception ex) {
            getLog().error(sm.getString("ajpprotocol.endpoint.stoperror"), ex);
            throw ex;
        }
        if (getLog().isInfoEnabled())
            getLog().info(sm.getString("ajpprotocol.stop", getName()));
    }
    @Override
    public void destroy() throws Exception {
        if (getLog().isInfoEnabled())
            getLog().info(sm.getString("ajpprotocol.destroy", getName()));
        endpoint.destroy();
        if (tpOname!=null)
            Registry.getRegistry(null, null).unregisterComponent(tpOname);
        if (rgOname != null)
            Registry.getRegistry(null, null).unregisterComponent(rgOname);
    }
    // *
    public String getName() {
        String encodedAddr = "";
        if (getAddress() != null) {
            encodedAddr = "" + getAddress();
            if (encodedAddr.startsWith("/"))
                encodedAddr = encodedAddr.substring(1);
            encodedAddr = URLEncoder.encode(encodedAddr) + "-";
        }
        return ("ajp-" + encodedAddr + endpoint.getPort());
    }
    /**
     * Processor cache.
     */
    protected int processorCache = -1;
    public int getProcessorCache() { return this.processorCache; }
    public void setProcessorCache(int processorCache) { this.processorCache = processorCache; }
    @Override
    public Executor getExecutor() { return endpoint.getExecutor(); }
    public void setExecutor(Executor executor) { endpoint.setExecutor(executor); }
    
    public int getMaxThreads() { return endpoint.getMaxThreads(); }
    public void setMaxThreads(int maxThreads) { endpoint.setMaxThreads(maxThreads); }
    public int getThreadPriority() { return endpoint.getThreadPriority(); }
    public void setThreadPriority(int threadPriority) { endpoint.setThreadPriority(threadPriority); }
    public int getBacklog() { return endpoint.getBacklog(); }
    public void setBacklog(int backlog) { endpoint.setBacklog(backlog); }
    public int getPort() { return endpoint.getPort(); }
    public void setPort(int port) { endpoint.setPort(port); }
    public InetAddress getAddress() { return endpoint.getAddress(); }
    public void setAddress(InetAddress ia) { endpoint.setAddress(ia); }
    public boolean getTcpNoDelay() { return endpoint.getTcpNoDelay(); }
    public void setTcpNoDelay(boolean tcpNoDelay) { endpoint.setTcpNoDelay(tcpNoDelay); }
    public int getSoLinger() { return endpoint.getSoLinger(); }
    public void setSoLinger(int soLinger) { endpoint.setSoLinger(soLinger); }
    public int getSoTimeout() { return endpoint.getSoTimeout(); }
    public void setSoTimeout(int soTimeout) { endpoint.setSoTimeout(soTimeout); }
    /**
     * Should authentication be done in the native webserver layer, 
     * or in the Servlet container ?
     */
    protected boolean tomcatAuthentication = true;
    public boolean getTomcatAuthentication() { return tomcatAuthentication; }
    public void setTomcatAuthentication(boolean tomcatAuthentication) { this.tomcatAuthentication = tomcatAuthentication; }
    /**
     * Required secret.
     */
    protected String requiredSecret = null;
    public void setRequiredSecret(String requiredSecret) { this.requiredSecret = requiredSecret; }
    
    /**
     * AJP packet size.
     */
    protected int packetSize = Constants.MAX_PACKET_SIZE;
    public int getPacketSize() { return packetSize; }
    public void setPacketSize(int packetSize) {
        if(packetSize < Constants.MAX_PACKET_SIZE) {
            this.packetSize = Constants.MAX_PACKET_SIZE;
        } else {
            this.packetSize = packetSize;
        }
    }
    
    /**
     * The number of seconds Tomcat will wait for a subsequent request
     * before closing the connection.
     */
    protected int keepAliveTimeout = -1;
    public int getKeepAliveTimeout() { return keepAliveTimeout; }
    public void setKeepAliveTimeout(int timeout) { keepAliveTimeout = timeout; }
    // -------------------- JMX related methods --------------------
    protected String domain;
    protected ObjectName oname;
    protected MBeanServer mserver;
    public ObjectName getObjectName() {
        return oname;
    }
    public String getDomain() {
        return domain;
    }
    @Override
    public ObjectName preRegister(MBeanServer server,
                                  ObjectName name) throws Exception {
        oname=name;
        mserver=server;
        domain=name.getDomain();
        return name;
    }
    @Override
    public void postRegister(Boolean registrationDone) {
        // NOOP
    }
    @Override
    public void preDeregister() throws Exception {
        // NOOP
    }
    @Override
    public void postDeregister() {
        // NOOP
    }
======= 654c964:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

======= 654c964:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

======= 654c964:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    @Override
    protected Log getLog() { return log; }
        endpoint = new AprEndpoint();
======= 654c964:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

======= 654c964:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

        ((AprEndpoint)endpoint).setHandler(cHandler);
        ((AprEndpoint)endpoint).setUseSendfile(false);
======= 654c964:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    public int getPollTime() { return ((AprEndpoint)endpoint).getPollTime(); }
    public void setPollTime(int pollTime) { ((AprEndpoint)endpoint).setPollTime(pollTime); }
    public void setPollerSize(int pollerSize) { ((AprEndpoint)endpoint).setPollerSize(pollerSize); }
    public int getPollerSize() { return ((AprEndpoint)endpoint).getPollerSize(); }
======= 654c964:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

                            ((AprEndpoint)proto.endpoint).getPoller().add(socket.getSocket().longValue());
======= 654c964:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

            AjpAprProcessor processor = new AjpAprProcessor(proto.packetSize, (AprEndpoint)proto.endpoint);
======= 654c964:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

======= 654c964:"java/org/apache/coyote/ajp/AjpProtocol.java"

======= 654c964:"java/org/apache/coyote/ajp/AjpProtocol.java"

    @Override
    protected Log getLog() { return log; }
        endpoint = new JIoEndpoint();
======= 654c964:"java/org/apache/coyote/ajp/AjpProtocol.java"

======= 654c964:"java/org/apache/coyote/ajp/AjpProtocol.java"

        ((JIoEndpoint)endpoint).setHandler(cHandler);
======= 654c964:"java/org/apache/coyote/ajp/AjpProtocol.java"

======= 654c964:"java/org/apache/coyote/ajp/AjpProtocol.java"

            AjpProcessor processor = new AjpProcessor(proto.packetSize, (JIoEndpoint)proto.endpoint);
======= 654c964:"java/org/apache/coyote/ajp/AjpProtocol.java"

      <fix>
        <bug>50054</bug>: Correctly handle the setting of minSpareThreads in 
        AJP connector. (kfujino) 
      </fix>

======= 0e71157:"java/org/apache/catalina/core/DefaultInstanceManager.java"

        String normalizedName = normalize(name);
        if ((normalizedName != null) && (normalizedName.length() > 0)) {
            lookedupResource = context.lookup(normalizedName);
======= 0e71157:"java/org/apache/catalina/core/DefaultInstanceManager.java"

        String normalizedName = normalize(name);
        if ((normalizedName != null) && (normalizedName.length() > 0)) {
            lookedupResource = context.lookup(normalizedName);
======= 0e71157:"java/org/apache/catalina/core/DefaultInstanceManager.java"

    
    private static String normalize(String jndiName){
        if(jndiName != null && jndiName.startsWith("java:comp/env/")){
            return jndiName.substring(14);
        }
        return jndiName;
    }
      <fix>
        <bug>49956</bug>: Handle case when @Resource annotation uses the full
        JNDI name for a resource. Based on a patch by Gurkan Erdogdu. (markt) 
      </fix>

======= 937227a:"java/org/apache/catalina/core/StandardContext.java"

        //Listeners may have been added by ServletContextInitializers.  Put them after the ones we know about.
        for (Object eventListener: getApplicationEventListeners()) {
            eventListeners.add(eventListener);
        }
        for (Object lifecycleListener: getApplicationLifecycleListeners()) {
            lifecycleListeners.add(lifecycleListener);
        }
======= 937227a:"java/org/apache/catalina/core/StandardContext.java"

 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
    /**
     * Check that a ServletContainerInitializer can install a
     * {@link ServletContextListener} and that it gets initialized.
     * @throws Exception
     */
    public void testServletContainerInitializer() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        Context context = tomcat.addContext("/",
                System.getProperty("java.io.tmpdir"));
        context.addServletContainerInitializer(new SCI(), null);
        tomcat.start();
        assertTrue(SCL.initialized);
    }
    /**
     * Check that a {@link ServletContextListener} cannot install a
     * {@link ServletContextInitializer}.
     * @throws Exception
     */
    public void testServletContextListener() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        Context context = tomcat.addContext("/",
                System.getProperty("java.io.tmpdir"));
        // SCL2 pretends to be in web.xml, and tries to install a
        // ServletContextInitializer.
        context.addApplicationListener(SCL2.class.getName());
        tomcat.start();
        //check that the ServletContextInitializer wasn't initialized.
        assertFalse(SCL3.initialized);
    }
    public static class SCI implements ServletContainerInitializer {
        @Override
        public void onStartup(Set<Class<?>> c, ServletContext ctx)
                throws ServletException {
            ctx.addListener(new SCL());
        }
    }
    public static class SCL implements ServletContextListener {
        static boolean initialized = false;
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            initialized = true;
        }
        @Override
        public void contextDestroyed(ServletContextEvent sce) {
            // NOOP
        }
    }
    
    public static class SCL2 implements ServletContextListener {
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            ServletContext sc = sce.getServletContext();
            sc.addListener(SCL3.class.getName());
        }
        @Override
        public void contextDestroyed(ServletContextEvent sce) {
            // NOOP
        }
    }
    public static class SCL3 implements ServletContextListener {
        static boolean initialized = false;
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            initialized = true;
        }
        @Override
        public void contextDestroyed(ServletContextEvent sce) {
            // NOOP
        }
    }
      <fix>
        <bug>49952</bug>: Allow ServletContainerInitializers to add listeners to
        a web application. Patch provided by David Jencks. (markt)
      </fix>

======= cf4e575:"java/org/apache/catalina/core/AsyncContextImpl.java"

======= cf4e575:"java/org/apache/catalina/core/AsyncContextImpl.java"

======= cf4e575:"java/org/apache/catalina/core/AsyncContextImpl.java"

    private volatile InstanceManager instanceManager;
======= cf4e575:"java/org/apache/catalina/core/AsyncContextImpl.java"

    @SuppressWarnings("unchecked")
             listener = (T) getInstanceManager().newInstance(clazz.getName(),
                     clazz.getClassLoader());
        } catch (InvocationTargetException e) {
            ServletException se = new ServletException(e);
            throw se;
        } catch (NamingException e) {
            ServletException se = new ServletException(e);
            throw se;
        } catch (ClassNotFoundException e) {
            ServletException se = new ServletException(e);
            throw se;
======= cf4e575:"java/org/apache/catalina/core/AsyncContextImpl.java"

    private InstanceManager getInstanceManager() {
        if (instanceManager == null) {
            if (context instanceof StandardContext) {
                instanceManager = ((StandardContext)context).getInstanceManager();
            } else {
                instanceManager = new DefaultInstanceManager(null,
                        new HashMap<String, Map<String, String>>(),
                        context,
                        getClass().getClassLoader()); 
            }
        }
        return instanceManager;
    }
        filter matches more than one URL pattern and/or Servlet name. (markt)
      </fix>
      <fix>
        <bug>49937</bug>: Use an InstanceManager when creating an AsyncListener
        through the AsyncContext to ensure annotations are processed. Based on a
        patch by David Jencks. (markt)

======= b893eee:"java/org/apache/el/parser/AstFloatingPoint.java"

    private volatile Number number;
======= b893eee:"java/org/apache/el/parser/AstInteger.java"

    private volatile Number number;
======= b893eee:"java/org/apache/el/parser/AstString.java"

    private volatile String string;
      <fix>
        <bug>49985</bug>: Fix thread safety issue in EL parser. (markt)
      </fix>

======= 5eb3851:"java/org/apache/catalina/core/StandardServer.java"

     * @exception   javax.management.InstanceNotFoundException
     *              if the managed resource object cannot be found
     * @exception   javax.management.MBeanException
     *              if the initializer of the object throws an exception, or
     *              persistence is not supported
     * @exception   javax.management.RuntimeOperationsException
     *              if an exception is reported by the persistence mechanism
        ObjectName sname = new ObjectName("Catalina:type=StoreConfig");
        mserver.invoke(sname, "storeConfig", null, null);            
        <bug>49915</bug>: Make error more obvious, particularly when accessed
        via JConsole, if StandardServer.storeConfig() is called when there is
        no StoreConfig implementation present. (markt)
      </fix>
      <fix>

======= 2c858be:"java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java"

======= 2c858be:"java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java"

        executor = new ThreadPoolExecutor(maxSpareThreads, maxThreads,
                keepAliveTime, TimeUnit.MILLISECONDS, runnablequeue,
                new TcclThreadFactory());
======= 2c858be:"java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * ThreadFactory implementation that creates threads with the thread context
 * class loader set to the class loader that loaded this factory. It is intended
 * to be used when tasks may be passed to executors when the web application
 * class loader is set as the thread context class loader, such as in async
 * session replication.
 */
    
    private static final AtomicInteger poolNumber = new AtomicInteger(1);
    private static final boolean IS_SECURITY_ENABLED =
        (System.getSecurityManager() != null);
    
    private final ThreadGroup group;
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;
    
    public TcclThreadFactory() {
        SecurityManager s = System.getSecurityManager();
        group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
        namePrefix = "pool-" + poolNumber.getAndIncrement() + "-thread-";
    }
    @Override
    public Thread newThread(Runnable r) {
        final Thread t = new Thread(group, r, namePrefix +
                threadNumber.getAndIncrement());
        
        if (IS_SECURITY_ENABLED) {
            AccessController.doPrivileged(new PrivilegedAction<Void>() {
                @Override
                public Void run() {
                    t.setContextClassLoader(this.getClass().getClassLoader());
                    return null;
                }
            });
        } else {
            t.setContextClassLoader(this.getClass().getClassLoader());
        }
        return t;
    }

======= f4de5ab:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        private static final int JVM_BUG_THRESHOLD = 16;
        private volatile int jvmBugCount = 0; 
        
======= f4de5ab:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                                long before = System.currentTimeMillis();
                                long after = System.currentTimeMillis();
                                if (keyCount == 0 &&
                                        (after - before) < selectorTimeout/2) {
                                    jvmBugCount++;
                                    if (jvmBugCount > JVM_BUG_THRESHOLD) {
                                        log.error(sm.getString(
                                                "endpoint.err.jvmbug"));
                                    }
                                }
  
        Sylvain Laurent. (markt)
      <add>
        <bug>49890</bug>: Detect when NIO connector encounters a known JVM bug
        on Linux and log an error to help determine if the bug is still present
        ort not. The JVM bug should be fixed for 2.6 kernels and the 1.6.0u18
        JVMs and later. (markt)
      </add>

======= 00cc8c6:"java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java"

                    Integer.toString(theRmiRegistryPort),
                    Integer.toString(theRmiServerPort), serverName));
  <subsection name="Extras">
    <changelog>
      <fix>
        <bug>49861</bug>: Don&apos;t log RMI ports formatted with commas for the
        JMX remote listener. (markt)
      </fix>
    </changelog>
  </subsection>

======= dc754cc:"java/org/apache/catalina/loader/JdbcLeakPrevention.java"

======= dc754cc:"java/org/apache/catalina/loader/JdbcLeakPrevention.java"

        /*
         * DriverManager.getDrivers() has a nasty side-effect of registering
         * drivers that are visible to this class loader but haven't yet been
         * loaded. Therefore, the first call to this method a) gets the list
         * of originally loaded drivers and b) triggers the unwanted
         * side-effect. The second call gets the complete list of drivers
         * ensuring that both original drivers and any loaded as a result of the
         * side-effects are all de-registered.
         */
        HashSet<Driver> originalDrivers = new HashSet<Driver>();
            originalDrivers.add(drivers.nextElement());
        }
        drivers = DriverManager.getDrivers();
        while (drivers.hasMoreElements()) {
            // Only report drivers that were originally registered. Skip any
            // that were registered as a side-effect of this code.
            if (originalDrivers.contains(driver)) {
                driverNames.add(driver.getClass().getCanonicalName());
            }
        <bug>49667</bug>: Ensure that using the JDBC driver memory leak
        prevention code does not cause a one of the memory leaks it is meant to
        avoid. (markt)
      </fix>
      <fix>

======= 167829c:"java/org/apache/catalina/connector/Connector.java"

    public String getExecutorName() {
        Object obj = protocolHandler.getExecutor();
        if (obj instanceof org.apache.catalina.Executor) {
            return ((org.apache.catalina.Executor) obj).getName();
        }
        return "Internal";
    }
    <attribute   name="executorName"
          description="The name of the executor - if any - associated with this Connector"
                 type="java.lang.String"
            writeable="false"/>
        <bug>49856</bug>: Add an executorName attribute to Connectors so it is
        possible to trace ThreadPool to Connector to Executor via the JMX
        interface. (markt)
      </fix>
      <fix>

======= 2bfc300:"java/org/apache/tomcat/util/threads/TaskQueue.java"

======= 2bfc300:"java/org/apache/tomcat/util/threads/TaskQueue.java"

        if (parent.getSubmittedCount()<(parent.getPoolSize())) return super.offer(o);
======= 2bfc300:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

 * {@link #getSubmittedCount()} method, to be used to properly handle the work queue.
======= 2bfc300:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

    /**
     * The number of tasks submitted but not yet finished. This includes tasks
     * in the queue and tasks that have been handed to a worker thread but the
     * latter did not start executing the task yet.
     * This number is always greater or equal to {@link #getActiveCount()}.
     */
    private final AtomicInteger submittedCount = new AtomicInteger(0);
======= 2bfc300:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

        submittedCount.decrementAndGet();
    public int getSubmittedCount() {
        return submittedCount.get();
======= 2bfc300:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

        submittedCount.incrementAndGet();
======= 2bfc300:"java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java"

                        submittedCount.decrementAndGet();
                    submittedCount.decrementAndGet();
                submittedCount.decrementAndGet();
        <bug>49730</bug>: Fix a race condition in StandardThreadExector that can
        cause requests to experience large delays. Patch provided by Sylvain
        Laurent. (markt)
      </fix>
      <fix>

======= 6c22816:"java/org/apache/catalina/startup/Bootstrap.java"

======= 6c22816:"java/org/apache/catalina/startup/Bootstrap.java"

            handleThrowable(t);
======= 6c22816:"java/org/apache/catalina/startup/Bootstrap.java"

                handleThrowable(t);
======= 6c22816:"java/org/apache/catalina/startup/Bootstrap.java"

            handleThrowable(t);
======= 6c22816:"java/org/apache/catalina/startup/Bootstrap.java"

    // Copied from ExceptionUtils since that class is not visible during start
    private static void handleThrowable(Throwable t) {
        if (t instanceof ThreadDeath) {
            throw (ThreadDeath) t;
        }
        if (t instanceof VirtualMachineError) {
            throw (VirtualMachineError) t;
        }
        // All other instances of Throwable will be silently swallowed
    }
      <fix>
        <bug>50021</bug>: Correct a regression in the fix for <bug>46844</bug>
        that may have caused additional problems during a failure at start up.
        (markt) 
      </fix>

======= 2f8a27c:"java/org/apache/jasper/compiler/ParserController.java"

     * @param jarResource The JAR file from which to read the included resource,
======= 2f8a27c:"java/org/apache/jasper/compiler/ParserController.java"

     * @param jarResource The location of the tag file.
======= 2f8a27c:"java/org/apache/jasper/compiler/ParserController.java"

     * @param jarResource The JAR file from which to read the JSP page or tag file,
======= 2f8a27c:"java/org/apache/jasper/compiler/TagFileProcessor.java"

     * @param jarResource
     *            the Jar resource containing the tag file 
      <fix>
        <bug>50018</bug>: Fix some minor Javadoc errors in Jasper source.
        Based on a patch by sebb. (timw)
      </fix>

======= 7c6b1a5:"java/org/apache/catalina/startup/Catalina.java"

        } else {
            // Server object already present. Must be running as a service
            // Shutdown hook will take care of clean-up
            System.exit(0);
        <bug>49195</bug>: Don't report an error when shutting down a Windows
        service for a Tomcat instance that has a disabled shutdown port. (markt)
      </fix>
      <fix>

======= 7b24ed5:"java/org/apache/jasper/compiler/Generator.java"

                StringBuilder msg = new StringBuilder();
                msg.append("file:");
                msg.append(n.getStart());
                msg.append(" jsp:getProperty for bean with name '");
======= 7b24ed5:"java/org/apache/jasper/compiler/JspDocumentParser.java"

                            err,
                            null);
======= 7b24ed5:"java/org/apache/jasper/compiler/Parser.java"

                                pageInfo, prefix, uri, location, err,
                                reader.mark());
======= 7b24ed5:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

    public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc,
            PageInfo pi, String prefix, String uriIn, TldLocation location,
            ErrorDispatcher err, Mark mark)
======= 7b24ed5:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                    err.jspError(mark, "jsp.error.file.not.found", tldName);
======= 7b24ed5:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                    err.jspError(mark, "jsp.error.tld.unable_to_read", jarResource.getUrl(),
        <bug>49665</bug>: Provide better information including JSP file name and
        location when a missing file is detected during TLD handling. Patch
        provided by Ted Leung. (markt)
      </fix>
      <fix>

======= 7435fa9:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

     * Check if the resource could be compressed, if the client supports it.
    private boolean isCompressable() {
        // Check if content is not already gzipped
        MessageBytes contentEncodingMB =
            response.getMimeHeaders().getValue("Content-Encoding");
        if ((contentEncodingMB != null)
            && (contentEncodingMB.indexOf("gzip") != -1))
            return false;
        // If force mode, always compress (test purposes only)
        if (compressionLevel == 2)
           return true;
        // Check if sufficient length to trigger the compression
        long contentLength = response.getContentLengthLong();
        if ((contentLength == -1)
            || (contentLength > compressionMinSize)) {
            // Check for compatible MIME-TYPE
            if (compressableMimeTypes != null) {
                return (startsWithStringArray(compressableMimeTypes,
                                              response.getContentType()));
            }
        }
        return false;
    }
    
    /**
     * Check if compression should be used for this resource. Already checked
     * that the resource could be compressed if the client supports it.
     */
    private boolean useCompression() {
======= 7435fa9:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

======= 7435fa9:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        return true;
======= 7435fa9:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        boolean isCompressable = false;
            isCompressable = isCompressable();
            if (isCompressable) {
                useCompression = useCompression();
            }
======= 7435fa9:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        }
        // If it might be compressed, set the Vary header
        if (isCompressable) {
        <bug>49625</bug>: Ensure Vary header is set if response may be
        compressed rather than only setting it if it is compressed. (markt)
      </fix>
      <fix>

======= d0d4c75:"java/org/apache/catalina/loader/WebappClassLoader.java"

                    classBytes, 0, offset, this.getClass().getProtectionDomain());

======= fb5a3e7:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

            String methodName = Constants.getMethodForCode(methodCode - 1);
======= fb5a3e7:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

                hName = Constants.getHeaderForCode(hId - 1);
======= fb5a3e7:"java/org/apache/coyote/ajp/AjpProcessor.java"

            String methodName = Constants.getMethodForCode(methodCode - 1);
======= fb5a3e7:"java/org/apache/coyote/ajp/AjpProcessor.java"

                hName = Constants.getHeaderForCode(hId - 1);
======= fb5a3e7:"java/org/apache/coyote/ajp/Constants.java"

    private static final String [] methodTransArray = {
======= fb5a3e7:"java/org/apache/coyote/ajp/Constants.java"

    
    /**
     * Converts an AJP coded HTTP method to the method name.
     * @param code the coded value
     * @return the string value of the method
     */
======= fb5a3e7:"java/org/apache/coyote/ajp/Constants.java"

    private static final String [] headerTransArray = {
======= fb5a3e7:"java/org/apache/coyote/ajp/Constants.java"

    /**
     * Converts an AJP coded HTTP request header to the header name.
     * @param code the coded value
     * @return the string value of the header name
     */
    private static final String [] responseTransArray = {
======= fb5a3e7:"java/org/apache/coyote/ajp/Constants.java"

    
    /**
     * Converts an AJP coded response header name to the HTTP response header name.
     * @param code the coded value
     * @return the string value of the header
     */
======= fb5a3e7:"java/org/apache/coyote/ajp/Constants.java"

                responseTransHash.put(getResponseHeaderForCode(i),

======= 8dc0306:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * classes from J2SE (java.*) and most classes of the servlet API 
======= 8dc0306:"java/org/apache/catalina/loader/WebappClassLoader.java"

        // Need to be careful with order here
        if (name == null) {
            // Can't load a class without a name
        }
        if (name.startsWith("java.")) {
            // Must never load java.* classes
        }
        if (name.startsWith("javax.servlet.jsp.jstl")) {
            // OK for web apps to package JSTL
            return true;
        }
        if (name.startsWith("javax.servlet.")) {
            // Web apps should never package any other Servlet or JSP classes
        }
        // Assume everything else is OK
      <fix>
        <bug>49909</bug>: Fix a regression introduced with the fix for
        <bug>47950</bug> that prevented JSTL classes being loaded. (markt)
      </fix>

======= b255697:"java/org/apache/catalina/ha/session/BackupManager.java"

                session.setPrimarySession(true);
======= b255697:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    if ( entry.getValue() != null && entry.getValue() instanceof ReplicatedMapEntry ) {
                        ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();
                        val.setOwner(getMapOwner());   
                    }
                getMapOwner().objectMadePrimay(key, entry.getValue());
======= b255697:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

      <fix>
        <bug>49924</bug>: When non-primary node changes into a primary node, 
        make sure isPrimarySession is changed to true. (kfujino)
      </fix>

======= e0182ef:"java/org/apache/catalina/Server.java"

======= e0182ef:"java/org/apache/catalina/Server.java"

    
    /**
     * Return the parent class loader.
     */
    public ClassLoader getParentClassLoader();
    
    /**
     * Return the outer Catalina startup/shutdown component if present.
     */
    public Catalina getCatalina();
    
    /**
     * Set the outer Catalina startup/shutdown component if present.
     */
    public void setCatalina(Catalina catalina);
    
======= e0182ef:"java/org/apache/catalina/Service.java"

    /**
     * Return the parent class loader.
     */
    public ClassLoader getParentClassLoader();
    
======= e0182ef:"java/org/apache/catalina/core/StandardEngine.java"

======= e0182ef:"java/org/apache/catalina/core/StandardEngine.java"

    /**
     * Return the parent class loader for this component.
     */
    @Override
    public ClassLoader getParentClassLoader() {
        if (parentClassLoader != null)
            return (parentClassLoader);
        if (service != null) {
            return (service.getParentClassLoader());
        }
        return (ClassLoader.getSystemClassLoader());
    }
======= e0182ef:"java/org/apache/catalina/core/StandardServer.java"

======= e0182ef:"java/org/apache/catalina/core/StandardServer.java"

    
    private Catalina catalina = null;
======= e0182ef:"java/org/apache/catalina/core/StandardServer.java"

    /**
     * Return the outer Catalina startup/shutdown component if present.
     */
    @Override
    public Catalina getCatalina() {
        return catalina;
    }
    
    
    /**
     * Set the outer Catalina startup/shutdown component if present.
     */
    @Override
    public void setCatalina(Catalina catalina) {
        this.catalina = catalina;
    }
    
======= e0182ef:"java/org/apache/catalina/core/StandardServer.java"

    /**
     * Return the parent class loader for this component.
     */
    @Override
    public ClassLoader getParentClassLoader() {
        if (catalina != null) {
            return (catalina.getParentClassLoader());
        }
        return (ClassLoader.getSystemClassLoader());
    }
======= e0182ef:"java/org/apache/catalina/core/StandardService.java"

    /**
     * Return the parent class loader for this component.
     */
    @Override
    public ClassLoader getParentClassLoader() {
        if (server != null) {
            return (server.getParentClassLoader());
        }
        return (ClassLoader.getSystemClassLoader());
    }
         type="org.apache.catalina.core.StandardContext"
         className="org.apache.catalina.mbeans.ContextMBean">
               
    <operation name="addApplicationListener"
               description="Add a new Listener class name to the set of Listeners configured for this application."
               impact="ACTION"
               returnType="void">
      <parameter name="listener"
                 description="Java class name of a listener class"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addApplicationParameter"
               description="Add a new application parameter for this application."
               impact="ACTION"
               returnType="void">
      <parameter name="listener"
                 description="Java class name of a listener class"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addChild"
               description="Add a child to this Context"
               impact="ACTION"
               returnType="void">
      <parameter name="type"
                 description="Type(classname) of the new child to be added"
                 type="java.lang.String"/>
      <parameter name="name"
                 description="Name of the child to be added"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addInstanceListener"
               description="Add the classname of an InstanceListener to be added to each Wrapper appended to this Context."
               impact="ACTION"
               returnType="void">
      <parameter name="listener"
                 description="Java class name of an InstanceListener class"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addLifecycleListener"
               description="Add a lifecycle listener to this Context"
               impact="ACTION"
               returnType="void">
      <parameter name="type"
                 description="Type(classname) of the new lifecycle listener to be added"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addLocaleEncodingMappingParameter"
               description="Add a Locale Encoding Mapping"
               impact="ACTION"
               returnType="void">
      <parameter name="locale"
                 description="Locale to map an encoding for"
                 type="java.lang.String"/>
      <parameter name="encoding"
                 description="Encoding to be used for a give locale"
                 type="java.lang.String"/>
    </operation>
    <operation name="addMimeMapping"
               description="Add a new MIME mapping, replacing any existing mapping for the specified extension."
               impact="ACTION"
               returnType="void">
      <parameter name="extension"
                 description="Filename extension being mapped"
                 type="java.lang.String"/>
      <parameter name="mimeType"
                 description="Corresponding MIME type"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addParameter"
               description="Add a new context initialization parameter, replacing any existing value for the specified name."
               impact="ACTION"
               returnType="void">
      <parameter name="name"
                 description="Name of the new parameter"
                 type="java.lang.String"/>
      <parameter name="value"
                 description="Value of the new  parameter"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addRoleMapping"
               description="Add a security role reference for this web application."
               impact="ACTION"
               returnType="void">
      <parameter name="role"
                 description="Security role used in the application"
                 type="java.lang.String"/>
      <parameter name="link"
                 description="Actual security role to check for"
                 type="java.lang.String"/>
    </operation>
    <operation name="addSecurityRole"
               description="Add a new security role for this web application."
               impact="ACTION"
               returnType="void">
      <parameter name="role"
                 description="New security role"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addServletMapping"
               description="Add a new servlet mapping, replacing any existing mapping for the specified pattern."
               impact="ACTION"
               returnType="void">
      <parameter name="pattern"
                 description="URL pattern to be mapped"
                 type="java.lang.String"/>
      <parameter name="name"
                 description="Name of the corresponding servlet to execute"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addServletMapping"
               description="Add a new servlet mapping, replacing any existing mapping for the specified pattern."
               impact="ACTION"
               returnType="void">
      <parameter name="pattern"
                 description="URL pattern to be mapped"
                 type="java.lang.String"/>
      <parameter name="name"
                 description="Name of the corresponding servlet to execute"
                 type="java.lang.String"/>
      <parameter name="jspWildcard"
                 description="'true' if name identifies the JspServlet and pattern contains a wildcard; 'false' otherwise"
                 type="boolean"/>
    </operation>
    
               returnType="java.lang.String">
      <parameter name="valveType"
                 description="Type(classname) of the new valve to be added"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addWatchedResource"
               description=" Add a resource which will be watched for reloading by the host auto deployer."
               impact="ACTION"
      <parameter name="name"
                 description="Path to the resource, relative to docBase"
                 type="java.lang.String"/>
    <operation name="addWelcomeFile"
               description="Add a new welcome file to the set recognized by this Context."
      <parameter name="name"
                 description="New welcome file name"
                 type="java.lang.String"/>
    <operation name="addWrapperLifecycle"
               description="Add the classname of a LifecycleListener to be added to each Wrapper appended to this Context."
                 description="Java class name of a LifecycleListener class"
                 type="java.lang.String"/>
    <operation name="addWrapperListener"
               description="Add the classname of a ContainerListener to be added to each Wrapper appended to this Context."
                 description="Java class name of a ContainerListener class"
                 type="java.lang.String"/>
    <operation name="destroy"
               description="Destroy the context"
    <operation name="findApplicationListeners"
               description="Return the set of application listener class names configured for this application."
               impact="INFO"
               returnType="[Ljava.lang.String;">    
    </operation>
    
    <operation name="findApplicationParameters"
               description="Return the set of application parameters for this application."
               impact="INFO"
               returnType="java.lang.String">    
    </operation>
    
    <operation name="findConstraints"
               description="Return the set of security constraints for this web application. If there are none, a zero-length array is returned."
               impact="INFO"
               returnType="java.lang.String">    
    </operation>
    
    <operation name="findErrorPage"
               description="Return the error page entry for the specified HTTP error code, if any; otherwise return null"
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="errorCode"
                 description="Error code to look up"
                 type="int"/>
    </operation>
    
    <operation name="findErrorPage"
               description="Return the error page entry for the specified Java exception type, if any; otherwise return null."
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="exceptionType"
                 description="Exception type to look up"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="findErrorPages"
               description="Return the set of defined error pages for all specified error codes and exception types."
               impact="INFO"
               returnType="[Ljava.lang.String;">    
    </operation>
    
    <operation name="findFilterDef"
               description="Return the filter definition for the specified filter name, if any; otherwise return null."
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="exceptionType"
                 description="Exception type to look up"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="findFilterDefs"
               description="Return the set of defined filters for this Context."
               impact="INFO"
               returnType="[Ljava.lang.String;">    
    </operation>
    
    <operation name="findFilterMaps"
               description="Return the set of filter mappings for this Context."
               impact="INFO"
               returnType="[Ljava.lang.String;">    
    </operation>
    
    <operation name="findInstanceListeners"
               description="Return the set of InstanceListener classes that will be added to newly created Wrappers automatically."
               impact="INFO"
               returnType="[Ljava.lang.String;">    
    </operation>
    
    <operation name="findMimeMapping"
               description="Return the MIME type to which the specified extension is mapped, if any; otherwise return null."
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="extension"
                 description="Extension to map to a MIME type"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="findMimeMappings"
               description="Return the extensions for which MIME mappings are defined."
               impact="ACTION"
               returnType="[Ljava.lang.String;">
    </operation>
    
    <operation name="findParameter"
               description="Return the value for the specified context initialization parameter name, if any; otherwise return null."
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="name"
                 description="Name of the parameter to return"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="findParameters"
               description="Return the names of all defined context initialization parameters for this Context."
               impact="ACTION"
               returnType="[Ljava.lang.String;">
    </operation>
    
    <operation name="findRoleMapping"
               description="For the given security role (as used by an application), return the corresponding role name (as defined by the underlying Realm) if there is one.  Otherwise, return the specified role unchanged."
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="role"
                 description="Security role to map"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="findSecurityRole"
               description="Return 'true' if the specified security role is defined for this application; otherwise return 'false'."
               impact="ACTION"
               returnType="boolean">
      <parameter name="role"
                 description="Security role to verify"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="findSecurityRoles"
               description="Return the security roles defined for this application."
               impact="ACTION"
               returnType="[Ljava.lang.String;">
    </operation>
    
    <operation name="findServletMapping"
               description="Return the servlet name mapped by the specified pattern.."
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="pattern"
                 description="Pattern for which a mapping is requested"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="findServletMappings"
               description="Return the patterns of all defined servlet mappings for this Context."
               impact="ACTION"
               returnType="[Ljava.lang.String;">
    </operation>
    
    <operation name="findStatusPage"
               description="Return the context-relative URI of the error page for the specified HTTP status code."
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="status"
                 description="HTTP status code to look up"
                 type="int"/>
    </operation>
    
    <operation name="findStatusPages"
               description="Return the set of HTTP status codes for which error pages have been specified."
               impact="ACTION"
               returnType="[Lint">
    </operation>
    
    <operation name="findWatchedResources"
               description="Return the set of watched resources for this Context."
               impact="ACTION"
               returnType="[Ljava.lang.String;">
    </operation>
    
    <operation name="findWelcomeFile"
               description="Return 'true' if the specified welcome file is defined for this Context; otherwise return 'false'."
               impact="ACTION"
               returnType="boolean">
      <parameter name="name"
                 description="Welcome file to verify"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="findWelcomeFiles"
               description="Return the set of welcome files defined for this Context."
               impact="ACTION"
               returnType="[Ljava.lang.String;">
    </operation>
    
    <operation name="findWrapperLifecycles"
               description="Return the set of LifecycleListener classes that will be added to newly created Wrappers automatically."
               impact="ACTION"
               returnType="[Ljava.lang.String;">
    </operation>
    
    <operation name="findWrapperListeners"
               description="Return the set of ContainerListener classes that will be added to newly created Wrappers automatically."
               impact="ACTION"
               returnType="[Ljava.lang.String;">
    </operation>
    
    <operation name="reload"
               description="Reload the webapplication"
    <operation name="removeApplicationListener"
               description="Remove the specified application listener class from the set of listeners for this application."
               impact="ACTION"
               returnType="void">
      <parameter name="listener"
                 description="Java class name of the listener to be removed"
                 type="java.lang.String"/>
    </operation>   
    <operation name="removeApplicationParameter"
               description="Remove the application parameter with the specified name from the set for this application."
               impact="ACTION"
               returnType="void">
      <parameter name="name"
                 description="Name of the application parameter to remove"
                 type="java.lang.String"/>
    </operation> 
    
    <operation name="removeChild"
               description="Remove a child from this Context"
               impact="ACTION"
               returnType="void">
      <parameter name="name"
                 description="Name of the existing child Container to be removed"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="removeInstanceListener"
               description="Remove the application parameter with the specified name from the set for this application."
               impact="ACTION"
               returnType="void">
      <parameter name="listener"
                 description="Class name of an InstanceListener class to be removed"
                 type="java.lang.String"/>
    </operation>        
    
    <operation name="removeLifecycleListeners"
               description="Removes lifecycle listeners of given class type from this Context"
               impact="ACTION"
               returnType="void">
      <parameter name="listener"
                 description="Type(classname) of the lifecycle listeners to be removed"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="removeMimeMapping"
               description="Remove the MIME mapping for the specified extension, if it exists; otherwise, no action is taken.."
               impact="ACTION"
               returnType="void">
      <parameter name="extension"
                 description="Extension to remove the mapping for"
                 type="java.lang.String"/>
    </operation> 
    
    <operation name="removeParameter"
               description="Remove the context initialization parameter with the specified name, if it exists; otherwise, no action is taken."
               impact="ACTION"
               returnType="void">
      <parameter name="name"
                 description="Name of the parameter to remove"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="removeRoleMapping"
               description="Remove any security role reference for the specified name"
               impact="ACTION"
               returnType="void">
      <parameter name="role"
                 description="Security role (as used in the application) to remove"
                 type="java.lang.String"/>
    </operation>  
    
    <operation name="removeSecurityRole"
               description="Remove any security role with the specified name."
               impact="ACTION"
               returnType="void">
      <parameter name="role"
                 description="Security role to remove"
                 type="java.lang.String"/>
    </operation> 
    
    <operation name="removeServletMapping"
               description="Remove any servlet mapping for the specified pattern, if it exists; otherwise, no action is taken."
               impact="ACTION"
               returnType="void">
      <parameter name="pattern"
                 description="URL pattern of the mapping to remove"
                 type="java.lang.String"/>
    </operation> 
    
    <operation name="removeValve"
               description="Remove a valve from this Context"
               impact="ACTION"
               returnType="void">
      <parameter name="valveName"
                 description="Objectname of the valve to be removed"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="removeWatchedResource"
               description="Remove the specified watched resource name from the list associated with this Context."
               impact="ACTION"
               returnType="void">
      <parameter name="name"
                 description="Name of the watched resource to be removed"
                 type="java.lang.String"/>
    </operation> 
    
    <operation name="removeWelcomeFile"
               description="Remove the specified welcome file name from the list recognized by this Context."
               impact="ACTION"
               returnType="void">
      <parameter name="name"
                 description="Name of the welcome file to be removed"
                 type="java.lang.String"/>
    </operation> 
    
    <operation name="removeWrapperLifecycle"
               description="Remove a class name from the set of LifecycleListener classes that will be added to newly created Wrappers."
               impact="ACTION"
               returnType="void">
      <parameter name="listener"
                 description="Class name of a LifecycleListener class to be removed"
                 type="java.lang.String"/>
    </operation> 
    
    <operation name="removeWrapperListener"
               description="Remove a class name from the set of ContainerListener classes that will be added to newly created Wrappers."
               impact="ACTION"
               returnType="void">
      <parameter name="listener"
                 description="Class name of a ContainerListener class to be removed"
                 type="java.lang.String"/>
    <operation name="start" 
               description="Start" 
               impact="ACTION" 
               returnType="void" /> 
    <operation name="stop" 
               description="Stop" 
               impact="ACTION" 
               returnType="void" /> 
    
         group="Engine"
         className="org.apache.catalina.mbeans.ContainerMBean">
               writeable="false"/>  
               
      <parameter name="type"
                 description="Type(classname) of the new child to be added"
                 type="java.lang.String"/>
      <parameter name="name"
                 description="Name of the child to be added"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addLifecycleListener"
               description="Add a lifecycle listener to this Engine"
               impact="ACTION"
               returnType="void">
      <parameter name="type"
                 description="Type(classname) of the new lifecycle listener to be added"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addValve"
               description="Add a valve to this Engine"
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="valveType"
                 description="Type(classname) of the new valve to be added"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="destroy" 
               description="Destroy" 
               impact="ACTION" 
               returnType="void" />
               
    <operation name="init" 
               description="Init" 
               impact="ACTION" 
               returnType="void" />
    
    <operation name="removeChild"
               description="Remove a child(Host) from this Engine"
               impact="ACTION"
               returnType="void">
      <parameter name="name"
                 description="Name of the existing child Container to be removed"
                 type="java.lang.String"/>
    <operation name="removeLifecycleListeners"
               description="Removes lifecycle listeners of given class type from this Engine"
               impact="ACTION"
               returnType="void">
      <parameter name="listener"
                 description="Type(classname) of the lifecycle listeners to be removed"
                 type="java.lang.String"/>
    </operation>    
    
    <operation name="removeValve"
               description="Remove a valve from this Engine"
               impact="ACTION"
               returnType="void">
      <parameter name="valveName"
                 description="Objectname of the valve to be removed"
                 type="java.lang.String"/>
    </operation>  
    
    <operation name="start" 
               description="Start" 
               impact="ACTION" 
               returnType="void" /> 
    
    <operation name="stop" 
               description="Stop" 
               impact="ACTION" 
               returnType="void" />
         type="org.apache.catalina.core.StandardHost"
         className="org.apache.catalina.mbeans.ContainerMBean">
               type="boolean"/> 
               
               
    <operation name="addChild"
               description="Add a child(Context) to this Host"
               impact="ACTION"
               returnType="void">
      <parameter name="type"
                 description="Type(classname) of the new child to be added"
                 type="java.lang.String"/>
      <parameter name="name"
                 description="Name of the child to be added"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addLifecycleListener"
               description="Add a lifecycle listener to this Host"
               impact="ACTION"
               returnType="void">
      <parameter name="type"
                 description="Type(classname) of the new lifecycle listener to be added"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addValve"
               description="Add a valve to this Host"
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="valveType"
                 description="Type(classname) of the new valve to be added"
                 type="java.lang.String"/>
    </operation>
                   
    <operation name="destroy" 
               description="Destroy" 
               impact="ACTION" 
               returnType="void" />
               
    <operation name="findReloadedContextMemoryLeaks"
               description="Provide a list of contexts that have leaked memory on reload. This will attempt to force a full garbage collection. Use with extreme caution on production systems."
               impact="ACTION"
               returnType="[Ljava.lang.String;" />
               
    <operation name="init" 
               description="Init" 
               impact="ACTION" 
               returnType="void" />
               
    <operation name="removeChild"
               description="Remove a child(Context) from this Host"
               impact="ACTION"
               returnType="void">
      <parameter name="name"
                 description="Name of the existing child Container to be removed"
                 type="java.lang.String"/>
    </operation>
    <operation name="removeLifecycleListeners"
               description="Removes lifecycle listeners of given class type from this Host"
               returnType="void">
      <parameter name="listener"
                 description="Type(classname) of the lifecycle listeners to be removed"
                 type="java.lang.String"/>
    </operation>  
    
    <operation name="removeValve"
               description="Remove a valve from this Host"
               impact="ACTION"
               returnType="void">
      <parameter name="valveName"
                 description="Objectname of the valve to be removed"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="start" 
               description="Start" 
               impact="ACTION" 
               returnType="void" />
    
    <operation name="stop" 
               description="Stop" 
               impact="ACTION" 
               returnType="void" />
         type="org.apache.catalina.core.StandardService"
         className="org.apache.catalina.mbeans.ServiceMBean">
    <attribute name="managedResource"
               description="The managed resource this MBean is associated with"
               type="java.lang.Object"/>
      
    <attribute name="name"
               description="Unique name of this Service"
               type="java.lang.String"/>
      
      <parameter name="address"
                 description="The IP address on which to bind"
                 type="java.lang.String"/>
      <parameter name="port"
                 description="TCP port number to listen on"
                 type="int"/>
      <parameter name="isAjp"
                 description="Create a AJP/1.3 Connector"
                 type="boolean"/>
      <parameter name="isSSL"
                 description="Create a secure Connector"
                 type="boolean"/>
    <operation name="addExecutor"
               description="Adds a named executor to the service"
               impact="ACTION"
               returnType="void">
      <parameter name="type"
                 description="Classname of the Executor to be added"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="findConnectors"
               description="Find and return the set of Connectors associated with this Service"
               impact="ACTION"
               returnType="[Ljava.lang.String;">
    </operation>
    <operation name="findExecutors"
               description="Retrieves all executors"
               impact="ACTION"
               returnType="[Ljava.lang.String;">
    </operation>
    
    <operation name="getExecutor"
               description="Retrieves executor by name"
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="name"
                 description="Name of the executor to be retrieved"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="start" 
               description="Start" 
               impact="ACTION" 
               returnType="void" />
               
    <operation name="stop" 
               description="Stop" 
               impact="ACTION" 
               returnType="void" />
         type="org.apache.catalina.core.StandardWrapper"
         className="org.apache.catalina.mbeans.ContainerMBean">
               
    <operation name="addInitParameter"
               description="Add a valve to this Wrapper"
               impact="ACTION"
               returnType="void">
      <parameter name="name"
                 description="Name of this initialization parameter to add"
                 type="java.lang.String"/>
      <parameter name="value"
                 description="Value of this initialization parameter to add"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addLifecycleListener"
               description="Add a lifecycle listener to this Wrapper"
               impact="ACTION"
               returnType="void">
      <parameter name="type"
                 description="Type(classname) of the new lifecycle listener to be added"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addMapping"
               description="Add a mapping associated with the Wrapper."
               impact="ACTION"
               returnType="void">
      <parameter name="mapping"
                 description="The new wrapper mapping"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addSecurityReference"
               description="Add a new security role reference record to the set of records for this servlet."
               impact="ACTION"
               returnType="void">
      <parameter name="name"
                 description="Role name used within this servlet"
                 type="java.lang.String"/>
      <parameter name="link"
                 description="Role name used within the web application"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="addValve"
               description="Add a valve to this Wrapper"
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="valveType"
                 description="Type(classname) of the new valve to be added"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="findInitParameter"
               description="Add a mapping associated with the Wrapper."
               impact="ACTION"
               returnType="void">
      <parameter name="mapping"
                 description="The new wrapper mapping"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="findInitParameters"
               description="Return the names of all defined initialization parameters for this servlet."
               impact="INFO"
               returnType="[Ljava.lang.String;">
    </operation>
    <operation name="findSecurityReference"
               description="Return the security role link for the specified security role reference name."
               impact="ACTION"
               returnType="java.lang.String">
      <parameter name="name"
                 description="Security role reference used within this servle"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="findSecurityReferences"
               description="Return the set of security role reference names associated with this servlet"
               impact="INFO"
               returnType="[Ljava.lang.String;">
    </operation>
    
    <operation name="removeInitParameter"
               description="Remove the specified initialization parameter from this servlet."
      <parameter name="name"
                 description="Name of the initialization parameter to remove"
                 type="java.lang.String"/>
    <operation name="removeLifecycleListeners"
               description="Removes lifecycle listeners of given class type from this Wrapper"
                 description="Type(classname) of the lifecycle listeners to be removed"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="removeMapping"
               description="Remove a mapping associated with the wrapper."
               impact="ACTION"
               returnType="void">
      <parameter name="mapping"
                 description="The pattern to remove"
                 type="java.lang.String"/>
    </operation>
    
    <operation name="removeSecurityReference"
               description="Remove any security role reference for the specified role name."
               impact="ACTION"
               returnType="void">
      <parameter name="name"
                 description="Security role used within this servlet to be removeds"
                 type="java.lang.String"/>
    
    <operation name="removeValve"
               description="Remove a valve from this Wrapper"
               impact="ACTION"
               returnType="void">
      <parameter name="valveName"
                 description="Objectname of the valve to be removed"
                 type="java.lang.String"/>
    </operation>
   
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    /**
     * Construct a <code>ModelMBean</code> with default
     * <code>ModelMBeanInfo</code> information.
     *
     * @exception MBeanException if the initializer of an object
     *  throws an exception
     * @exception RuntimeOperationsException if an IllegalArgumentException
     *  occurs
     */
    public ContainerMBean() 
        throws MBeanException, RuntimeOperationsException {
        
        super();
    }
    
    /**
     * Add a new child Container to those associated with this Container,
     * if supported. Won't start the child yet. Has to be started with a call to
     * Start method after necessary configurations are done.
     * 
     * @param type ClassName of the child to be added
     * @param name Name of the child to be added
     * 
     * @exception MBeanException if the child cannot be added
     */
    public void addChild(String type, String name) throws MBeanException{ 
        Container contained = null;
        try {
            contained = (Container)Class.forName(type).newInstance();
            contained.setName(name);
            
            if(contained instanceof StandardHost){
                HostConfig config = new HostConfig();
                contained.addLifecycleListener(config);
            } else if(contained instanceof StandardContext){
                ContextConfig config = new ContextConfig();
                contained.addLifecycleListener(config);
            }
        } catch (InstantiationException e) {
            throw new MBeanException(e);
        } catch (IllegalAccessException e) {
            throw new MBeanException(e);
        } catch (ClassNotFoundException e) {
            throw new MBeanException(e);
        }
        
        boolean oldValue= true;
        
        ContainerBase container = null;
        try {
            container = (ContainerBase)getManagedResource();
            oldValue = container.getStartChildren();
            container.setStartChildren(false);
            container.addChild(contained);
            contained.init();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        } catch (LifecycleException e){
            throw new MBeanException(e);
        } finally {
            if(container != null) {
                container.setStartChildren(oldValue);
            }
        }
    }
    
    /**
     * Remove an existing child Container from association with this parent
     * Container.
     *
     * @param name Name of the existing child Container to be removed
     */
    public void removeChild(String name) throws MBeanException{
        if(name != null){
            try {
                Container container = (Container)getManagedResource();
                Container contained = container.findChild(name);
                container.removeChild(contained);
            } catch (InstanceNotFoundException e) {
                throw new MBeanException(e);
            } catch (RuntimeOperationsException e) {
                throw new MBeanException(e);
            } catch (InvalidTargetObjectTypeException e) {
                throw new MBeanException(e);
            }
        }
    }
    
    /**
     * Adds a valve to this Container instance.
     *
     * @param valveType ClassName of the valve to be added
     * 
     * @exception MBeanException if a component cannot be removed
     */
    public String addValve(String valveType) throws MBeanException{ 
        Valve valve = null;
        try {
            valve = (Valve)Class.forName(valveType).newInstance();
        } catch (InstantiationException e) {
            throw new MBeanException(e);
        } catch (IllegalAccessException e) {
            throw new MBeanException(e);
        } catch (ClassNotFoundException e) {
            throw new MBeanException(e);
        }
        
        if (valve == null) {
            return null;
        }
            
        try {
            ContainerBase container = (ContainerBase)getManagedResource();
            container.addValve(valve);
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        return ((LifecycleMBeanBase)valve).getObjectName().toString();
    }
    
    /**
     * Remove an existing Valve.
     *
     * @param name MBean Name of the component to remove
     *
     * @exception MBeanException if a component cannot be removed
     */
    public void removeValve(String valveName) throws MBeanException{
        ContainerBase container=null;
        try {
            container = (ContainerBase)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        ObjectName oname;
        try {
            oname = new ObjectName(valveName);
        } catch (MalformedObjectNameException e) {
            throw new MBeanException(e);
        } catch (NullPointerException e) {
            throw new MBeanException(e);
        }
        
        if(container != null){
            Valve[] valves = container.getPipeline().getValves();
            for (int i = 0; i < valves.length; i++) {
                ObjectName voname = ((ValveBase) valves[i]).getObjectName();
                if (voname.equals(oname)) {
                    container.getPipeline().removeValve(valves[i]);
                }
            }
        }
    }
    
    /**
     * Add a LifecycleEvent listener to this component.
     *
     * @param type ClassName of the listener to add
     */
    public void addLifeCycleListener(String type) throws MBeanException{
        LifecycleListener listener = null;
        try {
            listener = (LifecycleListener)Class.forName(type).newInstance();
        } catch (InstantiationException e) {
            throw new MBeanException(e);
        } catch (IllegalAccessException e) {
            throw new MBeanException(e);
        } catch (ClassNotFoundException e) {
            throw new MBeanException(e);
        }
        
        if(listener != null){
            try {
                ContainerBase container = (ContainerBase)getManagedResource();
                container.addLifecycleListener(listener);
            } catch (InstanceNotFoundException e) {
                throw new MBeanException(e);
            } catch (RuntimeOperationsException e) {
                throw new MBeanException(e);
            } catch (InvalidTargetObjectTypeException e) {
                throw new MBeanException(e);
            }
        }
    }
    
    /**
     * Remove a LifecycleEvent listeners from this component.
     *
     * @param listener The ClassName of the listeners to be removed. 
     * Note that all the listeners having given ClassName will be removed. 
     */
    public void removeLifeCycleListeners(String type) throws MBeanException{
        ContainerBase container=null;
        try {
            container = (ContainerBase)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        LifecycleListener[] listeners = container.findLifecycleListeners();
        for(LifecycleListener listener: listeners){
            if(listener.getClass().equals(type)){
                container.removeLifecycleListener(listener);
            }
        }
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    public ContextMBean() throws MBeanException, RuntimeOperationsException {
        
        super();
    }
    
     /**
     * Return the set of application parameters for this application.
     */
    public String[] findApplicationParameters() throws MBeanException {
        
        Context context; 
        try {
            context = (Context)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        ApplicationParameter[] params = context.findApplicationParameters();
        String[] stringParams = new String[params.length];
        for(int counter=0; counter < params.length; counter++){
           stringParams[counter]=params[counter].toString();
        }
        
        return stringParams;
        
    }
    
    /**
     * Return the security constraints for this web application.
     * If there are none, a zero-length array is returned.
     */
    public String[] findConstraints() throws MBeanException {
        Context context; 
        try {
            context = (Context)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        SecurityConstraint[] constraints = context.findConstraints();
        String[] stringConstraints = new String[constraints.length];
        for(int counter=0; counter < constraints.length; counter++){
            stringConstraints[counter]=constraints[counter].toString();
        }
        
        return stringConstraints;
        
    }
    
    /**
     * Return the error page entry for the specified HTTP error code,
     * if any; otherwise return <code>null</code>.
     *
     * @param errorCode Error code to look up
     */
    public String findErrorPage(int errorCode) throws MBeanException {
        Context context; 
        try {
            context = (Context)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        return context.findErrorPage(errorCode).toString();
        
    }
    
    /**
     * Return the error page entry for the specified Java exception type,
     * if any; otherwise return <code>null</code>.
     *
     * @param exceptionType Exception type to look up
     */
    public String findErrorPage(String exceptionType) throws MBeanException {
        Context context; 
        try {
            context = (Context)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        return context.findErrorPage(exceptionType).toString();
        
    }
    
    /**
     * Return the set of defined error pages for all specified error codes
     * and exception types.
     */
    public String[] findErrorPages() throws MBeanException {
        
        Context context; 
        try {
            context = (Context)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        ErrorPage[] pages = context.findErrorPages();
        String[] stringPages = new String[pages.length];
        for(int counter=0; counter < pages.length; counter++){
            stringPages[counter]=pages[counter].toString();
        }
        
        return stringPages;
        
    }
    
    /**
     * Return the filter definition for the specified filter name, if any;
     * otherwise return <code>null</code>.
     *
     * @param filterName Filter name to look up
     */
    public String findFilterDef(String name) throws MBeanException {
        
        Context context; 
        try {
            context = (Context)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        FilterDef filterDef = context.findFilterDef(name);
        return filterDef.toString();
        
    }
    
    /**
     * Return the set of defined filters for this Context.
     */
    public String[] findFilterDefs() throws MBeanException {
        
        Context context; 
        try {
            context = (Context)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        ApplicationParameter[] params = context.findApplicationParameters();
        String[] stringParams = new String[params.length];
        for(int counter=0; counter < params.length; counter++){
            stringParams[counter]=params[counter].toString();
        }
        
        return stringParams;
        
    }
    
    /**
     * Return the set of filter mappings for this Context.
     */
    public String[] findFilterMaps() throws MBeanException {
        
        Context context; 
        try {
            context = (Context)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        FilterMap[] maps = context.findFilterMaps();
        String[] stringMaps = new String[maps.length];
        for(int counter=0; counter < maps.length; counter++){
            stringMaps[counter]=maps[counter].toString();
        }
        
        return stringMaps;
        
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    public ServiceMBean() 
        throws MBeanException, RuntimeOperationsException {
        
        super();
        
    }
    
    /**
     * Add a new Connector to the set of defined Connectors, and associate it
     * with this Service's Container.
     *
     * @param address The IP address on which to bind
     * @param port TCP port number to listen on
     * @param isAjp Create a AJP/1.3 Connector
     * @param isSSL Create a secure Connector
     * 
     * @throws MBeanException 
     */
    public void addConnector(String address, int port, boolean isAjp, boolean isSSL) throws MBeanException {
        
        Service service; 
        try {
            service = (Service)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        Connector connector = new Connector();
        if ((address!=null) && (address.length()>0)) {
            connector.setProperty("address", address);
        }
        
        connector.setPort(port);
        connector.setProtocol(isAjp ? "AJP/1.3" : "HTTP/1.1");
        connector.setSecure(isSSL);
        connector.setScheme(isSSL ? "https" : "http");
        service.addConnector(connector);       
    }
    
    /**
     * Adds a named executor to the service
     * @param type Classname of the Executor to be added
     * @throws MBeanException 
     */
    public void addExecutor(String type) throws MBeanException {
        
        Service service; 
        try {
            service = (Service)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        Executor executor;
        try {
             executor = (Executor)Class.forName(type).newInstance();
        } catch (InstantiationException e) {
            throw new MBeanException(e);
        } catch (IllegalAccessException e) {
            throw new MBeanException(e);
        } catch (ClassNotFoundException e) {
            throw new MBeanException(e);
        }
        
        service.addExecutor(executor);
        
    }
    
    /**
     * Find and return the set of Connectors associated with this Service.
     * @throws MBeanException 
     */
    public String[] findConnectors() throws MBeanException {
        
        Service service; 
        try {
            service = (Service)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        Connector[] connectors = service.findConnectors(); 
        String[] str = new String[connectors.length];
        
        for(int i=0; i< connectors.length; i++){
            str[i] = connectors[i].toString();
        }
        
        return str;
    }
    
    /**
     * Retrieves all executors
     * @throws MBeanException 
     */
    public String[] findExecutors() throws MBeanException {
        Service service; 
        try {
            service = (Service)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        Executor[] executors = service.findExecutors();
        String[] str = new String[executors.length];
        
        for(int i=0; i< executors.length; i++){
            str[i] = executors[i].toString();
        }
        
        return str;
    }
    
    /**
     * Retrieves executor by name
     * @param name Name of the executor to be retrieved
     * @throws MBeanException 
     */
    public String getExecutor(String name) throws MBeanException{
       
        Service service; 
        try {
            service = (Service)getManagedResource();
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }
        
        Executor executor = service.getExecutor(name);
        return executor.toString();
        
    }
======= e0182ef:"java/org/apache/catalina/startup/Catalina.java"

    public ClassLoader getParentClassLoader() {
        return parentClassLoader;
    }
======= e0182ef:"java/org/apache/catalina/startup/Catalina.java"

        getServer().setCatalina(this);
      <fix>
        GSOC 2010. Enable the creation of Services, Engines, Connectors, Hosts
        and Contexts via JMX from a minimal server.xml that contains only a
        Server element. Based on a patch by Chamith Buddhika. (markt)
      </fix>
      

======= 94147b2:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                || method.getName().length() < 4
======= 94147b2:"java/org/apache/catalina/core/DefaultInstanceManager.java"

                    clazz.getName() + "/" + getName(method));
======= 94147b2:"java/org/apache/catalina/core/DefaultInstanceManager.java"

        public static String getName(Method setter) {
            StringBuilder name = new StringBuilder(setter.getName());
            // remove 'set'
            name.delete(0, 3);
            // lowercase first char
            name.setCharAt(0, Character.toLowerCase(name.charAt(0)));
            return name.toString();
        }

======= 64a8346:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

                if (xaConnection == null) {
                    connection.close();
                } else {
                    xaConnection.close();
                }

======= a9f0fd5:"java/org/apache/catalina/realm/CombinedRealm.java"

    /**
     * Descriptive information about this Realm implementation.
     */
    protected static final String name = "CombinedRealm";
======= a9f0fd5:"java/org/apache/catalina/realm/CombinedRealm.java"

        return name;
      <fix>
        <bug>49883</bug>: Ensure that the CombinedRealm returns a name for use
        in log messages rather than throwing an
        <code>UnsupportedOperationException</code>. (markt)
      </fix>

======= cd7263e:"java/org/apache/catalina/connector/Connector.java"

        try {
            protocolHandler.stop();
        } catch (Exception e) {
            throw new LifecycleException
                (sm.getString
                 ("coyoteConnector.protocolHandlerStopFailed", e));
        }
======= cd7263e:"java/org/apache/catalina/core/StandardService.java"

     * @param executorName String
    public Executor getExecutor(String executorName) {
                if (executorName.equals(executor.getName()))
======= cd7263e:"java/org/apache/catalina/core/StandardService.java"

        // Pause connectors first
======= cd7263e:"java/org/apache/catalina/core/StandardService.java"

======= cd7263e:"java/org/apache/catalina/core/StandardService.java"

        // Now stop the connectors
                if (!LifecycleState.STARTED.equals(
                    // Connectors only need stopping if they are currently
                    // started. They may have failed to start or may have been
                    // stopped (e.g. via a JMX call)
======= cd7263e:"java/org/apache/coyote/ProtocolHandler.java"

     * Stop the protocol.
     */
    public void stop() throws Exception;
    /**
======= cd7263e:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

        while (started && !error && !endpoint.isPaused()) {
======= cd7263e:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

        if (!error && !endpoint.isPaused()) {
        if (!async || error || endpoint.isPaused())
======= cd7263e:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    public void stop() throws Exception {
        try {
            endpoint.stop();
        } catch (Exception ex) {
            log.error(sm.getString("ajpprotocol.endpoint.stoperror"), ex);
            throw ex;
        }
    }
    public void destroy() throws Exception {
        if (log.isInfoEnabled())
            log.info(sm.getString("ajpprotocol.destroy", getName()));
======= cd7263e:"java/org/apache/coyote/ajp/AjpProcessor.java"

        while (started && !error && !endpoint.isPaused()) {
======= cd7263e:"java/org/apache/coyote/ajp/AjpProcessor.java"

        if (async && !error && !endpoint.isPaused()) {
======= cd7263e:"java/org/apache/coyote/ajp/AjpProtocol.java"

    public void stop() throws Exception {
        try {
            endpoint.stop();
        } catch (Exception ex) {
            log.error(sm.getString("ajpprotocol.endpoint.stoperror"), ex);
            throw ex;
        }
    }
    public void destroy() throws Exception {
        if (log.isInfoEnabled())
            log.info(sm.getString("ajpprotocol.destroy", getName()));
======= cd7263e:"java/org/apache/coyote/http11/AbstractHttp11Protocol.java"

    public void stop() throws Exception {
        try {
            endpoint.stop();
        } catch (Exception ex) {
            getLog().error(sm.getString("http11protocol.endpoint.stoperror"), ex);
            throw ex;
        }
    }
    @Override
    public void destroy() throws Exception {
        if(getLog().isInfoEnabled())
            getLog().info(sm.getString("http11protocol.destroy", getName()));
======= cd7263e:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        while (!error && keepAlive && !comet && !async && !endpoint.isPaused()) {
======= cd7263e:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        if (error || endpoint.isPaused()) {
            inputBuffer.nextRequest();
            outputBuffer.nextRequest();
            recycle();
            return SocketState.CLOSED;
        } else if (comet  || async) {
            return SocketState.LONG;
======= cd7263e:"java/org/apache/coyote/http11/Http11NioProcessor.java"

        while (!error && keepAlive && !comet && !async && !endpoint.isPaused()) {
======= cd7263e:"java/org/apache/coyote/http11/Http11NioProcessor.java"

        if (error || endpoint.isPaused()) {
            recycle();
            return SocketState.CLOSED;
        } else if (comet || async) {
            return SocketState.LONG;
            if (recycle) {
======= cd7263e:"java/org/apache/coyote/http11/Http11Processor.java"

        while (started && !error && keepAlive && !endpoint.isPaused()) {
======= cd7263e:"java/org/apache/coyote/http11/Http11Processor.java"

        if (error || endpoint.isPaused()) {
======= cd7263e:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    
    public abstract void init() throws Exception;
    
    /**
     * Pause the endpoint, which will stop it accepting new connections.
     */
    public void pause() {
        if (running && !paused) {
            paused = true;
            unlockAccept();
            // Heuristic: Sleep for a while to ensure pause of the endpoint
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // Ignore
            }
        }
    }
    
    /**
     * Resume the endpoint, which will make it start accepting new connections
     * again.
     */
    public void resume() {
        if (running) {
            paused = false;
        }
    }
    
    public abstract void stop() throws Exception;
======= cd7263e:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        if (!paused) {
            pause();
        }
======= cd7263e:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            // During shutdown, executor may be null - avoid NPE
            if (running) {
                getExecutor().execute(new SocketWithOptionsProcessor(socket));
            }
======= cd7263e:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

        if (!paused) {
            pause();
        }
======= cd7263e:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

            // During shutdown, executor may be null - avoid NPE
            if (running) {
                getExecutor().execute(new SocketProcessor(wrapper));
            }
======= cd7263e:"java/org/apache/tomcat/util/net/NioEndpoint.java"

======= cd7263e:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        if (!paused) {
            pause();
        }
      <fix>
        <bug>49802</bug>: Re-factor connector pause, stop and destroy methods so
        that calling any of those methods has the expected results. (markt)
      </fix>

======= 6155a8b:"java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java"

    private List<ElementValuePair> element_value_pairs;
======= 6155a8b:"java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java"

        annotationEntry.element_value_pairs = new ArrayList<ElementValuePair>();
======= 6155a8b:"java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java"

        return element_value_pairs.toArray(new ElementValuePair[element_value_pairs.size()]);
======= 6155a8b:"java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java"

            ElementValuePair envp = element_value_pairs.get(i);
======= 6155a8b:"java/org/apache/tomcat/util/bcel/classfile/Attribute.java"

    private static final Map<String,AttributeReader> readers =
            new HashMap<String,AttributeReader>();
======= 6155a8b:"java/org/apache/tomcat/util/bcel/classfile/Attribute.java"

            AttributeReader r = readers.get(name);
======= 6155a8b:"java/org/apache/tomcat/util/bcel/classfile/JavaClass.java"

        implements Cloneable, Comparable<JavaClass> {
======= 6155a8b:"java/org/apache/tomcat/util/bcel/classfile/JavaClass.java"

            List<AnnotationEntry> accumulatedAnnotations = new ArrayList<AnnotationEntry>();
======= 6155a8b:"java/org/apache/tomcat/util/bcel/classfile/JavaClass.java"

            annotations = accumulatedAnnotations.toArray(new AnnotationEntry[accumulatedAnnotations.size()]);
======= 6155a8b:"java/org/apache/tomcat/util/bcel/classfile/JavaClass.java"

    public int compareTo(JavaClass obj) {
        return getClassName().compareTo(obj.getClassName());
======= 6155a8b:"java/org/apache/tomcat/util/bcel/classfile/Unknown.java"

    private static final Map<String, Unknown> unknown_attributes =
            new HashMap<String, Unknown>();
======= 6155a8b:"java/org/apache/tomcat/util/bcel/classfile/Utility.java"

    private static int unwrap( ThreadLocal<Integer> tl ) {
        return tl.get().intValue();
    private static void wrap( ThreadLocal<Integer> tl, int value ) {
    private static ThreadLocal<Integer> consumed_chars =
            new ThreadLocal<Integer>() {
        protected Integer initialValue() {
      <fix>
        <bug>49876</bug>: Fix the generics warnings in the copied Apache Jakarta
        BCEL code. Based on a patch by Gbor. (markt) 
      </fix>

======= a6620cb:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * Construct a new ClassLoader with no defined repositories and the given
     *
     * @param parent Our parent class loader

======= bcb994c:"java/org/apache/catalina/Globals.java"

    /**
     * Name of the system property containing
     * the tomcat product installation path
     */
    public static final String CATALINA_HOME_PROP = "catalina.home";
    /**
     * Name of the system property containing
     * the tomcat instance installation path
     */
    public static final String CATALINA_BASE_PROP = "catalina.base";
======= bcb994c:"java/org/apache/catalina/connector/Connector.java"

======= bcb994c:"java/org/apache/catalina/connector/Connector.java"

                                       System.getProperty(Globals.CATALINA_BASE_PROP));
======= bcb994c:"java/org/apache/catalina/core/StandardContext.java"

        String base=System.getProperty(Globals.CATALINA_BASE_PROP);
======= bcb994c:"java/org/apache/catalina/core/StandardContext.java"

            new File(System.getProperty(Globals.CATALINA_BASE_PROP), "conf");
======= bcb994c:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

======= bcb994c:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

        configBase = new File(System.getProperty(Globals.CATALINA_BASE_PROP), "conf");
======= bcb994c:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            file = new File(System.getProperty(Globals.CATALINA_BASE_PROP), host
======= bcb994c:"java/org/apache/catalina/manager/ManagerServlet.java"

======= bcb994c:"java/org/apache/catalina/manager/ManagerServlet.java"

            deployed = new File(System.getProperty(Globals.CATALINA_BASE_PROP),
        configBase = new File(System.getProperty(Globals.CATALINA_BASE_PROP), "conf");
======= bcb994c:"java/org/apache/catalina/manager/ManagerServlet.java"

            file = new File(System.getProperty(Globals.CATALINA_BASE_PROP),
======= bcb994c:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

======= bcb994c:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

            file = new File(System.getProperty(Globals.CATALINA_BASE_PROP), file.getPath());
======= bcb994c:"java/org/apache/catalina/manager/host/HostManagerServlet.java"

            new File(System.getProperty(Globals.CATALINA_BASE_PROP), "conf");
======= bcb994c:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

======= bcb994c:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

            file = new File(System.getProperty(Globals.CATALINA_BASE_PROP), pathname);
======= bcb994c:"java/org/apache/catalina/realm/MemoryRealm.java"

======= bcb994c:"java/org/apache/catalina/realm/MemoryRealm.java"

            file = new File(System.getProperty(Globals.CATALINA_BASE_PROP), pathname);
======= bcb994c:"java/org/apache/catalina/startup/Bootstrap.java"

======= bcb994c:"java/org/apache/catalina/startup/Bootstrap.java"

    protected static final String CATALINA_HOME_TOKEN = "${" + Globals.CATALINA_HOME_PROP + "}";
    protected static final String CATALINA_BASE_TOKEN = "${" + Globals.CATALINA_BASE_PROP + "}";
======= bcb994c:"java/org/apache/catalina/startup/Bootstrap.java"

        System.setProperty(Globals.CATALINA_HOME_PROP, s);
        System.setProperty(Globals.CATALINA_BASE_PROP, s);
======= bcb994c:"java/org/apache/catalina/startup/Bootstrap.java"

        if (System.getProperty(Globals.CATALINA_BASE_PROP) != null)
        if (System.getProperty(Globals.CATALINA_HOME_PROP) != null)
            System.setProperty(Globals.CATALINA_BASE_PROP,
                               System.getProperty(Globals.CATALINA_HOME_PROP));
            System.setProperty(Globals.CATALINA_BASE_PROP,
======= bcb994c:"java/org/apache/catalina/startup/Bootstrap.java"

        if (System.getProperty(Globals.CATALINA_HOME_PROP) != null)
                    (Globals.CATALINA_HOME_PROP, 
                System.setProperty(Globals.CATALINA_HOME_PROP,
            System.setProperty(Globals.CATALINA_HOME_PROP,
======= bcb994c:"java/org/apache/catalina/startup/Bootstrap.java"

        return System.getProperty(Globals.CATALINA_HOME_PROP,
======= bcb994c:"java/org/apache/catalina/startup/Bootstrap.java"

        return System.getProperty(Globals.CATALINA_BASE_PROP, getCatalinaHome());
======= bcb994c:"java/org/apache/catalina/startup/Catalina.java"

======= bcb994c:"java/org/apache/catalina/startup/Catalina.java"

            file = new File(System.getProperty(Globals.CATALINA_BASE_PROP), configFile);
======= bcb994c:"java/org/apache/catalina/startup/Catalina.java"

        String catalinaHome = System.getProperty(Globals.CATALINA_HOME_PROP);
            } else if (System.getProperty(Globals.CATALINA_BASE_PROP) != null) {
                catalinaHome = System.getProperty(Globals.CATALINA_BASE_PROP);
                    (Globals.CATALINA_HOME_PROP, Globals.CATALINA_BASE_PROP, "catalina.jar");
                        ("tomcat.install", Globals.CATALINA_HOME_PROP, "tomcat.jar");
======= bcb994c:"java/org/apache/catalina/startup/Catalina.java"

            System.setProperty(Globals.CATALINA_HOME_PROP, catalinaHome);
        if (System.getProperty(Globals.CATALINA_BASE_PROP) == null) {
            System.setProperty(Globals.CATALINA_BASE_PROP,
            String catalinaBase = System.getProperty(Globals.CATALINA_BASE_PROP);
======= bcb994c:"java/org/apache/catalina/startup/Catalina.java"

            System.setProperty(Globals.CATALINA_BASE_PROP, catalinaBase);
======= bcb994c:"java/org/apache/catalina/startup/CatalinaProperties.java"

======= bcb994c:"java/org/apache/catalina/startup/CatalinaProperties.java"

        ClassLoader cl = CatalinaProperties.class.getClassLoader();
        System.err.println("CatalinaProprties: cl=" + cl.toString());
        if ((cl = cl.getParent()) != null) {
            System.err.println("CatalinaProprties: parent cl=" + cl.toString());
        }
======= bcb994c:"java/org/apache/catalina/startup/CatalinaProperties.java"

        return System.getProperty(Globals.CATALINA_HOME_PROP,
======= bcb994c:"java/org/apache/catalina/startup/CatalinaProperties.java"

        return System.getProperty(Globals.CATALINA_BASE_PROP, getCatalinaHome());
======= bcb994c:"java/org/apache/catalina/startup/Embedded.java"

======= bcb994c:"java/org/apache/catalina/startup/Embedded.java"

    public void setCatalinaHome(String s) {
        System.setProperty(Globals.CATALINA_HOME_PROP, s);
    public void setCatalinaBase(String s) {
        System.setProperty(Globals.CATALINA_BASE_PROP, s);
        return System.getProperty(Globals.CATALINA_HOME_PROP);
        return System.getProperty(Globals.CATALINA_BASE_PROP);
======= bcb994c:"java/org/apache/catalina/startup/Embedded.java"

        String catalinaHome = System.getProperty(Globals.CATALINA_HOME_PROP);
            } else if (System.getProperty(Globals.CATALINA_BASE_PROP) != null) {
                catalinaHome = System.getProperty(Globals.CATALINA_BASE_PROP);
                    (Globals.CATALINA_HOME_PROP, Globals.CATALINA_BASE_PROP, "catalina.jar");
                        ("tomcat.install", Globals.CATALINA_HOME_PROP, "tomcat.jar");
======= bcb994c:"java/org/apache/catalina/startup/Embedded.java"

            System.setProperty(Globals.CATALINA_HOME_PROP, catalinaHome);
        if (System.getProperty(Globals.CATALINA_BASE_PROP) == null) {
            System.setProperty(Globals.CATALINA_BASE_PROP,
            String catalinaBase = System.getProperty(Globals.CATALINA_BASE_PROP);
======= bcb994c:"java/org/apache/catalina/startup/Embedded.java"

            System.setProperty(Globals.CATALINA_BASE_PROP, catalinaBase);
======= bcb994c:"java/org/apache/catalina/startup/ExpandWar.java"

======= bcb994c:"java/org/apache/catalina/startup/ExpandWar.java"

            appBase = new File(System.getProperty(Globals.CATALINA_BASE_PROP),
======= bcb994c:"java/org/apache/catalina/startup/ExpandWar.java"

            appBase = new File(System.getProperty(Globals.CATALINA_BASE_PROP),
======= bcb994c:"java/org/apache/catalina/startup/HostConfig.java"

======= bcb994c:"java/org/apache/catalina/startup/HostConfig.java"

        File base = new File(System.getProperty(Globals.CATALINA_BASE_PROP));
======= bcb994c:"java/org/apache/catalina/startup/Tomcat.java"

======= bcb994c:"java/org/apache/catalina/startup/Tomcat.java"

            basedir = System.getProperty(Globals.CATALINA_BASE_PROP);
            basedir = System.getProperty(Globals.CATALINA_HOME_PROP);
======= bcb994c:"java/org/apache/catalina/startup/Tomcat.java"

        System.setProperty(Globals.CATALINA_HOME_PROP, basedir);
        System.setProperty(Globals.CATALINA_BASE_PROP, basedir);
======= bcb994c:"java/org/apache/catalina/startup/Tool.java"

======= bcb994c:"java/org/apache/catalina/startup/Tool.java"

    private static String catalinaHome = System.getProperty(Globals.CATALINA_HOME_PROP);
======= bcb994c:"java/org/apache/catalina/startup/Tool.java"

            log.error("Must set '" + Globals.CATALINA_HOME_PROP + "' system property");
======= bcb994c:"java/org/apache/catalina/users/MemoryUserDatabase.java"

======= bcb994c:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                    file = new File(System.getProperty(Globals.CATALINA_BASE_PROP),
======= bcb994c:"java/org/apache/catalina/users/MemoryUserDatabase.java"

            file = new File(System.getProperty(Globals.CATALINA_BASE_PROP),
======= bcb994c:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                new File(System.getProperty(Globals.CATALINA_BASE_PROP), pathnameNew);
======= bcb994c:"java/org/apache/catalina/users/MemoryUserDatabase.java"

                new File(System.getProperty(Globals.CATALINA_BASE_PROP), pathnameOld);
                new File(System.getProperty(Globals.CATALINA_BASE_PROP), pathname);
======= bcb994c:"java/org/apache/catalina/valves/AccessLogValve.java"

======= bcb994c:"java/org/apache/catalina/valves/AccessLogValve.java"

            dir = new File(System.getProperty(Globals.CATALINA_BASE_PROP), directory);
======= bcb994c:"java/org/apache/jasper/compiler/AntCompiler.java"

======= bcb994c:"java/org/apache/jasper/compiler/AntCompiler.java"

        if (System.getProperty(Globals.CATALINA_HOME_PROP) != null) {
            project.setBasedir(System.getProperty(Globals.CATALINA_HOME_PROP));
======= bcb994c:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

======= bcb994c:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

        String file = adjustRelativePath(s, System.getProperty(Globals.CATALINA_BASE_PROP));
======= bcb994c:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

        String file = adjustRelativePath(s, System.getProperty(Globals.CATALINA_BASE_PROP));
======= bcb994c:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

======= bcb994c:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

                    keyStoreFile = new File(System.getProperty(Globals.CATALINA_BASE_PROP),
======= bcb994c:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

            crlFile = new File(System.getProperty(Globals.CATALINA_BASE_PROP), crlf);
      <update>
        <bug>48967</bug>: Replace strings "catalina.base" and "catalina.home"
        by globally defined constants. Patch provided by Marc Guillemot. (rjung)
      </update>

======= e641f20:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

            // Configure httpOnly on SSO cookie using same rules as session cookies
            if (request.getServletContext().getSessionCookieConfig().isHttpOnly() ||
                    request.getContext().getUseHttpOnly()) {
                cookie.setHttpOnly(true);
            }
            
        <bug>49749</bug>: Single sign on cookies should have httpOnly flag set
        using same rules as session cookies. (markt)
      </fix>
      <fix>
        <bug>49750</bug>: Align <code>WebappClassLoader.validate()</code>

======= 526f4ac:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

======= 526f4ac:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

    
    /**
     * Logger.
     */
    protected static org.apache.juli.logging.Log log
        = org.apache.juli.logging.LogFactory.getLog(AbstractOutputBuffer.class);
======= 526f4ac:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

        
        // go through the filters and if there is gzip filter
        // invoke it to flush
        for (int i = 0; i <= lastActiveFilter; i++) {
            if (activeFilters[i] instanceof GzipOutputFilter) {
                if (log.isDebugEnabled()) {
                    log.debug("Flushing the gzip filter at position " + i +
                            " of the filter chain...");
                }
                ((GzipOutputFilter) activeFilters[i]).flush();
                break;
            }
        }
======= 526f4ac:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 * Extension of {@link GZIPOutputStream} to workaround for a couple of long
 * standing JDK bugs
 * (<a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4255743">Bug
 * 4255743</a> and
 * <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4813885">Bug
 * 4813885</a>) so the GZIP'd output can be flushed. 
 */
    public FlushableGZIPOutputStream(OutputStream os) throws IOException {
        super(os);
    }
    private static final byte[] EMPTYBYTEARRAY = new byte[0];
    private boolean hasData = false;
    /**
     * Here we make sure we have received data, so that the header has been for
     * sure written to the output stream already.
     */
    @Override
    public synchronized void write(byte[] bytes, int i, int i1)
            throws IOException {
        super.write(bytes, i, i1);
        hasData = true;
    }
    @Override
    public synchronized void write(int i) throws IOException {
        super.write(i);
        hasData = true;
    }
    @Override
    public synchronized void write(byte[] bytes) throws IOException {
        super.write(bytes);
        hasData = true;
    }
    @Override
    public synchronized void flush() throws IOException {
        if (!hasData) {
            return; // do not allow the gzip header to be flushed on its own
        }
        // trick the deflater to flush
        /**
         * Now this is tricky: We force the Deflater to flush its data by
         * switching compression level. As yet, a perplexingly simple workaround
         * for
         * http://developer.java.sun.com/developer/bugParade/bugs/4255743.html
         */
        if (!def.finished()) {
            def.setInput(EMPTYBYTEARRAY, 0, 0);
            def.setLevel(Deflater.NO_COMPRESSION);
            deflate();
            def.setLevel(Deflater.DEFAULT_COMPRESSION);
            deflate();
            out.flush();
        }
        hasData = false; // no more data to flush
    }
    /*
     * Keep on calling deflate until it runs dry. The default implementation
     * only does it once and can therefore hold onto data when they need to be
     * flushed out.
     */
    @Override
    protected void deflate() throws IOException {
        int len;
        do {
            len = def.deflate(buf, 0, buf.length);
            if (len > 0) {
                out.write(buf, 0, len);
            }
        } while (len != 0);
    }
======= 526f4ac:"java/org/apache/coyote/http11/filters/GzipOutputFilter.java"

    /**
     * Logger.
     */
    protected static org.apache.juli.logging.Log log =
        org.apache.juli.logging.LogFactory.getLog(GzipOutputFilter.class);
======= 526f4ac:"java/org/apache/coyote/http11/filters/GzipOutputFilter.java"

            compressionStream = new FlushableGZIPOutputStream(fakeOutputStream);
======= 526f4ac:"java/org/apache/coyote/http11/filters/GzipOutputFilter.java"

    /**
     * Added to allow flushing to happen for the gzip'ed outputstream
     */
    public void flush() {
        if (compressionStream != null) {
            try {
                if (log.isDebugEnabled()) {
                    log.debug("Flushing the compression stream!");
                }
                compressionStream.flush();
            } catch (IOException e) {
                if (log.isDebugEnabled()) {
                    log.debug("Ignored exception while flushing gzip filter", e);
                }
            }
        }
    }
======= 526f4ac:"java/org/apache/coyote/http11/filters/GzipOutputFilter.java"

            compressionStream = new FlushableGZIPOutputStream(fakeOutputStream);
======= 526f4ac:"java/org/apache/coyote/http11/filters/GzipOutputFilter.java"

 * Test case to demonstrate the interaction between gzip and flushing in the
 * output filter.
 */
    /**
     * Test the interaction betwen gzip and flushing. The idea is to: 1. create
     * a internal output buffer, response, and attach an active gzipoutputfilter
     * to the output buffer 2. set the output stream of the internal buffer to
     * be a ByteArrayOutputStream so we can inspect the output bytes 3. write a
     * chunk out using the gzipoutputfilter and invoke a flush on the
     * InternalOutputBuffer 4. read from the ByteArrayOutputStream to find out
     * what's being written out (flushed) 5. find out what's expected by wrting
     * to GZIPOutputStream and close it (to force flushing) 6. Compare the size
     * of the two arrays, they should be close (instead of one being much
     * shorter than the other one)
     * 
     * @throws Exception
     */
    public void testFlushingWithGzip() throws Exception {
        // set up response, InternalOutputBuffer, and ByteArrayOutputStream
        Response res = new Response();
        InternalOutputBuffer iob = new InternalOutputBuffer(res);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        iob.setOutputStream(bos);
        res.setOutputBuffer(iob);
        // set up GzipOutputFilter to attach to the InternalOutputBuffer
        GzipOutputFilter gf = new GzipOutputFilter();
        iob.addFilter(gf);
        iob.addActiveFilter(gf);
        // write a chunk out
        ByteChunk chunk = new ByteChunk(1024);
        byte[] d = "Hello there tomcat developers, there is a bug in JDK".getBytes();
        chunk.append(d, 0, d.length);
        iob.doWrite(chunk, res);
        // flush the InternalOutputBuffer
        iob.flush();
        // read from the ByteArrayOutputStream to find out what's being written
        // out (flushed)
        byte[] dataFound = bos.toByteArray();
        // find out what's expected by wrting to GZIPOutputStream and close it
        // (to force flushing)
        ByteArrayOutputStream gbos = new ByteArrayOutputStream(1024);
        GZIPOutputStream gos = new GZIPOutputStream(gbos);
        gos.write(d);
        gos.close();
        // read the expected data
        byte[] dataExpected = gbos.toByteArray();
        // most of the data should have been flushed out
        assertTrue(dataFound.length >= (dataExpected.length - 20));
    }
        <bug>48738</bug>: Workaround a couple of long standing JDK bugs to
        enable GZIP compressed output streams to be flushed. Based on a patch
        provided by Jiong Wang. (markt)
      </fix>
      <fix>

======= e2f0b9b:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

======= e2f0b9b:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

            Valve valves[] = parent.getPipeline().getValves();
        <bug>49670</bug>: Restore SSO functionality that was broken by Lifecycle
        refactoring. (markt)
      </fix>
      <fix>

======= 187eed8:"java/org/apache/catalina/startup/ContextConfig.java"

======= 187eed8:"java/org/apache/catalina/startup/ContextConfig.java"

                // Spec does not define an order.
                // Use ordered JARs followed by remaining JARs
                Set<WebXml> resourceJars = new LinkedHashSet<WebXml>();
                for (WebXml fragment : orderedFragments) {
                    resourceJars.add(fragment);
                }
                for (WebXml fragment : fragments.values()) {
                    if (!resourceJars.contains(fragment)) {
                        resourceJars.add(fragment);
                    }
                }
                processResourceJARs(resourceJars);

======= 42c226f:"java/org/apache/jasper/compiler/Compiler.java"

        // Default ContentType processing is deferred until after the page has
        // been parsed
======= 42c226f:"java/org/apache/jasper/compiler/Compiler.java"

            // Leave this until now since it can only be set once - bug 49726
            if (pageInfo.getContentType() == null &&
                    jspProperty.getDefaultContentType() != null) {
                pageInfo.setContentType(jspProperty.getDefaultContentType());
            }
======= 42c226f:"java/org/apache/jasper/compiler/Compiler.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    
    public void testBug49726a() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = new ByteChunk();
        Map<String,List<String>> headers = new HashMap<String,List<String>>();
        
        getUrl("http://localhost:" + getPort() + "/test/bug49726a.jsp", res,
                headers);
        // Check request completed
        String result = res.toString();
        assertEcho(result, "OK");
        
        // Check content type
        assertTrue(headers.get("Content-Type").get(0).startsWith("text/html"));
    }
    public void testBug49726b() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        File appDir = new File("test/webapp-3.0");
        tomcat.addWebapp(null, "/test", appDir.getAbsolutePath());
        tomcat.start();
        ByteChunk res = new ByteChunk();
        Map<String,List<String>> headers = new HashMap<String,List<String>>();
        
        getUrl("http://localhost:" + getPort() + "/test/bug49726b.jsp", res,
                headers);
        // Check request completed
        String result = res.toString();
        assertEcho(result, "OK");
        
        // Check content type
        assertTrue(headers.get("Content-Type").get(0).startsWith("text/plain"));
    }
    /** Assertion for text printed by tags:echo */
    private static void assertEcho(String result, String expected) {
        assertTrue(result.indexOf("<p>" + expected + "</p>") > 0);
    }
  <jsp-config>
    <jsp-property-group>
      <default-content-type>text/plain</default-content-type>
      <url-pattern>/bug49726a.jsp</url-pattern>
      <url-pattern>/bug49726b.jsp</url-pattern>
    </jsp-property-group>
  </jsp-config>
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <head><title>Bug 49726 test case</title></head>
  <body>
    <p>OK</p>
  </body>
 Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  <head><title>Bug 49726 test case</title></head>
  <body>
    <p>OK</p>
  </body>
  <subsection name="Jasper">
    <changelog>
      <fix>
        <bug>49726</bug>: Specifying a default content type via a JSP property
        group should not prevent a page from setting some other content type.
        (markt)
      </fix>
    </changelog>
  </subsection>

======= 6fce7d7:"java/org/apache/catalina/loader/WebappClassLoader.java"

        if (name.startsWith("javax.servlet."))
            return false;
        <bug>47950</bug>: Align <code>WebappClassLoader.validate()</code>
        implementation with Javadoc and ensure that <code>javax.servlet.*</code>
        classes can not be loaded by a <code>WebappClassLoader</code> instance.
        Patch provided by pid. (markt)
      </fix>
      <fix>

======= c05cb94:"java/javax/annotation/Resource.java"

    @SuppressWarnings("rawtypes") // Can't use Class<?> because API needs to match specification
======= c05cb94:"java/javax/ejb/EJB.java"

   @SuppressWarnings("rawtypes") // Can't use Class<?> because API needs to match specification
======= c05cb94:"java/javax/el/BeanELResolver.java"

        public @SuppressWarnings("rawtypes") Class getPropertyType() {
======= c05cb94:"java/javax/el/ELContext.java"

    public Object getContext(@SuppressWarnings("rawtypes") Class key) {
======= c05cb94:"java/javax/el/ELContext.java"

    public void putContext(@SuppressWarnings("rawtypes") Class key,
======= c05cb94:"java/javax/el/ResourceBundleELResolver.java"

    public @SuppressWarnings({ "unchecked", "rawtypes" }) Iterator getFeatureDescriptors(
======= c05cb94:"java/javax/servlet/ServletRequestWrapper.java"

    public boolean isWrapperFor(@SuppressWarnings("rawtypes") Class wrappedType) {
======= c05cb94:"java/javax/servlet/ServletResponseWrapper.java"

    public boolean isWrapperFor(@SuppressWarnings("rawtypes") Class wrappedType) {
======= c05cb94:"java/javax/servlet/annotation/HandlesTypes.java"

======= c05cb94:"java/javax/servlet/jsp/el/ExpressionEvaluator.java"

            @SuppressWarnings("rawtypes")// TCK signature fails with generics
======= c05cb94:"java/javax/servlet/jsp/el/ExpressionEvaluator.java"

            @SuppressWarnings("rawtypes")// TCK signature fails with generics
======= c05cb94:"java/javax/servlet/jsp/el/ImplicitObjectELResolver.java"

    @SuppressWarnings({ "unchecked", "rawtypes" }) // TCK signature test fails with generics
======= c05cb94:"java/javax/servlet/jsp/tagext/TagSupport.java"

            @SuppressWarnings("rawtypes")
======= c05cb94:"java/javax/xml/ws/WebServiceRef.java"

    @SuppressWarnings("rawtypes") // Can't use Class<?> because API needs to match specification
    @SuppressWarnings("rawtypes") // Can't use Class<?> because API needs to match specification
======= c05cb94:"java/org/apache/el/lang/EvaluationContext.java"

    public Object getContext(@SuppressWarnings("rawtypes") Class key) {
======= c05cb94:"java/org/apache/el/lang/EvaluationContext.java"

    public void putContext(@SuppressWarnings("rawtypes") Class key,
======= c05cb94:"java/org/apache/el/parser/AstValue.java"

            @SuppressWarnings("rawtypes") Class[] paramTypes)
======= c05cb94:"java/org/apache/el/parser/AstValue.java"

            @SuppressWarnings("rawtypes") Class[] paramTypes,
======= c05cb94:"java/org/apache/jasper/el/ELContextWrapper.java"

    @SuppressWarnings("rawtypes") // Can't use Class<?> because API needs to match super-class specification
======= c05cb94:"java/org/apache/jasper/el/ELContextWrapper.java"

    @SuppressWarnings("rawtypes") // Can't use Class<?> because API needs to match super-class specification
======= c05cb94:"java/org/apache/jasper/el/ExpressionEvaluatorImpl.java"

            @SuppressWarnings("rawtypes") // API does not use generics
======= c05cb94:"java/org/apache/jasper/el/ExpressionEvaluatorImpl.java"

            @SuppressWarnings("rawtypes") // API does not use generics
======= c05cb94:"java/org/apache/naming/resources/DirContextURLConnection.java"

    @SuppressWarnings("rawtypes") // overridden method uses raw type Class[]
      <fix>
        <bug>49758</bug>: Fix generics warnings exposed by a fix in Eclipse 3.6.
        Patch provided by sebb. (markt)
      </fix>

======= d446678:"java/org/apache/catalina/manager/JMXProxyServlet.java"

    
    private static final long serialVersionUID = 1L;
    // ----------------------------------------------------- Instance Variables
    // --------------------------------------------------------- Public Methods
======= d446678:"java/org/apache/catalina/manager/JMXProxyServlet.java"

                        Class<?> c = value.getClass();
======= d446678:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
======= d446678:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
======= d446678:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
======= d446678:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
======= d446678:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
    @Override
======= d446678:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    @Override
======= d446678:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

    public static class MapEntry implements Map.Entry<Object,Object> {
======= d446678:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        @Override
        @Override
        @Override
      <fix>
        <bug>49757</bug>: Correct some generics warnings. Based on a patch
        provided by Gbor. (markt)
      </fix>

======= f4a10ec:"java/org/apache/catalina/startup/ContextConfig.java"

                // no impact on distributable
                annotations.setDistributable(true);
      <fix>
        <bug>49714</bug>: The annotation process of Jar doesn't influence 
        distributable element of web.xml. (kfujino)
      </fix>

======= 96a99ce:"test/org/apache/el/TestMethodExpressionImpl.java"

    
    /*
     * This is also tested implicitly in numerous places elsewhere in this
     * class.
     */
    public void testBug49655() throws Exception {
        // This is the call the failed
        MethodExpression me = factory.createMethodExpression(context,
                "#{beanA.setName('New value')}", null, null);
        // The rest is to check it worked correctly
        me.invoke(context, null);
        ValueExpression ve = factory.createValueExpression(context,
                "#{beanA.name}", java.lang.String.class);
        assertEquals("New value", ve.getValue(context));
    }

======= d21b105:"java/org/apache/catalina/session/ManagerBase.java"

        int size = getActiveSessions();
======= d21b105:"java/org/apache/catalina/session/ManagerBase.java"

                (getActiveSessions() >= maxActiveSessions)) {
======= d21b105:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    if (entry!=null && entry.isActive() && value.equals(entry.getValue())) return true;
======= d21b105:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                if ( entry != null && entry.isActive() ) {
======= d21b105:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                if ( entry!=null && entry.isActive() ) set.add(key);
======= d21b105:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    if (entry!=null && entry.isActive() && entry.getValue() != null) counter++;
======= d21b105:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                if (entry!=null && entry.isActive() && entry.getValue()!=null) values.add(entry.getValue());
======= d21b105:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            return (!proxy && !backup);
        public boolean isActive() {
            return !proxy;
        }
        
        <bug>49407</bug>: Change the BackupManager so it is consistent with
        DeltaManager and reports both primary and backup sessions when active
        sessions are requested. (markt)
      </fix>
      <fix>

======= 5f1ad13:"java/org/apache/catalina/connector/Request.java"

     * Flag that indicates if SSL attributes have been parsed to improve
     * performance for applications (usually frameworks) that make multiple
     * calls to {@link Request#getAttributeNames()}.
     */
    protected boolean sslAttributesParsed = false;
    /**
======= 5f1ad13:"java/org/apache/catalina/connector/Request.java"

        sslAttributesParsed = false;
======= 5f1ad13:"java/org/apache/catalina/connector/Request.java"

            sslAttributesParsed = true;
======= 5f1ad13:"java/org/apache/catalina/connector/Request.java"

        if (isSecure() && !sslAttributesParsed) {
      <fix>
        <bug>49613</bug>: Improve performance when using SSL for applications
        that make multiple class to <code>Request.getAttributeNames()</code>.
        Patch provided by Sampo Savolainen. (markt)
      </fix>

======= 2357fb5:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            if (status==SocketStatus.ERROR || status==SocketStatus.DISCONNECT) {
======= 2357fb5:"java/org/apache/catalina/connector/Request.java"

======= 2357fb5:"java/org/apache/catalina/core/AsyncContextImpl.java"

        NOT_STARTED, STARTED, DISPATCHING, DISPATCHED, COMPLETING, TIMING_OUT,
        ERROR_DISPATCHING
======= 2357fb5:"java/org/apache/catalina/core/AsyncContextImpl.java"

======= 2357fb5:"java/org/apache/catalina/core/AsyncContextImpl.java"

        if (state.get() ==  AsyncState.STARTED) {
            // TODO SERVLET3 - async - set context class loader when running the
            // task.
            // final ServletContext sctx = getServletRequest().getServletContext();
            // TODO - Use a container thread without creating a memory leak 
            // Execute the runnable using a container thread from the
            // Connector's thread pool
            // request.getConnector().getProtocolHandler().getExecutor().execute(run);
            Thread t = new Thread(run);
            t.start();
======= 2357fb5:"java/org/apache/catalina/core/AsyncContextImpl.java"

                state.get() == AsyncState.DISPATCHING);
======= 2357fb5:"java/org/apache/catalina/core/AsyncContextImpl.java"

            if (listenerInvoked) {
                // Listener should have called complete
                if (state.get() != AsyncState.NOT_STARTED) {
                    ((HttpServletResponse)servletResponse).setStatus(500);
                    doInternalComplete(true);
                }
            } else {
                // No listeners, container calls complete
                doInternalComplete(false);
======= 2357fb5:"java/org/apache/catalina/core/AsyncContextImpl.java"

======= 2357fb5:"java/org/apache/coyote/http11/Http11Processor.java"

            recycle();
======= 2357fb5:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

======= 2357fb5:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

======= 2357fb5:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

        ByteChunk bc = getUrl("http://localhost:" + getPort() + "/");
        assertEquals("OK", bc.toString());
        assertEquals("1false2true3true4true5false", servlet.getResult());
    }
    
    public void testBug49567() throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        
        // Must have a real docBase - just use temp
        Context ctx = 
            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
        Bug49567Servlet servlet = new Bug49567Servlet();
        
        Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet);
        wrapper.setAsyncSupported(true);
        ctx.addServletMapping("/", "servlet");
        
        tomcat.start();
        
        // Call the servlet once
        ByteChunk bc = getUrl("http://localhost:" + getPort() + "/");
        assertEquals("OK", bc.toString());
    public void testAsyncStartNoComplete() throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        
        // Minimise pauses during test
        tomcat.getConnector().setAttribute(
                "connectionTimeout", Integer.valueOf(3000));
        
        // Must have a real docBase - just use temp
        Context ctx = 
            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
        AsyncStartNoCompleteServlet servlet =
            new AsyncStartNoCompleteServlet();
        
        Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet);
        wrapper.setAsyncSupported(true);
        ctx.addServletMapping("/", "servlet");
        
        tomcat.start();
        
        // Call the servlet the first time
        ByteChunk bc1 = getUrl("http://localhost:" + getPort() +
                "/?echo=run1");
        assertEquals("OK-run1", bc1.toString());
        // Call the servlet the second time with a request parameter
        ByteChunk bc2 = getUrl("http://localhost:" + getPort() +
                "/?echo=run2");
        assertEquals("OK-run2", bc2.toString());
    }
    
    public void testAsyncStartWithComplete() throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        
        // Must have a real docBase - just use temp
        Context ctx = 
            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
        AsyncStartWithCompleteServlet servlet =
            new AsyncStartWithCompleteServlet();
        
        Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet);
        wrapper.setAsyncSupported(true);
        ctx.addServletMapping("/", "servlet");
        
        tomcat.start();
        
        // Call the servlet once
        ByteChunk bc = getUrl("http://localhost:" + getPort() + "/");
        assertEquals("OK", bc.toString());
    }
    
======= 2357fb5:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

                        resp.setContentType("text/plain");
                        resp.getWriter().print("OK");
                        result.append(e);
                    } catch (IOException e) {
                        result.append(e);
======= 2357fb5:"test/org/apache/catalina/core/TestAsyncContextImpl.java"

    private static class Bug49567Servlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        
        private StringBuilder result = new StringBuilder();
        
        public String getResult() {
            return result.toString();
        }
        @Override
        protected void doGet(final HttpServletRequest req,
                final HttpServletResponse resp)
                throws ServletException, IOException {
            
            result.append('1');
            result.append(req.isAsyncStarted());
            req.startAsync();
            result.append('2');
            result.append(req.isAsyncStarted());
            
            req.getAsyncContext().start(new Runnable() {
                @Override
                public void run() {
                    Thread t = new Thread(new Runnable() {
                        @Override
                        public void run() {
                            try {
                                result.append('3');
                                result.append(req.isAsyncStarted());
                                Thread.sleep(1000);
                                result.append('4');
                                result.append(req.isAsyncStarted());
                                resp.setContentType("text/plain");
                                resp.getWriter().print("OK");
                                req.getAsyncContext().complete();
                                result.append('5');
                                result.append(req.isAsyncStarted());
                            } catch (InterruptedException e) {
                                result.append(e);
                            } catch (IOException e) {
                                result.append(e);
                            }
                        }
                    });
                    t.start();
                }
            });
            // Pointless method call so there is somewhere to put a break point
            // when debugging
            req.getMethod();
        }
    }
    
    private static class AsyncStartNoCompleteServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        
        @Override
        protected void doGet(final HttpServletRequest req,
                final HttpServletResponse resp)
                throws ServletException, IOException {
            
            String echo = req.getParameter("echo");
            AsyncContext actxt = req.startAsync();
            resp.setContentType("text/plain");
            resp.getWriter().print("OK");
            if (echo != null) {
                resp.getWriter().print("-" + echo);
            }
            // Speed up the test by reducing the timeout
            actxt.setTimeout(1000);
        }
    }
    private static class AsyncStartWithCompleteServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        
        @Override
        protected void doGet(final HttpServletRequest req,
                final HttpServletResponse resp)
                throws ServletException, IOException {
            
            AsyncContext actxt = req.startAsync();
            resp.setContentType("text/plain");
            resp.getWriter().print("OK");
            actxt.complete();
        }
    }
        <bug>49528</bug>, <bug>49567</bug>: Ensure that
        <code>AsyncContext.isAsyncStarted()</code> returns the correct value
        after <code>AsyncContext.start()</code> and that if
        <code>AsyncContext.complete()</code> is called on a separate thread that
        it is handled correctly. (markt)

======= dfbd8aa:"java/org/apache/catalina/filters/ExpiresFilter.java"

 * <h2>Configuration Parameters</h2>
======= dfbd8aa:"java/org/apache/catalina/filters/ExpiresFilter.java"

 * <li>the <tt>Content-Type</tt> of the response matches one of the types
======= dfbd8aa:"java/org/apache/catalina/filters/ExpiresFilter.java"

======= dfbd8aa:"test/org/apache/catalina/filters/TestExpiresFilter.java"

        <bug>48998</bug>, <bug>49617</bug>: Add the ExpiresFilter, a port of the
        httpd mod_expires module. Patch provided by Cyrille Le Clerc. (markt)
    <li>the <tt>Content-Type</tt> of the response matches one of the types
         It overrides, for the specified MIME type <i>only</i>, any
    Sample of initialization log message:
    expiration date:
    an expiration date:

 * Copyright 2008-2009 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * <p>
 * ExpiresFilter is a Java Servlet API port of <a
 * href="http://httpd.apache.org/docs/2.2/mod/mod_expires.html">Apache
 * mod_expires</a> to add ' <tt>Expires</tt>' and '
 * <tt>Cache-Control: max-age=</tt>' headers to HTTP response according to its '
 * <tt>Content-Type</tt>'.
 * </p>
 * 
 * <p>
 * Following documentation is inspired by <tt>mod_expires</tt> .
 * </p>
 * <h1>Summary</h1>
 * <p>
 * This filter controls the setting of the <tt>Expires</tt> HTTP header and the
 * <tt>max-age</tt> directive of the <tt>Cache-Control</tt> HTTP header in
 * server responses. The expiration date can set to be relative to either the
 * time the source file was last modified, or to the time of the client access.
 * </p>
 * <p>
 * These HTTP headers are an instruction to the client about the document&#x27;s
 * validity and persistence. If cached, the document may be fetched from the
 * cache rather than from the source until this time has passed. After that, the
 * cache copy is considered &quot;expired&quot; and invalid, and a new copy must
 * be obtained from the source.
 * </p>
 * <p>
 * To modify <tt>Cache-Control</tt> directives other than <tt>max-age</tt> (see
 * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9" >RFC
 * 2616 section 14.9</a>), you can use other servlet filters or <a
 * href="http://httpd.apache.org/docs/2.2/mod/mod_headers.html" >Apache Httpd
 * mod_headers</a> module.
 * </p>
 * <h1>Filter Configuration</h1><h2>Basic configuration to add &#x27;
 * <tt>Expires</tt>&#x27; and &#x27; <tt>Cache-Control: max-age=</tt>&#x27;
 * headers to images, css and javascript</h2>
 * 
 * <code><pre>
 * &lt;web-app ...&gt;
 *    ...
 *    &lt;filter&gt;
 *       &lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt;
 *       &lt;filter-class&gt;org.apache.catalina.filters.ExpiresFilter&lt;/filter-class&gt;
 *       &lt;init-param&gt;
 *          &lt;param-name&gt;ExpiresByType image&lt;/param-name&gt;
 *          &lt;param-value&gt;access plus 10 minutes&lt;/param-value&gt;
 *       &lt;/init-param&gt;
 *       &lt;init-param&gt;
 *          &lt;param-name&gt;ExpiresByType text/css&lt;/param-name&gt;
 *          &lt;param-value&gt;access plus 10 minutes&lt;/param-value&gt;
 *       &lt;/init-param&gt;
 *       &lt;init-param&gt;
 *          &lt;param-name&gt;ExpiresByType text/javascript&lt;/param-name&gt;
 *          &lt;param-value&gt;access plus 10 minutes&lt;/param-value&gt;
 *       &lt;/init-param&gt;
 *    &lt;/filter&gt;
 *    ...
 *    &lt;filter-mapping&gt;
 *       &lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt;
 *       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
 *       &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
 *    &lt;/filter-mapping&gt;
 *    ...
 * &lt;/web-app&gt;
 * </pre></code>
 * 
 * <h2>Configuration Parameters</h2><h3>
 * <tt>ExpiresActive</tt></h3>
 * <p>
 * This directive enables or disables the generation of the <tt>Expires</tt> and
 * <tt>Cache-Control</tt> headers by this <tt>ExpiresFilter</tt>. If set to
 * <tt>Off</tt>, the headers will not be generated for any HTTP response. If set
 * to <tt>On</tt> or <tt>true</tt>, the headers will be added to served HTTP
 * responses according to the criteria defined by the
 * <tt>ExpiresByType &lt;content-type&gt;</tt> and <tt>ExpiresDefault</tt>
 * directives. Note that this directive does not guarantee that an
 * <tt>Expires</tt> or <tt>Cache-Control</tt> header will be generated. If the
 * criteria aren&#x27;t met, no header will be sent, and the effect will be as
 * though this directive wasn&#x27;t even specified.
 * </p>
 * <p>
 * This parameter is optional, default value is <tt>true</tt>.
 * </p>
 * <p>
 * <i>Enable filter</i>
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;!-- supports case insensitive &#x27;On&#x27; or &#x27;true&#x27; --&gt;
 *    &lt;param-name&gt;ExpiresActive&lt;/param-name&gt;&lt;param-value&gt;On&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * <p>
 * <i>Disable filter</i>
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;!-- supports anything different from case insensitive &#x27;On&#x27; and &#x27;true&#x27; --&gt;
 *    &lt;param-name&gt;ExpiresActive&lt;/param-name&gt;&lt;param-value&gt;Off&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * 
 * <h3>
 * <tt>ExpiresByType &lt;content-type&gt;</tt></h3>
 * <p>
 * This directive defines the value of the <tt>Expires</tt> header and the
 * <tt>max-age</tt> directive of the <tt>Cache-Control</tt> header generated for
 * documents of the specified type (<i>e.g.</i>, <tt>text/html</tt>). The second
 * argument sets the number of seconds that will be added to a base time to
 * construct the expiration date. The <tt>Cache-Control: max-age</tt> is
 * calculated by subtracting the request time from the expiration date and
 * expressing the result in seconds.
 * </p>
 * <p>
 * The base time is either the last modification time of the file, or the time
 * of the client&#x27;s access to the document. Which should be used is
 * specified by the <tt>&lt;code&gt;</tt> field; <tt>M</tt> means that the
 * file&#x27;s last modification time should be used as the base time, and
 * <tt>A</tt> means the client&#x27;s access time should be used. The duration
 * is expressed in seconds. <tt>A2592000</tt> stands for
 * <tt>access plus 30 days</tt> in alternate syntax.
 * </p>
 * <p>
 * The difference in effect is subtle. If <tt>M</tt> (<tt>modification</tt> in
 * alternate syntax) is used, all current copies of the document in all caches
 * will expire at the same time, which can be good for something like a weekly
 * notice that&#x27;s always found at the same URL. If <tt>A</tt> (
 * <tt>access</tt> or <tt>now</tt> in alternate syntax) is used, the date of
 * expiration is different for each client; this can be good for image files
 * that don&#x27;t change very often, particularly for a set of related
 * documents that all refer to the same images (<i>i.e.</i>, the images will be
 * accessed repeatedly within a relatively short timespan).
 * </p>
 * <p>
 * <strong>Example:</strong>
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresByType text/html&lt;/param-name&gt;&lt;param-value&gt;access plus 1 month 15   days 2 hours&lt;/param-value&gt;
 * &lt;/init-param&gt;
 *  
 * &lt;init-param&gt;
 *    &lt;!-- 2592000 seconds = 30 days --&gt;
 *    &lt;param-name&gt;ExpiresByType image/gif&lt;/param-name&gt;&lt;param-value&gt;A2592000&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * <p>
 * Note that this directive only has effect if <tt>ExpiresActive On</tt> has
 * been specified. It overrides, for the specified MIME type <i>only</i>, any
 * expiration date set by the <tt>ExpiresDefault</tt> directive.
 * </p>
 * <p>
 * You can also specify the expiration time calculation using an alternate
 * syntax, described earlier in this document.
 * </p>
 * <h3>
 * <tt>ExpiresExcludedResponseStatusCodes</tt></h3>
 * <p>
 * This directive defines the http response status codes for which the
 * <tt>ExpiresFilter</tt> will not generate expiration headers. By default, the
 * <tt>304</tt> status code (&quot;<tt>Not modified</tt>&quot;) is skipped. The
 * value is a comma separated list of http status codes.
 * </p>
 * <p>
 * This directive is useful to ease usage of <tt>ExpiresDefault</tt> directive.
 * Indeed, the behavior of <tt>304 Not modified</tt> (which does specify a
 * <tt>Content-Type</tt> header) combined with <tt>Expires</tt> and
 * <tt>Cache-Control:max-age=</tt> headers can be unnecessarily tricky to
 * understand.
 * </p>
 * <p>
 * Configuration sample :
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresExcludedResponseStatusCodes&lt;/param-name&gt;&lt;param-value&gt;302, 500, 503&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * 
 * <h3>ExpiresDefault</h3>
 * <p>
 * This directive sets the default algorithm for calculating the expiration time
 * for all documents in the affected realm. It can be overridden on a
 * type-by-type basis by the <tt>ExpiresByType</tt> directive. See the
 * description of that directive for details about the syntax of the argument,
 * and the "alternate syntax" description as well.
 * </p>
 * <h1>Alternate Syntax</h1>
 * <p>
 * The <tt>ExpiresDefault</tt> and <tt>ExpiresByType</tt> directives can also be
 * defined in a more readable syntax of the form:
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;&lt;param-value&gt;&lt;base&gt; [plus] {&lt;num&gt;   &lt;type&gt;}*&lt;/param-value&gt;
 * &lt;/init-param&gt;
 *  
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresByType type/encoding&lt;/param-name&gt;&lt;param-value&gt;&lt;base&gt; [plus]   {&lt;num&gt; &lt;type&gt;}*&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * <p>
 * where <tt>&lt;base&gt;</tt> is one of:
 * <ul>
 * <li><tt>access</tt></li>
 * <li><tt>now</tt> (equivalent to &#x27;<tt>access</tt>&#x27;)</li>
 * <li><tt>modification</tt></li>
 * </ul>
 * </p>
 * <p>
 * The <tt>plus</tt> keyword is optional. <tt>&lt;num&gt;</tt> should be an
 * integer value (acceptable to <tt>Integer.parseInt()</tt>), and
 * <tt>&lt;type&gt;</tt> is one of:
 * <ul>
 * <li><tt>years</tt></li>
 * <li><tt>months</tt></li>
 * <li><tt>weeks</tt></li>
 * <li><tt>days</tt></li>
 * <li><tt>hours</tt></li>
 * <li><tt>minutes</tt></li>
 * <li><tt>seconds</tt></li>
 * </ul>
 * For example, any of the following directives can be used to make documents
 * expire 1 month after being accessed, by default:
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;&lt;param-value&gt;access plus 1 month&lt;/param-value&gt;
 * &lt;/init-param&gt;
 *  
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;&lt;param-value&gt;access plus 4 weeks&lt;/param-value&gt;
 * &lt;/init-param&gt;
 *  
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;&lt;param-value&gt;access plus 30 days&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * <p>
 * The expiry time can be fine-tuned by adding several &#x27;
 * <tt>&lt;num&gt; &lt;type&gt;</tt>&#x27; clauses:
 * </p>
 * 
 * <code><pre>
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresByType text/html&lt;/param-name&gt;&lt;param-value&gt;access plus 1 month 15   days 2 hours&lt;/param-value&gt;
 * &lt;/init-param&gt;
 *  
 * &lt;init-param&gt;
 *    &lt;param-name&gt;ExpiresByType image/gif&lt;/param-name&gt;&lt;param-value&gt;modification plus 5 hours 3   minutes&lt;/param-value&gt;
 * &lt;/init-param&gt;
 * </pre></code>
 * <p>
 * Note that if you use a modification date based setting, the <tt>Expires</tt>
 * header will <strong>not</strong> be added to content that does not come from
 * a file on disk. This is due to the fact that there is no modification time
 * for such content.
 * </p>
 * <h1>Expiration headers generation eligibility</h1>
 * <p>
 * A response is eligible to be enriched by <tt>ExpiresFilter</tt> if :
 * <ol>
 * <li>no expiration header is defined (<tt>Expires</tt> header or the
 * <tt>max-age</tt> directive of the <tt>Cache-Control</tt> header),</li>
 * <li>the response status code is not excluded by the directive
 * <tt>ExpiresExcludedResponseStatusCodes</tt>,</li>
 * <li>The <tt>Content-Type</tt> of the response matches one of the types
 * defined the in <tt>ExpiresByType</tt> directives or the
 * <tt>ExpiresDefault</tt> directive is defined.</li>
 * </ol>
 * </p>
 * <p>
 * Note :
 * <ul>
 * <li>If <tt>Cache-Control</tt> header contains other directives than
 * <tt>max-age</tt>, they are concatenated with the <tt>max-age</tt> directive
 * that is added by the <tt>ExpiresFilter</tt>.</li>
 * </ul>
 * </p>
 * <h1>Expiration configuration selection</h1>
 * <p>
 * The expiration configuration if elected according to the following algorithm:
 * <ol>
 * <li><tt>ExpiresByType</tt> matching the exact content-type returned by
 * <tt>HttpServletResponse.getContentType()</tt> possibly including the charset
 * (e.g. &#x27;<tt>text/xml;charset=UTF-8</tt>&#x27;),</li>
 * <li><tt>ExpiresByType</tt> matching the content-type without the charset if
 * <tt>HttpServletResponse.getContentType()</tt> contains a charset (e.g. &#x27;
 * <tt>text/xml;charset=UTF-8</tt>&#x27; -&gt; &#x27;<tt>text/xml</tt>&#x27;),</li>
 * <li><tt>ExpiresByType</tt> matching the major type (e.g. substring before
 * &#x27;<tt>/</tt>&#x27;) of <tt>HttpServletResponse.getContentType()</tt>
 * (e.g. &#x27;<tt>text/xml;charset=UTF-8</tt>&#x27; -&gt; &#x27;<tt>text</tt>
 * &#x27;),</li>
 * <li><tt>ExpiresDefault</tt></li>
 * </ol>
 * </p>
 * <h1>Implementation Details</h1><h2>When to write the expiration headers ?</h2>
 * <p>
 * The <tt>ExpiresFilter</tt> traps the &#x27;on before write response
 * body&#x27; event to decide whether it should generate expiration headers or
 * not.
 * </p>
 * <p>
 * To trap the &#x27;before write response body&#x27; event, the
 * <tt>ExpiresFilter</tt> wraps the http servlet response&#x27;s writer and
 * outputStream to intercept calls to the methods <tt>write()</tt>,
 * <tt>print()</tt>, <tt>close()</tt> and <tt>flush()</tt>. For empty response
 * body (e.g. empty files), the <tt>write()</tt>, <tt>print()</tt>,
 * <tt>close()</tt> and <tt>flush()</tt> methods are not called; to handle this
 * case, the <tt>ExpiresFilter</tt>, at the end of its <tt>doFilter()</tt>
 * method, manually triggers the <tt>onBeforeWriteResponseBody()</tt> method.
 * </p>
 * <h2>Configuration syntax</h2>
 * <p>
 * The <tt>ExpiresFilter</tt> supports the same configuration syntax as Apache
 * Httpd mod_expires.
 * </p>
 * <p>
 * A challenge has been to choose the name of the <tt>&lt;param-name&gt;</tt>
 * associated with <tt>ExpiresByType</tt> in the <tt>&lt;filter&gt;</tt>
 * declaration. Indeed, Several <tt>ExpiresByType</tt> directives can be
 * declared when <tt>web.xml</tt> syntax does not allow to declare several
 * <tt>&lt;init-param&gt;</tt> with the same name.
 * </p>
 * <p>
 * The workaround has been to declare the content type in the
 * <tt>&lt;param-name&gt;</tt> rather than in the <tt>&lt;param-value&gt;</tt>.
 * </p>
 * <h2>Designed for extension : the open/close principle</h2>
 * <p>
 * The <tt>ExpiresFilter</tt> has been designed for extension following the
 * open/close principle.
 * </p>
 * <p>
 * Key methods to override for extension are :
 * <ul>
 * <li>
 * {@link #isEligibleToExpirationHeaderGeneration(HttpServletRequest, XHttpServletResponse)}
 * </li>
 * <li>
 * {@link #getExpirationDate(HttpServletRequest, XHttpServletResponse)}</li>
 * </ul>
 * </p>
 * <h1>Troubleshooting</h1>
 * <p>
 * To troubleshoot, enable logging on the
 * <tt>org.apache.catalina.filters.ExpiresFilter</tt>.
 * </p>
 * <p>
 * Extract of logging.properties
 * </p>
 * 
 * <code><pre>
 * org.apache.catalina.filters.ExpiresFilter.level = FINE
 * </pre></code>
 * <p>
 * Sample of initialization log message :
 * </p>
 * 
 * <code><pre>
 * Mar 26, 2010 2:01:41 PM org.apache.catalina.filters.ExpiresFilter init
 * FINE: Filter initialized with configuration ExpiresFilter[
 *    active=true, 
 *    excludedResponseStatusCode=[304], 
 *    default=null, 
 *    byType={
 *       image=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]], 
 *       text/css=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]], 
 *       text/javascript=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]]}]
 * </pre></code>
 * <p>
 * Sample of per-request log message where <tt>ExpiresFilter</tt> adds an
 * expiration date
 * </p>
 * 
 * <code><pre>
 * Mar 26, 2010 2:09:47 PM org.apache.catalina.filters.ExpiresFilter onBeforeWriteResponseBody
 * FINE: Request "/tomcat.gif" with response status "200" content-type "image/gif", set expiration date 3/26/10 2:19 PM
 * </pre></code>
 * <p>
 * Sample of per-request log message where <tt>ExpiresFilter</tt> does not add
 * an expiration date
 * </p>
 * 
 * <code><pre>
 * Mar 26, 2010 2:10:27 PM org.apache.catalina.filters.ExpiresFilter onBeforeWriteResponseBody
 * FINE: Request "/docs/config/manager.html" with response status "200" content-type "text/html", no expiration configured
 * </pre></code>
 * 
 */
    /**
     * Duration composed of an {@link #amount} and a {@link #unit}
     */
    protected static class Duration {
        public static Duration minutes(int amount) {
            return new Duration(amount, DurationUnit.MINUTE);
        }
        public static Duration seconds(int amount) {
            return new Duration(amount, DurationUnit.SECOND);
        }
        final protected int amount;
        final protected DurationUnit unit;
        public Duration(int amount, DurationUnit unit) {
            super();
            this.amount = amount;
            this.unit = unit;
        }
        public int getAmount() {
            return amount;
        }
        public DurationUnit getUnit() {
            return unit;
        }
        @Override
        public String toString() {
            return amount + " " + unit;
        }
    }
    /**
     * Duration unit
     */
    protected enum DurationUnit {
        DAY(Calendar.DAY_OF_YEAR), HOUR(Calendar.HOUR), MINUTE(Calendar.MINUTE), MONTH(
                Calendar.MONTH), SECOND(Calendar.SECOND), WEEK(
                Calendar.WEEK_OF_YEAR), YEAR(Calendar.YEAR);
        private final int calendardField;
        private DurationUnit(int calendardField) {
            this.calendardField = calendardField;
        }
        public int getCalendardField() {
            return calendardField;
        }
    }
    /**
     * <p>
     * Main piece of configuration of the filter.
     * </p>
     * <p>
     * Can be expressed like '<tt>access plus 1 month 15   days 2 hours</tt>'.
     * </p>
     */
    protected static class ExpiresConfiguration {
        /**
         * List of duration elements.
         */
        private List<Duration> durations;
        /**
         * Starting point of the elaspse to set in the response.
         */
        private StartingPoint startingPoint;
        public ExpiresConfiguration(StartingPoint startingPoint,
                Duration... durations) {
            this(startingPoint, Arrays.asList(durations));
        }
        public ExpiresConfiguration(StartingPoint startingPoint,
                List<Duration> durations) {
            super();
            this.startingPoint = startingPoint;
            this.durations = durations;
        }
        public List<Duration> getDurations() {
            return durations;
        }
        public StartingPoint getStartingPoint() {
            return startingPoint;
        }
        @Override
        public String toString() {
            return "ExpiresConfiguration[startingPoint=" + startingPoint +
                    ", duration=" + durations + "]";
        }
    }
    /**
     * Expiration configuration starting point. Either the time the
     * html-page/servlet-response was served ({@link StartingPoint#ACCESS_TIME})
     * or the last time the html-page/servlet-response was modified (
     * {@link StartingPoint#LAST_MODIFICATION_TIME}).
     */
    protected enum StartingPoint {
        ACCESS_TIME, LAST_MODIFICATION_TIME
    }
    /**
     * <p>
     * Wrapping extension of the {@link HttpServletResponse} to yrap the
     * "Start Write Response Body" event.
     * </p>
     * <p>
     * For performance optimization : this extended response holds the
     * {@link #lastModifiedHeader} and {@link #cacheControlHeader} values access
     * to the slow {@link #getHeader(String)} and to spare the <tt>string</tt>
     * to <tt>date</tt> to <tt>long</tt> conversion.
     * </p>
     */
    public class XHttpServletResponse extends HttpServletResponseWrapper {
        /**
         * Value of the <tt>Cache-Control/tt> http response header if it has
         * been set.
         */
        private String cacheControlHeader;
        /**
         * Value of the <tt>Last-Modified</tt> http response header if it has
         * been set.
         */
        private long lastModifiedHeader;
        private boolean lastModifiedHeaderSet;
        private PrintWriter printWriter;
        private HttpServletRequest request;
        private ServletOutputStream servletOutputStream;
        /**
         * Indicates whether calls to write methods (<tt>write(...)</tt>,
         * <tt>print(...)</tt>, etc) of the response body have been called or
         * not.
         */
        private boolean writeResponseBodyStarted;
        public XHttpServletResponse(HttpServletRequest request,
                HttpServletResponse response) {
            super(response);
            this.request = request;
        }
        @Override
        public void addDateHeader(String name, long date) {
            super.addDateHeader(name, date);
            if (!lastModifiedHeaderSet) {
                this.lastModifiedHeader = date;
                this.lastModifiedHeaderSet = true;
            }
        }
        @Override
        public void addHeader(String name, String value) {
            super.addHeader(name, value);
            if (HEADER_CACHE_CONTROL.equalsIgnoreCase(name) &&
                    cacheControlHeader == null) {
                cacheControlHeader = value;
            }
        }
        public String getCacheControlHeader() {
            return cacheControlHeader;
        }
        public long getLastModifiedHeader() {
            return lastModifiedHeader;
        }
        @Override
        public ServletOutputStream getOutputStream() throws IOException {
            if (servletOutputStream == null) {
                servletOutputStream = new XServletOutputStream(
                        super.getOutputStream(), request, this);
            }
            return servletOutputStream;
        }
        @Override
        public PrintWriter getWriter() throws IOException {
            if (printWriter == null) {
                printWriter = new XPrintWriter(super.getWriter(), request, this);
            }
            return printWriter;
        }
        public boolean isLastModifiedHeaderSet() {
            return lastModifiedHeaderSet;
        }
        public boolean isWriteResponseBodyStarted() {
            return writeResponseBodyStarted;
        }
        @Override
        public void reset() {
            super.reset();
            this.lastModifiedHeader = 0;
            this.lastModifiedHeaderSet = false;
            this.cacheControlHeader = null;
        }
        @Override
        public void setDateHeader(String name, long date) {
            super.setDateHeader(name, date);
            if (HEADER_LAST_MODIFIED.equalsIgnoreCase(name)) {
                this.lastModifiedHeader = date;
                this.lastModifiedHeaderSet = true;
            }
        }
        @Override
        public void setHeader(String name, String value) {
            super.setHeader(name, value);
            if (HEADER_CACHE_CONTROL.equalsIgnoreCase(name)) {
                this.cacheControlHeader = value;
            }
        }
        public void setWriteResponseBodyStarted(boolean writeResponseBodyStarted) {
            this.writeResponseBodyStarted = writeResponseBodyStarted;
        }
    }
    /**
     * Wrapping extension of {@link PrintWriter} to trap the
     * "Start Write Response Body" event.
     */
    public class XPrintWriter extends PrintWriter {
        private PrintWriter out;
        private HttpServletRequest request;
        private XHttpServletResponse response;
        public XPrintWriter(PrintWriter out, HttpServletRequest request,
                XHttpServletResponse response) {
            super(out);
            this.out = out;
            this.request = request;
            this.response = response;
        }
        @Override
        public PrintWriter append(char c) {
            fireBeforeWriteResponseBodyEvent();
            return out.append(c);
        }
        @Override
        public PrintWriter append(CharSequence csq) {
            fireBeforeWriteResponseBodyEvent();
            return out.append(csq);
        }
        @Override
        public PrintWriter append(CharSequence csq, int start, int end) {
            fireBeforeWriteResponseBodyEvent();
            return out.append(csq, start, end);
        }
        @Override
        public void close() {
            fireBeforeWriteResponseBodyEvent();
            out.close();
        }
        private void fireBeforeWriteResponseBodyEvent() {
            if (!this.response.isWriteResponseBodyStarted()) {
                this.response.setWriteResponseBodyStarted(true);
                onBeforeWriteResponseBody(request, response);
            }
        }
        @Override
        public void flush() {
            fireBeforeWriteResponseBodyEvent();
            out.flush();
        }
        @Override
        public void print(boolean b) {
            fireBeforeWriteResponseBodyEvent();
            out.print(b);
        }
        @Override
        public void print(char c) {
            fireBeforeWriteResponseBodyEvent();
            out.print(c);
        }
        @Override
        public void print(char[] s) {
            fireBeforeWriteResponseBodyEvent();
            out.print(s);
        }
        @Override
        public void print(double d) {
            fireBeforeWriteResponseBodyEvent();
            out.print(d);
        }
        @Override
        public void print(float f) {
            fireBeforeWriteResponseBodyEvent();
            out.print(f);
        }
        @Override
        public void print(int i) {
            fireBeforeWriteResponseBodyEvent();
            out.print(i);
        }
        @Override
        public void print(long l) {
            fireBeforeWriteResponseBodyEvent();
            out.print(l);
        }
        @Override
        public void print(Object obj) {
            fireBeforeWriteResponseBodyEvent();
            out.print(obj);
        }
        @Override
        public void print(String s) {
            fireBeforeWriteResponseBodyEvent();
            out.print(s);
        }
        @Override
        public PrintWriter printf(Locale l, String format, Object... args) {
            fireBeforeWriteResponseBodyEvent();
            return out.printf(l, format, args);
        }
        @Override
        public PrintWriter printf(String format, Object... args) {
            fireBeforeWriteResponseBodyEvent();
            return out.printf(format, args);
        }
        @Override
        public void println() {
            fireBeforeWriteResponseBodyEvent();
            out.println();
        }
        @Override
        public void println(boolean x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(char x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(char[] x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(double x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(float x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(int x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(long x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(Object x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void println(String x) {
            fireBeforeWriteResponseBodyEvent();
            out.println(x);
        }
        @Override
        public void write(char[] buf) {
            fireBeforeWriteResponseBodyEvent();
            out.write(buf);
        }
        @Override
        public void write(char[] buf, int off, int len) {
            fireBeforeWriteResponseBodyEvent();
            out.write(buf, off, len);
        }
        @Override
        public void write(int c) {
            fireBeforeWriteResponseBodyEvent();
            out.write(c);
        }
        @Override
        public void write(String s) {
            fireBeforeWriteResponseBodyEvent();
            out.write(s);
        }
        @Override
        public void write(String s, int off, int len) {
            fireBeforeWriteResponseBodyEvent();
            out.write(s, off, len);
        }
    }
    /**
     * Wrapping extension of {@link ServletOutputStream} to trap the
     * "Start Write Response Body" event.
     */
    public class XServletOutputStream extends ServletOutputStream {
        private HttpServletRequest request;
        private XHttpServletResponse response;
        private ServletOutputStream servletOutputStream;
        public XServletOutputStream(ServletOutputStream servletOutputStream,
                HttpServletRequest request, XHttpServletResponse response) {
            super();
            this.servletOutputStream = servletOutputStream;
            this.response = response;
            this.request = request;
        }
        @Override
        public void close() throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.close();
        }
        private void fireOnBeforeWriteResponseBodyEvent() {
            if (!this.response.isWriteResponseBodyStarted()) {
                this.response.setWriteResponseBodyStarted(true);
                onBeforeWriteResponseBody(request, response);
            }
        }
        @Override
        public void flush() throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.flush();
        }
        @Override
        public void print(boolean b) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(b);
        }
        @Override
        public void print(char c) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(c);
        }
        @Override
        public void print(double d) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(d);
        }
        @Override
        public void print(float f) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(f);
        }
        @Override
        public void print(int i) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(i);
        }
        @Override
        public void print(long l) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(l);
        }
        @Override
        public void print(String s) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.print(s);
        }
        @Override
        public void println() throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println();
        }
        @Override
        public void println(boolean b) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(b);
        }
        @Override
        public void println(char c) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(c);
        }
        @Override
        public void println(double d) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(d);
        }
        @Override
        public void println(float f) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(f);
        }
        @Override
        public void println(int i) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(i);
        }
        @Override
        public void println(long l) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(l);
        }
        @Override
        public void println(String s) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.println(s);
        }
        @Override
        public void write(byte[] b) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.write(b);
        }
        @Override
        public void write(byte[] b, int off, int len) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.write(b, off, len);
        }
        @Override
        public void write(int b) throws IOException {
            fireOnBeforeWriteResponseBodyEvent();
            servletOutputStream.write(b);
        }
    }
    /**
     * {@link Pattern} for a comma delimited string that support whitespace
     * characters
     */
    private static final Pattern commaSeparatedValuesPattern = Pattern.compile("\\s*,\\s*");
    private static final String HEADER_CACHE_CONTROL = "Cache-Control";
    private static final String HEADER_EXPIRES = "Expires";
    private static final String HEADER_LAST_MODIFIED = "Last-Modified";
    private static final Log log = LogFactory.getLog(ExpiresFilter.class);
    private static final String PARAMETER_EXPIRES_ACTIVE = "ExpiresActive";
    private static final String PARAMETER_EXPIRES_BY_TYPE = "ExpiresByType";
    private static final String PARAMETER_EXPIRES_DEFAULT = "ExpiresDefault";
    private static final String PARAMETER_EXPIRES_EXCLUDED_RESPONSE_STATUS_CODES = "ExpiresExcludedResponseStatusCodes";
    /**
     * Convert a comma delimited list of numbers into an <tt>int[]</tt>.
     * 
     * @param commaDelimitedInts
     *            can be <code>null</code>
     * @return never <code>null</code> array
     */
    protected static int[] commaDelimitedListToIntArray(
            String commaDelimitedInts) {
        String[] intsAsStrings = commaDelimitedListToStringArray(commaDelimitedInts);
        int[] ints = new int[intsAsStrings.length];
        for (int i = 0; i < intsAsStrings.length; i++) {
            String intAsString = intsAsStrings[i];
            try {
                ints[i] = Integer.parseInt(intAsString);
            } catch (NumberFormatException e) {
                throw new RuntimeException("Exception parsing number '" + i +
                        "' (zero based) of comma delimited list '" +
                        commaDelimitedInts + "'");
            }
        }
        return ints;
    }
    /**
     * Convert a given comma delimited list of strings into an array of String
     * 
     * @return array of patterns (non <code>null</code>)
     */
    protected static String[] commaDelimitedListToStringArray(
            String commaDelimitedStrings) {
        return (commaDelimitedStrings == null || commaDelimitedStrings.length() == 0) ? new String[0]
                : commaSeparatedValuesPattern.split(commaDelimitedStrings);
    }
    /**
     * Return <code>true</code> if the given <code>str</code> contains the given
     * <code>searchStr</code>.
     */
    protected static boolean contains(String str, String searchStr) {
        if (str == null || searchStr == null) {
            return false;
        }
        return str.indexOf(searchStr) >= 0;
    }
    /**
     * Convert an array of ints into a comma delimited string
     */
    protected static String intsToCommaDelimitedString(int[] ints) {
        if (ints == null) {
            return "";
        }
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < ints.length; i++) {
            result.append(ints[i]);
            if (i < (ints.length - 1)) {
                result.append(", ");
            }
        }
        return result.toString();
    }
    /**
     * Return <code>true</code> if the given <code>str</code> is
     * <code>null</code> or has a zero characters length.
     */
    protected static boolean isEmpty(String str) {
        return str == null || str.length() == 0;
    }
    /**
     * Return <code>true</code> if the given <code>str</code> has at least one
     * character (can be a withespace).
     */
    protected static boolean isNotEmpty(String str) {
        return !isEmpty(str);
    }
    /**
     * Return <code>true</code> if the given <code>string</code> starts with the
     * given <code>prefix</code> ignoring case.
     * 
     * @param string
     *            can be <code>null</code>
     * @param prefix
     *            can be <code>null</code>
     */
    protected static boolean startsWithIgnoreCase(String string, String prefix) {
        if (string == null || prefix == null) {
            return string == null && prefix == null;
        }
        if (prefix.length() > string.length()) {
            return false;
        }
        return string.regionMatches(true, 0, prefix, 0, prefix.length());
    }
    /**
     * Return the subset of the given <code>str</code> that is before the first
     * occurence of the given <code>separator</code>. Return <code>null</code>
     * if the given <code>str</code> or the given <code>separator</code> is
     * null. Return and empty string if the <code>separator</code> is empty.
     * 
     * @param str
     *            can be <code>null</code>
     * @param separator
     *            can be <code>null</code>
     * @return
     */
    protected static String substringBefore(String str, String separator) {
        if (str == null || str.isEmpty() || separator == null) {
            return null;
        }
        if (separator.isEmpty()) {
            return "";
        }
        int separatorIndex = str.indexOf(separator);
        if (separatorIndex == -1) {
            return str;
        }
        return str.substring(0, separatorIndex);
    }
    /**
     * @see #isActive()
     */
    private boolean active = true;
    /**
     * Default Expires configuration.
     */
    private ExpiresConfiguration defaultExpiresConfiguration;
    /**
     * list of response status code for which the {@link ExpiresFilter} will not
     * generate expiration headers.
     */
    private int[] excludedResponseStatusCodes = new int[] { HttpServletResponse.SC_NOT_MODIFIED };
    /**
     * Expires configuration by content type. Visible for test.
     */
    private Map<String, ExpiresConfiguration> expiresConfigurationByContentType = new LinkedHashMap<String, ExpiresConfiguration>();
    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {
        if (request instanceof HttpServletRequest &&
                response instanceof HttpServletResponse) {
            HttpServletRequest httpRequest = (HttpServletRequest) request;
            HttpServletResponse httpResponse = (HttpServletResponse) response;
            if (response.isCommitted()) {
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString(
                            "expiresFilter.responseAlreadyCommited",
                            httpRequest.getRequestURL()));
                }
                chain.doFilter(request, response);
            } else if (active) {
                XHttpServletResponse xResponse = new XHttpServletResponse(
                        httpRequest, httpResponse);
                chain.doFilter(request, xResponse);
                if (!xResponse.isWriteResponseBodyStarted()) {
                    // Empty response, manually trigger
                    // onBeforeWriteResponseBody()
                    onBeforeWriteResponseBody(httpRequest, xResponse);
                }
            } else {
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("expiresFilter.filterNotActive",
                            httpRequest.getRequestURL()));
                }
                chain.doFilter(request, response);
            }
        } else {
            chain.doFilter(request, response);
        }
    }
    public ExpiresConfiguration getDefaultExpiresConfiguration() {
        return defaultExpiresConfiguration;
    }
    public String getExcludedResponseStatusCodes() {
        return intsToCommaDelimitedString(excludedResponseStatusCodes);
    }
    public int[] getExcludedResponseStatusCodesAsInts() {
        return excludedResponseStatusCodes;
    }
    /**
     * <p>
     * Returns the expiration date of the given {@link XHttpServletResponse} or
     * <code>null</code> if no expiration date has been configured for the
     * declared content type.
     * </p>
     * <p>
     * <code>protected</code> for extension.
     * </p>
     * 
     * @see HttpServletResponse#getContentType()
     */
    protected Date getExpirationDate(XHttpServletResponse response) {
        String contentType = response.getContentType();
        // lookup exact content-type match (e.g.
        // "text/html; charset=iso-8859-1")
        ExpiresConfiguration configuration = expiresConfigurationByContentType.get(contentType);
        if (configuration != null) {
            Date result = getExpirationDate(configuration, response);
            if (log.isErrorEnabled()) {
                log.error(sm.getString(
                        "expiresFilter.useMatchingConfiguration",
                        configuration, contentType, contentType, result));
            }
            return result;
        }
        if (contains(contentType, ";")) {
            // lookup content-type without charset match (e.g. "text/html")
            String contentTypeWithoutCharset = substringBefore(contentType, ";").trim();
            configuration = expiresConfigurationByContentType.get(contentTypeWithoutCharset);
            if (configuration != null) {
                Date result = getExpirationDate(configuration, response);
                if (log.isErrorEnabled()) {
                    log.error(sm.getString(
                            "expiresFilter.useMatchingConfiguration",
                            configuration, contentTypeWithoutCharset,
                            contentType, result));
                }
                return result;
            }
        }
        if (contains(contentType, "/")) {
            // lookup major type match (e.g. "text")
            String majorType = substringBefore(contentType, "/");
            configuration = expiresConfigurationByContentType.get(majorType);
            if (configuration != null) {
                Date result = getExpirationDate(configuration, response);
                if (log.isErrorEnabled()) {
                    log.error(sm.getString(
                            "expiresFilter.useMatchingConfiguration",
                            configuration, majorType, contentType, result));
                }
                return result;
            }
        }
        if (defaultExpiresConfiguration != null) {
            Date result = getExpirationDate(defaultExpiresConfiguration,
                    response);
            if (log.isErrorEnabled()) {
                log.error(sm.getString("expiresFilter.useDefaultConfiguration",
                        defaultExpiresConfiguration, contentType, result));
            }
            return result;
        }
        if (log.isErrorEnabled()) {
            log.error(sm.getString(
                    "expiresFilter.noExpirationConfiguredForContentType",
                    contentType));
        }
        return null;
    }
    /**
     * <p>
     * Returns the expiration date of the given {@link ExpiresConfiguration},
     * {@link HttpServletRequest} and {@link XHttpServletResponse}.
     * </p>
     * <p>
     * <code>protected</code> for extension.
     * </p>
     */
    protected Date getExpirationDate(ExpiresConfiguration configuration,
            XHttpServletResponse response) {
        Calendar calendar;
        switch (configuration.getStartingPoint()) {
        case ACCESS_TIME:
            calendar = Calendar.getInstance();
            break;
        case LAST_MODIFICATION_TIME:
            if (response.isLastModifiedHeaderSet()) {
                try {
                    long lastModified = response.getLastModifiedHeader();
                    calendar = Calendar.getInstance();
                    calendar.setTimeInMillis(lastModified);
                } catch (NumberFormatException e) {
                    // default to now
                    calendar = Calendar.getInstance();
                }
            } else {
                // Last-Modified header not found, use now
                calendar = Calendar.getInstance();
            }
            break;
        default:
            throw new IllegalStateException(sm.getString(
                    "expiresFilter.unsupportedStartingPoint",
                    configuration.getStartingPoint()));
        }
        for (Duration duration : configuration.getDurations()) {
            calendar.add(duration.getUnit().getCalendardField(),
                    duration.getAmount());
        }
        return calendar.getTime();
    }
    public Map<String, ExpiresConfiguration> getExpiresConfigurationByContentType() {
        return expiresConfigurationByContentType;
    }
    @Override
    protected Log getLogger() {
        return log;
    }
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        for (Enumeration<String> names = filterConfig.getInitParameterNames(); names.hasMoreElements();) {
            String name = names.nextElement();
            String value = filterConfig.getInitParameter(name);
            try {
                if (name.startsWith(PARAMETER_EXPIRES_BY_TYPE)) {
                    String contentType = name.substring(
                            PARAMETER_EXPIRES_BY_TYPE.length()).trim();
                    ExpiresConfiguration expiresConfiguration = parseExpiresConfiguration(value);
                    this.expiresConfigurationByContentType.put(contentType,
                            expiresConfiguration);
                } else if (name.equalsIgnoreCase(PARAMETER_EXPIRES_DEFAULT)) {
                    ExpiresConfiguration expiresConfiguration = parseExpiresConfiguration(value);
                    this.defaultExpiresConfiguration = expiresConfiguration;
                } else if (name.equalsIgnoreCase(PARAMETER_EXPIRES_ACTIVE)) {
                    this.active = "On".equalsIgnoreCase(value) ||
                            Boolean.valueOf(value).booleanValue();
                } else if (name.equalsIgnoreCase(PARAMETER_EXPIRES_EXCLUDED_RESPONSE_STATUS_CODES)) {
                    this.excludedResponseStatusCodes = commaDelimitedListToIntArray(value);
                } else {
                    log.warn(sm.getString(
                            "expiresFilter.unknownParameterIgnored", name,
                            value));
                }
            } catch (RuntimeException e) {
                throw new ServletException(sm.getString(
                        "expiresFilter.exceptionProcessingParameter", name,
                        value), e);
            }
        }
        log.debug(sm.getString("expiresFilter.filterInitialized",
                this.toString()));
    }
    /**
     * Indicates that the filter is active. If <code>false</code>, the filter is
     * pass-through. Default is <code>true</code>.
     */
    public boolean isActive() {
        return active;
    }
    /**
     * 
     * <p>
     * <code>protected</code> for extension.
     * </p>
     */
    protected boolean isEligibleToExpirationHeaderGeneration(
            HttpServletRequest request, XHttpServletResponse response) {
        boolean expirationHeaderHasBeenSet = response.containsHeader(HEADER_EXPIRES) ||
                contains(response.getCacheControlHeader(), "max-age");
        if (expirationHeaderHasBeenSet) {
            if (log.isDebugEnabled()) {
                log.debug(sm.getString(
                        "expiresFilter.expirationHeaderAlreadyDefined",
                        request.getRequestURI(),
                        Integer.valueOf(response.getStatus()),
                        response.getContentType()));
            }
            return false;
        }
        for (int skippedStatusCode : this.excludedResponseStatusCodes) {
            if (response.getStatus() == skippedStatusCode) {
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("expiresFilter.skippedStatusCode",
                            request.getRequestURI(),
                            Integer.valueOf(response.getStatus()),
                            response.getContentType()));
                }
                return false;
            }
        }
        return true;
    }
    /**
     * <p>
     * If no expiration header has been set by the servlet and an expiration has
     * been defined in the {@link ExpiresFilter} configuration, sets the '
     * <tt>Expires</tt>' header and the attribute '<tt>max-age</tt>' of the '
     * <tt>Cache-Control</tt>' header.
     * </p>
     * <p>
     * Must be called on the "Start Write Response Body" event.
     * </p>
     * <p>
     * Invocations to <tt>Logger.debug(...)</tt> are guarded by
     * {@link Logger#isDebugEnabled()} because
     * {@link HttpServletRequest#getRequestURI()} and
     * {@link HttpServletResponse#getContentType()} costs <tt>String</tt>
     * objects instantiations (as of Tomcat 7).
     * </p>
     */
    public void onBeforeWriteResponseBody(HttpServletRequest request,
            XHttpServletResponse response) {
        if (!isEligibleToExpirationHeaderGeneration(request, response)) {
            return;
        }
        Date expirationDate = getExpirationDate(response);
        if (expirationDate == null) {
            if (log.isDebugEnabled()) {
                log.debug(sm.getString("expiresFilter.noExpirationConfigured",
                        request.getRequestURI(),
                        Integer.valueOf(response.getStatus()),
                        response.getContentType()));
            }
        } else {
            if (log.isDebugEnabled()) {
                log.debug(sm.getString("expiresFilter.setExpirationDate",
                        request.getRequestURI(),
                        Integer.valueOf(response.getStatus()),
                        response.getContentType(), expirationDate));
            }
            String maxAgeDirective = "max-age=" +
                    ((expirationDate.getTime() - System.currentTimeMillis()) / 1000);
            String cacheControlHeader = response.getCacheControlHeader();
            String newCacheControlHeader = (cacheControlHeader == null) ? maxAgeDirective
                    : cacheControlHeader + ", " + maxAgeDirective;
            response.setHeader(HEADER_CACHE_CONTROL, newCacheControlHeader);
            response.setDateHeader(HEADER_EXPIRES, expirationDate.getTime());
        }
    }
    /**
     * Parse configuration lines like '
     * <tt>access plus 1 month 15 days 2 hours</tt>' or '
     * <tt>modification 1 day 2 hours 5 seconds</tt>'
     * 
     * @param inputLine
     */
    protected ExpiresConfiguration parseExpiresConfiguration(String inputLine) {
        String line = inputLine.trim();
        StringTokenizer tokenizer = new StringTokenizer(line, " ");
        String currentToken;
        try {
            currentToken = tokenizer.nextToken();
        } catch (NoSuchElementException e) {
            throw new IllegalStateException(sm.getString(
                    "expiresFilter.startingPointNotFound", line));
        }
        StartingPoint startingPoint;
        if ("access".equalsIgnoreCase(currentToken) ||
                "now".equalsIgnoreCase(currentToken)) {
            startingPoint = StartingPoint.ACCESS_TIME;
        } else if ("modification".equalsIgnoreCase(currentToken)) {
            startingPoint = StartingPoint.LAST_MODIFICATION_TIME;
        } else if (!tokenizer.hasMoreTokens() &&
                startsWithIgnoreCase(currentToken, "a")) {
            startingPoint = StartingPoint.ACCESS_TIME;
            // trick : convert duration configuration from old to new style
            tokenizer = new StringTokenizer(currentToken.substring(1) +
                    " seconds", " ");
        } else if (!tokenizer.hasMoreTokens() &&
                startsWithIgnoreCase(currentToken, "m")) {
            startingPoint = StartingPoint.LAST_MODIFICATION_TIME;
            // trick : convert duration configuration from old to new style
            tokenizer = new StringTokenizer(currentToken.substring(1) +
                    " seconds", " ");
        } else {
            throw new IllegalStateException(sm.getString(
                    "expiresFilter.startingPointInvalid", currentToken, line));
        }
        try {
            currentToken = tokenizer.nextToken();
        } catch (NoSuchElementException e) {
            throw new IllegalStateException(sm.getString(
                    "Duration not found in directive '{}'", line));
        }
        if ("plus".equalsIgnoreCase(currentToken)) {
            // skip
            try {
                currentToken = tokenizer.nextToken();
            } catch (NoSuchElementException e) {
                throw new IllegalStateException(sm.getString(
                        "Duration not found in directive '{}'", line));
            }
        }
        List<Duration> durations = new ArrayList<Duration>();
        while (currentToken != null) {
            int amount;
            try {
                amount = Integer.parseInt(currentToken);
            } catch (NumberFormatException e) {
                throw new IllegalStateException(sm.getString(
                        "Invalid duration (number) '{}' in directive '{}'",
                        currentToken, line));
            }
            try {
                currentToken = tokenizer.nextToken();
            } catch (NoSuchElementException e) {
                throw new IllegalStateException(
                        sm.getString(
                                "Duration unit not found after amount {} in directive '{}'",
                                Integer.valueOf(amount), line));
            }
            DurationUnit durationUnit;
            if ("years".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.YEAR;
            } else if ("month".equalsIgnoreCase(currentToken) ||
                    "months".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.MONTH;
            } else if ("week".equalsIgnoreCase(currentToken) ||
                    "weeks".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.WEEK;
            } else if ("day".equalsIgnoreCase(currentToken) ||
                    "days".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.DAY;
            } else if ("hour".equalsIgnoreCase(currentToken) ||
                    "hours".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.HOUR;
            } else if ("minute".equalsIgnoreCase(currentToken) ||
                    "minutes".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.MINUTE;
            } else if ("second".equalsIgnoreCase(currentToken) ||
                    "seconds".equalsIgnoreCase(currentToken)) {
                durationUnit = DurationUnit.SECOND;
            } else {
                throw new IllegalStateException(
                        sm.getString(
                                "Invalid duration unit (years|months|weeks|days|hours|minutes|seconds) '{}' in directive '{}'",
                                currentToken, line));
            }
            Duration duration = new Duration(amount, durationUnit);
            durations.add(duration);
            if (tokenizer.hasMoreTokens()) {
                currentToken = tokenizer.nextToken();
            } else {
                currentToken = null;
            }
        }
        return new ExpiresConfiguration(startingPoint, durations);
    }
    public void setActive(boolean active) {
        this.active = active;
    }
    public void setDefaultExpiresConfiguration(
            ExpiresConfiguration defaultExpiresConfiguration) {
        this.defaultExpiresConfiguration = defaultExpiresConfiguration;
    }
    public void setExcludedResponseStatusCodes(int[] excludedResponseStatusCodes) {
        this.excludedResponseStatusCodes = excludedResponseStatusCodes;
    }
    public void setExpiresConfigurationByContentType(
            Map<String, ExpiresConfiguration> expiresConfigurationByContentType) {
        this.expiresConfigurationByContentType = expiresConfigurationByContentType;
    }
    @Override
    public String toString() {
        return getClass().getSimpleName() + "[active=" + this.active +
                ", excludedResponseStatusCode=[" +
                intsToCommaDelimitedString(this.excludedResponseStatusCodes) +
                "], default=" + this.defaultExpiresConfiguration + ", byType=" +
                this.expiresConfigurationByContentType + "]";
    }
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    public static final String TEMP_DIR = System.getProperty("java.io.tmpdir");
    public void testConfiguration() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        Context root = tomcat.addContext("", TEMP_DIR);
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("ExpiresDefault", "access plus 1 month");
        filterDef.addInitParameter("ExpiresByType text/html",
                "access plus 1 month 15 days 2 hours");
        filterDef.addInitParameter("ExpiresByType image/gif",
                "modification plus 5 hours 3 minutes");
        filterDef.addInitParameter("ExpiresByType image/jpg", "A10000");
        filterDef.addInitParameter("ExpiresByType video/mpeg", "M20000");
        filterDef.addInitParameter("ExpiresActive", "Off");
        filterDef.addInitParameter("ExpiresExcludedResponseStatusCodes",
                "304, 503");
        ExpiresFilter expiresFilter = new ExpiresFilter();
        filterDef.setFilter(expiresFilter);
        filterDef.setFilterClass(ExpiresFilter.class.getName());
        filterDef.setFilterName(ExpiresFilter.class.getName());
        root.addFilterDef(filterDef);
        FilterMap filterMap = new FilterMap();
        filterMap.setFilterName(ExpiresFilter.class.getName());
        filterMap.addURLPattern("*");
        tomcat.start();
        try {
            Assert.assertEquals(false, expiresFilter.isActive());
            // VERIFY EXCLUDED RESPONSE STATUS CODES
            {
                int[] excludedResponseStatusCodes = expiresFilter.getExcludedResponseStatusCodesAsInts();
                Assert.assertEquals(2, excludedResponseStatusCodes.length);
                Assert.assertEquals(304, excludedResponseStatusCodes[0]);
                Assert.assertEquals(503, excludedResponseStatusCodes[1]);
            }
            // VERIFY DEFAULT CONFIGURATION
            {
                ExpiresConfiguration expiresConfiguration = expiresFilter.getDefaultExpiresConfiguration();
                Assert.assertEquals(StartingPoint.ACCESS_TIME,
                        expiresConfiguration.getStartingPoint());
                Assert.assertEquals(1,
                        expiresConfiguration.getDurations().size());
                Assert.assertEquals(DurationUnit.MONTH,
                        expiresConfiguration.getDurations().get(0).getUnit());
                Assert.assertEquals(1, expiresConfiguration.getDurations().get(
                        0).getAmount());
            }
            // VERIFY TEXT/HTML
            {
                ExpiresConfiguration expiresConfiguration = expiresFilter.getExpiresConfigurationByContentType().get(
                        "text/html");
                Assert.assertEquals(StartingPoint.ACCESS_TIME,
                        expiresConfiguration.getStartingPoint());
                Assert.assertEquals(3,
                        expiresConfiguration.getDurations().size());
                Duration oneMonth = expiresConfiguration.getDurations().get(0);
                Assert.assertEquals(DurationUnit.MONTH, oneMonth.getUnit());
                Assert.assertEquals(1, oneMonth.getAmount());
                Duration fifteenDays = expiresConfiguration.getDurations().get(
                        1);
                Assert.assertEquals(DurationUnit.DAY, fifteenDays.getUnit());
                Assert.assertEquals(15, fifteenDays.getAmount());
                Duration twoHours = expiresConfiguration.getDurations().get(2);
                Assert.assertEquals(DurationUnit.HOUR, twoHours.getUnit());
                Assert.assertEquals(2, twoHours.getAmount());
            }
            // VERIFY IMAGE/GIF
            {
                ExpiresConfiguration expiresConfiguration = expiresFilter.getExpiresConfigurationByContentType().get(
                        "image/gif");
                Assert.assertEquals(StartingPoint.LAST_MODIFICATION_TIME,
                        expiresConfiguration.getStartingPoint());
                Assert.assertEquals(2,
                        expiresConfiguration.getDurations().size());
                Duration fiveHours = expiresConfiguration.getDurations().get(0);
                Assert.assertEquals(DurationUnit.HOUR, fiveHours.getUnit());
                Assert.assertEquals(5, fiveHours.getAmount());
                Duration threeMinutes = expiresConfiguration.getDurations().get(
                        1);
                Assert.assertEquals(DurationUnit.MINUTE, threeMinutes.getUnit());
                Assert.assertEquals(3, threeMinutes.getAmount());
            }
            // VERIFY IMAGE/JPG
            {
                ExpiresConfiguration expiresConfiguration = expiresFilter.getExpiresConfigurationByContentType().get(
                        "image/jpg");
                Assert.assertEquals(StartingPoint.ACCESS_TIME,
                        expiresConfiguration.getStartingPoint());
                Assert.assertEquals(1,
                        expiresConfiguration.getDurations().size());
                Duration tenThousandSeconds = expiresConfiguration.getDurations().get(
                        0);
                Assert.assertEquals(DurationUnit.SECOND,
                        tenThousandSeconds.getUnit());
                Assert.assertEquals(10000, tenThousandSeconds.getAmount());
            }
            // VERIFY VIDEO/MPEG
            {
                ExpiresConfiguration expiresConfiguration = expiresFilter.getExpiresConfigurationByContentType().get(
                        "video/mpeg");
                Assert.assertEquals(StartingPoint.LAST_MODIFICATION_TIME,
                        expiresConfiguration.getStartingPoint());
                Assert.assertEquals(1,
                        expiresConfiguration.getDurations().size());
                Duration twentyThousandSeconds = expiresConfiguration.getDurations().get(
                        0);
                Assert.assertEquals(DurationUnit.SECOND,
                        twentyThousandSeconds.getUnit());
                Assert.assertEquals(20000, twentyThousandSeconds.getAmount());
            }
        } finally {
            tomcat.stop();
        }
    }
    /**
     * Test that a resource with empty content is also processed
     */
    public void testEmptyContent() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("text/plain");
                // no content is written in the response
            }
        };
        validate(servlet, Integer.valueOf(7 * 60));
    }
    public void testParseExpiresConfigurationCombinedDuration() {
        ExpiresFilter expiresFilter = new ExpiresFilter();
        ExpiresConfiguration actualConfiguration = expiresFilter.parseExpiresConfiguration("access plus 1 month 15 days 2 hours");
        Assert.assertEquals(StartingPoint.ACCESS_TIME,
                actualConfiguration.getStartingPoint());
        Assert.assertEquals(3, actualConfiguration.getDurations().size());
    }
    public void testParseExpiresConfigurationMonoDuration() {
        ExpiresFilter expiresFilter = new ExpiresFilter();
        ExpiresConfiguration actualConfiguration = expiresFilter.parseExpiresConfiguration("access plus 2 hours");
        Assert.assertEquals(StartingPoint.ACCESS_TIME,
                actualConfiguration.getStartingPoint());
        Assert.assertEquals(1, actualConfiguration.getDurations().size());
        Assert.assertEquals(2,
                actualConfiguration.getDurations().get(0).getAmount());
        Assert.assertEquals(DurationUnit.HOUR,
                actualConfiguration.getDurations().get(0).getUnit());
    }
    public void testSkipBecauseCacheControlMaxAgeIsDefined() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("text/xml; charset=utf-8");
                response.addHeader("Cache-Control", "private, max-age=232");
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, Integer.valueOf(232));
    }
    public void testExcludedResponseStatusCode() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                response.addHeader("ETag", "W/\"1934-1269208821000\"");
                response.addDateHeader("Date", System.currentTimeMillis());
            }
        };
        validate(servlet, null, HttpServletResponse.SC_NOT_MODIFIED);
    }
    public void testNullContentType() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType(null);
            }
        };
        validate(servlet, Integer.valueOf(1 * 60));
    }
    public void testSkipBecauseExpiresIsDefined() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("text/xml; charset=utf-8");
                response.addDateHeader("Expires", System.currentTimeMillis());
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, null);
    }
    public void testUseContentTypeExpiresConfiguration() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("text/xml; charset=utf-8");
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, Integer.valueOf(3 * 60));
    }
    public void testUseContentTypeWithoutCharsetExpiresConfiguration()
            throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("text/xml; charset=iso-8859-1");
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, Integer.valueOf(5 * 60));
    }
    public void testUseDefaultConfiguration1() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("image/jpeg");
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, Integer.valueOf(1 * 60));
    }
    public void testUseDefaultConfiguration2() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("image/jpeg");
                response.addHeader("Cache-Control", "private");
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, Integer.valueOf(1 * 60));
    }
    public void testUseMajorTypeExpiresConfiguration() throws Exception {
        HttpServlet servlet = new HttpServlet() {
            private static final long serialVersionUID = 1L;
            @Override
            protected void service(HttpServletRequest request,
                    HttpServletResponse response) throws ServletException,
                    IOException {
                response.setContentType("text/json; charset=iso-8859-1");
                response.getWriter().print("Hello world");
            }
        };
        validate(servlet, Integer.valueOf(7 * 60));
    }
    protected void validate(HttpServlet servlet, Integer expectedMaxAgeInSeconds)
            throws Exception {
        validate(servlet, expectedMaxAgeInSeconds, HttpURLConnection.HTTP_OK);
    }
    protected void validate(HttpServlet servlet,
            Integer expectedMaxAgeInSeconds, int expectedResponseStatusCode)
            throws Exception {
        // SETUP
        Tomcat tomcat = getTomcatInstance();
        Context root = tomcat.addContext("", TEMP_DIR);
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("ExpiresDefault", "access plus 1 minute");
        filterDef.addInitParameter("ExpiresByType text/xml;charset=utf-8",
                "access plus 3 minutes");
        filterDef.addInitParameter("ExpiresByType text/xml",
                "access plus 5 minutes");
        filterDef.addInitParameter("ExpiresByType text",
                "access plus 7 minutes");
        filterDef.addInitParameter("ExpiresExcludedResponseStatusCodes",
                "304, 503");
        filterDef.setFilterClass(ExpiresFilter.class.getName());
        filterDef.setFilterName(ExpiresFilter.class.getName());
        root.addFilterDef(filterDef);
        FilterMap filterMap = new FilterMap();
        filterMap.setFilterName(ExpiresFilter.class.getName());
        filterMap.addURLPattern("*");
        root.addFilterMap(filterMap);
        Tomcat.addServlet(root, servlet.getClass().getName(), servlet);
        root.addServletMapping("/test", servlet.getClass().getName());
        tomcat.start();
        try {
            Calendar.getInstance(TimeZone.getTimeZone("GMT"));
            long timeBeforeInMillis = System.currentTimeMillis();
            // TEST
            HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(
                    "http://localhost:" + tomcat.getConnector().getPort() +
                            "/test").openConnection();
            // VALIDATE
            Assert.assertEquals(expectedResponseStatusCode,
                    httpURLConnection.getResponseCode());
            StringBuilder msg = new StringBuilder();
            for (Entry<String, List<String>> field : httpURLConnection.getHeaderFields().entrySet()) {
                for (String value : field.getValue()) {
                    msg.append((field.getKey() == null ? "" : field.getKey() +
                            ": ") +
                            value + "\n");
                }
            }
            System.out.println(msg);
            Integer actualMaxAgeInSeconds;
            String cacheControlHeader = httpURLConnection.getHeaderField("Cache-Control");
            if (cacheControlHeader == null) {
                actualMaxAgeInSeconds = null;
            } else {
                actualMaxAgeInSeconds = null;
                StringTokenizer cacheControlTokenizer = new StringTokenizer(
                        cacheControlHeader, ",");
                while (cacheControlTokenizer.hasMoreTokens() &&
                        actualMaxAgeInSeconds == null) {
                    String cacheDirective = cacheControlTokenizer.nextToken();
                    StringTokenizer cacheDirectiveTokenizer = new StringTokenizer(
                            cacheDirective, "=");
                    if (cacheDirectiveTokenizer.countTokens() == 2) {
                        String key = cacheDirectiveTokenizer.nextToken().trim();
                        String value = cacheDirectiveTokenizer.nextToken().trim();
                        if (key.equalsIgnoreCase("max-age")) {
                            actualMaxAgeInSeconds = Integer.valueOf(value);
                        }
                    }
                }
            }
            if (expectedMaxAgeInSeconds == null) {
                Assert.assertNull("actualMaxAgeInSeconds '" +
                        actualMaxAgeInSeconds + "' should be null",
                        actualMaxAgeInSeconds);
                return;
            }
            Assert.assertNotNull(actualMaxAgeInSeconds);
            @SuppressWarnings("null")
            int deltaInSeconds = Math.abs(actualMaxAgeInSeconds.intValue() -
                    expectedMaxAgeInSeconds.intValue());
            Assert.assertTrue("actualMaxAgeInSeconds: " +
                    actualMaxAgeInSeconds + ", expectedMaxAgeInSeconds: " +
                    expectedMaxAgeInSeconds + ", request time: " +
                    timeBeforeInMillis + " for content type " +
                    httpURLConnection.getContentType(), deltaInSeconds < 3);
        } finally {
            tomcat.stop();
        }
    }
    public void testIntsToCommaDelimitedString() {
        String actual = ExpiresFilter.intsToCommaDelimitedString(new int[] {
                500, 503 });
        String expected = "500, 503";
        Assert.assertEquals(expected, actual);
    }
      <add>
        <bug>48998</bug>: Add the ExpiresFilter, a port of the httpd mod_expires
        module. Patch provided by Cyrille Le Clerc. (markt)
      </add>
  <subsection name="Introduction">
    <p>
    ExpiresFilter is a Java Servlet API port of <a
    href="http://httpd.apache.org/docs/2.2/mod/mod_expires.html">Apache
    mod_expires</a>.
    This filter controls the setting of the <tt>Expires</tt> HTTP header and the
    <tt>max-age</tt> directive of the <tt>Cache-Control</tt> HTTP header in
    server responses. The expiration date can set to be relative to either the
    time the source file was last modified, or to the time of the client access.
    </p>
    
    <p>
    These HTTP headers are an instruction to the client about the document&#x27;s
    validity and persistence. If cached, the document may be fetched from the
    cache rather than from the source until this time has passed. After that, the
    cache copy is considered &quot;expired&quot; and invalid, and a new copy must
    be obtained from the source.
    </p>
    <p>
    To modify <tt>Cache-Control</tt> directives other than <tt>max-age</tt> (see
    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9" >RFC
    2616 section 14.9</a>), you can use other servlet filters or <a
    href="http://httpd.apache.org/docs/2.2/mod/mod_headers.html" >Apache Httpd
    mod_headers</a> module.
    </p>
        
  </subsection>
  <subsection name="Basic configuration sample">
    <p>
    Basic configuration to add '<tt>Expires</tt>' and '<tt>Cache-Control: max-age=</tt>' 
    headers to images, css and javascript.
    </p>
    <source>
 &lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt;
 &lt;filter-class&gt;org.apache.catalina.filters.ExpiresFilter&lt;/filter-class&gt;
 &lt;init-param&gt;
    &lt;param-name&gt;ExpiresByType image&lt;/param-name&gt;
    &lt;param-value&gt;access plus 10 minutes&lt;/param-value&gt;
 &lt;/init-param&gt;
 &lt;init-param&gt;
    &lt;param-name&gt;ExpiresByType text/css&lt;/param-name&gt;
    &lt;param-value&gt;access plus 10 minutes&lt;/param-value&gt;
 &lt;/init-param&gt;
 &lt;init-param&gt;
    &lt;param-name&gt;ExpiresByType text/javascript&lt;/param-name&gt;
    &lt;param-value&gt;access plus 10 minutes&lt;/param-value&gt;
 &lt;/init-param&gt;
 &lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt;
 &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
 &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
    </source>
    
  </subsection>
  
  <subsection name="Alternate Syntax">
    <p>
    The <tt>ExpiresDefault</tt> and <tt>ExpiresByType</tt> directives can also be
    defined in a more readable syntax of the form:
    </p>
    
    <source>
 &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;
 &lt;param-value&gt;&lt;base&gt; [plus] {&lt;num&gt;   &lt;type&gt;}*&lt;/param-value&gt;
 &lt;param-name&gt;ExpiresByType type&lt;/param-name&gt;
 &lt;param-value&gt;&lt;base&gt; [plus]   {&lt;num&gt; &lt;type&gt;}*&lt;/param-value&gt;
 &lt;param-name&gt;ExpiresByType type;encoding&lt;/param-name&gt;
 &lt;param-value&gt;&lt;base&gt; [plus]   {&lt;num&gt; &lt;type&gt;}*&lt;/param-value&gt;
    </source>
    <p>
    where <tt>&lt;base&gt;</tt> is one of:
    <ul>
    <li><tt>access</tt></li>
    <li><tt>now</tt> (equivalent to &#x27;<tt>access</tt>&#x27;)</li>
    <li><tt>modification</tt></li>
    </ul>
    </p>
    <p>
    The <tt>plus</tt> keyword is optional. <tt>&lt;num&gt;</tt> should be an
    integer value (acceptable to <tt>Integer.parseInt()</tt>), and
    <tt>&lt;type&gt;</tt> is one of:
    <ul>
    <li><tt>years</tt></li>
    <li><tt>months</tt></li>
    <li><tt>weeks</tt></li>
    <li><tt>days</tt></li>
    <li><tt>hours</tt></li>
    <li><tt>minutes</tt></li>
    <li><tt>seconds</tt></li>
    </ul>
    For example, any of the following directives can be used to make documents
    expire 1 month after being accessed, by default:
    </p>
    
    <source>
 &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;
 &lt;param-value&gt;access plus 1 month&lt;/param-value&gt;
 &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;
 &lt;param-value&gt;access plus 4 weeks&lt;/param-value&gt;
 &lt;param-name&gt;ExpiresDefault&lt;/param-name&gt;
 &lt;param-value&gt;access plus 30 days&lt;/param-value&gt;
 &lt;param-name&gt;ExpiresByType text/html&lt;/param-name&gt;
 &lt;param-value&gt;access plus 1 month 15   days 2 hours&lt;/param-value&gt;
 &lt;param-name&gt;ExpiresByType image/gif&lt;/param-name&gt;
 &lt;param-value&gt;modification plus 5 hours 3   minutes&lt;/param-value&gt;
    </source>
    <p>
    Note that if you use a modification date based setting, the <tt>Expires</tt>
    header will <strong>not</strong> be added to content that does not come from
    a file on disk. This is due to the fact that there is no modification time
    for such content.
    </p>  
  </subsection>
  
  <subsection name="Expiration headers generation eligibility">
    <p>
    A response is eligible to be enriched by <tt>ExpiresFilter</tt> if :
    <ol>
    <li>no expiration header is defined (<tt>Expires</tt> header or the
    <tt>max-age</tt> directive of the <tt>Cache-Control</tt> header),</li>
    <li>the response status code is not excluded by the directive
    <tt>ExpiresExcludedResponseStatusCodes</tt>,</li>
    <li>The <tt>Content-Type</tt> of the response matches one of the types
    defined the in <tt>ExpiresByType</tt> directives or the
    <tt>ExpiresDefault</tt> directive is defined.</li>
    </ol>
    </p>
    <p>
    Note : If <tt>Cache-Control</tt> header contains other directives than
    <tt>max-age</tt>, they are concatenated with the <tt>max-age</tt> directive
    that is added by the <tt>ExpiresFilter</tt>.
    </p>
  </subsection>
  
  <subsection name="Expiration configuration selection">
    <p>
    The expiration configuration if elected according to the following algorithm:
    <ol>
    <li><tt>ExpiresByType</tt> matching the exact content-type returned by
    <tt>HttpServletResponse.getContentType()</tt> possibly including the charset
    (e.g. &#x27;<tt>text/xml;charset=UTF-8</tt>&#x27;),</li>
    <li><tt>ExpiresByType</tt> matching the content-type without the charset if
    <tt>HttpServletResponse.getContentType()</tt> contains a charset (e.g. &#x27;
    <tt>text/xml;charset=UTF-8</tt>&#x27; -&gt; &#x27;<tt>text/xml</tt>&#x27;),</li>
    <li><tt>ExpiresByType</tt> matching the major type (e.g. substring before
    &#x27;<tt>/</tt>&#x27;) of <tt>HttpServletResponse.getContentType()</tt>
    (e.g. &#x27;<tt>text/xml;charset=UTF-8</tt>&#x27; -&gt; &#x27;<tt>text</tt>
    &#x27;),</li>
    <li><tt>ExpiresDefault</tt></li>
    </ol>
    </p>
  </subsection>
  <subsection name="Filter Class Name">
    <p>The filter class name for the Expires Filter is
    <strong><code>org.apache.catalina.filters.ExpiresFilter</code>
    </strong>.</p>
  </subsection>
  
  <subsection name="Initialisation parameters">
    <p>The <strong>Expires Filter</strong> supports the following
    initialisation parameters:</p>
    <attributes>
      <attribute name="ExpiresActive" required="false">
        <p>
        This directive enables or disables the generation of the <tt>Expires</tt> and
        <tt>Cache-Control</tt> headers by this <tt>ExpiresFilter</tt>. If set to
        <tt>Off</tt>, the headers will not be generated for any HTTP response. If set
        to <tt>On</tt> or <tt>true</tt>, the headers will be added to served HTTP
        responses according to the criteria defined by the
        <tt>ExpiresByType &lt;content-type&gt;</tt> and <tt>ExpiresDefault</tt>
        directives. Note that this directive does not guarantee that an
        <tt>Expires</tt> or <tt>Cache-Control</tt> header will be generated. If the
        criteria aren&#x27;t met, no header will be sent, and the effect will be as
        though this directive wasn&#x27;t even specified.
        </p>
        <p>
        Default value is <tt>true</tt>.
        </p>
        
        <p>
        <i>Sample: enable filter</i>
        </p>
    
        <source>
 &lt;!-- supports case insensitive &#x27;On&#x27; or &#x27;true&#x27; --&gt;
 &lt;param-name&gt;ExpiresActive&lt;/param-name&gt;
 &lt;param-value&gt;On&lt;/param-value&gt;
         </source>
         <p>
         <i>Sample: disable filter</i>
         </p>
    
         <source>
 &lt;!-- supports anything different from case insensitive &#x27;On&#x27; and &#x27;true&#x27; --&gt;
 &lt;param-name&gt;ExpiresActive&lt;/param-name&gt;
 &lt;param-value&gt;Off&lt;/param-value&gt;
         </source>
      </attribute>
      <attribute name="ExpiresExcludedResponseStatusCodes" required="false">
         <p>
         This directive defines the http response status codes for which the
         <tt>ExpiresFilter</tt> will not generate expiration headers. By default, the
         <tt>304</tt> status code (&quot;<tt>Not modified</tt>&quot;) is skipped. The
         value is a comma separated list of http status codes.
         </p>
         <p>
         This directive is useful to ease usage of <tt>ExpiresDefault</tt> directive.
         Indeed, the behavior of <tt>304 Not modified</tt> (which does specify a
         <tt>Content-Type</tt> header) combined with <tt>Expires</tt> and
         <tt>Cache-Control:max-age=</tt> headers can be unnecessarily tricky to
         understand.
         </p>
         <p>
         <i>Sample : exclude response status codes 302, 500 and 503</i>
         </p>
         
         <source>
 &lt;param-name&gt;ExpiresExcludedResponseStatusCodes&lt;/param-name&gt;
 &lt;param-value&gt;302, 500, 503&lt;/param-value&gt;
         </source>
      </attribute>
      <attribute name="ExpiresByType &lt;content-type&gt;" required="false">
         <p>
         This directive defines the value of the <tt>Expires</tt> header and the
         <tt>max-age</tt> directive of the <tt>Cache-Control</tt> header generated for
         documents of the specified type (<i>e.g.</i>, <tt>text/html</tt>). The second
         argument sets the number of seconds that will be added to a base time to
         construct the expiration date. The <tt>Cache-Control: max-age</tt> is
         calculated by subtracting the request time from the expiration date and
         expressing the result in seconds.
         </p>
         <p>
         The base time is either the last modification time of the file, or the time
         of the client&#x27;s access to the document. Which should be used is
         specified by the <tt>&lt;code&gt;</tt> field; <tt>M</tt> means that the
         file&#x27;s last modification time should be used as the base time, and
         <tt>A</tt> means the client&#x27;s access time should be used. The duration
         is expressed in seconds. <tt>A2592000</tt> stands for
         <tt>access plus 30 days</tt> in alternate syntax.
         </p>
         <p>
         The difference in effect is subtle. If <tt>M</tt> (<tt>modification</tt> in
         alternate syntax) is used, all current copies of the document in all caches
         will expire at the same time, which can be good for something like a weekly
         notice that&#x27;s always found at the same URL. If <tt>A</tt> (
         <tt>access</tt> or <tt>now</tt> in alternate syntax) is used, the date of
         expiration is different for each client; this can be good for image files
         that don&#x27;t change very often, particularly for a set of related
         documents that all refer to the same images (<i>i.e.</i>, the images will be
         accessed repeatedly within a relatively short timespan).
         </p>
         <p>
         <strong>Note:</strong> When the content type includes a charset (e.g. 
         <tt>'ExpiresByType text/xml;charset=utf-8'</tt>), Tomcat removes blank chars 
         between the '<tt>;</tt>' and the '<tt>charset</tt>' keyword. Due to this, 
         configuration of an expiration with a charset must <strong>not</strong> include 
         such a space character. 
         </p>
         <p>
         <i>Sample:</i>
         </p>
         
         <source>
   &lt;param-name&gt;ExpiresByType text/html&lt;/param-name&gt;
   &lt;param-value&gt;access plus 1 month 15   days 2 hours&lt;/param-value&gt;
 
   &lt;!-- 2592000 seconds = 30 days --&gt;
   &lt;param-name&gt;ExpiresByType image/gif&lt;/param-name&gt;
   &lt;param-value&gt;A2592000&lt;/param-value&gt;
         </source>
         <p>
         Note that this directive only has effect if <tt>ExpiresActive On</tt> has
         been specified. It overrides, for the specified MIME type <i>only</i>, any
         expiration date set by the <tt>ExpiresDefault</tt> directive.
         </p>
         <p>
         You can also specify the expiration time calculation using an alternate
         syntax, described earlier in this document.
         </p>
      </attribute>
      <attribute name="ExpiresDefault" required="false">
         <p>
         This directive sets the default algorithm for calculating the
         expiration time for all documents in the affected realm. It can be
         overridden on a type-by-type basis by the <tt>ExpiresByType</tt> directive. See the
         description of that directive for details about the syntax of the
         argument, and the "alternate syntax"
         description as well.
         </p>
      </attribute>
    </attributes>
  </subsection>
  
  <subsection name="Troubleshooting">
    <p>
    To troubleshoot, enable logging on the
    <tt>org.apache.catalina.filters.ExpiresFilter</tt>.
    </p>
    <p>
    Extract of logging.properties
    </p>
    
    <source>
    </source>
    <p>
    Sample of initialization log message :
    </p>
    
    <source>
 active=true, 
 excludedResponseStatusCode=[304], 
 default=null, 
 byType={
    image=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]], 
    text/css=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]], 
    text/javascript=ExpiresConfiguration[startingPoint=ACCESS_TIME, duration=[10 MINUTE]]}]
    </source>
    <p>
    Sample of per-request log message where <tt>ExpiresFilter</tt> adds an
    expiration date
    </p>
    
    <source>
    </source>
    <p>
    Sample of per-request log message where <tt>ExpiresFilter</tt> does not add
    an expiration date
    </p>
    
    <source>
    </source>
  </subsection>

======= eca4ed9:"java/org/apache/catalina/ha/session/SimpleTcpReplicationManager.java"

                    } catch (InterruptedException sleep) { /* Ignore */ }
        <bug>49127</bug>: Don't swallow exceptions unnecessarily in
        <code>SimpleTcpReplicationManager.startInternal()</code>. (markt)
      </fix>
      <fix>

======= e8245ef:"java/org/apache/catalina/loader/WebappClassLoader.java"

        } catch (SecurityException e) {
        <bug>49128</bug>: Don't swallow exceptions unnecessarily in
        <code>WebappClassLoader.start()</code>. (markt)
      </fix>
      <fix>

  <!--                                                                      -->
  <!--   allowExec           Is use of the exec command enabled? [false]    -->
  <!--                                                                      -->
  <!--   allowExec           Is use of the exec command enabled? [false]    -->
======= a36b0c0:"java/org/apache/catalina/ssi/SSIFilter.java"

======= a36b0c0:"java/org/apache/catalina/ssi/SSIFilter.java"

        allowExec = Boolean.parseBoolean(config.getInitParameter("allowExec"));
======= a36b0c0:"java/org/apache/catalina/ssi/SSIFilter.java"

                    debug, allowExec);
======= a36b0c0:"java/org/apache/catalina/ssi/SSIProcessor.java"

    protected final boolean allowExec;
    public SSIProcessor(SSIExternalResolver ssiExternalResolver, int debug,
            boolean allowExec) {
        this.allowExec = allowExec;
======= a36b0c0:"java/org/apache/catalina/ssi/SSIProcessor.java"

        if (allowExec) {
            addCommand("exec", new SSIExec());
        }
======= a36b0c0:"java/org/apache/catalina/ssi/SSIServlet.java"

    /** Allow exec (normally blocked for security) */
    protected boolean allowExec = false;
======= a36b0c0:"java/org/apache/catalina/ssi/SSIServlet.java"

        allowExec = Boolean.parseBoolean(
                getServletConfig().getInitParameter("allowExec"));
======= a36b0c0:"java/org/apache/catalina/ssi/SSIServlet.java"

                debug, allowExec);
      <add>
        <bug>48960</bug>: Add a new option to the SSI Servlet and SSI Filter to
        allow the disabling of the <code>exec</code> command. This is now
        disabled by default. Based on a patch by Yair Lenga. (markt)
      </add>

======= 4159093:"java/org/apache/tomcat/util/res/StringManager.java"

    private final ResourceBundle bundle;
    private final Locale locale;
======= 4159093:"java/org/apache/tomcat/util/res/StringManager.java"

        ResourceBundle bnd = null;
            bnd = ResourceBundle.getBundle(bundleName, Locale.getDefault());
======= 4159093:"java/org/apache/tomcat/util/res/StringManager.java"

                    bnd = ResourceBundle.getBundle(
        bundle = bnd;
        } else {
            locale = null;
======= 4159093:"java/org/apache/tomcat/util/res/StringManager.java"

    private static final Hashtable<String, StringManager> managers =

======= d6766f1:"java/org/apache/catalina/filters/AddDefaultCharsetFilter.java"

======= d6766f1:"java/org/apache/catalina/filters/AddDefaultCharsetFilter.java"

 * the "text" type to ISO-8859-1, or another user defined character set. RFC2616
 * explicitly states that browsers must use ISO-8859-1 if no character set is
 * defined for media with subtype "text". However, browsers may attempt to
 * browsers have an option to enable it.<br/>
    private static final Log log =
        LogFactory.getLog(AddDefaultCharsetFilter.class);
    private static final String DEFAULT_ENCODING = "ISO-8859-1";
    
    private String encoding;
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }
    @Override
    protected Log getLogger() {
        return log;
    }
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        super.init(filterConfig);
        if (encoding == null || encoding.length() == 0 ||
                encoding.equalsIgnoreCase("default")) {
            encoding = DEFAULT_ENCODING;
        } else if (encoding.equalsIgnoreCase("system")) {
            encoding = Charset.defaultCharset().name();
        } else if (!Charset.isSupported(encoding)) {
            throw new IllegalArgumentException(sm.getString(
                    "addDefaultCharset.unsupportedCharset", encoding));
        }
======= d6766f1:"java/org/apache/catalina/filters/AddDefaultCharsetFilter.java"

                new ResponseWrapper((HttpServletResponse)response, encoding);
     * Wrapper that adds a character set for text media types if no character
     * set is specified.
    public static class ResponseWrapper extends HttpServletResponseWrapper {
        private String encoding;
        
        public ResponseWrapper(HttpServletResponse response, String encoding) {
            super(response);
            this.encoding = encoding;
        }
            if (ct != null && ct.startsWith("text/")) {
                if (ct.indexOf("charset=") < 0) {
                    super.setContentType(ct + ";charset=" + encoding);
                } else {
                    super.setContentType(ct);
                    encoding = getCharacterEncoding();
                }
        @Override
        public void setCharacterEncoding(String charset) {
            super.setCharacterEncoding(charset);
            encoding = charset;
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    public void testNoneSpecifiedMode1() throws Exception {
        doTest(null, "ISO-8859-1");
    }
    public void testNoneSpecifiedMode2() throws Exception {
        doTest(null, "ISO-8859-2", 2);
    }
    public void testNoneSpecifiedMode3() throws Exception {
        doTest(null, "ISO-8859-3", 3);
    }
    public void testDefault() throws Exception {
        doTest("default", "ISO-8859-1");
    }
    public void testDefaultMixedCase() throws Exception {
        doTest("dEfAuLt", "ISO-8859-1");
    }
    public void testSystem() throws Exception {
        doTest("system", Charset.defaultCharset().name());
    }
    public void testSystemMixedCase() throws Exception {
        doTest("SyStEm", Charset.defaultCharset().name());
    }
    public void testUTF8() throws Exception {
        doTest("utf-8", "utf-8");
    }
    private void doTest(String encoding, String expected) throws Exception {
        doTest(encoding, expected, 1);
    }
    
    private void doTest(String encoding, String expected, int mode)
            throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        
        // Must have a real docBase - just use temp
        Context ctx = 
            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
        // Add the Servlet
        CharsetServlet servlet = new CharsetServlet(mode);
        Tomcat.addServlet(ctx, "servlet", servlet);
        ctx.addServletMapping("/", "servlet");
        
        // Add the Filter
        FilterDef filterDef = new FilterDef();
        filterDef.setFilterClass(AddDefaultCharsetFilter.class.getName());
        filterDef.setFilterName("filter");
        if (encoding != null) {
            filterDef.addInitParameter("encoding", encoding);
        }
        ctx.addFilterDef(filterDef);
        FilterMap filterMap = new FilterMap();
        filterMap.setFilterName("filter");
        filterMap.addServletName("servlet");
        ctx.addFilterMap(filterMap);
        
        tomcat.start();
        Map<String, List<String>> headers = new HashMap<String, List<String>>();
        getUrl("http://localhost:" + getPort() + "/", new ByteChunk(), headers);
        
        List<String> ctHeaders = headers.get("Content-Type");
        assertEquals(1, ctHeaders.size());
        String ct = ctHeaders.get(0);
        assertEquals("text/plain;charset=" + expected, ct);
    }
    private static class CharsetServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private static final String OUTPUT = "OK";
        
        private final int mode;
        
        public CharsetServlet(int mode) {
            this.mode = mode;
        }
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {
            
            switch (mode) {
                case 1:
                    resp.setContentType("text/plain");
                    break;
                case 2:
                    resp.setContentType("text/plain;charset=ISO-8859-2"); 
                    break;
                case 3:
                    resp.setContentType("text/plain");
                    resp.setCharacterEncoding("ISO-8859-3");
                    break;
                default:
                    resp.setContentType("text/plain;charset=ISO-8859-4");
                    break;
            }
            resp.getWriter().print(OUTPUT);
        }
    }
      <add>
        <bug>49478</bug>: Add support for user specified character sets to the
        <code>AddDefaultCharsetFilter</code>. Based on a patch by Felix
        Schumacher. (markt)
      </add>
    <p>The Add Default Character Set Filter supports the following initialization
    parameters:</p>
    <attributes>
      <attribute name="encoding" required="false">
        <p>Name of the character set which should be set, if no other character set 
        was set explicitly by a Servlet. This parameter has two special values 
        <code>default</code> and <code>system</code>. A value of <code>system</code>
        uses the JVM wide default character set, which is usually set by locale.
        A value of <code>default</code> will use <strong>ISO-8859-1</strong>.</p>
      </attribute>
    </attributes>

      <fix>
        <bug>49570</bug>: When using the example compression filter, set the
        Vary header on compressed responses. (markt)
      </fix>
======= c191152:"webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java"

                String vary = response.getHeader("Vary");
                if (vary == null) {
                    // Add a new Vary header
                    response.setHeader("Vary", "Accept-Encoding");
                } else if (vary.equals("*")) {
                    // No action required
                } else {
                    // Merge into current header
                    response.setHeader("Vary", vary + ",Accept-Encoding");
                }

======= a90b576:"java/org/apache/catalina/connector/Connector.java"

        try {
            protocolHandler.init();
        } catch (Exception e) {
            throw new LifecycleException
                (sm.getString
                 ("coyoteConnector.protocolHandlerInitializationFailed", e));
        }
======= a90b576:"java/org/apache/catalina/connector/Connector.java"

======= a90b576:"java/org/apache/catalina/connector/Connector.java"

        // MapperListener doesn't follow Lifecycle conventions
======= a90b576:"java/org/apache/catalina/connector/Connector.java"

        // MapperListener doesn't follow Lifecycle conventions
======= a90b576:"java/org/apache/catalina/connector/Connector.java"

        try {
            protocolHandler.destroy();
        } catch (Exception e) {
            throw new LifecycleException
                (sm.getString
                 ("coyoteConnector.protocolHandlerDestroyFailed", e));
        }
        <bug>49503</bug>: Make sure connectors bind to their associated ports
        sufficiently early to allow jsvc and the
        org.apache.catalina.startup.EXIT_ON_INIT_FAILURE system property to
        operate correctly. (markt)
      </fix>
      <fix>

======= dca6dd1:"java/org/apache/catalina/startup/ContextConfig.java"

        // Open the default context.xml file, if it exists
======= dca6dd1:"java/org/apache/catalina/startup/ContextConfig.java"

            File defaultContextFile = new File(defaultContextXml);
            if (!defaultContextFile.isAbsolute()) {
                defaultContextFile =new File(getBaseDir(), defaultContextXml);
            }
      <fix>
        <bug>49551</bug>: Allow default context.xml location to be specified
        using an absolute path. (markt)
      </fix>

======= 7b9630b:"java/org/apache/catalina/connector/Response.java"

    @SuppressWarnings("deprecation") // isSpace (deprecated) cannot be replaced by isWhiteSpace
======= 7b9630b:"java/org/apache/catalina/connector/Response.java"

                // N.B. isSpace (deprecated) cannot be replaced by isWhiteSpace
      <fix>
        <bug>49550</bug>: Supress deprecation warning where deprecated code is
        required to be used. No functional change. Patch provided by Sebb.
        (markt)
      </fix>

======= 3bd4bcb:"java/org/apache/catalina/core/ContainerBase.java"

        try {
            if (child.getState().isAvailable()) {
                child.stop();
        } catch (LifecycleException e) {
            log.error("ContainerBase.removeChild: stop: ", e);
        <bug>49530</bug>: Contexts and Servlets not stopped when Tomcat is shut
        down. (markt)
      </fix>
      <fix>

======= 4e34898:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        // If there is no context at this point, it is likely no ROOT context
        // has been deployed
        if (request.getContext() == null) {
            res.setStatus(404);
            res.setMessage("Not found");
            // No context, so use host
            request.getHost().logAccess(request, response, 0, true);
            return false;
        }
        
======= 4e34898:"java/org/apache/catalina/connector/MapperListener.java"

        mapper.addHost(host.getName(), aliases, host);
======= 4e34898:"java/org/apache/catalina/connector/MapperListener.java"

        Container host = context.getParent();
        mapper.addContext(host.getName(), host, contextName, context,
                welcomeFiles, resources);
======= 4e34898:"java/org/apache/catalina/connector/Request.java"

        return ((Host) mappingData.host);
======= 4e34898:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

     * @param host Host object
        (String hostName, Object host, String path, Object context,
            addHost(hostName, new String[0], host);
        Host mappedHost = hosts[pos];
        if (mappedHost.name.equals(hostName)) {
            synchronized (mappedHost) {
                Context[] contexts = mappedHost.contextList.contexts;
                if (slashCount > mappedHost.contextList.nesting) {
                    mappedHost.contextList.nesting = slashCount;
======= 4e34898:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

                    mappedHost.contextList.contexts = newContexts;
      <fix>
        <bug>49536</bug>: If no ROOT context is deployed, ensure a 404 rather
        than a 200 is returned for requests that don't map to any other context.
        (markt)
      </fix>

======= 0b8a9a8:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        // Handle special case of ROOT context where cookies require a path of
        // '/' but the servlet spec uses an empty string
        if (contextPath.length() == 0) {
            contextPath = "/";
        }
      <fix>
        <bug>49525</bug>: Ensure cookies for the ROOT context have a path of /
        rather than an empty string. (markt)
      </fix>

======= 3c88f07:"java/org/apache/catalina/core/StandardContext.java"

                "type=NamingResources," + getObjectKeyPropertiesNameOnly());
======= 3c88f07:"java/org/apache/catalina/core/StandardContext.java"

            new StringBuilder("j2eeType=WebModule,");
        keyProperties.append(getObjectKeyPropertiesNameOnly());
        keyProperties.append(",J2EEApplication=");
        keyProperties.append(getJ2EEApplication());
        keyProperties.append(",J2EEServer=");
        keyProperties.append(getJ2EEServer());
        return keyProperties.toString();
    }
    
    private String getObjectKeyPropertiesNameOnly() {
        StringBuilder result = new StringBuilder("name=");
        String hostname = getParent().getName();
        if (hostname == null) {
            result.append("DEFAULT");
            result.append(hostname);
            result.append('/');
            result.append(pathName);
        return result.toString();
      <fix>
        <bug>49522</bug>: Fix regression due to change of name for MBeans for
        naming resources that broke the complete server status page in the
        manager application. Note these MBeans now have a new name. (markt)
      </fix>

======= a0159a3:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

======= a0159a3:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

    
    private final int nonceCacheSize = 5;
======= a0159a3:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

            @SuppressWarnings("unchecked")
            LruCache<String> nonceCache =
                (LruCache<String>) req.getSession(true).getAttribute(
                    Constants.CSRF_NONCE_SESSION_ATTR_NAME);
            
                if (nonceCache != null && !nonceCache.contains(previousNonce)) {
            if (nonceCache == null) {
                nonceCache = new LruCache<String>(nonceCacheSize);
                req.getSession().setAttribute(
                        Constants.CSRF_NONCE_SESSION_ATTR_NAME, nonceCache);
            }
            
            nonceCache.add(newNonce);
======= a0159a3:"java/org/apache/catalina/filters/CsrfPreventionFilter.java"

    
    private static class LruCache<T> {
        // Although the internal implementation uses a Map, this cache
        // implementation is only concerned with the keys.
        private final Map<T,T> cache;
        
        public LruCache(final int cacheSize) {
            cache = new LinkedHashMap<T,T>() {
                private static final long serialVersionUID = 1L;
                @Override
                protected boolean removeEldestEntry(Map.Entry<T,T> eldest) {
                    if (size() > cacheSize) {
                        return true;
                    }
                    return false;
                }
            };
        }
        
        public void add(T key) {
            cache.put(key, null);
        }
        
        public boolean contains(T key) {
            return cache.containsKey(key);
        }
    }
======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            Context ctxt = (Context) host.findChild(contextPath);
            if (ctxt != null ) {
======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args[2] = ctxt.getDisplayName();
                args[3] = new Boolean(ctxt.getAvailable());
                if (ctxt.getManager() != null) {
                        (ctxt.getManager().getActiveSessions());
======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args = new Object[14];
======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                Manager manager = ctxt.getManager();
                            ctxt.getManager().getMaxInactiveInterval()/60);
                if (ctxt.getPath().equals(this.context.getPath())) {
                } else if (ctxt.getAvailable() && isDeployed) {
                } else if (ctxt.getAvailable() && !isDeployed) {
                } else if (!ctxt.getAvailable() && isDeployed) {
======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args = new Object[7];
======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        args = new Object[4];
        args = new Object[5];
        args[3] = sm.getString("htmlManagerServlet.diagnosticsLeakWarning");
        args[4] = sm.getString("htmlManagerServlet.diagnosticsLeakButton");
======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        Context ctxt = (Context) host.findChild(searchPath);
        if (null == ctxt) {
        Session[] sessions = ctxt.getManager().findSessions();
======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        Context ctxt = (Context) host.findChild(searchPath);
        if (null == ctxt) {
        Session session = ctxt.getManager().findSession(id);
======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        getServletContext().getRequestDispatcher(resp.encodeURL(sessionDetailJspPath)).include(req, resp);
======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "<small><a href=\"{4}\">{5}</a></small></td>\n";
======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= a0159a3:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <input type=\"submit\" value=\"{4}\">\n" +
        "  <small>{3}</small>\n" +
      <attribute name="nonceCacheSize" required="false">
        <p>The number of previously issued nonces that will be cached on a LRU
        basis to support parallel requests, limited use of the refresh and back
        in the browser and similar behaviors that may result in the submission
        of a previous nonce rather than the current one. If not set, the default
        value of 5 will be used.</p>
      </attribute>
      
    You are not authorized to view this page.
   </p>
   <p>
    If you have already configured the manager application to allow access and
    you have used your browsers back button, used a saved bookmark or similar
    then you may have triggered the cross-site request forgery (CSRF) protection
    that has been enabled for the HTML interface of the Manager application. You
    will need to reset this protection by returning to the 
    <a href="<%=request.getContextPath()%>/html">main manager page</a>. Once you
    return to this page you will be able to continue using the manager
    appliction's HTML interface normally. If you continue to see this access
    denied message, check that you have the necessary permissions to access this
    application.
   </p>
   <p>
    If you have not changed
   String submitUrl = response.encodeURL(((HttpServletRequest)
           pageContext.getRequest()).getRequestURL().toString());
    <meta http-equiv="pragma" content="no-cache"/><!-- HTTP 1.0 -->
    <meta http-equiv="cache-control" content="no-cache,must-revalidate"/><!-- HTTP 1.1 -->
    <meta http-equiv="expires" content="0"/><!-- 0 is an invalid value and should be treated as 'now' -->
    <meta http-equiv="content-language" content="en"/>
    <meta name="author" content="Cedrik LIME"/>
    <meta name="copyright" content="copyright 2005-2010 the Apache Software Foundation"/>
    <meta name="robots" content="noindex,nofollow,noarchive"/>
    <title>Sessions Administration: details for <%= currentSessionId %></title>
  <div>
    <input type="hidden" name="path" value="<%= path %>" />
    <input type="hidden" name="sessionId" value="<%= currentSessionId %>" />
    <input type="hidden" name="action" value="sessionDetail" />
    <input type="submit" value="Refresh" />
  </div>
       attributeNamesEnumeration.nextElement();
       ++nAttributes;
    <caption style="font-variant: small-caps;"><%= JspHelper.formatNumber(nAttributes) %> attributes</caption>
    <thead>
        <tr>
            <th>Remove Attribute</th>
            <th>Attribute name</th>
            <th>Attribute value</th>
        </tr>
    </thead>
    <%--tfoot>
        <tr>
            <td colspan="3" style="text-align: center;">
                TODO: set Max Inactive Interval on sessions
            </td>
        </tr>
    </tfoot--%>
    <tbody>
       String attributeName = (String) attributeNamesEnumeration.nextElement();
        <tr>
            <td align="center">
                <form method="post" action="<%= submitUrl %>">
                    <div>
                        <input type="hidden" name="path" value="<%= path %>" />
                        <input type="hidden" name="action" value="removeSessionAttribute" />
                        <input type="hidden" name="sessionId" value="<%= currentSessionId %>" />
                        <input type="hidden" name="attributeName" value="<%= attributeName %>" />
                        <input type="submit" value="Remove" />
                    </div>
                </form>
            </td>
            <td><%= JspHelper.escapeXml(attributeName) %></td>
            <td><% Object attributeValue = currentHttpSession.getAttribute(attributeName); %><span title="<%= attributeValue == null ? "" : attributeValue.getClass().toString() %>"><%= JspHelper.escapeXml(attributeValue) %></span></td>
        </tr>
    </tbody>
  <p style="text-align: center;">
    <input type="hidden" name="path" value="<%= path %>" />
    <input type="submit" value="Return to session list" />
  </p>
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-html401"
        alt="Valid HTML 4.01!" height="31" width="88"></a>
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0!" height="31" width="88" /></a>
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml11"
        alt="Valid XHTML 1.1!" height="31" width="88" /></a>
   String submitUrl = response.encodeURL(((HttpServletRequest)
           pageContext.getRequest()).getRequestURI() + "?path=" + path);
  <p style="text-align: center;">
    <input type="submit" value="Return to main page" />
  </p>
  <filter>
    <filter-name>CSRF</filter-name>
    <filter-class>org.apache.catalina.filters.CsrfPreventionFilter</filter-class>
    <init-param>
      <param-name>entryPoints</param-name>
      <param-value>/html,/html/,/html/list</param-value>
    </init-param>
  </filter>
  
  <filter-mapping>
    <filter-name>CSRF</filter-name>
    <servlet-name>HTMLManager</servlet-name>
    <servlet-name>jsp</servlet-name>
  </filter-mapping>
  

======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

 * header named <code>$remoteIpHeader</code> (default value <code>x-forwarded-for</code>). Values are processed in right-to-left order.</li>
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

 * <td>remoteIpHeader</td>
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

 * <code>remoteIpHeader</code></td>
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

 *       &lt;param-name&gt;remoteIpHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-for&lt;/param-value&gt;
 *       &lt;param-name&gt;remoteIpProxiesHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-by&lt;/param-value&gt;
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

 *       &lt;param-name&gt;remoteIpHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-for&lt;/param-value&gt;
 *       &lt;param-name&gt;remoteIpProxiesHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-by&lt;/param-value&gt;
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

 *       &lt;param-name&gt;remoteIpHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-for&lt;/param-value&gt;
 *       &lt;param-name&gt;remoteIpProxiesHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-by&lt;/param-value&gt;
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

 *       &lt;param-name&gt;remoteIpHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-for&lt;/param-value&gt;
 *       &lt;param-name&gt;remoteIpProxiesHeader&lt;/param-name&gt;&lt;param-value&gt;x-forwarded-by&lt;/param-value&gt;
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    protected static final String REMOTE_IP_HEADER_PARAMETER = "remoteIpHeader";
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

     * @see #setRemoteIpHeader(String)
    private String remoteIpHeader = "X-Forwarded-For";
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            String[] remoteIpHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIpHeader));
            // loop on remoteIpHeaderValue to find the first trusted remote ip and to build the proxies chain
            for (idx = remoteIpHeaderValue.length - 1; idx >= 0; idx--) {
                String currentRemoteIp = remoteIpHeaderValue[idx];
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            // continue to loop on remoteIpHeaderValue to build the new value of the remoteIpHeader
                String currentRemoteIp = remoteIpHeaderValue[idx];
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                    xRequest.removeHeader(remoteIpHeader);
                    xRequest.setHeader(remoteIpHeader, commaDelimitedRemoteIpHeaderValue);
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                        + "', originalScheme='" + request.getScheme() + "', original[" + remoteIpHeader + "]='"
                        + request.getHeader(remoteIpHeader) + ", original[" + protocolHeader + "]='"
                        + xRequest.getScheme() + "', newSecure='" + xRequest.isSecure() + "', new[" + remoteIpHeader + "]='"
                        + xRequest.getHeader(remoteIpHeader) + ", new[" + proxiesHeader + "]='" + xRequest.getHeader(proxiesHeader) + "'");
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    public String getRemoteIpHeader() {
        return remoteIpHeader;
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            setRemoteIpHeader(filterConfig.getInitParameter(REMOTE_IP_HEADER_PARAMETER));
======= 27091e7:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    public void setRemoteIpHeader(String remoteIpHeader) {
        this.remoteIpHeader = remoteIpHeader;
     * Comma delimited list of proxies that are trusted when they appear in the {@link #remoteIpHeader} header. Can be expressed as a
======= 27091e7:"java/org/apache/catalina/valves/RemoteIpValve.java"

 * header named <code>$remoteIpHeader</code> (default value <code>x-forwarded-for</code>). Values are processed in right-to-left order.</li>
======= 27091e7:"java/org/apache/catalina/valves/RemoteIpValve.java"

 * <td>remoteIpHeader</td>
======= 27091e7:"java/org/apache/catalina/valves/RemoteIpValve.java"

 * <code>remoteIpHeader</code></td>
======= 27091e7:"java/org/apache/catalina/valves/RemoteIpValve.java"

 *   remoteIpHeader="x-forwarded-for"
 *   remoteIpProxiesHeader="x-forwarded-by"
======= 27091e7:"java/org/apache/catalina/valves/RemoteIpValve.java"

 *   remoteIpHeader="x-forwarded-for"
 *   remoteIpProxiesHeader="x-forwarded-by"
======= 27091e7:"java/org/apache/catalina/valves/RemoteIpValve.java"

 *   remoteIpHeader="x-forwarded-for"
 *   remoteIpProxiesHeader="x-forwarded-by"
======= 27091e7:"java/org/apache/catalina/valves/RemoteIpValve.java"

 *   remoteIpHeader="x-forwarded-for"
 *   remoteIpProxiesHeader="x-forwarded-by"
======= 27091e7:"java/org/apache/catalina/valves/RemoteIpValve.java"

            String[] remoteIpHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIpHeader));
            // loop on remoteIpHeaderValue to find the first trusted remote ip and to build the proxies chain
            for (idx = remoteIpHeaderValue.length - 1; idx >= 0; idx--) {
                String currentRemoteIp = remoteIpHeaderValue[idx];
======= 27091e7:"java/org/apache/catalina/valves/RemoteIpValve.java"

            // continue to loop on remoteIpHeaderValue to build the new value of the remoteIpHeader
                String currentRemoteIp = remoteIpHeaderValue[idx];
         &lt;param-name&gt;remoteIpHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIpProxiesHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIpHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIpProxiesHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIpHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIpProxiesHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIpHeader&lt;/param-name&gt;
         &lt;param-name&gt;remoteIpProxiesHeader&lt;/param-name&gt;
      <attribute name="remoteIpHeader" required="false">
      <attribute name="remoteIpHeader" required="false">

======= 4f990f1:"java/org/apache/catalina/ha/session/DeltaManager.java"

    private int counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0 ;
    private long counterReceive_EVT_CHANGE_SESSION_ID = 0 ;
    private long counterSend_EVT_ALL_SESSION_DATA = 0 ;
    private long counterSend_EVT_CHANGE_SESSION_ID = 0;
======= 4f990f1:"java/org/apache/catalina/ha/session/DeltaManager.java"

    /**
     * @return Returns the counterSend_EVT_CHANGE_SESSION_ID.
     */
    public long getCounterSend_EVT_CHANGE_SESSION_ID() {
        return counterSend_EVT_CHANGE_SESSION_ID;
    }
======= 4f990f1:"java/org/apache/catalina/ha/session/DeltaManager.java"

    /**
     * @return Returns the counterReceive_EVT_CHANGE_SESSION_ID.
     */
    public long getCounterReceive_EVT_CHANGE_SESSION_ID() {
        return counterReceive_EVT_CHANGE_SESSION_ID;
    }
======= 4f990f1:"java/org/apache/catalina/ha/session/DeltaManager.java"

     * Change the session ID of the current session to a new randomly generated
     * session ID.
     * 
     * @param session   The session to change the session ID for
     */
    @Override
    public void changeSessionId(Session session) {
        changeSessionId(session, true);
    }
    public void changeSessionId(Session session, boolean notify) {
        // original sessionID
        String orgSessionID = session.getId();
        super.changeSessionId(session);
        if (notify) {
            // changed sessionID
            String newSessionID = session.getId();
            try {
                // serialize sessionID
                byte[] data = serializeSessionId(newSessionID);
                // notify change sessionID
                SessionMessage msg = new SessionMessageImpl(getName(),
                        SessionMessage.EVT_CHANGE_SESSION_ID, data,
                        orgSessionID, orgSessionID + "-"
                                + System.currentTimeMillis());
                counterSend_EVT_CHANGE_SESSION_ID++;
                send(msg);
            } catch (IOException e) {
                log.error(sm.getString("deltaManager.unableSerializeSessionID",
                        newSessionID), e);
            }
        }
    }
    /**
     * serialize sessionID
     * @throws IOException if an input/output error occurs
     */
    protected byte[] serializeSessionId(String sessionId) throws IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeUTF(sessionId);
        oos.flush();
        oos.close();
        return bos.toByteArray();
    }
    /**
     * Load sessionID
     * @throws IOException if an input/output error occurs
     */
    protected String deserializeSessionId(byte[] data) throws IOException {
        ReplicationStream ois = getReplicationStream(data);
        String sessionId = ois.readUTF();
        ois.close();
        return sessionId;
    }
    /**
======= 4f990f1:"java/org/apache/catalina/ha/session/DeltaManager.java"

                case SessionMessage.EVT_SESSION_DELTA:
                case SessionMessage.EVT_CHANGE_SESSION_ID: {
======= 4f990f1:"java/org/apache/catalina/ha/session/DeltaManager.java"

        counterReceive_EVT_CHANGE_SESSION_ID = 0;
======= 4f990f1:"java/org/apache/catalina/ha/session/DeltaManager.java"

        counterSend_EVT_CHANGE_SESSION_ID = 0;
======= 4f990f1:"java/org/apache/catalina/ha/session/DeltaManager.java"

                case SessionMessage.EVT_CHANGE_SESSION_ID: {
                    handleCHANGE_SESSION_ID(msg,sender);
                    break;
                 }
======= 4f990f1:"java/org/apache/catalina/ha/session/DeltaManager.java"

    /**
     * handle receive change sessionID at other node
     * @param msg
     * @param sender
     * @throws IOException
     */
    protected void handleCHANGE_SESSION_ID(SessionMessage msg,Member sender) throws IOException {
        counterReceive_EVT_CHANGE_SESSION_ID++;
        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
        String newSessionID = deserializeSessionId(msg.getSession());
        session.setPrimarySession(false);
        if(notifySessionListenersOnReplication) {
            session.setId(newSessionID);
        } else {
            session.setIdInternal(newSessionID);
            add(session);
        }
    }
======= 4f990f1:"java/org/apache/catalina/ha/session/SessionMessage.java"

 *   <li><pre>public static final int EVT_SESSION_EXPIRED</pre><li>
 *   <li><pre>public static final int EVT_SESSION_DELTA</pre><li>
 *   <li><pre>public static final int EVT_ALL_SESSION_DATA</pre><li>
 *   <li><pre>public static final int EVT_ALL_SESSION_TRANSFERCOMPLETE</pre><li>
 *   <li><pre>public static final int EVT_CHANGE_SESSION_ID</pre><li>
======= 4f990f1:"java/org/apache/catalina/ha/session/SessionMessage.java"

    /**
     * Event type used when a sessionID has been changed.
     */
    public static final int EVT_CHANGE_SESSION_ID = 15;
======= 4f990f1:"java/org/apache/catalina/ha/session/SessionMessageImpl.java"

     * <B>EVT_GET_ALL_SESSIONS</B><BR>
     *    get all sessions from from one of the nodes.<BR>
======= 4f990f1:"java/org/apache/catalina/ha/session/SessionMessageImpl.java"

     * <B>EVT_CHANGE_SESSION_ID</B><BR>
     *    send original sessionID and new sessionID.<BR>
======= 4f990f1:"java/org/apache/catalina/ha/session/SessionMessageImpl.java"

            case EVT_CHANGE_SESSION_ID : return "SESSION-ID-CHANGED";
      name="counterReceive_EVT_CHANGE_SESSION_ID"
      description="Count receive EVT_CHANGE_SESSION_ID messages"
      type="long"
      writeable="false"/>
    <attribute
      name="counterSend_EVT_CHANGE_SESSION_ID"
      description="Count send EVT_CHANGE_SESSION_ID messages"
      type="long"
      writeable="false"/>
    <attribute

======= e119b5b:"java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java"

        "org.apache.catalina.ha.authenticator.ClusterSingleSignOn";
======= e119b5b:"java/org/apache/catalina/ha/authenticator/ClusterSingleSignOnListener.java"

    protected static final String info = "org.apache.catalina.ha.authenticator.ClusterSingleSignOnListener/1.0";
======= e119b5b:"java/org/apache/catalina/ha/session/ClusterSessionListener.java"

    protected static final String info = "org.apache.catalina.ha.session.ClusterSessionListener/1.1";

======= ac8a5ba:"java/org/apache/catalina/core/StandardContext.java"

     * <code>false</code> will be used.
    /**
     * Should Tomcat attempt to terminate any {@link java.util.TimerThread}s
     * that have been started by the web application? If not specified, the
     * default value of <code>false</code> will be used.
     */
    private boolean clearReferencesStopTimerThreads = false;
======= ac8a5ba:"java/org/apache/catalina/core/StandardContext.java"

     * Return the clearReferencesStopTimerThreads flag for this Context.
     */
    public boolean getClearReferencesStopTimerThreads() {
        return (this.clearReferencesStopTimerThreads);
    }
    /**
     * Set the clearReferencesStopTimerThreads feature for this Context.
     *
     * @param clearReferencesStopTimerThreads The new flag value
     */
    public void setClearReferencesStopTimerThreads(
            boolean clearReferencesStopTimerThreads) {
        boolean oldClearReferencesStopTimerThreads =
            this.clearReferencesStopTimerThreads;
        this.clearReferencesStopTimerThreads = clearReferencesStopTimerThreads;
        support.firePropertyChange("clearReferencesStopTimerThreads",
                                   oldClearReferencesStopTimerThreads,
                                   this.clearReferencesStopTimerThreads);
    }
    /**
======= ac8a5ba:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * <code>false</code> will be used.
     * Should Tomcat attempt to terminate any {@link java.util.TimerThread}s
     * that have been started by the web application? If not specified, the
     * default value of <code>false</code> will be used.
     */
    private boolean clearReferencesStopTimerThreads = false;
    /**
======= ac8a5ba:"java/org/apache/catalina/loader/WebappClassLoader.java"

      * Return the clearReferencesStopTimerThreads flag for this Context.
      */
     public boolean getClearReferencesStopTimerThreads() {
         return (this.clearReferencesStopTimerThreads);
     }
     /**
      * Set the clearReferencesStopTimerThreads feature for this Context.
      *
      * @param clearReferencesStopTimerThreads The new flag value
      */
     public void setClearReferencesStopTimerThreads(
             boolean clearReferencesStopTimerThreads) {
         this.clearReferencesStopTimerThreads = clearReferencesStopTimerThreads;
     }
     /**
======= ac8a5ba:"java/org/apache/catalina/loader/WebappClassLoader.java"

     /**
      * Set the clearReferencesLogFactoryRelease feature for this Context.
      *
      * @param clearReferencesLogFactoryRelease The new flag value
      */
     public void setClearReferencesLogFactoryRelease(
             boolean clearReferencesLogFactoryRelease) {
         this.clearReferencesLogFactoryRelease =
             clearReferencesLogFactoryRelease;
     }
======= ac8a5ba:"java/org/apache/catalina/loader/WebappClassLoader.java"

======= ac8a5ba:"java/org/apache/catalina/loader/WebappClassLoader.java"

                    // TimerThread can be stopped safely so treat separately
                            "java.util.TimerThread") &&
                            clearReferencesStopTimerThreads) {
======= ac8a5ba:"java/org/apache/catalina/loader/WebappLoader.java"

                classLoader.setClearReferencesStopTimerThreads(
                        ((StandardContext) container).getClearReferencesStopTimerThreads());
      <attribute name="clearReferencesStopTimerThreads" required = "false">
        <p>If <code>true</code>, Tomcat attempts to terminate
        <code>java.util.Timer</code>threads that have been started by the web
        application. Unlike standard threads, timer threads can be stopped
        safely although there may still be side-effects for the application. If
        not specified, the default value of <code>false</code> will be used.</p>
      </attribute>

======= ac22dd8:"java/org/apache/catalina/ha/session/BackupManager.java"

======= ac22dd8:"java/org/apache/catalina/ha/session/DeltaManager.java"

======= ac22dd8:"java/org/apache/catalina/session/PersistentManagerBase.java"


======= 0f669e3:"java/org/apache/catalina/connector/MapperListener.java"

            child.addContainerListener(this);
======= 0f669e3:"java/org/apache/catalina/connector/MapperListener.java"

            removeListeners(child);
======= 0f669e3:"java/org/apache/catalina/connector/MapperListener.java"

======= 0f669e3:"java/org/apache/catalina/connector/MapperListener.java"

======= 0f669e3:"java/org/apache/catalina/connector/MapperListener.java"


======= 9369636:"java/org/apache/catalina/Globals.java"

======= 9369636:"java/org/apache/catalina/connector/CoyoteAdapter.java"

======= 9369636:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        // Copy the raw URI to the decodedURI
        
        // Parse the path parameters. This will:
        //   - strip out the path parameters
        //   - convert the decodedURI to bytes
        parsePathParameters(req, request);
        
        // URI decoding
        // %xx decoding of the URL
        try {
            req.getURLDecoder().convert(decodedURI, false);
        } catch (IOException ioe) {
            res.setStatus(400);
            res.setMessage("Invalid URI: " + ioe.getMessage());
            return false;
        }
        // Normalization
        if (!normalize(req.decodedURI())) {
            res.setStatus(400);
            res.setMessage("Invalid URI");
            return false;
        }
        // Character decoding
        convertURI(decodedURI, request);
        // Check that the URI is still normalized
        if (!checkNormalize(req.decodedURI())) {
            res.setStatus(400);
            res.setMessage("Invalid URI character encoding");
            return false;
======= 9369636:"java/org/apache/catalina/connector/CoyoteAdapter.java"

                redirectPath = redirectPath + ";" +
                    ApplicationSessionCookieConfig.getSessionUriParamName(
                            request.getContext()) +
                    "=" + request.getRequestedSessionId();
======= 9369636:"java/org/apache/catalina/connector/CoyoteAdapter.java"

        if (request.getServletContext().getEffectiveSessionTrackingModes()
            
            // Get the session ID if there was one
            String sessionID = request.getPathParameter(
                    ApplicationSessionCookieConfig.getSessionUriParamName(
                            request.getContext()));
            if (sessionID != null) {
                request.setRequestedSessionId(sessionID);
                request.setRequestedSessionURL(true);
            }
======= 9369636:"java/org/apache/catalina/connector/CoyoteAdapter.java"

     * Extract the path parameters from the request. This assumes parameters are
     * of the form /path;name=value;name2=value2/ etc. Currently only really
     * interested in the session ID that will be in this form. Other parameters
     * can safely be ignored.
     * 
     * @param req
     * @param request
     */
    protected void parsePathParameters(org.apache.coyote.Request req,
            Request request) {
        
        // Process in bytes (this is default format so this is normally a NO-OP
        req.decodedURI().toBytes();
        
        ByteChunk uriBC = req.decodedURI().getByteChunk();
        int semicolon = uriBC.indexOf(';', 0);
        String enc = null;
        
        while (semicolon > -1) {
            if (enc == null) {
                // What encoding to use? Some platforms, eg z/os, use a default
                // encoding that doesn't give the expected result so be explicit
                enc = connector.getURIEncoding();
                if (enc == null) {
                    enc = "ISO-8859-1";
                }
            }
            
            // Parse path param, and extract it from the decoded request URI
            int start = uriBC.getStart();
            int end = uriBC.getEnd();
            int pathParamStart = semicolon + 1;
            int pathParamEnd = ByteChunk.findChars(uriBC.getBuffer(),
                    uriBC.getStart() + pathParamStart, uriBC.getEnd(),
                    new byte[] {';', '/'});
            
            String pv = null;
            boolean warnedEncoding = false;
            
            if (pathParamEnd >= 0) {
                try {
                    pv = (new String(uriBC.getBuffer(), start + pathParamStart,
                                pathParamEnd - pathParamStart, enc));
                } catch (UnsupportedEncodingException e) {
                    if (!warnedEncoding) {
                        log.warn(sm.getString("coyoteAdapter.parsePathParam",
                                enc));
                        warnedEncoding = true;
                    }
                }
                // Extract path param from decoded request URI
                byte[] buf = uriBC.getBuffer();
                for (int i = 0; i < end - start - pathParamEnd; i++) {
                    buf[start + semicolon + i] 
                        = buf[start + i + pathParamEnd];
                }
                uriBC.setBytes(buf, start,
                        end - start - pathParamEnd + semicolon);
            } else {
                try {
                    pv = (new String(uriBC.getBuffer(), start + pathParamStart, 
                                (end - start) - pathParamStart, enc));
                } catch (UnsupportedEncodingException e) {
                    if (!warnedEncoding) {
                        log.warn(sm.getString("coyoteAdapter.parsePathParam",
                                enc));
                        warnedEncoding = true;
                    }
                }
                uriBC.setEnd(start + semicolon);
            }
            
            if (pv != null) {
                int equals = pv.indexOf('=');
                if (equals > -1) {
                    request.addPathParameter(pv.substring(0, equals),
                            pv.substring(equals + 1));
                }
            }
            
            semicolon = uriBC.indexOf(';', semicolon);
        }
    }
    
    
    /**
======= 9369636:"java/org/apache/catalina/connector/CoyoteAdapter.java"

======= 9369636:"java/org/apache/catalina/connector/Request.java"

    /**
     * Path parameters
     */
    protected Map<String,String> pathParameters = new HashMap<String, String>();
    protected void addPathParameter(String name, String value) {
        pathParameters.put(name, value);
    }
    protected String getPathParameter(String name) {
        return pathParameters.get(name);
    }
======= 9369636:"java/org/apache/catalina/connector/Request.java"

        pathParameters.clear();
======= 9369636:"java/org/apache/catalina/connector/Response.java"

======= 9369636:"java/org/apache/catalina/connector/Response.java"

            String tok = ";" +
                    ApplicationSessionCookieConfig.getSessionUriParamName(
                                request.getContext()) +
                    "=" + session.getIdInternal();
======= 9369636:"java/org/apache/catalina/connector/Response.java"

            sb.append(ApplicationSessionCookieConfig.getSessionUriParamName(
                    request.getContext()));
======= 9369636:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

    private static final String DEFAULT_SESSION_COOKIE_NAME = "JSESSIONID";
    private static final String DEFAULT_SESSION_PARAMETER_NAME = "jsessionid";
    
======= 9369636:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

    private static String getConfiguredSessionCookieName(Context context) {
======= 9369636:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

        return null;
    }
    
    
    /**
     * Determine the name to use for the session cookie for the provided
     * context.
     * @param context
     */
    public static String getSessionCookieName(Context context) {
    
        String result = getConfiguredSessionCookieName(context);
        
        if (result == null) {
            result = DEFAULT_SESSION_COOKIE_NAME; 
        }
        
        return result; 
    }
    
    /**
     * Determine the name to use for the session cookie for the provided
     * context.
     * @param context
     */
    public static String getSessionUriParamName(Context context) {
        
        String result = getConfiguredSessionCookieName(context);
        
        if (result == null) {
            result = DEFAULT_SESSION_PARAMETER_NAME; 
        }
        return result; 
======= 9369636:"java/org/apache/catalina/realm/RealmBase.java"

======= 9369636:"java/org/apache/catalina/realm/RealmBase.java"

======= 9369636:"java/org/apache/catalina/realm/RealmBase.java"

        if (serverDigest.equals(clientDigest)) {
        }
        return null;
======= 9369636:"java/org/apache/catalina/realm/RealmBase.java"

                
                if(log.isDebugEnabled())
                    log.debug("Passing all access");
                status = true;
======= 9369636:"java/org/apache/catalina/realm/RealmBase.java"

            file.append(ApplicationSessionCookieConfig.getSessionUriParamName(
                    request.getContext()));
======= 9369636:"java/org/apache/catalina/realm/RealmBase.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    public void testPathParams() throws Exception {
        // Setup Tomcat instance
        Tomcat tomcat = getTomcatInstance();
        
        // Must have a real docBase - just use temp
        Context ctx = 
            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
        Tomcat.addServlet(ctx, "servlet", new PathParamServlet());
        ctx.addServletMapping("/", "servlet");
        
        tomcat.start();
        
        testPath("/", "none");
        testPath("/;jsessionid=1234", "1234");
        testPath("/foo;jsessionid=1234", "1234");
        testPath("/foo;jsessionid=1234;dummy", "1234");
        testPath("/foo;jsessionid=1234;dummy=5678", "1234");
        testPath("/foo;jsessionid=1234;=5678", "1234");
        testPath("/foo;jsessionid=1234/bar", "1234");
    }
    private void testPath(String path, String expected) throws Exception {
        ByteChunk res = getUrl("http://localhost:" + getPort() + path);
        assertEquals(expected, res.toString());
    }
    private static class PathParamServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) 
                throws ServletException, IOException {
            resp.setContentType("text/plain");
            PrintWriter pw = resp.getWriter();
            String sessionId = req.getRequestedSessionId();
            if (sessionId == null) {
                sessionId = "none";
            }
            pw.write(sessionId);
        }
    }

======= a7b96d0:"java/org/apache/catalina/startup/ContextConfig.java"

    
    private static final String SCI_LOCATION =
        "META-INF/services/javax.servlet.ServletContainerInitializer";
======= a7b96d0:"java/org/apache/catalina/startup/ContextConfig.java"

            URL url = fragment.getURL();
                if ("jar".equals(url.getProtocol())) {
                    JarURLConnection conn =
                        (JarURLConnection) url.openConnection();
                    jarFile = conn.getJarFile();
                    ZipEntry entry = jarFile.getEntry(SCI_LOCATION);
                    if (entry != null) {
                        is = jarFile.getInputStream(entry);
                    }
                } else if ("file".equals(url.getProtocol())) {
                    String path = url.getPath();
                    File file = new File(path, SCI_LOCATION);
                    if (file.exists()) {
                        is = new FileInputStream(file);
                    }
                }
                if (is != null) {
                        "contextConfig.servletContainerInitializerFail", url,
======= a7b96d0:"java/org/apache/catalina/startup/ContextConfig.java"

            URL url = fragment.getURL();
                // Note: Ignore file URLs for now since only jar URLs will be accepted
                if ("jar".equals(url.getProtocol())) {
                    JarURLConnection conn =
                        (JarURLConnection) url.openConnection();
                    jarFile = conn.getJarFile();   
                    ZipEntry entry = jarFile.getEntry("META-INF/resources/");
                    if (entry != null) {
                        context.addResourceJarUrl(url);
                    }
                log.error(sm.getString("contextConfig.resourceJarFail", url,

======= 05810ee:"java/javax/servlet/http/Cookie.java"

======= 05810ee:"java/javax/servlet/http/Cookie.java"


======= 4fff6c0:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        if (usr != null) {
            poolProperties.getDbProperties().setProperty("user", usr);
        }
        if (pwd != null) {
            poolProperties.getDbProperties().setProperty("password", pwd);
        }
        

======= 5ad9ecd:"java/org/apache/catalina/core/ApplicationPart.java"

======= 5ad9ecd:"java/org/apache/catalina/core/ApplicationPart.java"

            String cdl = cd.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/core/StandardEngine.java"

======= 5ad9ecd:"java/org/apache/catalina/core/StandardEngine.java"

            this.defaultHost = host.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/core/StandardHost.java"

======= 5ad9ecd:"java/org/apache/catalina/core/StandardHost.java"

        name = name.toLowerCase(Locale.ENGLISH);      // Internally all names are lower case
======= 5ad9ecd:"java/org/apache/catalina/core/StandardHost.java"

        alias = alias.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/core/StandardHost.java"

        alias = alias.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/deploy/FilterMap.java"

======= 5ad9ecd:"java/org/apache/catalina/deploy/FilterMap.java"

        String dispatcher = dispatcherString.toUpperCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= 5ad9ecd:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                if (!filename.toLowerCase(Locale.ENGLISH).endsWith(".war")) {
======= 5ad9ecd:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                        filename.toLowerCase(Locale.ENGLISH).indexOf(".war"));
======= 5ad9ecd:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

            String cdl = cd.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/manager/util/SessionUtils.java"

                obj = in_session.getAttribute(LOCALE_TEST_ATTRIBUTES[i].toLowerCase(Locale.ENGLISH));
                obj = in_session.getAttribute(LOCALE_TEST_ATTRIBUTES[i].toUpperCase(Locale.ENGLISH));
======= 5ad9ecd:"java/org/apache/catalina/manager/util/SessionUtils.java"

                obj = httpSession.getAttribute(USER_TEST_ATTRIBUTES[i].toLowerCase(Locale.ENGLISH));
                obj = httpSession.getAttribute(USER_TEST_ATTRIBUTES[i].toUpperCase(Locale.ENGLISH));
======= 5ad9ecd:"java/org/apache/catalina/servlets/CGIServlet.java"

                header = headers.nextElement().toUpperCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/servlets/WebdavServlet.java"

======= 5ad9ecd:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if ((path.toUpperCase(Locale.ENGLISH).startsWith("/WEB-INF")) ||
            (path.toUpperCase(Locale.ENGLISH).startsWith("/META-INF"))) {
======= 5ad9ecd:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if ((path.toUpperCase(Locale.ENGLISH).startsWith("/WEB-INF")) ||
            (path.toUpperCase(Locale.ENGLISH).startsWith("/META-INF"))) {
======= 5ad9ecd:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if ((destinationPath.toUpperCase(Locale.ENGLISH).startsWith("/WEB-INF")) ||
            (destinationPath.toUpperCase(Locale.ENGLISH).startsWith("/META-INF"))) {
        if ((path.toUpperCase(Locale.ENGLISH).startsWith("/WEB-INF")) ||
            (path.toUpperCase(Locale.ENGLISH).startsWith("/META-INF"))) {
======= 5ad9ecd:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if ((path.toUpperCase(Locale.ENGLISH).startsWith("/WEB-INF")) ||
            (path.toUpperCase(Locale.ENGLISH).startsWith("/META-INF"))) {
======= 5ad9ecd:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if ((path.toUpperCase(Locale.ENGLISH).startsWith("/WEB-INF")) ||
            (path.toUpperCase(Locale.ENGLISH).startsWith("/META-INF"))) {
======= 5ad9ecd:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if (path.toUpperCase(Locale.ENGLISH).startsWith("/WEB-INF") ||
            path.toUpperCase(Locale.ENGLISH).startsWith("/META-INF"))
======= 5ad9ecd:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if (path.toUpperCase(Locale.ENGLISH).startsWith("/WEB-INF") ||
            path.toUpperCase(Locale.ENGLISH).startsWith("/META-INF"))
======= 5ad9ecd:"java/org/apache/catalina/ssi/ResponseIncludeWrapper.java"

        String lname = name.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/ssi/ResponseIncludeWrapper.java"

        String lname = name.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/ssi/ResponseIncludeWrapper.java"

        String lname = name.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/ssi/ResponseIncludeWrapper.java"

        String lname = name.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/ssi/SSIMediator.java"

======= 5ad9ecd:"java/org/apache/catalina/ssi/SSIMediator.java"

        String lowerCaseVariableName = variableName.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/ssi/SSIMediator.java"

                variableName = variableName.toUpperCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/ssi/SSIProcessor.java"

======= 5ad9ecd:"java/org/apache/catalina/ssi/SSIProcessor.java"

                            commands.get(strCmd.toLowerCase(Locale.ENGLISH));
======= 5ad9ecd:"java/org/apache/catalina/ssi/SSIServlet.java"

======= 5ad9ecd:"java/org/apache/catalina/ssi/SSIServlet.java"

        if (path == null || path.toUpperCase(Locale.ENGLISH).startsWith("/WEB-INF")
                || path.toUpperCase(Locale.ENGLISH).startsWith("/META-INF")) {
======= 5ad9ecd:"java/org/apache/catalina/ssi/SSIServletExternalResolver.java"

======= 5ad9ecd:"java/org/apache/catalina/ssi/SSIServletExternalResolver.java"

        String[] nameParts = name.toUpperCase(Locale.ENGLISH).split("_");
======= 5ad9ecd:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

======= 5ad9ecd:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                    String filename = filenames[j].toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                        String filename = filenames[j].toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/catalina/startup/ContextConfig.java"

======= 5ad9ecd:"java/org/apache/catalina/startup/ContextConfig.java"

        if (docBase.toLowerCase(Locale.ENGLISH).endsWith(".war") && !file.isDirectory() && unpackWARs) {
======= 5ad9ecd:"java/org/apache/catalina/startup/ContextConfig.java"

        } else if (docBase.toLowerCase(Locale.ENGLISH).endsWith(".war") &&
======= 5ad9ecd:"java/org/apache/catalina/startup/ContextConfig.java"

            if (docBase.toLowerCase(Locale.ENGLISH).endsWith(".war")) {
======= 5ad9ecd:"java/org/apache/catalina/startup/HostConfig.java"

======= 5ad9ecd:"java/org/apache/catalina/startup/HostConfig.java"

            if (files[i].toLowerCase(Locale.ENGLISH).endsWith(".xml")) {
======= 5ad9ecd:"java/org/apache/catalina/startup/HostConfig.java"

                    if (docBase.getAbsolutePath().toLowerCase(Locale.ENGLISH).endsWith(".war")) {
======= 5ad9ecd:"java/org/apache/catalina/startup/HostConfig.java"

            if (files[i].toLowerCase(Locale.ENGLISH).endsWith(".war") && dir.isFile()
======= 5ad9ecd:"java/org/apache/catalina/startup/HostConfig.java"

            if (docBase.getAbsolutePath().toLowerCase(Locale.ENGLISH).endsWith(".war")) {
======= 5ad9ecd:"java/org/apache/catalina/util/ExtensionValidator.java"

======= 5ad9ecd:"java/org/apache/catalina/util/ExtensionValidator.java"

            if (classpathItem.toLowerCase(Locale.ENGLISH).endsWith(".jar")) {
======= 5ad9ecd:"java/org/apache/catalina/util/ExtensionValidator.java"

            if (binding.getName().toUpperCase(Locale.ENGLISH).equals("MANIFEST.MF")) {
======= 5ad9ecd:"java/org/apache/catalina/util/ExtensionValidator.java"

                if (!binding.getName().toLowerCase(Locale.ENGLISH).endsWith(".jar")) {
======= 5ad9ecd:"java/org/apache/catalina/util/ExtensionValidator.java"

                    if (files[i].getName().toLowerCase(Locale.ENGLISH).endsWith(".jar") &&
======= 5ad9ecd:"java/org/apache/catalina/util/MIME2Java.java"

        return s_enchash.get(mimeCharsetName.toUpperCase(Locale.ENGLISH));
======= 5ad9ecd:"java/org/apache/catalina/util/MIME2Java.java"

        return s_revhash.get(encoding.toUpperCase(Locale.ENGLISH));
======= 5ad9ecd:"java/org/apache/tomcat/util/buf/MessageBytes.java"

======= 5ad9ecd:"java/org/apache/tomcat/util/buf/MessageBytes.java"

======= 5ad9ecd:"java/org/apache/tomcat/util/http/AcceptLanguage.java"

                qValueStr = qValueStr.trim().toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/FileItemHeadersImpl.java"

======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/FileItemHeadersImpl.java"

        String nameLower = name.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/FileItemHeadersImpl.java"

        String nameLower = name.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java"

======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java"

        if (contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART)) {
======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java"

            String cdl = pContentDisposition.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java"

                && pContentDisposition.toLowerCase(Locale.ENGLISH).startsWith(FORM_DATA)) {
======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java"

                    || (!contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART))) {
======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java"

                                &&  subContentType.toLowerCase(Locale.ENGLISH)
======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/ParameterParser.java"

======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/ParameterParser.java"

                    paramName = paramName.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/ServletFileUpload.java"

======= 5ad9ecd:"java/org/apache/tomcat/util/http/fileupload/ServletFileUpload.java"

        if (!"post".equals(request.getMethod().toLowerCase(Locale.ENGLISH))) {
        if (contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART)) {
======= 5ad9ecd:"java/org/apache/tomcat/util/modeler/OperationInfo.java"

======= 5ad9ecd:"java/org/apache/tomcat/util/modeler/OperationInfo.java"

            this.impact = impact.toUpperCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/tomcat/util/net/URL.java"

======= 5ad9ecd:"java/org/apache/tomcat/util/net/URL.java"

                    String s = spec.substring(start, i).toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

======= 5ad9ecd:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

                alias = alias.toLowerCase(Locale.ENGLISH);
======= 5ad9ecd:"webapps/examples/WEB-INF/classes/examples/ShowSource.java"

======= 5ad9ecd:"webapps/examples/WEB-INF/classes/examples/ShowSource.java"

            (jspFile.toUpperCase(Locale.ENGLISH).indexOf("/WEB-INF/") != 0) ||
            (jspFile.toUpperCase(Locale.ENGLISH).indexOf("/META-INF/") != 0))
======= 5ad9ecd:"webapps/examples/WEB-INF/classes/jsp2/examples/el/Functions.java"

======= 5ad9ecd:"webapps/examples/WEB-INF/classes/jsp2/examples/el/Functions.java"

        return text.toUpperCase(Locale.ENGLISH);

======= 09abffb:"java/org/apache/coyote/http11/Http11AprProcessor.java"

======= 09abffb:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                    (startPos, commaPos).toLowerCase(Locale.ENGLISH).trim();
======= 09abffb:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                .toLowerCase(Locale.ENGLISH).trim();
======= 09abffb:"java/org/apache/coyote/http11/Http11NioProcessor.java"

======= 09abffb:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                    (startPos, commaPos).toLowerCase(Locale.ENGLISH).trim();
======= 09abffb:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                .toLowerCase(Locale.ENGLISH).trim();
======= 09abffb:"java/org/apache/coyote/http11/Http11Processor.java"

======= 09abffb:"java/org/apache/coyote/http11/Http11Processor.java"

                    (startPos, commaPos).toLowerCase(Locale.ENGLISH).trim();
======= 09abffb:"java/org/apache/coyote/http11/Http11Processor.java"

                .toLowerCase(Locale.ENGLISH).trim();

======= a954806:"java/org/apache/jasper/compiler/Validator.java"

======= a954806:"java/org/apache/jasper/compiler/Validator.java"

            String pageDirEnc = thePageDirEnc.toUpperCase(Locale.ENGLISH);
======= a954806:"java/org/apache/jasper/compiler/Validator.java"

                configEnc = configEnc.toUpperCase(Locale.ENGLISH);
======= a954806:"java/org/apache/jasper/compiler/Validator.java"

                String pageEnc = root.getPageEncoding().toUpperCase(Locale.ENGLISH);
======= a954806:"java/org/apache/jasper/compiler/Validator.java"

            String pageDirEnc = thePageDirEnc.toUpperCase(Locale.ENGLISH);
======= a954806:"java/org/apache/jasper/compiler/Validator.java"

                String pageEnc = root.getPageEncoding().toUpperCase(Locale.ENGLISH);
======= a954806:"java/org/apache/jasper/tagplugins/jstl/Util.java"

        int index = input.toUpperCase(Locale.ENGLISH).indexOf(name.toUpperCase(Locale.ENGLISH));

======= 4a581aa:"java/org/apache/catalina/startup/ContextConfig.java"

======= 4a581aa:"java/org/apache/catalina/startup/ContextConfig.java"

     * super class needs to be checked for a match with {@Link HandlesTypes} or
     * for an annotation that matches {@Link HandlesTypes}.
======= 4a581aa:"java/org/apache/catalina/startup/ContextConfig.java"

        if (clazz.isAnnotation()) {
            // Skip
            return;
        }
        
        boolean match = false;
        
            if (entry.getKey().isAnnotation()) {
                AnnotationEntry[] annotationEntries = javaClass.getAnnotationEntries();
                for (AnnotationEntry annotationEntry : annotationEntries) {
                    if (entry.getKey().getName().equals(
                        getClassName(annotationEntry.getAnnotationType()))) {
                        match = true;
                        break;
                    }
                }
            } else if (entry.getKey().isAssignableFrom(clazz)) {
                match = true;
            }
            if (match) {
======= 4a581aa:"java/org/apache/catalina/startup/ContextConfig.java"

    private static final String getClassName(String internalForm) {
        if (!internalForm.startsWith("L")) {
            return internalForm;
        }
        
        // Assume starts with L, ends with ; and uses / rather than .
        return internalForm.substring(1,
                internalForm.length() - 1).replace('/', '.');
    }

======= f24ed2d:"java/org/apache/catalina/startup/ContextConfig.java"

            clazz = context.getLoader().getClassLoader().loadClass(className);
        } catch (NoClassDefFoundError e) {
            log.debug(sm.getString("contextConfig.invalidSciHandlesTypes",
                    className), e);
            return;
            return;

======= 27a3909:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java"

    protected int maxIdle = maxActive;

======= b75b021:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

    protected static final String PROP_SUSPECT_TIMEOUT = "suspectTimeout";
    
======= b75b021:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java"

        value = properties.getProperty(PROP_SUSPECT_TIMEOUT);
        if (value != null) {
            poolProperties.setSuspectTimeout(Integer.parseInt(value));
        }

======= 616bd68:"test/org/apache/catalina/tribes/demos/IntrospectionUtils.java"

    public static final String PATH_SEPARATOR =
        System.getProperty("path.separator");

======= 3396917:"java/org/apache/catalina/core/ApplicationFilterRegistration.java"

        filterMap.setFilterName(filterDef.getFilterName());

======= 3f4a241:"java/org/apache/catalina/core/StandardContext.java"

                    filterMaps.length - (filterMapInsertPoint + 1),

======= efd418b:"java/org/apache/jasper/JspCompilationContext.java"

======= efd418b:"java/org/apache/jasper/JspCompilationContext.java"

    protected Map<String, JarResource> tagFileJarUrls;
======= efd418b:"java/org/apache/jasper/JspCompilationContext.java"

    protected JarResource tagJarResource;
======= efd418b:"java/org/apache/jasper/JspCompilationContext.java"

        this.tagFileJarUrls = new HashMap<String, JarResource>();
======= efd418b:"java/org/apache/jasper/JspCompilationContext.java"

                                 JarResource tagJarResource) {
        this.tagJarResource = tagJarResource;
        if (tagJarResource != null) {
======= efd418b:"java/org/apache/jasper/JspCompilationContext.java"

            JarResource jarResource = tagFileJarUrls.get(res);
            if (jarResource == null) {
                jarResource = tagJarResource;
            if (jarResource != null) {
                result = jarResource.getEntry(res.substring(1));
======= efd418b:"java/org/apache/jasper/JspCompilationContext.java"

    public JarResource getTagFileJarResource(String tagFile) {
    public void setTagFileJarResource(String tagFile, JarResource jarResource) {
        this.tagFileJarUrls.put(tagFile, jarResource);
======= efd418b:"java/org/apache/jasper/JspCompilationContext.java"

    public JarResource getTagFileJarResource() {
        return this.tagJarResource;
======= efd418b:"java/org/apache/jasper/JspCompilationContext.java"

    public TldLocation getTldLocation(String uri) throws JasperException {
        TldLocation location = 
======= efd418b:"java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java"

                        pc.getJspCompilationContext().getTagFileJarResource(path),
======= efd418b:"java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
       
    /**     
     * @return The JarFile for this resource. A new instance of JarFile
     *         should be returned on each call.
     * @throws IOException
     */
    JarFile getJarFile() throws IOException;
       
    /**     
     * @return The URL of this resource. May or may not point 
     *         to the actual Jar file.    
     */
    String getUrl();
    
    /**     
     * @param name
     * @return The URL for the entry within this resource.
     */
    URL getEntry(String name);
======= efd418b:"java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    
    private String jarUrl;
    
    public JarURLResource(URL jarURL) {
        this(jarURL.toExternalForm());
    }
    
    public JarURLResource(String jarUrl) {
        this.jarUrl = jarUrl;
    }
    
    public JarFile getJarFile() throws IOException {
        URL jarFileUrl = new URL("jar:" + jarUrl + "!/");
        JarURLConnection conn = (JarURLConnection) jarFileUrl.openConnection();
        conn.setUseCaches(false);
        conn.connect();
        return conn.getJarFile();
    }
       
    public String getUrl() {
        return jarUrl;
    }
    
    public URL getEntry(String name) {
        try {
            return new URL("jar:" + jarUrl + "!/" + name);
        } catch (MalformedURLException e) {
            throw new RuntimeException("", e);
        }
    }
======= efd418b:"java/org/apache/jasper/compiler/JspDocumentParser.java"

            TldLocation location = ctxt.getTldLocation(uri);
======= efd418b:"java/org/apache/jasper/compiler/Parser.java"

    private JarResource jarResource;
======= efd418b:"java/org/apache/jasper/compiler/Parser.java"

            boolean directivesOnly, JarResource jarResource) {
======= efd418b:"java/org/apache/jasper/compiler/Parser.java"

        this.jarResource = jarResource;
======= efd418b:"java/org/apache/jasper/compiler/Parser.java"

            JarResource jarResource, String pageEnc, String jspConfigPageEnc,
                jarResource);
======= efd418b:"java/org/apache/jasper/compiler/Parser.java"

            parserController.parse(file, parent, jarResource);
======= efd418b:"java/org/apache/jasper/compiler/Parser.java"

                        TldLocation location = ctxt.getTldLocation(uri);
======= efd418b:"java/org/apache/jasper/compiler/Parser.java"

                            ctxt.setTagFileJarResource(info.getPath(),
                                    ctxt.getTagFileJarResource());
======= efd418b:"java/org/apache/jasper/compiler/ParserController.java"

        return doParse(inFileName, null, ctxt.getTagFileJarResource());
======= efd418b:"java/org/apache/jasper/compiler/ParserController.java"

        return doParse(inFileName, null, ctxt.getTagFileJarResource());
======= efd418b:"java/org/apache/jasper/compiler/ParserController.java"

            JarResource jarResource)
        return doParse(inFileName, parent, jarResource);
======= efd418b:"java/org/apache/jasper/compiler/ParserController.java"

            JarResource jarResource)
        Node.Nodes page = doParse(inFileName, null, jarResource);
======= efd418b:"java/org/apache/jasper/compiler/ParserController.java"

            JarResource jarResource)
======= efd418b:"java/org/apache/jasper/compiler/ParserController.java"

        JarFile jarFile = (jarResource == null) ? null : jarResource.getJarFile();
======= efd418b:"java/org/apache/jasper/compiler/ParserController.java"

                        jarResource.getEntry(absFileName.substring(1)).toString());
                        
======= efd418b:"java/org/apache/jasper/compiler/ParserController.java"

                        directiveOnly, jarResource,
======= efd418b:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            String name, String path, JarResource jarResource, TagLibraryInfo tagLibInfo)
======= efd418b:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            page = pc.parseTagFileDirectives(path, jarResource);
======= efd418b:"java/org/apache/jasper/compiler/TagFileProcessor.java"

        JarResource tagJarResouce = null;
            tagJarResouce = 
                compiler.getCompilationContext().getTldLocation(
                        tagInfo.getTagLibrary().getURI()).getJarResource();
        String wrapperUri;
        if (tagJarResouce == null) {
            wrapperUri = tagFilePath;
            wrapperUri = tagJarResouce.getEntry(tagFilePath).toString();
                        .getRuntimeContext(), tagJarResouce);
======= efd418b:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                            ctxt.getTagFileJarResource(tagFilePath));
======= efd418b:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                    TldLocation location =
                    JarResource jarResource = location.getJarResource();
                    pageInfo.addDependant(jarResource.getEntry(location.getName()).toString());
                    pageInfo.addDependant(jarResource.getEntry(tagFilePath.substring(1)).toString());
======= efd418b:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

            String prefix, String uriIn, TldLocation location, ErrorDispatcher err)
======= efd418b:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

======= efd418b:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

        String tldName = location.getName();
        JarResource jarResource = location.getJarResource();
            if (jarResource == null) {
                    in = getResourceAsStream(tldName);
                        throw new FileNotFoundException(tldName);
                    err.jspError("jsp.error.file.not.found", tldName);
                parseTLD(tldName, in, null);
                    pageInfo.addDependant(tldName);
                    in = jarResource.getEntry(tldName).openStream();
                    parseTLD(jarResource.getUrl(), in, jarResource);
                    err.jspError("jsp.error.tld.unable_to_read", jarResource.getUrl(),
                            jarResource.getUrl(), ex.toString());
======= efd418b:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

======= efd418b:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

    private void parseTLD(String uri, InputStream in, JarResource jarResource)
======= efd418b:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                        jarResource);
======= efd418b:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

    private TldLocation generateTLDLocation(String uri, JspCompilationContext ctxt)
======= efd418b:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

        if (uri.endsWith(".jar")) {
                url = ctxt.getResource(uri);
                err.jspError("jsp.error.tld.unable_to_get_jar", uri, ex
                err.jspError("jsp.error.tld.missing_jar", uri);
            return new TldLocation("META-INF/taglib.tld", url.toString());
        } else {
            return new TldLocation(uri);
======= efd418b:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

    private TagFileInfo createTagFileInfo(TreeNode elem, JarResource jarResource)
======= efd418b:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

            ctxt.setTagFileJarResource(path, jarResource);
                parserController, name, path, jarResource, this);
======= efd418b:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    
    private String entryName;
    private JarResource jar;
    
    public TldLocation(String entryName) {
        this(entryName, (JarResource)null);
    }
    
    public TldLocation(String entryName, String resourceUrl) {
        this(entryName, getJarResource(resourceUrl));
    }
    
    public TldLocation(String entryName, JarResource jarResource) {
        if (entryName == null) {
            throw new IllegalArgumentException("Tld name is required");
        }
        this.entryName = entryName;
        this.jar = jarResource;
    }
        
    private static JarResource getJarResource(String resourceUrl) {
        return (resourceUrl != null) ? new JarURLResource(resourceUrl) : null;
    }
    
    /**
     * @return The name of the tag library.
     */
    public String getName() {
        return entryName;
    }
    
    /**
     * 
     * @return The jar resource the tag library is contained in. 
     *         Might return null if the tag library is not contained in jar resource.
     */
    public JarResource getJarResource() {
        return jar;
    }
======= efd418b:"java/org/apache/jasper/compiler/TldLocationsCache.java"

    private Hashtable<String, TldLocation> mappings;
======= efd418b:"java/org/apache/jasper/compiler/TldLocationsCache.java"

        mappings = new Hashtable<String, TldLocation>();
======= efd418b:"java/org/apache/jasper/compiler/TldLocationsCache.java"

    public TldLocation getLocation(String uri) throws JasperException {
======= efd418b:"java/org/apache/jasper/compiler/TldLocationsCache.java"

                TldLocation location;
                    location = new TldLocation("META-INF/taglib.tld", ctxt.getResource(tagLoc).toString());
                } else {
                    location = new TldLocation(tagLoc);
                mappings.put(tagUri, location);
======= efd418b:"java/org/apache/jasper/compiler/TldLocationsCache.java"

                TldLocation location;
                if (entryName == null) {
                    location = new TldLocation(resourcePath);
                } else {
                    location = new TldLocation(entryName, resourcePath);
                }
                mappings.put(uri, location);
======= efd418b:"java/org/apache/jasper/servlet/JspServletWrapper.java"

======= efd418b:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                             JarResource tagJarResource) {
======= efd418b:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                                         tagJarResource);
      <add>
        <bug>48689</bug>: Access TLD files through a new JarResource interface
        to make extending Jasper simpler, particularly in OSGi environments.
        Patch provided by Jarek Gawor. (markt)
      </add>

======= b30fc95:"java/org/apache/catalina/connector/Request.java"

        for (ArrayList<Locale> list : locales.values()) {
            for (Locale locale : list) {
======= b30fc95:"java/org/apache/catalina/core/ApplicationHttpRequest.java"

        
        for (Map.Entry<String, String[]> entry : orig.entrySet()) {
            dest.put(entry.getKey(), entry.getValue());
======= b30fc95:"java/org/apache/catalina/core/StandardContext.java"

======= b30fc95:"java/org/apache/catalina/core/StandardContext.java"

        for (ArrayList<Wrapper> list : map.values()) {
            for (Wrapper wrapper : list) {
======= b30fc95:"java/org/apache/catalina/ha/authenticator/ClusterSingleSignOnListener.java"

            for (Map.Entry<String, ClusterManager> entry : managers.entrySet()) {
                if (entry.getValue() != null) {
                        session = entry.getValue().findSession(sessionId);
======= b30fc95:"java/org/apache/catalina/ha/authenticator/ClusterSingleSignOnListener.java"

                                  + entry.getKey());
======= b30fc95:"java/org/apache/catalina/ha/session/ClusterSessionListener.java"

======= b30fc95:"java/org/apache/catalina/ha/session/ClusterSessionListener.java"

                for (Map.Entry<String, ClusterManager> entry :
                        managers.entrySet()) {
                    if (entry.getValue() != null)
                        entry.getValue().messageDataReceived(msg);
                                    + entry.getKey());
======= b30fc95:"java/org/apache/catalina/startup/ContextConfig.java"

                for (Map.Entry<String, String> entry : initParams.entrySet()) {
                    servletDef.addInitParameter(entry.getKey(),
                            entry.getValue());
======= b30fc95:"java/org/apache/catalina/startup/ContextConfig.java"

                for (Map.Entry<String, String> entry : initParams.entrySet()) {
                    filterDef.addInitParameter(entry.getKey(),
                            entry.getValue());

======= a6092d7:"java/org/apache/catalina/realm/RealmBase.java"

    protected static volatile MessageDigest md5Helper;
======= a6092d7:"java/org/apache/catalina/session/StandardSession.java"

    protected static volatile HttpSessionContext sessionContext = null;
======= a6092d7:"java/org/apache/catalina/session/StandardSession.java"

        stream.writeObject(Long.valueOf(creationTime));
        stream.writeObject(Long.valueOf(lastAccessedTime));
        stream.writeObject(Integer.valueOf(maxInactiveInterval));
        stream.writeObject(Boolean.valueOf(isNew));
        stream.writeObject(Boolean.valueOf(isValid));
        stream.writeObject(Long.valueOf(thisAccessedTime));
======= a6092d7:"java/org/apache/catalina/session/StandardSession.java"

        stream.writeObject(Integer.valueOf(n));
======= a6092d7:"java/org/apache/catalina/startup/TldConfig.java"

    private static volatile Set<String> noTldJars = null;
======= a6092d7:"java/org/apache/catalina/util/ExtensionValidator.java"

    private static volatile ArrayList<Extension> containerAvailableExtensions =
        null;
======= a6092d7:"java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java"

    protected static volatile Digester digester = null;

======= fd7ed83:"java/org/apache/catalina/startup/Bootstrap.java"

        paramValues[0] = Boolean.valueOf(await);
======= fd7ed83:"java/org/apache/catalina/startup/Bootstrap.java"

            // Don't set daemon until init() has completed
            Bootstrap bootstrap = new Bootstrap();
                bootstrap.init();
            daemon = bootstrap;

======= aa758d8:"test/org/apache/catalina/tribes/test/interceptors/TestOrderInterceptor.java"

======= aa758d8:"test/org/apache/catalina/tribes/test/interceptors/TestOrderInterceptor.java"

        final Queue<Exception> exceptionQueue = new ConcurrentLinkedQueue<Exception>();
======= aa758d8:"test/org/apache/catalina/tribes/test/interceptors/TestOrderInterceptor.java"

                        exceptionQueue.add(x);
======= aa758d8:"test/org/apache/catalina/tribes/test/interceptors/TestOrderInterceptor.java"

        if (!exceptionQueue.isEmpty()) {
        	fail("Exception while sending in threads: " 
        			+ exceptionQueue.remove().toString());
        }

======= 8bd4d7a:"java/javax/servlet/jsp/tagext/TagSupport.java"

                    ((Class<?>)klass).isAssignableFrom(tag.getClass())) {

======= f61100d:"java/org/apache/catalina/ha/session/DeltaManager.java"

                int len = i + getSendAllSessionsSize() > currentSessions.length ? currentSessions.length - i : getSendAllSessionsSize();
                Session[] sendSessions = new Session[len];

======= e7fb8fa:"java/org/apache/catalina/core/StandardThreadExecutor.java"

     * prestart threads?
     */
    protected boolean prestartminSpareThreads = false;
    /**
======= e7fb8fa:"java/org/apache/catalina/core/StandardThreadExecutor.java"

        if (prestartminSpareThreads) {
            executor.prestartAllCoreThreads();
        }
======= e7fb8fa:"java/org/apache/catalina/core/StandardThreadExecutor.java"

    public boolean isPrestartminSpareThreads() {
        return prestartminSpareThreads;
    }
======= e7fb8fa:"java/org/apache/catalina/core/StandardThreadExecutor.java"

    public void setPrestartminSpareThreads(boolean prestartminSpareThreads) {
        this.prestartminSpareThreads = prestartminSpareThreads;
    }
      <add>
        <bug>43642</bug>: Add prestartminSpareThreads attribute for Executor. (jfclere)
      </add>
    <attribute name="prestartminSpareThreads" required="false">
      <p>(boolean) Whether minSpareThreads should be started when starting the Executor or not,
          the default is <code>false</code></p>
    </attribute>

======= 7205c74:"java/javax/mail/internet/MimeMessage.java"


======= fcb9861:"java/org/apache/catalina/ha/session/BackupManager.java"

        if (sessions instanceof LazyReplicatedMap) {
            LazyReplicatedMap map = (LazyReplicatedMap)sessions;
            if ( map!=null ) {
                map.breakdown();
            }

======= 09f4e25:"java/org/apache/catalina/ha/session/BackupManager.java"

======= 09f4e25:"java/org/apache/catalina/ha/session/BackupManager.java"

        
        if (!initialized) init();
        // Force initialization of the random number generator
        generateSessionId();
======= 09f4e25:"java/org/apache/catalina/ha/session/BackupManager.java"

        setState(LifecycleState.STARTING);
======= 09f4e25:"java/org/apache/catalina/ha/session/BackupManager.java"

        if (log.isDebugEnabled())
            log.debug("Stopping");
        setState(LifecycleState.STOPPING);
        this.random = null;
        if( initialized ) {
            destroy();
        }

======= 867605f:"java/org/apache/catalina/authenticator/DigestAuthenticator.java"

    protected volatile static MessageDigest md5Helper;

======= 95a2eb8:"java/javax/servlet/http/HttpServlet.java"

        StringBuilder buffer = new StringBuilder("TRACE ").append(req.getRequestURI())
            .append(" ").append(req.getProtocol());
            buffer.append(CRLF).append(headerName).append(": ")
                .append(req.getHeader(headerName)); 
        buffer.append(CRLF);
        responseLength = buffer.length();
        out.print(buffer.toString());        

======= b027259:"java/org/apache/jasper/runtime/JspFactoryImpl.java"

    protected static final class PageContextPool  {

======= bcf0a01:"java/org/apache/catalina/Realm.java"

======= bcf0a01:"java/org/apache/catalina/realm/CombinedRealm.java"

======= bcf0a01:"java/org/apache/catalina/realm/LockOutRealm.java"

======= bcf0a01:"java/org/apache/catalina/realm/RealmBase.java"


======= f8d3565:"java/org/apache/catalina/realm/JNDIRealm.java"


======= ead3997:"java/javax/el/ExpressionFactory.java"

     * @return the new ExpressionFactory
======= ead3997:"java/javax/el/ExpressionFactory.java"

     * @param properties the properties to be passed to the new instance (may be null)
     * @return the new ExpressionFactory
======= ead3997:"java/javax/servlet/HttpConstraintElement.java"

     * Convenience constructor for {@link EmptyRoleSemantic#DENY}.
======= ead3997:"java/javax/servlet/ServletContext.java"

     *                                  {@link SessionTrackingMode#SSL} in
======= ead3997:"java/org/apache/catalina/Context.java"

     * @param jspWildcard true if name identifies the JspServlet
======= ead3997:"java/org/apache/catalina/Host.java"

     * @return true if the Host will attempt to create directories
======= ead3997:"java/org/apache/catalina/Lifecycle.java"

 * the component as soon as {@link #start()} exits.
======= ead3997:"java/org/apache/catalina/Session.java"

     * @see #getThisAccessedTime()
======= ead3997:"java/org/apache/catalina/Session.java"

     * @see #getLastAccessedTime()
======= ead3997:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

     *                      to {@link HttpServletResponse#sendError(int, String)}
======= ead3997:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

     *                      to {@link HttpServletResponse#sendError(int, String)}
======= ead3997:"java/org/apache/catalina/connector/Request.java"

     * @param newSessionId   The session to change the session ID for
======= ead3997:"java/org/apache/catalina/core/ApplicationSessionCookieConfig.java"

     * @param context     The Context for the web application
======= ead3997:"java/org/apache/catalina/core/ContainerBase.java"

     * the digester should use {@link #getPipeline()}.{@link #addValve(Valve)} in case a
======= ead3997:"java/org/apache/catalina/core/StandardContext.java"

     * Set the clearReferencesThreadLocals feature for this Context.
     * @param clearReferencesThreadLocals The new flag value
======= ead3997:"java/org/apache/catalina/session/StandardSession.java"

     * @see #getThisAccessedTime()
======= ead3997:"java/org/apache/catalina/session/StandardSession.java"

     * @see #getLastAccessedTime()
======= ead3997:"java/org/apache/catalina/tribes/ChannelListener.java"

     * @see Object#hashCode()
======= ead3997:"java/org/apache/catalina/tribes/group/RpcChannel.java"

     * @param rpcOptions int - FIRST_REPLY, MAJORITY_REPLY or ALL_REPLY
     * @param channelOptions channel sender options
======= ead3997:"java/org/apache/el/parser/AstValue.java"

     * @since EL 2.2
======= ead3997:"java/org/apache/jasper/compiler/Node.java"

         *         false for string literals or rtexprvalues that should not be
======= ead3997:"webapps/examples/WEB-INF/classes/chat/ChatServlet.java"

======= ead3997:"webapps/examples/WEB-INF/classes/filters/ExampleFilter.java"

     * @param response The servlet response we are creating
======= ead3997:"webapps/examples/WEB-INF/classes/filters/SetCharacterEncodingFilter.java"

     * @param response The servlet response we are creating

======= 5be4f29:"java/org/apache/coyote/ajp/AjpProtocol.java"

        protected ConcurrentHashMap<SocketWrapper<Socket>, AjpProcessor> connections =
            new ConcurrentHashMap<SocketWrapper<Socket>, AjpProcessor>();
======= 5be4f29:"java/org/apache/coyote/http11/Http11Protocol.java"

======= 5be4f29:"java/org/apache/coyote/http11/Http11Protocol.java"

        protected ConcurrentHashMap<SocketWrapper<Socket>, Http11Processor> connections =
            new ConcurrentHashMap<SocketWrapper<Socket>, Http11Processor>();
======= 5be4f29:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

                Iterator<SocketWrapper<Socket>> sockets =
                    waitingRequests.iterator();
                    SocketWrapper<Socket> socket = sockets.next();
======= 5be4f29:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

    protected ConcurrentLinkedQueue<SocketWrapper<Socket>> waitingRequests =
        new ConcurrentLinkedQueue<SocketWrapper<Socket>>();

======= 1018cd7:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    @Override
======= 1018cd7:"java/org/apache/coyote/http11/Http11Protocol.java"

    @Override
======= 1018cd7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    @Override
======= 1018cd7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    @Override
======= 1018cd7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    @Override
======= 1018cd7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    @Override
======= 1018cd7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

    @Override
======= 1018cd7:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    @Override
======= 1018cd7:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    @Override
======= 1018cd7:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    @Override
======= 1018cd7:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    @Override
======= 1018cd7:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    @Override
======= 1018cd7:"java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java"

    @Override

======= 32046eb:"java/org/apache/catalina/mbeans/MBeanFactory.java"

======= 32046eb:"java/org/apache/catalina/mbeans/MBeanFactory.java"

======= 32046eb:"java/org/apache/catalina/mbeans/MBeanFactory.java"

        return createStandardContext(parent, path, docBase, false, false,
                false, false);                                  
======= 32046eb:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * Creates a new StandardService and StandardEngine.
     *
     * @param domain       Domain name for the container instance
     * @param defaultHost  Name of the default host to be used in the Engine
     * @param baseDir      Base directory value for Engine 
     *
     * @exception Exception if an MBean cannot be created or registered
     */
    public String createStandardServiceEngine(String domain,
            String defaultHost, String baseDir) throws Exception{
        if (!(container instanceof Server)) {
            throw new Exception();
        }
        
        StandardEngine engine = new StandardEngine();
        engine.setDomain(domain);
        engine.setName(domain);
        engine.setDefaultHost(defaultHost);
        engine.setBaseDir(baseDir);
        Service service = new StandardService();
        service.setContainer(engine);
        service.setName(domain);
        
        ((Server) container).addService(service);
        
        return engine.getJmxName().toString();
    }
    
    
    /**
======= 32046eb:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * Remove an existing Service.
     *
     * @param name MBean Name of the component to remove
     *
     * @exception Exception if a component cannot be removed
     */
    public void removeService(String name) throws Exception {
        if (!(container instanceof Server)) {
            throw new Exception();
        }
        
        // Acquire a reference to the component to be removed
        ObjectName oname = new ObjectName(name);
        Service service = getService(oname); 
        ((Server) container).removeService(service);
    }
    /**
                 type="org.apache.catalina.mbeans.MBeanFactory"
    <operation   name="createStandardServiceEngine"
          description="Create a new StandardService and StandardEngine"
      <parameter name="domain"
          description="Domain used for MBeans associated with the new Service"
          description="Default host name for the new Engine"
      <parameter name="baseDir"
          description="Base directory value for the new Engine"

======= cb0b029:"java/org/apache/catalina/tribes/io/ChannelData.java"

    public static volatile boolean USE_SECURE_RANDOM_FOR_UUID = false;

======= bddfc0a:"java/org/apache/catalina/session/StandardManager.java"

                    if (!session.isValidInternal()) {
                        // If session is already invalid,
                        // expire session to prevent memory leak.
                        session.setValid(true);
                        session.expire();
                    }

======= 6fc4360:"java/javax/servlet/annotation/HandlesTypes.java"

 * This annotation is used to declare an array of application classes which are
 * passed to a {@link javax.servlet.ServletContainerInitializer}.
 * 
    /**
     * @return array of classes
     */
======= 6fc4360:"java/javax/servlet/annotation/HttpConstraint.java"

 * This annotation represents the security constraints that are applied to all
 * requests with HTTP protocol method types that are not otherwise represented
 * by a corresponding {@link javax.servlet.annotation.HttpMethodConstraint} in a
 * {@link javax.servlet.annotation.ServletSecurity} annotation.
 * 
    /**
     * The EmptyRoleSemantic determines the behaviour when the rolesAllowed list
     * is empty.
     * 
     * @return empty role semantic
     */
    /**
     * Determines whether SSL/TLS is required to process the current request.
     * 
     * @return transport guarantee
     */
    /**
     * The authorized roles' names. The container may discard duplicate role
     * names during processing of the annotation. N.B. The String "*" does not
     * have a special meaning if it occurs as a role name.
     * 
     * @return array of names. The array may be of zero length, in which case
     *         the EmptyRoleSemantic applies; the returned value determines
     *         whether access is to be permitted or denied regardless of the
     *         identity and authentication state in either case, PERMIT or DENY.<br />
     *         Otherwise, when the array contains one or more role names access
     *         is permitted if the user a member of at least one of the named
     *         roles. The EmptyRoleSemantic is not applied in this case.
     * 
     */
======= 6fc4360:"java/javax/servlet/annotation/HttpMethodConstraint.java"

 * Specific security constraints can be applied to different types of request,
 * differentiated by the HTTP protocol method type by using this annotation
 * inside the {@link javax.servlet.annotation.ServletSecurity} annotation.
 * 
 * 
    /**
     * HTTP Protocol method name (e.g. POST, PUT)
     * 
     * @return method name
     */
    /**
     * The EmptyRoleSemantic determines the behaviour when the rolesAllowed list
     * is empty.
     * 
     * @return empty role semantic
     */
    /**
     * Determines whether SSL/TLS is required to process the current request.
     * 
     * @return transport guarantee
     */
    /**
     * The authorized roles' names. The container may discard duplicate role
     * names during processing of the annotation. N.B. The String "*" does not
     * have a special meaning if it occurs as a role name.
     * 
     * @return array of names. The array may be of zero length, in which case
     *         the EmptyRoleSemantic applies; the returned value determines
     *         whether access is to be permitted or denied regardless of the
     *         identity and authentication state in either case, PERMIT or DENY.<br />
     *         Otherwise, when the array contains one or more role names access
     *         is permitted if the user a member of at least one of the named
     *         roles. The EmptyRoleSemantic is not applied in this case.
     */
======= 6fc4360:"java/javax/servlet/annotation/MultipartConfig.java"

 * This annotation is used to indicate that the {@link javax.servlet.Servlet} on
 * which it is declared expects requests to made using the {@code
 * multipart/form-data} MIME type. <br />
 * <br />
 * 
 * {@link javax.servlet.http.Part} components of a given {@code
 * multipart/form-data} request are retrieved by a Servlet annotated with
 * {@code MultipartConfig} by calling
 * {@link javax.servlet.http.HttpServletRequest#getPart} or
 * {@link javax.servlet.http.HttpServletRequest#getParts}.<br />
 * <br />
 * 
 * E.g. <code>@WebServlet("/upload")}</code><br />
 * 
 * <code>@MultipartConfig()</code> <code>public class UploadServlet extends
 * HttpServlet ... } </code><br />
 * 
    /**
     * @return location in which the Container stores temporary files
     */
    /**
     * @return the maximum size allowed for uploaded files (in bytes)
     */
    /**
     * @return the maximum size of the request allowed for {@code
     *         multipart/form-data}
     */
    /**
     * @return the size threshold at which the file will be written to the disk
     */
======= 6fc4360:"java/javax/servlet/annotation/ServletSecurity.java"

 * Declare this annotation on a {@link javax.servlet.Servlet} implementation
 * class to enforce security constraints on HTTP protocol requests.<br />
 * The container applies constraints to the URL patterns mapped to each Servlet
 * which declares this annotation.<br />
 * <br />
 * 
    /**
     * Represents the two possible values of the empty role semantic, active
     * when a list of role names is empty.
     */
        /**
         * Access MUST be permitted, regardless of authentication state or
         * identity
         */
        /**
         * Access MUST be denied, regardless of authentication state or identity
         */
    /**
     * Represents the two possible values of data transport, encrypted or not.
     */
        /**
         * User data must not be encrypted by the container during transport
         */
        /**
         * The container MUST encrypt user data during transport
         */
    /**
     * The default constraint to apply to requests not handled by specific
     * method constraints
     * 
     * @return http constraint
     */
    /**
     * An array of HttpMethodContraint objects to which the security constraint
     * will be applied
     * 
     * @return array of http method constraint
     */
======= 6fc4360:"java/javax/servlet/annotation/WebFilter.java"

 * The annotation used to declare a Servlet {@link javax.servlet.Filter}. <br />
 * <br />
 * 
 * This annotation will be processed by the container during deployment, the
 * Filter class in which it is found will be created as per the configuration
 * and applied to the URL patterns, {@link javax.servlet.Servlet}s and
 * {@link javax.servlet.DispatcherType}s.<br />
 * <br/>
 * 
 * If the name attribute is not defined, the fully qualified name of the class
 * is used.<br/>
 * <br/>
 * 
 * At least one URL pattern MUST be declared in either the {@code value} or
 * {@code urlPattern} attribute of the annotation, but not both.<br/>
 * <br/>
 * 
 * The {@code value} attribute is recommended for use when the URL pattern is
 * the only attribute being set, otherwise the {@code urlPattern} attribute
 * should be used.<br />
 * <br />
 * 
 * The annotated class MUST implement {@link javax.servlet.Filter}.
 * 
 * E.g.
 * 
 * <code>@WebFilter("/path/*")</code><br />
 * <code>public class AnExampleFilter implements Filter { ... </code><br />
 * 
 * @since Servlet 3.0 (Section 8.1.2)
 * 
    /**
     * @return description of the Filter, if present
     */
    /**
     * @return display name of the Filter, if present
     */
    /**
     * @return array of initialization params for this Filter
     */
    /**
     * @return name of the Filter, if present
     */
    /**
     * @return small icon for this Filter, if present
     */
    /**
     * @return the large icon for this Filter, if present
     */
    /**
     * @return array of Servlet names to which this Filter applies
     */
    /**
     * A convenience method, to allow extremely simple annotation of a class.
     * 
     * @return array of URL patterns
     * @see #urlPatterns()
     */
    /**
     * @return array of URL patterns to which this Filter applies
     */
    /**
     * @return array of DispatcherTypes to which this filter applies
     */
    /**
     * @return asynchronous operation supported by this Filter
     */
======= 6fc4360:"java/javax/servlet/annotation/WebInitParam.java"

 * The annotation used to declare an initialization parameter on a
 * {@link javax.servlet.Servlet} or {@link javax.servlet.Filter}, within a
 * {@link javax.servlet.annotation.WebFilter} or
 * {@link javax.servlet.annotation.WebServlet} annotation.<br />
 * <br />
 * 
 * E.g.
 * <code>@WebServlet(name="TestServlet", urlPatterns={"/test"},initParams={@WebInitParam(name="test", value="true")})
 * public class TestServlet extends HttpServlet { ... </code><br />
 * 
    /**
     * @return name of the initialization parameter
     */
    /**
     * @return value of the initialization parameter
     */
    /**
     * @return description of the initialization parameter
     */
======= 6fc4360:"java/javax/servlet/annotation/WebListener.java"

 * The annotation used to declare a listener for various types of event, in a
 * given web application context.<br />
 * <br />
 * 
 * The class annotated MUST implement one, (or more), of the following
 * interfaces: {@link javax.servlet.http.HttpSessionAttributeListener},
 * {@link javax.servlet.http.HttpSessionListener},
 * {@link javax.servlet.ServletContextAttributeListener},
 * {@link javax.servlet.ServletContextListener},
 * {@link javax.servlet.ServletRequestAttributeListener},
 * {@link javax.servlet.ServletRequestListener} <br />
 * <br />
 * 
 * E.g. <code>@WebListener</code><br />
 * <code>public TestListener implements ServletContextListener {</code><br />
 * 
    /**
     * @return description of the listener, if present
     */
======= 6fc4360:"java/javax/servlet/annotation/WebServlet.java"

 * This annotation is used to declare the configuration of an
 * {@link javax.servlet.Servlet}. <br/>
 * 
 * If the name attribute is not defined, the fully qualified name of the class
 * is used.<br/>
 * <br/>
 * 
 * At least one URL pattern MUST be declared in either the {@code value} or
 * {@code urlPattern} attribute of the annotation, but not both.<br/>
 * <br/>
 * 
 * The {@code value} attribute is recommended for use when the URL pattern is
 * the only attribute being set, otherwise the {@code urlPattern} attribute
 * should be used.<br />
 * <br />
 * 
 * The class on which this annotation is declared MUST extend
 * {@link javax.servlet.http.HttpServlet}. <br />
 * <br />
 * 
 * E.g. <code>@WebServlet("/path")}<br />
 * public class TestServlet extends HttpServlet ... {</code><br />
 * 
 * E.g.
 * <code>@WebServlet(name="TestServlet", urlPatterns={"/path", "/alt"}) <br />
 * public class TestServlet extends HttpServlet ... {</code><br />
 * 
 * @since Servlet 3.0 (Section 8.1.1)
 * 
    /**
     * @return name of the Servlet
     */
    /**
     * A convenience method, to allow extremely simple annotation of a class.
     * 
     * @return array of URL patterns
     * @see #urlPatterns()
     */
    /**
     * @return array of URL patterns to which this Filter applies
     */
    /**
     * @return load on startup ordering hint
     */
    /**
     * @return array of initialization params for this Servlet
     */
    /**
     * @return asynchronous operation supported by this Servlet
     */
    /**
     * @return small icon for this Servlet, if present
     */
    /**
     * @return large icon for this Servlet, if present
     */
    /**
     * @return description of this Servlet, if present
     */
    /**
     * @return display name of this Servlet, if present
     */

======= 1ecfaa9:"java/org/apache/jasper/tagplugins/jstl/Util.java"

    private static char[][] specialCharactersRepresentation = new char[HIGHEST_SPECIAL + 1][];

======= e59ba8f:"java/org/apache/catalina/realm/JNDIRealm.java"

         final private List<String> roles = new ArrayList<String>();
             if (roles != null) {
                 this.roles.addAll(roles);
             }

======= 155e3f8:"java/org/apache/catalina/manager/ManagerServlet.java"

                    expired++;
======= 155e3f8:"java/org/apache/catalina/manager/ManagerServlet.java"

                writer.println(sm.getString("managerServlet.sessiontimeout.unlimited",
                                            "" + notimeout));
                writer.println(sm.getString("managerServlet.sessiontimeout.expired",
                                            "" + idle,"" + expired));

======= 216352a:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            if (timeout <= 0) {

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
    /**
     * Mock {@link FilterChain} to keep a handle on the passed
     * {@link ServletRequest}.
     */
    public static class MockFilterChain implements FilterChain {
        private HttpServletRequest request;
        @Override
        public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {
            this.request = (HttpServletRequest) request;
        }
        public HttpServletRequest getRequest() {
            return request;
        }
    }
    public static class MockHttpServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        HttpServletRequest request;
        public HttpServletRequest getRequest() {
            return request;
        }
        @Override
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            this.request = request;
            PrintWriter writer = response.getWriter();
            writer.println("request.remoteAddr=" + request.getRemoteAddr());
            writer.println("request.remoteHost=" + request.getRemoteHost());
            writer.println("request.secure=" + request.isSecure());
            writer.println("request.scheme=" + request.getScheme());
            writer.println("request.serverPort=" + request.getServerPort());
            writer.println();
            for (Enumeration<String> headers = request.getHeaderNames(); headers.hasMoreElements();) {
                String name = headers.nextElement().toString();
                writer.println("request.header['" + name + "']=" + Collections.list(request.getHeaders(name)));
            }
        }
    }
    /**
     * Enhanced {@link Request} to ease testing.
     */
    public static class MockHttpServletRequest extends Request {
        public MockHttpServletRequest() {
            super();
            setCoyoteRequest(new org.apache.coyote.Request());
            setConnector(new Connector());
        }
        public void setHeader(String name, String value) {
            getCoyoteRequest().getMimeHeaders().setValue(name).setString(value);
        }
        public void setScheme(String scheme) {
            getCoyoteRequest().scheme().setString(scheme);
        }
    }
    public static final String TEMP_DIR = System.getProperty("java.io.tmpdir");
    public void testCommaDelimitedListToStringArray() {
        List<String> elements = Arrays.asList("element1", "element2", "element3");
        String actual = RemoteIpFilter.listToCommaDelimitedString(elements);
        assertEquals("element1, element2, element3", actual);
    }
    public void testCommaDelimitedListToStringArrayEmptyList() {
        List<String> elements = new ArrayList<String>();
        String actual = RemoteIpFilter.listToCommaDelimitedString(elements);
        assertEquals("", actual);
    }
    public void testCommaDelimitedListToStringArrayNullList() {
        String actual = RemoteIpFilter.listToCommaDelimitedString(null);
        assertEquals("", actual);
    }
    public void testHeaderNamesCaseInsensitivity() {
        RemoteIpFilter.XForwardedRequest request = new RemoteIpFilter.XForwardedRequest(new MockHttpServletRequest());
        request.setHeader("myheader", "lower Case");
        request.setHeader("MYHEADER", "UPPER CASE");
        request.setHeader("MyHeader", "Camel Case");
        assertEquals(1, request.headers.size());
        assertEquals("Camel Case", request.getHeader("myheader"));
    }
    public void testIncomingRequestIsSecuredButProtocolHeaderSaysItIsNotWithCustomValues() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("protocolHeader", "x-forwarded-proto");
        filterDef.addInitParameter("remoteIPHeader", "x-my-forwarded-for");
        filterDef.addInitParameter("httpServerPort", "8080");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setSecure(true);
        request.setScheme("https");
        request.setHeader("x-my-forwarded-for", "140.211.11.130");
        request.setHeader("x-forwarded-proto", "http");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        boolean actualSecure = actualRequest.isSecure();
        assertEquals("request must be unsecured as header x-forwarded-proto said it is http", false, actualSecure);
        String actualScheme = actualRequest.getScheme();
        assertEquals("scheme must be http as header x-forwarded-proto said it is http", "http", actualScheme);
        int actualServerPort = actualRequest.getServerPort();
        assertEquals("wrong http server port", 8080, actualServerPort);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
    }
    public void testIncomingRequestIsSecuredButProtocolHeaderSaysItIsNotWithDefaultValues() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("protocolHeader", "x-forwarded-proto");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setSecure(true);
        request.setScheme("https");
        request.setHeader("x-forwarded-for", "140.211.11.130");
        request.setHeader("x-forwarded-proto", "http");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        boolean actualSecure = actualRequest.isSecure();
        assertEquals("request must be unsecured as header x-forwarded-proto said it is http", false, actualSecure);
        String actualScheme = actualRequest.getScheme();
        assertEquals("scheme must be http as header x-forwarded-proto said it is http", "http", actualScheme);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
    }
    public void testInvokeAllowedRemoteAddrWithNullRemoteIpHeader() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("remote-host-original-value");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = request.getHeader("x-forwarded-for");
        assertNull("x-forwarded-for must be null", actualXForwardedFor);
        String actualXForwardedBy = request.getHeader("x-forwarded-by");
        assertNull("x-forwarded-by must be null", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "192.168.0.10", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "remote-host-original-value", actualRemoteHost);
    }
    public void testInvokeAllProxiesAreInternal() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("remote-host-original-value");
        request.setHeader("x-forwarded-for", "140.211.11.130, 192.168.0.10, 192.168.0.11");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for");
        assertNull("all proxies are internal, x-forwarded-for must be null", actualXForwardedFor);
        String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by");
        assertNull("all proxies are internal, x-forwarded-by must be null", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
    }
    public void testInvokeAllProxiesAreTrusted() throws Exception {
        // PREPARE
        RemoteIpFilter remoteIpFilter = new RemoteIpFilter();
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        filterDef.setFilter(remoteIpFilter);
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("remote-host-original-value");
        request.setHeader("x-forwarded-for", "140.211.11.130, proxy1, proxy2");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for");
        assertNull("all proxies are trusted, x-forwarded-for must be null", actualXForwardedFor);
        String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by");
        assertEquals("all proxies are trusted, they must appear in x-forwarded-by", "proxy1, proxy2", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
    }
    public void testInvokeAllProxiesAreTrustedAndRemoteAddrMatchRegexp() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "127\\.0\\.0\\.1, 192\\.168\\..*, another-internal-proxy");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("remote-host-original-value");
        request.setHeader("x-forwarded-for", "140.211.11.130, proxy1, proxy2");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for");
        assertNull("all proxies are trusted, x-forwarded-for must be null", actualXForwardedFor);
        String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by");
        assertEquals("all proxies are trusted, they must appear in x-forwarded-by", "proxy1, proxy2", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
    }
    public void testInvokeAllProxiesAreTrustedOrInternal() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("remote-host-original-value");
        request.setHeader("x-forwarded-for", "140.211.11.130, proxy1, proxy2, 192.168.0.10, 192.168.0.11");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for");
        assertNull("all proxies are trusted, x-forwarded-for must be null", actualXForwardedFor);
        String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by");
        assertEquals("all proxies are trusted, they must appear in x-forwarded-by", "proxy1, proxy2", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
    }
    public void testInvokeNotAllowedRemoteAddr() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("not-allowed-internal-proxy");
        request.setRemoteHost("not-allowed-internal-proxy-host");
        request.setHeader("x-forwarded-for", "140.211.11.130, proxy1, proxy2");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for");
        assertEquals("x-forwarded-for must be unchanged", "140.211.11.130, proxy1, proxy2", actualXForwardedFor);
        String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by");
        assertNull("x-forwarded-by must be null", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "not-allowed-internal-proxy", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "not-allowed-internal-proxy-host", actualRemoteHost);
    }
    public void testInvokeUntrustedProxyInTheChain() throws Exception {
        // PREPARE
        FilterDef filterDef = new FilterDef();
        filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11");
        filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3");
        filterDef.addInitParameter("remoteIPHeader", "x-forwarded-for");
        filterDef.addInitParameter("proxiesHeader", "x-forwarded-by");
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("remote-host-original-value");
        request.setHeader("x-forwarded-for", "140.211.11.130, proxy1, untrusted-proxy, proxy2");
        // TEST
        HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);
        // VERIFY
        String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for");
        assertEquals("ip/host before untrusted-proxy must appear in x-forwarded-for", "140.211.11.130, proxy1", actualXForwardedFor);
        String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by");
        assertEquals("ip/host after untrusted-proxy must appear in  x-forwarded-by", "proxy2", actualXForwardedBy);
        String actualRemoteAddr = actualRequest.getRemoteAddr();
        assertEquals("remoteAddr", "untrusted-proxy", actualRemoteAddr);
        String actualRemoteHost = actualRequest.getRemoteHost();
        assertEquals("remoteHost", "untrusted-proxy", actualRemoteHost);
    }
    public void testListToCommaDelimitedString() {
        String[] actual = RemoteIpFilter.commaDelimitedListToStringArray("element1, element2, element3");
        String[] expected = new String[] { "element1", "element2", "element3" };
        assertEquals(expected.length, actual.length);
        for (int i = 0; i < actual.length; i++) {
            assertEquals(expected[i], actual[i]);
        }
    }
    public void testListToCommaDelimitedStringMixedSpaceChars() {
        String[] actual = RemoteIpFilter.commaDelimitedListToStringArray("element1  , element2,\t element3");
        String[] expected = new String[] { "element1", "element2", "element3" };
        assertEquals(expected.length, actual.length);
        for (int i = 0; i < actual.length; i++) {
            assertEquals(expected[i], actual[i]);
        }
    }
    private HttpServletRequest testRemoteIpFilter(FilterDef filterDef, Request request) throws LifecycleException, IOException,
            ServletException {
        Tomcat tomcat = getTomcatInstance();
        Context root = tomcat.addContext("", TEMP_DIR);
        RemoteIpFilter remoteIpFilter = new RemoteIpFilter();
        filterDef.setFilterClass(RemoteIpFilter.class.getName());
        filterDef.setFilter(remoteIpFilter);
        filterDef.setFilterName(RemoteIpFilter.class.getName());
        root.addFilterDef(filterDef);
        FilterMap filterMap = new FilterMap();
        filterMap.setFilterName(RemoteIpFilter.class.getName());
        filterMap.addURLPattern("*");
        root.addFilterMap(filterMap);
        getTomcatInstance().start();
        MockFilterChain filterChain = new MockFilterChain();
        // TEST
        remoteIpFilter.doFilter(request, new Response(), filterChain);
        return filterChain.getRequest();
    }
    /**
     * Test {@link RemoteIpFilter} in Tomcat standalone server
     */
    public void testWithTomcatServer() throws Exception {
        // mostly default configuration : enable "x-forwarded-proto"
        Map<String, String> remoteIpFilterParameter = new HashMap<String, String>();
        remoteIpFilterParameter.put("protocolHeader", "x-forwarded-proto");
        // SETUP
        Tomcat tomcat = getTomcatInstance();
        Context root = tomcat.addContext("", TEMP_DIR);
        FilterDef filterDef = new FilterDef();
        filterDef.getParameterMap().putAll(remoteIpFilterParameter);
        filterDef.setFilterClass(RemoteIpFilter.class.getName());
        filterDef.setFilterName(RemoteIpFilter.class.getName());
        root.addFilterDef(filterDef);
        FilterMap filterMap = new FilterMap();
        filterMap.setFilterName(RemoteIpFilter.class.getName());
        filterMap.addURLPattern("*");
        root.addFilterMap(filterMap);
        MockHttpServlet mockServlet = new MockHttpServlet();
        Tomcat.addServlet(root, mockServlet.getClass().getName(), mockServlet);
        root.addServletMapping("/test", mockServlet.getClass().getName());
        getTomcatInstance().start();
        // TEST
        HttpURLConnection httpURLConnection = (HttpURLConnection) new URL("http://localhost:" + tomcat.getConnector().getPort() + "/test")
                .openConnection();
        String expectedRemoteAddr = "my-remote-addr";
        httpURLConnection.addRequestProperty("x-forwarded-for", expectedRemoteAddr);
        httpURLConnection.addRequestProperty("x-forwarded-proto", "https");
        // VALIDATE
        Assert.assertEquals(HttpURLConnection.HTTP_OK, httpURLConnection.getResponseCode());
        HttpServletRequest request = mockServlet.getRequest();
        Assert.assertNotNull(request);
        // VALIDATE X-FOWARDED-FOR
        Assert.assertEquals(expectedRemoteAddr, request.getRemoteAddr());
        Assert.assertEquals(expectedRemoteAddr, request.getRemoteHost());
        // VALIDATE X-FORWARDED-PROTO
        Assert.assertTrue(request.isSecure());
        Assert.assertEquals("https", request.getScheme());
        Assert.assertEquals(443, request.getServerPort());
    }

======= 9a42719:"java/org/apache/catalina/filters/RemoteIpFilter.java"

            if (log.isDebugEnabled()) {
                log.debug("Skip RemoteIpFilter for request " + request.getRequestURI() + " with originalRemoteAddr '"
                        + request.getRemoteAddr() + "'");
            }
======= 9a42719:"java/org/apache/catalina/valves/RemoteIpValve.java"

        } else {
            if (log.isDebugEnabled()) {
                log.debug("Skip RemoteIpValve for request " + request.getRequestURI() + " with originalRemoteAddr '"
                        + request.getRemoteAddr() + "'");
            }

======= ae6fcf5:"java/org/apache/catalina/core/StandardContext.java"

    
    /**
     * Should Tomcat attempt to clear any ThreadLocal objects that are instances
     * of classes loaded by this class loader. Failure to remove any such
     * objects will result in a memory leak on web application stop, undeploy or
     * reload. It is disabled by default since the clearing of the ThreadLocal
     * objects is not performed in a thread-safe manner.
     */
    private boolean clearReferencesThreadLocals = false;
    
======= ae6fcf5:"java/org/apache/catalina/core/StandardContext.java"

     * Return the clearReferencesThreadLocals flag for this Context.
     */
    public boolean getClearReferencesThreadLocals() {
        return (this.clearReferencesThreadLocals);
    }
    /**
     * Set the clearReferencesStopThreads feature for this Context.
     *
     * @param clearReferencesStopThreads The new flag value
     */
    public void setClearReferencesThreadLocals(
            boolean clearReferencesThreadLocals) {
        boolean oldClearReferencesThreadLocals =
            this.clearReferencesThreadLocals;
        this.clearReferencesThreadLocals = clearReferencesThreadLocals;
        support.firePropertyChange("clearReferencesStopThreads",
                                   oldClearReferencesThreadLocals,
                                   this.clearReferencesThreadLocals);
    }
    /**
======= ae6fcf5:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * Should Tomcat attempt to clear any ThreadLocal objects that are instances
     * of classes loaded by this class loader. Failure to remove any such
     * objects will result in a memory leak on web application stop, undeploy or
     * reload. It is disabled by default since the clearing of the ThreadLocal
     * objects is not performed in a thread-safe manner.
     */
    private boolean clearReferencesThreadLocals = false;
    
    /**
======= ae6fcf5:"java/org/apache/catalina/loader/WebappClassLoader.java"

     /**
      * Return the clearReferencesThreadLocals flag for this Context.
      */
     public boolean getClearReferencesThreadLocals() {
         return (this.clearReferencesThreadLocals);
     }
     /**
      * Set the clearReferencesThreadLocals feature for this Context.
      *
      * @param clearReferencesThreadLocals The new flag value
      */
     public void setClearReferencesThreadLocals(
             boolean clearReferencesThreadLocals) {
         this.clearReferencesThreadLocals = clearReferencesThreadLocals;
     }
======= ae6fcf5:"java/org/apache/catalina/loader/WebappClassLoader.java"

                                    if (clearReferencesThreadLocals) {
                                        log.debug(sm.getString(
                                                "webappClassLoader.clearThreadLocalDebugClear"));
                                    }
                                if (clearReferencesThreadLocals) {
                                    log.info(sm.getString(
                                            "webappClassLoader.clearThreadLocalClear"));
                                }
                            if (clearReferencesThreadLocals) {
                                if (key == null) {
                                  staleEntriesCount++;
                                } else {
                                  mapRemove.invoke(map, key);
                                }
======= ae6fcf5:"java/org/apache/catalina/loader/WebappLoader.java"

                classLoader.setClearReferencesThreadLocals(
                        ((StandardContext) container).getClearReferencesThreadLocals());
      <attribute name="clearReferencesThreadLocals" required="false">
        <p>If <code>true</code>, Tomcat attempts to clear any ThreadLocal
        objects that are instances of classes loaded by this class loader.
        Failure to remove any such objects will result in a memory leak on web
        application stop, undeploy or reload.  If not specified, the default
        value of <code>false</code> will be used since the clearing of the
        ThreadLocal objects is not performed in a thread-safe manner.</p>
      </attribute>

======= 39d3082:"java/org/apache/catalina/ha/session/DeltaManager.java"

                if (notifySessionListenersOnReplication) {
                    session.tellNew();
                }

======= 83226d9:"java/org/apache/catalina/Context.java"

======= 83226d9:"java/org/apache/catalina/Context.java"

     * Return the URL of the XML descriptor for this context.
    public URL getConfigFile();
     * Set the URL of the XML descriptor for this context.
     * @param configFile The URL of the XML descriptor for this context.
    public void setConfigFile(URL configFile);
======= 83226d9:"java/org/apache/catalina/core/StandardContext.java"

======= 83226d9:"java/org/apache/catalina/core/StandardContext.java"

     * The URL of the XML descriptor for this context.
    private URL configFile = null;
======= 83226d9:"java/org/apache/catalina/core/StandardContext.java"

     * Return the URL of the XML descriptor for this context.
    public URL getConfigFile() {
======= 83226d9:"java/org/apache/catalina/core/StandardContext.java"

     * Set the URL of the XML descriptor for this context.
     * @param configFile The URL of the XML descriptor for this context.
    public void setConfigFile(URL configFile) {
======= 83226d9:"java/org/apache/catalina/core/StandardHost.java"

     * Should XML files be copied to $CATALINA_BASE/conf/<engine>/<host> by
     * default when a web application is deployed?
     */
    private boolean copyXML = false;
    /**
======= 83226d9:"java/org/apache/catalina/core/StandardHost.java"

     * Return the copy XML config file flag for this component.
     */
    public boolean isCopyXML() {
        return (this.copyXML);
    }
    /**
     * Set the copy XML config file flag for this component.
     *
     * @param copyXML The new copy XML flag
     */
    public void setCopyXML(boolean copyXML) {
        this.copyXML= copyXML;
    }
    
    
    /**
======= 83226d9:"java/org/apache/catalina/mbeans/MBeanFactory.java"

            context.setConfigFile(configFile.toURI().toURL());
======= 83226d9:"java/org/apache/catalina/startup/ContextConfig.java"

            File defaultContextFile = new File(getBaseDir(), defaultContextXml);
            if (defaultContextFile.exists()) {
                try {
                    URL defaultContextUrl = defaultContextFile.toURI().toURL();
                    processContextConfig(defaultContextUrl);
                } catch (MalformedURLException e) {
                    log.error(sm.getString(
                            "contextConfig.badUrl", defaultContextFile), e);
                }
            }
            
            File hostContextFile = new File(getConfigBase(),
                    getHostConfigPath(Constants.HostContextXml));
            if (hostContextFile.exists()) {
                try {
                    URL hostContextUrl = hostContextFile.toURI().toURL();
                    processContextConfig(hostContextUrl);
                } catch (MalformedURLException e) {
                    log.error(sm.getString(
                            "contextConfig.badUrl", hostContextFile), e);
                }
            }
            processContextConfig(context.getConfigFile());
======= 83226d9:"java/org/apache/catalina/startup/ContextConfig.java"

    protected void processContextConfig(URL contextXml) {
                    + "] configuration file [" + contextXml + "]");
            source = new InputSource(contextXml.toString());
            stream = contextXml.openStream();
            
            // Add as watched resource so that cascade reload occurs if a default
            // config file is modified/added/removed
            if (contextXml.getProtocol() == "file") {
                context.addWatchedResource(
                        (new File(contextXml.toURI())).getAbsolutePath());
                      contextXml) , e);
======= 83226d9:"java/org/apache/catalina/startup/ContextConfig.java"

                            + "] configuration file [" + contextXml + "]");
======= 83226d9:"java/org/apache/catalina/startup/HostConfig.java"

======= 83226d9:"java/org/apache/catalina/startup/HostConfig.java"

     * Should XML files be copied to $CATALINA_BASE/conf/<engine>/<host> by
     * default when a web application is deployed?
     */
    protected boolean copyXML = false;
    
    
    /**
======= 83226d9:"java/org/apache/catalina/startup/HostConfig.java"

     * Return the copy XML config file flag for this component.
     */
    public boolean isCopyXML() {
        return (this.copyXML);
    }
    /**
     * Set the copy XML config file flag for this component.
     *
     * @param copyXML The new copy XML flag
     */
    public void setCopyXML(boolean copyXML) {
        this.copyXML= copyXML;
    }
    /**
======= 83226d9:"java/org/apache/catalina/startup/HostConfig.java"

                setCopyXML(((StandardHost) host).isCopyXML());
======= 83226d9:"java/org/apache/catalina/startup/HostConfig.java"

            context.setConfigFile(contextXml.toURI().toURL());
======= 83226d9:"java/org/apache/catalina/startup/HostConfig.java"

        boolean xmlInWar = false;
        
                    xmlInWar = true;
                }
                if (copyXML) {
======= 83226d9:"java/org/apache/catalina/startup/HostConfig.java"

                context.setConfigFile(xml.toURI().toURL());
            } else if (deployXML && xmlInWar) {
                synchronized (digester) {
                    try {
                        jar = new JarFile(war);
                        entry =
                            jar.getJarEntry(Constants.ApplicationContextXml);
                        istream = jar.getInputStream(entry);
                        context = (Context) digester.parse(istream);
                        if (context == null) {
                            log.error(sm.getString(
                                    "hostConfig.deployDescriptor.error",
                                    file));
                            return;
                        }
                        context.setConfigFile(new URL("jar:" +
                                war.toURI().toString() + "!/" +
                                Constants.ApplicationContextXml));
                    } catch (Exception e) {
                        if (istream != null) {
                            try {
                                istream.close();
                            } catch (Throwable t) {
                                // Ignore
                            }
                            istream = null;
                        }
                    } finally {
                        entry = null;
                        if (jar != null) {
                            try {
                                jar.close();
                            } catch (Throwable t) {
                                // Ignore
                            }
                            jar = null;
                        }
                        digester.reset();
                    }
                }
                if (context == null) {
                    log.error(sm.getString("hostConfig.deployDescriptor.error",
                            file));
                    return;
                }
======= 83226d9:"java/org/apache/catalina/startup/HostConfig.java"

======= 83226d9:"java/org/apache/catalina/startup/HostConfig.java"

                if (copyXML) {
                    xmlCopy = new File(configBase(), file + ".xml");
                    InputStream is = null;
                    OutputStream os = null;
                        is = new FileInputStream(xml);
                        os = new FileOutputStream(xmlCopy);
                        IOTools.flow(is, os);
                        // Don't catch IOE - let the outer try/catch handle it
                    } finally {
                        try {
                            if (is != null) is.close();
                        } catch (IOException e){
                            // Ignore
                        }
                        try {
                            if (os != null) os.close();
                        } catch (IOException e){
                            // Ignore
                        }
                    context.setConfigFile(xmlCopy.toURI().toURL());
                } else {
                    context.setConfigFile(xml.toURI().toURL());
      <add>
        <bug>48662</bug>: Provide a new option to control the copying of context
        XML descriptors from web applications to the host's xmlBase. Copying of
        XMl descriptors is now disabled by default. (markt)
      </add>
        absolute pathname, or a pathname that is relative to the
        <code>$CATALINA_BASE</code> directory.  See
        deployment of web applications. If not specified, the default of
        <code>webapps</code> will be used.</p>
        This is the pathname of a directory that may contain context XML
        descriptors to be deployed on this virtual host.  You may specify an
        deployment of web applications. If not specified the default of
        <code>[engine_name]/[host_name]</code> will be used.</p>
        <p>If set to true, Tomcat will attempt to create the directories defined
        by the  attributes <code>appBase</code> and <code>xmlBase</code> during
        the startup phase. The default value is <code>true</code>. If set to
        true, and directory creation fails, an error message will be printed out
        but will not halt the startup sequence.</p>
        <p>This flag value indicates if Tomcat should check periodically for new
        or updated web applications while Tomcat is running. If true, Tomcat
        periodically checks the <code>appBase</code> and <code>xmlBase</code>
        directories and deploys any new web applications or context XML
        descriptors found. Updated web applications or context XML descriptors
        will trigger a reload of the web application. The flag's value defaults
        to true.  See
        be automatically deployed when Tomcat starts. The flag's value defaults
        to true.  See
      <attribute name="copyXML" required="false">
        <p>Set to <code>true</code> if you want a context XML descriptor
        embedded inside the application (located at
        <code>/META-INF/context.xml</code>) to be copied to <code>xmlBase</code>
        when the application is deployed. On subsequent starts, the copied
        context XML descriptor will be used in preference to any context XML
        descriptor embedded inside the application even if the descriptor
        embedded inside the application is more recent. The flag's value
        defaults to <code>false</code>.  Note if <strong>deployXML</strong>
        is <code>false</code>, this attribute will have no effect.</p>
      </attribute>
        <p>Set to <code>false</code> if you want to disable parsing the context
        XML descriptor embedded inside the application (located at
        <code>/META-INF/context.xml</code>). Security conscious environments
        should set this to <code>false</code> to prevent applications from
        interacting with the container's configuration. The  administrator will
        then be responsible for providing an external context configuration
        file, and putting it in the location defined by the
        <strong>xmlBase</strong> attribute. The flag's value defaults to
        <code>true</code>.</p>
        from a WAR file. WAR files located outside of the Host's
        <strong>appBase</strong> will not be expanded. See
       <code>org.apache.catalina.core.ContainerBase.[engine_name].[host_name]</code>
    <li>Any XML file in the Host's <code>xmlBase</code> directory (by
        default <code>$CATALINA_BASE/conf/[engine_name]/[host_name]</code>) is
        assumed to be a context XML descriptor containing a
        sub-elements) for a single web application. The web applications
        associated with each of these context XML descriptor files will be
        deployed first.<br/>
        The <code>docBase</code> attribute of this <code>&lt;Context&gt;</code>
        element must only be set if the docBase is outside the Host's
        <code>appBase</code>. For web applications located inside the Host's
        <code>appBase</code>, the <code>docBase</code> will be the name of the
        XML file with ".xml" replaced with ".war" for a web application archive
        or the name of the XML file with ".xml" removed for a directory.<br/>
        The <code>path</code> attribute must not be set. The context path used
        will be a slash character ("/") followed by the name of the XML file
        (less the .xml extension). Multi-level context paths may be defined
        using #, e.g. <code>foo#bar.xml</code> for a context path of
        <code>/foo/bar</code>. The default web application that has a context
        path of <code>/</code> may be defined by using a file called
        <code>ROOT.xml</code>.</li>
    <li>Any web application archive file within the Host's <code>appBase</code>
        directory that has not already been deployed as a result of a context
        XML descriptor and does not have a corresponding directory of the same
        name (without the ".war" extension) will be deployed next. The context
        path used will be a slash character ("/") followed by the web
        application archive name less the ".war" extension. The one exception to
        this rule is that a web application archive named "ROOT.war" will be
        deployed with a context path of <code>/</code>. Multi-level contexts may
        be defined by using #, e.g. use a WAR named <code>foo#bar.war</code> for
        a context path of <code>/foo/bar</code>.<br/>
        If the <code>unpackWARs</code> attribute is <code>true</code>, the web
        application archive file will be expanded to a directory of the same
        name (without the ".war" extension".<br/>
        Note: If you re-deploy an updated WAR file while Tomcat is stopped, be
        sure to delete the associated expanded directory before restarting 
        Tomcat, so that the updated WAR file will be re-expanded when Tomcat
        restarts.<br/>
        If <code>copyXml</code> is <code>true</code> (it is <code>false</code>
        by default), any web application archive file within the Hosts's
        <code>appBase</code> directory that does not have a corresponding
        context XML descriptor (with a ".xml" extension rather than a ".war"
        extension) in the Host's <code>xmlBase</code> will be scanned to see
        if it contains a context XML descriptor (located at
        <code>/META-INF/context.xml</code>) and if one is found the descriptor
        will be copied to the <code>xmlBase</code> directory and renamed.
        </li>
    <li>Finally, any sub-directory within the Host's <code>appBase</code> that
        has not already been deployed as a result of a context XML descriptor
        will be deployed next. The context path used will be a slash character
        ("/") followed by the directory name, unless the directory name is ROOT,
        in which case the context path will <code>/</code>. Multi-level contexts
        may be defined by using #, e.g. use a directory named
        <code>foo#bar</code> for a context path of <code>/foo/bar</code>.<br/>
        If <code>copyXml</code> is <code>true</code> (it is <code>false</code>
        by default), any directory within the Hosts's <code>appBase</code>
        directory that does not have a corresponding context XML descriptor in
        the Host's <code>xmlBase</code> will be scanned to see if it contains
        a context XML descriptor (located at <code>/META-INF/context.xml</code>)
        and if one is found the descriptor will be copied to the
        <code>xmlBase</code> directory and renamed.
        </li>
    sub-directories that are dropped in to the <code>appBase</code> (or 
    <code>xmlBase</code> in the case of an XML configuration file) directory
    while Tomcat is running will be automatically deployed, according to the
    rules described above. The  auto deployer will also track web applications
    for the following changes:
    <p>Finally, note that if you are defining contexts explicitly in server.xml,
    you should probably turn off automatic application deployment.  Otherwise,
    the web applications will each be deployed twice each, and that may cause
    problems for the applications.

======= fc66705:"java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java"

        sender.sendMessage(destination,message);
======= fc66705:"java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java"

            } catch (ChannelException x) {
                sender.disconnect();
                throw x;
                if (!connected) disconnect();

======= 9113574:"java/org/apache/jasper/runtime/JspWriterImpl.java"

    private static int min(int a, int b) {

======= f1760d8:"java/org/apache/naming/resources/FileDirContext.java"

     * This specialized resource implementation avoids opening the InputStream
======= f1760d8:"java/org/apache/naming/resources/FileDirContext.java"

                FileInputStream fis = new FileInputStream(file);
                inputStream = fis;
                return fis;
======= f1760d8:"java/org/apache/naming/resources/WARDirContext.java"

                    InputStream is = base.getInputStream(entry);
                    inputStream = is;
                    return is;

======= 6ac5036:"java/org/apache/jasper/JspCompilationContext.java"

            } else {
                // May not be in a JAR in some IDE environments
                result = context.getResource(canonicalURI(res));

======= 4cf35b8:"java/org/apache/catalina/realm/JNDIRealm.java"

        list.addAll(groupMap.values());
        return list;

======= 1ec5ca7:"java/org/apache/catalina/core/StandardHostValve.java"

            if (response.isCommitted()) {
                // Response is committed - including the error page is the
                // best we can do 
                rd.include(request.getRequest(), response.getResponse());
            } else {
                // Reset the response (keeping the real error code and message)
                response.resetBuffer(true);
                rd.forward(request.getRequest(), response.getResponse());
                // If we forward, the response is suspended again
                response.setSuspended(false);
            }

======= 7301a10:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        return ctxt.getServletContext();

======= 9e55819:"java/org/apache/jasper/security/SecurityClassLoad.java"

            // Trigger loading of class and reading of property
            SecurityUtil.isPackageProtectionEnabled();
            

======= 789ac1e:"java/org/apache/jasper/compiler/JavacErrorDetail.java"

                if (jspLines.length < jspBeginLineNum) {
                    // Avoid ArrayIndexOutOfBoundsException
                    // Probably bug 48494 but could be some other cause
                    jspExtract = Localizer.getMessage("jsp.error.bug48494");
                    return;
                }
                

  <!--                       contextXsltFile and globalXsltFile[null]       -->
  <!--                                                                      -->
  <!--   contextXsltFile     Make directory listings an XML doc and         -->
  <!--                       pass the result to this style sheet which is   -->
  <!--                       relative to the context root. This overrides   -->
  <!--                       globalXsltFile[null]                           -->
======= 0e595cf:"java/org/apache/catalina/servlets/DefaultServlet.java"

    protected String localXsltFile = null;
     * Allow customized directory listing per context.
     */
    protected String contextXsltFile = null;
    
    
    /**
    protected String globalXsltFile = null;
======= 0e595cf:"java/org/apache/catalina/servlets/DefaultServlet.java"

        contextXsltFile = getServletConfig().getInitParameter("contextXsltFile");
======= 0e595cf:"java/org/apache/catalina/servlets/DefaultServlet.java"

                if ((cacheEntry.name + trimmed).equals(contextXsltFile))
                    continue;
======= 0e595cf:"java/org/apache/catalina/servlets/DefaultServlet.java"

        if (contextXsltFile != null) {
            InputStream is =
                getServletContext().getResourceAsStream(contextXsltFile);
            if (is != null)
                return is;
            if (debug > 10)
                log("contextXsltFile '" + contextXsltFile + "' not found");
        }
        This can be overridden per context and/or per directory. See
        <strong>contextXsltFile</strong> and <strong>localXsltFile</strong>
        below. The format of the xml is shown below.
    </td>
  </tr>
  <tr>
    <th valign='top'>contextXsltFile</th>
    <td valign='top'>
        You may also customize your directory listing by context by
        configuring <code>contextXsltFile</code>. This should be a context
        relative path (e.g.: <code>/path/to/context.xslt</code>). This
        overrides <code>globalXsltFile</code>. If this value is present but a
        file does not exist, then <code>globalXsltFile</code> will be used. If
        <code>globalXsltFile</code> does not exist, then the default
        directory listing will be shown.
        This overrides <code>globalXsltFile</code> and
        <code>contextXsltFile</code>. If this value is present but a file
        does not exist, then <code>contextXsltFile</code> will be used. If
        <code>contextXsltFile</code> does not exist, then

======= 563e315:"java/org/apache/jasper/JspC.java"

======= 563e315:"java/org/apache/jasper/JspC.java"

    protected static final Set<String> insertBefore = new HashSet<String>();
    
    static {
        insertBefore.add("</web-app>");
        insertBefore.add("<servlet-mapping>");
        insertBefore.add("<session-config>");
        insertBefore.add("<mime-mapping>");
        insertBefore.add("<welcome-file-list>");
        insertBefore.add("<error-page>");
        insertBefore.add("<taglib>");
        insertBefore.add("<resource-env-ref>");
        insertBefore.add("<resource-ref>");
        insertBefore.add("<security-constraint>");
        insertBefore.add("<login-config>");
        insertBefore.add("<security-role>");
        insertBefore.add("<env-entry>");
        insertBefore.add("<ejb-ref>");
        insertBefore.add("<ejb-local-ref>");
    }
======= 563e315:"java/org/apache/jasper/JspC.java"

        boolean inserted = false;
        int current = reader.read();
        while (current > -1) {
            if (!inserted && current == '<') {
                String element = getElement(reader);
                if (insertBefore.contains(element)) {
                    // Insert generated content here
                    writer.println(insertStartMarker);
                    while (true) {
                        String line = fragmentReader.readLine();
                            writer.println();
                            break;
                        writer.println(line);
                    }
                    writer.println(insertEndMarker);
                    writer.println();
                    writer.write(element);
                } else if (element.contains(insertStartMarker)) {
                    // Skip the previous auto-generated content
                    while (!element.contains(insertEndMarker)) {
                        element = getElement(reader);
                } else {
                    writer.write(element);
                writer.write(current);
            current = reader.read();
======= 563e315:"java/org/apache/jasper/JspC.java"

    
    /*
     * Assumes valid xml
     */
    private String getElement(Reader reader) throws IOException {
        StringBuilder result = new StringBuilder();
        result.append('<');
        
        boolean done = false;
        
        while (!done) {
            int current = reader.read();
            while (current != '>') {
                result.append((char) current);
                current = reader.read();
            }
            result.append((char) current);
            
            int len = result.length();
            if (len > 7 && result.substring(0, 4).equals("<!--")) {
                // This is a comment - make sure we are at the end
                if (result.substring(len - 3, len).equals("-->")) {
                    done = true;
                }
            } else {
                done = true;
            }
        }
        
        
        return result.toString();
    }

======= da42e44:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if (!cacheEntry.exists) {
        	// File is in directory listing but doesn't appear to exist
        	// Broken symlink or odd permission settings?
        	return;
        }

======= 53e0674:"java/org/apache/catalina/ant/AbstractCatalinaTask.java"

                    
                    hconn.setFixedLengthStreamingMode(contentLength);
======= 53e0674:"java/org/apache/catalina/ant/DeployTask.java"

                    FileInputStream fsInput = new FileInputStream(war);
                    long size = fsInput.getChannel().size();
                    if (size > Integer.MAX_VALUE)
                        throw new UnsupportedOperationException(
                                "DeployTask does not support WAR files " +
                                "greater than 2 Gb");
                    contentLength = (int) size;
                    stream = new BufferedInputStream(fsInput, 1024);

======= c09753b:"java/javax/servlet/jsp/JspFactory.java"

    private static volatile JspFactory deflt = null;
======= c09753b:"java/javax/servlet/jsp/JspFactory.java"

    public static void setDefaultFactory(JspFactory deflt) {
======= c09753b:"java/javax/servlet/jsp/JspFactory.java"

    public static JspFactory getDefaultFactory() {

======= dda2cbc:"java/org/apache/catalina/loader/WebappClassLoader.java"

            try {
                if (!openJARs()) {
                    return null;
                }
                for (i = 0; (entry == null) && (i < jarFilesLength); i++) {
    
                    jarEntry = jarFiles[i].getJarEntry(path);
    
                    if (jarEntry != null) {
    
                        entry = new ResourceEntry();
                        try {
                            entry.codeBase = getURL(jarRealFiles[i], false);
                            String jarFakeUrl = getURI(jarRealFiles[i]).toString();
                            jarFakeUrl = "jar:" + jarFakeUrl + "!/" + path;
                            entry.source = new URL(jarFakeUrl);
                            entry.lastModified = jarRealFiles[i].lastModified();
                        } catch (MalformedURLException e) {
                            return null;
                        }
                        contentLength = (int) jarEntry.getSize();
                        try {
                            entry.manifest = jarFiles[i].getManifest();
                            binaryStream = jarFiles[i].getInputStream(jarEntry);
                        } catch (IOException e) {
                            return null;
                        }
    
                        // Extract resources contained in JAR to the workdir
                        if (antiJARLocking && !(path.endsWith(".class"))) {
                            byte[] buf = new byte[1024];
                            File resourceFile = new File
                                (loaderDir, jarEntry.getName());
                            if (!resourceFile.exists()) {
                                Enumeration<JarEntry> entries =
                                    jarFiles[i].entries();
                                while (entries.hasMoreElements()) {
                                    JarEntry jarEntry2 =  entries.nextElement();
                                    if (!(jarEntry2.isDirectory()) 
                                        && (!jarEntry2.getName().endsWith
                                            (".class"))) {
                                        resourceFile = new File
                                            (loaderDir, jarEntry2.getName());
                                            if (!resourceFile.getCanonicalPath().startsWith(
                                                    canonicalLoaderDir)) {
                                                throw new IllegalArgumentException(
                                                        sm.getString("webappClassLoader.illegalJarPath",
                                                    jarEntry2.getName()));
                                        } catch (IOException ioe) {
                                            throw new IllegalArgumentException(
                                                    sm.getString("webappClassLoader.validationErrorJarPath",
                                                            jarEntry2.getName()), ioe);
                                        }                                 
                                        resourceFile.getParentFile().mkdirs();
                                        FileOutputStream os = null;
                                        InputStream is = null;
                                            is = jarFiles[i].getInputStream
                                                (jarEntry2);
                                            os = new FileOutputStream
                                                (resourceFile);
                                            while (true) {
                                                int n = is.read(buf);
                                                if (n <= 0) {
                                                    break;
                                                }
                                                os.write(buf, 0, n);
                                            // Ignore
                                        } finally {
                                            try {
                                                if (is != null) {
                                                    is.close();
                                                }
                                            } catch (IOException e) {
                                            }
                                            try {
                                                if (os != null) {
                                                    os.close();
                                                }
                                            } catch (IOException e) {
                                            }
    
    
    
                if (entry == null) {
                    synchronized (notFoundResources) {
                        notFoundResources.put(name, name);
    
                if (binaryStream != null) {
    
                    byte[] binaryContent = new byte[contentLength];
    
                    int pos = 0;
    
                        while (true) {
                            int n = binaryStream.read(binaryContent, pos,
                                                      binaryContent.length - pos);
                            if (n <= 0)
                                break;
                            pos += n;
                        }
                    } catch (IOException e) {
                        log.error(sm.getString("webappClassLoader.readError", name), e);
                    if (fileNeedConvert) {
                        // Workaround for certain files on platforms that use
                        // EBCDIC encoding, when they are read through FileInputStream.
                        // See commit message of rev.303915 for details
                        // http://svn.apache.org/viewvc?view=revision&revision=303915
                        String str = new String(binaryContent,0,pos);
                        try {
                            binaryContent = str.getBytes("UTF-8");
                        } catch (Exception e) {
                            return null;
                        }
                    }
                    entry.binaryContent = binaryContent;
    
                    // The certificates are only available after the JarEntry 
                    // associated input stream has been fully read
                    if (jarEntry != null) {
                        entry.certificates = jarEntry.getCertificates();
                    }
    
            } finally {
                if (binaryStream != null) {
                    try {
                        binaryStream.close();
                    } catch (IOException e) { /* Ignore */}

======= 9905155:"java/org/apache/catalina/valves/RemoteIpValve.java"

 *   className="org.apache.catalina.valves.RemoteIpValve"
======= 9905155:"java/org/apache/catalina/valves/RemoteIpValve.java"

 *   className="org.apache.catalina.valves.RemoteIpValve"
======= 9905155:"java/org/apache/catalina/valves/RemoteIpValve.java"

 *   className="org.apache.catalina.valves.RemoteIpValve"
======= 9905155:"java/org/apache/catalina/valves/RemoteIpValve.java"

 *   className="org.apache.catalina.valves.RemoteIpValve"
======= 9905155:"java/org/apache/catalina/valves/RemoteIpValve.java"

    private static final String info = "org.apache.catalina.valves.RemoteIpValve/1.0";

======= 6f48cde:"java/org/apache/catalina/session/FileStore.java"

        BufferedInputStream bis = null;
            bis = new BufferedInputStream(fis);
======= 6f48cde:"java/org/apache/catalina/session/FileStore.java"

            if (bis != null) {
                    bis.close();
                } catch (IOException f) {
                    // Ignore
                }
            }
            if (fis != null) {
                try {
                    fis.close();
======= 6f48cde:"java/org/apache/catalina/session/FileStore.java"

            try {
                ois.close();
            } catch (IOException f) {
                // Ignore
======= 6f48cde:"java/org/apache/catalina/session/FileStore.java"

            if (fos != null) {
                    fos.close();
======= 6f48cde:"java/org/apache/catalina/session/StandardManager.java"

        BufferedInputStream bis = null;
            bis = new BufferedInputStream(fis);
======= 6f48cde:"java/org/apache/catalina/session/StandardManager.java"

            if (fis != null) {
                    fis.close();
                } catch (IOException f) {
                    // Ignore
                }
            }
            if (bis != null) {
                try {
                    bis.close();
======= 6f48cde:"java/org/apache/catalina/session/StandardManager.java"

                try {
                    ois.close();
                } catch (IOException f) {
                    // Ignore
                try {
                    ois.close();
                } catch (IOException f) {
                    // Ignore
                    ois.close();
======= 6f48cde:"java/org/apache/catalina/session/StandardManager.java"

            if (fos != null) {
                    fos.close();
======= 6f48cde:"java/org/apache/catalina/session/StandardManager.java"

                try {
                    oos.close();
                } catch (IOException f) {
                    // Ignore
======= 6f48cde:"java/org/apache/catalina/session/StandardManager.java"

        } finally {
            try {
                oos.close();
            } catch (IOException f) {
                // Ignore

======= 067e0ba:"java/org/apache/catalina/startup/Catalina.java"

======= 067e0ba:"java/org/apache/catalina/startup/Catalina.java"

======= 067e0ba:"java/org/apache/catalina/startup/Catalina.java"

======= 067e0ba:"java/org/apache/catalina/startup/Catalina.java"

        if( getServer() == null ) {
======= 067e0ba:"java/org/apache/catalina/startup/Catalina.java"

            if (getServer().getPort()>0) { 
                Socket socket = new Socket(getServer().getAddress(),
                        getServer().getPort());
                String shutdown = getServer().getShutdown();
======= 067e0ba:"java/org/apache/catalina/startup/Catalina.java"

        if (getServer() instanceof Lifecycle) {
                getServer().initialize();
======= 067e0ba:"java/org/apache/catalina/startup/Catalina.java"

        if (getServer() == null) {
        if (getServer() == null) {
======= 067e0ba:"java/org/apache/catalina/startup/Catalina.java"

        if (getServer() instanceof Lifecycle) {
                ((Lifecycle) getServer()).start();
======= 067e0ba:"java/org/apache/catalina/startup/Catalina.java"

        if (getServer() instanceof Lifecycle) {
                ((Lifecycle) getServer()).stop();
======= 067e0ba:"java/org/apache/catalina/startup/Catalina.java"

        getServer().await();
======= 067e0ba:"java/org/apache/catalina/startup/Catalina.java"

            if (getServer() != null) {

======= c85e791:"java/org/apache/catalina/deploy/WebXml.java"

======= c85e791:"java/org/apache/catalina/deploy/WebXml.java"

        for (Entry<String, String> entry : contextParams.entrySet()) {
            context.addParameter(entry.getKey(), entry.getValue());
======= c85e791:"java/org/apache/catalina/deploy/WebXml.java"

        for (Entry<String, String> entry : localeEncodingMappings.entrySet()) {
            context.addLocaleEncodingMappingParameter(entry.getKey(),
                    entry.getValue());
======= c85e791:"java/org/apache/catalina/deploy/WebXml.java"

        for (Entry<String, String> entry : mimeMappings.entrySet()) {
            context.addMimeMapping(entry.getKey(), entry.getValue());
======= c85e791:"java/org/apache/catalina/deploy/WebXml.java"

            for (Entry<String, String> entry : params.entrySet()) {
                wrapper.addInitParameter(entry.getKey(), entry.getValue());
======= c85e791:"java/org/apache/catalina/deploy/WebXml.java"

        for (Entry<String, String> entry : servletMappings.entrySet()) {
            context.addServletMapping(entry.getKey(), entry.getValue());
======= c85e791:"java/org/apache/catalina/deploy/WebXml.java"

        for (Entry<String, String> entry : taglibs.entrySet()) {
            context.addTaglib(entry.getKey(), entry.getValue());
======= c85e791:"java/org/apache/catalina/deploy/WebXml.java"

        for (Entry<String, T> entry : fragmentMap.entrySet()) {
            final String key = entry.getKey();
                T value = entry.getValue();
======= c85e791:"java/org/apache/catalina/deploy/WebXml.java"

                    for (Entry<String, WebXml> entry : fragments.entrySet()) {
                        if (!requestedOrder.contains(entry.getKey())) {
                            WebXml fragment = entry.getValue();
======= c85e791:"java/org/apache/tomcat/util/buf/StringCache.java"

======= c85e791:"java/org/apache/tomcat/util/buf/StringCache.java"

                        for (Entry<ByteEntry, int[]> item : bcStats.entrySet()) {
                            ByteEntry entry = item.getKey();
                            int[] countA = item.getValue();
======= c85e791:"java/org/apache/tomcat/util/buf/StringCache.java"

                        for (Entry<CharEntry, int[]> item : ccStats.entrySet()) {
                            CharEntry entry = item.getKey();
                            int[] countA = item.getValue();

======= 1789bd8:"java/org/apache/catalina/valves/RemoteIpValve.java"

======= 1789bd8:"java/org/apache/catalina/valves/RemoteIpValve.java"

 * <td>httpServerPort</td>
 * <td>Value returned by {@link ServletRequest#getServerPort()} when the <code>protocolHeader</code> indicates <code>http</code> protocol</td>
 * <td>N/A</td>
 * <td>integer</td>
 * <td>80</td>
 * </tr>
 * <tr>
 * <td>httpsServerPort</td>
 * <td>Value returned by {@link ServletRequest#getServerPort()} when the <code>protocolHeader</code> indicates <code>https</code> protocol</td>
 * <td>N/A</td>
 * <td>integer</td>
 * <td>443</td>
 * </tr>
======= 1789bd8:"java/org/apache/catalina/valves/RemoteIpValve.java"

     * @see #setHttpServerPort(int)
     */
    private int httpServerPort = 80;
    
    /**
======= 1789bd8:"java/org/apache/catalina/valves/RemoteIpValve.java"

    public int getHttpServerPort() {
        return httpServerPort;
    }
    
======= 1789bd8:"java/org/apache/catalina/valves/RemoteIpValve.java"

======= 1789bd8:"java/org/apache/catalina/valves/RemoteIpValve.java"

                if (protocolHeaderValue == null) {
                    // don't modify the secure,scheme and serverPort attributes
                    // of the request
                } else if (protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) {
                } else {
                    request.setSecure(false);
                    // use request.coyoteRequest.scheme instead of request.setScheme() because request.setScheme() is no-op in Tomcat 6.0
                    request.getCoyoteRequest().scheme().setString("http");
                    
                    request.setServerPort(httpServerPort);
======= 1789bd8:"java/org/apache/catalina/valves/RemoteIpValve.java"

     * Server Port value if the {@link #protocolHeader} is not <code>null</code> and does not indicate HTTP
     * </p>
     * <p>
     * Default value : 80
     * </p>
     */
    public void setHttpServerPort(int httpServerPort) {
        this.httpServerPort = httpServerPort;
    }
    
    /**
     * <p>
    <attribute name="httpServerPort"
               description="Value returned by ServletRequest.getServerPort() when the protocolHeader indicates http protocol"
               type="java.lang.String"
               writeable="false" />
    
    <attribute name="httpsServerPort"
               description="Value returned by ServletRequest.getServerPort() when the protocolHeader indicates https protocol"
               type="java.lang.String"
               writeable="false" />
    
    <attribute name="remoteIpHeader"
======= 1789bd8:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

        private String scheme;
        private boolean secure;
        private int serverPort;
======= 1789bd8:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

        public String getScheme() {
            return scheme;
        }
        public int getServerPort() {
            return serverPort;
        }
        public boolean isSecure() {
            return secure;
        }
        
            this.scheme = request.getScheme();
            this.secure = request.isSecure();
            this.serverPort = request.getServerPort();
======= 1789bd8:"test/org/apache/catalina/valves/TestRemoteIpValve.java"

    public void testInvokeXforwardedProtoSaysHttpsForIncomingHttpRequest() throws Exception {
        
        // PREPARE
        RemoteIpValve remoteIpValve = new RemoteIpValve();
        remoteIpValve.setRemoteIpHeader("x-forwarded-for");
        remoteIpValve.setProtocolHeader("x-forwarded-proto");
        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();
        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);
        
        Request request = new Request();
        request.setCoyoteRequest(new org.apache.coyote.Request());
        // client ip
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("192.168.0.10");
        request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-for").setString("140.211.11.130");
        // protocol
        request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-proto").setString("https");
        request.setSecure(false);
        request.setServerPort(8080);
        request.getCoyoteRequest().scheme().setString("http");
        
        // TEST
        remoteIpValve.invoke(request, null);
        
        // VERIFY
        // client ip
        String actualXForwardedFor = request.getHeader("x-forwarded-for");
        assertNull("no intermediate non-trusted proxy, x-forwarded-for must be null", actualXForwardedFor);
        
        String actualXForwardedBy = request.getHeader("x-forwarded-by");
        assertNull("no intermediate trusted proxy", actualXForwardedBy);
        
        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        
        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
        
        String actualPostInvokeRemoteAddr = request.getRemoteAddr();
        assertEquals("postInvoke remoteAddr", "192.168.0.10", actualPostInvokeRemoteAddr);
        
        String actualPostInvokeRemoteHost = request.getRemoteHost();
        assertEquals("postInvoke remoteAddr", "192.168.0.10", actualPostInvokeRemoteHost);
        
        // protocol
        String actualScheme = remoteAddrAndHostTrackerValve.getScheme();
        assertEquals("x-forwarded-proto says https", "https", actualScheme);
        
        int actualServerPort = remoteAddrAndHostTrackerValve.getServerPort();
        assertEquals("x-forwarded-proto says https", 443, actualServerPort);
        
        boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure();
        assertEquals("x-forwarded-proto says https", true, actualSecure);
        boolean actualPostInvokeSecure = request.isSecure();
        assertEquals("postInvoke secure", false, actualPostInvokeSecure);
        int actualPostInvokeServerPort = request.getServerPort();
        assertEquals("postInvoke serverPort", 8080, actualPostInvokeServerPort);
        String actualPostInvokeScheme = request.getScheme();
        assertEquals("postInvoke scheme", "http", actualPostInvokeScheme);
    }
    
    public void testInvokeXforwardedProtoIsNullForIncomingHttpRequest() throws Exception {
        
        // PREPARE
        RemoteIpValve remoteIpValve = new RemoteIpValve();
        remoteIpValve.setRemoteIpHeader("x-forwarded-for");
        remoteIpValve.setProtocolHeader("x-forwarded-proto");
        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();
        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);
        
        Request request = new Request();
        request.setCoyoteRequest(new org.apache.coyote.Request());
        // client ip
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("192.168.0.10");
        request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-for").setString("140.211.11.130");
        // protocol
        // null "x-forwarded-proto"
        request.setSecure(false);
        request.setServerPort(8080);
        request.getCoyoteRequest().scheme().setString("http");
        
        // TEST
        remoteIpValve.invoke(request, null);
        
        // VERIFY
        // client ip
        String actualXForwardedFor = request.getHeader("x-forwarded-for");
        assertNull("no intermediate non-trusted proxy, x-forwarded-for must be null", actualXForwardedFor);
        
        String actualXForwardedBy = request.getHeader("x-forwarded-by");
        assertNull("no intermediate trusted proxy", actualXForwardedBy);
        
        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        
        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
        
        String actualPostInvokeRemoteAddr = request.getRemoteAddr();
        assertEquals("postInvoke remoteAddr", "192.168.0.10", actualPostInvokeRemoteAddr);
        
        String actualPostInvokeRemoteHost = request.getRemoteHost();
        assertEquals("postInvoke remoteAddr", "192.168.0.10", actualPostInvokeRemoteHost);
        
        // protocol
        String actualScheme = remoteAddrAndHostTrackerValve.getScheme();
        assertEquals("x-forwarded-proto is null", "http", actualScheme);
        
        int actualServerPort = remoteAddrAndHostTrackerValve.getServerPort();
        assertEquals("x-forwarded-proto is null", 8080, actualServerPort);
        
        boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure();
        assertEquals("x-forwarded-proto is null", false, actualSecure);
        boolean actualPostInvokeSecure = request.isSecure();
        assertEquals("postInvoke secure", false, actualPostInvokeSecure);
        int actualPostInvokeServerPort = request.getServerPort();
        assertEquals("postInvoke serverPort", 8080, actualPostInvokeServerPort);
        String actualPostInvokeScheme = request.getScheme();
        assertEquals("postInvoke scheme", "http", actualPostInvokeScheme);
    }
    
    public void testInvokeXforwardedProtoSaysHttpForIncomingHttpsRequest() throws Exception {
        
        // PREPARE
        RemoteIpValve remoteIpValve = new RemoteIpValve();
        remoteIpValve.setRemoteIpHeader("x-forwarded-for");
        remoteIpValve.setProtocolHeader("x-forwarded-proto");
        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();
        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);
        
        Request request = new Request();
        request.setCoyoteRequest(new org.apache.coyote.Request());
        // client ip
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("192.168.0.10");
        request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-for").setString("140.211.11.130");
        // protocol
        request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-proto").setString("http");
        request.setSecure(true);
        request.setServerPort(8443);
        request.getCoyoteRequest().scheme().setString("https");
        
        // TEST
        remoteIpValve.invoke(request, null);
        
        // VERIFY
        // client ip
        String actualXForwardedFor = request.getHeader("x-forwarded-for");
        assertNull("no intermediate non-trusted proxy, x-forwarded-for must be null", actualXForwardedFor);
        
        String actualXForwardedBy = request.getHeader("x-forwarded-by");
        assertNull("no intermediate trusted proxy", actualXForwardedBy);
        
        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        
        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
        
        String actualPostInvokeRemoteAddr = request.getRemoteAddr();
        assertEquals("postInvoke remoteAddr", "192.168.0.10", actualPostInvokeRemoteAddr);
        
        String actualPostInvokeRemoteHost = request.getRemoteHost();
        assertEquals("postInvoke remoteAddr", "192.168.0.10", actualPostInvokeRemoteHost);
        
        // protocol
        String actualScheme = remoteAddrAndHostTrackerValve.getScheme();
        assertEquals("x-forwarded-proto says http", "http", actualScheme);
        
        int actualServerPort = remoteAddrAndHostTrackerValve.getServerPort();
        assertEquals("x-forwarded-proto says http", 80, actualServerPort);
        
        boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure();
        assertEquals("x-forwarded-proto says http", false, actualSecure);
        boolean actualPostInvokeSecure = request.isSecure();
        assertEquals("postInvoke secure", true, actualPostInvokeSecure);
        int actualPostInvokeServerPort = request.getServerPort();
        assertEquals("postInvoke serverPort", 8443, actualPostInvokeServerPort);
        String actualPostInvokeScheme = request.getScheme();
        assertEquals("postInvoke scheme", "https", actualPostInvokeScheme);
    }
    
    public void testInvokeXforwardedProtoIsNullForIncomingHttpsRequest() throws Exception {
        
        // PREPARE
        RemoteIpValve remoteIpValve = new RemoteIpValve();
        remoteIpValve.setRemoteIpHeader("x-forwarded-for");
        remoteIpValve.setProtocolHeader("x-forwarded-proto");
        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();
        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);
        
        Request request = new Request();
        request.setCoyoteRequest(new org.apache.coyote.Request());
        // client ip
        request.setRemoteAddr("192.168.0.10");
        request.setRemoteHost("192.168.0.10");
        request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-for").setString("140.211.11.130");
        // protocol
        // Don't declare "x-forwarded-proto"
        request.setSecure(true);
        request.setServerPort(8443);
        request.getCoyoteRequest().scheme().setString("https");
        
        // TEST
        remoteIpValve.invoke(request, null);
        
        // VERIFY
        // client ip
        String actualXForwardedFor = request.getHeader("x-forwarded-for");
        assertNull("no intermediate non-trusted proxy, x-forwarded-for must be null", actualXForwardedFor);
        
        String actualXForwardedBy = request.getHeader("x-forwarded-by");
        assertNull("no intermediate trusted proxy", actualXForwardedBy);
        
        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();
        assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr);
        
        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();
        assertEquals("remoteHost", "140.211.11.130", actualRemoteHost);
        
        String actualPostInvokeRemoteAddr = request.getRemoteAddr();
        assertEquals("postInvoke remoteAddr", "192.168.0.10", actualPostInvokeRemoteAddr);
        
        String actualPostInvokeRemoteHost = request.getRemoteHost();
        assertEquals("postInvoke remoteAddr", "192.168.0.10", actualPostInvokeRemoteHost);
        
        // protocol
        String actualScheme = remoteAddrAndHostTrackerValve.getScheme();
        assertEquals("x-forwarded-proto is null", "https", actualScheme);
        
        int actualServerPort = remoteAddrAndHostTrackerValve.getServerPort();
        assertEquals("x-forwarded-proto is null", 8443, actualServerPort);
        
        boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure();
        assertEquals("x-forwarded-proto is null", true, actualSecure);
        boolean actualPostInvokeSecure = request.isSecure();
        assertEquals("postInvoke secure", true, actualPostInvokeSecure);
        int actualPostInvokeServerPort = request.getServerPort();
        assertEquals("postInvoke serverPort", 8443, actualPostInvokeServerPort);
        String actualPostInvokeScheme = request.getScheme();
        assertEquals("postInvoke scheme", "https", actualPostInvokeScheme);
    }
    
    (http/https), server port and <code>request.secure</code> with the scheme presented 
    by a proxy or a load balancer via a request header 
    (e.g. &quot;X-Forwarded-Proto&quot;).</p>
    
      <attribute name="httpServerPort" required="false">
         <p>Value returned by <code>ServletRequest.getServerPort()</code> 
         when the <strong>protocolHeader</strong> indicates <code>http</code> 
         protocol. If not specified, the default of <code>80</code> is
        used.</p>
      </attribute>
      <attribute name="httpsServerPort" required="false">
         <p>Value returned by <code>ServletRequest.getServerPort()</code> 
         when the <strong>protocolHeader</strong> indicates <code>https</code> 
         protocol. If not specified, the default of <code>443</code> is
        used.</p>
      </attribute>
      

======= 7aa1206:"java/org/apache/catalina/filters/RemoteIpFilter.java"

 * <td>httpServerPort</td>
 * <td>Value returned by {@link ServletRequest#getServerPort()} when the <code>protocolHeader</code> indicates <code>http</code> protocol</td>
 * <td>N/A</td>
 * <td>integer</td>
 * <td>80</td>
 * </tr>
 * <tr>
 * <td>httpsServerPort</td>
 * <td>Value returned by {@link ServletRequest#getServerPort()} when the <code>protocolHeader</code> indicates <code>https</code> protocol</td>
 * <td>N/A</td>
 * <td>integer</td>
 * <td>443</td>
 * </tr>
======= 7aa1206:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    protected static final String HTTP_SERVER_PORT_PARAMETER = "httpServerPort";
======= 7aa1206:"java/org/apache/catalina/filters/RemoteIpFilter.java"

     * @see #setHttpServerPort(int)
     */
    private int httpServerPort = 80;
    /**
======= 7aa1206:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                if (protocolHeaderValue == null) {
                    // don't modify the secure,scheme and serverPort attributes of the request
                } else if (protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) {
                } else {
                    xRequest.setSecure(false);
                    xRequest.setScheme("http");
                    xRequest.setServerPort(httpServerPort);
======= 7aa1206:"java/org/apache/catalina/filters/RemoteIpFilter.java"

        if (filterConfig.getInitParameter(HTTP_SERVER_PORT_PARAMETER) != null) {
            try {
                setHttpServerPort(Integer.parseInt(filterConfig.getInitParameter(HTTP_SERVER_PORT_PARAMETER)));
            } catch (NumberFormatException e) {
                throw new NumberFormatException("Illegal " + HTTP_SERVER_PORT_PARAMETER + " : " + e.getMessage());
            }
        }
        
                throw new NumberFormatException("Illegal " + HTTPS_SERVER_PORT_PARAMETER + " : " + e.getMessage());
     * Server Port value if the {@link #protocolHeader} indicates HTTP (i.e. {@link #protocolHeader} is not null and
     * has a value different of {@link #protocolHeaderHttpsValue}). 
     * </p>
     * <p>
     * Default value : 80
     * </p>
     */
    public void setHttpServerPort(int httpServerPort) {
        this.httpServerPort = httpServerPort;
    }
    
    /**
     * <p>
    (http/https), server port and <code>request.secure</code> with the scheme presented 
    by a proxy or a load balancer via a request header 
    (e.g. &quot;X-Forwarded-Proto&quot;).</p>
      <attribute name="httpServerPort" required="false">
         <p>Value returned by <code>ServletRequest.getServerPort()</code> 
         when the <strong>protocolHeader</strong> indicates <code>http</code> 
         protocol. If not specified, the default of <code>80</code> is
        used.</p>
      </attribute>
      <attribute name="httpsServerPort" required="false">
         <p>Value returned by <code>ServletRequest.getServerPort()</code> 
         when the <strong>protocolHeader</strong> indicates <code>https</code> 
         protocol. If not specified, the default of <code>443</code> is
        used.</p>
      </attribute>

======= d0f9da2:"java/org/apache/catalina/util/RequestUtil.java"

        return URLDecode(bytes, enc, false);

======= 62d29b6:"java/org/apache/catalina/realm/JNDIRealm.java"

        if (user != null) {
            return new GenericPrincipal(user.username, user.password,
                    getRoles(context, user));
        }
        
        return null;

======= 13daf69:"java/org/apache/coyote/http11/Http11AprProcessor.java"

            // Always overrides anything the app might set
        } else if (headers.getValue("Server") == null) {
            // If app didn't set the header, use the default
======= 13daf69:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            // Always overrides anything the app might set
        } else if (headers.getValue("Server") == null) {
            // If app didn't set the header, use the default
======= 13daf69:"java/org/apache/coyote/http11/Http11Processor.java"

            // Always overrides anything the app might set
        } else if (headers.getValue("Server") == null) {
            // If app didn't set the header, use the default
      <p>Overrides the Server header for the http response. If set, the value
      for this attribute overrides the Tomcat default and any Server header set
      by a web application. If not set, any value specified by the application
      is used. If the application does not specify a value then
      <code>Apache-Coyote/1.1</code> is used. Unless you are paranoid, you won't
      need this feature.

======= eeb017a:"java/org/apache/juli/ClassLoaderLogManager.java"

    private final class Cleaner extends Thread {
        
        @Override
        public void run() {
            // The JVM us being shutdown. Make sure all loggers for all class
            // loaders are shutdown
            for (ClassLoaderLogInfo clLogInfo : classLoaderLoggers.values()) {
                for (Logger logger : clLogInfo.loggers.values()) {
                    resetLogger(logger);
                }
            }
        }
            
        private void resetLogger(Logger logger) {
            
            Handler[] handlers = logger.getHandlers();
            for (Handler handler : handlers) {
                logger.removeHandler(handler);
                try {
                    handler.close();
                } catch (Exception e) {
                    // Ignore
                }
            }
        }
    }
    
    // ------------------------------------------------------------Constructors
    public ClassLoaderLogManager() {
        super();
        try { 
            Runtime.getRuntime().addShutdownHook(new Cleaner());
        } catch (IllegalStateException ise) {
            // We are probably already being shutdown. Ignore this error.
        }
    }
======= eeb017a:"java/org/apache/juli/ClassLoaderLogManager.java"

======= eeb017a:"java/org/apache/juli/logging/LogFactory.java"

======= eeb017a:"java/org/apache/juli/logging/LogFactory.java"

    public static void release(
            @SuppressWarnings("unused") ClassLoader classLoader) {
        // JULI's log manager looks at the current classLoader
        LogManager.getLogManager().reset();

======= f2eea0c:"java/org/apache/catalina/startup/ContextConfig.java"

                sm.getString("contextConfig.jndiUrlNotDirContextConn", url);

======= 4df1957:"java/javax/el/BeanELResolver.java"

======= 4df1957:"java/javax/el/BeanELResolver.java"

        public @SuppressWarnings("unchecked") Class getPropertyType() {
======= 4df1957:"java/javax/el/ELContext.java"

    // Can't use Class<?> because API needs to match specification
    public Object getContext(@SuppressWarnings("unchecked") Class key) {
    // Can't use Class<?> because API needs to match specification
    public void putContext(@SuppressWarnings("unchecked") Class key,
            Object contextObject) throws NullPointerException {
======= 4df1957:"java/javax/el/ResourceBundleELResolver.java"

    // Can't use Iterator<FeatureDescriptor> because API needs to match specification
    public @SuppressWarnings("unchecked") Iterator getFeatureDescriptors(
            ELContext context, Object base) {
======= 4df1957:"java/org/apache/catalina/loader/WebappClassLoader.java"

            @SuppressWarnings("unchecked") // clearJdbcDriverRegistrations() returns List<String> 
======= 4df1957:"java/org/apache/catalina/loader/WebappClassLoader.java"

        @SuppressWarnings("unchecked") // resourceEntries is HashMap<String, ResourceEntry>
======= 4df1957:"java/org/apache/catalina/loader/WebappClassLoader.java"

    @SuppressWarnings("deprecation") // thread.stop()
======= 4df1957:"java/org/apache/el/lang/ELSupport.java"

            @SuppressWarnings("unchecked") // checked above
            @SuppressWarnings("unchecked") // checked above
======= 4df1957:"java/org/apache/el/lang/EvaluationContext.java"

    // Can't use Class<?> because API needs to match specification in superclass
    public Object getContext(@SuppressWarnings("unchecked") Class key) {
======= 4df1957:"java/org/apache/el/lang/EvaluationContext.java"

    // Can't use Class<?> because API needs to match specification in superclass
    public void putContext(@SuppressWarnings("unchecked") Class key,
            Object contextObject) {
======= 4df1957:"java/org/apache/el/parser/AstIdentifier.java"

    // Interface el.parser.Node uses raw types (and is auto-generated)
    public Object invoke(EvaluationContext ctx,
            @SuppressWarnings("unchecked") Class[] paramTypes,
    // Interface el.parser.Node uses raw types (and is auto-generated)
    public MethodInfo getMethodInfo(EvaluationContext ctx, 
            @SuppressWarnings("unchecked") Class[] paramTypes)
======= 4df1957:"java/org/apache/el/parser/AstValue.java"

    // Interface el.parser.Node uses raw types (and is auto-generated)
    public MethodInfo getMethodInfo(EvaluationContext ctx, 
            @SuppressWarnings("unchecked") Class[] paramTypes)
======= 4df1957:"java/org/apache/el/parser/AstValue.java"

    // Interface el.parser.Node uses a raw type (and is auto-generated)
    public Object invoke(EvaluationContext ctx, 
            @SuppressWarnings("unchecked") Class[] paramTypes,
======= 4df1957:"java/org/apache/el/parser/SimpleNode.java"

    // Interface el.parser.Node uses raw types (and is auto-generated)
    public Object invoke(EvaluationContext ctx, 
            @SuppressWarnings("unchecked") Class[] paramTypes,
    // Interface el.parser.Node uses a raw type (and is auto-generated)
            @SuppressWarnings("unchecked") Class[] paramTypes)
            throws ELException {
======= 4df1957:"java/org/apache/naming/resources/VirtualDirContext.java"

    protected ArrayList<NamingEntry> list(File file) {
        ArrayList<NamingEntry> entries = super.list(file);

======= 11810fb:"test/org/apache/el/TestELEvaluation.java"

======= 11810fb:"test/org/apache/el/TestELEvaluation.java"

    public void testParserFunction() {
        // bug 48112
        assertEquals("{world}", evaluateExpression("${fn:trim('{world}')}"));
    }
======= 11810fb:"test/org/apache/el/TestELEvaluation.java"

        ctx.setFunctionMapper(new FMapper());
    
    public static class FMapper extends FunctionMapper {
        @Override
        public Method resolveFunction(String prefix, String localName) {
            if ("trim".equals(localName)) {
                Method m;
                try {
                    m = this.getClass().getMethod("trim", String.class);
                    return m;
                } catch (SecurityException e) {
                    // Ignore
                } catch (NoSuchMethodException e) {
                    // Ignore
                } 
            }
            return null;
        }
        
        public static String trim(String input) {
            return input.trim();
        }
    }

======= da5f249:"java/org/apache/catalina/connector/Connector.java"

        Object addressObj = getProperty("address");
        StringBuilder sb = new StringBuilder(domain);
        sb.append(":type=");
        sb.append(type);
        sb.append(",port=");
        sb.append(getPort());
        if (addressObj != null) {
            String address = addressObj.toString();
            if (address.length() > 0) {
                sb.append(",address=");
                sb.append(ObjectName.quote(address));
            }
        ObjectName _oname = new ObjectName(sb.toString());
======= da5f249:"java/org/apache/catalina/mbeans/MBeanUtils.java"

            Object addressObj = IntrospectionUtils.getProperty(connector, "address");            
            sb.append(",port=");
            sb.append(port);
            if (addressObj != null) {
                String address = addressObj.toString();
                if (address.length() > 0) {
                    sb.append(",address=");
                    sb.append(ObjectName.quote(address));
                }

======= 3d309a5:"java/org/apache/catalina/connector/CoyoteAdapter.java"

======= 3d309a5:"java/org/apache/catalina/connector/CoyoteAdapter.java"

    
    private static final String POWERED_BY = "Servlet/3.0 JSP/2.2 " +
            "(" + ServerInfo.getServerInfo() + " Java/" +
            System.getProperty("java.vm.vendor") + "/" +
            System.getProperty("java.runtime.version") + ")";
======= 3d309a5:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            response.addHeader("X-Powered-By", POWERED_BY);

======= 9a2ae02:"java/javax/el/ExpressionFactory.java"

======= 9a2ae02:"java/javax/el/ExpressionFactory.java"

    private static final String SERVICE_RESOURCE_NAME =
        "META-INF/services/javax.el.ExpressionFactory";
    private static final String SEP = System.getProperty("file.separator");
    private static final String PROPERTY_FILE =
        System.getProperty("java.home") + "jre" + SEP + "lib" + SEP +
        "el.properties";
    private static final String PROPERTY_NAME = "javax.el.ExpressionFactory";
======= 9a2ae02:"java/javax/el/ExpressionFactory.java"

    /**
     * Create a new {@link ExpressionFactory}. The class to use is determined by
     * the following search order:
     * <ol>
     * <li>services API (META-INF/services/javax.el.ExpressionFactory)</li>
     * <li>$JRE_HOME/lib/el.properties - key javax.el.ExpressionFactory</li>
     * <li>javax.el.ExpressionFactory</li>
     * <li>Platform default implementation -
     *     org.apache.el.ExpressionFactoryImpl</li>
     * </ol>
     * @return
     */
    /**
     * Create a new {@link ExpressionFactory} passing in the provided
     * {@link Properties}. Search order is the same as {@link #newInstance()}.
     * 
     * @param properties
     * @return
     */
        String className = null;
        ExpressionFactory result = null;
        
        ClassLoader tccl = Thread.currentThread().getContextClassLoader();
        // First services API
        className = getClassNameServices(tccl);
        if (className == null) {
            // Second el.properties file
            className = getClassNameJreDir();
        }
        if (className == null) {
            // Third system property 
            className = getClassNameSysProp();
        }
        if (className == null) {
            // Fourth - default
            className = "org.apache.el.ExpressionFactoryImpl";
        }
        
        try {
            Class<?> clazz = null;
            if (tccl == null) {
                clazz = Class.forName(className);
            } else {
                clazz = tccl.loadClass(className);
            }
            Constructor<?> constructor = null;
            // Do we need to look for a constructor that will take properties?
            if (properties != null) {
                try {
                    constructor = clazz.getConstructor(Properties.class);
                } catch (SecurityException se) {
                    throw new ELException(se);
                } catch (NoSuchMethodException nsme) {
                    // This can be ignored
                    // This is OK for this constructor not to exist
                }
            }
            if (constructor == null) {
                result = (ExpressionFactory) clazz.newInstance();
            } else {
                result =
                    (ExpressionFactory) constructor.newInstance(properties);
            }
            
        } catch (ClassNotFoundException e) {
            throw new ELException(
                    "Unable to find ExpressionFactory of type: " + className,
                    e);
        } catch (InstantiationException e) {
            throw new ELException(
                    "Unable to create ExpressionFactory of type: " + className,
                    e);
        } catch (IllegalAccessException e) {
            throw new ELException(
                    "Unable to create ExpressionFactory of type: " + className,
                    e);
        } catch (IllegalArgumentException e) {
            throw new ELException(
                    "Unable to create ExpressionFactory of type: " + className,
                    e);
        } catch (InvocationTargetException e) {
            throw new ELException(
                    "Unable to create ExpressionFactory of type: " + className,
                    e);
        }
        
        return result;
    }
    
    private static String getClassNameServices(ClassLoader tccl) {
        InputStream is = null;
        
        if (tccl == null) {
            is = ClassLoader.getSystemResourceAsStream(SERVICE_RESOURCE_NAME);
        } else {
            is = tccl.getResourceAsStream(SERVICE_RESOURCE_NAME);
        }
        if (is != null) {
            String line = null;
            try {
                BufferedReader br =
                    new BufferedReader(new InputStreamReader(is, "UTF-8"));
                line = br.readLine();
                if (line != null && line.trim().length() > 0) {
                    return line.trim();
                }
            } catch (UnsupportedEncodingException e) {
                // Should never happen with UTF-8
                // If it does - ignore & return null
            } catch (IOException e) {
                throw new ELException("Failed to read " + SERVICE_RESOURCE_NAME,
                        e);
            } finally {
                try {
                    is.close();
                } catch (IOException ioe) {
                    // Ignore
                }
            }
        }
        
        return null;
    }
    
    private static String getClassNameJreDir() {
        File file = new File(PROPERTY_FILE);
        if (file.canRead()) {
            InputStream is = null;
            try {
                is = new FileInputStream(file);
                Properties props = new Properties();
                props.load(is);
                String value = props.getProperty(PROPERTY_NAME);
                if (value != null && value.trim().length() > 0) {
                    return value.trim();
                }
            } catch (FileNotFoundException e) {
                // Should not happen - ignore it if it does
            } catch (IOException e) {
                throw new ELException("Failed to read " + PROPERTY_FILE, e);
            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException e) {
                        // Ignore
                    }
                }
            }
        }
        return null;
    }
    
    private static final String getClassNameSysProp() {
        String value = System.getProperty(PROPERTY_NAME);
        if (value != null && value.trim().length() > 0) {
            return value.trim();
        }
======= 9a2ae02:"java/org/apache/jasper/compiler/JspUtil.java"

======= 9a2ae02:"java/org/apache/jasper/compiler/PageInfo.java"

======= 9a2ae02:"java/org/apache/jasper/compiler/PageInfo.java"

    private ExpressionFactory expressionFactory =
        ExpressionFactory.newInstance();
======= 9a2ae02:"java/org/apache/jasper/compiler/Validator.java"

======= 9a2ae02:"java/org/apache/jasper/compiler/Validator.java"

        private static final ExpressionFactory EXPRESSION_FACTORY =
            ExpressionFactory.newInstance();
======= 9a2ae02:"java/org/apache/jasper/compiler/Validator.java"

                                        EXPRESSION_FACTORY.coerceToType(attrs.getValue(i), expectedClass);
======= 9a2ae02:"java/org/apache/jasper/runtime/JspApplicationContextImpl.java"

======= 9a2ae02:"java/org/apache/jasper/runtime/JspApplicationContextImpl.java"


======= d939925:"java/org/apache/catalina/session/StoreBase.java"

        long timeNow = System.currentTimeMillis();
                int timeIdle = (int) ((timeNow - session.getThisAccessedTime()) / 1000L);
                if (timeIdle < session.getMaxInactiveInterval()) {
======= d939925:"java/org/apache/catalina/session/StoreBase.java"

                remove(keys[i]);

  <!--                                                                      -->
  <!--   stderrTimeout        The time (in milliseconds) to wait for the    -->
  <!--                        reading of stdErr to complete before          -->
  <!--                        terminating the CGI process. [2000]           -->
======= ae6c3c4:"java/org/apache/catalina/servlets/CGIServlet.java"

    private String parameterEncoding =
        System.getProperty("file.encoding", "UTF-8");
    /**
     * The time (in milliseconds) to wait for the reading of stdErr to complete
     * before terminating the CGI process.
     */
    private long stderrTimeout = 2000;
======= ae6c3c4:"java/org/apache/catalina/servlets/CGIServlet.java"

        if (getServletConfig().getInitParameter("stderrTimeout") != null) {
            stderrTimeout = Long.parseLong(getServletConfig().getInitParameter(
                    "stderrTimeout"));
        }
======= ae6c3c4:"java/org/apache/catalina/servlets/CGIServlet.java"

            Thread errReaderThread = null;
======= ae6c3c4:"java/org/apache/catalina/servlets/CGIServlet.java"

                errReaderThread = new Thread() {
                };
                errReaderThread.start();
======= ae6c3c4:"java/org/apache/catalina/servlets/CGIServlet.java"

                // Make sure the error stream reader has finished
                if (errReaderThread != null) {
                    try {
                        errReaderThread.join(stderrTimeout);
                    } catch (InterruptedException e) {
                        log ("Interupted waiting for stderr reader thread");
                    }
                }

======= ff22e4a:"java/org/apache/naming/resources/DirContextURLConnection.java"

                // This will be of the form /<hostname>/<contextpath>/file name
                // if <contextpath> is not empty otherwise this will be of the
                // form /<hostname>/file name
                int start;
                if(context instanceof ProxyDirContext &&
                        "".equals(((ProxyDirContext)context).getContextName())){
                    start = file.indexOf('/',1);
                }
                else
                    start = file.indexOf('/', file.indexOf('/', 1) + 1);

======= e1d1476:"java/org/apache/catalina/ha/session/DeltaSession.java"

    protected final Lock diffLock = new ReentrantReadWriteLock().writeLock();
======= e1d1476:"java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java"

    final ReentrantReadWriteLock inLock = new ReentrantReadWriteLock(true);
    final ReentrantReadWriteLock outLock= new ReentrantReadWriteLock(true);
======= e1d1476:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

    private final ReentrantLock[] locks = new ReentrantLock[LOCK_COUNT];

======= d9f2c99:"java/org/apache/catalina/session/PersistentManagerBase.java"

======= d9f2c99:"java/org/apache/catalina/session/PersistentManagerBase.java"

    /**
     * Sessions currently being swapped in and the associated locks
     */
    private Map<String,Object> sessionSwapInLocks =
    	new HashMap<String,Object>();
======= d9f2c99:"java/org/apache/catalina/session/PersistentManagerBase.java"

        Object swapInLock = null;
        
        /*
         * The purpose of this sync and these locks is to make sure that a
         * session is only loaded once. It doesn't matter if the lock is removed
         * and then another thread enters this method and trues to load the same
         * session. That thread will re-creates a swapIn lock for that session,
         * quickly find that the session is already in sessions, use it and
         * carry on.
         */
        synchronized (this) {
        Session session = null;
        synchronized (swapInLock) {
        	// First check to see if another thread has loaded the session into
        	// the manager
        	session = sessions.get(id);
        	
        	if (session == null) {
        	}
        // Make sure the lock is removed
        synchronized (this) {

======= 803d64d:"java/org/apache/catalina/filters/RemoteIpFilter.java"

 * <code>192.168/16</code>) to configure <code>RemoteIPInternalProxy</code> and <code>RemoteIPTrustedProxy</code> ; as the JVM doesn't have a
 * href="http://apr.apache.org/docs/apr/1.3/group__apr__network__io.html#gb74d21b8898b7c40bf7fd07ad3eb993d">apr_ipsubnet_test</a>, we rely on 
 * regular expressions.
======= 803d64d:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    protected static final String PROTOCOL_HEADER_HTTPS_VALUE_PARAMETER = "protocolHeaderHttpsValue";
======= 803d64d:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    private String protocolHeaderHttpsValue = "https";
======= 803d64d:"java/org/apache/catalina/filters/RemoteIpFilter.java"

                if (protocolHeaderValue != null && protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) {
======= 803d64d:"java/org/apache/catalina/filters/RemoteIpFilter.java"

    public String getProtocolHeaderHttpsValue() {
        return protocolHeaderHttpsValue;
======= 803d64d:"java/org/apache/catalina/filters/RemoteIpFilter.java"

        if (filterConfig.getInitParameter(PROTOCOL_HEADER_HTTPS_VALUE_PARAMETER) != null) {
            setProtocolHeaderHttpsValue(filterConfig.getInitParameter(PROTOCOL_HEADER_HTTPS_VALUE_PARAMETER));
======= 803d64d:"java/org/apache/catalina/filters/RemoteIpFilter.java"

     * Case insensitive value of the protocol header to indicate that the incoming http request uses HTTPS.
     * Default value : <code>https</code>
    public void setProtocolHeaderHttpsValue(String protocolHeaderHttpsValue) {
        this.protocolHeaderHttpsValue = protocolHeaderHttpsValue;

======= 51d5511:"java/org/apache/tomcat/util/net/jsse/JSSESupport.java"

======= 51d5511:"java/org/apache/tomcat/util/net/jsse/JSSESupport.java"

    
    private static final Map<SSLSession,Integer> keySizeCache =
        new WeakHashMap<SSLSession, Integer>();
======= 51d5511:"java/org/apache/tomcat/util/net/jsse/JSSESupport.java"

        
        Integer keySize = null;
        synchronized(keySizeCache) {
            keySize = keySizeCache.get(session);
        }
        
======= 51d5511:"java/org/apache/tomcat/util/net/jsse/JSSESupport.java"

            synchronized(keySizeCache) {
                keySizeCache.put(session, keySize);
            }

======= 88b5d4b:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

======= 88b5d4b:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

     * @throws IOException  If the forward to the login page fails and the call
     *                      to {@link HttpServletResponse#sendError(int, String)
     *                      throws an {@link IOException}
            HttpServletResponse response, LoginConfig config)
            throws IOException {
            String msg = sm.getString("formAuthenticator.forwardLoginFail");
            log.warn(msg, t);
            request.setAttribute(Globals.EXCEPTION_ATTR, t);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                    msg);
======= 88b5d4b:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

     * @throws IOException  If the forward to the error page fails and the call
     *                      to {@link HttpServletResponse#sendError(int, String)
     *                      throws an {@link IOException}
            HttpServletResponse response, LoginConfig config)
            throws IOException {
            String msg = sm.getString("formAuthenticator.forwardErrorFail");
            log.warn(msg, t);
            request.setAttribute(Globals.EXCEPTION_ATTR, t);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                    msg);

======= b09d817:"modules/bayeux/java/org/apache/tomcat/bayeux/TomcatBayeux.java"

        return java.util.Arrays.asList(clients.values().toArray(new Client[0]));

======= 9be399f:"modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java"

======= 9be399f:"modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java"

    private static final Log log = LogFactory.getLog(RequestBase.class);
    
======= 9be399f:"modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java"

    JSONObject msgData = null;
======= 9be399f:"modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java"

    @Override
======= 9be399f:"modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java"

    @Override

======= 549a5d5:"java/org/apache/catalina/connector/Request.java"

     * names returned will only be those for the attributes set via
     * <li>{@link Globals#DISPATCHER_TYPE_ATTR}</li>
     * <li>{@link Globals#DISPATCHER_REQUEST_PATH_ATTR}</li>
     * <li>{@link Globals#ASYNC_SUPPORTED_ATTR}</li>
     * <li>{@link Globals#CERTIFICATES_ATTR} (SSL connections only)</li>
     * <li>{@link Globals#CIPHER_SUITE_ATTR} (SSL connections only)</li>
     * <li>{@link Globals#KEY_SIZE_ATTR} (SSL connections only)</li>
     * <li>{@link Globals#SSL_SESSION_ID_ATTR} (SSL connections only)</li>
     * <li>{@link Globals#SSL_SESSION_MGR_ATTR} (SSL connections only)</li>
======= 549a5d5:"java/org/apache/catalina/connector/Request.java"

     * @return the event
======= 549a5d5:"java/org/apache/catalina/connector/Request.java"

     * @return true if the requested session ID was obtained from the SSL session

======= 806200c:"java/org/apache/catalina/ha/session/DeltaSession.java"

            if (value == null || exclude(keys[i]))

======= ed40c2c:"java/org/apache/catalina/ant/jmx/JMXAccessorTask.java"

                for (Iterator<?> iter1 = ((List<?>) key).iterator(); iter1.hasNext();) {
======= ed40c2c:"java/org/apache/catalina/tribes/membership/Membership.java"

            @SuppressWarnings("unchecked") // map is correct type already
            final HashMap<MemberImpl, MbrEntry> tmpclone = (HashMap<MemberImpl, MbrEntry>) map.clone();
            clone.map = tmpclone;
======= ed40c2c:"java/org/apache/catalina/tribes/membership/Membership.java"

     * @return - true if this member is new to the cluster, false otherwise.<br/>
     * - false if this member is the local member or updated.
======= ed40c2c:"java/org/apache/naming/resources/DirContextURLConnection.java"

          return (Collections.emptyMap());
======= ed40c2c:"java/org/apache/naming/resources/DirContextURLConnection.java"

    @SuppressWarnings("unchecked") // overridden method uses raw type Class[]

======= 9afe6ce:"java/org/apache/catalina/ha/context/ReplicatedContext.java"

        if( !initialized ) { 
            try {
                init();
            } catch( Exception ex ) {
                throw new LifecycleException("Error initializaing ", ex);
            }
        }

======= b8599a3:"java/org/apache/el/lang/ELSupport.java"

     * Compare two objects, after coercing to the same type if appropriate.
     * 
     * If the objects are identical, or they are equal according to 
     * {@link #equals(Object, Object)} then return 0.
     * 
     * If either object is a BigDecimal, then coerce both to BigDecimal first.
     * Similarly for Double(Float), BigInteger, and Long(Integer, Char, Short, Byte).
     *  
     * Otherwise, check that the first object is an instance of Comparable, and compare
     * against the second object. If that is null, return 1, otherwise
     * return the result of comparing against the second object.
     * 
     * Similarly, if the second object is Comparable, if the first is null, return -1,
     * else return the result of comparing against the first object.
     * 
     * A null object is considered as:
     * <ul>
     * <li>ZERO when compared with Numbers</li>
     * <li>the empty string for String compares</li>
     * <li>Otherwise null is considered to be lower than anything else.</li>
     * </ul>
     * 
     * @param obj0 first object
     * @param obj1 second object
     * @return -1, 0, or 1 if this object is less than, equal to, or greater than val.
     * @throws ELException if neither object is Comparable
     * @throws ClassCastException if the objects are not mutually comparable
======= b8599a3:"java/org/apache/el/lang/ELSupport.java"

        if (obj0 instanceof Comparable<?>) {
            @SuppressWarnings("unchecked")
            final Comparable<Object> comparable = (Comparable<Object>) obj0;
            return (obj1 != null) ? comparable.compareTo(obj1) : 1;
        if (obj1 instanceof Comparable<?>) {
            @SuppressWarnings("unchecked")
            final Comparable<Object> comparable = (Comparable<Object>) obj1;
            return (obj0 != null) ? -comparable.compareTo(obj0) : -1;
     * Compare two objects for equality, after coercing to the same type if appropriate.
     * 
     * If the objects are identical (including both null) return true.
     * If either object is null, return false.
     * If either object is Boolean, coerce both to Boolean and check equality.
     * Similarly for Enum, String, BigDecimal, Double(Float), Long(Integer, Short, Byte, Character)
     * Otherwise default to using Object.equals().
     * 
     * @param obj0 the first object
     * @param obj1 the second object
     * @return true if the objects are equal
     * @throws ELException
======= b8599a3:"java/org/apache/el/lang/ELSupport.java"

            return (Enum<?>) obj;
     * Convert an object to Boolean.
     * Null and empty string are false.
     * @param obj the object to convert
     * @return the Boolean value of the object
     * @throws IllegalArgumentException if object is not Boolean or String
======= b8599a3:"java/org/apache/el/lang/ELSupport.java"

     * Coerce an object to a string
     * @return the String value of the object
        } else if (obj instanceof Enum<?>) {
            return ((Enum<?>) obj).name();
======= b8599a3:"java/org/apache/el/lang/ELSupport.java"

     * Check if an array contains any {@code null} entries.
     * @param obj array to be checked
     * @return true if the array contains a {@code null}
======= b8599a3:"test/org/apache/el/TestELEvaluation.java"

======= b8599a3:"test/org/apache/el/TestELEvaluation.java"

    private void compareBoth(String msg, int expected, Object o1, Object o2){
        int i1 = ELSupport.compare(o1, o2);
        int i2 = ELSupport.compare(o2, o1);
        assertEquals(msg,expected, i1);
        assertEquals(msg,expected, -i2);
    }
    public void testElSupportCompare(){
        compareBoth("Nulls should compare equal", 0, null, null);
        compareBoth("Null should compare equal to \"\"", 0, "", null);
        compareBoth("Null should be less than File()",-1, null, new File(""));
        compareBoth("Null should be less than Date()",-1, null, new Date());
        compareBoth("Date(0) should be less than Date(1)",-1, new Date(0), new Date(1));        
        try {
            compareBoth("Should not compare",0, new Date(), new File(""));
            fail("Expecting ClassCastException");
        } catch (ClassCastException expected) {
            // Expected
        }
        assertTrue(null == null);
    }

======= 2ac1900:"java/org/apache/el/lang/EvaluationContext.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification in super-class
======= 2ac1900:"java/org/apache/el/lang/EvaluationContext.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification in super-class
======= 2ac1900:"java/org/apache/jasper/el/ELContextWrapper.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match super-class specification
======= 2ac1900:"java/org/apache/jasper/el/ELContextWrapper.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match super-class specification

======= ce8d1c5:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= ce8d1c5:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= ce8d1c5:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= ce8d1c5:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= ce8d1c5:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= ce8d1c5:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= ce8d1c5:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= ce8d1c5:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= ce8d1c5:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= ce8d1c5:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= ce8d1c5:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type
======= ce8d1c5:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @SuppressWarnings("unchecked") // doPrivileged() returns the correct type

======= f0a0aec:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

            case ASYNC : {
                if ((filterMap.getDispatcherMapping() & FilterMap.ASYNC) > 0) {
                    return true;
                }
                break;
            }
======= f0a0aec:"java/org/apache/catalina/deploy/FilterMap.java"

    public static final int ASYNC = 16;
======= f0a0aec:"java/org/apache/catalina/deploy/FilterMap.java"

     * representing the state of when filters should be applied.
======= f0a0aec:"java/org/apache/catalina/deploy/FilterMap.java"

        }  else if (dispatcher.equals(DispatcherType.ASYNC.name())) {
            // apply ERROR to the global dispatcherMapping.
            dispatcherMapping |= ASYNC;

======= 56897be:"java/org/apache/tomcat/util/modeler/Registry.java"

            if ((group == null)) {
                if (item.getGroup() == null){
                    results.add(item.getName());
                }
======= 56897be:"java/org/apache/tomcat/util/modeler/Registry.java"

        } else if( source instanceof Class<?> ) {

======= 632e68c:"java/javax/annotation/Resource.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
======= 632e68c:"java/javax/ejb/EJB.java"

   @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
======= 632e68c:"java/javax/el/BeanELResolver.java"

        public Class getPropertyType() {
======= 632e68c:"java/javax/el/BeanELResolver.java"

======= 632e68c:"java/javax/el/ELContext.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
======= 632e68c:"java/javax/el/ELContext.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
======= 632e68c:"java/javax/el/ListELResolver.java"

======= 632e68c:"java/javax/el/ListELResolver.java"

======= 632e68c:"java/javax/el/ListELResolver.java"

======= 632e68c:"java/javax/el/ListELResolver.java"

======= 632e68c:"java/javax/el/ListELResolver.java"

======= 632e68c:"java/javax/el/ListELResolver.java"

======= 632e68c:"java/javax/el/ListELResolver.java"

======= 632e68c:"java/javax/el/MapELResolver.java"

======= 632e68c:"java/javax/el/MapELResolver.java"

======= 632e68c:"java/javax/el/MapELResolver.java"

======= 632e68c:"java/javax/el/MapELResolver.java"

======= 632e68c:"java/javax/el/MapELResolver.java"

======= 632e68c:"java/javax/el/MapELResolver.java"

======= 632e68c:"java/javax/el/MapELResolver.java"

======= 632e68c:"java/javax/el/MapELResolver.java"

======= 632e68c:"java/javax/el/ResourceBundleELResolver.java"

    @SuppressWarnings("unchecked") // Can't use Iterator<FeatureDescriptor> because API needs to match specification
======= 632e68c:"java/javax/xml/ws/WebServiceRef.java"

    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification

======= 21cd308:"java/org/apache/catalina/ant/jmx/JMXAccessorTask.java"

                if (type instanceof SimpleType<?>) {
======= 21cd308:"java/org/apache/catalina/ant/jmx/JMXAccessorTask.java"

                    if (type instanceof SimpleType<?>) {
======= 21cd308:"java/org/apache/catalina/connector/Request.java"

======= 21cd308:"java/org/apache/catalina/connector/Request.java"

======= 21cd308:"java/org/apache/catalina/core/StandardPart.java"

======= 21cd308:"java/org/apache/catalina/ha/backend/CollectedInfo.java"

        Set<ObjectInstance> set = mBeanServer.queryMBeans(objectName, null);
======= 21cd308:"java/org/apache/catalina/ha/session/BackupManager.java"

        @SuppressWarnings("unchecked") // sessions is of type Map<String, Session>
======= 21cd308:"java/org/apache/catalina/ha/tcp/ReplicationValve.java"

        List<DeltaSession> sessions = crossContextSessions.get();
        if(sessions != null && sessions.size() >0) {
            for(Iterator<DeltaSession> iter = sessions.iterator(); iter.hasNext() ;) {          
======= 21cd308:"java/org/apache/catalina/ha/tcp/ReplicationValve.java"

            List<DeltaSession> sessions = crossContextSessions.get();
            if(sessions != null && sessions.size() >0) {
                Iterator<DeltaSession> iter = sessions.iterator();
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            @SuppressWarnings("unchecked") // mapMembers has the correct type
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
            Map.Entry<?,?> e = i.next();
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                        ArrayList<?> list = (ArrayList<?>) msg.getValue();
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
                    Map.Entry<?,?> e = i.next();
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
                    Map.Entry<?,?> e = i.next();
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
            Map.Entry<?,?> e = i.next();
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
                Map.Entry<?,?> e = i.next();
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Iterator<Map.Entry<?,?>> i = m.entrySet().iterator();
                Map.Entry<?,?> entry = i.next();
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
                    Map.Entry<?,?> e = i.next();
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
                Map.Entry<?,?> e = i.next();
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
                Map.Entry<?,?> e = i.next();
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Iterator<Map.Entry<?,?>> it = super.entrySet().iterator();
                Map.Entry<?,?> e = it.next();
======= 21cd308:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
                Map.Entry<?,?> e = i.next();
======= 21cd308:"java/org/apache/catalina/tribes/transport/bio/MultipointBioSender.java"

        @SuppressWarnings("unchecked") // bioSenders is of type HashMap<Member, BioSender>

======= 92e53f3:"java/org/apache/catalina/core/StandardContext.java"

        taglibs = new HashMap<String, String>();
======= 92e53f3:"java/org/apache/catalina/startup/TldConfig.java"

        } else if (event.getType().equals(Lifecycle.STOP_EVENT)) {
            taglibUris.clear();
            listeners.clear();
        }

======= 55e5052:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

                int charValue = HexUtils.getDec(valueB[i + valueS]);
======= 55e5052:"java/org/apache/coyote/ajp/AjpProcessor.java"

                int charValue = HexUtils.getDec(valueB[i + valueS]);
======= 55e5052:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                int charValue = HexUtils.getDec(valueB[i + valueS]);
======= 55e5052:"java/org/apache/coyote/http11/Http11NioProcessor.java"

                int charValue = HexUtils.getDec(valueB[i + valueS]);
======= 55e5052:"java/org/apache/coyote/http11/Http11Processor.java"

                int charValue = HexUtils.getDec(valueB[i + valueS]);
======= 55e5052:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

                if (HexUtils.getDec(buf[pos]) != -1) {
                    result += HexUtils.getDec(buf[pos]);
======= 55e5052:"java/org/apache/coyote/http11/filters/ChunkedOutputFilter.java"

            chunkLength[pos--] = HexUtils.getHex(digit);
======= 55e5052:"java/org/apache/tomcat/util/buf/HexUtils.java"

    private static final int[] DEC = {
======= 55e5052:"java/org/apache/tomcat/util/buf/HexUtils.java"

    private static final byte[] HEX = 
======= 55e5052:"java/org/apache/tomcat/util/buf/HexUtils.java"

    public static int getDec(int index){
        return DEC[index];
    }
    public static byte getHex(int index){
        return HEX[index];
    }
======= 55e5052:"java/org/apache/tomcat/util/buf/MessageBytes.java"

            buf[end++] = HexUtils.getHex(digit);
======= 55e5052:"java/org/apache/tomcat/util/buf/MessageBytes.java"

            buf[end++] = HexUtils.getHex(digit);

======= a524187:"java/org/apache/catalina/tribes/group/GroupChannel.java"

        protected volatile boolean doRun = true;
======= a524187:"java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java"

    protected volatile boolean run = false;
======= a524187:"java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java"

    protected volatile boolean running = true;
======= a524187:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

    protected volatile boolean doRunSender = false;
    protected volatile boolean doRunReceiver = false;
======= a524187:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

        static volatile boolean running = false;

======= c7d7ba2:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"

        protected volatile boolean run = true;

======= af8a612:"java/org/apache/naming/NamingContext.java"

                ((Context) entry.value).destroySubcontext(name.getSuffix(1));

======= 94c643b:"java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java"

    public void setDomain(String domain) {
        if ( domain == null ) return;
        if (domain.startsWith("{"))
            setDomain(org.apache.catalina.tribes.util.Arrays.fromString(domain));
            setDomain(org.apache.catalina.tribes.util.Arrays.convert(domain));
    }
======= 94c643b:"java/org/apache/catalina/tribes/membership/McastService.java"

======= 94c643b:"java/org/apache/catalina/tribes/membership/McastService.java"

    public void setDomain(String domain) {
        if ( domain == null ) return;
        if ( domain.startsWith("{") ) setDomain(Arrays.fromString(domain));
        else setDomain(Arrays.convert(domain));
    }

======= 04b0838:"java/org/apache/catalina/startup/WebRuleSet.java"

        } else if ("false".equals(value)) {
            webxml.setMetadataComplete(false);

======= 58162ed:"java/org/apache/catalina/core/NamingContextListener.java"

            namingResources.addPropertyChangeListener(this);
======= 58162ed:"java/org/apache/catalina/core/NamingContextListener.java"

======= 58162ed:"java/org/apache/catalina/core/NamingContextListener.java"

     * Process property change events.
======= 58162ed:"java/org/apache/catalina/core/NamingContextListener.java"

     * Process a property change on the naming resources, by making the
======= 58162ed:"java/org/apache/catalina/core/NamingContextListener.java"


======= ae5c640:"java/org/apache/catalina/session/ManagerBase.java"

        if (randomIS!=null) {
            try {
                randomIS.close();
            } catch (IOException ioe) {
                log.warn("Failed to close randomIS.");
            }
            randomIS=null;
        }

======= c0cb61b:"java/org/apache/tomcat/util/IntrospectionUtils.java"

        return setProperty(o,name,value,true);
    }
    public static boolean setProperty(Object o, String name, String value,boolean invokeSetProperty) {
======= c0cb61b:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

                return IntrospectionUtils.setProperty(this,name,value,false);

======= c53173b:"java/org/apache/catalina/core/ContainerBase.java"

     * Return the Logger for this Container.

======= 242b6a3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

======= 242b6a3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

    private AtomicInteger jspReloadCount;
======= 242b6a3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        if (loader == null) {
            loader = this.getClass().getClassLoader();
            if (loader != null) {
                                               loader.toString()));
        parentClassLoader =  loader;
        classpath = initClassPath();
            codeSource = null;
            permissionCollection = null;
            SecurityHolder holder = initSecurity();
            codeSource = holder.cs;
            permissionCollection = holder.pc;
        } else {
            codeSource = null;
            permissionCollection = null;
======= 242b6a3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

    private final ServletContext context;
    private final Options options;
    private final ClassLoader parentClassLoader;
    private final PermissionCollection permissionCollection;
    private final CodeSource codeSource;                    
    private final String classpath;
    private volatile long lastCheck = -1L;
======= 242b6a3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

    public void incrementJspReloadCount() {
        jspReloadCount.incrementAndGet();
======= 242b6a3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

    public void setJspReloadCount(int count) {
        jspReloadCount.set(count);
======= 242b6a3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

        return jspReloadCount.intValue();
======= 242b6a3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

    private String initClassPath() {
======= 242b6a3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

        String path = cpath.toString() + cp;
            log.debug("Compilation classpath initialized: " + path);
        return path;
    // Helper class to allow initSecurity() to return two items
    private static class SecurityHolder{
        private final CodeSource cs;
        private final PermissionCollection pc;
        private SecurityHolder(CodeSource cs, PermissionCollection pc){
            this.cs = cs;
            this.pc = pc;
        }
    }
    private SecurityHolder initSecurity() {
        CodeSource source = null;
        PermissionCollection permissions = null;
======= 242b6a3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                source = new CodeSource(url,(Certificate[])null);
                permissions = policy.getPermissions(source);
                    permissions.add
                    permissions.add
                permissions.add(new FilePermission(docBase,"read"));
======= 242b6a3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                    permissions.add
                permissions.add(new FilePermission(
                permissions.add( new RuntimePermission(
======= 242b6a3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                        permissions.add(
                        permissions.add(
                        permissions.add(
        return new SecurityHolder(source, permissions);

======= a1cb0c3:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    private static final org.apache.juli.logging.Log log =
    private static final byte[] START_DATA = {70,76,84,50,48,48,50};
    private static final byte[] END_DATA = {84,76,70,50,48,48,51};
======= a1cb0c3:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

======= a1cb0c3:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    /**
     * Converts a byte array entry to boolean
     * @param b byte array
     * @param offset within byte array
     * @return true if byte array entry is non-zero, false otherwise
     */
======= a1cb0c3:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    
    private static AtomicInteger invokecount = new AtomicInteger(0);
    

======= 84d49a0:"java/org/apache/catalina/Authenticator.java"

======= 84d49a0:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

======= 84d49a0:"java/org/apache/tomcat/util/net/NioEndpoint.java"

======= 84d49a0:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestSuspectTimeout.java"


======= 0d7263a:"java/org/apache/coyote/http11/AbstractHttp11Protocol.java"

    private static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(AbstractHttp11Protocol.class);
======= 0d7263a:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    @Override
======= 0d7263a:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    @Override
======= 0d7263a:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    private static final org.apache.juli.logging.Log log
======= 0d7263a:"java/org/apache/coyote/http11/Http11Protocol.java"

    private static final org.apache.juli.logging.Log log
======= 0d7263a:"java/org/apache/coyote/http11/Http11Protocol.java"

    @Override
======= 0d7263a:"java/org/apache/coyote/http11/Http11Protocol.java"

    @Override

======= 38f52b5:"java/org/apache/catalina/startup/Tomcat.java"

    private static final String[] DEFAULT_MIME_MAPPINGS = {
======= 38f52b5:"java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java"

    private static final byte[] START_DATA = new byte[] {113, 1, -58, 2, -34, -60, 75, -78, -101, -12, 32, -29, 32, 111, -40, 4};
    private static final byte[] END_DATA = new byte[] {54, -13, 90, 110, 47, -31, 75, -24, -81, -29, 36, 52, -58, 77, -110, 56};
======= 38f52b5:"java/org/apache/catalina/util/HexUtils.java"

    private static final int[] DEC = {

======= 16c4534:"java/org/apache/catalina/tribes/io/BufferPool.java"

    public static final int DEFAULT_POOL_SIZE = 100*1024*1024; //100MB
======= 16c4534:"java/org/apache/jasper/compiler/ServletWriter.java"

    public static final int TAB_WIDTH = 2;
    public static final String SPACES = "                              ";
======= 16c4534:"modules/tomcat-lite/java/org/apache/tomcat/util/http/MimeMap.java"

    public static final Hashtable<String,String> defaultMap =

======= 799b934:"java/org/apache/catalina/core/ApplicationFilterConfig.java"

    private static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/catalina/core/ContainerBase.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/core/StandardHost.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/core/StandardWrapper.java"

    protected static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/ha/ClusterListener.java"

    public static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ClusterListener.class);
======= 799b934:"java/org/apache/catalina/ha/context/ReplicatedContext.java"

    public static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( ReplicatedContext.class );
======= 799b934:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

    public static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
======= 799b934:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

    public static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
======= 799b934:"java/org/apache/catalina/ha/deploy/WarWatcher.java"

    public static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
======= 799b934:"java/org/apache/catalina/ha/session/BackupManager.java"

    public static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( BackupManager.class );
======= 799b934:"java/org/apache/catalina/ha/session/DeltaManager.java"

    public static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(DeltaManager.class);
======= 799b934:"java/org/apache/catalina/ha/session/DeltaRequest.java"

    public static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/catalina/ha/session/DeltaSession.java"

    public static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(DeltaSession.class);
======= 799b934:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

    public static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
======= 799b934:"java/org/apache/catalina/ha/session/SerializablePrincipal.java"

    protected static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/catalina/ha/session/SimpleTcpReplicationManager.java"

    public static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( SimpleTcpReplicationManager.class );
======= 799b934:"java/org/apache/catalina/ha/tcp/ReplicationValve.java"

    private static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/catalina/loader/WebappClassLoader.java"

    protected static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/loader/WebappLoader.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/mbeans/MBeanFactory.java"

    private static final org.apache.juli.logging.Log log = 
======= 799b934:"java/org/apache/catalina/security/SecurityConfig.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/security/SecurityUtil.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/startup/Catalina.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/startup/CatalinaProperties.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/startup/ContextConfig.java"

    protected static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/startup/DefaultJarScanner.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/startup/DigesterFactory.java"

   protected static final org.apache.juli.logging.Log log = 
======= 799b934:"java/org/apache/catalina/startup/EngineConfig.java"

    protected static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/startup/HostConfig.java"

    protected static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/startup/TldConfig.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/startup/UserConfig.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/startup/WebXml.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/catalina/tribes/group/ChannelInterceptorBase.java"

    protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(
======= 799b934:"java/org/apache/catalina/tribes/group/GroupChannel.java"

        protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(HeartbeatThread.class);
======= 799b934:"java/org/apache/catalina/tribes/group/RpcChannel.java"

    protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(RpcChannel.class);
======= 799b934:"java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java"

    private static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( FragmentationInterceptor.class );
======= 799b934:"java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java"

    protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(MessageDispatchInterceptor.class);
======= 799b934:"java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java"

    private static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( TcpFailureDetector.class );
======= 799b934:"java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java"

    protected static final org.apache.juli.logging.Log log = 
======= 799b934:"java/org/apache/catalina/tribes/group/interceptors/ThroughputInterceptor.java"

    protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ThroughputInterceptor.class);
======= 799b934:"java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java"

    private static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(TwoPhaseCommitInterceptor.class);
======= 799b934:"java/org/apache/catalina/tribes/io/ObjectReader.java"

    protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ObjectReader.class);
======= 799b934:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    public static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/catalina/tribes/membership/McastService.java"

    private static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

    private static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java"

    protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(LazyReplicatedMap.class);
======= 799b934:"java/org/apache/catalina/tribes/tipis/ReplicatedMap.java"

    protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ReplicatedMap.class);
======= 799b934:"java/org/apache/catalina/tribes/transport/bio/BioReceiver.java"

    protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(BioReceiver.class);
======= 799b934:"java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java"

    protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( BioReplicationTask.class );
======= 799b934:"java/org/apache/catalina/tribes/transport/bio/BioSender.java"

    private static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(BioSender.class);
======= 799b934:"java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java"

    private static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(FastQueue.class);
======= 799b934:"java/org/apache/catalina/tribes/transport/nio/NioReceiver.java"

    protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(NioReceiver.class);
======= 799b934:"java/org/apache/catalina/tribes/transport/nio/NioReplicationTask.java"

    private static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( NioReplicationTask.class );
======= 799b934:"java/org/apache/catalina/tribes/transport/nio/NioSender.java"

    protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(NioSender.class);
======= 799b934:"java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java"

    protected static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ParallelNioSender.class);
======= 799b934:"java/org/apache/catalina/tribes/util/Logs.java"

    public static final Log MESSAGES = LogFactory.getLog( "org.apache.catalina.tribes.MESSAGES" );
======= 799b934:"java/org/apache/catalina/util/ExtensionValidator.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

    protected static final org.apache.juli.logging.Log log
======= 799b934:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

    protected static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/coyote/ajp/AjpMessage.java"

    protected static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/coyote/ajp/AjpProcessor.java"

    protected static final org.apache.juli.logging.Log log
======= 799b934:"java/org/apache/coyote/ajp/AjpProtocol.java"

    protected static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

    protected static final org.apache.juli.logging.Log log
======= 799b934:"java/org/apache/coyote/http11/Http11AprProcessor.java"

    protected static final org.apache.juli.logging.Log log
======= 799b934:"java/org/apache/coyote/http11/Http11AprProtocol.java"

    protected static final org.apache.juli.logging.Log log = 
======= 799b934:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    protected static final org.apache.juli.logging.Log log
======= 799b934:"java/org/apache/coyote/http11/Http11Protocol.java"

    protected static final org.apache.juli.logging.Log log
======= 799b934:"java/org/apache/jasper/JspCompilationContext.java"

    protected final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/jasper/compiler/SmapUtil.java"

        private final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/jasper/security/SecurityClassLoad.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/jasper/xmlparser/UCSReader.java"

    private final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/jasper/xmlparser/UTF8Reader.java"

    private final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/naming/NamingContext.java"

    private static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/naming/SelectorContext.java"

    private static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/naming/resources/FileDirContext.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/naming/resources/WARDirContext.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/tomcat/util/DomUtil.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/tomcat/util/IntrospectionUtils.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/tomcat/util/buf/B2CConverter.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/tomcat/util/buf/C2BConverter.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/tomcat/util/buf/StringCache.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/tomcat/util/buf/UEncoder.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/tomcat/util/http/Cookies.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/tomcat/util/http/Parameters.java"

    private static final org.apache.juli.logging.Log log=
======= 799b934:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

    private static final org.apache.juli.logging.Log logger =
======= 799b934:"java/org/apache/tomcat/util/net/SSLImplementation.java"

    private static final org.apache.juli.logging.Log logger =
======= 799b934:"java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java"

    static final org.apache.juli.logging.Log logger = 
======= 799b934:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

    static final org.apache.juli.logging.Log log =
======= 799b934:"java/org/apache/tomcat/util/net/jsse/JSSESupport.java"

    private static final org.apache.juli.logging.Log log =
======= 799b934:"modules/tomcat-lite/java/org/apache/tomcat/util/http/mapper/BaseMapper.java"

    private static final org.apache.juli.logging.Log logger =
======= 799b934:"test/org/apache/catalina/tribes/demos/IntrospectionUtils.java"

    private static final org.apache.juli.logging.Log log=

======= 57571a7:"java/org/apache/tomcat/jni/Address.java"

    static public final String APR_ANYADDR = "0.0.0.0";

======= e5ae1bc:"java/org/apache/catalina/tribes/io/ChannelData.java"

    public static final ChannelData[] EMPTY_DATA_ARRAY = new ChannelData[0];

======= 5447621:"java/org/apache/catalina/startup/DefaultJarScanner.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"java/org/apache/tomcat/JarScannerCallback.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestConcurrency.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestException.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/driver/ResultSet.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"modules/tomcat-lite/examples/spring/TomcatSpring.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/addons/Filesystem.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/addons/UserAuthentication.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/addons/UserSessionManager.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/addons/UserTemplateClassMapper.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/integration/ObjectManager.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/integration/jmx/JmxObjectManagerSpi.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/integration/simple/LocalFilesystem.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/integration/simple/Main.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/integration/simple/ServletHelper.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/integration/simple/SimpleObjectManager.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/lite/BodyWriter.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/lite/Connector.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/lite/ContextPreinitListener.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/lite/WebappContextMapper.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/lite/coyote/CoyoteConnector.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/lite/webxml/ServletContextConfig.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/lite/webxml/TomcatLiteWebXmlConfig.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/lite/webxml/WebXml.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/servlets/file/CopyUtils.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/servlets/file/FileCopyUtils.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/servlets/jsp/PreCompileFilter.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/servlets/jsp/SingleThreadedProxyServlet.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/servlets/sec/UserDB.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/servlets/session/RandomGenerator.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/servlets/util/Range.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/servlets/util/UrlUtils.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/util/http/HttpRequest.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/java/org/apache/tomcat/util/http/HttpResponse.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/test/org/apache/tomcat/lite/LiteTestHelper.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/test/org/apache/tomcat/lite/PropertiesSpiTest.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/test/org/apache/tomcat/lite/SimpleServlet.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/WatchdogTest.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"modules/tomcat-lite/test/org/apache/tomcat/util/buf/UEncoderTest.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
======= 5447621:"test/org/apache/TestAll.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"test/org/apache/catalina/startup/SimpleHttpClient.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
======= 5447621:"test/org/apache/catalina/startup/TestWebXml.java"

 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

======= 7849435:"java/javax/servlet/GenericServlet.java"

     *					that contains configuration
======= 7849435:"java/javax/servlet/http/HttpServlet.java"

     *                  uses to return the headers to the client
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/JspWriter.java"

     * @throws	   java.io.IOException If an error occurred while writing
======= 7849435:"java/javax/servlet/jsp/PageContext.java"

     * This method is kept for backwards compatibility reasons.  Newly
======= 7849435:"java/javax/servlet/jsp/SkipPageException.java"

 * the page in the case where one tag invokes another (as can be
======= 7849435:"java/javax/servlet/jsp/tagext/JspFragment.java"

     * @throws javax.servlet.jsp.JspException Thrown if an error occurred
======= 7849435:"java/javax/servlet/jsp/tagext/PageData.java"

 * when being passed to a TagLibraryValidator instance.
======= 7849435:"java/javax/servlet/jsp/tagext/PageData.java"

     * The stream is encoded in UTF-8.  Recall that the XML view of a 
======= 7849435:"java/javax/servlet/jsp/tagext/SimpleTagSupport.java"

     * This additional constraint can be exploited by a
======= 7849435:"java/javax/servlet/jsp/tagext/TagLibraryInfo.java"

     * If a tag library is imported more than once and bound to different prefixes, 
======= 7849435:"java/javax/servlet/jsp/tagext/TagLibraryValidator.java"

 * The JSP container is responsible for locating an appropriate
======= 7849435:"java/javax/servlet/jsp/tagext/TagSupport.java"

     * This additional constraint can be exploited by a

======= 39a78f4:"java/org/apache/coyote/ActionCode.java"

    /** Action id, usable in switches and table indexes
======= 39a78f4:"java/org/apache/coyote/ProtocolHandler.java"

 * This is the main interface to be implemented by a coyote connector.
 * Adapter is the main interface to be implemented by a coyote servlet container.
======= 39a78f4:"java/org/apache/coyote/Request.java"

    // Time of the request - useful to avoid repeated calls to System.currentTime
======= 39a78f4:"java/org/apache/coyote/Request.java"

     * Get the instance id (or JVM route). Currently Ajp is sending it with each
     * 'negotiated' at config time so both tomcat and apache share the same name.
======= 39a78f4:"java/org/apache/coyote/RequestGroupInfo.java"

 *  It is currently used only as a JMX artifact, to aggregate the data
======= 39a78f4:"java/org/apache/coyote/RequestInfo.java"

 * about the requests being processed.
======= 39a78f4:"java/org/apache/coyote/RequestInfo.java"

    // This is useful for long-running requests only
======= 39a78f4:"java/org/apache/coyote/Response.java"

     * Called explicitly by user to set the Content-Language and
======= 39a78f4:"java/org/apache/coyote/Response.java"

     * @param charset String containing the name of the character encoding.
======= 39a78f4:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

            // 4 - hardcoded, byte[] marshaling overhead
======= 39a78f4:"java/org/apache/coyote/ajp/AjpAprProtocol.java"

     * Adapter which will process the requests received by this endpoint.
======= 39a78f4:"java/org/apache/coyote/ajp/AjpProcessor.java"

            // 4 - hardcoded, byte[] marshaling overhead
======= 39a78f4:"java/org/apache/coyote/ajp/AjpProtocol.java"

     * Adapter which will process the requests received by this endpoint.
======= 39a78f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

     * Content delimiter for the request (if false, the connection will
======= 39a78f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

     * Minimum content size to make compression.
======= 39a78f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

     * Add a mime-type which will be compressible
======= 39a78f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

     * Set compressible mime-type list (this method is best when used with
======= 39a78f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        // Check if content is not already gzipped
======= 39a78f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        // If force mode, always compress (test purposes only)
======= 39a78f4:"java/org/apache/coyote/http11/AbstractHttp11Processor.java"

        // Check if sufficient length to trigger the compression
======= 39a78f4:"java/org/apache/coyote/http11/AbstractInputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * This method will write the contents of the specified message bytes 
======= 39a78f4:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * This method will write the contents of the specified message bytes 
======= 39a78f4:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * This method will write the contents of the specified char 
======= 39a78f4:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * This method will write the contents of the specified byte 
======= 39a78f4:"java/org/apache/coyote/http11/AbstractOutputBuffer.java"

     * This method will write the contents of the specified String to the 
======= 39a78f4:"java/org/apache/coyote/http11/Http11AprProcessor.java"

     * Content delimiter for the request (if false, the connection will
======= 39a78f4:"java/org/apache/coyote/http11/Http11AprProcessor.java"

     * Minimum content size to make compression.
======= 39a78f4:"java/org/apache/coyote/http11/Http11AprProcessor.java"

     * Add a mime-type which will be compressible
======= 39a78f4:"java/org/apache/coyote/http11/Http11AprProcessor.java"

     * Set compressible mime-type list (this method is best when used with
======= 39a78f4:"java/org/apache/coyote/http11/Http11AprProcessor.java"

     * Set compressible mime-type list
======= 39a78f4:"java/org/apache/coyote/http11/Http11AprProcessor.java"

            // Acknowledge request
======= 39a78f4:"java/org/apache/coyote/http11/Http11AprProcessor.java"

            // Default is what the socket tells us. Overridden if a host is
======= 39a78f4:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        // Check if content is not already gzipped
======= 39a78f4:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        // If force mode, always compress (test purposes only)
======= 39a78f4:"java/org/apache/coyote/http11/Http11AprProcessor.java"

        // Check if sufficient length to trigger the compression
======= 39a78f4:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            // Acknowledge request
======= 39a78f4:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            // Default is what the socket tells us. Overridden if a host is
======= 39a78f4:"java/org/apache/coyote/http11/Http11Processor.java"

            // Acknowledge request
======= 39a78f4:"java/org/apache/coyote/http11/Http11Processor.java"

            // Default is what the socket tells us. Overridden if a host is
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

     * read operations, or if the given buffer is not big enough to accommodate
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

     * Fill the internal buffer using data from the underlying input stream.
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * Send an acknowledgment.
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * This method will write the contents of the specified message bytes 
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * This method will write the contents of the specified message bytes 
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * This method will write the contents of the specified char 
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * This method will write the contents of the specified byte 
======= 39a78f4:"java/org/apache/coyote/http11/InternalAprOutputBuffer.java"

     * This method will write the contents of the specified String to the 
======= 39a78f4:"java/org/apache/coyote/http11/InternalInputBuffer.java"

     * read operations, or if the given buffer is not big enough to accommodate
======= 39a78f4:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

     * read operations, or if the given buffer is not big enough to accommodate
======= 39a78f4:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

                    if (!fill(true, false)) //request line parsing
======= 39a78f4:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

     * Send an acknowledgment.
======= 39a78f4:"java/org/apache/coyote/http11/InternalNioOutputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/InternalOutputBuffer.java"

     * Send an acknowledgment.
======= 39a78f4:"java/org/apache/coyote/http11/InternalOutputBuffer.java"

     * @throws IOException an underlying I/O error occurred
======= 39a78f4:"java/org/apache/coyote/http11/filters/VoidInputFilter.java"

     * Set the associated request.
======= 39a78f4:"java/org/apache/el/parser/AstValue.java"

        // if our base is null (we know there are more properties to evaluate)
======= 39a78f4:"java/org/apache/el/parser/ParseException.java"

   * following this token will (therefore) be the first error token.

======= 6ce7032:"java/org/apache/jasper/Constants.java"

     * Default URLs to download the plugin for Netscape and IE.
======= 6ce7032:"java/org/apache/jasper/EmbeddedServletOptions.java"

     * Is the generation of SMAP info for JSR45 debugging suppressed?
======= 6ce7032:"java/org/apache/jasper/EmbeddedServletOptions.java"

     * Background JSP compile thread check interval
======= 6ce7032:"java/org/apache/jasper/EmbeddedServletOptions.java"

     * Is the generation of SMAP info for JSR45 debugging suppressed?
======= 6ce7032:"java/org/apache/jasper/JasperException.java"

 * convenient to catch just this at the top-level. 
======= 6ce7032:"java/org/apache/jasper/JspC.java"

     * Is the generation of SMAP info for JSR45 debugging suppressed?
======= 6ce7032:"java/org/apache/jasper/JspC.java"

     * Obtain JSP configuration information specified in web.xml.
======= 6ce7032:"java/org/apache/jasper/JspC.java"

                    // If there is no acceptable candidate, uriRoot will
======= 6ce7032:"java/org/apache/jasper/JspCompilationContext.java"

            // strip the base slash since it will be combined with the
======= 6ce7032:"java/org/apache/jasper/JspCompilationContext.java"

        // a root directory separator char
======= 6ce7032:"java/org/apache/jasper/JspCompilationContext.java"

     * derived package name directly mirrors the file hierarchy of the JSP page.
======= 6ce7032:"java/org/apache/jasper/Options.java"

     * A tag library is 'exposed' either explicitly in 
     * web.xml or implicitly via the uri tag in the TLD 
======= 6ce7032:"java/org/apache/jasper/Options.java"

     * Obtain JSP configuration information specified in web.xml.  
======= 6ce7032:"java/org/apache/jasper/compiler/Collector.java"

 * Collect info about the page and nodes, and make them available through
======= 6ce7032:"java/org/apache/jasper/compiler/Compiler.java"

     * has dependencies, the check is also extended to its dependents, and so
     * on. This method can by overridden by a subclasses of Compiler.
======= 6ce7032:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

 * Instead of a global mapper, a mapper is used for each call to EL
======= 6ce7032:"java/org/apache/jasper/compiler/Generator.java"

     * Generation of static initializers in preamble. For example, dependent
======= 6ce7032:"java/org/apache/jasper/compiler/Generator.java"

             * Check if bean is already there
======= 6ce7032:"java/org/apache/jasper/compiler/Generator.java"

                // Initialize local variables used in this method.
======= 6ce7032:"java/org/apache/jasper/compiler/Generator.java"

            int srcLine = 0; // relative to starting source line
======= 6ce7032:"java/org/apache/jasper/compiler/Generator.java"

         * shortName and encoded to make the resultant string a valid Java
======= 6ce7032:"java/org/apache/jasper/compiler/JarScannerFactory.java"

 * implementation.
======= 6ce7032:"java/org/apache/jasper/compiler/JarScannerFactory.java"

     * Obtain the {@link JarScanner} associated with the specified {@link
======= 6ce7032:"java/org/apache/jasper/compiler/JspConfig.java"

                        // The url patterns are reconstructed as the following:
======= 6ce7032:"java/org/apache/jasper/compiler/JspDocumentParser.java"

    // Flag set to delay incrementing tagDependentNesting until jsp:body
======= 6ce7032:"java/org/apache/jasper/compiler/JspReader.java"

     * gets a unique identifier (which is the index in the array of source
======= 6ce7032:"java/org/apache/jasper/compiler/JspReader.java"

        // is not set to null just for convenience, for it maybe used to
======= 6ce7032:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

 * is dependent upon.  If a dependent file changes the JSP page
======= 6ce7032:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

     * application context.
======= 6ce7032:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

     * Process a "destroy" event for this web application context.
======= 6ce7032:"java/org/apache/jasper/compiler/JspUtil.java"

     * replacement of '$' with '.' of a binary name would not work, as '$' is a
======= 6ce7032:"java/org/apache/jasper/compiler/Node.java"

 * An internal data representation of a JSP page or a JSP document (XML). Also
 * included here is a visitor class for traversing nodes.
======= 6ce7032:"java/org/apache/jasper/compiler/Node.java"

         * page's dom.
======= 6ce7032:"java/org/apache/jasper/compiler/Node.java"

                // Mandatory attribute "name" will be checked in Validator
======= 6ce7032:"java/org/apache/jasper/compiler/Node.java"

         *            The position of the source line, relative to the line at
======= 6ce7032:"java/org/apache/jasper/compiler/Node.java"

     * Auxiliary classes used in Node
======= 6ce7032:"java/org/apache/jasper/compiler/TagFileProcessor.java"

         * Perform miscellaneous checks after the nodes are visited.
======= 6ce7032:"java/org/apache/jasper/compiler/TagFileProcessor.java"

     *            the url for the Jar containing the tag file 
======= 6ce7032:"java/org/apache/jasper/compiler/TagFileProcessor.java"

                    // dependency exists. The circularly dependent tag
======= 6ce7032:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            // Add the dependents for this tag file to its parent's
            // Dependent list. The only reliable dependency information
======= 6ce7032:"java/org/apache/jasper/compiler/TagFileProcessor.java"

     * assumed to have been processed and encapsulated as TagFileInfo in the
======= 6ce7032:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

     * @return TagInfo corresponding to tag file directives
======= 6ce7032:"java/org/apache/jasper/compiler/TextOptimizer.java"

         * The following directives are ignored in text concatenation
======= 6ce7032:"java/org/apache/jasper/compiler/TldLocationsCache.java"

    // Constructor and Initializations
======= 6ce7032:"java/org/apache/jasper/compiler/Validator.java"

 * some page global value (such as those from page directives) are stored, for
======= 6ce7032:"java/org/apache/jasper/compiler/Validator.java"

             * The bodycontent of a SimpleTag cannot be JSP.
======= 6ce7032:"java/org/apache/jasper/compiler/Validator.java"

                                    // The String literal must be castable to what is declared as type
======= 6ce7032:"java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java"

 * This interface allows the plugin author to make inquiries about the
======= 6ce7032:"java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java"

     * used to declare an inner class, a method, or a class variable.
======= 6ce7032:"java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java"

     * Generate codes to evaluate value of a attribute in the custom tag
======= 6ce7032:"java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java"

     * is deemed too complicated for optimization.
======= 6ce7032:"java/org/apache/jasper/runtime/BodyContentImpl.java"

     * method will not throw an IOException if the buffer has already been
======= 6ce7032:"java/org/apache/jasper/runtime/JspContextWrapper.java"

======= 6ce7032:"java/org/apache/jasper/servlet/JspServlet.java"

     * @param request The servlet request we are processing
======= 6ce7032:"java/org/apache/jasper/servlet/JspServletWrapper.java"

     * when compiling tag files with circular dependencies.  A prototype
======= 6ce7032:"java/org/apache/jasper/tagplugins/jstl/core/Import.java"

            //assign appropriate value to the charset
======= 6ce7032:"java/org/apache/jasper/util/Enumerator.java"

 * Constructors are provided to easily create such wrappers.
======= 6ce7032:"java/org/apache/jasper/xmlparser/UTF8Reader.java"

        //       error. By signaling the error on the next block read we
======= 6ce7032:"java/org/apache/jasper/xmlparser/XMLEncodingDetector.java"

     * invocation when it's read() method is invoked, but uses the
======= 6ce7032:"java/org/apache/juli/ClassLoaderLogManager.java"

     * @throws IOException Error
======= 6ce7032:"java/org/apache/juli/OneLineFormatter.java"

 * it easier to grep the logs. The only exception is stacktraces which are
 * always preceded by whitespace to make it simple to skip them.
======= 6ce7032:"java/org/apache/juli/logging/DirectJDKLog.java"

                // it is also possible that the user modified jre/lib/logging.properties - 
======= 6ce7032:"java/org/apache/juli/logging/DirectJDKLog.java"

    // is bad - design by committee can be really bad ! The impact on performance of 
======= 6ce7032:"java/org/apache/juli/logging/Log.java"

 * The implementation should ensure, though, that this ordering behaves
======= 6ce7032:"java/org/apache/juli/logging/LogFactory.java"

 * Note that this implementation is not just a wrapper around JDK logging ( like
======= 6ce7032:"java/org/apache/juli/logging/LogFactory.java"

     * For example, running the following ant scriptlet:
======= 6ce7032:"java/org/apache/juli/logging/LogFactory.java"

     * the specified object's class has overridden the toString method.

======= 21e86e6:"java/org/apache/naming/NamingEntry.java"

     * The type instance variable is used to avoid using RTTI when doing
======= 21e86e6:"java/org/apache/naming/NamingService.java"

     * Returns the Catalina component name.
======= 21e86e6:"java/org/apache/naming/NamingServiceMBean.java"

     * Returns the JNDI component name.
======= 21e86e6:"java/org/apache/naming/ResourceRef.java"

     * @param auth Resource authentication
======= 21e86e6:"java/org/apache/naming/ResourceRef.java"

     * @param auth Resource authentication
======= 21e86e6:"java/org/apache/naming/factory/EjbFactory.java"

     * Create a new EJB instance.
======= 21e86e6:"java/org/apache/naming/factory/OpenEjbFactory.java"

     * Create a new EJB instance using OpenEJB.
======= 21e86e6:"java/org/apache/naming/factory/ResourceEnvFactory.java"

     * Create a new Resource env instance.
======= 21e86e6:"java/org/apache/naming/factory/TransactionFactory.java"

 * Object factory for User transactions.
======= 21e86e6:"java/org/apache/naming/factory/TransactionFactory.java"

     * Create a new User transaction instance.
======= 21e86e6:"java/org/apache/naming/resources/BaseDirContext.java"

     * @return an enumeration of SearchResults of the objects that satisfy the 
======= 21e86e6:"java/org/apache/naming/resources/DirContextURLConnection.java"

     * Connect to the DirContext, and retrieve the bound object, as well as
======= 21e86e6:"java/org/apache/naming/resources/FileDirContext.java"

     * @return an enumeration of SearchResults of the objects that satisfy the
======= 21e86e6:"java/org/apache/naming/resources/FileDirContext.java"

     * @return Vector containing NamingEntry objects
======= 21e86e6:"java/org/apache/naming/resources/ProxyDirContext.java"

        // Retrieving object
======= 21e86e6:"java/org/apache/naming/resources/Resource.java"

 * Encapsulates the contents of a resource.
======= 21e86e6:"java/org/apache/naming/resources/ResourceCache.java"

     * Find a map element given its name in a sorted array of map elements.
======= 21e86e6:"java/org/apache/naming/resources/WARDirContext.java"

     * @return an enumeration of SearchResults of the objects that satisfy the 

======= ed97da7:"java/org/apache/tomcat/jni/BIOCallback.java"

     * @param buf containing the bytes to write.
======= ed97da7:"java/org/apache/tomcat/jni/BIOCallback.java"

     * @return String with up to len bytes read
======= ed97da7:"java/org/apache/tomcat/jni/Directory.java"

     * @param perm Permissions for the new directory.
======= ed97da7:"java/org/apache/tomcat/jni/Directory.java"

     * @param perm Permissions for the new directory.
======= ed97da7:"java/org/apache/tomcat/jni/File.java"

     * Write data from array of byte arrays to the specified file.
======= ed97da7:"java/org/apache/tomcat/jni/File.java"

     * Write data from array of byte arrays to the specified file,
======= ed97da7:"java/org/apache/tomcat/jni/File.java"

     * @return The read character
======= ed97da7:"java/org/apache/tomcat/jni/File.java"

     * This function should be used in preference to explicit manipulation
======= ed97da7:"java/org/apache/tomcat/jni/File.java"

     * @param file The file to retrieve flags.
======= ed97da7:"java/org/apache/tomcat/jni/Local.java"

     *                the number of instances is unlimited.
======= ed97da7:"java/org/apache/tomcat/jni/OS.java"

     * Get the name of the system default character set.
======= ed97da7:"java/org/apache/tomcat/jni/OS.java"

     * data can't be retrieved on this system.
======= ed97da7:"java/org/apache/tomcat/jni/Poll.java"

    public static final int APR_POLLNVAL = 0x040; /** Descriptor invalid */
======= ed97da7:"java/org/apache/tomcat/jni/Poll.java"

     * descriptor is signaled in apr_pollset_poll().
======= ed97da7:"java/org/apache/tomcat/jni/Poll.java"

     * @param descriptors Array of signaled descriptors (output parameter)
     *        The descriptor array must be two times the size of pollset.
     * @return Number of signaled descriptors (output parameter)
======= ed97da7:"java/org/apache/tomcat/jni/Poll.java"

     * @param descriptors Array of signaled descriptors (output parameter)
     *        The descriptor array must be the size of pollset.
     * @return Number of signaled descriptors (output parameter)
======= ed97da7:"java/org/apache/tomcat/jni/Poll.java"

     *        The descriptor array must be two times the size of pollset.
======= ed97da7:"java/org/apache/tomcat/jni/Pool.java"

     * Object attached to the pool will be globally referenced
     * until the pool is cleared or dataSet is called with the null data.
======= ed97da7:"java/org/apache/tomcat/jni/Proc.java"

    /** a restart is occurring, perform any necessary cleanup (including
======= ed97da7:"java/org/apache/tomcat/jni/Proc.java"

    /** a health check is occurring, for most maintenance functions
======= ed97da7:"java/org/apache/tomcat/jni/Proc.java"

     * Allocate apr_proc_t structure from pool
======= ed97da7:"java/org/apache/tomcat/jni/SSL.java"

     * a hardware accelerator card for crypto operations.
======= ed97da7:"java/org/apache/tomcat/jni/SSL.java"

     * Close BIO and dereference callback object
======= ed97da7:"java/org/apache/tomcat/jni/SSL.java"

     * @param file File containing DH params.
======= ed97da7:"java/org/apache/tomcat/jni/SSLContext.java"

     * Associate BIOCallback for input or output data capture.
     * [WARN]   -- Warning messages
======= ed97da7:"java/org/apache/tomcat/jni/SSLContext.java"

     * renegotiation with the reconfigured Cipher Suite after the HTTP request
======= ed97da7:"java/org/apache/tomcat/jni/SSLContext.java"

     *                 is encrypted, password prompt will be displayed.
======= ed97da7:"java/org/apache/tomcat/jni/SSLContext.java"

     * is established. In per-directory context it forces a SSL renegotiation with
======= ed97da7:"java/org/apache/tomcat/jni/Shm.java"

     * Create and make accessible a shared memory segment.
     *         Not all platforms support anonymous shared memory segments, but in
     *         some cases it is preferred over other types of shared memory
======= ed97da7:"java/org/apache/tomcat/jni/Socket.java"

     *           elapses with no data read or written
======= ed97da7:"java/org/apache/tomcat/jni/Socket.java"

     * Private method for getting the socket struct members
     * @param socket The socket to use
======= ed97da7:"java/org/apache/tomcat/jni/Socket.java"

     * @return The structure member address
======= ed97da7:"java/org/apache/tomcat/jni/Time.java"

    /** number of milliseconds per microsecond */
======= ed97da7:"java/org/apache/tomcat/jni/Time.java"

     * number of microseconds since 00:00:00 January 1, 1970 UTC
======= ed97da7:"java/org/apache/tomcat/jni/User.java"

     * @return APR_SUCCESS if the apr_uid_t structures identify the same user,
======= ed97da7:"java/org/apache/tomcat/jni/User.java"

     * @return APR_SUCCESS if the apr_gid_t structures identify the same group,
======= ed97da7:"java/org/apache/tomcat/util/DomUtil.java"

    /** Get the trimmed text content of a node or null if there is no text
======= ed97da7:"java/org/apache/tomcat/util/DomUtil.java"

     * @param parent lookup direct children
======= ed97da7:"java/org/apache/tomcat/util/IntrospectionUtils.java"

                    // check if it's overridden
======= ed97da7:"java/org/apache/tomcat/util/buf/B2CConverter.java"

 *  This uses the standard JDK mechanism - a reader - but provides mechanisms
======= ed97da7:"java/org/apache/tomcat/util/buf/B2CConverter.java"

    /** Overridden - will do nothing but reset internal state.
======= ed97da7:"java/org/apache/tomcat/util/buf/B2CConverter.java"

======= ed97da7:"java/org/apache/tomcat/util/buf/ByteChunk.java"

    /** Input interface, used when the buffer is empty
======= ed97da7:"java/org/apache/tomcat/util/buf/ByteChunk.java"

     *  If -1 or not set, the buffer will grow indefinitely.
======= ed97da7:"java/org/apache/tomcat/util/buf/ByteChunk.java"

     *  You can also call it explicitly to force the data to be written.
======= ed97da7:"java/org/apache/tomcat/util/buf/ByteChunk.java"

             it's safer to use the "classical" new String().
======= ed97da7:"java/org/apache/tomcat/util/buf/C2BConverter.java"

 *  This uses the standard JDK mechanism - a writer - but provides mechanisms
======= ed97da7:"java/org/apache/tomcat/util/buf/C2BConverter.java"

 *  Special writer class, where close() is overridden. The default implementation
 *  would set byteOutputter to null, and the writer can't be recycled. 
======= ed97da7:"java/org/apache/tomcat/util/buf/C2BConverter.java"

    // stream with flush() and close(). overridden.
======= ed97da7:"java/org/apache/tomcat/util/buf/C2BConverter.java"

    /** Overridden - will do nothing but reset internal state.
======= ed97da7:"java/org/apache/tomcat/util/buf/C2BConverter.java"

======= ed97da7:"java/org/apache/tomcat/util/buf/CharChunk.java"

 * Utilities to manipulate char chunks. While String is
 * designed as immutable and secure objects.
======= ed97da7:"java/org/apache/tomcat/util/buf/CharChunk.java"

    // -1: grow indefinitely
======= ed97da7:"java/org/apache/tomcat/util/buf/CharChunk.java"

     *  If -1 or not set, the buffer will grow indefinitely.
======= ed97da7:"java/org/apache/tomcat/util/buf/MessageBytes.java"

======= ed97da7:"java/org/apache/tomcat/util/buf/MessageBytes.java"

======= ed97da7:"java/org/apache/tomcat/util/buf/MessageBytes.java"

======= ed97da7:"java/org/apache/tomcat/util/buf/StringCache.java"

                    // while waiting for the lock, just return the toString value
======= ed97da7:"java/org/apache/tomcat/util/buf/UDecoder.java"

======= ed97da7:"java/org/apache/tomcat/util/buf/UEncoder.java"

     * Utility function to re-encode the URL.
======= ed97da7:"java/org/apache/tomcat/util/collections/MultiMap.java"

    /** Create a new, uninitialized entry. 
======= ed97da7:"java/org/apache/tomcat/util/collections/MultiMapNamesEnumeration.java"

    Each nextElement() is O(n) ( a comparison is
    This is less frequent than add() -
======= ed97da7:"java/org/apache/tomcat/util/collections/MultiMapNamesEnumeration.java"

    // we always to toString and unique.
======= ed97da7:"java/org/apache/tomcat/util/digester/AbstractRulesImpl.java"

    /** Namespace uri to associate with subsequent <code>Rule</code>'s */
======= ed97da7:"java/org/apache/tomcat/util/digester/CallMethodRule.java"

     *  zero for a single argument from the body of this element
     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/CallMethodRule.java"

     *  zero for a single argument from the body of this element
     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/CallMethodRule.java"

     *  zero for a single argument from the body of this element
     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/CallMethodRule.java"

     *  zero for a single argument from the body of this element
     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/Digester.java"

     * properties only affect the SAXParser and empty constructor.
======= ed97da7:"java/org/apache/tomcat/util/digester/Digester.java"

     * Set the public id of the current file being parse.
======= ed97da7:"java/org/apache/tomcat/util/digester/Digester.java"

     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/Digester.java"

     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/Digester.java"

     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/Digester.java"

     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/FactoryCreateRule.java"

 * needed before the object can be created.  A common scenario is for the
======= ed97da7:"java/org/apache/tomcat/util/digester/GenericParser.java"

     * Create a <code>SAXParser</code> configured to support XML Schema and DTD
======= ed97da7:"java/org/apache/tomcat/util/digester/NodeCreateRule.java"

 *   only the XML content under the element the rule was triggered on.</li>
======= ed97da7:"java/org/apache/tomcat/util/digester/RuleSet.java"

 * class that implements this interface:</p>
======= ed97da7:"java/org/apache/tomcat/util/digester/RulesBase.java"

     * order that they were originally registered.
======= ed97da7:"java/org/apache/tomcat/util/digester/SetNextRule.java"

     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/SetNextRule.java"

     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/SetNextRule.java"

     * to introspect the relevant objects so that the right method can be called.
======= ed97da7:"java/org/apache/tomcat/util/digester/SetPropertiesRule.java"

     * <p>Constructor allows attribute->property mapping to be overridden.</p>
======= ed97da7:"java/org/apache/tomcat/util/digester/SetPropertiesRule.java"

     * property name, then this indicates that the attribute should be ignored.</p>
======= ed97da7:"java/org/apache/tomcat/util/digester/SetPropertyRule.java"

     *  have a writable property of the specified name
======= ed97da7:"java/org/apache/tomcat/util/digester/SetRootRule.java"

     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/SetRootRule.java"

     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/SetRootRule.java"

     * to introspect the relevant objects so that the right method can be called.
======= ed97da7:"java/org/apache/tomcat/util/digester/SetTopRule.java"

     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/SetTopRule.java"

     *  (if you wish to use a primitive type, specify the corresponding
======= ed97da7:"java/org/apache/tomcat/util/digester/SetTopRule.java"

     * to introspect the relevant objects so that the right method can be called.
======= ed97da7:"java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java"

    /** Sets digester using these Rules */
======= ed97da7:"java/org/apache/tomcat/util/http/ContentType.java"

 * Useful methods for Content-Type processing
======= ed97da7:"java/org/apache/tomcat/util/http/Cookies.java"

    /** Register a new, initialized cookie. Cookies are recycled, and
======= ed97da7:"java/org/apache/tomcat/util/http/Cookies.java"

                    // at the last quote. This must be dealt with
======= ed97da7:"java/org/apache/tomcat/util/http/Cookies.java"

                        // getToken returns the position at the delimiter
======= ed97da7:"java/org/apache/tomcat/util/http/Cookies.java"

     * Given a starting position after an initial quote character, this gets
======= ed97da7:"java/org/apache/tomcat/util/http/MimeHeaders.java"

 *  For input headers it is possible to use the MessageByte for Fields - so no GC
======= ed97da7:"java/org/apache/tomcat/util/http/MimeHeaders.java"

    Each nextElement() is O(n) ( a comparison is
    This is less frequent than add() -
======= ed97da7:"java/org/apache/tomcat/util/http/fileupload/FileItem.java"

     *         for storing the contents of the file.
======= ed97da7:"java/org/apache/tomcat/util/http/fileupload/MultipartStream.java"

 *   close-delimiter := "--" boundary "--"<br>
======= ed97da7:"java/org/apache/tomcat/util/http/fileupload/MultipartStream.java"

     * The index of last valid character in the buffer + 1.
======= ed97da7:"java/org/apache/tomcat/util/http/fileupload/MultipartStream.java"

        // We prepend CR/LF to the boundary to chop trailing CR/LF from
======= ed97da7:"java/org/apache/tomcat/util/http/fileupload/MultipartStream.java"

            // Read boundary - if succeeded, the stream contains an
======= ed97da7:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

     * Find a map element given its name in a sorted array of map elements.
======= ed97da7:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

     * Find a map element given its name in a sorted array of map elements.
======= ed97da7:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

     * Find a map element given its name in a sorted array of map elements.
======= ed97da7:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

     * Find a map element given its name in a sorted array of map elements.
======= ed97da7:"java/org/apache/tomcat/util/modeler/AttributeInfo.java"

     * Is this attribute writable by management applications?
======= ed97da7:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

 *  - some of the gratuitous flexibility removed - instead this is more predictive and
======= ed97da7:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

 *     supported.</li>
======= ed97da7:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

======= ed97da7:"java/org/apache/tomcat/util/modeler/Registry.java"

    /** List of managed beans, keyed by class name
======= ed97da7:"java/org/apache/tomcat/util/modeler/Registry.java"

     * This method should be used to explicitly load metadata - but this is not
     * in the same package.
======= ed97da7:"java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java"

     * @param getAttMap The readable attributes map
======= ed97da7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

     * Use sendfile for sending static files.
======= ed97da7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            // exit, otherwise parallel destruction of sockets which are still
======= ed97da7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

         * be 62 (recompiling APR is necessary to remove this limitation).
======= ed97da7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            // exit, otherwise parallel destruction of sockets which are still
======= ed97da7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

         * @param data containing the reference to the data which should be sent
======= ed97da7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                // Close the socket, as the response would be incomplete
======= ed97da7:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                                // Close the socket, as the response would be incomplete
======= ed97da7:"java/org/apache/tomcat/util/net/DefaultServerSocketFactory.java"

 * plain old server sockets.
======= ed97da7:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                                //Invocations for both read and write on separate threads
======= ed97da7:"java/org/apache/tomcat/util/net/NioEndpoint.java"

                        reg(key,ka,0);//avoid multiple calls, this gets reregistered after invocation
======= ed97da7:"java/org/apache/tomcat/util/net/ServerSocketFactory.java"

     *  Note that the "preferred" mechanism is to
======= ed97da7:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

     * Gets the initialized trust managers.

======= c52b1ba:"java/javax/servlet/SessionCookieConfig.java"

     * Sets the maximum age.
     * @param MaxAge the maximum age to set
======= c52b1ba:"java/org/apache/catalina/ant/jmx/JMXAccessorCreateTask.java"

     * @param classLoaderName The classLoader to set.
======= c52b1ba:"java/org/apache/catalina/core/ApplicationFilterChain.java"

     * Process the event, using the security manager if the option is enabled.
     * 
     * @param event the event to process
     * 
======= c52b1ba:"java/org/apache/catalina/core/StandardContextValve.java"

======= c52b1ba:"java/org/apache/catalina/core/StandardContextValve.java"

     * @param event
======= c52b1ba:"java/org/apache/catalina/core/StandardEngineValve.java"

======= c52b1ba:"java/org/apache/catalina/core/StandardEngineValve.java"

     * @param event the event
======= c52b1ba:"java/org/apache/catalina/core/StandardHostValve.java"

======= c52b1ba:"java/org/apache/catalina/core/StandardHostValve.java"

     * @param event the event
======= c52b1ba:"java/org/apache/catalina/core/StandardWrapperValve.java"

======= c52b1ba:"java/org/apache/catalina/ha/ClusterManager.java"

    * @param domainReplication Flag value.
======= c52b1ba:"java/org/apache/catalina/ha/session/DeltaSession.java"

    public DeltaSession() {
        this(null);
    }
======= c52b1ba:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

     * @param msg
======= c52b1ba:"java/org/apache/catalina/manager/StatusTransformer.java"

======= c52b1ba:"java/org/apache/catalina/manager/StatusTransformer.java"

======= c52b1ba:"java/org/apache/catalina/manager/StatusTransformer.java"

     * Write an HTML or XML header.
     * @param writer the PrintWriter to use
     * @param mode - 0 = HTML header, 1 = XML declaration
======= c52b1ba:"java/org/apache/catalina/realm/CombinedRealm.java"

     * @param nonce Unique (or supposedly unique) token which has been used
     * @param realmName Realm name
            String nonce, String nc, String cnonce, String qop,
======= c52b1ba:"java/org/apache/catalina/realm/CombinedRealm.java"

            authenticatedUser = realm.authenticate(username, clientDigest, nonce,
======= c52b1ba:"java/org/apache/catalina/realm/LockOutRealm.java"

     * @param nonce Unique (or supposedly unique) token which has been used
     * @param realmName Realm name
            String nonce, String nc, String cnonce, String qop,
======= c52b1ba:"java/org/apache/catalina/realm/LockOutRealm.java"

                nonce, nc, cnonce, qop, realmName, md5a2);
======= c52b1ba:"java/org/apache/catalina/startup/Embedded.java"

     * Enables or disables redirection.
     * @param redirectStreams The new redirection value
======= c52b1ba:"java/org/apache/catalina/startup/WebRuleSet.java"

     * @param text The body text of this element
======= c52b1ba:"java/org/apache/catalina/startup/WebRuleSet.java"

     * @param text The body text of this element
======= c52b1ba:"java/org/apache/catalina/tribes/group/ChannelCoordinator.java"

     * @param payload TBA
======= c52b1ba:"java/org/apache/catalina/tribes/io/ChannelData.java"

     * Sets the message options.
     * 
     * @param options the message options
======= c52b1ba:"java/org/apache/catalina/tribes/io/ChannelData.java"

     * @param xbuf byte[]
======= c52b1ba:"java/org/apache/catalina/tribes/io/ObjectReader.java"

     * @param count whether to return the count
     * @return number of messages that was sent to callback (or -1 if count == false)
======= c52b1ba:"java/org/apache/catalina/tribes/io/ReplicationStream.java"

     * @param classLoaders The class loader array used to instantiate objects
======= c52b1ba:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

======= c52b1ba:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

     * @param cdata - the message data to be contained within the package
======= c52b1ba:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

     * Converts a boolean to a 1-byte array
     * @param bool - the integer
     * @return - 1-byte array
======= c52b1ba:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

======= c52b1ba:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

     * @return serialized content as byte[] array 
======= c52b1ba:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

     * @param localLoopbackDisabled - disable loopbackMode
======= c52b1ba:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

     * @throws IOException
======= c52b1ba:"java/org/apache/catalina/tribes/membership/MemberImpl.java"

     * The number of milliseconds since this member was
======= c52b1ba:"java/org/apache/catalina/tribes/membership/MemberImpl.java"

     * @param aliveTime - the number of milliseconds since this member was created
======= c52b1ba:"java/org/apache/catalina/tribes/membership/MemberImpl.java"

======= c52b1ba:"java/org/apache/catalina/tribes/membership/Membership.java"

     * @param local - has to be the name of the local member. Used to filter the local member from the cluster membership
     * @param includeLocal - TBA
======= c52b1ba:"java/org/apache/catalina/tribes/transport/bio/util/LinkObject.java"

     * @param msg the message
     * @param destination TBA
======= c52b1ba:"java/org/apache/catalina/tribes/transport/nio/NioReceiver.java"

     * @throws IOException
======= c52b1ba:"java/org/apache/catalina/users/MemoryUserDatabase.java"

     * @param readonly the new status
======= c52b1ba:"java/org/apache/catalina/valves/RemoteIpValve.java"

     * @param remoteIpHeader
======= c52b1ba:"java/org/apache/catalina/valves/RemoteIpValve.java"

     * Comma delimited list of proxies that are trusted when they appear in the {@link #remoteIpHeader} header. Can be expressed as a
======= c52b1ba:"java/org/apache/coyote/http11/Http11Processor.java"

     * @param socketWrapper Socket from which the HTTP requests will be read
======= c52b1ba:"java/org/apache/jasper/compiler/ParserController.java"

     * @param jarFileUrl The JAR file from which to read the included resource,
======= c52b1ba:"java/org/apache/jasper/compiler/TagFileProcessor.java"

     * @param path
======= c52b1ba:"java/org/apache/jasper/compiler/TldLocationsCache.java"

======= c52b1ba:"java/org/apache/naming/HandlerRef.java"

======= c52b1ba:"java/org/apache/naming/ServiceRef.java"

======= c52b1ba:"java/org/apache/naming/resources/BaseDirContext.java"

     * @param name The path to the desired resource
======= c52b1ba:"java/org/apache/tomcat/buildutil/Txt2Html.java"

     * @param fs The fileset to be converted.
======= c52b1ba:"java/org/apache/tomcat/buildutil/Txt2Html.java"

     * @throws BuildException if an error occurs during execution of
======= c52b1ba:"java/org/apache/tomcat/util/digester/SetPropertiesRule.java"

     * @param theName the local name if the parser is namespace aware, or just 
======= c52b1ba:"java/org/apache/tomcat/util/digester/SetPropertyRule.java"

     * @param theName the local name if the parser is namespace aware, or just 
======= c52b1ba:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

======= c52b1ba:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

======= c52b1ba:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

======= c52b1ba:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

======= c52b1ba:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

======= c52b1ba:"java/org/apache/tomcat/util/modeler/BaseModelMBean.java"

======= c52b1ba:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"

======= c52b1ba:"java/org/apache/tomcat/util/net/SSLSessionManager.java"

     * Invalidate the SSL session

======= ab3620c:"java/org/apache/catalina/startup/Tomcat.java"

        // NOOP
======= ab3620c:"java/org/apache/catalina/startup/Tomcat.java"

     * @return new StandardContext
======= ab3620c:"java/org/apache/catalina/startup/Tomcat.java"

     *  @param baseDir base dir for the context, for static files. Must exist, 
======= ab3620c:"java/org/apache/catalina/startup/Tomcat.java"

     * Static version of {@link #addServlet(String, String, String)}
======= ab3620c:"java/org/apache/catalina/startup/Tomcat.java"

     * Static version of {@link #addServlet(String, String, Servlet)}.
======= ab3620c:"java/org/apache/catalina/startup/Tomcat.java"

     * @see #addUser(String, String) 
======= ab3620c:"java/org/apache/catalina/startup/Tomcat.java"

            getHost().addChild(ctx);
        } else {
            host.addChild(ctx);
                                     String url, String path) {
======= ab3620c:"java/org/apache/catalina/startup/Tomcat.java"

            getHost().addChild(ctx);
        } else {
            host.addChild(ctx);
======= ab3620c:"java/org/apache/catalina/startup/Tomcat.java"

     * Static version of {@link #initWebappDefaults(String)}

======= 18c0edc:"java/org/apache/catalina/Cluster.java"

     * cluster that this manager is participating in the cluster.
======= 18c0edc:"java/org/apache/catalina/CometEvent.java"

     *  Note that the response object and dependent OutputStream and Writer are still 
======= 18c0edc:"java/org/apache/catalina/CometEvent.java"

     * request. The servlet should perform any needed cleanup as if it had received
======= 18c0edc:"java/org/apache/catalina/CometProcessor.java"

 * asynchronous IO, receiving events when data is available for reading, and
======= 18c0edc:"java/org/apache/catalina/Context.java"

     * Remove the tag library location for the specified tag library URI.
======= 18c0edc:"java/org/apache/catalina/Context.java"

     * @return true if namespace awareness is enabled.
======= 18c0edc:"java/org/apache/catalina/Context.java"

     * @return true if namespace awareness is enabled.
======= 18c0edc:"java/org/apache/catalina/Host.java"

     * this host's child webapps should be discovered and automatically 
======= 18c0edc:"java/org/apache/catalina/Host.java"

     * that this host's child webapps should be discovered and automatically 
======= 18c0edc:"java/org/apache/catalina/Host.java"

     * @return true if namespace awareness is enabled.
======= 18c0edc:"java/org/apache/catalina/Pipeline.java"

     * Valve for this Pipeline (if any).  Prior to setting the basic Valve,
======= 18c0edc:"java/org/apache/catalina/Pipeline.java"

     * @exception IllegalArgumentException if the specified Valve refuses to be
======= 18c0edc:"java/org/apache/catalina/ant/BaseRedirectorHelperTask.java"

     * always sent to the log. Default is that output is sent only to
======= 18c0edc:"java/org/apache/catalina/ant/BaseRedirectorHelperTask.java"

         * this is to prevent that we attempt to reuse the previously 
======= 18c0edc:"java/org/apache/catalina/ant/BaseRedirectorHelperTask.java"

     * priorities to output stream.
======= 18c0edc:"java/org/apache/catalina/ant/BaseRedirectorHelperTask.java"

     * priorities to output stream, then flushes the stream.
======= 18c0edc:"java/org/apache/catalina/ant/JKStatusUpdateTask.java"

     * check correct lb and worker parameter
======= 18c0edc:"java/org/apache/catalina/ant/jmx/JMXAccessorQueryTask.java"

 * The property manager.lenght show the size of the result 
 * and with manager.[0..length].name the 
======= 18c0edc:"java/org/apache/catalina/ant/jmx/JMXAccessorQueryTask.java"

     *  with <em>attributebinding=true</em> you can save all attributes from all found objects
======= 18c0edc:"java/org/apache/catalina/ant/jmx/JMXAccessorSetTask.java"

     * Get MBean Attribute from Mbean Server
======= 18c0edc:"java/org/apache/catalina/ant/jmx/JMXAccessorTask.java"

     * option is that you delimit your result with a delimiter
======= 18c0edc:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

 * so that it can be omitted in environments that do not require these
======= 18c0edc:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

     * we signaled after successful authentication?
======= 18c0edc:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

            // The browser isn't expecting this conditional response now.
======= 18c0edc:"java/org/apache/catalina/authenticator/SingleSignOn.java"

 * web application is propagated to other web applications in the same
======= 18c0edc:"java/org/apache/catalina/connector/Connector.java"

     * The server port to which we should pretend requests to this Connector
======= 18c0edc:"java/org/apache/catalina/connector/CoyoteAdapter.java"

     * Look for SSL session ID if required. Only look for SSL Session ID if it
======= 18c0edc:"java/org/apache/catalina/connector/CoyoteInputStream.java"

     * which would permanently disable us.
======= 18c0edc:"java/org/apache/catalina/connector/CoyoteReader.java"

 * Coyote implementation of the buffered reader.
======= 18c0edc:"java/org/apache/catalina/connector/OutputBuffer.java"

 * Coyote is mostly the Processor's responsibility).
======= 18c0edc:"java/org/apache/catalina/connector/Request.java"

     * The preferred Locales associated with this Request.
======= 18c0edc:"java/org/apache/catalina/connector/Request.java"

     * @param URIConverter the new URI converter
======= 18c0edc:"java/org/apache/catalina/connector/Request.java"

                // Error valve will pick this exception up and display it to user
======= 18c0edc:"java/org/apache/catalina/connector/Request.java"

                // Error valve will pick this exception up and display it to user
======= 18c0edc:"java/org/apache/catalina/connector/Request.java"

     * Set the set of cookies received with this Request.
======= 18c0edc:"java/org/apache/catalina/connector/Request.java"

        // Identify the Realm we will use for checking role assignments
======= 18c0edc:"java/org/apache/catalina/connector/RequestFacade.java"

         * in place, so that performance won't suffer in the non-secure case
======= 18c0edc:"java/org/apache/catalina/connector/RequestFacade.java"

         * in place, so that performance won't suffer in the non-secure case
======= 18c0edc:"java/org/apache/catalina/connector/Response.java"

     * @param charset String containing the name of the character encoding.
======= 18c0edc:"java/org/apache/catalina/connector/Response.java"

        //from the appendCookieValue invocation
======= 18c0edc:"java/org/apache/catalina/deploy/ContextService.java"

     * The instantiation of the handler have to be done.
======= 18c0edc:"java/org/apache/catalina/filters/WebdavFixFilter.java"

 *   <li>Canceling the first authentication dialog box and then trying to
======= 18c0edc:"java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java"

 * authenticates to one web application is propagated to other web applications and
======= 18c0edc:"java/org/apache/catalina/ha/backend/CollectedInfo.java"

 * send the muticast message using the format...
======= 18c0edc:"java/org/apache/catalina/ha/backend/HeartbeatListener.java"

 * send the muticast message using the format...
======= 18c0edc:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     * Modification from watchDir war detected!
======= 18c0edc:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

     * War remove from watchDir
======= 18c0edc:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

     * The number of the last message processed. Message IDs are 1 based.
======= 18c0edc:"java/org/apache/catalina/ha/deploy/WarWatcher.java"

     * check for modification and send notification to listener
======= 18c0edc:"java/org/apache/catalina/ha/session/DeltaManager.java"

     * Set the maximum number of active Sessions allowed, or -1 for no limit.
======= 18c0edc:"java/org/apache/catalina/ha/session/DeltaManager.java"

     * FIXME replace currently sessions with same id without notification.
======= 18c0edc:"java/org/apache/catalina/ha/session/DeltaManager.java"

     * Expire all find sessions.
======= 18c0edc:"java/org/apache/catalina/ha/session/DeltaRequest.java"

 * a request is executed. These actions will then translate into invocations of methods 
======= 18c0edc:"java/org/apache/catalina/ha/session/DeltaSession.java"

     * Last time the session was replicated, used for distributed expiring of
======= 18c0edc:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

 * nodes. After all that, the session stickiness will work directly to the
======= 18c0edc:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

     * get name of failed request session attribute
======= 18c0edc:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

     * Handle jvmRoute stickiness after tomcat instance failed. After this
     * SessionID change propagate to the other cluster nodes.
======= 18c0edc:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

        // FIXME: setId trigger session Listener, but only chance to register manager with correct id!
======= 18c0edc:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

            // now sending the change to all other clusternodes!
======= 18c0edc:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

        // set original sessionid at request, to allow application detect the
======= 18c0edc:"java/org/apache/catalina/ha/session/SessionMessageImpl.java"

     * @return the event type in a string representation, useful for debugging
======= 18c0edc:"java/org/apache/catalina/ha/tcp/ReplicationValve.java"

     * reset the active statistics 
======= 18c0edc:"java/org/apache/catalina/ha/tcp/ReplicationValve.java"

     * @param request current request after response is generated
======= 18c0edc:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

     * emit Failure Event to LifecylceListener
     *            received Message
======= 18c0edc:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * <code>URL</code> referring to it, or <code>null</code> if this resource
======= 18c0edc:"java/org/apache/catalina/loader/WebappClassLoader.java"

     * Validate a classname. As per SRV.9.7.2, we must restrict loading of 
======= 18c0edc:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

     * @param path Context path of the application to be undeployed
======= 18c0edc:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    // limited number of substitutions MessageFormat can process
    // (maximum of 10).
======= 18c0edc:"java/org/apache/catalina/manager/JMXProxyServlet.java"

                // can't be null - I think
======= 18c0edc:"java/org/apache/catalina/manager/ManagerServlet.java"

     * @param idle Expire all sessions with idle time &gt; idle for this context
======= 18c0edc:"java/org/apache/catalina/manager/host/HTMLHostManagerServlet.java"

    // limited number of substitutions MessageFormat can process
    // (maximum of 10).
======= 18c0edc:"java/org/apache/catalina/manager/util/SessionUtils.java"

     * JSF check the browser meta tag "accept languages" to choose what language to display.
======= 18c0edc:"java/org/apache/catalina/mbeans/ContextEnvironmentMBean.java"

        // cannot use side-effects.  It's removed and added back each time 
======= 18c0edc:"java/org/apache/catalina/mbeans/ContextResourceLinkMBean.java"

        // cannot use side-effects.  It's removed and added back each time 
======= 18c0edc:"java/org/apache/catalina/mbeans/ContextResourceMBean.java"

        // cannot use side-effects.  It's removed and added back each time 
======= 18c0edc:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * @param contextName MBean Name of the component to remove
======= 18c0edc:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * @param name MBean Name of the component to remove
======= 18c0edc:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * @param name MBean Name of the component to remove
======= 18c0edc:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * @param name MBean Name of the component to remove
======= 18c0edc:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * @param name MBean Name of the component to remove
======= 18c0edc:"java/org/apache/catalina/mbeans/MBeanFactory.java"

     * @param name MBean Name of the component to remove
======= 18c0edc:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

     * Semicolon separated list of paths containing MBean descriptor resources.
======= 18c0edc:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        // Create the MBean for the Connector itself
======= 18c0edc:"java/org/apache/catalina/realm/DataSourceRealm.java"

======= 18c0edc:"java/org/apache/catalina/realm/DataSourceRealm.java"

     * The column in the user table that holds the user's credentials
======= 18c0edc:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

     * @param qop           Quality of protection applied to the message
======= 18c0edc:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

     * Quality of protection applied to the message.
======= 18c0edc:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

     * {@link TextInputCallback} is used to pass the various additional
======= 18c0edc:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

 *     "catalina.base" system property) or absolute pathname to the
======= 18c0edc:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

     * <code>null</code> if validation failed.
======= 18c0edc:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

     * @return <code>true</code> in all cases because the
======= 18c0edc:"java/org/apache/catalina/realm/JAASRealm.java"

 * <p>Implementation of <b>Realm</b> that authenticates users via the <em>Java
======= 18c0edc:"java/org/apache/catalina/realm/JAASRealm.java"

 * <li>As this Realm iterates over the <code>Principals</code> returned by
======= 18c0edc:"java/org/apache/catalina/realm/JAASRealm.java"

     * @param qop           Quality of protection applied to the message
======= 18c0edc:"java/org/apache/catalina/realm/JDBCRealm.java"

======= 18c0edc:"java/org/apache/catalina/realm/JDBCRealm.java"

     * The column in the user table that holds the user's credentials
======= 18c0edc:"java/org/apache/catalina/realm/JDBCRealm.java"

        // Number of tries is the number of attempts to connect to the database
        // This needs rewritten with better pooling support, the existing code
======= 18c0edc:"java/org/apache/catalina/realm/JDBCRealm.java"

        // Number of tries is the number of attempts to connect to the database
        // This needs rewritten with better pooling support, the existing code
======= 18c0edc:"java/org/apache/catalina/realm/JDBCRealm.java"

        // Number of tries is the number of attempts to connect to the database
======= 18c0edc:"java/org/apache/catalina/realm/JNDIRealm.java"

            // Occasionally the directory context will timeout.  Try one more
======= 18c0edc:"java/org/apache/catalina/realm/LockOutRealm.java"

 * associated user storage mechanisms. It achieves this by recording all failed
======= 18c0edc:"java/org/apache/catalina/realm/RealmBase.java"

        // Should be overridden in JAASRealm - to avoid pretty inefficient conversions
======= 18c0edc:"java/org/apache/catalina/security/SecurityUtil.java"

     * @param targetType <code>Class</code> array used to instantiate a
======= 18c0edc:"java/org/apache/catalina/security/SecurityUtil.java"

     * @param targetType <code>Class</code> array used to instantiate a 
======= 18c0edc:"java/org/apache/catalina/security/SecurityUtil.java"

     * @param targetType <code>Class</code> array used to instantiate a
======= 18c0edc:"java/org/apache/catalina/security/SecurityUtil.java"

     * @param targetType <code>Class</code> array used to instantiate a
======= 18c0edc:"java/org/apache/catalina/security/SecurityUtil.java"

     * @param targetType <code>Class</code> array used to instantiate a 
======= 18c0edc:"java/org/apache/catalina/servlets/CGIServlet.java"

 * <b>Metavariable Values</b>: According to the CGI specification,
======= 18c0edc:"java/org/apache/catalina/servlets/CGIServlet.java"

 * supplied to the script are precisely as supplied by the client and
======= 18c0edc:"java/org/apache/catalina/servlets/CGIServlet.java"

         * script; relies heavily on Servlet API methods and findCGI
         *           Invocation
======= 18c0edc:"java/org/apache/catalina/servlets/CGIServlet.java"

     * passed to the constructor.
======= 18c0edc:"java/org/apache/catalina/servlets/CGIServlet.java"

         *                  parameters as strings
======= 18c0edc:"java/org/apache/catalina/servlets/DefaultServlet.java"

     * @param path Path which has to be rewritten
======= 18c0edc:"java/org/apache/catalina/servlets/WebdavServlet.java"

     * Propfind helper method. Displays the properties of a lock-null resource.
======= 18c0edc:"java/org/apache/catalina/servlets/WebdavServlet.java"

    // This one collides with HTTP 1.1
    // "207 Partial Update OK"
======= 18c0edc:"java/org/apache/catalina/servlets/WebdavServlet.java"

    // This one collides with HTTP 1.1
======= 18c0edc:"java/org/apache/catalina/servlets/WebdavServlet.java"

    // This one collides with HTTP 1.1
======= 18c0edc:"java/org/apache/catalina/servlets/WebdavServlet.java"

        // HTTP 1.0 status Code
======= 18c0edc:"java/org/apache/catalina/session/JDBCStore.java"

     * @return <code>Connection</code> if the connection succeeded
======= 18c0edc:"java/org/apache/catalina/session/PersistentManagerBase.java"

 * persistence, even if only for  restarts.
======= 18c0edc:"java/org/apache/catalina/session/PersistentManagerBase.java"

     * Set the maximum number of active Sessions allowed, or -1 for
======= 18c0edc:"java/org/apache/catalina/session/StandardManager.java"

     * Set the maximum number of active Sessions allowed, or -1 for
======= 18c0edc:"java/org/apache/catalina/ssi/ExpressionParseTree.java"

                    // Similar strategy to NOT_EQ above, except this
                    // Similar strategy to NOT_EQ above, except this
======= 18c0edc:"java/org/apache/catalina/ssi/SSIFsize.java"

    //We try to mimic Apache here, as we do everywhere
======= 18c0edc:"java/org/apache/catalina/ssi/SSIServletExternalResolver.java"

            //cut off file name
======= 18c0edc:"java/org/apache/catalina/ssi/SSIStopProcessingException.java"

 * commands. This is used to mimic the Apache behavior in #set with invalid
======= 18c0edc:"java/org/apache/catalina/tribes/Channel.java"

 *    registering a <code>MembershipListener</code><br>
======= 18c0edc:"java/org/apache/catalina/tribes/Channel.java"

     * SEND_OPTIONS_BYTE_MESSAGE - The message is a pure byte message and no marshaling or unmarshaling will
======= 18c0edc:"java/org/apache/catalina/tribes/ChannelListener.java"

 * was processed by an above application or if it was just received and forgot about, a feature required
======= 18c0edc:"java/org/apache/catalina/tribes/Heartbeat.java"

     * Heartbeat invocation for resources cleanup etc
======= 18c0edc:"java/org/apache/catalina/tribes/Member.java"

     * @return the listen port for this member, -1 if its not listening on an insecure port
======= 18c0edc:"java/org/apache/catalina/tribes/UniqueId.java"

 * <p>Title: Represents a globally unique Id</p>
======= 18c0edc:"java/org/apache/catalina/tribes/group/GroupChannel.java"

     * The first interceptor in the interceptor stack.
======= 18c0edc:"java/org/apache/catalina/tribes/group/GroupChannel.java"

     * sleep in between invocations of <code>Channel.heartbeat()</code>
======= 18c0edc:"java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java"

 * except it uses an atomic long for the currentSize calculation
======= 18c0edc:"java/org/apache/catalina/tribes/io/ObjectReader.java"

     * @return number of messages that was sent to callback
======= 18c0edc:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

                 * On some platforms (e.g. Linux) it is not possible to bind
======= 18c0edc:"java/org/apache/catalina/tribes/transport/PooledSender.java"

        // no op, senders created upon demands
======= 18c0edc:"java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java"

     * send a reply-acknowledgment (6,2,3)
======= 18c0edc:"java/org/apache/catalina/tribes/transport/bio/BioSender.java"

     * After successful sending update stats
     * WARNING: Subclasses must be very careful that only one thread call this pushMessage at once!!!
======= 18c0edc:"java/org/apache/catalina/tribes/transport/bio/BioSender.java"

     * Wait for Acknowledgment from other server
     * FIXME Please, not wait only for three characters, better control that the wait ack message is correct.
======= 18c0edc:"java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java"

 * length when you have strange producer thread problems.
======= 18c0edc:"java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java"

     * limit the queue length ( default is unlimited)
======= 18c0edc:"java/org/apache/catalina/tribes/transport/nio/NioSender.java"

                //we have written everything, or we are starting a new package
======= 18c0edc:"java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java"

                //timeout has occurred
======= 18c0edc:"java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java"

        //clean up any canceled keys
======= 18c0edc:"java/org/apache/catalina/users/MemoryUserDatabase.java"

     * The relative or absolute pathname of the file in which we write
======= 18c0edc:"java/org/apache/catalina/util/Base64.java"

     * Encodes hex octets into Base64.
======= 18c0edc:"java/org/apache/catalina/util/Base64.java"

     * Decodes Base64 data into octets
======= 18c0edc:"java/org/apache/catalina/util/DateTool.java"

     * US locale - all HTTP dates are in English
======= 18c0edc:"java/org/apache/catalina/util/ExtensionValidator.java"

 * Ensures that all extension dependencies are resolved for a WEB application
 * application and then validates those extensions.
======= 18c0edc:"java/org/apache/catalina/util/ExtensionValidator.java"

     * Runtime validation of a Web Application.
======= 18c0edc:"java/org/apache/catalina/util/ExtensionValidator.java"

        // Find the Manifest for the Web Application
======= 18c0edc:"java/org/apache/catalina/util/ExtensionValidator.java"

     * This method should also provide static validation of a Web Application 
======= 18c0edc:"java/org/apache/catalina/util/ExtensionValidator.java"

                // check the application itself for the extension
======= 18c0edc:"java/org/apache/catalina/util/IOTools.java"

     * @param buf the char array to use as a buffer
======= 18c0edc:"java/org/apache/catalina/util/ManifestResource.java"

     * Convenience method to check if this <code>ManifestResource</code>
======= 18c0edc:"java/org/apache/catalina/util/ParameterMap.java"

     * @param map Map whose contents are duplicated in the new map
======= 18c0edc:"java/org/apache/catalina/util/RequestUtil.java"

     * Convert a byte character value to hexadecimal digit value.
======= 18c0edc:"java/org/apache/catalina/util/SchemaResolver.java"

     * The digester instance for which this class is the entity resolver.
======= 18c0edc:"java/org/apache/catalina/util/SchemaResolver.java"

     * all remote dtds and schema to a local destination.
======= 18c0edc:"java/org/apache/catalina/util/Strftime.java"

        //translate.put("s","seconds since epoch");
======= 18c0edc:"java/org/apache/catalina/util/Strftime.java"

        //translate.put("U","week in year with first Sunday as first day...");
        //translate.put("W","week in year with first Monday as first day...");
======= 18c0edc:"java/org/apache/catalina/valves/AccessLogValve.java"

     * performing conditional logging. If null, every
======= 18c0edc:"java/org/apache/catalina/valves/AccessLogValve.java"

                 * not encounter a closing } - then I ignore the {
======= 18c0edc:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

     * List of current Comet connections.
======= 18c0edc:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

            // Track the connection for webapp reload

======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceProxy.java"

    private Hashtable<String,QName> portComponentRef = null;
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceProxy.java"

        Class<?> serviceendpointClass = (Class<?>) args[1];
        for (Iterator<QName> ports = service.getPorts(); ports.hasNext();) {
            QName portName = ports.next();
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceProxy.java"

    public void setPortComponentRef(Hashtable<String,QName> portComponentRef) {
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceProxy.java"

        Class<?> serviceendpointClass = (Class<?>) args[0];
        QName portname = this.portComponentRef.get(serviceendpointClass.getName());
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

            Hashtable<?,?> environment)
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

            Hashtable<String,QName> portComponentRef =
                new Hashtable<String,QName>();
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

            Class<?> serviceInterfaceClass = null;
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                    Map<String,?> ports = wsdlservice.getPorts();
                    for (Iterator<String> i = ports.keySet().iterator(); i.hasNext();) {
                        String portName = i.next();
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

            Class<?>[] interfaces = null;
            Class<?>[] serviceInterfaces = serviceInterfaceClass.getInterfaces();
            interfaces = new Class[serviceInterfaces.length + 1];
            for (int i = 0; i < serviceInterfaces.length; i++) {
                interfaces[i] = serviceInterfaces[i];
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                ArrayList<String> soaproles = new ArrayList<String>();
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                    Class<?> handlerClass = null;
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                    ArrayList<QName> headers = new ArrayList<QName>();
                    Hashtable<String,String> config = new Hashtable<String,String>();
                    ArrayList<String> portNames = new ArrayList<String>();
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

                    handlerref.setHeaders(headers.toArray(new QName[headers.size()]));
                        Iterator<String> iter = portNames.iterator();
                            initHandlerChain(new QName(iter.next()), handlerRegistry,
                        Enumeration<QName> e = portComponentRef.elements();
                            initHandlerChain(e.nextElement(), handlerRegistry,
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

        List<ExtensibilityElement> extensions = port.getExtensibilityElements();
        for (Iterator<ExtensibilityElement> i = extensions.iterator();
                i.hasNext();) {
            ExtensibilityElement ext = i.next();
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

            HandlerInfo handlerref, ArrayList<String> soaprolesToAdd) {
======= 97ccffd:"java/org/apache/naming/factory/webservices/ServiceRefFactory.java"

            soaproles[i+j] = soaprolesToAdd.get(j);

======= 9204e4d:"java/org/apache/catalina/core/ApplicationDispatcher.java"

     * called servlet will be propagated to the caller.
======= 9204e4d:"java/org/apache/catalina/core/ApplicationDispatcher.java"

            // Servlet SRV.6.2.2. The Request/Response may have been wrapped
======= 9204e4d:"java/org/apache/catalina/core/ApplicationDispatcher.java"

     * called servlet will be propagated to the caller.
======= 9204e4d:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

 * Factory for the creation and caching of Filters and creation 
======= 9204e4d:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

     * Prevent instantiation outside of the getInstanceMethod().
======= 9204e4d:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

     * Return the factory instance.
======= 9204e4d:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

     * Convenience method which returns true if  the dispatcher type
======= 9204e4d:"java/org/apache/catalina/core/ApplicationHttpRequest.java"

     * If this request is cross context, since this changes session access
======= 9204e4d:"java/org/apache/catalina/core/ContainerBase.java"

     * @exception IllegalArgumentException if the specified Valve refuses to be
======= 9204e4d:"java/org/apache/catalina/core/ContainerBase.java"

     * Valve for this Pipeline (if any).  Prior to setting the basic Valve,
======= 9204e4d:"java/org/apache/catalina/core/ContainerBase.java"

     * Return the abbreviated name of this container for logging messages
======= 9204e4d:"java/org/apache/catalina/core/StandardContext.java"

     * before the mappings in the deployment descriptor but must be inserted in
======= 9204e4d:"java/org/apache/catalina/core/StandardContext.java"

     * @param docBase The original document root
======= 9204e4d:"java/org/apache/catalina/core/StandardEngine.java"

    /** Allow the base dir to be specified explicitly for
======= 9204e4d:"java/org/apache/catalina/core/StandardEngine.java"

        // This can be overridden at engine, context and host level  
======= 9204e4d:"java/org/apache/catalina/core/StandardEngine.java"

            // for consistency...: we are probably in embedded mode
======= 9204e4d:"java/org/apache/catalina/core/StandardHost.java"

     * Attribute value used to turn on/off XML namespace awareness.
======= 9204e4d:"java/org/apache/catalina/core/StandardHost.java"

     * that this host's child webapps should be discovered and automatically 
======= 9204e4d:"java/org/apache/catalina/core/StandardHost.java"

     * @return true if namespace awareness is enabled.
======= 9204e4d:"java/org/apache/catalina/core/StandardHost.java"

      * Return the MBean Names of the Valves associated with this Host
======= 9204e4d:"java/org/apache/catalina/core/StandardPipeline.java"

     * Valve for this Pipeline (if any).  Prior to setting the basic Valve,
======= 9204e4d:"java/org/apache/catalina/core/StandardPipeline.java"

     * @exception IllegalArgumentException if the specified Valve refuses to be
======= 9204e4d:"java/org/apache/catalina/core/StandardPipeline.java"

            // Unregister the removed valve
======= 9204e4d:"java/org/apache/catalina/core/StandardService.java"

        // FIXME pero -- Why container stop first? KeepAlive connections can send request! 
======= 9204e4d:"java/org/apache/catalina/core/StandardService.java"

            // backward compat, nobody should bother to load it explicitly
======= 9204e4d:"java/org/apache/catalina/core/StandardService.java"

        // Service shouldn't be used with embedded, so it doesn't matter
======= 9204e4d:"java/org/apache/catalina/core/StandardWrapperFacade.java"

     * Create a new facade around a StandardWrapper.
======= 9204e4d:"java/org/apache/catalina/core/StandardWrapperValve.java"

    // Some JMX statistics. This valve is associated with a StandardWrapper.

======= a3fa5d3:"java/javax/servlet/ServletContext.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/ServletContext.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/ServletContext.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/ServletContext.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/ServletRequest.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/ServletRequestWrapper.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/SingleThreadModel.java"

======= a3fa5d3:"java/javax/servlet/UnavailableException.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/UnavailableException.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/UnavailableException.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpServletRequest.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpServletRequestWrapper.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpServletResponse.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpServletResponse.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpServletResponse.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpServletResponseWrapper.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpServletResponseWrapper.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpServletResponseWrapper.java"

     @Deprecated
    public void setStatus(int sc, String sm) {
======= a3fa5d3:"java/javax/servlet/http/HttpSession.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpSession.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpSession.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpSession.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpSession.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpSessionContext.java"

======= a3fa5d3:"java/javax/servlet/http/HttpSessionContext.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpSessionContext.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/http/HttpUtils.java"

======= a3fa5d3:"java/javax/servlet/jsp/JspException.java"

    @Deprecated
======= a3fa5d3:"java/javax/servlet/jsp/el/ELException.java"

======= a3fa5d3:"java/javax/servlet/jsp/el/ELParseException.java"

======= a3fa5d3:"java/javax/servlet/jsp/el/Expression.java"

======= a3fa5d3:"java/javax/servlet/jsp/el/ExpressionEvaluator.java"

======= a3fa5d3:"java/javax/servlet/jsp/el/FunctionMapper.java"

======= a3fa5d3:"java/javax/servlet/jsp/el/VariableResolver.java"

======= a3fa5d3:"java/javax/servlet/jsp/tagext/BodyTag.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/Cluster.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/Cluster.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/Manager.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/connector/Request.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/connector/Request.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/connector/Response.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/connector/Response.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/connector/Response.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/ApplicationContext.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/ApplicationContext.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/ApplicationContext.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/ApplicationContext.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/ApplicationContextFacade.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/ApplicationHttpResponse.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/DummyRequest.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/DummyRequest.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/DummyResponse.java"

    @Deprecated
    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/core/DummyResponse.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/ha/session/DeltaSession.java"

======= a3fa5d3:"java/org/apache/catalina/ha/session/DeltaSession.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/ha/session/DeltaSession.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/realm/JAASRealm.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/ManagerBase.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/StandardSession.java"

======= a3fa5d3:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/StandardSession.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/StandardSessionFacade.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/StandardSessionFacade.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/StandardSessionFacade.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/StandardSessionFacade.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/session/StandardSessionFacade.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/startup/Catalina.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/startup/Catalina.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/io/XByteBuffer.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/membership/McastService.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/el/parser/SimpleCharStream.java"

  @Deprecated
======= a3fa5d3:"java/org/apache/el/parser/SimpleCharStream.java"

  @Deprecated
======= a3fa5d3:"java/org/apache/jasper/servlet/JspCServletContext.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/jasper/servlet/JspCServletContext.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/jasper/servlet/JspCServletContext.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/jasper/servlet/JspCServletContext.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/naming/resources/ResourceAttributes.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/tomcat/util/digester/Rule.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/tomcat/util/digester/Rule.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/tomcat/util/digester/Rule.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/tomcat/util/digester/SetNextRule.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/tomcat/util/digester/SetNextRule.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/tomcat/util/digester/SetPropertiesRule.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/tomcat/util/digester/SetPropertyRule.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/tomcat/util/digester/SetRootRule.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/tomcat/util/digester/SetRootRule.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/tomcat/util/digester/SetTopRule.java"

    @Deprecated
======= a3fa5d3:"java/org/apache/tomcat/util/digester/SetTopRule.java"

    @Deprecated

======= 363b79a:"java/org/apache/catalina/startup/WebRuleSet.java"

     * matching pattern prefix and default fragment setting.
======= 363b79a:"java/org/apache/catalina/startup/WebRuleSet.java"

 * Rule to check that the <code>login-config</code> is occurring 
======= 363b79a:"java/org/apache/catalina/startup/WebRuleSet.java"

 * Rule to check that the <code>jsp-config</code> is occurring 
======= 363b79a:"java/org/apache/catalina/startup/WebRuleSet.java"

 * Rule to check that the <code>session-config</code> is occurring 

======= 5d9f68b:"java/org/apache/catalina/startup/TldConfig.java"

     * Attribute value used to turn on/off TLD  namespace awareness.
======= 5d9f68b:"java/org/apache/catalina/startup/TldConfig.java"

     * @return true if namespace awareness is enabled.

======= 7508847:"java/org/apache/catalina/startup/SetNextNamingRule.java"

     *  (if you wish to use a primitive type, specify the corresponding

======= b6df018:"java/org/apache/catalina/startup/ContextConfig.java"

        // Removing security role
======= b6df018:"java/org/apache/catalina/startup/ContextConfig.java"

     *                  segments) to read

======= 07e5982:"java/org/apache/catalina/startup/HostConfig.java"

     * Attribute value used to turn on/off XML namespace awareness.
======= 07e5982:"java/org/apache/catalina/startup/HostConfig.java"

     * @return true if namespace awareness is enabled.
======= 07e5982:"java/org/apache/catalina/startup/HostConfig.java"

     * Set the namespace-aware feature of the XML parser used when
======= 07e5982:"java/org/apache/catalina/startup/HostConfig.java"

     * <code>false</code> if the application has not been deployed or does not
======= 07e5982:"java/org/apache/catalina/startup/HostConfig.java"

     * Entry point for the admin webapp, and other JMX Context controllers.
======= 07e5982:"java/org/apache/catalina/startup/HostConfig.java"

     * Entry point for the admin webapp, and other JMX Context controllers.

======= ae16eb2:"java/org/apache/catalina/startup/Embedded.java"

     * Return true if redirection of standard streams is enabled.
======= ae16eb2:"java/org/apache/catalina/startup/Embedded.java"

     * If tomcat is embedded in an application that already defines those -

======= 6908b18:"java/org/apache/catalina/ant/jmx/JMXAccessorTask.java"

                project.log("wrong object reference " + refId + " - "
======= 6908b18:"java/org/apache/catalina/tribes/transport/bio/BioReceiver.java"

 * @version $Revision$ $Date$
======= 6908b18:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

        String remoteHost;
        String user = request.getRemoteUser();
        String query=request.getRequestURI();
======= 6908b18:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

        if (pattern.equals("combined")) {
======= 6908b18:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"

                            sk.cancel();
======= 6908b18:"java/org/apache/tomcat/util/net/NioBlockingSelector.java"


======= c060034:"java/org/apache/catalina/startup/Bootstrap.java"

 * Bootstrap loader for Catalina.  This application constructs a class loader
======= c060034:"java/org/apache/catalina/startup/Bootstrap.java"

     * Stop the standalone server.
======= c060034:"java/org/apache/catalina/startup/Bootstrap.java"

     * Stop the standalone server.

======= 481cfe9:"java/org/apache/catalina/startup/Catalina.java"

 * <li><b>-help</b>      - Display usage information.
 * <li><b>-nonaming</b>  - Disable naming support.
 * <li><b>-start</b>     - Start an instance of Catalina.
 * <li><b>-stop</b>      - Stop the currently running instance of Catalina.
======= 481cfe9:"java/org/apache/catalina/startup/Catalina.java"

             + " [ -nonaming ] "
             + " { -help | start | stop }");

======= 3ef0f21:"java/org/apache/catalina/startup/Bootstrap.java"

                args[args.length - 1] = "start";
                args[args.length - 1] = "stop";

======= f3b04b4:"java/org/apache/jasper/compiler/Validator.java"

                    // JSP.2.2 - '#{' not allowed in template text
                    String value = attrs.getValue(i);
                    if (!pageInfo.isDeferredSyntaxAllowedAsLiteral()) {
                        if (containsDeferredSyntax(value)) {
                            err.jspError(n, "jsp.error.el.template.deferred");
                        }
                    }
                            attrs.getURI(i), attrs.getLocalName(i), value, n,
                            false);
======= f3b04b4:"java/org/apache/jasper/compiler/Validator.java"

        /*
         * Look for a #{ sequence that isn't preceded by \.
         */
        private boolean containsDeferredSyntax(String value) {
            if (value == null) {
                return false;
            }
            
            int i = 0;
            int len = value.length();
            boolean prevCharIsEscape = false;
            while (i < value.length()) {
                char c = value.charAt(i);
                if (c == '#' && (i+1) < len && value.charAt(i+1) == '{' && !prevCharIsEscape) {
                    return true;
                } else if (c == '\\') {
                    prevCharIsEscape = true;
                } else {
                    prevCharIsEscape = false;
                }
                i++;
            }
            return false;
        }
======= f3b04b4:"java/org/apache/jasper/compiler/Validator.java"

                                    // The String literal must be castable to what is declared as type

======= 14084ac:"java/org/apache/catalina/connector/Response.java"

        if (name == null || name.length() == 0) {
            return;
        }
======= 14084ac:"java/org/apache/catalina/connector/Response.java"

        if (name == null || name.length() == 0 || value == null) {
            return;
        }
======= 14084ac:"java/org/apache/catalina/connector/Response.java"

        if (name == null || name.length() == 0) {
            return;
        }
======= 14084ac:"java/org/apache/catalina/connector/Response.java"

        if (name == null || name.length() == 0) {
            return;
        }
======= 14084ac:"java/org/apache/catalina/connector/Response.java"

        if (name == null || name.length() == 0 || value == null) {
            return;
        }
======= 14084ac:"java/org/apache/catalina/connector/Response.java"

        if (name == null || name.length() == 0) {
            return;
        }

======= 7fc56b4:"java/org/apache/catalina/connector/Request.java"

     * empty <code>Enumeration</code> if there are none. Note that the attribute
     * names return will only be those for the attributes set via
     * {@link #setAttribute(String, Object)}. Tomcat internal attributes will
     * not be included although they are accessible via
     * {@link #getAttribute(String)}. The Tomcat internal attributes include:
     * <ul>
     * <li>{@link Globals.DISPATCHER_TYPE_ATTR}</li>
     * <li>{@link Globals.DISPATCHER_REQUEST_PATH_ATTR}</li>
     * <li>{@link Globals.ASYNC_SUPPORTED_ATTR}</li>
     * <li>{@link Globals.CERTIFICATES_ATTR} (SSL connections only)</li>
     * <li>{@link Globals.CIPHER_SUITE_ATTR} (SSL connections only)</li>
     * <li>{@link Globals.KEY_SIZE_ATTR} (SSL connections only)</li>
     * <li>{@link Globals.SSL_SESSION_ID_ATTR} (SSL connections only)</li>
     * <li>{@link Globals.SSL_SESSION_MGR_ATTR} (SSL connections only)</li>
     * </ul>
     * The underlying connector may also expose request attributes. These all
     * have names starting with "org.apache.tomcat" and include:
     * <ul>
     * <li>org.apache.tomcat.sendfile.support</li>
     * <li>org.apache.tomcat.comet.support</li>
     * <li>org.apache.tomcat.comet.timeout.support</li>
     * </ul>
     * Connector implementations may return some, all or none of these
     * attributes and may also support additional attributes.

======= d55f1d9:"java/org/apache/catalina/startup/HostConfig.java"

                // There is a chance the the resource was only missing
                // temporarily eg renamed during a text editor save
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e1) {
                    // Ignore
                }
                // Recheck the resource to see if it was really deleted
                if (resource.exists()) {
                    continue;
                }

======= deac657:"java/org/apache/jasper/compiler/Parser.java"

                // Comment
                reader.skipUntil("--%>");
            } else if (reader.matches("%!")) {
                // Declaration
                reader.skipUntil("%>");
            } else if (reader.matches("%=")) {
                // Expression
                reader.skipUntil("%>");
            } else if (reader.matches("%")) {
                // Scriptlet
                reader.skipUntil("%>");

======= 99f01fd:"java/org/apache/catalina/manager/Constants.java"

        org.apache.catalina.util.TomcatCSS.TOMCAT_CSS + "\n" +
======= 99f01fd:"java/org/apache/catalina/manager/Constants.java"

        "  form {\n" +
        "    margin: 1;\n" +
        "  }\n" +
        "  form.inline {\n" +
        "    display: inline;\n" +
        "  }\n" +
======= 99f01fd:"java/org/apache/catalina/manager/Constants.java"

        "<table cellspacing=\"4\" border=\"0\">\n" +
======= 99f01fd:"java/org/apache/catalina/manager/Constants.java"

        "<table cellspacing=\"4\" border=\"0\">\n" +
======= 99f01fd:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= 99f01fd:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= 99f01fd:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        } else if (command.equals("/upload") || command.equals("/deploy") ||
                command.equals("/reload") || command.equals("/undeploy") ||
                command.equals("/expire") || command.equals("/start") ||
                command.equals("/stop")) {
            message =
                sm.getString("managerServlet.postCommand", command);
======= 99f01fd:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        String path = request.getParameter("path");
        String deployPath = request.getParameter("deployPath");
        String deployConfig = request.getParameter("deployConfig");
        String deployWar = request.getParameter("deployWar");
        String message = "";
        if (command == null || command.length() == 0) {
            // No command == list
            // List always displayed -> do nothing
        } else if (command.equals("/upload")) {
            message = upload(request);
        } else if (command.equals("/deploy")) {
            message = deployInternal(deployConfig, deployPath, deployWar);
        } else if (command.equals("/reload")) {
            message = reload(path);
        } else if (command.equals("/undeploy")) {
            message = undeploy(path);
        } else if (command.equals("/expire")) {
            message = expireSessions(path, request);
        } else if (command.equals("/start")) {
            message = start(path);
        } else if (command.equals("/stop")) {
            message = stop(path);
        } else {
            // Try GET
            doGet(request,response);
            return;
        }
======= 99f01fd:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  &nbsp;<small>{1}</small>&nbsp;\n" +
        "  <form class=\"inline\" method=\"POST\" action=\"{2}\"><small><input type=\"submit\" value=\"{3}\"></small></form>\n" +
        "  <form class=\"inline\" method=\"POST\" action=\"{4}\"><small><input type=\"submit\" value=\"{5}\"></small></form>\n" +
        "  <form class=\"inline\" method=\"POST\" action=\"{6}\"><small><input type=\"submit\" value=\"{7}\"></small></form>\n" +
======= 99f01fd:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  <form class=\"inline\" method=\"POST\" action=\"{0}\"><small><input type=\"submit\" value=\"{1}\"></small></form>\n" +
        "  &nbsp;<small>{3}</small>&nbsp;\n" +
        "  &nbsp;<small>{5}</small>&nbsp;\n" +
        "  <form class=\"inline\" method=\"POST\" action=\"{6}\"><small><input type=\"submit\" value=\"{7}\"></small></form>\n" +
        "  &nbsp;<small>{1}</small>&nbsp;\n" +
        "  <form class=\"inline\" method=\"POST\" action=\"{2}\"><small><input type=\"submit\" value=\"{3}\"></small></form>\n" +
        "  <form class=\"inline\" method=\"POST\" action=\"{4}\"><small><input type=\"submit\" value=\"{5}\"></small></form>\n" +
        "  &nbsp;<small>{7}</small>&nbsp;\n" +
        "  <form class=\"inline\" method=\"POST\" action=\"{0}\"><small><input type=\"submit\" value=\"{1}\"></small></form>\n" +
        "  &nbsp;<small>{3}</small>&nbsp;\n" +
        "  &nbsp;<small>{5}</small>&nbsp;\n" +
        "  &nbsp;<small>{7}</small>&nbsp;\n" +

======= 0f99904:"java/org/apache/catalina/connector/CoyoteAdapter.java"

======= 0f99904:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            // What encoding to use? Some platforms, eg z/os, use a default
            // encoding that doesn't give the expected result so be explicit 
            String enc = connector.getURIEncoding();
            if (enc == null) {
                enc = "ISO-8859-1";
            }
======= 0f99904:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            try {
                if (semicolon2 >= 0) {
                    request.setRequestedSessionId
                        (new String(uriBC.getBuffer(), start + sessionIdStart,
                                semicolon2 - sessionIdStart, enc));
                    // Extract session ID from request URI
                    byte[] buf = uriBC.getBuffer();
                    for (int i = 0; i < end - start - semicolon2; i++) {
                        buf[start + semicolon + i] 
                            = buf[start + i + semicolon2];
                    }
                    uriBC.setBytes(buf, start,
                            end - start - semicolon2 + semicolon);
                } else {
                    request.setRequestedSessionId
                        (new String(uriBC.getBuffer(), start + sessionIdStart, 
                                (end - start) - sessionIdStart, enc));
                    uriBC.setEnd(start + semicolon);
                request.setRequestedSessionURL(true);
            } catch (UnsupportedEncodingException uee) {
                // Make sure no session ID is returned
                request.setRequestedSessionId(null);
                request.setRequestedSessionURL(false);
                log.warn(sm.getString("coyoteAdapter.parseSession", enc), uee);

======= 73bb9e4:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

            } catch (BindException orig) {
                String msg;
                    msg = orig.getMessage() + " <null>:" + getPort();
                    msg = orig.getMessage() + " " +
                            getAddress().toString() + ":" + getPort();
                BindException be = new BindException(msg);
                be.initCause(orig);
                throw be;

======= 189181a:"test/org/apache/catalina/startup/TestTomcat.java"

     * Simple servlet to test JNDI 
======= 189181a:"test/org/apache/catalina/startup/TestTomcat.java"

    /**
     * Servlet that tries to obtain a URL for WEB-INF/web.xml
     */
    public static class GetResource extends HttpServlet {
        
        private static final long serialVersionUID = 1L;
        
        public void doGet(HttpServletRequest req, HttpServletResponse res) 
        throws IOException {
            URL url = req.getServletContext().getResource("/WEB-INF/web.xml");
         
            res.getWriter().write("The URL obtained for /WEB-INF/web.xml was ");
            if (url == null) {
                res.getWriter().write("null");
            } else {
                res.getWriter().write(url.toString());
            }
        }
    }
    
======= 189181a:"test/org/apache/catalina/startup/TestTomcat.java"

        assertEquals("Hello world", res.toString());
======= 189181a:"test/org/apache/catalina/startup/TestTomcat.java"

        assertEquals("Hello, Tomcat User", res.toString());
     * Test for https://issues.apache.org/bugzilla/show_bug.cgi?id=47866
     */
    public void testGetResource() throws Exception {
        Tomcat tomcat = getTomcatInstance();
        
        // Must have a real docBase - just use temp
        StandardContext ctx = 
            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
        // You can customize the context by calling 
        // its API
        
        Tomcat.addServlet(ctx, "myServlet", new GetResource());
        ctx.addServletMapping("/", "myServlet");
        
        tomcat.start();
        
        int rc =getUrl("http://localhost:" + getPort() + "/", new ByteChunk(),
                null);
        assertEquals(HttpServletResponse.SC_OK, rc);
    }
    /**

======= a31d52f:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

                (path.getBuffer(), pathOffset, pathEnd-pathOffset);

======= aaf7b5d:"java/org/apache/tomcat/util/net/AbstractEndpoint.java"

    public int getMaxThreads() {
        if (running && executor!=null) {
            if (executor instanceof java.util.concurrent.ThreadPoolExecutor) {
                return ((java.util.concurrent.ThreadPoolExecutor)executor).getMaximumPoolSize();
            } else if (executor instanceof ResizableExecutor) {
                return ((ResizableExecutor)executor).getMaxThreads();
            } else {
                return -1;
            }
        } else {
            return maxThreads;
        }
    }
======= aaf7b5d:"java/org/apache/tomcat/util/threads/ResizableExecutor.java"

    public int getMaxThreads();

======= e9248d7:"java/org/apache/catalina/core/AprLifecycleListener.java"

    protected static final int TCN_REQUIRED_PATCH = 17;
    protected static final int TCN_RECOMMENDED_PV = 17;
======= e9248d7:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                    // certLength == -1 indicates an error
                    if (clientCert != null  && certLength > -1) {
======= e9248d7:"java/org/apache/coyote/http11/Http11AprProcessor.java"

                // Consume and buffer the request body, so that it does not
                // interfere with the client's handshake messages
                    // Configure connection to require a certificate
                    SSLSocket.setVerify(socket, SSL.SSL_CVERIFY_REQUIRE,
                            endpoint.getSSLVerifyDepth());
                    // Renegotiate certificates
                    if (SSLSocket.renegotiate(socket) == 0) {
                        // Don't look for certs unless we know renegotiation worked.
                        // Get client certificate and the certificate chain if present
                        // certLength == -1 indicates an error 
                        int certLength = SSLSocket.getInfoI(socket,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
                        byte[] clientCert = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT);
                        X509Certificate[] certs = null;
                        if (clientCert != null && certLength > -1) {
                            certs = new X509Certificate[certLength + 1];
                            CertificateFactory cf = CertificateFactory.getInstance("X.509");
                            certs[0] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(clientCert));
                            for (int i = 0; i < certLength; i++) {
                                byte[] data = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
                                certs[i+1] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data));
                            }
                        }
                        if (certs != null) {
                            request.setAttribute(AprEndpoint.CERTIFICATE_KEY, certs);
======= e9248d7:"java/org/apache/tomcat/jni/SSLSocket.java"

     * usually there is no acknowledgement step between the headers and the
======= e9248d7:"java/org/apache/tomcat/jni/SSLSocket.java"

     * Set Type of Client Certificate verification and Maximum depth of CA
     * Certificates in Client Certificate verification.
     * <br />
     * This is used to change the verification level for a connection prior to
     * starting a re-negotiation.
     * <br />
     * The following levels are available for level:
     * <PRE>
     * SSL_CVERIFY_NONE           - No client Certificate is required at all
     * SSL_CVERIFY_OPTIONAL       - The client may present a valid Certificate
     * SSL_CVERIFY_REQUIRE        - The client has to present a valid
     *                              Certificate
     * SSL_CVERIFY_OPTIONAL_NO_CA - The client may present a valid Certificate
     *                              but it need not to be (successfully)
     *                              verifiable
     * </PRE>
     * <br />
     * @param sock  The socket to change.
     * @param level Type of Client Certificate verification.
     */
    public static native void setVerify(long sock, int level, int depth);
    
    /**    
     * Return SSL Info parameter as byte array.
======= e9248d7:"java/org/apache/tomcat/jni/SSLSocket.java"

     * Return SSL Info parameter as String.
======= e9248d7:"java/org/apache/tomcat/jni/SSLSocket.java"

     * Return SSL Info parameter as integer.

======= 59e88f1:"java/org/apache/catalina/startup/Tomcat.java"

     * Controls if the loggers will be silenced or not.
     * @param silent    <code>true</code> sets the log level to WARN for the
     *                  loggers that log information on Tomcat start up. This
     *                  prevents the usual startup information being logged.
     *                  <code>false</code> sets the log level to the default
     *                  level of INFO.
    public void setSilent(boolean silent) {
            if (silent) {
                Logger.getLogger(s).setLevel(Level.WARNING);
            } else {
                Logger.getLogger(s).setLevel(Level.INFO);
            }

======= 6cce550:"java/org/apache/catalina/startup/Tomcat.java"

======= 6cce550:"java/org/apache/catalina/startup/Tomcat.java"

     *    
     * @param contextPath   Context to add Servlet to
     * @param servletName   Servlet name (used in mappings)
     * @param servletClass  The class to be used for the Servlet
     * @return The wrapper for the servlet
     */
    public StandardWrapper addServlet(String contextPath, 
            String servletName, 
            String servletClass) {
        Container ctx = getHost().findChild(contextPath);
        return addServlet((StandardContext) ctx, 
                servletName, servletClass);
    }
    /**
     * Static version of {@link #addServlet(String, String, String)
     * @param ctx           Context to add Servlet to
     * @param servletName   Servlet name (used in mappings)
     * @param servletClass  The class to be used for the Servlet
     * @return The wrapper for the servlet
======= 6cce550:"java/org/apache/catalina/startup/Tomcat.java"

    /**
     * Add an existing Servlet to the context with no class.forName or
     * initialisation.
     * @param contextPath   Context to add Servlet to
     * @param servletName   Servlet name (used in mappings)
     * @param servlet       The Servlet to add
     * @return The wrapper for the servlet
     */
    public StandardWrapper addServlet(String contextPath, 
            String servletName, 
            Servlet servlet) {
        Container ctx = getHost().findChild(contextPath);
        return addServlet((StandardContext) ctx, 
                servletName, servlet);
    }
    /**
     * Static version of {@link #addServlet(String, String, Servlet).
     * @param ctx           Context to add Servlet to
     * @param servletName   Servlet name (used in mappings)
     * @param servlet       The Servlet to add
     * @return The wrapper for the servlet
======= 6cce550:"java/org/apache/catalina/startup/Tomcat.java"

     *  
     * @param contextPath   The context to set the defaults for
     */
    public void initWebappDefaults(String contextPath) {
        Container ctx = getHost().findChild(contextPath);
        initWebappDefaults((StandardContext) ctx);
    }
    
    /**
     * Static version of {@link #initWebappDefaults(String)
     * @param ctx   The context to set the defaults for
======= 6cce550:"java/org/apache/catalina/startup/Tomcat.java"

    /**
     * Fix startup sequence - required if you don't use web.xml.
     * The start() method in context will set 'configured' to false - and
     * expects a listener to set it back to true.
======= 6cce550:"java/org/apache/catalina/startup/Tomcat.java"

    /**
     * Helper class for wrapping existing servlets. This disables servlet 

======= 720de5e:"java/org/apache/catalina/startup/Bootstrap.java"

                log.debug("Expanded " + before + " to " + repository);

======= 6ab874a:"java/org/apache/catalina/manager/ManagerServlet.java"

            if (0==histoInterval)
                histoInterval=1;

======= fe53ca9:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

        /* welcome file processing - take 2
         * Now that we have looked for welcome files with a physical
         * backing, now look for an extension mapping listed
         * but may not have a physical backing to it. This is for 
         * the case of index.jsf, index.do, etc.
         * A watered down version of rule 4
         */
        if (mappingData.wrapper == null) {
            boolean checkWelcomeFiles = checkJspWelcomeFiles;
            if (!checkWelcomeFiles) {
                char[] buf = path.getBuffer();
                checkWelcomeFiles = (buf[pathEnd - 1] == '/');
            }
            if (checkWelcomeFiles) {
                for (int i = 0; (i < context.welcomeResources.length)
                         && (mappingData.wrapper == null); i++) {
                    path.setOffset(pathOffset);
                    path.setEnd(pathEnd);
                    path.append(context.welcomeResources[i], 0,
                                context.welcomeResources[i].length());
                    path.setOffset(servletPath);
                    internalMapExtensionWrapper(extensionWrappers,
                                                path, mappingData);
                }
                path.setOffset(servletPath);
                path.setEnd(pathEnd);
            }
        }

======= 4f5a5e4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractCreateStatementInterceptor.java"

    protected static final String CREATE_STATEMENT      = "createStatement";
    protected static final int    CREATE_STATEMENT_IDX  = 0;
    protected static final String PREPARE_STATEMENT     = "prepareStatement";
    protected static final int    PREPARE_STATEMENT_IDX = 1;
    protected static final String PREPARE_CALL          = "prepareCall";
    protected static final int    PREPARE_IDX           = 2;
    protected static final String[] STATEMENT_TYPES = {CREATE_STATEMENT, PREPARE_STATEMENT, PREPARE_CALL};
    protected static final int    STATEMENT_TYPE_COUNT = STATEMENT_TYPES.length;
    
    protected static final String EXECUTE        = "execute";
    protected static final String EXECUTE_QUERY  = "executeQuery";
    protected static final String EXECUTE_UPDATE = "executeUpdate";
    protected static final String EXECUTE_BATCH  = "executeBatch";
    protected static final String[] EXECUTE_TYPES = {EXECUTE, EXECUTE_QUERY, EXECUTE_UPDATE, EXECUTE_BATCH};
======= 4f5a5e4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractCreateStatementInterceptor.java"

            process = isStatement(method, process);
======= 4f5a5e4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractCreateStatementInterceptor.java"

     * @param method the method that was called. It will be one of the methods defined in {@link #STATEMENT_TYPES}
======= 4f5a5e4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractCreateStatementInterceptor.java"

     * Returns true if the method that is being invoked matches one of the statement types.
     * 
     * @param method the method being invoked on the proxy
     * @param process boolean result used for recursion
     * @return returns true if the method name matched
     */
    protected boolean isStatement(Method method, boolean process){
        return process(STATEMENT_TYPES, method, process);
    }
    /**
     * Returns true if the method that is being invoked matches one of the execute types.
     * 
     * @param method the method being invoked on the proxy
     * @param process boolean result used for recursion
     * @return returns true if the method name matched
     */
    protected boolean isExecute(Method method, boolean process){
        return process(EXECUTE_TYPES, method, process);
    }
    /*
======= 4f5a5e4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

        new Constructor[AbstractCreateStatementInterceptor.STATEMENT_TYPE_COUNT];
======= 4f5a5e4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

        if (sql==null && compare(EXECUTE_BATCH,name)) {
======= 4f5a5e4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

        if (sql==null && compare(EXECUTE_BATCH,name)) {
======= 4f5a5e4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

        if (sql==null && compare(EXECUTE_BATCH,name)) {
======= 4f5a5e4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

            if (compare(CREATE_STATEMENT,name)) {
                constructor = getConstructor(CREATE_STATEMENT_IDX,Statement.class);
            }else if (compare(PREPARE_STATEMENT,name)) {
                constructor = getConstructor(PREPARE_STATEMENT_IDX,PreparedStatement.class);
            }else if (compare(PREPARE_CALL,name)) {
                constructor = getConstructor(PREPARE_IDX,CallableStatement.class);
======= 4f5a5e4:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java"

            process = isExecute( method, process);

======= 278dedc:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestConcurrency.java"

        Driver.reset();
======= 278dedc:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestConcurrency.java"

                assertTrue("Size comparison(less than 11):",ds.getPool().getSize()<=10);

======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported
======= abbb922:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java"

     * @throws UnsupportedOperationException - this operation is not supported

======= a9e00d5:"test/org/apache/catalina/connector/TestRequest.java"

    @Override
    public void setUp() throws Exception {
        super.setUp();
    }
    @Override
    public void tearDown() throws Exception {
        super.tearDown();
    }
======= a9e00d5:"test/org/apache/catalina/connector/TestRequest.java"

        client.setPort(getPort());
======= a9e00d5:"test/org/apache/catalina/connector/TestRequest.java"

        private static final long serialVersionUID = 1L;
======= a9e00d5:"test/org/apache/catalina/connector/TestRequest.java"

    private class Bug37794Client extends SimpleHttpClient {
        
        private boolean init;
        
        private synchronized void init() throws Exception {
            if (init) return;
            
            Tomcat tomcat = getTomcatInstance();
            StandardContext root = tomcat.addContext("", TEMP_DIR);
            Tomcat.addServlet(root, "Bug37794", new Bug37794Servlet());
            root.addServletMapping("/test", "Bug37794");
            tomcat.start();
            
            init = true;
        }
        
            Tomcat tomcat = getTomcatInstance();
            
                init();
======= a9e00d5:"test/org/apache/catalina/connector/TestRequest.java"

======= a9e00d5:"test/org/apache/catalina/connector/TestRequest.java"

        private int port = 8080;
======= a9e00d5:"test/org/apache/catalina/connector/TestRequest.java"

        public void setPort(int thePort) {
            port = thePort;
        }
======= a9e00d5:"test/org/apache/catalina/connector/TestRequest.java"

            socket = new Socket("localhost", port);
======= a9e00d5:"test/org/apache/catalina/startup/TestTomcat.java"

======= a9e00d5:"test/org/apache/catalina/startup/TestTomcat.java"

======= a9e00d5:"test/org/apache/catalina/startup/TestTomcat.java"

        Tomcat tomcat = getTomcatInstance();
        // Must have a real docBase - just use temp
            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
======= a9e00d5:"test/org/apache/catalina/startup/TestTomcat.java"

        ByteChunk res = getUrl("http://localhost:" + getPort() + "/");
        Tomcat tomcat = getTomcatInstance();
            new File("output/build/webapps/examples");
        ByteChunk res = getUrl("http://localhost:" + getPort() +
                "/examples/servlets/servlet/HelloWorldExample");
        Tomcat tomcat = getTomcatInstance();
        long t0 = System.currentTimeMillis();
        tomcat.addContext(null, "/", ".");
        System.err.println("Test time: " + 
                (System.currentTimeMillis() - t0));
     }

======= cfb18a0:"test/org/apache/catalina/startup/TestTomcat.java"

        tempDir = new File(base + "output/tmp");
        tomcat.getHost().setAppBase(tempDir.getAbsolutePath() + "/webapps");
======= cfb18a0:"test/org/apache/catalina/startup/TestTomcat.java"

        ExpandWar.delete(tempDir);

======= 768af9f:"java/org/apache/jasper/compiler/JspUtil.java"

        String targetType = getCanonicalName(expectedType);

======= 50d0e6e:"java/org/apache/jasper/servlet/JspServlet.java"

======= 50d0e6e:"java/org/apache/jasper/servlet/JspServlet.java"


======= 9dc93f5:"java/org/apache/catalina/Valve.java"

     *     executing <code>getNext().invoke()</code>.
======= 9dc93f5:"java/org/apache/catalina/Valve.java"

     *     <code>getNext().invoke()</code> method has returned.
     *     specified Response after the <code>getNext().invoke()</code> method has

======= a9f0239:"java/org/apache/catalina/loader/WebappClassLoader.java"

            java.util.Collection<ResourceEntry> values =
                ((HashMap<String,ResourceEntry>) resourceEntries.clone()).values();
            Iterator<ResourceEntry> loadedClasses = values.iterator();
            //
            // walk through all loaded class to trigger initialization for
            //    any uninitialized classes, otherwise initialization of
            //    one class may call a previously cleared class.
            while(loadedClasses.hasNext()) {
                ResourceEntry entry = loadedClasses.next();
                if (entry.loadedClass != null) {
                    Class<?> clazz = entry.loadedClass;
                    try {
                        Field[] fields = clazz.getDeclaredFields();
                        for (int i = 0; i < fields.length; i++) {
                            if(Modifier.isStatic(fields[i].getModifiers())) {
                                fields[i].get(null);
                                break;
                            }
                        }
                    } catch(Throwable t) {
                        // Ignore
                    }
                }
            }
            loadedClasses = values.iterator();

======= f0d447d:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

======= f0d447d:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

             if (manager != null && (
                     (manager instanceof ClusterManager
                       && getCluster() != null
                       && getCluster().getManager(((ClusterManager)manager).getName()) != null)
                     ||
                     (manager instanceof PersistentManager)))
======= f0d447d:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

        if (getCluster() != null) {
            // now sending the change to all other clusternode!
            ClusterManager manager = (ClusterManager)catalinaSession.getManager();
            sendSessionIDClusterBackup(manager,request,sessionId, newSessionID);
        }
======= f0d447d:"java/org/apache/catalina/ha/session/JvmRouteBinderValve.java"

        if (log.isInfoEnabled()) {
            if (cluster == null)
                log.info(sm.getString("jvmRoute.noCluster"));
        }

======= 83e98da:"java/org/apache/catalina/ha/session/DeltaManager.java"

            if (msg != null){
               session.setLastTimeReplicated(System.currentTimeMillis());
               msg.setTimestamp(session.getLastTimeReplicated());
            }

======= 6f3e56e:"java/org/apache/catalina/session/StandardSession.java"

    protected transient volatile boolean expiring = false;
======= 6f3e56e:"java/org/apache/catalina/session/StandardSession.java"

    protected volatile boolean isValid = false;
======= 6f3e56e:"java/org/apache/catalina/session/StandardSession.java"

        // Check to see if expire is in progress or has previously been called
        if (expiring || !isValid)
            // Check again, now we are inside the sync so this code only runs once
            // Double check locking - expiring and isValid need to be volatile
            if (expiring || !isValid)
                return;
            // Mark this session as "being expired"

======= aa8a2d3:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

======= aa8a2d3:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

======= aa8a2d3:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

    protected ExecutorService executor = ExecutorFactory.newThreadPool(0, 2, 2, TimeUnit.SECONDS);
======= aa8a2d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

======= aa8a2d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

======= aa8a2d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

            executor = ExecutorFactory.newThreadPool(minThreads, maxThreads, maxIdleTime, TimeUnit.MILLISECONDS, tf);
======= aa8a2d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

======= aa8a2d3:"java/org/apache/catalina/tribes/transport/ReceiverBase.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private static class TaskQueue extends LinkedBlockingQueue<Runnable> {
        ThreadPoolExecutor parent = null;
        public TaskQueue() {
            super();
        }
        public TaskQueue(int initialCapacity) {
            super(initialCapacity);
        }
        public TaskQueue(Collection<? extends Runnable> c) {
            super(c);
        }
        public void setParent(ThreadPoolExecutor tp) {
            parent = tp;
        }
        
        public boolean force(Runnable o) {
            if ( parent.isShutdown() ) throw new RejectedExecutionException("Executor not running, can't force a command into the queue");
            return super.offer(o); //forces the item onto the queue, to be used if the task is rejected
        }
        public boolean offer(Runnable o) {
            //we can't do any checks
            if (parent==null) return super.offer(o);
            //we are maxed out on threads, simply queue the object
            if (parent.getPoolSize() == parent.getMaximumPoolSize()) return super.offer(o);
            //we have idle threads, just add it to the queue
            //this is an approximation, so it could use some tuning
            if (parent.getActiveCount()<(parent.getPoolSize())) return super.offer(o);
            //if we have less threads than maximum force creation of a new thread
            if (parent.getPoolSize()<parent.getMaximumPoolSize()) return false;
            //if we reached here, we need to add it to the queue
            return super.offer(o);
        }
    }

======= 80f8ec6:"java/org/apache/catalina/realm/GenericPrincipal.java"

======= 80f8ec6:"java/org/apache/catalina/realm/GenericPrincipal.java"

        this(realm, name, password, roles, userPrincipal, null);
    }
    
    /**
     * Construct a new Principal, associated with the specified Realm, for the
     * specified username and password, with the specified role names
     * (as Strings).
     *
     * @param realm The Realm that owns this principal
     * @param name The username of the user represented by this Principal
     * @param password Credentials used to authenticate this user
     * @param roles List of roles (must be Strings) possessed by this user
     * @param userPrincipal - the principal to be returned from the request 
     *        getUserPrincipal call if not null; if null, this will be returned
     * @param loginContext  - If provided, this will be used to log out the user
     *        at the appropriate time
     */
    public GenericPrincipal(Realm realm, String name, String password,
                            List<String> roles, Principal userPrincipal,
                            LoginContext loginContext) {
======= 80f8ec6:"java/org/apache/catalina/realm/GenericPrincipal.java"

        this.loginContext = loginContext;
======= 80f8ec6:"java/org/apache/catalina/realm/GenericPrincipal.java"

    
    /**
     * The JAAS LoginContext, if any, used to authenticate this Principal.
     * Kept so we can call logout().
     */
    protected LoginContext loginContext = null;
    public LoginContext getLoginContext() {
        return loginContext;
    }
======= 80f8ec6:"java/org/apache/catalina/realm/JAASRealm.java"

        Principal principal = createPrincipal(username, subject, loginContext);
======= 80f8ec6:"java/org/apache/catalina/realm/JAASRealm.java"

     * @param loginContext Associated with th Princpal so
     *                     {@link LoginContext#logout()} can be called later
    protected Principal createPrincipal(String username, Subject subject,
            LoginContext loginContext) {
======= 80f8ec6:"java/org/apache/catalina/realm/JAASRealm.java"

        return new GenericPrincipal(this, username, null, roles, userPrincipal,
                loginContext);
======= 80f8ec6:"java/org/apache/catalina/session/StandardSession.java"

======= 80f8ec6:"java/org/apache/catalina/session/StandardSession.java"

======= 80f8ec6:"java/org/apache/catalina/session/StandardSession.java"

            // Call the JAAS logout method if necessary
            if (principal instanceof GenericPrincipal) {
                GenericPrincipal gp = (GenericPrincipal) principal;
                if (gp.getLoginContext() != null) {
                    try {
                        gp.getLoginContext().logout();
                    } catch (LoginException e) {
                        manager.getContainer().getLogger().error(
                                sm.getString("standardSession.jaaslogoutfail"),
                                e);
                    }
                }
            }

======= c1099f7:"java/org/apache/catalina/ha/session/DeltaSession.java"

                    getDeltaRequest().execute(this, ((ClusterManager)getManager()).isNotifyListenersOnReplication());

======= 202a33e:"java/org/apache/jasper/compiler/Generator.java"

======= 202a33e:"java/org/apache/jasper/compiler/Generator.java"

    
    private Set<String> varInfoNames;
======= 202a33e:"java/org/apache/jasper/compiler/Generator.java"

            } else if (varInfoNames.contains(name)) {
                // The object is a custom action with an associated
                                + "(_jspx_page_context.findAttribute(\""
                                + "\"), \""
            } else {
                StringBuilder msg =
                    new StringBuilder("jsp:getProperty for bean with name '");
                msg.append(name);
                msg.append(
                        "'. Name was not previously introduced as per JSP.5.3");
                
                throw new JasperException(msg.toString());
======= 202a33e:"java/org/apache/jasper/compiler/Generator.java"

            
            // Add the named objects to the lits of 'introduced' names to enable
            // a later test as per JSP.5.3
            VariableInfo[] infos = n.getVariableInfos();
            if (infos != null && infos.length > 0) {
                for (int i = 0; i < infos.length; i++) {
                    VariableInfo info = infos[i];
                    if (info != null && info.getVarName() != null)
                    pageInfo.getVarInfoNames().add(info.getVarName());
                }
            }
            
======= 202a33e:"java/org/apache/jasper/compiler/Generator.java"

        varInfoNames = pageInfo.getVarInfoNames();
======= 202a33e:"java/org/apache/jasper/compiler/PageInfo.java"

======= 202a33e:"java/org/apache/jasper/compiler/PageInfo.java"

    private Set<String> varInfoNames;
======= 202a33e:"java/org/apache/jasper/compiler/PageInfo.java"

        this.varInfoNames = new HashSet<String>();
======= 202a33e:"java/org/apache/jasper/compiler/PageInfo.java"

    public Set<String> getVarInfoNames() {
        return varInfoNames;
    }

======= c6818a0:"java/org/apache/catalina/realm/JNDIRealm.java"

            // Some directories prefix the password with the hash type
            if (password.startsWith("{MD5}") || password.startsWith("{SHA}")) {

======= d92da6e:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

======= d92da6e:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

======= d92da6e:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

======= d92da6e:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

======= d92da6e:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

======= d92da6e:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

======= d92da6e:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

======= d92da6e:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java"

======= d92da6e:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/DefaultProperties.java"

        
        url = System.getProperty("url","jdbc:mysql://localhost:3306/mysql?autoReconnect=true");
        driverClassName = System.getProperty("driverClassName","com.mysql.jdbc.Driver");
        password = System.getProperty("password","password");
        username = System.getProperty("username","root");
        
        validationQuery = System.getProperty("validationQuery","SELECT 1");
======= d92da6e:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/DefaultProperties.java"

        
======= d92da6e:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestSlowQueryReport.java"

        String fastSql = this.datasource.getValidationQuery();
            ResultSet rs = st.executeQuery(fastSql);

======= ef96fa2:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java"

        if (connection==null) {
            throw new SQLException("Driver:"+driver+" returned null for URL:"+driverURL);
        }
        

======= 76a4eb3:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

                // Spec says apps should have read/write for their temp
                // directory. This is fine, as no security sensitive files, at
                // least any that the app doesn't have full control of anyway,
                // will be written here.
                        (new FilePermission(workDir,"read,write"));
                permissionCollection.add(new FilePermission(
                        workDir,"read,write,delete"));

======= 51fd68b:"java/org/apache/catalina/tribes/membership/McastService.java"

    public void setLocalLoopbackDisabled(boolean localLoopbackDisabled) {
        properties.setProperty("localLoopbackDisabled",String.valueOf(localLoopbackDisabled));
    }
======= 51fd68b:"java/org/apache/catalina/tribes/membership/McastService.java"

                                    this,
                                    Boolean.valueOf(properties.getProperty("localLoopbackDisabled","false")).booleanValue());
======= 51fd68b:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

     * disable/enable local loopback message
     */
    protected boolean localLoopbackDisabled = false;
    
    /**
======= 51fd68b:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

     * @param disableLoopbackMode - disable loopbackMode
======= 51fd68b:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

        MessageListener msgservice,
        boolean localLoopbackDisabled)
======= 51fd68b:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

        this.localLoopbackDisabled = localLoopbackDisabled;
======= 51fd68b:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

        socket.setLoopbackMode(localLoopbackDisabled); //hint if we want disable loop back(local machine) messages
    
    <attribute name="localLoopbackDisabled" required="false">
      <p>
      Membership uses multicast, it will call <code>java.net.MulticastSocket.setLoopbackMode(localLoopbackDisabled)</code>.
      When <code>localLoopbackDisabled==true</code> multicast messages will not reach other nodes on the same local machine.
      The default is <code>false</code>. <br/>
      </p>
    </attribute>

======= c768090:"java/org/apache/catalina/ha/session/DeltaManager.java"

        if(notifySessionListenersOnReplication) {
        } else {
            add(session);
        }

======= b3e2be4:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                    rentry.resetDiff();

======= cc1f0dd:"java/org/apache/catalina/startup/HostConfig.java"

======= cc1f0dd:"java/org/apache/catalina/startup/HostConfig.java"

            if (deployXML && xml.exists()) {
                deployedApp.redeployResources.put
                (xml.getAbsolutePath(), new Long(xml.lastModified()));
            }
======= cc1f0dd:"java/org/apache/catalina/startup/HostConfig.java"

            File xmlCopy = null;
======= cc1f0dd:"java/org/apache/catalina/startup/HostConfig.java"

                xmlCopy = new File(configBase(), file + ".xml");
======= cc1f0dd:"java/org/apache/catalina/startup/HostConfig.java"

======= cc1f0dd:"java/org/apache/catalina/startup/HostConfig.java"

            if (xmlCopy != null) {
                deployedApp.redeployResources.put
                (xmlCopy.getAbsolutePath(), new Long(xmlCopy.lastModified()));
            }

======= 468f370:"java/org/apache/catalina/session/StandardSession.java"

======= 468f370:"java/org/apache/catalina/session/StandardSession.java"

======= 468f370:"java/org/apache/catalina/session/StandardSession.java"

======= 468f370:"java/org/apache/catalina/session/StandardSession.java"

        if (context instanceof StandardContext) {
            // NOTE:  Race condition is harmless, so do not synchronize
            ((StandardContext) context).fireContainerEvent(type, data);

======= f00029e:"java/org/apache/catalina/valves/AccessLogValve.java"

    private volatile String dateStamp = "";
======= f00029e:"java/org/apache/catalina/valves/AccessLogValve.java"

    private volatile long currentMillis = 0;
======= f00029e:"java/org/apache/catalina/valves/AccessLogValve.java"

            dateStamp = fileDateFormatter.format(
                    new Date(System.currentTimeMillis()));
======= f00029e:"java/org/apache/catalina/valves/AccessLogValve.java"

                String tsDate = fileDateFormatter.format(new Date(systime));
======= f00029e:"java/org/apache/catalina/valves/AccessLogValve.java"

                    dateStamp = fileDateFormatter.format(
                            new Date(System.currentTimeMillis()));

======= 36feee0:"java/org/apache/coyote/http11/Http11Processor.java"

    protected void parseHost(MessageBytes valueMB) {

======= 9fa7640:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

======= 9fa7640:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

======= 9fa7640:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

            member.setServiceStartTime(-1);
======= 9fa7640:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

        return (member!=null) ? member.getServiceStartTime() : -1l;

======= 96167ed:"java/org/apache/tomcat/util/res/StringManager.java"

        bundle = ResourceBundle.getBundle(bundleName, Locale.getDefault());
======= 96167ed:"java/org/apache/tomcat/util/res/StringManager.java"


======= 1ad0501:"java/org/apache/catalina/core/StandardHostValve.java"

======= 1ad0501:"java/org/apache/catalina/core/StandardHostValve.java"

            String message = response.getMessage();

======= 54b9da9:"java/org/apache/catalina/connector/MapperListener.java"

            if (host != null) {
                host.removeContainerListener(this);
            }
======= 54b9da9:"java/org/apache/catalina/mbeans/MBeanUtils.java"

======= 54b9da9:"java/org/apache/catalina/mbeans/MBeanUtils.java"

======= 54b9da9:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        try {
            String address = (String)
                IntrospectionUtils.getProperty(connector, "address");
            Integer port = (Integer)
                IntrospectionUtils.getProperty(connector, "port");
            StringBuffer sb = new StringBuffer(domain);
            sb.append(":type=Connector");
            sb.append(",port=" + port);
            if ((address != null) && (address.length()>0)) {
                sb.append(",address=" + address);
            name = new ObjectName(sb.toString());
            return (name);
        } catch (Exception e) {
                ("Cannot create object name for " + connector+e);
======= 54b9da9:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        // domain is engine name
        String domain = service.getContainer().getName();
======= 54b9da9:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        // Unregister associated request processor
        String worker = null;
        ProtocolHandler handler = connector.getProtocolHandler();
        if (handler instanceof Http11Protocol) {
            worker = ((Http11Protocol)handler).getName();
        } else if (handler instanceof Http11NioProtocol) {
            worker = ((Http11NioProtocol)handler).getName();
        } else if (handler instanceof Http11AprProtocol) {
            worker = ((Http11AprProtocol)handler).getName();
        } else if (handler instanceof AjpProtocol) {
            worker = ((AjpProtocol)handler).getName();
        } else if (handler instanceof AjpAprProtocol) {
            worker = ((AjpAprProtocol)handler).getName();
        }
        ObjectName query = new ObjectName(
                domain + ":type=RequestProcessor,worker=" + worker + ",*");
        Set<ObjectName> results = mserver.queryNames(query, null);
        for(ObjectName result : results) {
            mserver.unregisterMBean(result);
        }
======= 54b9da9:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        String domain = context.getParent().getParent().getName();
======= 54b9da9:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        // If this is a user database resource need to destroy groups, roles,
        // users and UserDatabase mbean
        if ("org.apache.catalina.UserDatabase".equals(resource.getType())) {
            destroyMBeanUserDatabase(resource.getName());
        }
======= 54b9da9:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        String domain = engine.getName();
======= 54b9da9:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        String domain = host.getParent().getName();
======= 54b9da9:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        if( mserver.isRegistered(oname) )
======= 54b9da9:"java/org/apache/catalina/mbeans/MBeanUtils.java"

        
        // Global String cache - fixed name
        oname = new ObjectName("Catalina:type=StringCache");
        if( mserver.isRegistered(oname) )
            mserver.unregisterMBean(oname);
        // MBean Factory - fixed name
        oname = new ObjectName("Catalina:type=MBeanFactory");
        if( mserver.isRegistered(oname) )
            mserver.unregisterMBean(oname);
======= 54b9da9:"java/org/apache/catalina/mbeans/MBeanUtils.java"

     * Deregister the MBean for the
     * <code>UserDatabase</code> object with this name.
     *
     * @param userDatabase The UserDatabase to be managed
     *
     * @exception Exception if an MBean cannot be deregistered
     */
    static void destroyMBeanUserDatabase(String userDatabase)
        throws Exception {
        ObjectName query = null;
        Set<ObjectName> results = null;
        
        // Groups
        query = new ObjectName(
                "Users:type=Group,database=" + userDatabase + ",*");
        results = mserver.queryNames(query, null);
        for(ObjectName result : results) {
            mserver.unregisterMBean(result);
        }
        
        // Roles
        query = new ObjectName(
                "Users:type=Role,database=" + userDatabase + ",*");
        results = mserver.queryNames(query, null);
        for(ObjectName result : results) {
            mserver.unregisterMBean(result);
        }
        
        // Users
        query = new ObjectName(
                "Users:type=User,database=" + userDatabase + ",*");
        results = mserver.queryNames(query, null);
        for(ObjectName result : results) {
            mserver.unregisterMBean(result);
        }
        // The database itself
        ObjectName db = new ObjectName(
                "Users:type=UserDatabase,database=" + userDatabase);
        mserver.unregisterMBean(db);
    }
    /**
======= 54b9da9:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        } else if (Lifecycle.AFTER_STOP_EVENT.equals(event.getType())) {
======= 54b9da9:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

======= 54b9da9:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        // deregister the MBean for the Connector itself
        if (log.isDebugEnabled())
            log.debug("Destroying MBean for Connector " + connector);
        MBeanUtils.destroyMBean(connector, service);
======= 54b9da9:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        MBeanUtils.destroyMBean(context);
======= 54b9da9:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        MBeanUtils.destroyMBean(engine);
======= 54b9da9:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        MBeanUtils.destroyMBean(host);
======= 54b9da9:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

        MBeanUtils.destroyMBean(server);
======= 54b9da9:"java/org/apache/catalina/mbeans/ServerLifecycleListener.java"

            destroyMBeans(engine);
        // Deregister the MBeans for the corresponding Connectors
        Connector connectors[] = service.findConnectors();
        for (int j = 0; j < connectors.length; j++) {
            destroyMBeans(connectors[j], service);

======= d04dd88:"java/org/apache/catalina/realm/JNDIRealm.java"

 * <li>If the directory server contains nested roles, you can search for them
 * by setting <code>roleNested</code> to <code>true</code>.
 * The default value is <code>false</code>, so role searches will not find
 * nested roles.</li>
======= d04dd88:"java/org/apache/catalina/realm/JNDIRealm.java"

======= d04dd88:"java/org/apache/catalina/realm/JNDIRealm.java"

    
    /**
     * Should we look for nested group in order to determine roles?
     */
    protected boolean roleNested = false;
======= d04dd88:"java/org/apache/catalina/realm/JNDIRealm.java"

======= d04dd88:"java/org/apache/catalina/realm/JNDIRealm.java"

    
    /**
     * Return the "The nested group search flag" flag.
     */
    public boolean getRoleNested() {
        return (this.roleNested);
    }
    /**
     * Set the "search subtree for roles" flag.
     *
     * @param roleNested The nested group search flag
     */
    public void setRoleNested(boolean roleNested) {
        this.roleNested = roleNested;
    }
     
======= d04dd88:"java/org/apache/catalina/realm/JNDIRealm.java"

======= d04dd88:"java/org/apache/catalina/realm/JNDIRealm.java"

        
======= d04dd88:"java/org/apache/catalina/realm/JNDIRealm.java"

            for (String key: keys) {
                containerLog.trace(  "  Found direct role " + key + " -> " + groupMap.get(key));
        // if nested group search is enabled, perform searches for nested groups until no new group is found
        if (getRoleNested()) {
            // The following efficient algorithm is known as memberOf Algorithm, as described in "Practices in 
            // Directory Groups". It avoids group slurping and handles cyclic group memberships as well.
            // See http://middleware.internet2.edu/dir/ for details
            Set<String> newGroupDNs = new HashSet<String>(groupMap.keySet());
            while (!newGroupDNs.isEmpty()) {
                Set<String> newThisRound = new HashSet<String>(); // Stores the groups we find in this iteration
                for (String groupDN : newGroupDNs) {
                    filter = roleFormat.format(new String[] { groupDN });
                    if (containerLog.isTraceEnabled()) {
                        containerLog.trace("Perform a nested group search with base "+ roleBase + " and filter " + filter);
                    }
                    results = context.search(roleBase, filter, controls);
                    try {
                        while (results.hasMore()) {
                            SearchResult result = results.next();
                            Attributes attrs = result.getAttributes();
                            if (attrs == null)
                                continue;
                            String dname = getDistinguishedName(context, roleBase, result);
                            String name = getAttributeValue(roleName, attrs);
                            if (name != null && dname != null && !groupMap.keySet().contains(dname)) {
                                groupMap.put(dname, name);
                                newThisRound.add(dname);
                                if (containerLog.isTraceEnabled()) {
                                    containerLog.trace("  Found nested role " + dname + " -> " + name);
                                }
                            }
                         }
                    } catch (PartialResultException ex) {
                        if (!adCompat)
                            throw ex;
                    }
                }
                newGroupDNs = newThisRound;
            }
        return new ArrayList<String>(groupMap.values());
        <bug>46925</bug>: Replace recusive search for nested roles with
        iterative search. Patch provided by Stefan Zoerner. (rjung)
      </update>
      <update>
        session attribute serialization. (mturk)

======= 04cacaf:"java/org/apache/jasper/runtime/PageContextImpl.java"

======= 04cacaf:"java/org/apache/jasper/runtime/PageContextImpl.java"

======= 04cacaf:"java/org/apache/jasper/runtime/PageContextImpl.java"


======= c8cbc28:"java/org/apache/catalina/core/Constants.java"

    public static final String PRECOMPILE = 
        System.getProperty("org.apache.jasper.Constants.PRECOMPILE",
                "jsp_precompile");
======= c8cbc28:"java/org/apache/catalina/core/StandardWrapper.java"

                    req.setQueryString(Constants.PRECOMPILE +
                            "jsp_precompile=true");

======= 90e8d0d:"java/org/apache/catalina/realm/JNDIRealm.java"

======= 90e8d0d:"java/org/apache/catalina/realm/JNDIRealm.java"

    protected String getDistinguishedName(DirContext context, String base,
            SearchResult result) throws NamingException {
        // Get the entry's distinguished name.  For relative results, this means
        // we need to composite a name with the base name, the context name, and
        // the result name.  For non-relative names, use the returned name.
        if (result.isRelative()) {
           if (containerLog.isTraceEnabled()) {
               containerLog.trace("  search returned relative name: " +
                       result.getName());
           }
           NameParser parser = context.getNameParser("");
           Name contextName = parser.parse(context.getNameInNamespace());
           Name baseName = parser.parse(base);
   
           // Bugzilla 32269
           Name entryName =
               parser.parse(new CompositeName(result.getName()).get(0));
   
           Name name = contextName.addAll(baseName);
           name = name.addAll(entryName);
           return name.toString();
        } else {
           String absoluteName = result.getName();
           if (containerLog.isTraceEnabled())
               containerLog.trace("  search returned absolute name: " +
                       result.getName());
           try {
               // Normalize the name by running it through the name parser.
               NameParser parser = context.getNameParser("");
               URI userNameUri = new URI(absoluteName);
               String pathComponent = userNameUri.getPath();
               // Should not ever have an empty path component, since that is /{DN}
               if (pathComponent.length() < 1 ) {
                   throw new InvalidNameException(
                           "Search returned unparseable absolute name: " +
                           absoluteName );
               }
               Name name = parser.parse(pathComponent.substring(1));
               return name.toString();
           } catch ( URISyntaxException e ) {
               throw new InvalidNameException(
                       "Search returned unparseable absolute name: " +
                       absoluteName );
           }
        }

======= 78a994a:"java/org/apache/jasper/runtime/BodyContentImpl.java"

======= 78a994a:"java/org/apache/jasper/runtime/BodyContentImpl.java"

     * This method returns the size of the buffer used by the JspWriter.
     *
     * @return the size of the buffer in bytes, or 0 is unbuffered.
     */
    public int getBufferSize() {
        // According to the spec, the JspWriter returned by 
        // JspContext.pushBody(java.io.Writer writer) must behave as
        // though it were unbuffered. This means that its getBufferSize()
        // must always return 0.
        return (writer == null) ? bufferSize : 0;
    }
    
    /**
======= 78a994a:"java/org/apache/jasper/runtime/BodyContentImpl.java"

        if (writer == null) {

======= 42a093b:"java/org/apache/coyote/http11/Http11AprProcessor.java"

            if (!error) {
                // Setting up filters, and parse some request headers
                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
                try {
                    prepareRequest();
                } catch (Throwable t) {
                    if (log.isDebugEnabled()) {
                        log.debug(sm.getString("http11processor.request.prepare"), t);
                    }
                    // 400 - Internal Server Error
                    response.setStatus(400);
                    error = true;
======= 42a093b:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            if (!error) {
                // Setting up filters, and parse some request headers
                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
                try {
                    prepareRequest();
                } catch (Throwable t) {
                    if (log.isDebugEnabled()) {
                        log.debug(sm.getString("http11processor.request.prepare"), t);
                    }
                    // 400 - Internal Server Error
                    response.setStatus(400);
                    error = true;
======= 42a093b:"java/org/apache/coyote/http11/Http11Processor.java"

            if (!error) {
                // Setting up filters, and parse some request headers
                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
                try {
                    prepareRequest();
                } catch (Throwable t) {
                    if (log.isDebugEnabled()) {
                        log.debug(sm.getString("http11processor.request.prepare"), t);
                    }
                    // 400 - Internal Server Error
                    response.setStatus(400);
                    error = true;
======= 42a093b:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

            // Spec says no CR or LF in method name
            if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {
                throw new IllegalArgumentException(
                        sm.getString("iib.invalidmethod"));
            }
======= 42a093b:"java/org/apache/coyote/http11/InternalInputBuffer.java"

            // Spec says no CR or LF in method name
            if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {
                throw new IllegalArgumentException(
                        sm.getString("iib.invalidmethod"));
            }
======= 42a093b:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

                // Spec says no CR or LF in method name
                if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {
                    throw new IllegalArgumentException(
                            sm.getString("iib.invalidmethod"));
                }

======= f109fb9:"java/org/apache/catalina/loader/WebappClassLoader.java"

                clazz = Class.forName(name, false, loader);
======= f109fb9:"java/org/apache/catalina/loader/WebappClassLoader.java"

                clazz = Class.forName(name, false, loader);

======= 80b90ee:"java/org/apache/jasper/compiler/Generator.java"

                            + ((jreversion == null) ? "" : ";version="
======= 80b90ee:"java/org/apache/jasper/compiler/Generator.java"

                            + ((jreversion == null) ? "" : ";version="

======= 6ecc35d:"java/org/apache/catalina/ssi/SSIServlet.java"

        bufferedReader.close();

======= 0c48c98:"java/org/apache/tomcat/util/threads/TaskThreadFactory.java"

    private final ThreadGroup group;
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;
    private final boolean daemon;
    private final int threadPriority;

======= 4e1c4b2:"java/org/apache/tomcat/util/threads/TaskQueue.java"

    private ThreadPoolExecutor parent = null;
======= 4e1c4b2:"java/org/apache/tomcat/util/threads/TaskQueue.java"

        if (parent != null && parent.getPoolSize()<parent.getMaximumPoolSize()){
        	return false;
        } else {
            //if we reached here, we need to add it to the queue
            //or can't do any checks
            return super.offer(o);
        }

======= a228c06:"java/org/apache/jk/server/JkCoyoteHandler.java"

        req.recycle();

======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

    
    private final Object applicationListenersLock = new Object();
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

    private final Object applicationParametersLock = new Object();
    
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

    
    private final Object constraintsLock = new Object();
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

    
    private final Object filterMapsLock = new Object();
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

    private final Object instanceListenersLock = new Object();
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

    private final Object securityRolesLock = new Object();
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

    
    private final Object servletMappingsLock = new Object();
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

    private final Object watchedResourcesLock = new Object();
    private final Object welcomeFilesLock = new Object();
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

    private final Object wrapperLifecyclesLock = new Object();
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

    private final Object wrapperListenersLock = new Object();
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (applicationListenersLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (applicationParametersLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (constraintsLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (filterMapsLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (filterMapsLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (instanceListenersLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (securityRolesLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (servletMappingsLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (watchedResourcesLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (welcomeFilesLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperLifecyclesLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperListenersLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (instanceListenersLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperLifecyclesLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperListenersLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (applicationParametersLock) {
            return (applicationParameters);
        }
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (instanceListenersLock) {
            return (instanceListeners);
        }
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (securityRolesLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (securityRolesLock) {
            return (securityRoles);
        }
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (servletMappingsLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (servletMappingsLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (welcomeFilesLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (watchedResourcesLock) {
            return watchedResources;
        }
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (welcomeFilesLock) {
            return (welcomeFiles);
        }
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperLifecyclesLock) {
            return (wrapperLifecycles);
        }
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperListenersLock) {
            return (wrapperListeners);
        }
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (applicationListenersLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (applicationParametersLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (constraintsLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (filterMapsLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (instanceListenersLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (securityRolesLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (servletMappingsLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (watchedResourcesLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (welcomeFilesLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperLifecyclesLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (wrapperListenersLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardContext.java"

        synchronized (instanceListenersLock) {
            instanceListeners = new String[0];
        }
======= f1fd999:"java/org/apache/catalina/core/StandardHost.java"

    
    private final Object aliasesLock = new Object();
======= f1fd999:"java/org/apache/catalina/core/StandardHost.java"

        synchronized (aliasesLock) {
            // Skip duplicate aliases
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i].equals(alias))
                    return;
            }
            // Add this alias to the list
            String newAliases[] = new String[aliases.length + 1];
            for (int i = 0; i < aliases.length; i++)
                newAliases[i] = aliases[i];
            newAliases[aliases.length] = alias;
            aliases = newAliases;
======= f1fd999:"java/org/apache/catalina/core/StandardHost.java"

        synchronized (aliasesLock) {
            return (this.aliases);
        }
======= f1fd999:"java/org/apache/catalina/core/StandardHost.java"

        synchronized (aliasesLock) {
======= f1fd999:"java/org/apache/catalina/core/StandardHost.java"

        synchronized (aliasesLock) {
            return aliases;
        }
======= f1fd999:"java/org/apache/catalina/tribes/membership/Membership.java"

    private final Object membersLock = new Object();
    
======= f1fd999:"java/org/apache/catalina/tribes/membership/Membership.java"

        synchronized (membersLock) {
======= f1fd999:"java/org/apache/catalina/tribes/membership/Membership.java"

      synchronized (membersLock) {
======= f1fd999:"java/org/apache/catalina/tribes/membership/Membership.java"

        synchronized (membersLock) {
======= f1fd999:"java/org/apache/catalina/util/InstanceSupport.java"

    
    private final Object listenersLock = new Object(); // Lock object for changes to listeners
======= f1fd999:"java/org/apache/catalina/util/InstanceSupport.java"

      synchronized (listenersLock) {
======= f1fd999:"java/org/apache/catalina/util/InstanceSupport.java"

        synchronized (listenersLock) {
======= f1fd999:"java/org/apache/catalina/util/LifecycleSupport.java"

    
    private final Object listenersLock = new Object(); // Lock object for changes to listeners
======= f1fd999:"java/org/apache/catalina/util/LifecycleSupport.java"

      synchronized (listenersLock) {
======= f1fd999:"java/org/apache/catalina/util/LifecycleSupport.java"

        synchronized (listenersLock) {

======= 81ebe8f:"java/org/apache/catalina/ant/jmx/JMXAccessorTask.java"

    public static final String JMX_SERVICE_PREFIX = "service:jmx:rmi:///jndi/rmi://";
    public static final String JMX_SERVICE_SUFFIX = "/jmxrmi";
    // ----------------------------------------------------- Instance Variables

======= f497f12:"java/org/apache/jasper/Constants.java"

======= f497f12:"java/org/apache/jasper/Constants.java"

    private static final String[] PRIVATE_STANDARD_IMPORTS = { 
    public static final List<String> STANDARD_IMPORTS =
        Collections.unmodifiableList(Arrays.asList(PRIVATE_STANDARD_IMPORTS));
======= f497f12:"java/org/apache/jasper/Constants.java"

    // TODO Add 2.4, 2.5, 3.0
    private static final String[] PRIVATE_CACHED_DTD_PUBLIC_IDS = {
    public static final List<String> CACHED_DTD_PUBLIC_IDS =
        Collections.unmodifiableList(
                Arrays.asList(PRIVATE_CACHED_DTD_PUBLIC_IDS));
    private static final String[] PRIVATE_CACHED_DTD_RESOURCE_PATHS = {
    public static final List<String> CACHED_DTD_RESOURCE_PATHS =
        Collections.unmodifiableList(
                Arrays.asList(PRIVATE_CACHED_DTD_RESOURCE_PATHS));
======= f497f12:"java/org/apache/jasper/compiler/PageInfo.java"

        imports.addAll(Constants.STANDARD_IMPORTS);
======= f497f12:"java/org/apache/jasper/xmlparser/ParserUtils.java"

        for (int i = 0; i < Constants.CACHED_DTD_PUBLIC_IDS.size(); i++) {
            String cachedDtdPublicId = Constants.CACHED_DTD_PUBLIC_IDS.get(i);
                String resourcePath =
                    Constants.CACHED_DTD_RESOURCE_PATHS.get(i);

======= 243aa86:"java/org/apache/catalina/session/ManagerBase.java"

        public PrivilegedSetRandomFile(String s) {
            devRandomSource = s;
        }
        
        public DataInputStream run(){
======= 243aa86:"java/org/apache/catalina/session/ManagerBase.java"

                log.warn("Error reading " + devRandomSource, ex);
                if (randomIS != null) {
                    try {
                        randomIS.close();
                    } catch (Exception e) {
                        log.warn("Failed to close randomIS.");
                    }
                }
                devRandomSource = null;
                randomIS=null;
            }            
======= 243aa86:"java/org/apache/catalina/session/ManagerBase.java"

        // as a hack, you can use a static file - and generate the same
            randomIS = AccessController.doPrivileged(new PrivilegedSetRandomFile(s));
======= 243aa86:"java/org/apache/catalina/session/ManagerBase.java"

                log.warn("Error reading " + devRandomSource, ex);
                if (randomIS != null) {
                    try {
                        randomIS.close();
                    } catch (Exception e) {
                        log.warn("Failed to close randomIS.");
                    }
                devRandomSource = null;

======= a9a58fb:"java/org/apache/catalina/manager/Constants.java"

        "<?xml-stylesheet type=\"text/xsl\" href=\"xform.xsl\" ?>";

======= 23c47da:"java/org/apache/tomcat/util/res/StringManager.java"

    public String getString(final String key, final Object... args) {
        if (value == null) {
            value = key;
        MessageFormat mf = new MessageFormat(value);
        mf.setLocale(locale);
        return mf.format(args, new StringBuffer(), null).toString();
======= 23c47da:"java/org/apache/tomcat/util/res/StringManager.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    private static final StringManager sm =
        StringManager.getManager("org.apache.naming");
    public void testNullKey() {
        boolean iaeThrown = false;
        
        try {
            sm.getString(null);
        } catch (IllegalArgumentException iae) {
            iaeThrown = true;
        }
        assertEquals("IAE not thrown on null key", true, iaeThrown);
    }
    
    public void testBug46933() {
        // Check null args are OK
        sm.getString("namingContext.nameNotBound");
        sm.getString("namingContext.nameNotBound", (Object[]) null);
        sm.getString("namingContext.nameNotBound", new Object[1]);
    }

======= 360f8eb:"java/org/apache/catalina/valves/AccessLogValve.java"

======= 360f8eb:"java/org/apache/catalina/valves/AccessLogValve.java"

        int offset = timezone.getDSTSavings();

======= f36a2c4:"java/org/apache/jasper/compiler/Compiler.java"

                // Fix for bugzilla 41606
                // Set JspServletWrapper.servletClassLastModifiedTime after successful compile
                String targetFileName = ctxt.getClassFileName();
                if (targetFileName != null) {
                    File targetFile = new File(targetFileName);
                    if (targetFile.exists() && jsw != null) {
                        jsw.setServletClassLastModifiedTime(targetFile.lastModified());
                    }
                }

======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

        support.firePropertyChange("delegate", oldDelegate,
                                   this.delegate);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldAntiJARLocking,
                                   this.antiJARLocking);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldAntiResourceLocking,
                                   this.antiResourceLocking);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldAvailable,
                                   this.available);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldConfigured,
                                   this.configured);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldCookies,
                                   this.cookies);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                oldUseHttpOnly,
                this.useHttpOnly);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldCrossContext,
                                   this.crossContext);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldDistributable,
                                   this.distributable);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

        support.firePropertyChange("ignoreAnnotations", oldIgnoreAnnotations,
                this.ignoreAnnotations);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldPrivileged,
                                   this.privileged);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldReloadable,
                                   this.reloadable);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldOverride,
                                   this.override);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldReplaceWelcomeFiles,
                                   this.replaceWelcomeFiles);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldSessionTimeout,
                                   this.sessionTimeout);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   oldSwallowOutput,
                                   this.swallowOutput);
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                                   Long.valueOf(oldUnloadDelay),
                                   Long.valueOf(this.unloadDelay));
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                statusPages.put(Integer.valueOf(errorPage.getErrorCode()),
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

            return (statusPages.get(Integer.valueOf(errorCode)));
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

        ErrorPage errorPage = statusPages.get(Integer.valueOf(status));
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

                statusPages.remove(Integer.valueOf(errorPage.getErrorCode()));
======= b10d9da:"java/org/apache/catalina/core/StandardContext.java"

            Integer key = Integer.valueOf(loadOnStartup);

======= fae26ce:"java/org/apache/catalina/core/StandardServer.java"

                    random = new Random();
======= fae26ce:"java/org/apache/catalina/tribes/util/UUIDGenerator.java"

    protected static Random rand = new Random();
======= fae26ce:"test/org/apache/catalina/tribes/demos/LoadTest.java"

        public static Random r = new Random();
======= fae26ce:"test/org/apache/catalina/tribes/demos/MapDemo.java"

        public static Random random = new Random();
======= fae26ce:"test/org/apache/catalina/tribes/test/channel/TestDataIntegrity.java"

        public static Random r = new Random();
======= fae26ce:"test/org/apache/catalina/tribes/test/channel/TestMulticastPackages.java"

        public static Random r = new Random();
======= fae26ce:"test/org/apache/catalina/tribes/test/channel/TestRemoteProcessException.java"

        public static Random r = new Random();
======= fae26ce:"test/org/apache/catalina/tribes/test/channel/TestUdpPackages.java"

        public static Random r = new Random();
======= fae26ce:"test/org/apache/catalina/tribes/test/io/TestSenderConnections.java"

        static Random r = new Random();

======= 08f7a5f:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                        Request[] reqs = null;
                        try {
                             reqs = (Request[])
                                session.getAttribute(cometRequestsAttribute);
                        } catch (IllegalStateException ise) {
                            // Ignore - session has been invalidated
                            // Listener will have cleaned up
                        }
======= 08f7a5f:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                                    try {
                                        session.setAttribute(
                                                cometRequestsAttribute,
                                                newConnectionInfos);
                                    } catch (IllegalStateException ise) {
                                        // Ignore - session has been invalidated
                                        // Listener will have cleaned up
                                    }
                                    try {
                                        session.removeAttribute(
                                                cometRequestsAttribute);
                                    } catch (IllegalStateException ise) {
                                        // Ignore - session has been invalidated
                                        // Listener will have cleaned up
                                    }

======= ac6369a:"java/org/apache/coyote/http11/Http11Processor.java"

                if (keptAlive) {

======= 3b1b7b3:"modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/StarvationTest.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

======= 9752018:"java/org/apache/catalina/connector/RequestFacade.java"

    public boolean getAllowTrace() {
        return request.getConnector().getAllowTrace();
    }
======= 9752018:"java/org/apache/catalina/servlets/DefaultServlet.java"

======= 9752018:"java/org/apache/catalina/servlets/DefaultServlet.java"

    
======= 9752018:"java/org/apache/catalina/servlets/DefaultServlet.java"

     * Override default implementation to ensure that TRACE is correctly
     * handled.
     *
     * @param req   the {@link HttpServletRequest} object that
     *                  contains the request the client made of
     *                  the servlet
     *
     * @param resp  the {@link HttpServletResponse} object that
     *                  contains the response the servlet returns
     *                  to the client                                
     *
     * @exception IOException   if an input or output error occurs
     *                              while the servlet is handling the
     *                              OPTIONS request
     *
     * @exception ServletException  if the request for the
     *                                  OPTIONS cannot be handled
     */
    protected void doOptions(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        StringBuffer allow = new StringBuffer();
        // There is a doGet method
        allow.append("GET, HEAD");
        // There is a doPost
        allow.append(", POST");
        // There is a doPut
        allow.append(", PUT");
        // There is a doDelete
        allow.append(", POST");
        // Trace - assume disabled unless we can prove otherwise
        if (req instanceof RequestFacade &&
                ((RequestFacade) req).getAllowTrace()) {
            allow.append(", TRACE");
        }
        // Always allow options
        allow.append(", OPTIONS");
        
        resp.setHeader("Allow", allow.toString());
    }
    
    
    /**

======= 8d2b8ff:"java/org/apache/catalina/startup/ContextConfig.java"

        if (docBase.startsWith(canonicalAppBase.getPath() + File.separatorChar)) {

======= 156f1ca:"java/org/apache/catalina/authenticator/SSLAuthenticator.java"

            response.sendError(HttpServletResponse.SC_UNAUTHORIZED,

======= 2824a70:"java/org/apache/jasper/compiler/Generator.java"

======= 2824a70:"java/org/apache/jasper/compiler/Generator.java"

                            .getLocalName(), n.getAttributes(), 
                            n.getNamedAttributeNodes(), n.hasEmptyBody());
======= 2824a70:"java/org/apache/jasper/compiler/Generator.java"

                    String shortName, Attributes attrs, Node.Nodes namedAttrs,
                    boolean hasEmptyBody) {
                    String[] attrNames =
                        new String[attrs.getLength() + namedAttrs.size()];
                    for (int i = 0; i < namedAttrs.size(); i++) {
                        attrNames[attrs.getLength() + i] =
                            ((NamedAttribute) namedAttrs.getNode(i)).getQName();
                    }

======= f0bd732:"java/org/apache/catalina/servlets/WebdavServlet.java"

======= f0bd732:"java/org/apache/catalina/servlets/WebdavServlet.java"

    /**
     * Default depth in spec is infinite. Limit depth to 3 by default as
     * infinite depth makes operations very expensive.
     */
    private int maxDepth = 3;
======= f0bd732:"java/org/apache/catalina/servlets/WebdavServlet.java"

        if (getServletConfig().getInitParameter("maxDepth") != null)
            maxDepth = Integer.parseInt(
                    getServletConfig().getInitParameter("maxDepth"));
======= f0bd732:"java/org/apache/catalina/servlets/WebdavServlet.java"

        int depth = maxDepth;
            depth = maxDepth;
                depth = maxDepth;
======= f0bd732:"java/org/apache/catalina/servlets/WebdavServlet.java"

            lock.depth = maxDepth;
                lock.depth = maxDepth;
======= f0bd732:"java/org/apache/catalina/servlets/WebdavServlet.java"

                 (lock.depth == maxDepth) ) {
======= f0bd732:"java/org/apache/catalina/servlets/WebdavServlet.java"

            if (depth == maxDepth) {

======= 7d7f757:"java/org/apache/jasper/compiler/Validator.java"

         * @param thePageDirEnc The value of the pageEncoding attribute of the page
        private void compareTagEncodings(String thePageDirEnc,
            String pageDirEnc = thePageDirEnc.toUpperCase();
======= 7d7f757:"java/org/apache/jasper/compiler/Validator.java"

                String pageEnc = root.getPageEncoding().toUpperCase();

======= 3aaac85:"java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java"

                        pc.getJspCompilationContext().getTagFileJarUrl(path),
======= 3aaac85:"java/org/apache/jasper/compiler/JspUtil.java"

======= 3aaac85:"java/org/apache/jasper/compiler/JspUtil.java"

     * 
     * @deprecated Use {@link #getTagHandlerClassName(String, String,
     *             ErrorDispatcher)
     *             See https://issues.apache.org/bugzilla/show_bug.cgi?id=46471
        return getTagHandlerClassName(path, null, err);
    }
    
    /**
     * Gets the fully-qualified class name of the tag handler corresponding to
     * the given tag file path.
     * 
     * @param path
     *            Tag file path
     * @param err
     *            Error dispatcher
     * 
     * @return Fully-qualified class name of the tag handler corresponding to
     *         the given tag file path
     */
    public static String getTagHandlerClassName(String path, String urn,
            ErrorDispatcher err) throws JasperException {
======= 3aaac85:"java/org/apache/jasper/compiler/JspUtil.java"

                className = getClassNameBase(urn);
======= 3aaac85:"java/org/apache/jasper/compiler/JspUtil.java"

    private static String getClassNameBase(String urn) {
        StringBuffer base = new StringBuffer("org.apache.jsp.tag.meta.");
        if (urn != null) {
            base.append(makeJavaPackage(urn));
            base.append('.');
        }
        return base.toString();
    }
======= 3aaac85:"java/org/apache/jasper/compiler/ParserController.java"

     * @deprecated Use {@link #parseTagFileDirectives(String, URL)}
     *             See https://issues.apache.org/bugzilla/show_bug.cgi?id=46471
        return parseTagFileDirectives(
                inFileName, ctxt.getTagFileJarUrl(inFileName));
    }
    /**
     * Extracts tag file directive information from the given tag file.
     *
     * This is invoked by the compiler 
     *
     * @param inFileName    The name of the tag file to be parsed.
     * @param tagFileJarUrl The location of the tag file.
     */
    public Node.Nodes parseTagFileDirectives(String inFileName,
            URL tagFileJarUrl)
            throws FileNotFoundException, JasperException, IOException {
        Node.Nodes page = doParse(inFileName, null, tagFileJarUrl);
======= 3aaac85:"java/org/apache/jasper/compiler/TagFileProcessor.java"

======= 3aaac85:"java/org/apache/jasper/compiler/TagFileProcessor.java"

            String tagClassName = JspUtil.getTagHandlerClassName(
                    path, tagLibInfo.getReliableURN(), err);
======= 3aaac85:"java/org/apache/jasper/compiler/TagFileProcessor.java"

     * @deprecated Use {@link TagFileProcessor#parseTagFileDirectives(
     *                  ParserController, String, String, URL, TagLibraryInfo)}
     *             See https://issues.apache.org/bugzilla/show_bug.cgi?id=46471
        return parseTagFileDirectives(pc, name, path,
                pc.getJspCompilationContext().getTagFileJarUrl(path),
                tagLibInfo);
    }
    
    /**
     * Parses the tag file, and collects information on the directives included
     * in it. The method is used to obtain the info on the tag file, when the
     * handler that it represents is referenced. The tag file is not compiled
     * here.
     * 
     * @param pc
     *            the current ParserController used in this compilation
     * @param name
     *            the tag name as specified in the TLD
     * @param tagfile
     *            the path for the tagfile
     * @param tagFileJarUrl
     *            the url for the Jar containign the tag file 
     * @param tagLibInfo
     *            the TagLibraryInfo object associated with this TagInfo
     * @return a TagInfo object assembled from the directives in the tag file.
     */
    public static TagInfo parseTagFileDirectives(ParserController pc,
            String name, String path, URL tagFileJarUrl, TagLibraryInfo tagLibInfo)
            throws JasperException {
            page = pc.parseTagFileDirectives(path, tagFileJarUrl);
======= 3aaac85:"java/org/apache/jasper/compiler/TagFileProcessor.java"

        URL tagFileJarUrl = null;
        if (tagFilePath.startsWith("/META-INF/")) {
            try { 
                tagFileJarUrl = new URL("jar:" +
                        compiler.getCompilationContext().getTldLocation(
                        tagInfo.getTagLibrary().getURI())[0] + "!/");
            } catch (MalformedURLException e) {
                e.printStackTrace();
            }
        }
        String tagFileJarPath;
        if (tagFileJarUrl == null) {
            tagFileJarPath = "";
        } else {
            tagFileJarPath = tagFileJarUrl.toString();
        }
        JspServletWrapper wrapper = rctxt.getWrapper(tagFileJarPath + tagFilePath);
                        .getRuntimeContext(), tagFileJarUrl);
                rctxt.addWrapper(tagFileJarPath + tagFilePath, wrapper);
======= 3aaac85:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

            // See https://issues.apache.org/bugzilla/show_bug.cgi?id=46471
            // This needs to be removed once all the broken code that depends on
            // it has been removed
                parserController, name, path, jarFileUrl, this);
======= 3aaac85:"java/org/apache/jasper/compiler/TagLibraryInfoImpl.java"

                 // Do nothing

======= 1ca03ff:"java/org/apache/jasper/servlet/JasperLoader.java"

        if( !name.startsWith(Constants.JSP_PACKAGE_NAME + '.') ) {

======= e31998a:"java/org/apache/catalina/realm/JDBCRealm.java"

        if (dbConnection == null) {
            throw new SQLException(sm.getString(
                    "jdbcRealm.open.invalidurl",driverName, connectionURL));
        }

======= 85fc30c:"java/org/apache/catalina/core/StandardContext.java"

        setName(path);
======= 85fc30c:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= 85fc30c:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    protected static final URLEncoder URL_ENCODER; 
    static {
        URL_ENCODER = new URLEncoder();
        // '/' should not be encoded in context paths
        URL_ENCODER.addSafeCharacter('/');
    }
======= 85fc30c:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

 
======= 85fc30c:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                args = new Object[7];
                args[0] = URL_ENCODER.encode(displayPath);
                args[1] = displayPath;
                args[2] = context.getDisplayName();
                if (args[2] == null) {
                    args[2] = "&nbsp;";
                args[3] = new Boolean(context.getAvailable());
                args[4] = response.encodeURL
                     "/html/sessions?path=" + URL_ENCODER.encode(displayPath));
                    args[5] = new Integer
                    args[5] = new Integer(0);
                args[6] = highlightColor;
======= 85fc30c:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                     "/html/start?path=" + URL_ENCODER.encode(displayPath));
                     "/html/stop?path=" + URL_ENCODER.encode(displayPath));
                     "/html/reload?path=" + URL_ENCODER.encode(displayPath));
                     "/html/undeploy?path=" + URL_ENCODER.encode(displayPath));
                     "/html/expire?path=" + URL_ENCODER.encode(displayPath));
======= 85fc30c:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        " <td class=\"row-left\" bgcolor=\"{6}\" rowspan=\"2\"><small><a href=\"{0}\">{1}</a>" +
        " <td class=\"row-left\" bgcolor=\"{6}\" rowspan=\"2\"><small>{2}</small></td>\n" +
        " <td class=\"row-center\" bgcolor=\"{6}\" rowspan=\"2\"><small>{3}</small></td>\n" +
        " <td class=\"row-center\" bgcolor=\"{6}\" rowspan=\"2\">" +
        "<small><a href=\"{4}\" target=\"_new\">{5}</a></small></td>\n";

======= 24bcb47:"java/org/apache/jasper/compiler/Generator.java"

            Class<?> type = expectedType;
======= 24bcb47:"java/org/apache/jasper/compiler/Generator.java"

                            // Composite expression - must coerce to String
                            type = String.class;
======= 24bcb47:"java/org/apache/jasper/compiler/Generator.java"

                        // Composite expression - must coerce to String
                        type = String.class;
                                    tx.substring(mark, i+1), type,

======= 7e6a2ec:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

        if(!(econtainer instanceof Engine)) {

======= 5277185:"java/org/apache/jasper/compiler/Generator.java"

            if (isPoolingEnabled && !(n.implementsJspIdConsumer())) {

======= 99c5ca6:"java/org/apache/tomcat/util/http/ServerCookie.java"

    /**
     * If set to false, we don't use the IE6/7 Max-Age/Expires work around
     */
    public static final boolean ALWAYS_ADD_EXPIRES =
        Boolean.valueOf(System.getProperty("org.apache.tomcat.util.http.ServerCookie.ALWAYS_ADD_EXPIRES", "true")).booleanValue();
======= 99c5ca6:"java/org/apache/tomcat/util/http/ServerCookie.java"

            if (version > 0) {
                buf.append ("; Max-Age=");
                buf.append (maxAge);
            }
            // IE6, IE7 and possibly other browsers don't understand Max-Age.
            // They do understand Expires, even with V1 cookies!
            if (version == 0 || ALWAYS_ADD_EXPIRES) {
======= 99c5ca6:"java/org/apache/tomcat/util/http/ServerCookie.java"

    <property
    name="org.apache.tomcat.util.http. ServerCookie.ALWAYS_ADD_EXPIRES">
      <p>If this is <code>true</code> Tomcat will always add an expires
      parameter to a SetCookie header even for cookies with version greater than
      zero. This is to work around a known IE6 and IE7 bug that causes IE to
      ignore the Max-Age parameter in a SetCookie header.If not specified, the
      default value of <code>true</code> will be used.</p>
    </property>

======= a1e4c86:"java/org/apache/catalina/security/SecurityUtil.java"

        } catch( PrivilegedActionException pe) {
            Throwable e;
            if (pe.getException() instanceof InvocationTargetException) {
                e = ((InvocationTargetException)pe.getException())
            } else {
                e = pe;
            }

======= 408175f:"modules/bayeux/java/org/apache/cometd/bayeux/Bayeux.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * This interface represents the server side API for the Bayeux messaging protocol.
 * Bayeux is a simple subscribe/publish/receive methodology, not far from JMS, but much simplified.<br/>
 * It is used both by the actual implementation and by server side clients.<br/>
 * Server side clients use this to create, retrieve and subscribe to channels.
 * Server side clients are represented, just like remote clients, through the Client interface.
 * <br/>
 * The Bayeux implementations is intended to be thread safe and multiple threads may simultaneously call Bayeux methods.
 * <br/>
 * The Bayeux object, is the starting point for any cometd application relying on the Bayeux object.
 * Dependent on the container, the Bayeux object will be stored in the <code>javax.servlet.ServletContext</code> object
 * as an attribute under the name <code>Bayeux.DOJOX_COMETD_BAYEUX</code><br/>
 * To retrieve this object, one would simply call<br/>
 * <code>Bayeux bx = (Bayeux)getServletContext().getAttribute(Bayeux.DOJOX_COMETD_BAYEUX);
 * <br/><br/>
 * The Bayeux protocol is pretty straight forward and includes a bunch of messaging that is not needed to be known to clients,
 * both server side and remote clients.
 * This object gets initialized by a container dependent servlet, and the servlet then handles all Bayeux communication from the client.
 * Remote messsages are delivered to channels, and to server side clients using the <code>Listener</code> interface.<br/>
 * <br/>
 * A <code>Bayeux session</code> is active as long as the webapp hosting the Bayeux object is active.<br/>
 * When the webapplication shuts down, the Bayeux object will unsubscribe all clients and remove all the active channels.
 * 
 * @author Greg Wilkins
 * @author Filip Hanik
 */
    
    /**Meta definitions for channels*/
    public static final String META="/meta";
    /**Meta definitions for channels*/
    public static final String META_SLASH="/meta/";
    /**Meta definitions for channels - connect message*/
    public static final String META_CONNECT="/meta/connect";
    /**Meta definitions for channels - client messsage*/
    public static final String META_CLIENT="/meta/client";
    /**Meta definitions for channels - disconnect messsage*/
    public static final String META_DISCONNECT="/meta/disconnect";
    /**Meta definitions for channels - handshake messsage*/
    public static final String META_HANDSHAKE="/meta/handshake";
    /**Meta definitions for channels - ping messsage*/
    public static final String META_PING="/meta/ping";
    /**Meta definitions for channels - reconnect messsage
     * @deprecated
     */
    public static final String META_RECONNECT="/meta/reconnect";
    /**Meta definitions for channels - status messsage*/
    public static final String META_STATUS="/meta/status";
    /**Meta definitions for channels - subscribe messsage*/
    public static final String META_SUBSCRIBE="/meta/subscribe";
    /**Meta definitions for channels - unsubscribe messsage*/
    public static final String META_UNSUBSCRIBE="/meta/unsubscribe";
    /*Field names inside Bayeux messages*/
    /**Field names inside Bayeux messages - clientId field*/
    public static final String CLIENT_FIELD="clientId";
    /**Field names inside Bayeux messages - data field*/
    public static final String DATA_FIELD="data";
    /**Field names inside Bayeux messages - channel field*/
    public static final String CHANNEL_FIELD="channel";
    /**Field names inside Bayeux messages - id field*/
    public static final String ID_FIELD="id";
    /**Field names inside Bayeux messages - error field*/
    public static final String ERROR_FIELD="error";
    /**Field names inside Bayeux messages - timestamp field*/
    public static final String TIMESTAMP_FIELD="timestamp";
    /**Field names inside Bayeux messages - transport field*/
    public static final String TRANSPORT_FIELD="transport";
    /**Field names inside Bayeux messages - advice field*/
    public static final String ADVICE_FIELD="advice";
    /**Field names inside Bayeux messages - successful field*/
    public static final String SUCCESSFUL_FIELD="successful";
    /**Field names inside Bayeux messages - subscription field*/
    public static final String SUBSCRIPTION_FIELD="subscription";
    /**Field names inside Bayeux messages - ext field*/
    public static final String EXT_FIELD="ext";
    /**Field names inside Bayeux messages - connectionType field*/
    public static final String CONNECTION_TYPE_FIELD="connectionType";
    /**Field names inside Bayeux messages - version field*/
    public static final String VERSION_FIELD="version";
    /**Field names inside Bayeux messages - minimumVersion field*/
    public static final String MIN_VERSION_FIELD="minimumVersion";
    /**Field names inside Bayeux messages - supportedConnectionTypes field*/
    public static final String SUPP_CONNECTION_TYPE_FIELD="supportedConnectionTypes";
    /**Field names inside Bayeux messages - json-comment-filtered field*/
    public static final String JSON_COMMENT_FILTERED_FIELD="json-comment-filtered";
    /**Field names inside Bayeux messages - reconnect field*/
    public static final String RECONNECT_FIELD = "reconnect";
    /**Field names inside Bayeux messages - interval field*/
    public static final String INTERVAL_FIELD = "interval";
    /**Field values inside Bayeux messages - retry response*/
    public static final String RETRY_RESPONSE = "retry";
    /**Field values inside Bayeux messages - handshake response*/
    public static final String HANDSHAKE_RESPONSE = "handshake";
    /**Field values inside Bayeux messages - none response*/
    public static final String NONE_RESPONSE = "none";
    /**Service channel names-starts with*/
    public static final String SERVICE="/service";
    /**Service channel names-trailing slash*/
    public static final String SERVICE_SLASH="/service/";
    /*Transport types*/
    /**Transport types - long polling*/
    public static final String TRANSPORT_LONG_POLL="long-polling";
    /**Transport types - callback polling*/
    public static final String TRANSPORT_CALLBACK_POLL="callback-polling";
    /**Transport types - iframe*/
    public static final String TRANSPORT_IFRAME="iframe";
    /**Transport types - flash*/
    public static final String TRANSPORT_FLASH="flash";
    /** ServletContext attribute name used to obtain the Bayeux object */
    public static final String DOJOX_COMETD_BAYEUX="dojox.cometd.bayeux";
    /*http field names*/
    /**http helpers - text/json content type*/
    public static final String JSON_CONTENT_TYPE="text/json";
    /**http helpers - parameter name for json message*/
    public static final String MESSAGE_PARAMETER="message";
    /**http helpers - name of the jsonp parameter*/
    public static final String JSONP_PARAMETER="jsonp";
    /**http helpers - default name of the jsonp callback function*/
    public static final String JSONP_DEFAULT_NAME="jsonpcallback";
    /*--Client----------------------------------------------------------- */
    /**
     * Creates a new server side client. This method is to be invoked
     * by server side objects only. You cannot create a remote client by using this method.
     * A client represents an entity that can subscribe to channels and publish and receive messages
     * through these channels
     * @param idprefix String - the prefix string for the id generated, can be null
     * @param listener Listener - a callback object to be called when messages are to be delivered to the new client
     * @return Client - returns an implementation of the client interface.
     */
    public Client newClient(String idprefix, Listener listener);
    /**
     * retrieve a client based on an ID. Will return null if the client doesn't exist.
     * @param clientid String
     * @return Client-null if the client doesn't exist.returns the client if it does.
     */
    public Client getClient(String clientid);
    
    /**
     * Returns a non modifiable list of all the clients that are currently active
     * in this Bayeux session
     * @return List<Client> - a list containing all clients. The List can not be modified.
     */
    public List<Client> getClients();
    
    /**
     * Returns true if a client with the given id exists.<br/>
     * Same as executing <code>getClient(id)!=null</code>.
     * @param clientId String
     * @return boolean - true if the client exists
     */
    public boolean hasClient(String clientId);
    
    /**
     * Removes the client all together.
     * This will unsubscribe the client to any channels it may be subscribed to
     * and remove it from the list.
     * @param client Client
     * @return Client - returns the client that was removed, or null if no client was removed.
     */
    public Client remove(Client client);
    
    /*--Channel---------------------------------------------------------- */
    /**
     * Returns the channel for a given channel id.
     * If the channel doesn't exist, and the <code>create</code> parameter is set to true,
     * the channel will be created and added to the list of active channels.<br/>
     * if <code>create</code> is set to false, and the channel doesn't exist, null will be returned.
     * @param channelId String - the id of the channel to be retrieved or created
     * @param create boolean - true if the Bayeux impl should create the channel
     * @return Channel - null if <code>create</code> is set to false and the channel doesn't exist, 
     * otherwise it returns a channel object.
     */
    public Channel getChannel(String channelId, boolean create);
    
    /**
     * Returns a list of currently active channels in this Bayeux session.
     * @return List<Channel>
     */
    public List<Channel> getChannels();
    /**
     * Removes a channel from the Bayeux object.
     * This will also unsubscribe all the clients currently subscribed to the
     * the channel.
     * @param channel Channel - the channel to be removed
     * @return Channel - returns the channel that was removed, or null if no channel was removed.
     */
    public Channel remove(Channel channel);
    /**
     * returns true if a channel with the given channelId exists.
     * <br/>Same as executing <code>Bayeux.getChannel(channelId,false)!=null</code>
     * @param channelId String
     * @return boolean - true if the channel exists.
     */
    public boolean hasChannel(String channelId);
    /* --Message---------------------------------------------------------- */
    /**
     * Creates a new message to be sent by a server side client.
     * @return Message - returns a new Message object, that has a unique id.
     */
    public Message newMessage(Client from);
    /*--Security policy----------------------------------------------------------- */
    /**
     * Returns the security policy associated with this Bayeux session
     * @return SecurityPolicy
     */
    public SecurityPolicy getSecurityPolicy();
   
    /**
     * Sets the security policy to be used in this Bayeux session
     * @param securityPolicy SecurityPolicy
     */
    public void setSecurityPolicy(SecurityPolicy securityPolicy);
======= 408175f:"modules/bayeux/java/org/apache/cometd/bayeux/Channel.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * A Bayeux Channel represents a channel used to receive messages from and to publish messages to.
 * In order to publish messages to or receive messages from, one must subscribe to the channel.
 * This is easily done by invoking the <code>subscribe</code> method.
 * A channel is created by calling the <code>Bayeux.getChannel(channelId,true)</code> method.
 * A channel can be created either server side by invoking the getChannel, or client side
 * by using the /meta/subscribe message without a wildcard.
 * @author Greg Wilkins
 * @author Filip Hanik
 */
    /**
     * Returns the id for this channel. The id is unique within bayeux session.
     * @return String - will never be null.
     */
    public String getId();
    /** 
     * Publishes a message to all the subscribers of this channel.
     * The <code>from</code> is contained within the message, by calling
     * <code>msg.getClient()</code>
     * @param data - the message to be published, can not be null.
     */
    public void publish(Message msg);
    
    /** 
     * Publishes more than one message to all the subscribers of this channel.
     * The <code>from</code> is contained within the message, by calling
     * <code>msg[x].getClient()</code>
     * @param data - the message to be published, can not be null.
     */
    public void publish(Message[] msgs);
    /** 
     * Non persistent channels are removed when the last subscription is
     * removed. Persistent channels survive periods without any subscribers.
     * @return true if the Channel will persist without any subscription.
     */
    public boolean isPersistent();
    
    /**
     * @param persistent true if the Channel will persist without any subscription.
     * @see isPersistent
     */
    public void setPersistent(boolean persistent);
    
    /** 
     * Subscribes a client to a channel.
     * @param subscriber - the client to be subscribed. If the client
     * already is subscribed, this call will not create a duplicate subscription.
     */
    public void subscribe(Client subscriber);
    /** 
     * Unsubscribes a client from a channel
     * @param subscriber - the client to be subscribed.
     * @return - returns the client that was unsubscribed, or null if the client wasn't subscribed.
     */
    public Client unsubscribe(Client subscriber);
    /**
     * returns a non modifiable list of all the subscribers to this 
     * channel.
     * @return a list of subscribers
     */
    public List<Client> getSubscribers();
    
    /**
     * Adds a data filter to this channel. All messages received by this channel 
     * will run through this filter.
     * @param filter Filter
     */
    public void addFilter(DataFilter filter);
    
    /**
     * Removes a filter from this channel.
     * returns the filter that was removed, or null if the filter wasn't in the channel.
     * @param filter Filter
     * @return Filter - null if no filter was removed otherwise it returns the filter that was removed.
     */
    public DataFilter removeFilter(DataFilter filter);
======= 408175f:"modules/bayeux/java/org/apache/cometd/bayeux/Client.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * <p>
 * A client may subscribe to channels and publish messages to channels.
 * Client instances should not be directly created by uses, but should 
 * be obtained via the {@link Bayeux#getClient(String)} or {@link Bayeux#newClient(String, Listener)}
 * methods.
 * </p>
 * <p>
 * Three types of client may be represented by this interface:<nl>
 * <li>The server representation of a remote client connected via HTTP, 
 *     automatically created by the Bayeux server when a connect message comes in</li>
 * <li>A server side client, created by the application using the {@link Bayeux#newClient(String, Listener)} method</li>
 * <li>A java client connected to a remote Bayeux server - not implemented</li>
 * </nl>
 * @author Greg Wilkins
 * @author Filip Hanik
 */
    /**
     * Returns a unique id for this client. The id is unique within this Bayeux session.
     * @return String - will not be null
     */
    public String getId();
    /**
     * Returns true if this client is holding messages to be delivered to the remote client.
     * This method always returns false for local clients, since messages are delivered instantly using the 
     * Listener(callback) object
     * @return boolean
     */
    public boolean hasMessages();
    /** 
     * Deliver a message to this client only
     * Deliver a message directly to the client. The message is not 
     * filtered or published to a channel.
     * @param message
     */
    public void deliver(Message message);
    /** 
     * Deliver a batch of messages to this client only
     * Deliver a batch messages directly to the client. The messages are not 
     * filtered or published to a channel.
     * @param message
     */
    public void deliver(Message[] message);
    /**
     * @return True if the client is local. False if this client is either a remote HTTP client or
     * a java client to a remote server. 
     */
    public boolean isLocal();
    
    /**
     * Starts a batch, no messages will be delivered until endBatch is called.
     * Batches can be nested, and messages will only be delivered after
     * the last endBatch has been called.
     */
    public void startBatch();
    
    /**
     * Ends a batch. since batches can be nested, messages will only be delivered
     * after the endBatch has been called as many times as startBatch has.
     */
    public void endBatch();
    
    
======= 408175f:"modules/bayeux/java/org/apache/cometd/bayeux/DataFilter.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Data Filter<br/>
 * Data filters are used to transform data as it is sent to a Channel.
 * Messages are filtered as the message is published to a channel, invoking the 
 * {@link Channel#publish(Message)} method.<br/>
 * This method gets invoked in two different scenarios, the first being when a message is received from
 * a remote client, and the Bayeux implementation invokes the publish method directly.
 * The second scenario is when a local client invokes {@link Channel#publish(Message)} directly in the local JVM.
 * @author Greg Wilkins
 * @author Filip Hanik
 *
 */
    /**
     * Runs a message through the filter. Filtering can only modify an existing object, it can not replace it.
     * @param data Message - the message to be filtered, may not be null
     */
    public void filter(Message data);
======= 408175f:"modules/bayeux/java/org/apache/cometd/bayeux/Listener.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Cometd Listener interface.<br/>
 * For local clients, in order to receive messages, they pass in a callback object
 * when the local client is created using the {@link Bayeux#newClient(String,Listener)} method.
 * This callback object, implementing the Listener interface, is used to deliver messages to local, in JVM, clients.
 * @author Greg Wilkins
 * @author Filip Hanik
 *
 */
    /**
     * This method is called when the client is removed (explicitly or from a timeout)
     * @param timeout - true if the client was removed from a timeout
     * false if it was removed explicitly.
     */
    public void removed(boolean timeout);
    
    /**
     * Invoked when a message is delivered to the client.
     * The message contains the message itself, as well as what channel this message came through
     * and who the sender is. If someone invoked {@link Client#deliver(Message)} then the channel reference will
     * be null.
     * @param msg 
     */
    public void deliver(Message[] msg);
======= 408175f:"modules/bayeux/java/org/apache/cometd/bayeux/Message.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * A Bayeux Message<br/>
 * A Bayeux message is a Map of String/Object key value pairs representing the data in the message.
 * The message contains information about the channel it was published through and who the sender was
 * 
 * @author Greg Wilkins
 * @author Filip Hanik
 */
    /**
     * Returns a reference to the client that sent this message
     * @return Client - may be null
     */
    public Client getClient();
    /**
     * Returns a reference to the channel that this message was published throuhg
     * @return Channel - may be null
     */
    public Channel getChannel();
    /**
     * Returns the unique id of this message
     * @return String
     */
    public String getId();
    
    /**
     * Sets the time to live in milliseconds. If the message hasn't been delivered 
     * when the time passed after the creation time is longer than the TTL the message will
     * expire and removed from any delivery queues.
     * @param ttl long
     */
    public void setTTL(long ttl);
    
    /**
     * Returns the time to live (in milliseconds) for this message
     * @return long
     */
    public long getTTL();
    
    /**
     * returns the timestamp in milliseconds(System.currentTimeMillis()) of when this message was created.
     * @return long
     */
    public long getCreationTime();
======= 408175f:"modules/bayeux/java/org/apache/cometd/bayeux/SecurityPolicy.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * @author Greg Wilkins
 */
    boolean canHandshake(Message message);
    boolean canCreate(Client client,String channel,Message message);
    boolean canSubscribe(Client client,String channel,Message messsage);
    boolean canPublish(Client client,String channel,Message messsage);
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/BayeuxException.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * 
 * @author Filip Hanik
 * @version 1.0
 */
    public BayeuxException() {
        super();
    }
    public BayeuxException(String message) {
        super(message);
    }
    public BayeuxException(String message, Throwable cause) {
        super(message, cause);
    }
    public BayeuxException(Throwable cause) {
        super(cause);
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/BayeuxRequest.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * An interface that defines methods for managing Bayeux request meta 
 * messages.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 0.9
 */
    public static final String LAST_REQ_ATTR = "org.apache.cometd.bayeux.last_request";
    public static final String CURRENT_REQ_ATTR = "org.apache.cometd.bayeux.current_request";
    public static final String JSON_MSG_ARRAY = "org.apache.cometd.bayeux.json_msg_array";
    /**
     * Validates a specific request. 
     * This method must be called prior to process()
     * as a request can do pre processing in the validate method.
     * <br/>
     * Should the validation fail, an error object is returned 
     * containing an error message, and potentially a stack trace
     * if an exception was generated
     * @return HttpError - null if no error was detected, an HttpError object containing information about the error.
     */
    public HttpError validate();
    
    /**
     * processes a remote client Bayeux message
     * @param prevops - the operation requested by the previous request, in case of chained requests.
     * @return int - returns the interest operation for a CometEvent. Currently not used
     * @throws BayeuxException - if an error was detected, and the appropriate error response couldn't be delivered to the client. 
     */
    public int process(int prevops) throws BayeuxException;
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/BayeuxServlet.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * 
 * @author Filip Hanik
 * @author Guy Molinari
 * @version 1.0
 */
    /**
     * Attribute to hold the TomcatBayeux object in the servlet context
     */
    public static final String TOMCAT_BAYEUX_ATTR = Bayeux.DOJOX_COMETD_BAYEUX;
    
    /**
     * Logger object
     */
    protected static Log log = LogFactory.getLog(BayeuxServlet.class);
    /**
     * Servlet config - for future use
     */
    protected ServletConfig servletConfig;
    
    /**
     * Reference to the global TomcatBayeux object
     */
    protected TomcatBayeux tb;
    
    /**
     * Upon servlet destruction, the servlet will clean up the 
     * TomcatBayeux object and terminate any outstanding events.
     */
    public void destroy() {
        servletConfig = null;
        //to do, close all outstanding comet events
        //tb.destroy();
        tb = null;//TO DO, close everything down
        
    }
    
    /**
     * Returns the preconfigured connection timeout.
     * If no timeout has been configured as a servlet init parameter named <code>timeout</code>
     * then the default of 2min will be used.
     * @return int - the timeout for a connection in milliseconds
     */
    protected int getTimeout() {
        String timeoutS = servletConfig.getInitParameter("timeout");
        int timeout = 120*1000; //2 min
        try {
            timeout = Integer.parseInt(timeoutS);
        }catch (NumberFormatException nfe) {
            //ignore, we have a default value
        }
        return timeout;
    }
    
    protected int getReconnectInterval() {
        String rs = servletConfig.getInitParameter("reconnectInterval");
        int rct = 1000; //1 seconds
        try {
            rct = Integer.parseInt(rs);
        }catch (NumberFormatException nfe) {
            //ignore, we have a default value
        }
        return rct;
    }
    public void event(CometEvent cometEvent) throws IOException, ServletException {
        CometEvent.EventType type = cometEvent.getEventType();
        if (log.isDebugEnabled()) {
            log.debug("["+Thread.currentThread().getName()+"] Received Comet Event type="+type+" subtype:"+cometEvent.getEventSubType());
        }
        synchronized (cometEvent) {
            if (type==CometEvent.EventType.BEGIN) {
                //begin event, set the timeout
                cometEvent.setTimeout(getTimeout());
                //checkBayeux(cometEvent); - READ event should always come
            } else if (type==CometEvent.EventType.READ) {
                checkBayeux(cometEvent);
            } else if (type==CometEvent.EventType.ERROR) {
                tb.remove(cometEvent);
                cometEvent.close();
            } else if (type==CometEvent.EventType.END) {
                tb.remove(cometEvent);
                cometEvent.close();
            }//end if
            
        }//synchronized
    }//event
    /**
     * 
     * @param cometEvent CometEvent
     * @return boolean - true if we comet event stays open
     * @throws IOException
     * @throws UnsupportedOperationException
     */
    protected void checkBayeux(CometEvent cometEvent) throws IOException, UnsupportedOperationException {
        //we actually have data.
        //data can be text/json or 
        if (Bayeux.JSON_CONTENT_TYPE.equals(cometEvent.getHttpServletRequest().getContentType())) {
            //read and decode the bytes according to content length
            log.warn("["+Thread.currentThread().getName()+"] JSON encoding not supported, will throw an exception and abort the request.");
            int contentlength = cometEvent.getHttpServletRequest().getContentLength();
            throw new UnsupportedOperationException("Decoding "+Bayeux.JSON_CONTENT_TYPE+" not yet implemented.");
        } else { //GET method or application/x-www-form-urlencoded
            String message = cometEvent.getHttpServletRequest().getParameter(Bayeux.MESSAGE_PARAMETER);
            if (log.isTraceEnabled()) {
                log.trace("["+Thread.currentThread().getName()+"] Received JSON message:"+message);
            }
            try {
                int action = handleBayeux(message, cometEvent);
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Bayeux handling complete, action result="+action);
                }
                if (action<=0) {
                    cometEvent.close();
                }
            }catch (Exception x) {
                x.printStackTrace();
                tb.remove(cometEvent);
                log.error(x);
                cometEvent.close();
            }
        }
    }
    
    protected int handleBayeux(String message, CometEvent event) throws IOException, ServletException {
        int result = 0;
        if (message==null || message.length()==0) return result;
        try {
            BayeuxRequest request = null;
            //a message can be an array of messages
            JSONArray jsArray = new JSONArray(message);
            for (int i = 0; i < jsArray.length(); i++) {
                JSONObject msg = jsArray.getJSONObject(i);
                
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Processing bayeux message:"+msg);
                }
                request = RequestFactory.getRequest(tb,event,msg);
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Processing bayeux message using request:"+request);
                }
                result = request.process(result);
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Processing bayeux message result:"+result);
                }
            }
            if (result>0 && request!=null) {
                event.getHttpServletRequest().setAttribute(BayeuxRequest.LAST_REQ_ATTR, request);
                ClientImpl ci = (ClientImpl)tb.getClient(((RequestBase)request).getClientId());
                ci.addCometEvent(event);
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Done bayeux message added to request attribute");
                }
            } else if (result == 0 && request!=null) {
                RequestBase.deliver(event,(ClientImpl)tb.getClient(((RequestBase)request).getClientId()));
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Done bayeux message, delivered to client");
                }
            }
            
        }catch (JSONException x) {
            log.error(x);//to do impl error handling
            result = -1;
        }catch (BayeuxException x) {
            log.error(x); //to do impl error handling
            result = -1;
        }
        return result;
    }
    public ServletConfig getServletConfig() {
        return servletConfig;
    }
    public String getServletInfo() {
        return "Tomcat/BayeuxServlet/1.0";
    }
    public void init(ServletConfig servletConfig) throws ServletException {
        
        this.servletConfig = servletConfig;
        ServletContext ctx = servletConfig.getServletContext();
        if (ctx.getAttribute(TOMCAT_BAYEUX_ATTR)==null)
            ctx.setAttribute(TOMCAT_BAYEUX_ATTR,new TomcatBayeux());
        this.tb = (TomcatBayeux)ctx.getAttribute(TOMCAT_BAYEUX_ATTR);
        tb.setReconnectInterval(getReconnectInterval());
    }
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        if (servletResponse instanceof HttpServletResponse) {
            ( (HttpServletResponse) servletResponse).sendError(500, "Misconfigured Tomcat server, must be configured to support Comet operations.");
        } else {
            throw new ServletException("Misconfigured Tomcat server, must be configured to support Comet operations for the Bayeux protocol.");
        }
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/ChannelImpl.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * 
 * @author Filip Hanik
 * @version 1.0
 */
    
    protected static Log log = LogFactory.getLog(ChannelImpl.class);
    
    /**
     * The unique id of this channel
     */
    protected String id = null;
    
    /**
     * A list of the current subscribers
     */
    protected LinkedList<Client> subscribers = new LinkedList<Client>();
    
    /**
     * A list of the current filters
     */
    protected LinkedList<DataFilter> filters = new LinkedList<DataFilter>();
    
    /**
     * Is this channel persistent, default value is true
     */
    protected boolean persistent = true; 
    
    /**
     * Creates a new channel
     * @param id String - the id of the channel, can not be null
     */
    protected ChannelImpl(String id) {
        assert id != null;
        this.id = id;
    }
    /**
     * returns the id of this channel
     * @return String
     */
    public String getId() {
        return id;
    }
    
    /**
     * Returns true if this channel matches the pattern to its id.
     * The channel pattern can be a complete name like <code>/service/mychannel</code>
     * or it can be a wild card pattern like <code>/service/app2/**</code>
     * @param pattern String according to the Bayeux specification section 2.2.1 Channel Globbing, can not be null.
     * @return boolean true if the id of this channel matches the pattern
     */
    public boolean matches(String pattern) {
        if (pattern == null)
            throw new NullPointerException("Channel pattern must not be null.");
        if (getId().equals(pattern))
            return true;
        int wildcardPos = pattern.indexOf("/*");
        if (wildcardPos == -1)
            return false;
        boolean multiSegment = pattern.indexOf("**") != -1;
        String leadSubstring = pattern.substring(0, wildcardPos);
        if (leadSubstring == null)
            return false;
        if (multiSegment) 
            return getId().startsWith(leadSubstring);
        else {
            if (getId().length() <= wildcardPos + 2)
                return false;
            return !(getId().substring(wildcardPos + 2).contains("/"));
        }
    }
    /**
     * @return returns a non modifiable list of the subscribers for this channel.
     */
    public List<Client> getSubscribers() {
        return Collections.unmodifiableList(subscribers);
    }
    /**
     * @return true if the Channel will persist without any subscription.
     */
    public boolean isPersistent() {
        return persistent;
    }
    
    public void publish(Message msg) {
        publish(new Message[] {msg});
    }
    public void publish(Message[] msgs) {
        if (msgs==null) return;
        MessageImpl[] imsgs = new MessageImpl[msgs.length];
        for (int i=0; msgs!=null && i<msgs.length; i++) {
            Message data = msgs[i];
            if (!(data instanceof MessageImpl)) 
                throw new IllegalArgumentException("Invalid message class, you can only publish messages "+
                                                   "created through the Bayeux.newMessage() method");
            if (log.isDebugEnabled()) {
                log.debug("Publishing message:"+data+" to channel:"+this);
            }
            //clone it so that we can set this channel as a reference
            MessageImpl msg = (MessageImpl)((MessageImpl)data).clone();
            //this is the channel it was delivered through
            msg.setChannel(this);
            //pass through filters
            for (Iterator<DataFilter> it = filters.iterator(); it.hasNext(); ) {
                it.next().filter(msg);
            }
            imsgs[i] = msg;
        }
        //deliver it to the clients
        for (Iterator<Client> it = subscribers.iterator(); it.hasNext(); ) {
            ClientImpl c = (ClientImpl)it.next();
            c.deliverInternal(this,imsgs);
        }
        
    }
    public void setPersistent(boolean persistent) {
        this.persistent = persistent;
    }
    public void subscribe(Client subscriber) {
        if (!subscribers.contains((subscriber))) { 
            subscribers.addLast(subscriber);
            ((ClientImpl)subscriber).subscribed(this);
        }
    }
    public Client unsubscribe(Client subscriber) {
        if (subscribers.remove(subscriber)) {
            ((ClientImpl)subscriber).unsubscribed(this);
            return subscriber;
        } else
            return null;
    }
    
    public void addFilter(DataFilter filter) {
        if (!filters.contains(filter)) 
            filters.addLast(filter);
    }
    public DataFilter removeFilter(DataFilter filter) {
        if ( filters.remove(filter) ) return filter;
        else return null;
    }
    
    public String toString() {
        StringBuffer buf = new StringBuffer(super.toString());
        buf.append("; channelId=").append(getId());
        return buf.toString();
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/ClientImpl.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    
    public static final int SUPPORT_CALLBACK_POLL = 0x1;
    public static final int SUPPORT_LONG_POLL = 0x2; 
    public static final String COMET_EVENT_ATTR = "org.apache.cometd.bayeux.client";
    
    protected static Log log = LogFactory.getLog(ClientImpl.class);
    protected static LinkedList<Message> EMPTY_LIST = new LinkedList<Message>();
    /**
     * queued message for remote clients.
     */
    protected LinkedList<Message> messages = null;
    
    /**
     * 
     */
    protected Queue<CometEvent> events = new LinkedList<CometEvent>();
    
    /**
     * Unique id representing this client
     */
    protected String id;
    
    /**
     * supported connection types, defaults to long-polling
     */
    protected int supportedConnTypes = SUPPORT_LONG_POLL | SUPPORT_CALLBACK_POLL;
    
    /**
     * The desired connection type
     */
    protected int desirectConnType = SUPPORT_LONG_POLL;
    
    /**
     * Does this client use json-comment-filtered messages
     */
    protected boolean useJsonFiltered = false;
    
    /**
     * Same JVM clients, get local=true
     */
    protected boolean local;
    
    /**
     * The callback object for local clients
     */
    protected Listener listener;
    
    protected AtomicInteger nrofsubscriptions = new AtomicInteger(0);
    
    protected ClientImpl(String id, boolean local) {
        this.id = id;
        this.local = local;
        if (!local) messages = new LinkedList<Message>();
    }
    
    protected ClientImpl(String id, CometEvent event) {
        this(id,false);
        events = new ConcurrentLinkedQueue<CometEvent>();
        addCometEvent(event);
    }
    public synchronized void deliver(Message message) {
        deliverInternal(null,new MessageImpl[] {(MessageImpl)message});
    }
    
    public synchronized void deliver(Message[] message) {
        deliverInternal(null,message);
    }
    protected synchronized void deliverInternal(ChannelImpl channel, MessageImpl message) {
        deliverInternal(channel,new MessageImpl[] {message});
    }
    protected synchronized void deliverInternal(ChannelImpl channel, Message[] msgs) {
        if (isLocal()) {
            //local clients must have a listener
            ArrayList<Message> list = new ArrayList<Message>();
            for (int i=0; msgs!=null && i<msgs.length; i++) {
                //dont deliver to ourselves
                if (this!=msgs[i].getClient()) list.add(msgs[i]);
            }
            if (getListener() != null && list.size()>0) {
                getListener().deliver(list.toArray(new Message[0]));
            }
        } else {
            for (int i=0; msgs!=null && i<msgs.length; i++) {
                MessageImpl message = (MessageImpl)msgs[i];
                if (this==message.getClient()) { 
                    //dont deliver to ourself
                    continue;
                }
                //we are not implementing forever responses, if the client is connected
                //then we will fire off the message
                //first we check to see if we have any existing connections we can piggy back on
                CometEvent event = events.poll();
                boolean delivered = false;
                //TODO TODO - check on thread safety, for writing and for getting last request.
                if (event!=null) {
                    synchronized (event) {
                        RequestBase rq = (RequestBase)event.getHttpServletRequest().getAttribute(RequestBase.LAST_REQ_ATTR);
                        if (rq!=null) {
                            Map map = new HashMap();
                            try {
                                map.put(Bayeux.CHANNEL_FIELD,message.getChannel().getId());
                                map.put(Bayeux.DATA_FIELD,message);
                                JSONObject json = new JSONObject(map);
                                if (log.isDebugEnabled()) {
                                    log.debug("Message instantly delivered to remote client["+this+"] message:"+json);
                                }
                                rq.addToDeliveryQueue(this, json);
                                //deliver the batch
                                if (i==(msgs.length-1)) {
                                    rq.deliver(event, this);
                                    event.close(); //todo, figure out a better way, this means only one message gets delivered
                                    removeCometEvent(event); //and delivered instantly
                                }
                                delivered = true;
                            } catch (Exception x) {
                                log.error(x);
                            }
                        }
                    }
                } 
                if (!delivered) {
                    if (log.isDebugEnabled()) {
                        log.debug("Message added to queue for remote client["+this+"] message:"+message);
                    }
                    //queue the message for the next round
                    messages.add(message);
                }
            }
        }
    }
    public String getId() {
        return this.id;
    }
    protected Listener getListener() {
        return listener;
    }
    public boolean hasMessages() {
        if (isLocal()) return false;
        else {
            return messages.size() > 0;
        }
    }
    public boolean isLocal() {
        return local;
    }
    public int getSupportedConnTypes() {
        return supportedConnTypes;
    }
    public int getDesirectConnType() {
        return desirectConnType;
    }
    public boolean useJsonFiltered() {
        return useJsonFiltered;
    }
    public void setListener(Listener listener) {
        this.listener = listener;
    }
    public void setSupportedConnTypes(int supportedConnTypes) {
        this.supportedConnTypes = supportedConnTypes;
    }
    public void setUseJsonFiltered(boolean useJsonFiltered) {
        this.useJsonFiltered = useJsonFiltered;
    }
    public void setDesirectConnType(int desirectConnType) {
        this.desirectConnType = desirectConnType;
    }
    public boolean supportsCallbackPoll() {
        return (supportedConnTypes & SUPPORT_CALLBACK_POLL) == SUPPORT_CALLBACK_POLL;
    }
    public boolean supportsLongPoll() {
        return (supportedConnTypes & SUPPORT_LONG_POLL) == SUPPORT_LONG_POLL;
    }
    public synchronized List<Message> takeMessages() {
        if (isLocal()) return null;
        if (messages.size()==0) return EMPTY_LIST;
        List result = new LinkedList(messages);
        messages.clear();
        return result;
    }
    
    public String toString() {
        StringBuffer buf = new StringBuffer(super.toString());
        buf.append(" id=").append(getId());
        return buf.toString();
    }
    
    public boolean isSubscribed() {
        return nrofsubscriptions.get()>0;
    }
    
    protected synchronized boolean addCometEvent(CometEvent event) {
        boolean result = false;
        if (!events.contains(event)) {
            events.add(event);
            result = true;
        }
        event.getHttpServletRequest().setAttribute(COMET_EVENT_ATTR,this);
        return result;
    }
    
    protected synchronized boolean removeCometEvent(CometEvent event) {
        boolean result = events.remove(event);
        event.getHttpServletRequest().removeAttribute(COMET_EVENT_ATTR);
        return result;
    }
    
    
    protected void subscribed(ChannelImpl ch) {
        nrofsubscriptions.addAndGet(1);
    }
    
    protected void unsubscribed(ChannelImpl ch) {
        nrofsubscriptions.addAndGet(-1);
    }
    
    public void startBatch(){
        //noop until improved
    }
    public void endBatch() {
        //noop until improved
    }
        
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/HttpError.java"

    private int code;
    private String status;
    private Throwable cause;
    public HttpError(int code, String status, Throwable cause) {
        this.code = code;
        this.status = status;
        this.cause = cause;
    }
    public void setCode(int code) {
        this.code = code;
    }
    public void setStatus(String status) {
        this.status = status;
    }
    public void setCause(Throwable exception) {
        this.cause = exception;
    }
    public int getCode() {
        return code;
    }
    public String getStatus() {
        return status;
    }
    public Throwable getCause() {
        return cause;
    }
    public String toString() {
        if (cause != null)
            return code + ":" + status + " - [" + cause + "]";
        else
            return code + ":" + status;
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/MessageImpl.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    
    protected Channel channel;
    protected Client client;
    protected String id;
    private long TTL = 1000*60*5; //5min is the default TTL for a message
    protected long creationTime = System.currentTimeMillis();
    public Object clone() {
        MessageImpl copy = new MessageImpl(id);
        copy.putAll(this);
        copy.channel = channel;
        copy.client = client;
        copy.id = id;
        copy.creationTime = creationTime;
        copy.TTL = TTL;
        return copy;
    }
    protected MessageImpl(String id) {
        assert id != null;
        this.id = id;
    }
    public Channel getChannel() {
        return channel;
    }
    public Client getClient() {
        return client;
    }
    public long getCreationTime() {
        return creationTime;
    }
    public long getTTL() {
        return TTL;
    }
    public String getId() {
        return id;
    }
    protected void setChannel(Channel channel) {
        this.channel = channel;
    }
    protected void setClient(Client client) {
        this.client = client;
    }
    public void setTTL(long TTL) {
        this.TTL = TTL;
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/RequestBase.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Common functionality and member variables for all Bayeux requests.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 0.9
 *
 */
    
    protected static final SimpleDateFormat timestampFmt =
        new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
    static {
        timestampFmt.setTimeZone(TimeZone.getTimeZone("GMT"));
    }
    //message properties, combined for all messages
    protected TomcatBayeux tomcatBayeux;
    protected String channel;
    protected String id;
    protected String clientId;
    protected String version = null;
    protected String[] suppConnTypes = null;
    protected int suppConnTypesFlag = 0;
    protected int desiredConnTypeFlag = 0;
    protected String minVersion = null;
    protected String subscription = null;
    protected String data = null;
    protected String conType = null;
    protected LinkedHashMap<String, Object> ext = new LinkedHashMap<String, Object> ();
    
    protected CometEvent event;
    
    protected HashMap<String, Object> response = null;
    
    protected static Log log = LogFactory.getLog(RequestBase.class);
    
    protected int reconnectInterval = 1000;
    
    protected RequestBase(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        this.tomcatBayeux = tb;
        this.event = event;
        channel = jsReq.optString(Bayeux.CHANNEL_FIELD);
        id = jsReq.optString(Bayeux.ID_FIELD);
        clientId = jsReq.optString(Bayeux.CLIENT_FIELD);
        version = jsReq.optString(Bayeux.VERSION_FIELD);
        minVersion = jsReq.optString(Bayeux.MIN_VERSION_FIELD);
        conType = jsReq.optString(Bayeux.CONNECTION_TYPE_FIELD);
        subscription = jsReq.optString(Bayeux.SUBSCRIPTION_FIELD);
        data = jsReq.optString(Bayeux.DATA_FIELD);
        reconnectInterval = tb.getReconnectInterval();
        if (jsReq.has(Bayeux.EXT_FIELD)) {
            JSONObject jext = jsReq.getJSONObject(Bayeux.EXT_FIELD);
            for (Iterator<String> i = jext.keys(); i.hasNext(); ) {
                String key = i.next();
                ext.put(key, jext.get(key));
            }//for
        }//end if
        
        if (jsReq.has(Bayeux.SUPP_CONNECTION_TYPE_FIELD)) {
            JSONArray types = jsReq.getJSONArray(Bayeux.SUPP_CONNECTION_TYPE_FIELD);
            suppConnTypes = new String[types.length()];
            for (int i = 0; i < types.length(); i++) {
                suppConnTypes[i] = types.getString(i);
                if (Bayeux.TRANSPORT_CALLBACK_POLL.equals(suppConnTypes[i]))
                    suppConnTypesFlag = suppConnTypesFlag|ClientImpl.SUPPORT_CALLBACK_POLL;
                else if (Bayeux.TRANSPORT_LONG_POLL.equals(suppConnTypes[i]))
                    suppConnTypesFlag = suppConnTypesFlag|ClientImpl.SUPPORT_LONG_POLL;
            }//for
        }//end if
        if (conType!=null) {
            if (Bayeux.TRANSPORT_CALLBACK_POLL.equals(conType))
                desiredConnTypeFlag = ClientImpl.SUPPORT_CALLBACK_POLL;
            else if (Bayeux.TRANSPORT_LONG_POLL.equals(conType))
                desiredConnTypeFlag = ClientImpl.SUPPORT_LONG_POLL;
        }//end if
        
        //due to the fact that the javascript doesn't send up a required field
        //we have to fake it
        suppConnTypesFlag = ClientImpl.SUPPORT_CALLBACK_POLL | ClientImpl.SUPPORT_LONG_POLL;
    }
    public HttpError validate() {
        HttpError result = null;
        return result;
    }
    public TomcatBayeux getTomcatBayeux() {
        return tomcatBayeux;
    }
    public String getChannel() {
        return channel;
    }
    public String getId() {
        return id;
    }
    public String getClientId() {
        return clientId;
    }
    public LinkedHashMap getExt() {
        return ext;
    }
    public CometEvent getEvent() {
        return event;
    }
    
    protected static void deliver(CometEvent event, ClientImpl to) throws IOException, ServletException, BayeuxException {
        JSONArray jarray = getJSONArray(event,true);
        if ( jarray == null ) throw new BayeuxException("No message to send!");
        String jsonstring = jarray.toString();
        if (log.isDebugEnabled()) {
            log.debug("["+Thread.currentThread().getName()+"] Delivering message to[" + to + "] message:" + jsonstring);
        }
        if (to!=null) {
            if (to.useJsonFiltered()) {
                if (!event.getHttpServletResponse().isCommitted()) event.getHttpServletResponse().setContentType("text/json-comment-filtered");
            }else {	
                if (!event.getHttpServletResponse().isCommitted()) event.getHttpServletResponse().setContentType("text/json");
            }
        }
        PrintWriter out = event.getHttpServletResponse().getWriter();
        if (to==null) {
            //do nothing
        }else if ( (to.getDesirectConnType() == 0 && to.supportsLongPoll()) || to.getDesirectConnType() == ClientImpl.SUPPORT_LONG_POLL) {
            if (to.useJsonFiltered())
                out.print("/*");
        } else if ( (to.getDesirectConnType() == 0 && to.supportsCallbackPoll()) || to.getDesirectConnType() == ClientImpl.SUPPORT_CALLBACK_POLL) {
            String jsonp = event.getHttpServletRequest().getParameter(Bayeux.JSONP_PARAMETER);
            if (jsonp == null)
                jsonp = Bayeux.JSONP_DEFAULT_NAME;
            out.print(jsonp);
            out.print('(');
        } else {
            throw new BayeuxException("Client doesn't support any appropriate connection type.");
        }
        out.print(jsonstring);
        if ( to == null ) {
            //do nothing
        } else if ( (to.getDesirectConnType() == 0 && to.supportsLongPoll()) || to.getDesirectConnType() == ClientImpl.SUPPORT_LONG_POLL) {
            if (to.useJsonFiltered())
                out.print("*/");
        } else if ( (to.getDesirectConnType() == 0 && to.supportsCallbackPoll()) || to.getDesirectConnType() == ClientImpl.SUPPORT_CALLBACK_POLL) {
            out.print(");");
        } 
        out.flush();
        event.getHttpServletResponse().flushBuffer();
        
    }
    protected static JSONArray getJSONArray(CometEvent event, boolean nullok) {
        synchronized(event) {
            JSONArray jarray = (JSONArray) event.getHttpServletRequest().getAttribute(JSON_MSG_ARRAY);
            if (jarray == null && (!nullok)) {
                jarray = new JSONArray();
                event.getHttpServletRequest().setAttribute(JSON_MSG_ARRAY, jarray);
            }
            return jarray;
        }
    }
    protected JSONArray getJSONArray() {
        return getJSONArray(event,false);
    }
    protected void addToDeliveryQueue(ClientImpl to, JSONObject msg) throws IOException, ServletException, BayeuxException {
        synchronized (event) {
            getJSONArray().put(msg);
        }
    }
    
    protected void flushMessages(ClientImpl client) throws BayeuxException {
        List<Message> msgs = client.takeMessages();
        synchronized (event) {
            try {
                for (Iterator<Message> it = msgs.iterator(); it.hasNext(); ){
                    MessageImpl msg = (MessageImpl)it.next();
                    Map map = new HashMap();
                    map.put(Bayeux.CHANNEL_FIELD,msg.getChannel().getId());
                    if (msg.getClient()!=null) map.put(Bayeux.CLIENT_FIELD,msg.getClient().getId());
                    map.put(Bayeux.DATA_FIELD,msg);
                    JSONObject obj = new JSONObject(map);
                    addToDeliveryQueue(client, obj);
                }
            } catch (ServletException x) {
                throw new BayeuxException(x);
            } catch (IOException x) {
                throw new BayeuxException(x);
            }
        }
    }
    
    public int process(int prevops) throws BayeuxException {
        event.getHttpServletRequest().setAttribute(CURRENT_REQ_ATTR,this);
        return prevops;
    }
    
    public int getReconnectInterval() {
        return reconnectInterval;
    }
    public String getTimeStamp() {
        return timestampFmt.format(new Date(System.currentTimeMillis()));
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/RequestFactory.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    public static BayeuxRequest getRequest(TomcatBayeux tomcatBayeux, CometEvent event, JSONObject msg) throws JSONException {
        String channel = msg.optString(Bayeux.CHANNEL_FIELD);
        if (Bayeux.META_HANDSHAKE.equals(channel)) {
            return new MetaHandshakeRequest(tomcatBayeux,event,msg);
        }else if (Bayeux.META_CONNECT.equals(channel)) {
            return new MetaConnectRequest(tomcatBayeux,event,msg);
        }else if (Bayeux.META_DISCONNECT.equals(channel)) {
            return new MetaDisconnectRequest(tomcatBayeux,event,msg);
        }else if (Bayeux.META_SUBSCRIBE.equals(channel)) {
            return new MetaSubscribeRequest(tomcatBayeux,event,msg);
        }else if (Bayeux.META_UNSUBSCRIBE.equals(channel)) {
            return new MetaUnsubscribeRequest(tomcatBayeux,event,msg);
        } else {
            return new PublishRequest(tomcatBayeux,event,msg);
        }
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/TomcatBayeux.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * 
 * @author Filip Hanik
 * @version 1.0
 */
    
    protected int reconnectInterval = 5000;
    /**
     * a list of all active clients
     */
    protected HashMap<String,Client> clients = new HashMap<String,Client>();
    
    /**
     * a list of all active channels
     */
    protected LinkedHashMap<String, Channel> channels = new LinkedHashMap<String,Channel>();
    
    /**
     * security policy to be used.
     */
    protected SecurityPolicy securityPolicy = null;
    /**
     * default client to use when we need to send an error message but don't have a client valid reference
     */
    protected static ClientImpl errorClient = new ClientImpl("error-no-client",false);
    
    /**
     * returns the default error client
     * @return ClientImpl
     */
    public static ClientImpl getErrorClient() {
        return errorClient;
    }
    
    protected TomcatBayeux() {
    }
    
    /**
     * should be invoked when the servlet is destroyed or when the context shuts down
     */
    public void destroy() {
        throw new UnsupportedOperationException("TomcatBayeux.destroy() not yet implemented");
    }
    public Channel getChannel(String channelId, boolean create) {
        Channel result = channels.get(channelId);
        if (result==null && create) {
            result = new ChannelImpl(channelId);
            channels.put(channelId,result);
        }
        return result;
    }
    
    public Channel remove(Channel channel) {
        return channels.remove(channel.getId());
    }
    
    public Client remove(Client client) {
        if (client==null) return null;
        for (Channel ch : getChannels()) {
            ch.unsubscribe(client);
        }
        return clients.remove(client.getId());
    }
    public Client getClient(String clientId) {
        return clients.get(clientId);
    }
    
    public boolean hasClient(String clientId) {
        return clients.containsKey(clientId);
    }
    
    public List<Client> getClients() {
        return java.util.Arrays.asList(clients.entrySet().toArray(new Client[0]));
    }
    public SecurityPolicy getSecurityPolicy() {
        return securityPolicy;
    }
    public int getReconnectInterval() { 
        return reconnectInterval;
    }
    public boolean hasChannel(String channel) {
        return channels.containsKey(channel);
    }
    public Client newClient(String idprefix, Listener listener, boolean local, CometEvent event) {
        String id = createUUID(idprefix);
        ClientImpl client = new ClientImpl(id, local);
        client.setListener(listener);
        clients.put(id, client);
        return client;
    }
    public Client newClient(String idprefix, Listener listener) {
        assert listener!=null;
        //if this method gets called, someone is using the API inside
        //the JVM, this is a local client
        return newClient(idprefix,listener,true, null);
    }
    
    protected ClientImpl getClientImpl(CometEvent event) {
        return (ClientImpl)event.getHttpServletRequest().getAttribute(ClientImpl.COMET_EVENT_ATTR);
    }
    
    protected void remove(CometEvent event) {
        ClientImpl client = getClientImpl(event);
        if (client!=null) {
            client.removeCometEvent(event);
        }
    }
    public String createUUID(String idprefix) {
        if (idprefix==null) idprefix="";
        return idprefix + Arrays.toString(UUIDGenerator.randomUUID(false));
    }
    
    public List<Channel> getChannels() {
        return java.util.Arrays.asList(channels.entrySet().toArray(new Channel[0]));
    }
    protected Message newMessage() {
        String id = createUUID("msg-");
        return new MessageImpl(id);
    }
    public Message newMessage(Client from) {
        MessageImpl msg = (MessageImpl)newMessage();
        msg.setClient(from);
        return msg;
    }
    public void setSecurityPolicy(SecurityPolicy securityPolicy) {
        this.securityPolicy = securityPolicy;
    }
    public void setReconnectInterval(int reconnectTimeout) {
        this.reconnectInterval = reconnectTimeout;
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaConnectRequest.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_CONNECT);
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaConnectRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
        if (clientId!=null && getTomcatBayeux().hasClient(clientId)) {
            event.getHttpServletRequest().setAttribute("client",getTomcatBayeux().getClient(clientId));
        }
    }
    /**
     * Check client request for validity.
     *
     * Per section 4.2.1 of the Bayuex spec a connect request must contain:
     *  1) The "/meta/connect" channel identifier.
     *  2) The clientId returned by the server after handshake.
     *  3) The desired connectionType (must be one of the server's supported
     *     types returned by handshake response.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(clientId==null|| (!getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        if (! (Bayeux.TRANSPORT_LONG_POLL.equals(conType) || Bayeux.TRANSPORT_CALLBACK_POLL.equals(conType)))
            return new HttpError(400,"Unsupported connection type.",null);
        return null;//no error
    }
    /**
     * Transition to connected state, flushing pending messages if
     * available.  If there are pending subscriptions and no messages to
     * flush then the connection is held until there is a pending publish
     * event to be delivered to this client (Section 4.2.2 of spec).
     */
    public int process(int prevops) throws BayeuxException {
        super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = (ClientImpl)getTomcatBayeux().getClient(clientId);
        boolean success = false;
        HttpError error = validate();
        if (error == null) {
            client.setDesirectConnType(desiredConnTypeFlag);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.RETRY_RESPONSE);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.INTERVAL_FIELD, getReconnectInterval());
            success = true;
        }else {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.HANDSHAKE_RESPONSE);
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        response.put(Bayeux.TIMESTAMP_FIELD,getTimeStamp());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        
        //return immediately if there is no subscriptions
        //so that we can process the next message
        int result = client.isSubscribed()?1:0; 
        if (success && client!=null && client.hasMessages()) {
            //send out messages 
            flushMessages(client);
            result = 0; //flush out the messages
        }
        return result;
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaDisconnectRequest.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_DISCONNECT);
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaDisconnectRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
    }
    /**
     * Check client request for validity.
     *
     * Per section 4.4.1 of the Bayuex spec a connect request must contain:
     *  1) The "/meta/disconnect" channel identifier.
     *  2) The clientId.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(clientId==null|| (!this.getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        return null;//no error
    }
    /**
     * Disconnect a client session.
     */
    public int process(int prevops) throws BayeuxException {
        super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = (ClientImpl)getTomcatBayeux().getClient(clientId);
        HttpError error = validate();
        if (error == null) {
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "retry");
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("interval", getReconnectInterval());
        }else {
            getTomcatBayeux().remove(client);
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "none");
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        return 0;
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaHandshakeRequest.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_HANDSHAKE);
        responseTemplate.put(Bayeux.VERSION_FIELD,"1.0");
        responseTemplate.put(Bayeux.SUPP_CONNECTION_TYPE_FIELD,new String[] { Bayeux.TRANSPORT_LONG_POLL, Bayeux.TRANSPORT_CALLBACK_POLL });
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaHandshakeRequest(TomcatBayeux tomcatBayeux, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tomcatBayeux, event, jsReq);
    }
    
    public String getVersion() { return version; }
    public String getMinimumVersion() { return minVersion; }
    /**
     * Check client request for validity.
     *
     * Per section 4.1.1 of the Bayuex spec a handshake request must contain:
     *  1) The "/meta/handshake" channel identifier.
     *  2) The version of the protocol supported by the client
     *  3) The client's supported connection types.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        boolean error = (version==null || version.length()==0);
        if (!error) error = suppConnTypesFlag==0;
        if (error) return new HttpError(400,"Invalid handshake request, supportedConnectionType field missing.",null);
        else return null;
    }
    /**
     * Generate and return a client identifier.  Return a list of
     * supported connection types.  Must be a subset of or identical to
     * the list of types supported by the client.  See section 4.1.2 of
     * the Bayuex specification.
     */
    public int process(int prevops) throws BayeuxException {
        super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = null;
        HttpError error = validate();
        if (error == null) {
            client = (ClientImpl) getTomcatBayeux().newClient("http-", null, false,getEvent());
            clientId = client.getId();
            client.setSupportedConnTypes(suppConnTypesFlag);
            client.setUseJsonFiltered(getExt().get(Bayeux.JSON_COMMENT_FILTERED_FIELD) != null);
            response.put(Bayeux.CLIENT_FIELD, client.getId());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.RETRY_RESPONSE);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.INTERVAL_FIELD, getReconnectInterval());
        }else {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            client = TomcatBayeux.getErrorClient();
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.NONE_RESPONSE);
        }
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        return 0;
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaSubscribeRequest.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_SUBSCRIBE);
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaSubscribeRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
    }
    /**
     * Check client request for validity.
     *
     * Per section 4.5.1 of the Bayuex spec a connect request must contain:
     *  1) The "/meta/subscribe" channel identifier.
     *  2) The clientId.
     *  3) The subscription.  This is the name of the channel of interest,
     *     or a pattern.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(clientId==null|| (!this.getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        if (subscription==null||subscription.length()==0)
            return new HttpError(400,"Subscription missing.",null);
        return null;//no error
    }
    /**
     * Register interest for one or more channels.  Per section 2.2.1 of the
     * Bayeux spec, a pattern may be specified.  Assign client to matching
     * channels and inverse client to channel reference.
     */
    public int process(int prevops) throws BayeuxException {
        super.process(prevops);
        response = (HashMap<String, Object>)this.responseTemplate.clone();
        ClientImpl client = (ClientImpl)getTomcatBayeux().getClient(clientId);
        HttpError error = validate();
        if (error == null) {
            boolean wildcard = subscription.indexOf('*')!=-1;
            boolean subscribed = false;
            if (wildcard) {
                List<Channel> channels = getTomcatBayeux().getChannels();
                Iterator<Channel> it = channels.iterator();
                while (it.hasNext()) {
                    ChannelImpl ch = (ChannelImpl)it.next();
                    if (ch.matches(subscription)) {
                        ch.subscribe(client);
                        subscribed = true;
                    }
                }
            }else {
                ChannelImpl ch = (ChannelImpl)getTomcatBayeux().getChannel(subscription,true);
                ch.subscribe(client);
                subscribed = true;
            }
            response.put(Bayeux.SUCCESSFUL_FIELD, Boolean.valueOf(subscribed));
            response.put(Bayeux.SUBSCRIPTION_FIELD,subscription);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "retry");
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("interval", getReconnectInterval());
        }else {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "handshake");
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        response.put(Bayeux.TIMESTAMP_FIELD,getTimeStamp());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        return 0;
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaUnsubscribeRequest.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_UNSUBSCRIBE);
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaUnsubscribeRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
    }
    /**
     * Check client request for validity.
     *
     * Per section 4.6.1 of the Bayuex spec a connect request must contain:
     *  1) The "/meta/unsubscribe" channel identifier.
     *  2) The clientId.
     *  3) The subscription.  This is the name of the channel of interest,
     *     or a pattern.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(clientId==null|| (!this.getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        if (subscription==null||subscription.length()==0)
            return new HttpError(400,"Subscription missing.",null);
        return null;//no error
    }
    /**
     * De-register interest for one or more channels.  Per section 2.2.1 of the
     * Bayeux spec, a pattern may be specified.  Sever relationships.
     */
    public int process(int prevops) throws BayeuxException {
        super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = (ClientImpl)getTomcatBayeux().getClient(clientId);
        HttpError error = validate();
        if (error == null) {
            boolean wildcard = subscription.indexOf('*')!=-1;
            boolean unsubscribed = false;
            if (wildcard) {
                List<Channel> channels = getTomcatBayeux().getChannels();
                Iterator<Channel> it = channels.iterator();
                while (it.hasNext()) {
                    ChannelImpl ch = (ChannelImpl)it.next();
                    if (ch.matches(subscription)) {
                        ch.unsubscribe(client);
                        unsubscribed = true;
                    }
                }
            }else {
                ChannelImpl ch = (ChannelImpl)getTomcatBayeux().getChannel(subscription,true);
                ch.unsubscribe(client);
                unsubscribed = true;
            }
            response.put(Bayeux.SUCCESSFUL_FIELD, Boolean.valueOf(unsubscribed));
            response.put(Bayeux.SUBSCRIPTION_FIELD,subscription);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "retry");
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("interval", getReconnectInterval());
        }else {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "handshake");
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        response.put(Bayeux.TIMESTAMP_FIELD,getTimeStamp());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        return 0;
    }
======= 408175f:"modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    JSONObject msgData = null;
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public PublishRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
    }
    /**
     * Check client request for validity.
     *
     * Per section 5.1.1 of the Bayuex spec a connect request must contain:
     *  1) The channel identifier of the channel for publication.
     *  2) The data to send.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(channel==null|| (!this.getTomcatBayeux().hasChannel(channel)))
            return new HttpError(400,"Channel Id not valid.", null);
        if(data==null || data.length()==0)
            return new HttpError(400,"Message data missing.", null);
        try {
            this.msgData = new JSONObject(data);
        }catch (JSONException x) {
            return new HttpError(400,"Invalid JSON object in data attribute.",x);
        }
        if(clientId==null|| (!this.getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        return null;//no error
    }
    /**
     *  Send the event message to all registered subscribers.
     */
    public int process(int prevops) throws BayeuxException {
        super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = clientId!=null?(ClientImpl)getTomcatBayeux().getClient(clientId):
                                           (ClientImpl)event.getHttpServletRequest().getAttribute("client");
        boolean success = false;
        HttpError error = validate();
        if (error == null) {
            ChannelImpl chimpl = (ChannelImpl)getTomcatBayeux().getChannel(channel,false);
            MessageImpl mimpl = (MessageImpl)getTomcatBayeux().newMessage(client);
            
            try {
                String[] keys = JSONObject.getNames(msgData);
                for (int i = 0; i < keys.length; i++) {
                    mimpl.put(keys[i], msgData.get(keys[i]));
                }
                success = true;
                ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.RETRY_RESPONSE);
                ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.INTERVAL_FIELD, getReconnectInterval());
            }catch (JSONException x) {
                if (log.isErrorEnabled()) log.error("Unable to parse:"+msgData,x);
                throw new BayeuxException(x);
            }
            chimpl.publish(mimpl);
        }
        if(!success) {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.HANDSHAKE_RESPONSE);
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CHANNEL_FIELD,channel);
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        
        if (success && client!=null && client.hasMessages()) {
            //send out messages 
            flushMessages(client);
        }
        return 0;
    }
======= 408175f:"modules/bayeux/test/org/apache/cometd/bayeux/samples/BayeuxStockTicker.java"

        ServletContextAttributeListener, Listener {
    static AtomicInteger counter = new AtomicInteger(0);
    protected int id;
    protected Bayeux b;
    protected Client c;
    protected boolean alive = true;
    protected boolean initialized = false;
    protected TickerThread tt = new TickerThread();
    public BayeuxStockTicker() {
        id = counter.incrementAndGet();
        System.out.println("new listener created with id:" + id);
    }
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        alive = false;
        tt.run = false;
        tt.interrupt();
    }
    public void contextInitialized(ServletContextEvent servletContextEvent) {
    }
    public void attributeAdded(ServletContextAttributeEvent scae) {
        if (scae.getName().equals(Bayeux.DOJOX_COMETD_BAYEUX)) {
            if (initialized) return;
            initialized = true;
            System.out.println("Starting stock ticker server client!");
            b = (Bayeux) scae.getValue();
            c = b.newClient("stock-ticker-", this);
            tt.start();
        }
    }
    public void attributeRemoved(ServletContextAttributeEvent scae) {
        if (scae.getName().equals(Bayeux.DOJOX_COMETD_BAYEUX)) {
            initialized = false;
            b = (Bayeux) scae.getValue();
            List<Channel> chs = b.getChannels();
            for (Channel ch : chs) {
                ch.unsubscribe(c);
            }
        }
    }
    public void attributeReplaced(
            ServletContextAttributeEvent servletContextAttributeEvent) {
    }
    public void removed(boolean timeout) {
        System.out.println("Client removed.");
    }
    public void deliver(Message[] msgs) {
        for (int i = 0; msgs != null && i < msgs.length; i++) {
            Message msg = msgs[i];
            System.out.println("[stock ticker server client ]received message:" + msg);
        }
    }
    public class TickerThread extends Thread {
        public boolean run = true;
        public TickerThread() {
            setName("Ticker Thread");
        }
        public void run() {
            try {
                
                Stock[] stocks = new Stock[] { 
                        new Stock("GOOG", 435.43),
                        new Stock("YHOO", 27.88), 
                        new Stock("SPRG", 1015.55), };
                for (Stock s : stocks) {
                    Channel ch = b.getChannel("/stock/"+s.getSymbol(), true);
                    ch.subscribe(c);
                    
                }
                Random r = new Random(System.currentTimeMillis());
                while (run) {
                    for (int j = 0; j < 1; j++) {
                        int i = r.nextInt() % 3;
                        if (i < 0)
                            i = i * (-1);
                        Stock stock = stocks[i];
                        double change = r.nextDouble();
                        boolean plus = r.nextBoolean();
                        if (plus) {
                            stock.setValue(stock.getValue() + change);
                        } else {
                            stock.setValue(stock.getValue() - change);
                        }
                        Channel ch = b.getChannel("/stock/"+stock.getSymbol(), true);
                        Message m = b.newMessage(c);
                        m.put("stock", stock.toString());
                        m.put("symbol", stock.getSymbol());
                        m.put("price", stock.getValueAsString());
                        m.put("change", stock.getLastChangeAsString());
                        ch.publish(m);
                        System.out.println("Stock: "+stock.getSymbol()+" Price: "+stock.getValueAsString()+" Change: "+stock.getLastChangeAsString());
                    }
                    Thread.sleep(850);
                }
            } catch (InterruptedException ix) {
            } catch (Exception x) {
                x.printStackTrace();
            }
        }
    }
    public static class Stock {
        protected static DecimalFormat df = new DecimalFormat("0.00");
        protected String symbol = "";
        protected double value = 0.0d;
        protected double lastchange = 0.0d;
        protected int cnt = 0;
        public Stock(String symbol, double initvalue) {
            this.symbol = symbol;
            this.value = initvalue;
        }
        public void setCnt(int c) {
            this.cnt = c;
        }
        public int getCnt() {
            return cnt;
        }
        public String getSymbol() {
            return symbol;
        }
        public double getValue() {
            return value;
        }
        public void setValue(double value) {
            double old = this.value;
            this.value = value;
            this.lastchange = value - old;
        }
        public String getValueAsString() {
            return df.format(value);
        }
        public double getLastChange() {
            return this.lastchange;
        }
        public void setLastChange(double lastchange) {
            this.lastchange = lastchange;
        }
        public String getLastChangeAsString() {
            return df.format(lastchange);
        }
        public int hashCode() {
            return symbol.hashCode();
        }
        public boolean equals(Object other) {
            if (other instanceof Stock) {
                return this.symbol.equals(((Stock) other).symbol);
            } else {
                return false;
            }
        }
        
        public String toString(){
            StringBuffer buf = new StringBuffer("STOCK#");
            buf.append(getSymbol());
            buf.append("#");
            buf.append(getValueAsString());
            buf.append("#");
            buf.append(getLastChangeAsString());
            buf.append("#");
            buf.append(String.valueOf(getCnt()));
            return buf.toString();
         
        }
        public Object clone() {
            Stock s = new Stock(this.getSymbol(), this.getValue());
            s.setLastChange(this.getLastChange());
            s.setCnt(this.cnt);
            return s;
        }
    }
======= 408175f:"modules/bayeux/test/org/apache/cometd/bayeux/samples/EchoChatClient.java"

    
    static AtomicInteger counter = new AtomicInteger(0);
    protected int id;
    protected Bayeux b;
    protected Client c;
    protected boolean alive = true;
    protected TimestampThread tt = new TimestampThread();
    public EchoChatClient() {
        id = counter.incrementAndGet();
        System.out.println("new listener created with id:"+id);
    }
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        alive = false;
        tt.interrupt();
    }
    public void contextInitialized(ServletContextEvent servletContextEvent) {
    }
    public void attributeAdded(ServletContextAttributeEvent scae) {
        if (scae.getName().equals(Bayeux.DOJOX_COMETD_BAYEUX)) {
            System.out.println("Starting echo chat client!");
            b = (Bayeux)scae.getValue();
            c = b.newClient("echochat-",this);
            Channel ch = b.getChannel("/chat/demo",true);
            ch.subscribe(c);
            tt.start();
        }
    }
    public void attributeRemoved(ServletContextAttributeEvent servletContextAttributeEvent) {
    }
    public void attributeReplaced(ServletContextAttributeEvent servletContextAttributeEvent) {
    }
    public void removed(boolean timeout) {
        System.out.println("Client removed.");
    }
    public void deliver(Message[] msgs) {
        for (int i=0; msgs!=null && i<msgs.length; i++) {
            Message msg = msgs[i];
            System.out.println("[echochatclient ]received message:" + msg);
            Message m = b.newMessage(c);
            m.putAll(msg);
            //echo the same message
            m.put("user", "echochatserver");
            if (m.containsKey("msg")) {
                //simple chat demo
                String chat = (String) m.get("msg");
                m.put("msg", "echochatserver|I received your message-" + chat.substring(chat.indexOf("|") + 1));
            }
            System.out.println("[echochatclient ]sending message:" + m);
            msg.getChannel().publish(m);
        }
    }
    public class TimestampThread extends Thread {
        public TimestampThread() {
            setDaemon(true);
        }
        
        public void run() {
            while (alive) {
                try {
                    sleep(5000);
                    Channel ch = b.getChannel("/chat/demo",false);
                    if (ch.getSubscribers().size()<=1) {
                        continue;
                    }
                    Message m = b.newMessage(c);
                    m.put("user","echochatserver");
                    m.put("chat","Time is:"+new java.sql.Date(System.currentTimeMillis()).toLocaleString());
                    m.put("join",false);
                    ch.publish(m);
                }catch (InterruptedException ignore) {
                    Thread.currentThread().interrupted();
                }catch (Exception x) {
                    x.printStackTrace();
                }
            }
        }
    }
   xmlns="http://java.sun.com/xml/ns/javaee" 
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
   version="2.5"> 
  <display-name>Cometd Test WebApp</display-name>
  
  <servlet>
    <servlet-name>cometd</servlet-name>
    <servlet-class>org.apache.tomcat.bayeux.BayeuxServlet</servlet-class>
    <init-param>
      <param-name>timeout</param-name>
      <param-value>120000000</param-value>
    </init-param>
    <init-param>
      <param-name>reconnectInterval</param-name>
      <param-value>250</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>cometd</servlet-name>
    <url-pattern>/cometd/*</url-pattern>
  </servlet-mapping>
  
  <listener>
    <listener-class>org.apache.cometd.bayeux.samples.EchoChatClient</listener-class>
  </listener>
  <listener>
    <listener-class>org.apache.cometd.bayeux.samples.BayeuxStockTicker</listener-class>
  </listener>
  
  dojox.cometd.init("/cometd/cometd");
  dojox.cometd.startBatch();
  dojox.cometd.subscribe("/stock/GOOG", onMsgEvent);
  dojox.cometd.subscribe("/stock/YHOO", onMsgEvent);
  dojox.cometd.subscribe("/stock/SPRG", onMsgEvent);
  dojox.cometd.endBatch();
   if(node == undefined || node == null)
   {
      return;
   }
   var len = node.childNodes.length;
   // Break apart the text string into screen name and message parts.
   var symbol = event.data.symbol;
   var price = event.data.price;
   var pricechange = event.data.change;
   //alert("symbol: "+symbol+" price: "+price+" change: "+pricechange);
   var pricenode = dojo.byId("price."+symbol);
   var changenode = dojo.byId("change."+symbol);
   removeChildrenFromNode(pricenode);
   removeChildrenFromNode(changenode);
   var pricelabel = document.createTextNode(price);
   pricelabel.value = price;
   var changelabel = document.createTextNode(pricechange);
   changelabel.value = pricechange;
   pricenode.appendChild(pricelabel);
   changenode.appendChild(changelabel);
   var table = dojo.byId("stocktable");  
   var rows = table.getElementsByTagName("tr");  
   for(i = 0; i < rows.length; i++){
   }          
   //manipulate rows 
   var rowCurrent = dojo.byId("row."+symbol);
   if (pricechange<=0) {
       rowCurrent.bgColor = "red";
   } else {
   }
  <tr id="row.HEADER">
    <td>SYMBOL</td>
    <td>PRICE</td>
    <td>LAST CHANGE</td>
    <td>SUBSCRIBE</td></tr>
  <tr id="row.SPRG">
    <td>SPRG</td>
    <td id="price.SPRG"></td>
    <td id="change.SPRG"></td>
    <td id="check.SPRG"><input type="checkbox" id="check.SPRG" checked onClick="subscribe(this,'SPRG')"></td>
  </tr>
  <tr id="row.GOOG">
    <td>GOOG</td>
    <td id="price.GOOG"></td>
    <td id="change.GOOG"></td>
    <td id="check.GOOG"><input type="checkbox" id="check.GOOG" checked  onClick="subscribe(this,'GOOG')"></td>
  </tr>
  <tr id="row.YHOO">
    <td>YHOO</td>
    <td id="price.YHOO"></td>
    <td id="change.YHOO"></td>
    <td id="check.YHOO"><input type="checkbox" id="check.GOOG" checked  onClick="subscribe(this,'YHOO')"></td>
  </tr>
======= 408175f:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/ConnectionState.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Interceptor that keep track of connection state to avoid roundtrips to the database
 * @author fhanik
 *
 */
    protected static Log log = LogFactory.getLog(ConnectionState.class);
    
    protected final String[] readState = {"getAutoCommit","getTransactionIsolation","isReadOnly","getCatalog"};
    protected final String[] writeState = {"setAutoCommit","setTransactionIsolation","setReadOnly","setCatalog"};
    protected Boolean autoCommit = null;
    protected Integer transactionIsolation = null;
    protected Boolean readOnly = null;
    protected String catalog = null;
    
    
    public void reset(ConnectionPool parent, PooledConnection con) {
        PoolProperties poolProperties = parent.getPoolProperties();
        if (poolProperties.getDefaultReadOnly()!=null) {
            try {
                if (readOnly==null || readOnly.booleanValue()!=poolProperties.getDefaultReadOnly().booleanValue()) {
                    con.getConnection().setReadOnly(poolProperties.getDefaultReadOnly().booleanValue());
                    readOnly = poolProperties.getDefaultReadOnly();
                }
            }catch (SQLException x) {
                readOnly = null;
                log.error("Unable to reset readonly state to connection.",x);
            }
        }
        if (poolProperties.getDefaultAutoCommit()!=null) {
            try {
                if (autoCommit==null || autoCommit.booleanValue()!=poolProperties.getDefaultAutoCommit().booleanValue()) {
                    con.getConnection().setAutoCommit(poolProperties.getDefaultAutoCommit().booleanValue());
                    autoCommit = poolProperties.getDefaultAutoCommit();
                }
            }catch (SQLException x) {
                autoCommit = null;
                log.error("Unable to reset autocommit state to connection.",x);
            }
        }
        if (poolProperties.getDefaultCatalog()!=null) {
            try {
                if (catalog==null || (!catalog.equals(poolProperties.getDefaultCatalog()))) {
                    con.getConnection().setCatalog(poolProperties.getDefaultCatalog());
                    catalog = poolProperties.getDefaultCatalog();
                }
            }catch (SQLException x) {
                catalog = null;
                log.error("Unable to reset default catalog state to connection.",x);
            }
        }
        if (poolProperties.getDefaultTransactionIsolation()!=DataSourceFactory.UNKNOWN_TRANSACTIONISOLATION) {
            try {
                if (transactionIsolation==null || transactionIsolation.intValue()!=poolProperties.getDefaultTransactionIsolation()) {
                    con.getConnection().setTransactionIsolation(poolProperties.getDefaultTransactionIsolation());
                    transactionIsolation = poolProperties.getDefaultTransactionIsolation();
                }
            }catch (SQLException x) {
                transactionIsolation = null;
                log.error("Unable to reset transaction isolation state to connection.",x);
            }
        }
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        String name = method.getName();
        boolean read = false;
        int index = -1;
        for (int i=0; (!read) && i<readState.length; i++) {
            read = compare(name,readState[i]);
            if (read) index = i;
        }
        boolean write = false;
        for (int i=0; (!write) && (!read) && i<writeState.length; i++) {
            write = compare(name,writeState[i]);
            if (write) index = i;
        }
        Object result = null;
        if (read) {
            switch (index) {
                case 0:{result = autoCommit; break;}
                case 1:{result = transactionIsolation; break;}
                case 2:{result = readOnly; break;}
                case 3:{result = catalog; break;}
                default: result = null;
            }
            //return cached result, if we have it
            if (result!=null) return result;
        }
        result = super.invoke(proxy, method, args);
        if (read || write) {
            switch (index) {
                case 0:{autoCommit = (Boolean) (read?result:args[0]); break;}
                case 1:{transactionIsolation = (Integer)(read?result:args[0]); break;}
                case 2:{readOnly = (Boolean)(read?result:args[0]); break;}
                case 3:{catalog = (String)(read?result:args[0]); break;}
            }
        }
        return result;
    }
======= 408175f:"modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * @author Filip Hanik
 * @version 1.0
 */
    protected final String[] statements = {"createStatement","prepareStatement","prepareCall"};
    protected final String[] executes = {"execute","executeQuery","executeUpdate","executeBatch"};
    protected static IdentityHashMap<ConnectionPool,HashMap<String,QueryStats>> perPoolStats = 
        new IdentityHashMap<ConnectionPool,HashMap<String,QueryStats>>();
    
    protected HashMap<String,QueryStats> queries = null;
    
    protected long threshold = 100; //don't report queries less than this
    protected int  maxQueries= 1000; //don't store more than this amount of queries
    
    
    public SlowQueryReport() {
        super();
    }
    public long getThreshold() {
        return threshold;
    }
    public void setThreshold(long threshold) {
        this.threshold = threshold;
    }
    @Override
    public void closeInvoked() {
        // TODO Auto-generated method stub
        
    }
    @Override
    public Object createStatement(Object proxy, Method method, Object[] args, Object statement) {
        // TODO Auto-generated method stub
        String sql = null;
        if (method.getName().startsWith("prepare")) {
            sql = (args.length>0 && (args[0] instanceof String))?(String)args[0]:null;
        }
        return new StatementProxy(statement,sql);
    }
    protected boolean process(final String[] names, Method method, boolean process) {
        for (int i=0; (!process) && i<names.length; i++) {
            process = compare(method.getName(),names[i]);
        }
        return process;
    }
    protected class QueryStats {
        private final String query;
        private int nrOfInvocations;
        private long maxInvocationTime;
        private long maxInvocationDate;
        private long minInvocationTime;
        private long minInvocationDate;
        private long totalInvocationTime;
        
        public QueryStats(String query) {
            this.query = query;
        }
        
        public void add(long invocationTime) {
            long now = -1;
            //not thread safe, but don't sacrifice performance for this kind of stuff
            maxInvocationTime = Math.max(invocationTime, maxInvocationTime);
            if (maxInvocationTime == invocationTime) {
                now = System.currentTimeMillis();
                maxInvocationDate = now;
            }
            minInvocationTime = Math.min(invocationTime, minInvocationTime);
            if (minInvocationTime==invocationTime) {
                now = (now==-1)?System.currentTimeMillis():now;
                minInvocationDate = now;
            }
            nrOfInvocations++;
            totalInvocationTime+=invocationTime;
        }
        
        public String getQuery() {
            return query;
        }
        public int getNrOfInvocations() {
            return nrOfInvocations;
        }
        public long getMaxInvocationTime() {
            return maxInvocationTime;
        }
        public long getMaxInvocationDate() {
            return maxInvocationDate;
        }
        public long getMinInvocationTime() {
            return minInvocationTime;
        }
        public long getMinInvocationDate() {
            return minInvocationDate;
        }
        public long getTotalInvocationTime() {
            return totalInvocationTime;
        }
        public int hashCode() {
            return query.hashCode();
        }
        
        public boolean equals(Object other) {
            if (other instanceof QueryStats) {
                QueryStats qs = (QueryStats)other;
                return SlowQueryReport.this.compare(qs.query,this.query);
            } 
            return false;
        }
    }
    
    protected class StatementProxy implements InvocationHandler {
        protected boolean closed = false;
        protected Object delegate;
        protected final String query;
        public StatementProxy(Object parent, String query) {
            this.delegate = parent;
            this.query = query;
        }
        
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            final String name = method.getName();
            boolean close = compare(JdbcInterceptor.CLOSE_VAL,name);
            if (close && closed) return null; //allow close to be called multiple times
            if (closed) throw new SQLException("Statement closed.");
            boolean process = false;
            process = process(executes, method, process);
            long start = (process)?System.currentTimeMillis():0;
            //execute the query
            Object result =  method.invoke(delegate,args);
            long delta = (process)?(System.currentTimeMillis()-start):0;
            if (delta>threshold) {
                String sql = null;//TODO
                QueryStats qs = SlowQueryReport.this.queries.get(sql);
                if (qs == null) {
                    qs = new QueryStats(sql);
                    SlowQueryReport.this.queries.put((String)sql,qs);
                }
                qs.add(delta);
                return qs;
            }
            if (close) {
                closed=true;
                delegate = null;
            }
            return result;
        }
    }
    public void reset(ConnectionPool parent, PooledConnection con) {
        if (queries==null && SlowQueryReport.perPoolStats.get(parent)==null) {
            queries = new LinkedHashMap<String,QueryStats>() {
                @Override
                protected boolean removeEldestEntry(Entry<String, QueryStats> eldest) {
                    return size()>maxQueries;
                }
            };
        }
    }
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/
   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
   1. Definitions.
      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.
      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.
      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.
      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.
      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.
      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.
      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).
      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.
      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."
      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.
   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.
   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.
   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:
      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and
      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and
      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and
      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.
      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.
   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.
   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.
   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.
   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.
   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.
   END OF TERMS AND CONDITIONS
   APPENDIX: How to apply the Apache License to your work.
      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.
   Copyright [yyyy] [name of copyright owner]
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

======= 8d5db6f:"java/javax/el/CompositeELResolver.java"

======= 8d5db6f:"java/javax/el/CompositeELResolver.java"

        private Iterator<FeatureDescriptor> itr;
        private FeatureDescriptor next;
======= 8d5db6f:"java/javax/el/CompositeELResolver.java"

        public boolean hasNext() {          
            if (this.next != null)
                return true;
            if (this.itr != null){
                while (this.next == null && itr.hasNext()) {
                    this.next = itr.next();
                }
            } else {
                return false;
            }
            if (this.next == null) {
                this.itr = null;
                this.guaranteeIterator();
            }
            return hasNext();
            if (!hasNext())
                throw new NoSuchElementException();
            FeatureDescriptor next = this.next;
            this.next = null;
            return next;

======= b5a5094:"java/org/apache/jasper/compiler/Compiler.java"

            if (tfp != null && ctxt.isPrototypeMode()) {

======= 23a8ba0:"java/org/apache/catalina/connector/MapperListener.java"

======= 23a8ba0:"java/org/apache/catalina/connector/MapperListener.java"

    implements NotificationListener, ContainerListener
======= 23a8ba0:"java/org/apache/catalina/connector/MapperListener.java"

    // --------------------------------------------- Container Listener methods
    public void containerEvent(ContainerEvent event) {
        if (event.getType() == Host.ADD_ALIAS_EVENT) {
            mapper.addHostAlias(((Host) event.getSource()).getName(),
                    event.getData().toString());
        } else if (event.getType() == Host.REMOVE_ALIAS_EVENT) {
            mapper.removeHostAlias(event.getData().toString());
        }
    }
    
======= 23a8ba0:"java/org/apache/catalina/connector/MapperListener.java"

        // This should probably be called later 
======= 23a8ba0:"java/org/apache/catalina/connector/MapperListener.java"

            Host host = (Host) ServerFactory.getServer().findService(
                    domain).getContainer().findChild(name);
        
            String[] aliases = host.findAliases();
            host.addContainerListener(this);
======= 23a8ba0:"java/org/apache/catalina/connector/MapperListener.java"

        if( name != null ) { 
            Host host = (Host) ServerFactory.getServer().findService(
                domain).getContainer().findChild(name);
        
            mapper.removeHost(name);
            host.removeContainerListener(this);
            if(log.isDebugEnabled())
                log.debug(sm.getString
                        ("mapperListener.unregisterHost", name, domain));
        }
======= 23a8ba0:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

    /**
     * Add an alias to an existing host.
     * @param name  The name of the host
     * @param alias The alias to add
     */
    public synchronized void addHostAlias(String name, String alias) {
        int pos = find(hosts, name);
        if (pos < 0) {
            // Should not be adding an alias for a host that doesn't exist but
            // just in case...
            return;
        }
        Host realHost = hosts[pos];
        
        Host[] newHosts = new Host[hosts.length + 1];
        Host newHost = new Host();
        newHost.name = alias;
        newHost.contextList = realHost.contextList;
        newHost.object = realHost;
        if (insertMap(hosts, newHosts, newHost)) {
            hosts = newHosts;
        }
    }
    /**
     * Remove a host alias
     * @param alias The alias to remove
     */
    public synchronized void removeHostAlias(String alias) {
        // Find and remove the alias
        int pos = find(hosts, alias);
        if (pos < 0) {
            return;
        }
        Host[] newHosts = new Host[hosts.length - 1];
        if (removeMap(hosts, newHosts, alias)) {
            hosts = newHosts;
        }
    }
======= 23a8ba0:"java/org/apache/tomcat/util/http/mapper/Mapper.java"

     * Find a map element given its name in a sorted array of map elements.

======= 4d5cca1:"java/org/apache/catalina/ssi/SSIServletExternalResolver.java"

    protected String getPathWithoutContext(final String contextPath,
            final String servletPath) {
        if (servletPath.startsWith(contextPath)) {
            return servletPath.substring(contextPath.length());
        return servletPath;
======= 4d5cca1:"java/org/apache/catalina/ssi/SSIServletExternalResolver.java"

                    String noContext = getPathWithoutContext(
                            normContext.getContextPath(), normalized);

======= e148369:"java/org/apache/catalina/core/ApplicationFilterChain.java"

                        ("doFilter", filter, classType, args, principal);
======= e148369:"java/org/apache/catalina/security/SecurityUtil.java"

     * Perform work as a particular <code>Subject</code>. Here the work
======= e148369:"java/org/apache/catalina/security/SecurityUtil.java"

        doAsPrivilege(
                methodName, targetObject, targetType, targetArguments, null);
    }
    
    /**
     * Perform work as a particular <code>Subject</code>. Here the work
     * will be granted to a <code>null</code> subject. 
     *
     * @param methodName the method to apply the security restriction
     * @param targetObject the <code>Filter</code> on which the method will 
     * be called.
     * @param targetType <code>Class</code> array used to instanciate a
     * <code>Method</code> object.
     * @param targetArguments <code>Object</code> array contains the 
     * runtime parameters instance.
     * @param principal the <code>Principal</code> to which the security 
     * privilege apply
     */    
    public static void doAsPrivilege(final String methodName, 
                                     final Filter targetObject, 
                                     final Class[] targetType,
                                     final Object[] targetArguments,
                                     Principal principal) 
        throws java.lang.Exception{
======= e148369:"java/org/apache/catalina/security/SecurityUtil.java"

        execute(method, targetObject, targetArguments, principal);

======= 38ef38d:"java/org/apache/jasper/compiler/ParserController.java"

            if (jarFile == null) {
                compiler.getPageInfo().addDependant(absFileName);
            } else {
                compiler.getPageInfo().addDependant(
                        jarFileUrl.toExternalForm() + absFileName.substring(1));
            }

======= e0489c8:"java/org/apache/catalina/core/StandardHostValve.java"

        Class<?> clazz = exception.getClass();
======= e0489c8:"java/org/apache/catalina/core/StandardHostValve.java"

            response.resetBuffer();

======= f4bef20:"java/org/apache/catalina/connector/CoyoteWriter.java"

    // No need for a do privileged block - every web app has permission to read
    // this by default
    private static final char[] LINE_SEP =
        System.getProperty("line.separator").toCharArray();

======= d9def07:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

        request.getCoyoteRequest().getParameters().setQueryStringEncoding(
                request.getConnector().getURIEncoding());

======= 85e71cf:"java/org/apache/tomcat/util/http/fileupload/DeferredFileOutputStream.java"

        if (threshold < DefaultFileItemFactory.DEFAULT_SIZE_THRESHOLD) {
            // Small threshold, use it
            memoryOutputStream = new ByteArrayOutputStream(threshold);
        } else {
            // Large threshold. Use default and array will expand if required
            memoryOutputStream = new ByteArrayOutputStream(
                    DefaultFileItemFactory.DEFAULT_SIZE_THRESHOLD);
        }

======= 6344b96:"java/org/apache/catalina/session/StandardSession.java"

    protected volatile long lastAccessedTime = creationTime;
======= 6344b96:"java/org/apache/catalina/session/StandardSession.java"

    protected volatile long thisAccessedTime = creationTime;

======= 428c03b:"java/org/apache/catalina/core/DefaultInstanceManager.java"

======= 428c03b:"java/org/apache/catalina/core/DefaultInstanceManager.java"

======= 428c03b:"java/org/apache/catalina/core/DefaultInstanceManager.java"

    protected void postConstruct(Object instance, final Class<?> clazz)
        Method[] methods = null;
        if (Globals.IS_SECURITY_ENABLED) {
            methods = AccessController.doPrivileged(
                    new PrivilegedAction<Method[]>(){
                public Method[] run(){
                    return clazz.getDeclaredMethods();
                }
            });
        } else {
            methods = clazz.getDeclaredMethods();
        }
======= 428c03b:"java/org/apache/catalina/core/DefaultInstanceManager.java"

            Field[] fields = null;
            if (Globals.IS_SECURITY_ENABLED) {
                final Class<?> clazz2 = clazz;
                fields = AccessController.doPrivileged(
                        new PrivilegedAction<Field[]>(){
                    public Field[] run(){
                        return clazz2.getDeclaredFields();
                    }
                });
            } else {
                fields = clazz.getDeclaredFields();
            }
======= 428c03b:"java/org/apache/catalina/core/DefaultInstanceManager.java"

            Method[] methods = null;
            if (Globals.IS_SECURITY_ENABLED) {
                final Class<?> clazz2 = clazz;
                methods = AccessController.doPrivileged(
                        new PrivilegedAction<Method[]>(){
                    public Method[] run(){
                        return clazz2.getDeclaredMethods();
                    }
                });
            } else {
                methods = clazz.getDeclaredMethods();
            }

======= e40c910:"java/org/apache/naming/resources/ResourceAttributes.java"

     * @return Weak ETag
        return getETag(false);
    }
    /**
     * Get ETag.
     * 
     * @param strong If true, the strong ETag will be returned
     * @return ETag
     */
    public String getETag(boolean strong) {
        if (strong) {
            // The strong ETag must always be calculated by the resources
            if (strongETag != null)
                return strongETag;
            if (attributes != null) {
                Attribute attribute = attributes.get(ETAG);
                if (attribute != null) {
                    try {
                        strongETag = attribute.get().toString();
                    } catch (NamingException e) {
                        ; // No value for the attribute
            return strongETag;
        } else {
            // The weakETag is contentLenght + lastModified
            if (weakETag == null) {
                weakETag = "W/\"" + getContentLength() + "-" 
                    + getLastModified() + "\"";
            }
            return weakETag;

======= e277f6c:"java/org/apache/catalina/connector/CoyoteAdapter.java"


======= e85ed8c:"java/org/apache/catalina/Globals.java"

    public static final String SESSION_COOKIE_NAME =
        System.getProperty("org.apache.catalina.SESSION_COOKIE_NAME",
                "JSESSIONID");
    public static final String SESSION_PARAMETER_NAME =
        System.getProperty("org.apache.catalina.SESSION_PARAMETER_NAME",
                "jsessionid");
======= e85ed8c:"java/org/apache/catalina/authenticator/Constants.java"

    public static final String SINGLE_SIGN_ON_COOKIE =
        System.getProperty(
                "org.apache.catalina.authenticator.Constants.SSO_SESSION_COOKIE_NAME",
                "JSESSIONIDSSO");
======= e85ed8c:"java/org/apache/jasper/Constants.java"

    public static final String SESSION_PARAMETER_NAME =
        System.getProperty("org.apache.catalina.SESSION_PARAMETER_NAME",
                "jsessionid");
  <properties>
    <property name="org.apache.catalina.SESSION_COOKIE_NAME">
      <p>An alternative name for the session cookie. Defaults to
      <code>JSESSIONID</code>. Note that the Servlet specification requires
      this to be <code>JSESSIONID</code>. You should not rely on being able to
      change this.</p>
    </property>
    <property name="org.apache.catalina.SESSION_PARAMETER_NAME">
      <p>An alternative name for the session path parameter. Defaults to
      <code>jsessionid</code>. Note that the Servlet specification requires
      this to be <code>jsessionid</code>. You should not rely on being able to
      change this.</p>
    </property>
    <property name="org.apache.catalina.SSO_SESSION_COOKIE_NAME">
      <p>An alternative name for the single sign on session cookie. Defaults to
      <code>JSESSIONIDSSO</code>.</p>
    </property>
    
  </properties>

======= f69637f:"java/org/apache/catalina/core/StandardContext.java"

======= f69637f:"java/org/apache/catalina/core/StandardContext.java"

======= f69637f:"java/org/apache/catalina/core/StandardContext.java"

        if (processTlds) {
            this.addLifecycleListener(new TldConfig());
        }
======= f69637f:"java/org/apache/catalina/startup/TldConfig.java"

 * Startup event listener for a <b>Context</b> that configures application
 * listeners configured in any TLD files.
======= f69637f:"java/org/apache/catalina/startup/TldConfig.java"

======= f69637f:"java/org/apache/catalina/startup/TldConfig.java"

======= f69637f:"java/org/apache/catalina/startup/TldConfig.java"

    public void lifecycleEvent(LifecycleEvent event) {
        // Identify the context we are associated with
        try {
            context = (Context) event.getLifecycle();
        } catch (ClassCastException e) {
            log.error(sm.getString("tldConfig.cce", event.getLifecycle()), e);
            return;
        }
        
        if (event.getType().equals(Lifecycle.INIT_EVENT)) {
            init();
        } else if (event.getType().equals(Lifecycle.START_EVENT)) {
            try {
                execute();
            } catch (Exception e) {
                log.error(sm.getString(
                        "tldConfig.execute", context.getPath()), e);
            }
        } // Ignore the other event types - nothing to do 
    }
    
    private void init() {
        if (tldDigester == null){
            // (1)  check if the attribute has been defined
            //      on the context element.
            setTldValidation(context.getTldValidation());
            setTldNamespaceAware(context.getTldNamespaceAware());
    
            // (2) if the attribute wasn't defined on the context
            //     try the host.
            if (!tldValidation) {
              setTldValidation(
                      ((StandardHost) context.getParent()).getXmlValidation());
            }
    
            if (!tldNamespaceAware) {
              setTldNamespaceAware(
                      ((StandardHost) context.getParent()).getXmlNamespaceAware());
            }
            tldDigester = DigesterFactory.newDigester(tldValidation, 
                    tldNamespaceAware, 
                    new TldRuleSet());
            tldDigester.getParser();
        }
    }

======= c340c69:"java/org/apache/catalina/ha/deploy/FarmWarDeployer.java"

            host = (Host) engine.findChild(hostname);
======= c340c69:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

======= c340c69:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

     * The number of messages we have written
======= c340c69:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

    
    /**
     * The number of the last message procssed. Message IDs are 1 based.
     */
    protected AtomicLong lastMessageProcessed = new AtomicLong(0);
    
    /**
     * Messages received out of order are held in the buffer until required. If
     * everything is worked as expected, messages will spend very little time in
     * the buffer.
     */
    protected Map<Long, FileMessage> msgBuffer =
        new ConcurrentHashMap<Long, FileMessage>();
======= c340c69:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

     * Flag that indicates if a thread is writing messages to disk. Access to
     * this flag must be synchronised.
     */
    protected boolean isWriting = false;
    /**
======= c340c69:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

        
        if (msg.getMessageNumber() <= lastMessageProcessed.get()) {
            // Duplicate of message already processed
            log.warn("Receive Message again -- Sender ActTimeout too short [ path: "
                    + msg.getContextPath()
                    + " war: "
                    + msg.getFileName()
                    + " data: "
                    + msg.getData()
                    + " data length: " + msg.getDataLength() + " ]");
            return false;
        }
        
        FileMessage previous =
            msgBuffer.put(new Long(msg.getMessageNumber()), msg);
        if (previous !=null) {
            // Duplicate of message not yet processed
            log.warn("Receive Message again -- Sender ActTimeout too short [ path: "
                    + msg.getContextPath()
                    + " war: "
                    + msg.getFileName()
                    + " data: "
                    + msg.getData()
                    + " data length: " + msg.getDataLength() + " ]");
            return false;
        }
        
        FileMessage next = null;
        synchronized (this) {
            if (!isWriting) {
                next = msgBuffer.get(new Long(lastMessageProcessed.get() + 1));
                if (next != null) {
                    isWriting = true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
        
        while (next != null) {
            out.write(next.getData(), 0, next.getDataLength());
            lastMessageProcessed.incrementAndGet();
            if (next.getMessageNumber() == next.getTotalNrOfMsgs()) {
            }
            synchronized(this) {
                next =
                    msgBuffer.get(new Long(lastMessageProcessed.get() + 1));
                if (next == null) {
                    isWriting = false;
                }
            }
        
======= c340c69:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"

        msgBuffer.clear();
        lastMessageProcessed = null;
======= c340c69:"java/org/apache/catalina/ha/deploy/FileMessageFactory.java"


======= 03097fa:"java/org/apache/jk/common/JkInputStream.java"

        if (message == null) {
            // mod_jk + httpd 2.x fails with a null status message - bug 45026
            message = Integer.toString(res.getStatus());
        }

  <!--   useAcceptRanges     Should the Accept-Ranges header be included    -->
  <!--                       in responses where appropriate? [true]         -->
  <!--                                                                      -->
======= 633545f:"java/org/apache/catalina/servlets/DefaultServlet.java"

    /**
     * Should the Accept-Ranges: bytes header be send with static resources?
     */
    protected boolean useAcceptRanges = true;
======= 633545f:"java/org/apache/catalina/servlets/DefaultServlet.java"

        if (getServletConfig().getInitParameter("useAcceptRanges") != null)
            useAcceptRanges = Boolean.parseBoolean(getServletConfig().getInitParameter("useAcceptRanges"));
======= 633545f:"java/org/apache/catalina/servlets/DefaultServlet.java"

            if (useAcceptRanges) {
                // Accept ranges header
                response.setHeader("Accept-Ranges", "bytes");
            }
  <tr>
    <th valign='top'>useAcceptRanges</th>
    <td valign='top'>
        If true, the Accept-Ranges header will be set when appropriate for the
        response. [true]
    </td>
  </tr>

======= 2c0fffe:"java/org/apache/catalina/core/ApplicationDispatcher.java"

                     getCombinedPath());
======= 2c0fffe:"java/org/apache/catalina/core/ApplicationDispatcher.java"

    /**
     * Combine the servletPath and the pathInfo. If pathInfo is
     * <code>null</code> it is ignored. If servletPath is <code>null</code> then
     * <code>null</code> is returned.
     * @return The combined path with pathInfo appended to servletInfo
     */
    private String getCombinedPath() {
        if (servletPath == null) {
            return null;
        }
        if (pathInfo == null) {
            return servletPath;
        }
        return servletPath + pathInfo;
    }
======= 2c0fffe:"java/org/apache/catalina/core/ApplicationDispatcher.java"

                    getCombinedPath());
======= 2c0fffe:"java/org/apache/catalina/core/ApplicationDispatcher.java"

                    getCombinedPath());

======= 678b516:"java/org/apache/catalina/valves/AccessLogValve.java"

            String value = request.getHeader(header);
            if (value == null) {
                buf.append('-');
            } else {
                buf.append(value);
            }

======= d69b378:"java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java"

        try {selector.close();} catch (Exception ignore) {}

      <exclude name="org/apache/tomcat/bayeux/**" />
      <exclude name="org/apache/cometd/**" />
  <property name="cometd-api.jar" value="${tomcat.extras}/cometd-api.jar"/>
  <property name="tomcat-bayeux.jar" value="${tomcat.extras}/tomcat-bayeux.jar"/>
  <property name="cometd.war" value="${tomcat.extras}/cometd.war"/>
  <target name="bayeux">
    <mkdir dir="${tomcat.extras}"/>
    <copy todir="${tomcat.extras}" file="${json-lib.home}/${json-lib.jar}"/>
    <!-- Classpath -->
    <path id="tomcat.bayeux.classpath">
      <pathelement path="${tomcat.classpath}"/>
      <pathelement path="${json-lib.home}/${json-lib.jar}"/>
    </path>
    <!-- compile org.apache.tomcat.bayeux -->
    <!-- compile org.apache.cometd -->
    <javac srcdir="java" destdir="${tomcat.classes}"
           debug="${compile.debug}"
           deprecation="${compile.deprecation}"
           source="${compile.source}"
           optimize="${compile.optimize}">
      <classpath refid="tomcat.bayeux.classpath" />
      <include name="org/apache/tomcat/bayeux/**" />
      <include name="org/apache/cometd/**" />
    </javac>
    <!-- Cometd API JAR File -->
    <jar jarfile="${cometd-api.jar}">
      <fileset dir="${tomcat.classes}">
        <exclude name="**/package.html" />
        <exclude name="**/LocalStrings_*" />
        <include name="org/apache/cometd/**" />
      </fileset>
    </jar>
    <!-- Cometd API JAR File -->
    <jar jarfile="${tomcat-bayeux.jar}">
      <fileset dir="${tomcat.classes}">
        <exclude name="**/package.html" />
        <exclude name="**/LocalStrings_*" />
        <include name="org/apache/tomcat/bayeux/**" />
      </fileset>
    </jar>
    <zip zipfile="${cometd.war}">
      <fileset dir="${basedir}/webapps/cometd">
        <include name="**/**"/>
      </fileset>
    </zip>
    <checksum file="${cometd-api.jar}" forceOverwrite="yes" fileext=".md5" />
    <checksum file="${tomcat-bayeux.jar}" forceOverwrite="yes" fileext=".md5" />
    <checksum file="${tomcat.extras}/${json-lib.jar}" forceOverwrite="yes" fileext=".md5" />
    <echo>You've built the Tomcat Bayeux libraries, simply add the following libraries to your CATALINA_HOME/lib directory:
          ${cometd-api.jar}
          ${tomcat-bayeux.jar} 
          ${tomcat.extras}/${json-lib.jar}
          ${cometd.war}
    </echo>
  </target>
  <target name="extras" depends="prepare,commons-logging,webservices,bayeux">
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * This interface represents the server side API for the Bayeux messaging protocol.
 * Bayeux is a simple subscribe/publish/receive methodology, not far from JMS, but much simplified.<br/>
 * It is used both by the actual implementation and by server side clients.<br/>
 * Server side clients use this to create, retrieve and subscribe to channels.
 * Server side clients are represented, just like remote clients, through the Client interface.
 * <br/>
 * The Bayeux implementations is intended to be thread safe and multiple threads may simultaneously call Bayeux methods.
 * <br/>
 * The Bayeux object, is the starting point for any cometd application relying on the Bayeux object.
 * Dependent on the container, the Bayeux object will be stored in the <code>javax.servlet.ServletContext</code> object
 * as an attribute under the name <code>Bayeux.DOJOX_COMETD_BAYEUX</code><br/>
 * To retrieve this object, one would simply call<br/>
 * <code>Bayeux bx = (Bayeux)getServletContext().getAttribute(Bayeux.DOJOX_COMETD_BAYEUX);
 * <br/><br/>
 * The Bayeux protocol is pretty straight forward and includes a bunch of messaging that is not needed to be known to clients,
 * both server side and remote clients.
 * This object gets initialized by a container dependent servlet, and the servlet then handles all Bayeux communication from the client.
 * Remote messsages are delivered to channels, and to server side clients using the <code>Listener</code> interface.<br/>
 * <br/>
 * A <code>Bayeux session</code> is active as long as the webapp hosting the Bayeux object is active.<br/>
 * When the webapplication shuts down, the Bayeux object will unsubscribe all clients and remove all the active channels.
 * 
 * @author Greg Wilkins
 * @author Filip Hanik
 */
    
    /**Meta definitions for channels*/
    public static final String META="/meta";
    /**Meta definitions for channels*/
    public static final String META_SLASH="/meta/";
    /**Meta definitions for channels - connect message*/
    public static final String META_CONNECT="/meta/connect";
    /**Meta definitions for channels - client messsage*/
    public static final String META_CLIENT="/meta/client";
    /**Meta definitions for channels - disconnect messsage*/
    public static final String META_DISCONNECT="/meta/disconnect";
    /**Meta definitions for channels - handshake messsage*/
    public static final String META_HANDSHAKE="/meta/handshake";
    /**Meta definitions for channels - ping messsage*/
    public static final String META_PING="/meta/ping";
    /**Meta definitions for channels - reconnect messsage
     * @deprecated
     */
    public static final String META_RECONNECT="/meta/reconnect";
    /**Meta definitions for channels - status messsage*/
    public static final String META_STATUS="/meta/status";
    /**Meta definitions for channels - subscribe messsage*/
    public static final String META_SUBSCRIBE="/meta/subscribe";
    /**Meta definitions for channels - unsubscribe messsage*/
    public static final String META_UNSUBSCRIBE="/meta/unsubscribe";
    /*Field names inside Bayeux messages*/
    /**Field names inside Bayeux messages - clientId field*/
    public static final String CLIENT_FIELD="clientId";
    /**Field names inside Bayeux messages - data field*/
    public static final String DATA_FIELD="data";
    /**Field names inside Bayeux messages - channel field*/
    public static final String CHANNEL_FIELD="channel";
    /**Field names inside Bayeux messages - id field*/
    public static final String ID_FIELD="id";
    /**Field names inside Bayeux messages - error field*/
    public static final String ERROR_FIELD="error";
    /**Field names inside Bayeux messages - timestamp field*/
    public static final String TIMESTAMP_FIELD="timestamp";
    /**Field names inside Bayeux messages - transport field*/
    public static final String TRANSPORT_FIELD="transport";
    /**Field names inside Bayeux messages - advice field*/
    public static final String ADVICE_FIELD="advice";
    /**Field names inside Bayeux messages - successful field*/
    public static final String SUCCESSFUL_FIELD="successful";
    /**Field names inside Bayeux messages - subscription field*/
    public static final String SUBSCRIPTION_FIELD="subscription";
    /**Field names inside Bayeux messages - ext field*/
    public static final String EXT_FIELD="ext";
    /**Field names inside Bayeux messages - connectionType field*/
    public static final String CONNECTION_TYPE_FIELD="connectionType";
    /**Field names inside Bayeux messages - version field*/
    public static final String VERSION_FIELD="version";
    /**Field names inside Bayeux messages - minimumVersion field*/
    public static final String MIN_VERSION_FIELD="minimumVersion";
    /**Field names inside Bayeux messages - supportedConnectionTypes field*/
    public static final String SUPP_CONNECTION_TYPE_FIELD="supportedConnectionTypes";
    /**Field names inside Bayeux messages - json-comment-filtered field*/
    public static final String JSON_COMMENT_FILTERED_FIELD="json-comment-filtered";
    /**Field names inside Bayeux messages - reconnect field*/
    public static final String RECONNECT_FIELD = "reconnect";
    /**Field names inside Bayeux messages - interval field*/
    public static final String INTERVAL_FIELD = "interval";
    /**Field values inside Bayeux messages - retry response*/
    public static final String RETRY_RESPONSE = "retry";
    /**Field values inside Bayeux messages - handshake response*/
    public static final String HANDSHAKE_RESPONSE = "handshake";
    /**Field values inside Bayeux messages - none response*/
    public static final String NONE_RESPONSE = "none";
    /**Service channel names-starts with*/
    public static final String SERVICE="/service";
    /**Service channel names-trailing slash*/
    public static final String SERVICE_SLASH="/service/";
    /*Transport types*/
    /**Transport types - long polling*/
    public static final String TRANSPORT_LONG_POLL="long-polling";
    /**Transport types - callback polling*/
    public static final String TRANSPORT_CALLBACK_POLL="callback-polling";
    /**Transport types - iframe*/
    public static final String TRANSPORT_IFRAME="iframe";
    /**Transport types - flash*/
    public static final String TRANSPORT_FLASH="flash";
    /** ServletContext attribute name used to obtain the Bayeux object */
    public static final String DOJOX_COMETD_BAYEUX="dojox.cometd.bayeux";
    /*http field names*/
    /**http helpers - text/json content type*/
    public static final String JSON_CONTENT_TYPE="text/json";
    /**http helpers - parameter name for json message*/
    public static final String MESSAGE_PARAMETER="message";
    /**http helpers - name of the jsonp parameter*/
    public static final String JSONP_PARAMETER="jsonp";
    /**http helpers - default name of the jsonp callback function*/
    public static final String JSONP_DEFAULT_NAME="jsonpcallback";
    /*--Client----------------------------------------------------------- */
    /**
     * Creates a new server side client. This method is to be invoked
     * by server side objects only. You cannot create a remote client by using this method.
     * A client represents an entity that can subscribe to channels and publish and receive messages
     * through these channels
     * @param idprefix String - the prefix string for the id generated, can be null
     * @param listener Listener - a callback object to be called when messages are to be delivered to the new client
     * @return Client - returns an implementation of the client interface.
     */
    public Client newClient(String idprefix, Listener listener);
    /**
     * retrieve a client based on an ID. Will return null if the client doesn't exist.
     * @param clientid String
     * @return Client-null if the client doesn't exist.returns the client if it does.
     */
    public Client getClient(String clientid);
    
    /**
     * Returns a non modifiable list of all the clients that are currently active
     * in this Bayeux session
     * @return List<Client> - a list containing all clients. The List can not be modified.
     */
    public List<Client> getClients();
    
    /**
     * Returns true if a client with the given id exists.<br/>
     * Same as executing <code>getClient(id)!=null</code>.
     * @param clientId String
     * @return boolean - true if the client exists
     */
    public boolean hasClient(String clientId);
    
    /**
     * Removes the client all together.
     * This will unsubscribe the client to any channels it may be subscribed to
     * and remove it from the list.
     * @param client Client
     * @return Client - returns the client that was removed, or null if no client was removed.
     */
    public Client remove(Client client);
    
    /*--Channel---------------------------------------------------------- */
    /**
     * Returns the channel for a given channel id.
     * If the channel doesn't exist, and the <code>create</code> parameter is set to true,
     * the channel will be created and added to the list of active channels.<br/>
     * if <code>create</code> is set to false, and the channel doesn't exist, null will be returned.
     * @param channelId String - the id of the channel to be retrieved or created
     * @param create boolean - true if the Bayeux impl should create the channel
     * @return Channel - null if <code>create</code> is set to false and the channel doesn't exist, 
     * otherwise it returns a channel object.
     */
    public Channel getChannel(String channelId, boolean create);
    
    /**
     * Returns a list of currently active channels in this Bayeux session.
     * @return List<Channel>
     */
    public List<Channel> getChannels();
    /**
     * Removes a channel from the Bayeux object.
     * This will also unsubscribe all the clients currently subscribed to the
     * the channel.
     * @param channel Channel - the channel to be removed
     * @return Channel - returns the channel that was removed, or null if no channel was removed.
     */
    public Channel remove(Channel channel);
    /**
     * returns true if a channel with the given channelId exists.
     * <br/>Same as executing <code>Bayeux.getChannel(channelId,false)!=null</code>
     * @param channelId String
     * @return boolean - true if the channel exists.
     */
    public boolean hasChannel(String channelId);
    /* --Message---------------------------------------------------------- */
    /**
     * Creates a new message to be sent by a server side client.
     * @return Message - returns a new Message object, that has a unique id.
     */
    public Message newMessage(Client from);
    /*--Security policy----------------------------------------------------------- */
    /**
     * Returns the security policy associated with this Bayeux session
     * @return SecurityPolicy
     */
    public SecurityPolicy getSecurityPolicy();
   
    /**
     * Sets the security policy to be used in this Bayeux session
     * @param securityPolicy SecurityPolicy
     */
    public void setSecurityPolicy(SecurityPolicy securityPolicy);
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * A Bayeux Channel represents a channel used to receive messages from and to publish messages to.
 * In order to publish messages to or receive messages from, one must subscribe to the channel.
 * This is easily done by invoking the <code>subscribe</code> method.
 * A channel is created by calling the <code>Bayeux.getChannel(channelId,true)</code> method.
 * A channel can be created either server side by invoking the getChannel, or client side
 * by using the /meta/subscribe message without a wildcard.
 * @author Greg Wilkins
 * @author Filip Hanik
 */
    /**
     * Returns the id for this channel. The id is unique within bayeux session.
     * @return String - will never be null.
     */
    public String getId();
    /** 
     * Publishes a message to all the subscribers of this channel.
     * The <code>from</code> is contained within the message, by calling
     * <code>msg.getClient()</code>
     * @param data - the message to be published, can not be null.
     */
    public void publish(Message msg);
    
    /** 
     * Publishes more than one message to all the subscribers of this channel.
     * The <code>from</code> is contained within the message, by calling
     * <code>msg[x].getClient()</code>
     * @param data - the message to be published, can not be null.
     */
    public void publish(Message[] msgs);
    /** 
     * Non persistent channels are removed when the last subscription is
     * removed. Persistent channels survive periods without any subscribers.
     * @return true if the Channel will persist without any subscription.
     */
    public boolean isPersistent();
    
    /**
     * @param persistent true if the Channel will persist without any subscription.
     * @see isPersistent
     */
    public void setPersistent(boolean persistent);
    
    /** 
     * Subscribes a client to a channel.
     * @param subscriber - the client to be subscribed. If the client
     * already is subscribed, this call will not create a duplicate subscription.
     */
    public void subscribe(Client subscriber);
    /** 
     * Unsubscribes a client from a channel
     * @param subscriber - the client to be subscribed.
     * @return - returns the client that was unsubscribed, or null if the client wasn't subscribed.
     */
    public Client unsubscribe(Client subscriber);
    /**
     * returns a non modifiable list of all the subscribers to this 
     * channel.
     * @return a list of subscribers
     */
    public List<Client> getSubscribers();
    
    /**
     * Adds a data filter to this channel. All messages received by this channel 
     * will run through this filter.
     * @param filter Filter
     */
    public void addFilter(DataFilter filter);
    
    /**
     * Removes a filter from this channel.
     * returns the filter that was removed, or null if the filter wasn't in the channel.
     * @param filter Filter
     * @return Filter - null if no filter was removed otherwise it returns the filter that was removed.
     */
    public DataFilter removeFilter(DataFilter filter);
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * <p>
 * A client may subscribe to channels and publish messages to channels.
 * Client instances should not be directly created by uses, but should 
 * be obtained via the {@link Bayeux#getClient(String)} or {@link Bayeux#newClient(String, Listener)}
 * methods.
 * </p>
 * <p>
 * Three types of client may be represented by this interface:<nl>
 * <li>The server representation of a remote client connected via HTTP, 
 *     automatically created by the Bayeux server when a connect message comes in</li>
 * <li>A server side client, created by the application using the {@link Bayeux#newClient(String, Listener)} method</li>
 * <li>A java client connected to a remote Bayeux server - not implemented</li>
 * </nl>
 * @author Greg Wilkins
 * @author Filip Hanik
 */
    /**
     * Returns a unique id for this client. The id is unique within this Bayeux session.
     * @return String - will not be null
     */
    public String getId();
    /**
     * Returns true if this client is holding messages to be delivered to the remote client.
     * This method always returns false for local clients, since messages are delivered instantly using the 
     * Listener(callback) object
     * @return boolean
     */
    public boolean hasMessages();
    /** 
     * Deliver a message to this client only
     * Deliver a message directly to the client. The message is not 
     * filtered or published to a channel.
     * @param message
     */
    public void deliver(Message message);
    /** 
     * Deliver a batch of messages to this client only
     * Deliver a batch messages directly to the client. The messages are not 
     * filtered or published to a channel.
     * @param message
     */
    public void deliver(Message[] message);
    /**
     * @return True if the client is local. False if this client is either a remote HTTP client or
     * a java client to a remote server. 
     */
    public boolean isLocal();
    
    /**
     * Starts a batch, no messages will be delivered until endBatch is called.
     * Batches can be nested, and messages will only be delivered after
     * the last endBatch has been called.
     */
    public void startBatch();
    
    /**
     * Ends a batch. since batches can be nested, messages will only be delivered
     * after the endBatch has been called as many times as startBatch has.
     */
    public void endBatch();
    
    
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Data Filter<br/>
 * Data filters are used to transform data as it is sent to a Channel.
 * Messages are filtered as the message is published to a channel, invoking the 
 * {@link Channel#publish(Message)} method.<br/>
 * This method gets invoked in two different scenarios, the first being when a message is received from
 * a remote client, and the Bayeux implementation invokes the publish method directly.
 * The second scenario is when a local client invokes {@link Channel#publish(Message)} directly in the local JVM.
 * @author Greg Wilkins
 * @author Filip Hanik
 *
 */
    /**
     * Runs a message through the filter. Filtering can only modify an existing object, it can not replace it.
     * @param data Message - the message to be filtered, may not be null
     */
    public void filter(Message data);
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Cometd Listener interface.<br/>
 * For local clients, in order to receive messages, they pass in a callback object
 * when the local client is created using the {@link Bayeux#newClient(String,Listener)} method.
 * This callback object, implementing the Listener interface, is used to deliver messages to local, in JVM, clients.
 * @author Greg Wilkins
 * @author Filip Hanik
 *
 */
    /**
     * This method is called when the client is removed (explicitly or from a timeout)
     * @param timeout - true if the client was removed from a timeout
     * false if it was removed explicitly.
     */
    public void removed(boolean timeout);
    
    /**
     * Invoked when a message is delivered to the client.
     * The message contains the message itself, as well as what channel this message came through
     * and who the sender is. If someone invoked {@link Client#deliver(Message)} then the channel reference will
     * be null.
     * @param msg 
     */
    public void deliver(Message[] msg);
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * A Bayeux Message<br/>
 * A Bayeux message is a Map of String/Object key value pairs representing the data in the message.
 * The message contains information about the channel it was published through and who the sender was
 * 
 * @author Greg Wilkins
 * @author Filip Hanik
 */
    /**
     * Returns a reference to the client that sent this message
     * @return Client - may be null
     */
    public Client getClient();
    /**
     * Returns a reference to the channel that this message was published throuhg
     * @return Channel - may be null
     */
    public Channel getChannel();
    /**
     * Returns the unique id of this message
     * @return String
     */
    public String getId();
    
    /**
     * Sets the time to live in milliseconds. If the message hasn't been delivered 
     * when the time passed after the creation time is longer than the TTL the message will
     * expire and removed from any delivery queues.
     * @param ttl long
     */
    public void setTTL(long ttl);
    
    /**
     * Returns the time to live (in milliseconds) for this message
     * @return long
     */
    public long getTTL();
    
    /**
     * returns the timestamp in milliseconds(System.currentTimeMillis()) of when this message was created.
     * @return long
     */
    public long getCreationTime();
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * @author Greg Wilkins
 */
    boolean canHandshake(Message message);
    boolean canCreate(Client client,String channel,Message message);
    boolean canSubscribe(Client client,String channel,Message messsage);
    boolean canPublish(Client client,String channel,Message messsage);
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * 
 * @author Filip Hanik
 * @version 1.0
 */
    public BayeuxException() {
        super();
    }
    public BayeuxException(String message) {
        super(message);
    }
    public BayeuxException(String message, Throwable cause) {
        super(message, cause);
    }
    public BayeuxException(Throwable cause) {
        super(cause);
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * An interface that defines methods for managing Bayeux request meta 
 * messages.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 0.9
 */
    public static final String LAST_REQ_ATTR = "org.apache.cometd.bayeux.last_request";
    public static final String CURRENT_REQ_ATTR = "org.apache.cometd.bayeux.current_request";
    public static final String JSON_MSG_ARRAY = "org.apache.cometd.bayeux.json_msg_array";
    /**
     * Validates a specific request. 
     * This method must be called prior to process()
     * as a request can do pre processing in the validate method.
     * <br/>
     * Should the validation fail, an error object is returned 
     * containing an error message, and potentially a stack trace
     * if an exception was generated
     * @return HttpError - null if no error was detected, an HttpError object containing information about the error.
     */
    public HttpError validate();
    
    /**
     * processes a remote client Bayeux message
     * @param prevops - the operation requested by the previous request, in case of chained requests.
     * @return int - returns the interest operation for a CometEvent. Currently not used
     * @throws BayeuxException - if an error was detected, and the appropriate error response couldn't be delivered to the client. 
     */
    public int process(int prevops) throws BayeuxException;
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * 
 * @author Filip Hanik
 * @author Guy Molinari
 * @version 1.0
 */
    /**
     * Attribute to hold the TomcatBayeux object in the servlet context
     */
    public static final String TOMCAT_BAYEUX_ATTR = Bayeux.DOJOX_COMETD_BAYEUX;
    
    /**
     * Logger object
     */
    protected static Log log = LogFactory.getLog(BayeuxServlet.class);
    /**
     * Servlet config - for future use
     */
    protected ServletConfig servletConfig;
    
    /**
     * Reference to the global TomcatBayeux object
     */
    protected TomcatBayeux tb;
    
    /**
     * Upon servlet destruction, the servlet will clean up the 
     * TomcatBayeux object and terminate any outstanding events.
     */
    public void destroy() {
        servletConfig = null;
        //to do, close all outstanding comet events
        //tb.destroy();
        tb = null;//TO DO, close everything down
        
    }
    
    /**
     * Returns the preconfigured connection timeout.
     * If no timeout has been configured as a servlet init parameter named <code>timeout</code>
     * then the default of 2min will be used.
     * @return int - the timeout for a connection in milliseconds
     */
    protected int getTimeout() {
        String timeoutS = servletConfig.getInitParameter("timeout");
        int timeout = 120*1000; //2 min
        try {
            timeout = Integer.parseInt(timeoutS);
        }catch (NumberFormatException nfe) {
            //ignore, we have a default value
        }
        return timeout;
    }
    
    protected int getReconnectInterval() {
        String rs = servletConfig.getInitParameter("reconnectInterval");
        int rct = 5000; //5 seconds
        try {
            rct = Integer.parseInt(rs);
        }catch (NumberFormatException nfe) {
            //ignore, we have a default value
        }
        return rct;
    }
    public void event(CometEvent cometEvent) throws IOException, ServletException {
        CometEvent.EventType type = cometEvent.getEventType();
        if (log.isDebugEnabled()) {
            log.debug("["+Thread.currentThread().getName()+"] Received Comet Event type="+type+" subtype:"+cometEvent.getEventSubType());
        }
        synchronized (cometEvent) {
            if (type==CometEvent.EventType.BEGIN) {
                //begin event, set the timeout
                cometEvent.setTimeout(getTimeout());
                //checkBayeux(cometEvent); - READ event should always come
            } else if (type==CometEvent.EventType.READ) {
                checkBayeux(cometEvent);
            } else if (type==CometEvent.EventType.ERROR) {
                tb.remove(cometEvent);
                cometEvent.close();
            } else if (type==CometEvent.EventType.END) {
                tb.remove(cometEvent);
                cometEvent.close();
            }//end if
            
        }//synchronized
    }//event
    /**
     * 
     * @param cometEvent CometEvent
     * @return boolean - true if we comet event stays open
     * @throws IOException
     * @throws UnsupportedOperationException
     */
    protected void checkBayeux(CometEvent cometEvent) throws IOException, UnsupportedOperationException {
        //we actually have data.
        //data can be text/json or 
        if (Bayeux.JSON_CONTENT_TYPE.equals(cometEvent.getHttpServletRequest().getContentType())) {
            //read and decode the bytes according to content length
            log.warn("["+Thread.currentThread().getName()+"] JSON encoding not supported, will throw an exception and abort the request.");
            int contentlength = cometEvent.getHttpServletRequest().getContentLength();
            throw new UnsupportedOperationException("Decoding "+Bayeux.JSON_CONTENT_TYPE+" not yet implemented.");
        } else { //GET method or application/x-www-form-urlencoded
            String message = cometEvent.getHttpServletRequest().getParameter(Bayeux.MESSAGE_PARAMETER);
            if (log.isTraceEnabled()) {
                log.trace("["+Thread.currentThread().getName()+"] Received JSON message:"+message);
            }
            try {
                int action = handleBayeux(message, cometEvent);
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Bayeux handling complete, action result="+action);
                }
                if (action<=0) {
                    cometEvent.close();
                }
            }catch (Exception x) {
                x.printStackTrace();
                tb.remove(cometEvent);
                log.error(x);
                cometEvent.close();
            }
        }
    }
    
    protected int handleBayeux(String message, CometEvent event) throws IOException, ServletException {
        int result = 0;
        if (message==null || message.length()==0) return result;
        try {
            BayeuxRequest request = null;
            //a message can be an array of messages
            JSONArray jsArray = new JSONArray(message);
            for (int i = 0; i < jsArray.length(); i++) {
                JSONObject msg = jsArray.getJSONObject(i);
                
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Processing bayeux message:"+msg);
                }
                request = RequestFactory.getRequest(tb,event,msg);
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Processing bayeux message using request:"+request);
                }
                result = request.process(result);
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Processing bayeux message result:"+result);
                }
            }
            if (result>0 && request!=null) {
                event.getHttpServletRequest().setAttribute(BayeuxRequest.LAST_REQ_ATTR, request);
                ClientImpl ci = (ClientImpl)tb.getClient(((RequestBase)request).getClientId());
                ci.addCometEvent(event);
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Done bayeux message added to request attribute");
                }
            } else if (result == 0 && request!=null) {
                RequestBase.deliver(event,(ClientImpl)tb.getClient(((RequestBase)request).getClientId()));
                if (log.isDebugEnabled()) {
                    log.debug("["+Thread.currentThread().getName()+"] Done bayeux message, delivered to client");
                }
            }
            
        }catch (JSONException x) {
            log.error(x);//to do impl error handling
            result = -1;
        }catch (BayeuxException x) {
            log.error(x); //to do impl error handling
            result = -1;
        }
        return result;
    }
    public ServletConfig getServletConfig() {
        return servletConfig;
    }
    public String getServletInfo() {
        return "Tomcat/BayeuxServlet/1.0";
    }
    public void init(ServletConfig servletConfig) throws ServletException {
        
        this.servletConfig = servletConfig;
        ServletContext ctx = servletConfig.getServletContext();
        if (ctx.getAttribute(TOMCAT_BAYEUX_ATTR)==null)
            ctx.setAttribute(TOMCAT_BAYEUX_ATTR,new TomcatBayeux());
        this.tb = (TomcatBayeux)ctx.getAttribute(TOMCAT_BAYEUX_ATTR);
        tb.setReconnectInterval(getReconnectInterval());
    }
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        if (servletResponse instanceof HttpServletResponse) {
            ( (HttpServletResponse) servletResponse).sendError(500, "Misconfigured Tomcat server, must be configured to support Comet operations.");
        } else {
            throw new ServletException("Misconfigured Tomcat server, must be configured to support Comet operations for the Bayeux protocol.");
        }
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * 
 * @author Filip Hanik
 * @version 1.0
 */
    
    protected static Log log = LogFactory.getLog(ChannelImpl.class);
    
    /**
     * The unique id of this channel
     */
    protected String id = null;
    
    /**
     * A list of the current subscribers
     */
    protected LinkedList<Client> subscribers = new LinkedList<Client>();
    
    /**
     * A list of the current filters
     */
    protected LinkedList<DataFilter> filters = new LinkedList<DataFilter>();
    
    /**
     * Is this channel persistent, default value is true
     */
    protected boolean persistent = true; 
    
    /**
     * Creates a new channel
     * @param id String - the id of the channel, can not be null
     */
    protected ChannelImpl(String id) {
        assert id != null;
        this.id = id;
    }
    /**
     * returns the id of this channel
     * @return String
     */
    public String getId() {
        return id;
    }
    
    /**
     * Returns true if this channel matches the pattern to its id.
     * The channel pattern can be a complete name like <code>/service/mychannel</code>
     * or it can be a wild card pattern like <code>/service/app2/**</code>
     * @param pattern String according to the Bayeux specification section 2.2.1 Channel Globbing, can not be null.
     * @return boolean true if the id of this channel matches the pattern
     */
    public boolean matches(String pattern) {
        if (pattern == null)
            throw new NullPointerException("Channel pattern must not be null.");
        if (getId().equals(pattern))
            return true;
        int wildcardPos = pattern.indexOf("/*");
        if (wildcardPos == -1)
            return false;
        boolean multiSegment = pattern.indexOf("**") != -1;
        String leadSubstring = pattern.substring(0, wildcardPos);
        if (leadSubstring == null)
            return false;
        if (multiSegment) 
            return getId().startsWith(leadSubstring);
        else {
            if (getId().length() <= wildcardPos + 2)
                return false;
            return !(getId().substring(wildcardPos + 2).contains("/"));
        }
    }
    /**
     * @return returns a non modifiable list of the subscribers for this channel.
     */
    public List<Client> getSubscribers() {
        return Collections.unmodifiableList(subscribers);
    }
    /**
     * @return true if the Channel will persist without any subscription.
     */
    public boolean isPersistent() {
        return persistent;
    }
    
    public void publish(Message msg) {
        publish(new Message[] {msg});
    }
    public void publish(Message[] msgs) {
        if (msgs==null) return;
        MessageImpl[] imsgs = new MessageImpl[msgs.length];
        for (int i=0; msgs!=null && i<msgs.length; i++) {
            Message data = msgs[i];
            if (!(data instanceof MessageImpl)) 
                throw new IllegalArgumentException("Invalid message class, you can only publish messages "+
                                                   "created through the Bayeux.newMessage() method");
            if (log.isDebugEnabled()) {
                log.debug("Publishing message:"+data+" to channel:"+this);
            }
            //clone it so that we can set this channel as a reference
            MessageImpl msg = (MessageImpl)((MessageImpl)data).clone();
            //this is the channel it was delivered through
            msg.setChannel(this);
            //pass through filters
            for (Iterator<DataFilter> it = filters.iterator(); it.hasNext(); ) {
                it.next().filter(msg);
            }
            imsgs[i] = msg;
        }
        //deliver it to the clients
        for (Iterator<Client> it = subscribers.iterator(); it.hasNext(); ) {
            ClientImpl c = (ClientImpl)it.next();
            c.deliverInternal(this,imsgs);
        }
        
    }
    public void setPersistent(boolean persistent) {
        this.persistent = persistent;
    }
    public void subscribe(Client subscriber) {
        if (!subscribers.contains((subscriber))) { 
            subscribers.addLast(subscriber);
            ((ClientImpl)subscriber).subscribed(this);
        }
    }
    public Client unsubscribe(Client subscriber) {
        if (subscribers.remove(subscriber)) {
            ((ClientImpl)subscriber).unsubscribed(this);
            return subscriber;
        } else
            return null;
    }
    
    public void addFilter(DataFilter filter) {
        if (!filters.contains(filter)) 
            filters.addLast(filter);
    }
    public DataFilter removeFilter(DataFilter filter) {
        if ( filters.remove(filter) ) return filter;
        else return null;
    }
    
    public String toString() {
        StringBuffer buf = new StringBuffer(super.toString());
        buf.append("; channelId=").append(getId());
        return buf.toString();
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    
    public static final int SUPPORT_CALLBACK_POLL = 0x1;
    public static final int SUPPORT_LONG_POLL = 0x2; 
    public static final String COMET_EVENT_ATTR = "org.apache.cometd.bayeux.client";
    
    protected static Log log = LogFactory.getLog(ClientImpl.class);
    protected static LinkedList<Message> EMPTY_LIST = new LinkedList<Message>();
    /**
     * queued message for remote clients.
     */
    protected LinkedList<Message> messages = null;
    
    /**
     * 
     */
    protected Queue<CometEvent> events = new LinkedList<CometEvent>();
    
    /**
     * Unique id representing this client
     */
    protected String id;
    
    /**
     * supported connection types, defaults to long-polling
     */
    protected int supportedConnTypes = SUPPORT_LONG_POLL | SUPPORT_CALLBACK_POLL;
    
    /**
     * The desired connection type
     */
    protected int desirectConnType = SUPPORT_LONG_POLL;
    
    /**
     * Does this client use json-comment-filtered messages
     */
    protected boolean useJsonFiltered = false;
    
    /**
     * Same JVM clients, get local=true
     */
    protected boolean local;
    
    /**
     * The callback object for local clients
     */
    protected Listener listener;
    
    protected AtomicInteger nrofsubscriptions = new AtomicInteger(0);
    
    protected ClientImpl(String id, boolean local) {
        this.id = id;
        this.local = local;
        if (!local) messages = new LinkedList<Message>();
    }
    
    protected ClientImpl(String id, CometEvent event) {
        this(id,false);
        events = new ConcurrentLinkedQueue<CometEvent>();
        addCometEvent(event);
    }
    public synchronized void deliver(Message message) {
        deliverInternal(null,new MessageImpl[] {(MessageImpl)message});
    }
    
    public synchronized void deliver(Message[] message) {
        deliverInternal(null,message);
    }
    protected synchronized void deliverInternal(ChannelImpl channel, MessageImpl message) {
        deliverInternal(channel,new MessageImpl[] {message});
    }
    protected synchronized void deliverInternal(ChannelImpl channel, Message[] msgs) {
        if (isLocal()) {
            //local clients must have a listener
            ArrayList<Message> list = new ArrayList<Message>();
            for (int i=0; msgs!=null && i<msgs.length; i++) {
                if (this!=msgs[i].getClient()) list.add(msgs[i]);
            }
            if (getListener() != null) {
                getListener().deliver(list.toArray(new Message[0]));
            }
        } else {
            for (int i=0; msgs!=null && i<msgs.length; i++) {
                MessageImpl message = (MessageImpl)msgs[i];
                if (this==message.getClient()) { 
                    //dont deliver to ourself
                    continue;
                }
                //we are not implementing forever responses, if the client is connected
                //then we will fire off the message
                //first we check to see if we have any existing connections we can piggy back on
                CometEvent event = events.poll();
                boolean delivered = false;
                //TODO TODO - check on thread safety, for writing and for getting last request.
                if (event!=null) {
                    synchronized (event) {
                        RequestBase rq = (RequestBase)event.getHttpServletRequest().getAttribute(RequestBase.LAST_REQ_ATTR);
                        if (rq!=null) {
                            Map map = new HashMap();
                            try {
                                map.put(Bayeux.CHANNEL_FIELD,message.getChannel().getId());
                                map.put(Bayeux.DATA_FIELD,message);
                                JSONObject json = new JSONObject(map);
                                if (log.isDebugEnabled()) {
                                    log.debug("Message instantly delivered to remote client["+this+"] message:"+json);
                                }
                                rq.addToDeliveryQueue(this, json);
                                //deliver the batch
                                if (i==(msgs.length-1)) {
                                    rq.deliver(event, this);
                                    event.close(); //todo, figure out a better way, this means only one message gets delivered
                                    removeCometEvent(event); //and delivered instantly
                                }
                                delivered = true;
                            } catch (Exception x) {
                                log.error(x);
                            }
                        }
                    }
                } 
                if (!delivered) {
                    if (log.isDebugEnabled()) {
                        log.debug("Message added to queue for remote client["+this+"] message:"+message);
                    }
                    //queue the message for the next round
                    messages.add(message);
                }
            }
        }
    }
    public String getId() {
        return this.id;
    }
    protected Listener getListener() {
        return listener;
    }
    public boolean hasMessages() {
        if (isLocal()) return false;
        else {
            return messages.size() > 0;
        }
    }
    public boolean isLocal() {
        return local;
    }
    public int getSupportedConnTypes() {
        return supportedConnTypes;
    }
    public int getDesirectConnType() {
        return desirectConnType;
    }
    public boolean useJsonFiltered() {
        return useJsonFiltered;
    }
    public void setListener(Listener listener) {
        this.listener = listener;
    }
    public void setSupportedConnTypes(int supportedConnTypes) {
        this.supportedConnTypes = supportedConnTypes;
    }
    public void setUseJsonFiltered(boolean useJsonFiltered) {
        this.useJsonFiltered = useJsonFiltered;
    }
    public void setDesirectConnType(int desirectConnType) {
        this.desirectConnType = desirectConnType;
    }
    public boolean supportsCallbackPoll() {
        return (supportedConnTypes & SUPPORT_CALLBACK_POLL) == SUPPORT_CALLBACK_POLL;
    }
    public boolean supportsLongPoll() {
        return (supportedConnTypes & SUPPORT_LONG_POLL) == SUPPORT_LONG_POLL;
    }
    public synchronized List<Message> takeMessages() {
        if (isLocal()) return null;
        if (messages.size()==0) return EMPTY_LIST;
        List result = new LinkedList(messages);
        messages.clear();
        return result;
    }
    
    public String toString() {
        StringBuffer buf = new StringBuffer(super.toString());
        buf.append(" id=").append(getId());
        return buf.toString();
    }
    
    public boolean isSubscribed() {
        return nrofsubscriptions.get()>0;
    }
    
    protected synchronized boolean addCometEvent(CometEvent event) {
        boolean result = false;
        if (!events.contains(event)) {
            events.add(event);
            result = true;
        }
        event.getHttpServletRequest().setAttribute(COMET_EVENT_ATTR,this);
        return result;
    }
    
    protected synchronized boolean removeCometEvent(CometEvent event) {
        boolean result = events.remove(event);
        event.getHttpServletRequest().removeAttribute(COMET_EVENT_ATTR);
        return result;
    }
    
    
    protected void subscribed(ChannelImpl ch) {
        nrofsubscriptions.addAndGet(1);
    }
    
    protected void unsubscribed(ChannelImpl ch) {
        nrofsubscriptions.addAndGet(-1);
    }
    
    public void startBatch(){
        //noop until improved
    }
    public void endBatch() {
        //noop until improved
    }
        
    private int code;
    private String status;
    private Throwable cause;
    public HttpError(int code, String status, Throwable cause) {
        this.code = code;
        this.status = status;
        this.cause = cause;
    }
    public void setCode(int code) {
        this.code = code;
    }
    public void setStatus(String status) {
        this.status = status;
    }
    public void setCause(Throwable exception) {
        this.cause = exception;
    }
    public int getCode() {
        return code;
    }
    public String getStatus() {
        return status;
    }
    public Throwable getCause() {
        return cause;
    }
    public String toString() {
        if (cause != null)
            return code + ":" + status + " - [" + cause + "]";
        else
            return code + ":" + status;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    
    protected Channel channel;
    protected Client client;
    protected String id;
    private long TTL = 1000*60*5; //5min is the default TTL for a message
    protected long creationTime = System.currentTimeMillis();
    public Object clone() {
        MessageImpl copy = new MessageImpl(id);
        copy.putAll(this);
        copy.channel = channel;
        copy.client = client;
        copy.id = id;
        copy.creationTime = creationTime;
        copy.TTL = TTL;
        return copy;
    }
    protected MessageImpl(String id) {
        assert id != null;
        this.id = id;
    }
    public Channel getChannel() {
        return channel;
    }
    public Client getClient() {
        return client;
    }
    public long getCreationTime() {
        return creationTime;
    }
    public long getTTL() {
        return TTL;
    }
    public String getId() {
        return id;
    }
    protected void setChannel(Channel channel) {
        this.channel = channel;
    }
    protected void setClient(Client client) {
        this.client = client;
    }
    public void setTTL(long TTL) {
        this.TTL = TTL;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Common functionality and member variables for all Bayeux requests.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 0.9
 *
 */
    
    protected static final SimpleDateFormat timestampFmt =
        new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
    static {
        timestampFmt.setTimeZone(TimeZone.getTimeZone("GMT"));
    }
    //message properties, combined for all messages
    protected TomcatBayeux tomcatBayeux;
    protected String channel;
    protected String id;
    protected String clientId;
    protected String version = null;
    protected String[] suppConnTypes = null;
    protected int suppConnTypesFlag = 0;
    protected int desiredConnTypeFlag = 0;
    protected String minVersion = null;
    protected String subscription = null;
    protected String data = null;
    protected String conType = null;
    protected LinkedHashMap<String, Object> ext = new LinkedHashMap<String, Object> ();
    
    protected CometEvent event;
    
    protected HashMap<String, Object> response = null;
    
    protected static Log log = LogFactory.getLog(RequestBase.class);
    
    protected int reconnectInterval;
    
    protected RequestBase(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        this.tomcatBayeux = tb;
        this.event = event;
        channel = jsReq.optString(Bayeux.CHANNEL_FIELD);
        id = jsReq.optString(Bayeux.ID_FIELD);
        clientId = jsReq.optString(Bayeux.CLIENT_FIELD);
        version = jsReq.optString(Bayeux.VERSION_FIELD);
        minVersion = jsReq.optString(Bayeux.MIN_VERSION_FIELD);
        conType = jsReq.optString(Bayeux.CONNECTION_TYPE_FIELD);
        subscription = jsReq.optString(Bayeux.SUBSCRIPTION_FIELD);
        data = jsReq.optString(Bayeux.DATA_FIELD);
        reconnectInterval = tb.getReconnectInterval();
        if (jsReq.has(Bayeux.EXT_FIELD)) {
            JSONObject jext = jsReq.getJSONObject(Bayeux.EXT_FIELD);
            for (Iterator<String> i = jext.keys(); i.hasNext(); ) {
                String key = i.next();
                ext.put(key, jext.get(key));
            }//for
        }//end if
        
        if (jsReq.has(Bayeux.SUPP_CONNECTION_TYPE_FIELD)) {
            JSONArray types = jsReq.getJSONArray(Bayeux.SUPP_CONNECTION_TYPE_FIELD);
            suppConnTypes = new String[types.length()];
            for (int i = 0; i < types.length(); i++) {
                suppConnTypes[i] = types.getString(i);
                if (Bayeux.TRANSPORT_CALLBACK_POLL.equals(suppConnTypes[i]))
                    suppConnTypesFlag = suppConnTypesFlag|ClientImpl.SUPPORT_CALLBACK_POLL;
                else if (Bayeux.TRANSPORT_LONG_POLL.equals(suppConnTypes[i]))
                    suppConnTypesFlag = suppConnTypesFlag|ClientImpl.SUPPORT_LONG_POLL;
            }//for
        }//end if
        if (conType!=null) {
            if (Bayeux.TRANSPORT_CALLBACK_POLL.equals(conType))
                desiredConnTypeFlag = ClientImpl.SUPPORT_CALLBACK_POLL;
            else if (Bayeux.TRANSPORT_LONG_POLL.equals(conType))
                desiredConnTypeFlag = ClientImpl.SUPPORT_LONG_POLL;
        }//end if
        
        //due to the fact that the javascript doesn't send up a required field
        //we have to fake it
        suppConnTypesFlag = ClientImpl.SUPPORT_CALLBACK_POLL | ClientImpl.SUPPORT_LONG_POLL;
    }
    public HttpError validate() {
        HttpError result = null;
        return result;
    }
    public TomcatBayeux getTomcatBayeux() {
        return tomcatBayeux;
    }
    public String getChannel() {
        return channel;
    }
    public String getId() {
        return id;
    }
    public String getClientId() {
        return clientId;
    }
    public LinkedHashMap getExt() {
        return ext;
    }
    public CometEvent getEvent() {
        return event;
    }
    
    protected static void deliver(CometEvent event, ClientImpl to) throws IOException, ServletException, BayeuxException {
        JSONArray jarray = getJSONArray(event,true);
        if ( jarray == null ) throw new BayeuxException("No message to send!");
        String jsonstring = jarray.toString();
        if (log.isDebugEnabled()) {
            log.debug("["+Thread.currentThread().getName()+"] Delivering message to[" + to + "] message:" + jsonstring);
        }
        PrintWriter out = event.getHttpServletResponse().getWriter();
        if (to==null) {
            //do nothing
        }else if ( (to.getDesirectConnType() == 0 && to.supportsLongPoll()) || to.getDesirectConnType() == ClientImpl.SUPPORT_LONG_POLL) {
            if (to.useJsonFiltered())
                out.print("/*");
        } else if ( (to.getDesirectConnType() == 0 && to.supportsCallbackPoll()) || to.getDesirectConnType() == ClientImpl.SUPPORT_CALLBACK_POLL) {
            String jsonp = event.getHttpServletRequest().getParameter(Bayeux.JSONP_PARAMETER);
            if (jsonp == null)
                jsonp = Bayeux.JSONP_DEFAULT_NAME;
            out.print(jsonp);
            out.print('(');
        } else {
            throw new BayeuxException("Client doesn't support any appropriate connection type.");
        }
        out.print(jsonstring);
        if ( to == null ) {
            //do nothing
        } else if ( (to.getDesirectConnType() == 0 && to.supportsLongPoll()) || to.getDesirectConnType() == ClientImpl.SUPPORT_LONG_POLL) {
            if (to.useJsonFiltered())
                out.print("*/");
        } else if ( (to.getDesirectConnType() == 0 && to.supportsCallbackPoll()) || to.getDesirectConnType() == ClientImpl.SUPPORT_CALLBACK_POLL) {
            out.print(");");
        } 
        out.flush();
        event.getHttpServletResponse().flushBuffer();
        
    }
    protected static JSONArray getJSONArray(CometEvent event, boolean nullok) {
        synchronized(event) {
            JSONArray jarray = (JSONArray) event.getHttpServletRequest().getAttribute(JSON_MSG_ARRAY);
            if (jarray == null && (!nullok)) {
                jarray = new JSONArray();
                event.getHttpServletRequest().setAttribute(JSON_MSG_ARRAY, jarray);
            }
            return jarray;
        }
    }
    protected JSONArray getJSONArray() {
        return getJSONArray(event,false);
    }
    protected void addToDeliveryQueue(ClientImpl to, JSONObject msg) throws IOException, ServletException, BayeuxException {
        synchronized (event) {
            getJSONArray().put(msg);
        }
    }
    
    protected void flushMessages(ClientImpl client) throws BayeuxException {
        List<Message> msgs = client.takeMessages();
        synchronized (event) {
            try {
                for (Iterator<Message> it = msgs.iterator(); it.hasNext(); ){
                    MessageImpl msg = (MessageImpl)it.next();
                    Map map = new HashMap();
                    map.put(Bayeux.CHANNEL_FIELD,msg.getChannel().getId());
                    if (msg.getClient()!=null) map.put(Bayeux.CLIENT_FIELD,msg.getClient().getId());
                    map.put(Bayeux.DATA_FIELD,msg);
                    JSONObject obj = new JSONObject(map);
                    addToDeliveryQueue(client, obj);
                }
            } catch (ServletException x) {
                throw new BayeuxException(x);
            } catch (IOException x) {
                throw new BayeuxException(x);
            }
        }
    }
    
    public int process(int prevops) throws BayeuxException {
        event.getHttpServletRequest().setAttribute(CURRENT_REQ_ATTR,this);
        return prevops;
    }
    
    public int getReconnectInterval() {
        return reconnectInterval;
    }
    public String getTimeStamp() {
        return timestampFmt.format(new Date(System.currentTimeMillis()));
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    public static BayeuxRequest getRequest(TomcatBayeux tomcatBayeux, CometEvent event, JSONObject msg) throws JSONException {
        String channel = msg.optString(Bayeux.CHANNEL_FIELD);
        if (Bayeux.META_HANDSHAKE.equals(channel)) {
            return new MetaHandshakeRequest(tomcatBayeux,event,msg);
        }else if (Bayeux.META_CONNECT.equals(channel)) {
            return new MetaConnectRequest(tomcatBayeux,event,msg);
        }else if (Bayeux.META_DISCONNECT.equals(channel)) {
            return new MetaDisconnectRequest(tomcatBayeux,event,msg);
        }else if (Bayeux.META_SUBSCRIBE.equals(channel)) {
            return new MetaSubscribeRequest(tomcatBayeux,event,msg);
        }else if (Bayeux.META_UNSUBSCRIBE.equals(channel)) {
            return new MetaUnsubscribeRequest(tomcatBayeux,event,msg);
        } else {
            return new PublishRequest(tomcatBayeux,event,msg);
        }
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * 
 * @author Filip Hanik
 * @version 1.0
 */
    
    protected int reconnectInterval = 5000;
    /**
     * a list of all active clients
     */
    protected HashMap<String,Client> clients = new HashMap<String,Client>();
    
    /**
     * a list of all active channels
     */
    protected LinkedHashMap<String, Channel> channels = new LinkedHashMap<String,Channel>();
    
    /**
     * security policy to be used.
     */
    protected SecurityPolicy securityPolicy = null;
    /**
     * default client to use when we need to send an error message but don't have a client valid reference
     */
    protected static ClientImpl errorClient = new ClientImpl("error-no-client",false);
    
    /**
     * returns the default error client
     * @return ClientImpl
     */
    public static ClientImpl getErrorClient() {
        return errorClient;
    }
    
    protected TomcatBayeux() {
    }
    
    /**
     * should be invoked when the servlet is destroyed or when the context shuts down
     */
    public void destroy() {
        throw new UnsupportedOperationException("TomcatBayeux.destroy() not yet implemented");
    }
    public Channel getChannel(String channelId, boolean create) {
        Channel result = channels.get(channelId);
        if (result==null && create) {
            result = new ChannelImpl(channelId);
            channels.put(channelId,result);
        }
        return result;
    }
    
    public Channel remove(Channel channel) {
        return channels.remove(channel.getId());
    }
    
    public Client remove(Client client) {
        if (client==null) return null;
        for (Channel ch : getChannels()) {
            ch.unsubscribe(client);
        }
        return clients.remove(client.getId());
    }
    public Client getClient(String clientId) {
        return clients.get(clientId);
    }
    
    public boolean hasClient(String clientId) {
        return clients.containsKey(clientId);
    }
    
    public List<Client> getClients() {
        return java.util.Arrays.asList(clients.entrySet().toArray(new Client[0]));
    }
    public SecurityPolicy getSecurityPolicy() {
        return securityPolicy;
    }
    public int getReconnectInterval() { 
        return reconnectInterval;
    }
    public boolean hasChannel(String channel) {
        return channels.containsKey(channel);
    }
    public Client newClient(String idprefix, Listener listener, boolean local, CometEvent event) {
        String id = createUUID(idprefix);
        ClientImpl client = new ClientImpl(id, local);
        client.setListener(listener);
        clients.put(id, client);
        return client;
    }
    public Client newClient(String idprefix, Listener listener) {
        assert listener!=null;
        //if this method gets called, someone is using the API inside
        //the JVM, this is a local client
        return newClient(idprefix,listener,true, null);
    }
    
    protected ClientImpl getClientImpl(CometEvent event) {
        return (ClientImpl)event.getHttpServletRequest().getAttribute(ClientImpl.COMET_EVENT_ATTR);
    }
    
    protected void remove(CometEvent event) {
        ClientImpl client = getClientImpl(event);
        if (client!=null) {
            client.removeCometEvent(event);
        }
    }
    public String createUUID(String idprefix) {
        if (idprefix==null) idprefix="";
        return idprefix + Arrays.toString(UUIDGenerator.randomUUID(false));
    }
    
    public List<Channel> getChannels() {
        return java.util.Arrays.asList(channels.entrySet().toArray(new Channel[0]));
    }
    protected Message newMessage() {
        String id = createUUID("msg-");
        return new MessageImpl(id);
    }
    public Message newMessage(Client from) {
        MessageImpl msg = (MessageImpl)newMessage();
        msg.setClient(from);
        return msg;
    }
    public void setSecurityPolicy(SecurityPolicy securityPolicy) {
        this.securityPolicy = securityPolicy;
    }
    public void setReconnectInterval(int reconnectTimeout) {
        this.reconnectInterval = reconnectTimeout;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_CONNECT);
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaConnectRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
        if (clientId!=null && getTomcatBayeux().hasClient(clientId)) {
            event.getHttpServletRequest().setAttribute("client",getTomcatBayeux().getClient(clientId));
        }
    }
    /**
     * Check client request for validity.
     *
     * Per section 4.2.1 of the Bayuex spec a connect request must contain:
     *  1) The "/meta/connect" channel identifier.
     *  2) The clientId returned by the server after handshake.
     *  3) The desired connectionType (must be one of the server's supported
     *     types returned by handshake response.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(clientId==null|| (!getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        if (! (Bayeux.TRANSPORT_LONG_POLL.equals(conType) || Bayeux.TRANSPORT_CALLBACK_POLL.equals(conType)))
            return new HttpError(400,"Unsupported connection type.",null);
        return null;//no error
    }
    /**
     * Transition to connected state, flushing pending messages if
     * available.  If there are pending subscriptions and no messages to
     * flush then the connection is held until there is a pending publish
     * event to be delivered to this client (Section 4.2.2 of spec).
     */
    public int process(int prevops) throws BayeuxException {
        prevops = super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = (ClientImpl)getTomcatBayeux().getClient(clientId);
        boolean success = false;
        HttpError error = validate();
        if (error == null) {
            client.setDesirectConnType(desiredConnTypeFlag);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.RETRY_RESPONSE);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.INTERVAL_FIELD, getReconnectInterval());
            success = true;
        }else {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.HANDSHAKE_RESPONSE);
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        response.put(Bayeux.TIMESTAMP_FIELD,getTimeStamp());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        
        //return immediately if there is no subscriptions
        //so that we can process the next message
        int result = client.isSubscribed()?1:0; 
        if (success && client!=null && client.hasMessages()) {
            //send out messages 
            flushMessages(client);
            result = 0; //flush out the messages
        }
        return result;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_DISCONNECT);
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaDisconnectRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
    }
    /**
     * Check client request for validity.
     *
     * Per section 4.4.1 of the Bayuex spec a connect request must contain:
     *  1) The "/meta/disconnect" channel identifier.
     *  2) The clientId.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(clientId==null|| (!this.getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        return null;//no error
    }
    /**
     * Disconnect a client session.
     */
    public int process(int prevops) throws BayeuxException {
        prevops = super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = (ClientImpl)getTomcatBayeux().getClient(clientId);
        HttpError error = validate();
        if (error == null) {
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "retry");
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("interval", getReconnectInterval());
        }else {
            getTomcatBayeux().remove(client);
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "none");
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        return 0;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_HANDSHAKE);
        responseTemplate.put(Bayeux.VERSION_FIELD,"1.0");
        responseTemplate.put(Bayeux.SUPP_CONNECTION_TYPE_FIELD,new String[] { Bayeux.TRANSPORT_LONG_POLL, Bayeux.TRANSPORT_CALLBACK_POLL });
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaHandshakeRequest(TomcatBayeux tomcatBayeux, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tomcatBayeux, event, jsReq);
    }
    
    public String getVersion() { return version; }
    public String getMinimumVersion() { return minVersion; }
    /**
     * Check client request for validity.
     *
     * Per section 4.1.1 of the Bayuex spec a handshake request must contain:
     *  1) The "/meta/handshake" channel identifier.
     *  2) The version of the protocol supported by the client
     *  3) The client's supported connection types.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        boolean error = (version==null || version.length()==0);
        if (!error) error = suppConnTypesFlag==0;
        if (error) return new HttpError(400,"Invalid handshake request, supportedConnectionType field missing.",null);
        else return null;
    }
    /**
     * Generate and return a client identifier.  Return a list of
     * supported connection types.  Must be a subset of or identical to
     * the list of types supported by the client.  See section 4.1.2 of
     * the Bayuex specification.
     */
    public int process(int prevops) throws BayeuxException {
        prevops = super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = null;
        HttpError error = validate();
        if (error == null) {
            client = (ClientImpl) getTomcatBayeux().newClient("http-", null, false,getEvent());
            clientId = client.getId();
            client.setSupportedConnTypes(suppConnTypesFlag);
            client.setUseJsonFiltered(getExt().get(Bayeux.JSON_COMMENT_FILTERED_FIELD) != null);
            response.put(Bayeux.CLIENT_FIELD, client.getId());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.RETRY_RESPONSE);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.INTERVAL_FIELD, getReconnectInterval());
        }else {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            client = TomcatBayeux.getErrorClient();
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.NONE_RESPONSE);
        }
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        return 0;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_SUBSCRIBE);
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaSubscribeRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
    }
    /**
     * Check client request for validity.
     *
     * Per section 4.5.1 of the Bayuex spec a connect request must contain:
     *  1) The "/meta/subscribe" channel identifier.
     *  2) The clientId.
     *  3) The subscription.  This is the name of the channel of interest,
     *     or a pattern.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(clientId==null|| (!this.getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        if (subscription==null||subscription.length()==0)
            return new HttpError(400,"Subscription missing.",null);
        return null;//no error
    }
    /**
     * Register interest for one or more channels.  Per section 2.2.1 of the
     * Bayeux spec, a pattern may be specified.  Assign client to matching
     * channels and inverse client to channel reference.
     */
    public int process(int prevops) throws BayeuxException {
        prevops = super.process(prevops);
        response = (HashMap<String, Object>)this.responseTemplate.clone();
        ClientImpl client = (ClientImpl)getTomcatBayeux().getClient(clientId);
        HttpError error = validate();
        if (error == null) {
            boolean wildcard = subscription.indexOf('*')!=-1;
            boolean subscribed = false;
            if (wildcard) {
                List<Channel> channels = getTomcatBayeux().getChannels();
                Iterator<Channel> it = channels.iterator();
                while (it.hasNext()) {
                    ChannelImpl ch = (ChannelImpl)it.next();
                    if (ch.matches(subscription)) {
                        ch.subscribe(client);
                        subscribed = true;
                    }
                }
            }else {
                ChannelImpl ch = (ChannelImpl)getTomcatBayeux().getChannel(subscription,true);
                ch.subscribe(client);
                subscribed = true;
            }
            response.put(Bayeux.SUCCESSFUL_FIELD, Boolean.valueOf(subscribed));
            response.put(Bayeux.SUBSCRIPTION_FIELD,subscription);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "retry");
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("interval", getReconnectInterval());
        }else {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "handshake");
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        response.put(Bayeux.TIMESTAMP_FIELD,getTimeStamp());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        return 0;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.CHANNEL_FIELD,Bayeux.META_UNSUBSCRIBE);
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public MetaUnsubscribeRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
    }
    /**
     * Check client request for validity.
     *
     * Per section 4.6.1 of the Bayuex spec a connect request must contain:
     *  1) The "/meta/unsubscribe" channel identifier.
     *  2) The clientId.
     *  3) The subscription.  This is the name of the channel of interest,
     *     or a pattern.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(clientId==null|| (!this.getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        if (subscription==null||subscription.length()==0)
            return new HttpError(400,"Subscription missing.",null);
        return null;//no error
    }
    /**
     * De-register interest for one or more channels.  Per section 2.2.1 of the
     * Bayeux spec, a pattern may be specified.  Sever relationships.
     */
    public int process(int prevops) throws BayeuxException {
        prevops = super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = (ClientImpl)getTomcatBayeux().getClient(clientId);
        HttpError error = validate();
        if (error == null) {
            boolean wildcard = subscription.indexOf('*')!=-1;
            boolean unsubscribed = false;
            if (wildcard) {
                List<Channel> channels = getTomcatBayeux().getChannels();
                Iterator<Channel> it = channels.iterator();
                while (it.hasNext()) {
                    ChannelImpl ch = (ChannelImpl)it.next();
                    if (ch.matches(subscription)) {
                        ch.unsubscribe(client);
                        unsubscribed = true;
                    }
                }
            }else {
                ChannelImpl ch = (ChannelImpl)getTomcatBayeux().getChannel(subscription,true);
                ch.unsubscribe(client);
                unsubscribed = true;
            }
            response.put(Bayeux.SUCCESSFUL_FIELD, Boolean.valueOf(unsubscribed));
            response.put(Bayeux.SUBSCRIPTION_FIELD,subscription);
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "retry");
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("interval", getReconnectInterval());
        }else {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put("reconnect", "handshake");
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        response.put(Bayeux.TIMESTAMP_FIELD,getTimeStamp());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        return 0;
    }
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * Handshake request Bayeux message.
 *
 * @author Guy A. Molinari
 * @author Filip Hanik
 * @version 1.0
 *
 */
    JSONObject msgData = null;
    protected static HashMap<String,Object> responseTemplate = new HashMap<String,Object>();
    static {
        responseTemplate.put(Bayeux.SUCCESSFUL_FIELD,Boolean.TRUE);
        responseTemplate.put(Bayeux.ADVICE_FIELD, new HashMap<String, Object>());
    }
    public PublishRequest(TomcatBayeux tb, CometEvent event, JSONObject jsReq) throws JSONException {
        super(tb, event, jsReq);
    }
    /**
     * Check client request for validity.
     *
     * Per section 5.1.1 of the Bayuex spec a connect request must contain:
     *  1) The channel identifier of the channel for publication.
     *  2) The data to send.
     *  
     * @return HttpError This method returns null if no errors were found
     */
    public HttpError validate() {
        if(channel==null|| (!this.getTomcatBayeux().hasChannel(channel)))
            return new HttpError(400,"Channel Id not valid.", null);
        if(data==null || data.length()==0)
            return new HttpError(400,"Message data missing.", null);
        try {
            this.msgData = new JSONObject(data);
        }catch (JSONException x) {
            return new HttpError(400,"Invalid JSON object in data attribute.",x);
        }
        if(clientId==null|| (!this.getTomcatBayeux().hasClient(clientId)))
            return new HttpError(400,"Client Id not valid.", null);
        return null;//no error
    }
    /**
     *  Send the event message to all registered subscribers.
     */
    public int process(int prevops) throws BayeuxException {
        prevops = super.process(prevops);
        response = (HashMap<String, Object>)responseTemplate.clone();
        ClientImpl client = clientId!=null?(ClientImpl)getTomcatBayeux().getClient(clientId):
                                           (ClientImpl)event.getHttpServletRequest().getAttribute("client");
        boolean success = false;
        HttpError error = validate();
        if (error == null) {
            ChannelImpl chimpl = (ChannelImpl)getTomcatBayeux().getChannel(channel,false);
            MessageImpl mimpl = (MessageImpl)getTomcatBayeux().newMessage(client);
            
            try {
                String[] keys = JSONObject.getNames(msgData);
                for (int i = 0; i < keys.length; i++) {
                    mimpl.put(keys[i], msgData.get(keys[i]));
                }
                success = true;
                ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.RETRY_RESPONSE);
                ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.INTERVAL_FIELD, getReconnectInterval());
            }catch (JSONException x) {
                if (log.isErrorEnabled()) log.error("Unable to parse:"+msgData,x);
                throw new BayeuxException(x);
            }
            chimpl.publish(mimpl);
        }
        if(!success) {
            response.put(Bayeux.SUCCESSFUL_FIELD,Boolean.FALSE);
            response.put(Bayeux.ERROR_FIELD, error.toString());
            ((HashMap) response.get(Bayeux.ADVICE_FIELD)).put(Bayeux.RECONNECT_FIELD, Bayeux.HANDSHAKE_RESPONSE);
            if (client==null) client = TomcatBayeux.getErrorClient();
        }
        response.put(Bayeux.CHANNEL_FIELD,channel);
        response.put(Bayeux.CLIENT_FIELD, client.getId());
        try {
            JSONObject obj = new JSONObject(response);
            addToDeliveryQueue(client, obj);
        } catch (ServletException x) {
            throw new BayeuxException(x);
        } catch (IOException x) {
            throw new BayeuxException(x);
        }
        
        if (success && client!=null && client.hasMessages()) {
            //send out messages 
            flushMessages(client);
        }
        return 0;
    }
    
    static AtomicInteger counter = new AtomicInteger(0);
    protected int id;
    protected Bayeux b;
    protected Client c;
    protected boolean alive = true;
    protected TimestampThread tt = new TimestampThread();
    public EchoChatClient() {
        id = counter.incrementAndGet();
        System.out.println("new listener created with id:"+id);
    }
    /**
     * contextDestroyed
     *
     * @param servletContextEvent ServletContextEvent
     * @todo Implement this javax.servlet.ServletContextListener method
     */
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        alive = false;
        tt.interrupt();
    }
    /**
     * contextInitialized
     *
     * @param servletContextEvent ServletContextEvent
     * @todo Implement this javax.servlet.ServletContextListener method
     */
    public void contextInitialized(ServletContextEvent servletContextEvent) {
    }
    public void attributeAdded(ServletContextAttributeEvent scae) {
        if (scae.getName().equals(Bayeux.DOJOX_COMETD_BAYEUX)) {
            b = (Bayeux)scae.getValue();
            c = b.newClient("echochat-",this);
            Channel ch = b.getChannel("/chat/demo",true);
            ch.subscribe(c);
            tt.start();
        }
    }
    public void attributeRemoved(ServletContextAttributeEvent servletContextAttributeEvent) {
    }
    public void attributeReplaced(ServletContextAttributeEvent servletContextAttributeEvent) {
    }
    public void removed(boolean timeout) {
        System.out.println("Client removed.");
    }
    public void deliver(Message[] msgs) {
        for (int i=0; msgs!=null && i<msgs.length; i++) {
            Message msg = msgs[i];
            System.out.println("[echochatclient ]received message:" + msg);
            Message m = b.newMessage(c);
            m.putAll(msg);
            //echo the same message
            m.put("user", "echochatserver");
            if (m.containsKey("msg")) {
                //simple chat demo
                String chat = (String) m.get("msg");
                m.put("msg", "echochatserver|I received your message-" + chat.substring(chat.indexOf("|") + 1));
            }
            System.out.println("[echochatclient ]sending message:" + m);
            msg.getChannel().publish(m);
        }
    }
    public class TimestampThread extends Thread {
        public TimestampThread() {
            setDaemon(true);
        }
        
        public void run() {
            while (alive) {
                try {
                    sleep(5000);
                    Channel ch = b.getChannel("/chat/demo",false);
                    if (ch.getSubscribers().size()<=1) {
                        continue;
                    }
                    Message m = b.newMessage(c);
                    m.put("user","echochatserver");
                    m.put("chat","Time is:"+new java.sql.Date(System.currentTimeMillis()).toLocaleString());
                    m.put("join",false);
                    ch.publish(m);
                }catch (InterruptedException ignore) {
                    
                }catch (Exception x) {
                    x.printStackTrace();
                }
            }
        }
    }
  { 
    "channels": "/**",
    "filter"  : "org.mortbay.cometd.filter.NoMarkupFilter",
    "init"    : {}
  },
  { 
    "channels": "/chat/*",
    "filter"   : "org.mortbay.cometd.filter.RegexFilter",
    "init"    : [ 
  },
  
  { 
    "channels": "/chat/**",
    "filter"   : "org.mortbay.cometd.filter.RegexFilter",
    "init"    : [ 
  }
  
  
   xmlns="http://java.sun.com/xml/ns/javaee" 
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
   version="2.5"> 
  <display-name>Cometd Test WebApp</display-name>
  
  <servlet>
    <servlet-name>cometd</servlet-name>
    <servlet-class>org.apache.tomcat.bayeux.BayeuxServlet</servlet-class>
    <init-param>
      <param-name>timeout</param-name>
      <param-value>120000000</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>cometd</servlet-name>
    <url-pattern>/cometd/*</url-pattern>
  </servlet-mapping>
  
  border: 0px solid black; 
  background-color: #e0e0e0;
  border: 1px solid black; 
  width: 45em;
  height: 20ex;
  overflow: auto; 
  background-color: #f0f0f0;
  padding: 4px;
  border: 0px solid black; 
  clear: both;
  padding: 4px;
  border: 0px solid black; 
  border-top: 1px solid black; 
  width:28em;
  background-color: #e0f0f0;
  width:14em;
  background-color: #e0f0f0;
  display: none;
  font-weight: bold;
  font-style: italic;
    _last: "",
    _username: null,
    _connected: true,
    join: function(name){
        
        if(name == null || name.length==0 ){
            alert('Please enter a username!');
        }else{
            dojox.cometd.init(new String(document.location).replace(/http:\/\/[^\/]*/,'').replace(/\/examples\/.*$/,'')+"/cometd");
            // dojox.cometd.init("http://127.0.0.2:8080/cometd");
            this._connected=true;
            this._username=name;
            dojo.byId('join').className='hidden';
            dojo.byId('joined').className='';
            dojo.byId('phrase').focus();
            // subscribe and join
            dojox.cometd.subscribe("/chat/demo", room, "_chat");
            dojox.cometd.publish("/chat/demo", { user: room._username, join: true, chat : room._username+" has joined"});
            // handle cometd failures while in the room
            room._meta=dojo.subscribe("/cometd/meta",dojo.hitch(this,function(event){
                console.debug(event);   
                if (event.action=="handshake"){
                    dojox.cometd.subscribe("/chat/demo", room, "_chat");
                } else if (event.action=="connect") {
                        room._chat({data:{leave:true,user:"SERVER",chat:"reconnected!"}});
                        room._chat({data:{leave:true,user:"SERVER",chat:"disconnected!"}});
            }));
        }
    },
    leave: function(){
        if (room._username==null)
            return;
            dojo.unsubscribe(room._meta);
        dojox.cometd.unsubscribe("/chat/demo", room, "_chat");
        dojox.cometd.publish("/chat/demo", { user: room._username, leave: true, chat : room._username+" has left"});
        // switch the input form
        dojo.byId('join').className='';
        dojo.byId('joined').className='hidden';
        dojo.byId('username').focus();
        room._username=null;
        dojox.cometd.disconnect();
    },
      
    chat: function(text){
        if(!text || !text.length){ return false; }
        dojox.cometd.publish("/chat/demo", { user: room._username, chat: text});
    },
    _chat: function(message){
        var chat=dojo.byId('chat');
        if(!message.data){
            alert("bad message format "+message);
            return;
        }
        var from=message.data.user;
        var special=message.data.join || message.data.leave;
        var text=message.data.chat;
        if(!text){ return; }
        if( !special && from == room._last ){
            from="...";
        }else{
            room._last=from;
            from+=":";
        }
        if(special){
            chat.innerHTML += "<span class=\"alert\"><span class=\"from\">"+from+"&nbsp;</span><span class=\"text\">"+text+"</span></span><br/>";
            room._last="";
        }else{
            chat.innerHTML += "<span class=\"from\">"+from+"&nbsp;</span><span class=\"text\">"+text+"</span><br/>";
        } 
        chat.scrollTop = chat.scrollHeight - chat.clientHeight;    
    },
  
  _init: function(){
        dojo.byId('join').className='';
        dojo.byId('joined').className='hidden';
        dojo.byId('username').focus();
        var element=dojo.byId('username');
        element.setAttribute("autocomplete","OFF"); 
        dojo.connect(element, "onkeyup", function(e){   
            if(e.keyCode == dojo.keys.ENTER){
                room.join(dojo.byId('username').value);
                return false;
            }
            return true;
  
        dojo.connect(dojo.byId('joinB'), "onclick", function(e){
            room.join(dojo.byId('username').value);
            e.preventDefault();
  
        element=dojo.byId('phrase');
        element.setAttribute("autocomplete","OFF");
        dojo.connect(element, "onkeyup", function(e){   
            if(e.keyCode == dojo.keys.ENTER){
                room.chat(dojo.byId('phrase').value);
                dojo.byId('phrase').value='';
                e.preventDefault();
            }
  
            dojo.byId('phrase').value='';
    } 
    <title>Cometd chat</title>
    <script type="text/javascript" src="../dojo/dojo/dojo.js"></script>
    <script type="text/javascript" src="../dojo/dojox/cometd.js.uncompressed.js"></script>
    <script type="text/javascript" src="chat.js"></script>
    <link rel="stylesheet" type="text/css" href="chat.css">
 <div id="chat"></div>
 <div id="input">
   <div id="join" >
     Username:&nbsp;<input id="username" type="text"/><input id="joinB" class="button" type="submit" name="join" value="Join"/>
   </div>
   <div id="joined" class="hidden">
     Chat:&nbsp;<input id="phrase" type="text"/>
     <input id="sendB" class="button" type="submit" name="join" value="Send"/>
     <input id="leaveB" class="button" type="submit" name="join" value="Leave"/>
   </div>
  </div>
 </div>
 * loader.js - A bootstrap module.  Runs before the hostenv_*.js file. Contains
 * all of the package loading methods.
 */
 	} // Function
 * loader.js - A bootstrap module.  Runs before the hostenv_*.js file. Contains
 * all of the package loading methods.
 */
    var depRegExp = /dojo.(require|requireIf|provide|requireAfterIf|platformRequire|requireLocalization)\(([\w\W]*?)\)/mg;
    var match;
    //summary: Figure out whether the path is local or x-domain
    
    return false;     
    this._isXDomain |= currentIsXDomain;
        // check whether the relpath is an absolute URL itself. If so, we 
        // ignore baseUrl
    	var colonIndex = relpath.indexOf(":");
    	var slashIndex = relpath.indexOf("/");
        if(colonIndex > 0 && colonIndex < slashIndex){ 
    	}
    }
 	var bundleResource = [moduleName, "nls", bundleName].join(".");
 	var bundleResource = dojo.getObject([moduleName, "nls", bundleName].join("."));
    // summary: loads a bundle intelligently based on whether the module is 
    // local or xd. Overrides the local-case implementation.
    
    var modulePath = this.moduleUrl(moduleName).toString();
    if (this._xdIsXDomainPath(modulePath)) {
        // call cross-domain loader
        return dojo.xdRequireLocalization.apply(dojo, arguments);
    } else {
        // call local-loader
        return dojo._xdRealRequireLocalization.apply(dojo, arguments);
    }
 			d.isSafari = parseFloat(dav.split("Version/")[1]) || 2;
 	} // Function
 	var bundlePackage = [moduleName, "nls", bundleName].join(".");
 * this file defines Comet protocol client. Actual message transport is
 * deferred to one of several connection type implementations. The default is a
 * long-polling implementation. A single global object named "dojox.cometd" is
 * used to mediate for these connection types in order to provide a stable
 * interface.
 *
 * extensions modules may be loaded (eg "dojox.cometd.timestamp", that use
 * the cometd._extendInList and cometd._extendOutList fields to provide functions
 * that extend and handling incoming and outgoing messages.
 */
 	this.DISCONNECTED="DISCONNECTED";	// _initialized==false 	&& _connected==false
 	this.CONNECTING="CONNECTING";		// _initialized==true	&& _connected==false (handshake sent)
 	this.CONNECTED="CONNECTED";		// _initialized==true	&& _connected==true (first successful connect)
 	this.DISCONNECTING="DISCONNECING";	// _initialized==false 	&& _connected==true (disconnect sent)
 	
 		}else if(this._cometd._connected){
 * this file defines Comet protocol client. Actual message transport is
 * deferred to one of several connection type implementations. The default is a
 * long-polling implementation. A single global object named "dojox.cometd" is
 * used to mediate for these connection types in order to provide a stable
 * interface.
 *
 * extensions modules may be loaded (eg "dojox.cometd.timestamp", that use
 * the cometd._extendInList and cometd._extendOutList fields to provide functions
 * that extend and handling incoming and outgoing messages.
 */
 	this.DISCONNECTED="DISCONNECTED";	// _initialized==false 	&& _connected==false
 	this.CONNECTING="CONNECTING";		// _initialized==true	&& _connected==false (handshake sent)
 	this.CONNECTED="CONNECTED";		// _initialized==true	&& _connected==true (first successful connect)
 	this.DISCONNECTING="DISCONNECING";	// _initialized==false 	&& _connected==true (disconnect sent)
 	
 		}else if(this._cometd._connected){
        this._session=null;
        this._in=function(msg){
                var channel=msg.channel;
                if (channel=="/service/ext/session"){
                        this._session=msg.data;
                }
                return msg;
        }
        this._out=function(msg){
                var channel=msg.channel;
                if (channel=="/meta/handshake" && this._session!=null){
                        if (!msg.ext)
                                msg.ext={};
                        msg.ext.session=this._session;
                }
                return msg;
        }
 * this file provides the time synchronization extension to cometd.
 * Timesync allows the client and server to exchange time information on every 
 * handshake and connect message so that the client may calculate an approximate
 * offset from it's own clock epoch to that of the server.
 *
 * With each handshake or connect, the extension sends timestamps within the 
 * ext field like: {ext:{timesync:{tc:12345567890},...},...}
 * where ts is the timestamp in ms since 1970 of when the message was sent.
 *
 * A cometd server that supports timesync, should respond with and ext field
 * like: {ext:{timesync:{tc:12345567890,ts:1234567900,p:123},...},...}
 * where ts is the timestamp sent by the client, te is the timestamp on the server
 * of when the message was received and p is the poll duration in ms - ie the
 * time the server took before sending the response.
 *
 * On receipt of the response, the client is able to use current time to determine
 * the total trip time, from which p is subtracted to determine an approximate
 * two way network traversal time. The assumption is made that the network is
 * symmetric for traversal time, so the offset between the two clocks is 
 * ts-tc-(now-tc-p)/2. In practise networks (and the cometd client/server software)
 * is never perfectly symmetric, so accuracy is limited by the difference, which 
 * can be 10s of milliseconds.
 *
 * In order to smooth over any transient fluctuations, the extension keeps a sliding
 * average of the offsets received. By default this is over 10 messages, but this can
 * be changed with the dojox.cometd.timesync._window element.
 */
    "http://www.w3.org/TR/html4/strict.dtd">
    <head>
        <title>Comet echo RPC</title>
        <link rel="stylesheet" type="text/css" href="chat/chat.css"></link>
        <script type="text/javascript" src="../dojo/dojo/dojo.js.uncompressed.js"></script>
        <script type="text/javascript" src="../dojo/dojox/cometd.js.uncompressed.js"></script>
        <script type="text/javascript">
            dojo.require("dojox.cometd");
            dojo.require("dojox.cometd.timestamp");
            $ = dojo.byId;
            var echoBehaviours = { 
                '#phrase': {
                    "found": function(e){
                        e.setAttribute("autocomplete","OFF");
                    },
                    "onkeyup": function(e){
                        if(e.keyCode == dojo.keys.ENTER){
                            echoRpc($('phrase').value);
                            $('phrase').value='';
                            return false;
                        }
                        return true;
                    }
                },
                '#sendB': {
                    "onclick": function(e){
                        echoRpc($('phrase').value);
                        $('phrase').value='';
                        return false;
                    }
                }
            };
            function setUp(){
              var element=dojo.byId('phrase');
              element.setAttribute("autocomplete","OFF");
              dojo.connect(element, "onkeyup", function(e){   
                        if(e.keyCode == dojo.keys.ENTER){
                            echoRpc($('phrase').value);
                            $('phrase').value='';
                            return false;
                        }
                        return true;
                    });
              element=dojo.byId('sendB');
              dojo.connect(element, "onclick", function(e){   
                        echoRpc($('phrase').value);
                        $('phrase').value='';
                        return false;
                    });
              dojox.cometd.init(new String(document.location).replace(/http:\/\/[^\/]*/,'').replace(/\/examples\/.*$/,'')+"/cometd");
              dojox.cometd.subscribe("/service/echo",echoRpcReturn);
            }
            function echoRpc(msg){
                console.debug(msg);
                dojox.cometd.publish("/service/echo", { msg: msg });
            }
            
            function echoRpcReturn(msg){
                dojo.byId("responses").innerHTML += (msg.timestamp?msg.timestamp:"")+" "+msg.channel+": "+msg.data.msg+"\n";
            }
            dojo.addOnLoad(setUp);
        </script>
    </head>
    <body>
        
        <h1>Echo test</h1>
        <p>
            Echo data to ONLY this client using RPC style messaging over
            cometd. Requires a server side component at /service/echo which echos
            responses directly to the client.
        </p>
        <div>
            Echo: <input id="phrase" type="text"></input> <input id="sendB" class="button" type="submit" name="join" value="Send"/>
        </div>
        <pre id="responses"></pre>
    </body>
  dojo.byId("message").style.visibility='hidden';
  dojox.cometd.init("/cometd/cometd");
    return str.replace(/(^\s+|\s+$)/g,'');
  dojo.byId("msgtext").value = "";
  dojo.byId("msgtext").focus();
   if (e.keyCode == 13) {
      send(trim(dojo.byId("msgtext").value));
      clear();
   }
  dojox.cometd.subscribe("/chat/demo", onMsgEvent);
  dojo.byId("login").style.visibility='hidden';
  dojo.byId("message").style.visibility='visible';
  send("Has joined the chat room");
  clear();
  dojo.byId("msgtext").onkeydown = enterKeyHandler;
  dojo.byId("myname").appendChild(document.createTextNode("-> " + dojo.byId("scrname").value + " <-"));
   // Break apart the text string into screen name and message parts.
   var str = trim(event.data.msg);
   var scrname = ""; 
   if (str.match(/^.*[|].*$/)) {
       var spl = str.split("|");
       scrname = spl[0];
       str = " - " + spl[1];
   }
   // Insert the screen name in red and the message black into the DOM
   var newP = document.createElement("p");
   var fnt1 = document.createElement("font");
   var attr1 = document.createAttribute("color");
   attr1.nodeValue = "red";
   fnt1.setAttributeNode(attr1);
   var newT = document.createTextNode(scrname);
   fnt1.appendChild(newT);
   newP.appendChild(fnt1);  
   var fnt2 = document.createElement("font");
   var attr2 = document.createAttribute("color");
   attr2.nodeValue = "black";
   fnt2.setAttributeNode(attr2);
   var newT2 = document.createTextNode(str);
   fnt2.appendChild(newT2);
   newP.appendChild(fnt2);  
   dojo.byId("dialog").appendChild(newP)
  var scrname = dojo.byId("scrname").value;
  var evt = {'data': { 'msg': trim(scrname) + '|' + msg }};
  onMsgEvent(evt);  // Echo local
  dojox.cometd.publish("/chat/demo", evt.data);
  background-color : #ffffcc;
  text-align: center;
  color : black;
  color : black;
  color : yellow;
  background-color : #ccffcc;
  padding-left : 20%;
  padding-right : 20%;
  border: none;
  margin: 0 auto;
  padding: 10px ;
  border-bottom: thin solid black;
  border-right: thin solid black;
  padding: 10px ;
  border-bottom: thin solid black;
  border-right: thin solid black;
  border-left: thin solid black;
  padding: 10px ;
  border-left: thin solid black;
  border-bottom: thin solid black;
  padding: 10px ;
  border-top: thin solid black;
  border-right: thin solid black;
  border-bottom: thin solid black;
  padding: 10px ;
  border-top: thin solid black;
  border-right: thin solid black;
  border-left: thin solid black;
  border-bottom: thin solid black;
  padding: 10px ;
  border-top: thin solid black;
  border-left: thin solid black;
  border-bottom: thin solid black;
  padding: 10px ;
  border-top: thin solid black;
  border-right: thin solid black;
  padding: 10px ;
  border-top: thin solid black;
  border-right: thin solid black;
  border-left: thin solid black;
  padding: 10px ;
  border-top: thin solid black;
  border-left: thin solid black;
    <head>
        <title>Tic Tac Toe - Cometd Example</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="stylesheet" type="text/css" href="resources/tictactoe.css">
        <script type="text/javascript" src="../dojo/dojo/dojo.js"></script>
        <script type="text/javascript" src="../dojo/dojox/cometd.js.uncompressed.js"></script>
        <script type="text/javascript">
            dojo.require("dojox.cometd");
            var X = 10;
            var O = 1;
   
            var board = new Array(9);
            var wins = new Array(8);
            var turnNum = 0;
            var winner = -1;
            var iam = 0;
            dojo.addOnLoad(function() {
                initArrays();
                dojox.cometd.init("/cometd/cometd");
                dojox.cometd.subscribe("/demo/tictactoe", onMsgEvent);
            });
            function postMe(arg) {
                var move = eval(arg);
                if (iam == 0 && this.win() != -1) {
                    dojo.byId("myrole").innerHTML = "Game is over.";
                    return;
                }
                if (iam == 0 && turnNum > 1) {
                    dojo.byId("gstatus").innerHTML = "Sorry, you will have to wait until this game ends.";
                    return;
                }
                if (iam != 0 && this.whoseTurn() != iam) {
                    dojo.byId("gstatus").innerHTML = "Not your turn.";
                    return;
                }
                if (! this.turn(move)) {
                    dojo.byId("gstatus").innerHTML = "Not a valid move try again";
                    return;
                }
                var win = this.win();
                var turn = this.whoseTurn();
                var data = { 'move': move, 'win': win, 'turn': turn, 'board': board, 'turnNum': turnNum };
                dojox.cometd.publish("/demo/tictactoe", data);
                onMsgEvent({ 'data': data});
                
            };
            function onMsgEvent(event) {
                
                var data = event.data
                for (i = 0; i < 9; i++) {
                    // 0 is blank, 10 is x, 1 is o
                    dojo.byId("img" + i).src = "resources/" + data.board[i] + ".gif";
                }
                
                var statusMsg;  
                // -1 is unfinished, 0 is tie, 1 is X win, 2 is Y win
                if (data.win == 0) {
                    statusMsg = "It's a tie!";
                } else if (data.win == 1) {
                    statusMsg = "X wins!";
                } else if (data.win == 2) {
                    statusMsg = "O wins!";
                } else if (data.win == -1 && data.turn == 10) {  
                    statusMsg = "It's X's Turn";
                } else if (data.win == -1 && data.turn == 1) {
                    statusMsg = "It's O's Turn";
                } else {
                    statusMsg = "That's odd, it shouldn't get here";
                }
                if (iam == 0) {
                    if (turnNum == 0) {
                        dojo.byId("myrole").innerHTML = "You can join the game if you'd like.";
                    } else {
                        dojo.byId("myrole").innerHTML = "You are currently a spectator.";
                    }
                } else if (iam == X) {
                    dojo.byId("myrole").innerHTML = "You are currently player 'X'.";
                } else {
                    dojo.byId("myrole").innerHTML = "You are currently player 'O'.";
                }
                
                if (data.win != -1) {
                    statusMsg = statusMsg + '<br><a href="ttt1.html">Restart the game</a>';
                }
        
                // And write the status message out here -
                dojo.byId("gstatus").innerHTML = statusMsg;
                board = data.board;
                winner = data.win;
                turnNum = data.turnNum;
            }
            //return false if cell is an invalid move
            function turn(cell) {
                if (cell < 0 || cell > 8) return false; // invalid move
                if (winner != -1) return false;
                if (iam == 0) {
                    if (iam == 0 && turnNum == 0) {
                        iam = X;
                    }
                    else {
                        iam = O;
                    }
                }
                if (board[cell] != 0) {
                    return false; // invalid move
                }
                turnNum++;
                if (turnNum % 2 == 1) { //then X
                    board[cell] = X;
                } else { // else O
                    board[cell] = O;
                }
                return true;
            }
            function whoseTurn() {
                if (turnNum == 0 || turnNum % 2 == 0 ) {
                    return X;
                } else return O;
            }
    
            function done() {
                return (turnNum > 8);
            }
            
            
            // return -1 for no win, 0 for tie, 1 for x win, 2 for o win
            function win() {
                if (winner != -1) {
                    return winner;
                }
                for (i = 0 ; i < 8; i++) {
                    var winSum = board[wins[i][0]] + board[wins[i][1]] + board[wins[i][2]];
                    if (winSum == 3) {
                        winner = 2;
                    } else if (winSum == 30) {
                        winner = 1;
                    }
                }
                if (winner == -1 && turnNum > 8) {
                    winner = 0;
                } 
                return winner;
            }
 
            function initArrays() {
                wins[0] = new Array(3);
                wins[0][0] = 0;
                wins[0][1] = 1;
                wins[0][2] = 2;
                wins[1] = new Array(3);
                wins[1][0] = 3;
                wins[1][1] = 4;
                wins[1][2] = 5;
                wins[2] = new Array(3);
                wins[2][0] = 6;
                wins[2][1] = 7;
                wins[2][2] = 8;
                wins[3] = new Array(3);
                wins[3][0] = 0;
                wins[3][1] = 3;
                wins[3][2] = 6;
                wins[4] = new Array(3);
                wins[4][0] = 1;
                wins[4][1] = 4;
                wins[4][2] = 7;
                wins[5] = new Array(3);
                wins[5][0] = 2;
                wins[5][1] = 5;
                wins[5][2] = 8;
                wins[6] = new Array(3);
                wins[6][0] = 0;
                wins[6][1] = 4;
                wins[6][2] = 8;
                wins[7] = new Array(3);
                wins[7][0] = 2;
                wins[7][1] = 4;
                wins[7][2] = 6;
                board[0] = 0;
                board[1] = 0;
                board[2] = 0;
                board[3] = 0;
                board[4] = 0;
                board[5] = 0;
                board[6] = 0;
                board[7] = 0;
                board[8] = 0;
            }
        </script>
        
    </head>
    <body>
        
        <h1>Tic Tac Toe</h1>
        <table>
            <tr>
                <td id="cell0"><img id="img0" src="resources/0.gif" 
                                    onclick=postMe("0")></td>
                <td id="cell1"><img id="img1" src="resources/0.gif" 
                                    onclick=postMe("1")></td>
                <td id="cell2"><img id="img2" src="resources/0.gif" 
                                    onclick=postMe("2")></td>
            </tr>
            <tr>
                <td id="cell3"><img id="img3" src="resources/0.gif" 
                                    onclick=postMe("3")></td>
                <td id="cell4"><img id="img4" src="resources/0.gif" 
                                    onclick=postMe("4")></td>
                <td id="cell5"><img id="img5" src="resources/0.gif" 
                                    onclick=postMe("5")></td>
            </tr>
            <tr>
                <td id="cell6"><img id="img6" src="resources/0.gif" 
                                    onclick=postMe("6")></td>
                <td id="cell7"><img id="img7" src="resources/0.gif" 
                                    onclick=postMe("7")></td>
                <td id="cell8"><img id="img8" src="resources/0.gif" 
                                    onclick=postMe("8")></td>
            </tr>      
        </table>
        <h2 id="gstatus">New game, click to start.</h2><br/>
        <h2 id="myrole"></h2>
    </body>
    "http://www.w3.org/TR/html4/strict.dtd">
    <head>
        <title>Comet echo RPC</title>
        <link rel="stylesheet" type="text/css" href="chat/chat.css"></link>
        <script type="text/javascript" src="../dojo/dojo/dojo.js.uncompressed.js"></script>
        <script type="text/javascript" src="../dojo/dojox/cometd.js.uncompressed.js"></script>
        <script type="text/javascript">
            dojo.require("dojox.cometd");
            dojo.require("dojox.cometd.timesync");
            dojox.cometd.init(new String(document.location).replace(/http:\/\/[^\/]*/,'').replace(/\/examples\/.*$/,'')+"/cometd");
            var next=0;
            var tick=function(){
            setTimeout(tick,1000);
        </script>
    </head>
    <body>
        
        <h1>TimeSync test</h1>
        <p>
            This test uses the timesync extension to calculate a timeoffset with the server.
        </p>
        <div id="time">
        </div>
    </body>
  

======= 3773ec4:"java/org/apache/catalina/util/ManifestResource.java"

            return true;

======= ccc1014:"java/org/apache/jasper/runtime/JspContextWrapper.java"


======= 6d40691:"java/org/apache/el/parser/ELParser.java"

                        jjtn000.setPrefix(t0.image);

======= 337d6a6:"java/org/apache/jasper/compiler/Compiler.java"

======= 337d6a6:"java/org/apache/jasper/compiler/JspUtil.java"

======= 337d6a6:"java/org/apache/jasper/compiler/JspUtil.java"

======= 337d6a6:"java/org/apache/jasper/compiler/Node.java"

======= 337d6a6:"java/org/apache/jasper/compiler/Node.java"

         * Sequence number for temporary variables.
         */
        private int tempSequenceNumber = 0;
        /*
======= 337d6a6:"java/org/apache/jasper/compiler/Node.java"

        
        /**
         * Generates a new temporary variable name.
         */
        public String nextTemporaryVariableName() {
            if (parentRoot == null) {
                return Constants.TEMP_VARIABLE_NAME_PREFIX + (tempSequenceNumber++);
            } else {
                return parentRoot.nextTemporaryVariableName();
            }
            
        }
======= 337d6a6:"java/org/apache/jasper/compiler/Node.java"

                temporaryVariableName = getRoot().nextTemporaryVariableName();
======= 337d6a6:"java/org/apache/jasper/compiler/TagPluginManager.java"

            return node.getRoot().nextTemporaryVariableName();

======= 6a1f316:"java/org/apache/coyote/http11/Http11AprProtocol.java"

    public void setPollerThreadCount(int pollerThreadCount) { endpoint.setPollerThreadCount(pollerThreadCount); }
    public int getPollerThreadCount() { return endpoint.getPollerThreadCount(); }
    
    public void setSendfileThreadCount(int sendfileThreadCount) { endpoint.setSendfileThreadCount(sendfileThreadCount); }
    public int getSendfileThreadCount() { return endpoint.getSendfileThreadCount(); }
    
     <fix><bug>45074</bug>Add configuration parameters in Http11AprProtocol</fix>

======= 46055c5:"java/org/apache/catalina/core/AprLifecycleListener.java"

                        log.debug(sm.getString("aprListener.sslInit"), t);
     <fix><bug>44809</bug>Improve AprLifecycleListener Error Messages</fix>

======= fea7658:"java/org/apache/tomcat/util/net/AprEndpoint.java"

        serverSock = Socket.create(Address.getInfo(inetAddress).family,
                Socket.SOCK_STREAM,

======= b266836:"java/org/apache/juli/ClassLoaderLogManager.java"

                    info = classLoaderLoggers.get(current);
                        handler = info.handlers.get(handlerName);
======= b266836:"java/org/apache/juli/ClassLoaderLogManager.java"

        return getClassLoaderInfo(classLoader).loggers.get(name);
======= b266836:"java/org/apache/juli/ClassLoaderLogManager.java"

        String prefix = this.prefix.get();
======= b266836:"java/org/apache/juli/ClassLoaderLogManager.java"

                info = classLoaderLoggers.get(current);
======= b266836:"java/org/apache/juli/ClassLoaderLogManager.java"

        ClassLoaderLogInfo info = classLoaderLoggers.get(classLoader);
======= b266836:"java/org/apache/juli/ClassLoaderLogManager.java"

            info = classLoaderLoggers.get(classLoader);
======= b266836:"java/org/apache/juli/ClassLoaderLogManager.java"

        ClassLoaderLogInfo info = classLoaderLoggers.get(classLoader);
======= b266836:"java/org/apache/juli/ClassLoaderLogManager.java"

                LogNode childNode = currentNode.children.get(nextName);

======= 816ecb8:"java/org/apache/catalina/core/StandardWrapper.java"

======= 816ecb8:"java/org/apache/catalina/core/StandardWrapper.java"

    protected AtomicInteger countAllocated = new AtomicInteger(0);
======= 816ecb8:"java/org/apache/catalina/core/StandardWrapper.java"

        return (this.countAllocated.get());
======= 816ecb8:"java/org/apache/catalina/core/StandardWrapper.java"

                                countAllocated.incrementAndGet();
======= 816ecb8:"java/org/apache/catalina/core/StandardWrapper.java"

                    countAllocated.incrementAndGet();
======= 816ecb8:"java/org/apache/catalina/core/StandardWrapper.java"

            while (countAllocated.get() >= nInstances) {
======= 816ecb8:"java/org/apache/catalina/core/StandardWrapper.java"

            countAllocated.incrementAndGet();
======= 816ecb8:"java/org/apache/catalina/core/StandardWrapper.java"

            countAllocated.decrementAndGet();
            countAllocated.decrementAndGet();
======= 816ecb8:"java/org/apache/catalina/core/StandardWrapper.java"

        if (countAllocated.get() > 0) {
            while ((nRetries < 21) && (countAllocated.get() > 0)) {
                                          countAllocated.toString()));

======= 6d78232:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

     * @param realm         Our associated JAASRealm instance
     * @param username      Username to be authenticated with
     * @param password      Password to be authenticated with
     * @param nonce         Server generated nonce
     * @param nc            Nonce count
     * @param cnonce        Client generated nonce
     * @param qop           Quality of protection aplied to the message
     * @param realmName     Realm name
     * @param md5a2         Second MD5 digest used to calculate the digest
     * @param authMethod    The authentication mehtod in use 
                               String md5a2, String authMethod) {
======= 6d78232:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

        this.authMethod = authMethod;
======= 6d78232:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

======= 6d78232:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

    /**
     * The authentication methdod to be used. If null, assume BASIC/FORM.
     */
    protected String authMethod;
======= 6d78232:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

                } else if (cb.getPrompt().equals("authMethod")) {
                    cb.setText(authMethod);
======= 6d78232:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

======= 6d78232:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        Callback callbacks[] = new Callback[9];
======= 6d78232:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        callbacks[8] = new TextInputCallback("authMethod");
======= 6d78232:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        String authMethod = null;
======= 6d78232:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

            authMethod = ((TextInputCallback) callbacks[8]).getText();
======= 6d78232:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        if (authMethod == null) {
            // BASIC or FORM
        } else if (authMethod.equals(Constants.DIGEST_METHOD)) {
        } else if (authMethod.equals(Constants.CERT_METHOD)) {
            principal = super.getPrincipal(username);
        } else {
            throw new LoginException("Unknown authentication method");
======= 6d78232:"java/org/apache/catalina/realm/JAASRealm.java"

======= 6d78232:"java/org/apache/catalina/realm/JAASRealm.java"

     * @param authMethod    The authentication scheme in use
                        nc, cnonce, qop, realmName, md5a2,
                        Constants.DIGEST_METHOD));
======= 6d78232:"java/org/apache/catalina/realm/JAASRealm.java"

        return authenticate(username,
                new JAASCallbackHandler(this, username, null, null, null, null,
                        null, null, null, Constants.CERT_METHOD));

======= c984c6a:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

======= c984c6a:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

    
    /**
     * Construct a callback handler for DIGEST authentication.
     *
     * @param realm     Our associated JAASRealm instance
     * @param username  Username to be authenticated with
     * @param password  Password to be authenticated with
     * @param nonce     Server generated nonce
     * @param nc        Nonce count
     * @param cnonce    Client generated nonce
     * @param qop       Quality of protection aplied to the message
     * @param realmName Realm name
     * @param md5a2     Second MD5 digest used to calculate the digest
     *                      MD5(Method + ":" + uri)
     */
    public JAASCallbackHandler(JAASRealm realm, String username,
                               String password, String nonce, String nc,
                               String cnonce, String qop, String realmName,
                               String md5a2) {
        this(realm, username, password);
        this.nonce = nonce;
        this.nc = nc;
        this.cnonce = cnonce;
        this.qop = qop;
        this.realmName = realmName;
        this.md5a2 = md5a2;
    }
======= c984c6a:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

    /**
     * Server generated nonce.
     */
    protected String nonce = null;
    
    /**
     * Nonce count.
     */
    protected String nc = null;
    
    /**
     * Client generated nonce.
     */
    protected String cnonce = null;
    /**
     * Quality of protection aplied to the message.
     */
    protected String qop;
    /**
     * Realm name.
     */
    protected String realmName;
    /**
     * Second MD5 digest.
     */
    protected String md5a2;
     * This implementation only recognizes {@link NameCallback},
     * {@link PasswordCallback} and {@link TextInputCallback}.
     * {@link TextInputCallback} is ued to pass the various additional
     * parameters required for DIGEST authentication. 
======= c984c6a:"java/org/apache/catalina/realm/JAASCallbackHandler.java"

            } else if (callbacks[i] instanceof TextInputCallback) {
                TextInputCallback cb = ((TextInputCallback) callbacks[i]);
                if (cb.getPrompt().equals("nonce")) {
                    cb.setText(nonce);
                } else if (cb.getPrompt().equals("nc")) {
                    cb.setText(nc);
                } else if (cb.getPrompt().equals("cnonce")) {
                    cb.setText(cnonce);
                } else if (cb.getPrompt().equals("qop")) {
                    cb.setText(qop);
                } else if (cb.getPrompt().equals("realmName")) {
                    cb.setText(realmName);
                } else if (cb.getPrompt().equals("md5a2")) {
                    cb.setText(md5a2);
                } else {
                    throw new UnsupportedCallbackException(callbacks[i]);
                }
======= c984c6a:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

======= c984c6a:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        Callback callbacks[] = new Callback[8];
        callbacks[2] = new TextInputCallback("nonce");
        callbacks[3] = new TextInputCallback("nc");
        callbacks[4] = new TextInputCallback("cnonce");
        callbacks[5] = new TextInputCallback("qop");
        callbacks[6] = new TextInputCallback("realmName");
        callbacks[7] = new TextInputCallback("md5a2");
        String nonce = null;
        String nc = null;
        String cnonce = null;
        String qop = null;
        String realmName = null;
        String md5a2 = null;
            nonce = ((TextInputCallback) callbacks[2]).getText();
            nc = ((TextInputCallback) callbacks[3]).getText();
            cnonce = ((TextInputCallback) callbacks[4]).getText();
            qop = ((TextInputCallback) callbacks[5]).getText();
            realmName = ((TextInputCallback) callbacks[6]).getText();
            md5a2 = ((TextInputCallback) callbacks[7]).getText();
======= c984c6a:"java/org/apache/catalina/realm/JAASMemoryLoginModule.java"

        if (md5a2 == null) {
            // Not using DIGEST
            principal = super.authenticate(username, password);
        } else {
            // Must be using DIGEST
            principal = super.authenticate(username, password, nonce, nc,
                    cnonce, qop, realmName, md5a2);
        }
======= c984c6a:"java/org/apache/catalina/realm/JAASRealm.java"

======= c984c6a:"java/org/apache/catalina/realm/JAASRealm.java"

     * Return the <code>Principal</code> associated with the specified username
     * and credentials, if there is one; otherwise return <code>null</code>.
        return authenticate(username,
                new JAASCallbackHandler(this, username, credentials));
    }
     
    /**
     * Return the <code>Principal</code> associated with the specified username
     * and digest, if there is one; otherwise return <code>null</code>.
     *
     * @param username      Username of the <code>Principal</code> to look up
     * @param clientDigest  Digest to use in authenticating this username
     * @param nonce         Server generated nonce
     * @param nc            Nonce count
     * @param cnonce        Client generated nonce
     * @param qop           Quality of protection aplied to the message
     * @param realmName     Realm name
     * @param md5a2         Second MD5 digest used to calculate the digest
     *                          MD5(Method + ":" + uri)
     */
    public Principal authenticate(String username, String clientDigest,
            String nonce, String nc, String cnonce, String qop,
            String realmName, String md5a2) {
        return authenticate(username,
                new JAASCallbackHandler(this, username, clientDigest, nonce,
                        nc, cnonce, qop, realmName, md5a2));
    }
    // -------------------------------------------------------- Package Methods
    // ------------------------------------------------------ Protected Methods
    /**
     * Perform the actual JAAS authentication
     */
    protected Principal authenticate(String username,
            CallbackHandler callbackHandler) {
======= c984c6a:"java/org/apache/catalina/realm/JAASRealm.java"

            loginContext = new LoginContext(appName, callbackHandler);
======= c984c6a:"java/org/apache/catalina/realm/JAASRealm.java"

======= c984c6a:"java/org/apache/catalina/realm/JAASRealm.java"

     * Return the password associated with the given principal's user name. This
     * always returns null as the JAASRealm has no way of obtaining this
     * information.

======= 38a62a6:"java/org/apache/jk/server/JkMain.java"

        // wEnv sometime null at shutdown - bug45591
        if (wEnv != null) {
            for( int i=0; i<wEnv.getHandlerCount(); i++ ) {
                if( wEnv.getHandler(i) != null ) {
                    wEnv.getHandler(i).pause();
                }

======= 9d3cad7:"java/org/apache/catalina/realm/JDBCRealm.java"

======= 9d3cad7:"java/org/apache/catalina/realm/JDBCRealm.java"

    protected synchronized Principal getPrincipal(String username) {

======= 4cab5f3:"java/org/apache/catalina/core/StandardContext.java"

            } catch (IllegalAccessException iae) {
                getLogger().error
                (sm.getString("standardContext.applicationListenerIAE",
                              listeners[i]), iae);
            ok = false;

======= 92f847d:"java/org/apache/catalina/connector/CoyoteReader.java"

                    if (pos == 0 && aggregator == null) {

======= d41f610:"java/org/apache/catalina/servlets/CGIServlet.java"

                // Close the output stream if used
                if (cgiOutput != null) {
                    cgiOutput.close();
                }

======= 252fca1:"java/org/apache/catalina/startup/HostConfig.java"

                if (!docBase.getCanonicalPath().startsWith(
                        appBase().getAbsolutePath() + File.separator)) {

======= 36bb5d9:"java/org/apache/catalina/ha/session/DeltaManager.java"

                if (log.isWarnEnabled()) log.warn(sm.getString("deltaManager.waitForSessionState",getName(), mbr,getStateTransferTimeout()));
     <attribute name="stateTransferTimeout" required="false">
       The time in seconds to wait for a session state transfer to complete from another node
       when a node is starting up.
       Default value is <code>60</code> seconds.
     </attribute>

======= f23907d:"java/org/apache/coyote/ajp/AjpMessage.java"

        mb.getCharChunk().recycle(); // not valid anymore

======= a2a7714:"java/org/apache/catalina/tribes/membership/McastServiceImpl.java"

            try {socket.close();}catch ( Exception ignore){}

======= e0200b0:"java/org/apache/naming/resources/DirContextURLConnection.java"

======= e0200b0:"java/org/apache/naming/resources/DirContextURLConnection.java"

    protected String getHeaderValueAsString(Object headerValue) {
        if (headerValue == null) return null;
        if (headerValue instanceof Date) {
            // return date strings (ie Last-Modified) in HTTP format, rather
            // than Java format
            return FastHttpDateFormat.formatDate(
                    ((Date)headerValue).getTime(), null);
        }
        return headerValue.toString();
    }
======= e0200b0:"java/org/apache/naming/resources/DirContextURLConnection.java"

                  Object attrValue = attributeValues.next();
                  attributeValueList.add(getHeaderValueAsString(attrValue));
======= e0200b0:"java/org/apache/naming/resources/DirContextURLConnection.java"

                    Object attrValue = attribute.get(attribute.size()-1);
                    return getHeaderValueAsString(attrValue);

======= f93376d:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

            // Spec says single SP but it also says be tolerant of HT
            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
======= f93376d:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

        // Spec says single SP but also says be tolerant of multiple and/or HT
        while (space) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill())
                    throw new EOFException(sm.getString("iib.eof.error"));
            }
            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                pos++;
            } else {
                space = false;
            }
        }
======= f93376d:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

======= f93376d:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

            // Spec says single SP but it also says be tolerant of HT
            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
======= f93376d:"java/org/apache/coyote/http11/InternalAprInputBuffer.java"

        // Spec says single SP but also says be tolerant of multiple and/or HT
        while (space) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill())
                    throw new EOFException(sm.getString("iib.eof.error"));
            }
            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                pos++;
            } else {
                space = false;
            }
        }
======= f93376d:"java/org/apache/coyote/http11/InternalInputBuffer.java"

            // Spec says single SP but it also says be tolerant of HT
            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
======= f93376d:"java/org/apache/coyote/http11/InternalInputBuffer.java"

        
        // Spec says single SP but also says be tolerant of multiple and/or HT
        while (space) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill())
                    throw new EOFException(sm.getString("iib.eof.error"));
            }
            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                pos++;
            } else {
                space = false;
            }
        }
======= f93376d:"java/org/apache/coyote/http11/InternalInputBuffer.java"

======= f93376d:"java/org/apache/coyote/http11/InternalInputBuffer.java"

            // Spec says single SP but it also says be tolerant of HT
            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
======= f93376d:"java/org/apache/coyote/http11/InternalInputBuffer.java"

        // Spec says single SP but also says be tolerant of multiple and/or HT
        while (space) {
            // Read new bytes if needed
            if (pos >= lastValid) {
                if (!fill())
                    throw new EOFException(sm.getString("iib.eof.error"));
            }
            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                pos++;
            } else {
                space = false;
            }
        }
======= f93376d:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

                if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
======= f93376d:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            // Spec says single SP but also be tolerant of multiple and/or HT
            boolean space = true;
            while (space) {
                // Read new bytes if needed
                if (pos >= lastValid) {
                    if (!fill(true, false)) //request line parsing
                        return false;
                }
                if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                    pos++;
                } else {
                    space = false;
                }
            }
                if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
======= f93376d:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"

            // Spec says single SP but also be tolerant of multiple and/or HT
            boolean space = true;
            while (space) {
                // Read new bytes if needed
                if (pos >= lastValid) {
                    if (!fill(true, false)) //request line parsing
                        return false;
                }
                if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                    pos++;
                } else {
                    space = false;
                }
            }

======= 3c84dcf:"java/org/apache/jasper/compiler/Validator.java"

        private String comparePageEncodings(String thePageDirEnc,
            String configEnc = root.getJspConfigPageEncoding().toUpperCase();
            String pageDirEnc = thePageDirEnc.toUpperCase();
======= 3c84dcf:"java/org/apache/jasper/compiler/Validator.java"

                String pageEnc = root.getPageEncoding().toUpperCase();

======= a9cb6a6:"java/org/apache/catalina/core/StandardContext.java"

======= a9cb6a6:"java/org/apache/catalina/core/StandardContext.java"

            // Configure and call application event listeners
            
            try {
                // Start manager
                if ((manager != null) && (manager instanceof Lifecycle)) {
                    ((Lifecycle) getManager()).start();
                }
    
                // Start ContainerBackgroundProcessor thread
                super.threadStart();
            } catch(Exception e) {
                log.error("Error manager.start()", e);
                ok = false;
            }
            // Configure and call application filters

======= 17b4436:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        String currentPrefix = getPrefix(current.getQName());
        
        if (JSP_URI.equals(uri) && TEXT_ACTION.equals(current.getLocalName())
                && "jsp".equals(currentPrefix)) {
======= 17b4436:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        String prefix = getPrefix(qName);
======= 17b4436:"java/org/apache/jasper/compiler/JspDocumentParser.java"

        String prefix = getPrefix(qName);
        if (prefix.length() > 0) {
======= 17b4436:"java/org/apache/jasper/compiler/JspDocumentParser.java"

    private String getPrefix(String qName) {
        int index = qName.indexOf(':');
        if (index != -1) {
            return qName.substring(0, index);
        }
        return "";
    }

======= 332d0f0:"java/org/apache/catalina/core/StandardContext.java"

            if (urlPattern.indexOf('/') < 0) {
                checkUnusualURLPattern(urlPattern);
            } else
                (urlPattern.indexOf("*.") < 0)) {
            checkUnusualURLPattern(urlPattern);
        } else
    /**
     * Check for unusual but valid <code>&lt;url-pattern&gt;</code>s.
     * See Bugzilla 34805, 43079 & 43080
     */
    private void checkUnusualURLPattern(String urlPattern) {
        if (log.isInfoEnabled()) {
            if(urlPattern.endsWith("*") && (urlPattern.length() < 2 ||
                    urlPattern.charAt(urlPattern.length()-2) != '/')) {
                log.info("Suspicious url pattern: \"" + urlPattern + "\"" +
                        " in context [" + getName() + "] - see" +
                        " section SRV.11.2 of the Servlet specification" );
            }
        }
    }
======= 332d0f0:"java/org/apache/catalina/deploy/SecurityCollection.java"

======= 332d0f0:"java/org/apache/catalina/deploy/SecurityCollection.java"

======= 332d0f0:"java/org/apache/catalina/deploy/SecurityCollection.java"


======= e2524a8:"java/org/apache/coyote/http11/Http11AprProcessor.java"

            this.compressableMimeTypes = null;
======= e2524a8:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            this.compressableMimeTypes = null;
======= e2524a8:"java/org/apache/coyote/http11/Http11Processor.java"

            this.compressableMimeTypes = null;

======= fa91954:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                URL url = file.toURI().toURL();
======= fa91954:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                    URL url = file.toURI().toURL();
======= fa91954:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                    URL url = directory.toURI().toURL();
======= fa91954:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                    URL url = file.toURI().toURL();
======= fa91954:"java/org/apache/catalina/startup/ClassLoaderFactory.java"

                        URL url = file.toURI().toURL();
======= fa91954:"java/org/apache/jasper/JspCompilationContext.java"

            String tagName = tagInfo.getTagClassName();
            path = tagName.replace('.', File.separatorChar);
            path = path.substring(0, path.lastIndexOf(File.separatorChar));
            path = getServletPackageName().replace('.',File.separatorChar);
        }
                File base = options.getScratchDir();
                baseUrl = base.toURI().toURL();
                outputDir = base.getAbsolutePath() + File.separator + path + 
                    File.separator;

======= 6a8b1bb:"java/org/apache/catalina/startup/HostConfig.java"

            if (files[i].toLowerCase().endsWith(".war") && dir.isFile()) {

======= f4a7632:"java/org/apache/catalina/manager/ManagerServlet.java"

 * <li><b>/sessions</b> - Deprecated. Use expire.
======= f4a7632:"java/org/apache/catalina/manager/ManagerServlet.java"

        } else if (command.equals("/sessions")) {
            expireSessions(writer, path, request);

======= dfa25f4:"java/org/apache/jasper/compiler/Generator.java"

                    if (attrNames.length > 0) {
                        poolName = poolName + "&";
                    }

======= 48131cd:"java/javax/annotation/security/DenyAll.java"

======= 48131cd:"java/javax/ejb/EJB.java"

   String description() default "";
======= 48131cd:"java/javax/persistence/PersistenceContext.java"

   PersistenceProperty[] properties() default {};
======= 48131cd:"java/javax/persistence/PersistenceContext.java"

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
   String name();
   String value();

======= 0ea3e15:"java/org/apache/jasper/compiler/AntCompiler.java"

                endorsedArg.setLine("-J-Djava.endorsed.dirs=" +
                        quotePathList(endorsed));
                info.append("    endorsed dir=" + quotePathList(endorsed) +
                        "\n");
======= 0ea3e15:"java/org/apache/jasper/compiler/AntCompiler.java"

    private String quotePathList(String list) {
        StringBuffer result = new StringBuffer(list.length() + 10);
        StringTokenizer st = new StringTokenizer(list, File.pathSeparator);
        while (st.hasMoreTokens()) {
            String token = st.nextToken();
            if (token.indexOf(' ') == -1) {
                result.append(token);
            } else {
                result.append('\"');
                result.append(token);
                result.append('\"');
            }
            if (st.hasMoreTokens()) {
                result.append(File.pathSeparatorChar);
            }
        }
        return result.toString();
    }

======= 06c23d8:"java/org/apache/catalina/startup/ContextConfig.java"

======= 06c23d8:"java/org/apache/catalina/startup/ContextConfig.java"

======= 06c23d8:"java/org/apache/catalina/startup/ContextConfig.java"

======= 06c23d8:"java/org/apache/catalina/startup/ContextConfig.java"

        if (webDigester == null){
            webDigester = createWebDigester();
            webDigester.getParser();
        }
        
        if (contextDigester == null){
            contextDigester = createContextDigester();
            contextDigester.getParser();
        }

======= 2edf51e:"java/org/apache/catalina/startup/TldConfig.java"

                    // Expect file URLs, these are %xx encoded or not depending
                    // on the class loader
                    
                    // Check that the URL is using file protocol, else ignore it
                    if (!"file".equals(urls[i].getProtocol())) {
                        continue;
                    }
                    

======= 6723b35:"java/org/apache/catalina/core/ApplicationContext.java"

    private static final class DispatchData {

======= df75937:"java/org/apache/catalina/ssi/SSIProcessor.java"

                    if (c == '"' && !escaped) quotes++;

======= 75fbd91:"java/org/apache/catalina/ssi/SSIEcho.java"

        String originalValue = null;
                originalValue = paramValue;
======= 75fbd91:"java/org/apache/catalina/ssi/SSIEcho.java"

        String variableValue = ssiMediator.getVariableValue(
                originalValue, encoding);
        if (variableValue == null) {
            variableValue = MISSING_VARIABLE_VALUE;
        }
        writer.write(variableValue);
        return System.currentTimeMillis();
======= 75fbd91:"java/org/apache/catalina/ssi/SSIMediator.java"

======= 75fbd91:"java/org/apache/catalina/ssi/SSIMediator.java"

        // If it has no references or HTML entities then no work
        if (val.indexOf('$') < 0 && val.indexOf('&') < 0) return val;
        
        // HTML decoding
        val.replace("&lt;", "<");
        val.replace("&gt;", ">");
        val.replace("&quot;", "\"");
        val.replace("&amp;", "&");
        int charStart = sb.indexOf("&#");
        while (charStart > -1) {
            int charEnd = sb.indexOf(";", charStart);
            if (charEnd > -1) {
                char c = (char) Integer.parseInt(
                        sb.substring(charStart + 2, charEnd));
                sb.delete(charStart, charEnd + 1);
                sb.insert(charStart, c);
                charStart = sb.indexOf("&#");
            } else {
                break;
            }
        }
======= 75fbd91:"java/org/apache/catalina/ssi/SSIMediator.java"

            retVal = HttpMessages.filter(value);

======= 1f41c3d:"java/org/apache/jasper/runtime/PageContextImpl.java"

======= 1f41c3d:"java/org/apache/jasper/runtime/PageContextImpl.java"

        final ExpressionFactory exprFactory = jspf.getJspApplicationContext(pageContext.getServletContext()).getExpressionFactory();

======= 0035fd4:"java/org/apache/el/lang/FunctionMapperImpl.java"

            // make sure m isn't null
            getMethod();

======= c3c525b:"java/org/apache/catalina/core/StandardThreadExecutor.java"

    public int getQueueSize() {
        return (executor != null) ? executor.getQueue().size() : -1;
    }
======= c3c525b:"java/org/apache/catalina/core/StandardThreadExecutor.java"


======= 7be2374:"java/org/apache/catalina/realm/RealmBase.java"

                    break;
                    status = true;
            } else {
======= 7be2374:"java/org/apache/catalina/realm/RealmBase.java"

        if (!denyfromall && allRolesMode != AllRolesMode.STRICT_MODE &&
                !status && principal != null) {

======= ca41a27:"java/org/apache/catalina/connector/InputBuffer.java"

======= ca41a27:"java/org/apache/catalina/connector/InputBuffer.java"

    /**
     * The string manager for this package.
     */
    protected static StringManager sm =
        StringManager.getManager(Constants.Package);
======= ca41a27:"java/org/apache/catalina/connector/InputBuffer.java"

======= ca41a27:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= ca41a27:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= ca41a27:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= ca41a27:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= ca41a27:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));
======= ca41a27:"java/org/apache/catalina/connector/InputBuffer.java"

        if (closed)
            throw new IOException(sm.getString("inputBuffer.streamClosed"));

======= fdac1d6:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

======= fdac1d6:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

======= fdac1d6:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

     * List of current Coment connections.
    protected List<Request> cometRequests =
        Collections.synchronizedList(new ArrayList<Request>());
    /**
     * Name of session attribute used to store list of comet connections.
     */
    protected String cometRequestsAttribute =
        "org.apache.tomcat.comet.connectionList";
======= fdac1d6:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

            // The container is getting stopped, close all current connections 
            Iterator<Request> iterator = cometRequests.iterator();
                Request request = iterator.next();
                // Remove the session tracking attribute as it isn't
                // serializable or required.
                HttpSession session = request.getSession(false);
                if (session != null) {
                    session.removeAttribute(cometRequestsAttribute);
                }
                // Close the comet connection
                try {
                    CometEventImpl cometEvent = request.getEvent();
                    cometEvent.setEventType(CometEvent.EventType.END);
                    cometEvent.setEventSubType(
                            CometEvent.EventSubType.WEBAPP_RELOAD);
                    getNext().event(request, request.getResponse(), cometEvent);
                    cometEvent.close();
                } catch (Exception e) {
                    container.getLogger().warn(
                            sm.getString("cometConnectionManagerValve.event"),
                            e);
            cometRequests.clear();
======= fdac1d6:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

            
            // Track the conection for webapp reload
            cometRequests.add(request);
            
            // Track the connection for session expiration
                Request[] requests = (Request[])
                        session.getAttribute(cometRequestsAttribute);
                if (requests == null) {
                    requests = new Request[1];
                    requests[0] = request;
                    session.setAttribute(cometRequestsAttribute,
                            requests);
                    Request[] newRequests = 
                        new Request[requests.length + 1];
                    for (int i = 0; i < requests.length; i++) {
                        newRequests[i] = requests[i];
                    newRequests[requests.length] = request;
                    session.setAttribute(cometRequestsAttribute, newRequests);
======= fdac1d6:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

                            && !(event.getEventSubType() ==
                                CometEvent.EventSubType.TIMEOUT))) {
                
                // Remove the connection from webapp reload tracking
                cometRequests.remove(request);
                
                // Remove connection from session expiration tracking
                // Note: can't get the session if it has been invalidated but
                // OK since session listener will have done clean-up
                HttpSession session = request.getSession(false);
                if (session != null) {
                    synchronized (session) {
                        Request[] reqs = (Request[])
                            session.getAttribute(cometRequestsAttribute);
                        if (reqs != null) {
                            boolean found = false;
                            for (int i = 0; !found && (i < reqs.length); i++) {
                                found = (reqs[i] == request);
                            }
                            if (found) {
                                if (reqs.length > 1) {
                                    Request[] newConnectionInfos = 
                                        new Request[reqs.length - 1];
                                    int pos = 0;
                                    for (int i = 0; i < reqs.length; i++) {
                                        if (reqs[i] != request) {
                                            newConnectionInfos[pos++] = reqs[i];
                                        }
                                    }
                                    session.setAttribute(cometRequestsAttribute,
                                            newConnectionInfos);
                                } else {
                                    session.removeAttribute(
                                            cometRequestsAttribute);
                }
======= fdac1d6:"java/org/apache/catalina/valves/CometConnectionManagerValve.java"

        Request[] reqs = (Request[])
            se.getSession().getAttribute(cometRequestsAttribute);
        if (reqs != null) {
            for (int i = 0; i < reqs.length; i++) {
                Request req = reqs[i];
                    CometEventImpl event = req.getEvent();
                    event.setEventType(CometEvent.EventType.END);
                    event.setEventSubType(CometEvent.EventSubType.SESSION_END);
                    ((CometProcessor)
                            req.getWrapper().getServlet()).event(event);
                    event.close();
                    req.getWrapper().getParent().getLogger().warn(sm.getString(
                            "cometConnectionManagerValve.listenerEvent"), e);

======= 7bd915c:"java/org/apache/tomcat/util/net/JIoEndpoint.java"

                if (address == null)
                    throw new BindException(be.getMessage() + "<null>:" + port);
                else
                    throw new BindException(be.getMessage() + " " +
                            address.toString() + ":" + port);

======= 288b2ae:"java/javax/servlet/http/HttpServlet.java"

======= 288b2ae:"java/javax/servlet/http/HttpServlet.java"

 * A response wrapper for use in (dumb) "HEAD" support.
 * the content length appropriately.  All other methods delegate to the
 * wrapped HTTP Servlet Response object.
        super(r);
          super.setContentLength(noBody.getContentLength());
        super.setContentLength(len);
    public ServletOutputStream getOutputStream() throws IOException {
        return noBody;
    }
    public PrintWriter getWriter() throws UnsupportedEncodingException {
            OutputStreamWriter w;

======= 8a3b14b:"java/org/apache/catalina/servlets/DefaultServlet.java"

                if (debug > 10)
                    log("readme '" + readmeFile + "' not found", e);
                return null;
======= 8a3b14b:"java/org/apache/catalina/servlets/DefaultServlet.java"

                if (debug > 10)
                    log("localXsltFile '" + localXsltFile + "' not found", e);
                return null;

======= bf6ce6f:"java/org/apache/tomcat/util/net/NioEndpoint.java"

            // Start poller thread
            poller = new Poller();
            Thread pollerThread = new Thread(poller, getName() + "-ClientPoller");
            pollerThread.setPriority(threadPriority);
            pollerThread.setDaemon(true);
            pollerThread.start();
======= bf6ce6f:"java/org/apache/tomcat/util/net/NioEndpoint.java"

      <fix><bug>43701</bug>: Start acceptor thread before poller thread
      </fix>

======= 948598d:"java/org/apache/catalina/loader/WebappClassLoader.java"

======= 948598d:"java/org/apache/catalina/loader/WebappClassLoader.java"

    
    protected final class PrivilegedGetClassLoader
        implements PrivilegedAction<ClassLoader> {
        public Class<?> clazz;
        public PrivilegedGetClassLoader(Class<?> clazz){
            this.clazz = clazz;
        }
        public ClassLoader run() {       
            return clazz.getClassLoader();
        }           
    }
    
======= 948598d:"java/org/apache/catalina/loader/WebappClassLoader.java"

        
        if ((log.isTraceEnabled()) && (clazz != null)) {
            ClassLoader cl;
            if (Globals.IS_SECURITY_ENABLED){
                cl = AccessController.doPrivileged(
                    new PrivilegedGetClassLoader(clazz));
            } else {
                cl = clazz.getClassLoader();
            }
            log.debug("      Loaded by " + cl.toString());
        }

======= cdff09f:"java/org/apache/catalina/core/StandardContext.java"

                if (listener.equals(applicationListeners[i])) {
                    log.info(sm.getString(
                            "standardContext.duplicateListener",listener));
                }

======= f9e41b8:"java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java"

        if( truststoreType == null) {
            truststoreType = System.getProperty("javax.net.ssl.trustStoreType");
        }

======= e14afee:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

======= e14afee:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                Manager manager = context.getManager();
                if (manager == null) {
                    args[11] = sm.getString("htmlManagerServlet.noManager");
                } else {
                    args[11] = new Integer(
                            context.getManager().getMaxInactiveInterval()/60);
                }

======= 1cc6641:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

            //we need a CRLF
            if ((pos+1) >= lastValid) {   
                //if we call parseCRLF we overrun the buffer here
                //so we defer it to the next call BZ 11117
                needCRLFParse = true;
            } else {
                parseCRLF(); //parse the CRLF immediately
            }
======= 1cc6641:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

        boolean crfound = false;
======= 1cc6641:"java/org/apache/coyote/http11/filters/ChunkedInputFilter.java"

                if (crfound) throw new IOException("Invalid CRLF, two CR characters encountered.");
                crfound = true;
                if (!crfound) throw new IOException("Invalid CRLF, no CR character encountered.");

======= 98b8ba2:"java/org/apache/jasper/compiler/Parser.java"

                    } else {
                        // Current compilation context needs location of cached
                        // tag files
                        for (TagFileInfo info : impl.getTagFiles()) {
                            ctxt.setTagFileJarUrl(info.getPath(),
                                    ctxt.getTagFileJarUrl());
                        }

======= 61ce1a3:"java/org/apache/jasper/compiler/Node.java"

            if (ret == null) {
                if (body != null) {
                    StringBuffer buf = new StringBuffer();
                    for (int i = 0; i < body.size(); i++) {
                        buf.append(body.getNode(i).getText());
                    }
                    ret = buf.toString();
                } else {
                    // Nulls cause NPEs further down the line
                    ret = "";

======= ccadbbc:"java/org/apache/tomcat/util/modeler/ManagedBean.java"

                object = bean;
======= ccadbbc:"java/org/apache/tomcat/util/modeler/ManagedBean.java"

                object = bean;

======= c5bcc98:"java/org/apache/el/parser/AstValue.java"

======= c5bcc98:"java/org/apache/el/parser/AstValue.java"

        ELResolver resolver = ctx.getELResolver();
        resolver.setValue(ctx, t.base, t.property, 
        		// coerce to the expected type
        		ELSupport.coerceToType(value, 
        				resolver.getType(ctx, t.base, t.property)));

======= 2441155:"java/org/apache/naming/resources/FileDirContext.java"

            getCreation();
            getLastModified();
======= 2441155:"java/org/apache/naming/resources/FileDirContext.java"

            creation = getLastModified();
======= 2441155:"java/org/apache/naming/resources/FileDirContext.java"

                creation = getCreation();
======= 2441155:"java/org/apache/naming/resources/FileDirContext.java"

                lastModified = getLastModified();

======= e452200:"java/org/apache/catalina/connector/CoyoteAdapter.java"

======= e452200:"java/org/apache/catalina/connector/CoyoteAdapter.java"

    /**
     * Encoder for the Location URL in HTTP redirects.
     */
    protected static URLEncoder urlEncoder;
    // ----------------------------------------------------- Static Initializer
    /**
     * The safe character set.
     */
    static {
        urlEncoder = new URLEncoder();
        urlEncoder.addSafeCharacter('-');
        urlEncoder.addSafeCharacter('_');
        urlEncoder.addSafeCharacter('.');
        urlEncoder.addSafeCharacter('*');
        urlEncoder.addSafeCharacter('/');
    }
======= e452200:"java/org/apache/catalina/connector/CoyoteAdapter.java"

            String redirectPath = urlEncoder.encode(redirectPathMB.toString());

======= fdb170e:"java/org/apache/el/lang/EvaluationContext.java"

======= fdb170e:"java/org/apache/el/lang/EvaluationContext.java"

    
    public Locale getLocale() { 
        return this.elContext.getLocale();
        }
    public void setLocale(Locale locale) { 
        this.elContext.setLocale(locale);
    }

======= c228054:"java/org/apache/el/lang/ELArithmetic.java"

        throw new IllegalArgumentException(MessageFactory.get("error.convert",
                obj, objType, "Number"));

======= df2b1e6:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  &nbsp;<input type=\"submit\" value=\"{9}\">&nbsp;{10}&nbsp;<input type=\"text\" name=\"idle\" size=\"5\" value=\"{11}\">&nbsp;{12}&nbsp;\n" +
======= df2b1e6:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "  &nbsp;<input type=\"submit\" value=\"{9}\">&nbsp;{10}&nbsp;<input type=\"text\" name=\"idle\" size=\"5\" value=\"{11}\">&nbsp;{12}&nbsp;\n" +

======= 46721e4:"java/org/apache/catalina/realm/JAASRealm.java"

      * Sets the list of comma-delimited classes that represent roles. The
      * classes in the list must implement <code>java.security.Principal</code>.
      * The supplied list of classes will be parsed when {@link #start()} is
      * called.
      * in the provided List. Each class must implement
      * <code>java.security.Principal</code>.
======= 46721e4:"java/org/apache/catalina/realm/JAASRealm.java"

         ClassLoader loader = this.getClass().getClassLoader();
         if (isUseContextClassLoader())
             loader = Thread.currentThread().getContextClassLoader();
                 Class principalClass = Class.forName(classNames[i], false,
                         loader);
======= 46721e4:"java/org/apache/catalina/realm/JAASRealm.java"

      * Sets the list of comma-delimited classes that represent individual
      * users. The classes in the list must implement
      * <code>java.security.Principal</code>. The supplied list of classes will
      * be parsed when {@link #start()} is called.
      */
======= 46721e4:"java/org/apache/catalina/realm/JAASRealm.java"

        if (!isUseContextClassLoader()) {
          ocl = Thread.currentThread().getContextClassLoader();
          Thread.currentThread().setContextClassLoader(
                  this.getClass().getClassLoader());
======= 46721e4:"java/org/apache/catalina/realm/JAASRealm.java"

            if(!isUseContextClassLoader()) {
======= 46721e4:"java/org/apache/catalina/realm/JAASRealm.java"

        Iterator<Principal> principals = subject.getPrincipals().iterator();
            Principal principal = principals.next();
======= 46721e4:"java/org/apache/catalina/realm/JAASRealm.java"

        // These need to be called after loading configuration, in case
        // useContextClassLoader appears after them in xml config
        parseClassNames(userClassNames, userClasses);
        parseClassNames(roleClassNames, roleClasses);

======= 71bd193:"java/org/apache/catalina/connector/Response.java"

        usingOutputStream = false;
        usingWriter = false;
        isCharacterEncodingSet = false;

======= 8f91433:"java/org/apache/catalina/core/ApplicationContext.java"

        if (path == null || !path.startsWith("/"))
======= 8f91433:"java/org/apache/catalina/core/ApplicationContext.java"

        // Normalize the slashes

======= ffbbe88:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                if ((host.findChild(path) != null) && !isDeployed(path)) {
                    message = sm.getString
                        ("htmlManagerServlet.deployUploadInServerXml", war);
                    break;
                }

======= d1d0619:"java/org/apache/coyote/http11/Http11AprProtocol.java"

            processor.setCompression(proto.compression);
======= d1d0619:"java/org/apache/coyote/http11/Http11NioProtocol.java"

            processor.setCompression(proto.compression);
======= d1d0619:"java/org/apache/coyote/http11/Http11Protocol.java"

            processor.setCompression(proto.compression);

======= eb87635:"java/org/apache/jasper/compiler/ErrorDispatcher.java"

            // If this is a scriplet node then there is a one to one mapping
            // between JSP lines and Java lines
            if (errVisitor.getJspSourceNode() instanceof Node.Scriptlet) {
                javacError = new JavacErrorDetail(
                        fname,
                        lineNum,
                        errNode.getStart().getFile(),
                        errNode.getStart().getLineNumber() + lineNum -
                            errVisitor.getJspSourceNode().getBeginJavaLine(),
                        errMsgBuf,
                        ctxt);
            } else {
                javacError = new JavacErrorDetail(
                        fname,
                        lineNum,
                        errNode.getStart().getFile(),
                        errNode.getStart().getLineNumber(),
                        errMsgBuf,
                        ctxt);
            }

======= 324387d:"java/org/apache/catalina/servlets/WebdavServlet.java"

        // Copy was successful
        resp.setStatus(WebdavStatus.SC_CREATED);

======= 9314e5b:"java/org/apache/catalina/core/StandardWrapper.java"

            log.info("Error registering servlet with jmx " + this, ex);
======= 9314e5b:"java/org/apache/catalina/core/StandardWrapper.java"

                         instance, ex);

======= 3c61f9b:"java/org/apache/catalina/servlets/WebdavServlet.java"

 * are handled by the DefaultServlet. The WebDAVServlet must not be used as the
 * default servlet (ie mapped to '/') as it will not work in this configuration.
 * To enable WebDAV for a context add the following to web.xml:<br/><code>
 * &lt;servlet&gt;<br/>
 *  &lt;servlet-name&gt;webdav&lt;/servlet-name&gt;<br/>
 *  &lt;servlet-class&gt;org.apache.catalina.servlets.WebdavServlet&lt;/servlet-class&gt;<br/>
 *    &lt;init-param&gt;<br/>
 *      &lt;param-name&gt;debug&lt;/param-name&gt;<br/>
 *      &lt;param-value&gt;0&lt;/param-value&gt;<br/>
 *    &lt;/init-param&gt;<br/>
 *    &lt;init-param&gt;<br/>
 *      &lt;param-name&gt;listings&lt;/param-name&gt;<br/>
 *      &lt;param-value&gt;true&lt;/param-value&gt;<br/>
 *    &lt;/init-param&gt;<br/>
 *  &lt;/servlet&gt;<br/>
 *  &lt;servlet-mapping&gt;<br/>
 *    &lt;servlet-name&gt;webdav&lt;/servlet-name&gt;<br/>
 *    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;<br/>
 *  &lt;/servlet-mapping&gt;
 * </code>
 * <p/>
 * This will enable read only access. To enable read-write access add:<br/>
 * <code>
 *    &lt;init-param&gt;<br/>
 *      &lt;param-name&gt;readonly&lt;/param-name&gt;<br/>
 *      &lt;param-value&gt;false&lt;/param-value&gt;<br/>
 *    &lt;/init-param&gt;<br/>
 * </code>
 * <p/>
 * To make the content editable via a different URL, using the following
 * mapping:<br/>
 * <code>
 *  &lt;servlet-mapping&gt;<br/>
 *    &lt;servlet-name&gt;webdav&lt;/servlet-name&gt;<br/>
 *    &lt;url-pattern&gt;/webdavedit/*&lt;/url-pattern&gt;<br/>
 *  &lt;/servlet-mapping&gt;
 * </code>
 * <p/>
 * Don't forget to secure access appropriately to the editing URLs. With this
 * configuration the context will be accessible to normal users as before. Those
 * users with the necessary access will be able to edit content available via
 * http://host:port/context/content using
 * http://host:port/context/webdavedit/content
======= 3c61f9b:"java/org/apache/catalina/servlets/WebdavServlet.java"


  -1: remm (would like clarification on the sleep value, currently 100s)
  +1: jfclere, remm
======= 16464d6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            sendfileData.remove(new Long(data.socket));
======= 16464d6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

            long maintainTime = 0;
======= 16464d6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    // Reset maintain time.
                    maintainTime = 0;
======= 16464d6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    maintainTime += pollTime;
======= 16464d6:"java/org/apache/tomcat/util/net/AprEndpoint.java"

                    // Call maintain for the sendfile poller
                    if (soTimeout > 0 && maintainTime > 1000000L && running) {
                        rv = Poll.maintain(sendfilePollset, desc, true);
                        maintainTime = 0;
                        if (rv > 0) {
                            for (int n = 0; n < rv; n++) {
                                // Get the sendfile state
                                SendfileData state = sendfileData.get(new Long(desc[n]));
                                // Close socket and clear pool
                                remove(state);
                                // Destroy file descriptor pool, which should close the file
                                // Close the socket, as the response would be incomplete
                                Socket.destroy(state.socket);
                            }
                        }
                    }
      <fix>
        <bug>43479</bug>: Memory leak cleaning up sendfile connections, submitted by Chris Elving. (remm)
      </fix>
      <fix>
        <bug>42925</bug>: Add maintain for sendfile. (remm)
      </fix>

======= 73b5e41:"java/org/apache/catalina/core/StandardContext.java"

        ErrorPage errorPage = (ErrorPage)statusPages.get(new Integer(status));
        if (errorPage!=null) {
            return errorPage.getLocation();
        }
        return null;
        Patch by Tuomas Kiviaho- tuomas.kiviahos at ikis fi (funkman)
      </fix>
      <fix>
        <bug>43453</bug>: ClassCastException at 
        org.apache.catalina.core.StandardContext.findStatusPage(int)
         (funkman)

======= 5aed2f5:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            if (!removed) {
                if (log.isDebugEnabled()) log.debug("Member["+member+"] disappeared, but was not present in the map.");
                return; //the member was not part of our map.
            }
        <bug>43435</bug>: Don't iterate and relocate sessions if they are not part of the map.
      </fix>
      <fix>

======= 28da141:"java/org/apache/coyote/http11/Http11NioProtocol.java"

    public void setClientauth(String s) {setClientAuth(s);}
    public String getClientauth(){ return getClientAuth();}
    public String getClientAuth() { return ep.getClientAuth();}
    public void setClientAuth(String s ) { ep.setClientAuth(s);}
    public void setTruststoreFile(String f){ep.setTruststoreFile(f);}
    public String getTruststoreFile(){return ep.getTruststoreFile();}
    public void setTruststorePass(String p){ep.setTruststorePass(p);}
    public String getTruststorePass(){return ep.getTruststorePass();}
    public void setTruststoreType(String t){ep.setTruststoreType(t);}
    public String getTruststoreType(){ return ep.getTruststoreType();}
    
    
======= 28da141:"java/org/apache/tomcat/util/net/NioEndpoint.java"

    public String adjustRelativePath(String path, String relativeTo) {
        File f = new File(path);
        if ( !f.isAbsolute()) {
            path = relativeTo + File.separator + path;
            f = new File(path);
        }
        if (!f.exists()) {
            log.warn("configured file:["+path+"] does not exist.");
        }
        return path;
    }
    
    public String defaultIfNull(String val, String defaultValue) {
        if (val==null) return defaultValue;
        else return val;
    }
    protected String truststoreFile = System.getProperty("javax.net.ssl.trustStore");
    public void setTruststoreFile(String s) {
        s = adjustRelativePath(s,System.getProperty("catalina.base"));
        this.truststoreFile = s;
    }
    public String getTruststoreFile() {return truststoreFile;}
    protected String truststorePass = System.getProperty("javax.net.ssl.trustStorePassword");
    public void setTruststorePass(String truststorePass) {this.truststorePass = truststorePass;}
    public String getTruststorePass() {return truststorePass;}
    protected String truststoreType = System.getProperty("javax.net.ssl.trustStoreType");
    public void setTruststoreType(String truststoreType) {this.truststoreType = truststoreType;}
    public String getTruststoreType() {return truststoreType;}
    
    public void setKeystoreFile(String s ) { 
        s = adjustRelativePath(s,System.getProperty("catalina.base"));
        this.keystoreFile = s; 
    }
    protected String clientAuth = "false";
    public String getClientAuth() { return clientAuth;}
    public void setClientAuth(String s ) { this.clientAuth = s;}
======= 28da141:"java/org/apache/tomcat/util/net/NioEndpoint.java"

            char[] tpassphrase = (getTruststorePass()!=null)?getTruststorePass().toCharArray():passphrase;
            String ttype = (getTruststoreType()!=null)?getTruststoreType():getKeystoreType();
            KeyStore ts = null;
            if (getTruststoreFile()==null) {
                ts = KeyStore.getInstance(getKeystoreType());
                ts.load(new FileInputStream(getKeystoreFile()), passphrase);
            }else {
                ts = KeyStore.getInstance(ttype);
                ts.load(new FileInputStream(getTruststoreFile()), tpassphrase);
            }
======= 28da141:"java/org/apache/tomcat/util/net/NioEndpoint.java"

        if ("false".equals(getClientAuth())) {
            engine.setNeedClientAuth(false);
            engine.setWantClientAuth(false);
        } else if ("true".equals(getClientAuth()) || "yes".equals(getClientAuth())){
            engine.setNeedClientAuth(true);
        } else if ("want".equals(getClientAuth())) {
            engine.setWantClientAuth(true);
        }        

======= 4dd22a5:"java/org/apache/catalina/core/ApplicationDispatcher.java"

======= 4dd22a5:"java/org/apache/catalina/core/ApplicationDispatcher.java"

======= 4dd22a5:"java/org/apache/catalina/core/ApplicationDispatcher.java"

======= 4dd22a5:"java/org/apache/catalina/core/ApplicationDispatcher.java"

======= 4dd22a5:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        // Recycle request if necessary (also BZ 30949)
        recycleRequestWrapper(state);
        
======= 4dd22a5:"java/org/apache/catalina/core/ApplicationDispatcher.java"

    private void recycleRequestWrapper(State state) {
        if (state.wrapRequest instanceof ApplicationHttpRequest) {
            ((ApplicationHttpRequest) state.wrapRequest).recycle();        }
    }
        <bug>30949</bug>: Improve previous fix. Ensure requests are re-cycled
        on cross-context includes and forwards when an exception occurs in the
        target page. (markt)
      </fix>
      <fix>

======= 9c37a01:"java/org/apache/catalina/session/StandardManager.java"

      <fix>
         <bug>43216</bug>: Set correct StandardSession#accessCount as StandardSession.ACTIVITY_CHECK is true.
          Patch provided by Takayuki Kaneko (pero)
      </fix>

======= 44e36ea:"java/org/apache/catalina/util/RequestUtil.java"

     * servers. It is assumed the string is not a query string.
======= 44e36ea:"java/org/apache/catalina/util/RequestUtil.java"

    
    
     * Decode and return the specified URL-encoded String. It is assumed the
     * string is not a query string.
======= 44e36ea:"java/org/apache/catalina/util/RequestUtil.java"

        return URLDecode(str, enc, false);
    }
    
    /**
     * Decode and return the specified URL-encoded String.
     *
     * @param str The url-encoded string
     * @param enc The encoding to use; if null, the default encoding is used
     * @param isQuery Is this a query string being processed
     * @exception IllegalArgumentException if a '%' character is not followed
     * by a valid 2-digit hexadecimal number
     */
    public static String URLDecode(String str, String enc, boolean isQuery) {
======= 44e36ea:"java/org/apache/catalina/util/RequestUtil.java"

        return URLDecode(bytes, enc, isQuery);
     * Decode and return the specified URL-encoded byte array. It is assumed
     * the string is not a query string.
======= 44e36ea:"java/org/apache/catalina/util/RequestUtil.java"

     * Decode and return the specified URL-encoded byte array. It is assumed
     * the string is not a query string.
======= 44e36ea:"java/org/apache/catalina/util/RequestUtil.java"

        return URLDecode(bytes, null, false);
    }
    /**
     * Decode and return the specified URL-encoded byte array.
     *
     * @param bytes The url-encoded byte array
     * @param enc The encoding to use; if null, the default encoding is used
     * @param isQuery Is this a query string being processed
     * @exception IllegalArgumentException if a '%' character is not followed
     * by a valid 2-digit hexadecimal number
     */
    public static String URLDecode(byte[] bytes, String enc, boolean isQuery) {
    
======= 44e36ea:"java/org/apache/catalina/util/RequestUtil.java"

            if (b == '+' && isQuery) {
        <bug>42944</bug>: Correctly handle servlet mappings that use a '+'
        character as part of the url pattern. (markt)
      </fix>
      <fix>

======= 8aa247e:"webapps/examples/WEB-INF/classes/sessions/DummyCart.java"

======= 8aa247e:"webapps/examples/WEB-INF/classes/sessions/DummyCart.java"

    public void processRequest() {
        if (submit == null || submit.equals("add"))

======= a6ea14d:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

            comet = req.isComet();
                if (comet) {
                    req.setFilterChain(filterChain);
                }
======= a6ea14d:"java/org/apache/catalina/core/ApplicationFilterFactory.java"


 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 * <p>Representation of a security role reference for a web application, as
 * represented in a <code>&lt;security-role-ref&gt;</code> element
 * in the deployment descriptor.</p>
 *
 * @author Mark Thomas
 * @version $Revision$ $Date$
 * @since Tomcat 5.5
 */
    // ------------------------------------------------------------- Properties
    /**
     * The (required) role name.
     */
    private String name = null;
    public String getName() {
        return (this.name);
    }
    public void setName(String name) {
        this.name = name;
    }
    /**
     * The optional role link.
     */
    private String link = null;
    public String getLink() {
        return (this.link);
    }
    public void setLink(String link) {
        this.link = link;
    }
    // --------------------------------------------------------- Public Methods
    /**
     * Return a String representation of this object.
     */
    public String toString() {
        StringBuffer sb = new StringBuffer("SecurityRoleRef[");
        sb.append("name=");
        sb.append(name);
        if (link != null) {
            sb.append(", link=");
            sb.append(link);
        }
        sb.append("]");
        return (sb.toString());
    }
======= ba25bfb:"java/org/apache/catalina/startup/WebRuleSet.java"

======= ba25bfb:"java/org/apache/catalina/startup/WebRuleSet.java"

        digester.addRule(prefix + "web-app/servlet/security-role-ref",
                new SecurityRoleRefCreateRule());
        digester.addCallMethod(
                prefix + "web-app/servlet/security-role-ref/role-link",
                "setLink", 0);
        digester.addCallMethod(
                prefix + "web-app/servlet/security-role-ref/role-name",
                "setName", 0);
======= ba25bfb:"java/org/apache/catalina/startup/WebRuleSet.java"

======= ba25bfb:"java/org/apache/catalina/startup/WebRuleSet.java"

 * A Rule that adds a security-role-ref to a servlet, allowing for the fact that
 * role-link is an optional element.
 */
    
    public SecurityRoleRefCreateRule() {
    }
    
    public void begin(String namespace, String name, Attributes attributes)
            throws Exception {
        SecurityRoleRef securityRoleRef = new SecurityRoleRef();
        digester.push(securityRoleRef);
        if (digester.getLogger().isDebugEnabled())
            digester.getLogger().debug("new SecurityRoleRef");
    }
    public void end(String namespace, String name)
            throws Exception {
        SecurityRoleRef securityRoleRef = (SecurityRoleRef) digester.pop();
        Wrapper wrapper = (Wrapper) digester.peek();
        
        wrapper.addSecurityReference(securityRoleRef.getName(),
                securityRoleRef.getLink());
        if (digester.getLogger().isDebugEnabled())
            digester.getLogger().debug("pop SecurityRoleRef");
    }
        <bug>41722</bug>: Make the role-link element optional (as required by
        the spec) when using a security-role-ref element. (markt)
      </fix>
      <fix>
        override an env-entry in web.xml. (markt)

======= 6c6ad83:"java/org/apache/jasper/compiler/JavacErrorDetail.java"

            InputStream is = null;
            FileInputStream  fis = null;
            
                is = ctxt.getResourceAsStream(jspFileName);
                String[] jspLines = readFile(is);
                fis = new FileInputStream(ctxt.getServletJavaFileName());
                String[] javaLines = readFile(fis);
======= 6c6ad83:"java/org/apache/jasper/compiler/JavacErrorDetail.java"

            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }
                }
                if (fis != null) {
                    try {
                        fis.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }
                }

======= 53add24:"java/org/apache/catalina/deploy/NamingResources.java"

======= 53add24:"java/org/apache/catalina/deploy/NamingResources.java"

            ContextEnvironment ce = findEnvironment(environment.getName());
            ContextResourceLink rl = findResourceLink(environment.getName());
            if (ce != null) {
                if (ce.getOverride()) {
                    removeEnvironment(environment.getName());
                } else {
                    return;
                }
            } else if (rl != null) {
                // Link. Need to look at the global resources
                NamingResources global =
                    ServerFactory.getServer().getGlobalNamingResources();
                if (global.findEnvironment(rl.getGlobal()) != null) {
                    if (global.findEnvironment(rl.getGlobal()).getOverride()) {
                        removeResourceLink(environment.getName());
                    } else {
                        return;
                    }
                }
                // It exists but it isn't an env or a res link...
      <fix>
        <bug>42547</bug>: Fix NPE when a ResourceLink in context.xml tries to
        override an env-entry in web.xml.
      </fix>

======= 5b65cf4:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

    private int currFunc = 0;
======= 5b65cf4:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

                throws JasperException {
        ELFunctionMapper map = new ELFunctionMapper();
        map.ds = new StringBuffer();
        map.ss = new StringBuffer();
        page.visit(map.new ELFunctionVisitor());
        // Append the declarations to the root node
        String ds = map.ds.toString();
        if (ds.length() > 0) {
            Node root = page.getRoot();
            new Node.Declaration(map.ss.toString(), null, root);
            new Node.Declaration("static {\n" + ds + "}\n", null, root);
        }
======= 5b65cf4:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

        
        /**
         * Use a global name map to facilitate reuse of function maps.
         * The key used is prefix:function:uri.
         */
        private HashMap<String, String> gMap = new HashMap<String, String>();
        public void visit(Node.ParamAction n) throws JasperException {
            doMap(n.getValue());
            visitBody(n);
        }
        public void visit(Node.IncludeAction n) throws JasperException {
            doMap(n.getPage());
            visitBody(n);
        }
        public void visit(Node.ForwardAction n) throws JasperException {
            doMap(n.getPage());
            visitBody(n);
        }
            doMap(n.getValue());
            visitBody(n);
        }
            doMap(n.getBeanName());
            visitBody(n);
        }
            doMap(n.getHeight());
            doMap(n.getWidth());
            visitBody(n);
        }
            Node.JspAttribute[] attrs = n.getJspAttributes();
            for (int i = 0; attrs != null && i < attrs.length; i++) {
                doMap(attrs[i]);
            }
            doMap(n.getNameAttribute());
            visitBody(n);
        }
            Node.JspAttribute[] attrs = n.getJspAttributes();
            for (int i = 0; attrs != null && i < attrs.length; i++) {
                doMap(attrs[i]);
            }
            visitBody(n);
        }
            Node.JspAttribute[] attrs = n.getJspAttributes();
            for (int i = 0; attrs != null && i < attrs.length; i++) {
                doMap(attrs[i]);
            }
            visitBody(n);
        }
            doMap(n.getEL());
        }
        private void doMap(Node.JspAttribute attr) 
                throws JasperException {
            if (attr != null) {
                doMap(attr.getEL());
            }
        }
        private void doMap(ELNode.Nodes el) 
                throws JasperException {
            class Fvisitor extends ELNode.Visitor {
                ArrayList<ELNode.Function> funcs =
                    new ArrayList<ELNode.Function>();
                HashMap<String, String> keyMap = new HashMap<String, String>();
                public void visit(ELNode.Function n) throws JasperException {
                    String key = n.getPrefix() + ":" + n.getName();
                    if (! keyMap.containsKey(key)) {
                        keyMap.put(key,"");
                        funcs.add(n);
                    }
                }
            }
            if (el == null) {
                return;
            }
            // First locate all unique functions in this EL
            Fvisitor fv = new Fvisitor();
            el.visit(fv);
            ArrayList functions = fv.funcs;
            if (functions.size() == 0) {
                return;
            }
            // Reuse a previous map if possible
            String decName = matchMap(functions);
            if (decName != null) {
                el.setMapName(decName);
                return;
            }
        
            // Generate declaration for the map statically
            decName = getMapName();
            ss.append("static private org.apache.jasper.runtime.ProtectedFunctionMapper " + decName + ";\n");
            ds.append("  " + decName + "= ");
            ds.append("org.apache.jasper.runtime.ProtectedFunctionMapper");
            // Special case if there is only one function in the map
            String funcMethod = null;
            if (functions.size() == 1) {
                funcMethod = ".getMapForFunction";
            } else {
                ds.append(".getInstance();\n");
                funcMethod = "  " + decName + ".mapFunction";
            }
            for (int i = 0; i < functions.size(); i++) {
                ELNode.Function f = (ELNode.Function)functions.get(i);
                FunctionInfo funcInfo = f.getFunctionInfo();
                String key = f.getPrefix()+ ":" + f.getName();
                ds.append(funcMethod + "(\"" + key + "\", " +
                        funcInfo.getFunctionClass() + ".class, " +
                        '\"' + f.getMethodName() + "\", " +
                        "new Class[] {");
                String params[] = f.getParameters();
                for (int k = 0; k < params.length; k++) {
                    if (k != 0) {
                        ds.append(", ");
                    }
                    int iArray = params[k].indexOf('[');
                    if (iArray < 0) {
                        ds.append(params[k] + ".class");
                    }
                    else {
                        String baseType = params[k].substring(0, iArray);
                        ds.append("java.lang.reflect.Array.newInstance(");
                        ds.append(baseType);
                        ds.append(".class,");
                        // Count the number of array dimension
                        int aCount = 0;
                        for (int jj = iArray; jj < params[k].length(); jj++ ) {
                            if (params[k].charAt(jj) == '[') {
                                aCount++;
                            }
                        }
                        if (aCount == 1) {
                            ds.append("0).getClass()");
                        } else {
                            ds.append("new int[" + aCount + "]).getClass()");
                        }
                    }
                }
                ds.append("});\n");
                // Put the current name in the global function map
                gMap.put(f.getPrefix() + ':' + f.getName() + ':' + f.getUri(),
                         decName);
            }
            el.setMapName(decName);
        }
======= 5b65cf4:"java/org/apache/jasper/compiler/ELFunctionMapper.java"

        private String matchMap(ArrayList functions) {
            String mapName = null;
            for (int i = 0; i < functions.size(); i++) {
                ELNode.Function f = (ELNode.Function)functions.get(i);
                String temName = (String) gMap.get(f.getPrefix() + ':' +
                                        f.getName() + ':' + f.getUri());
                if (temName == null) {
                    return null;
                }
                if (mapName == null) {
                    mapName = temName;
                } else if (!temName.equals(mapName)) {
                    // If not all in the previous match, then no match.
                    return null;
                }
            }
            return mapName;
        }
        private String getMapName() {
            return "_jspx_fnmap_" + currFunc++;
        }
      <fix>
        Fix XSS security vulnerability (CVE-2007-2450) in the Manager and Host
        Manager. Reported by Daiki Fukumori. (markt)
      </fix>
      <fix>
        <bug>42643</bug> Prevent creation of duplicate JSP function mapper
        variables. (markt)
      </fix>
      <fix>
        Fix XSS security vulnerabilities (CVE-2007-2449) in the examples.
        Reported by Toshiharu Sugiyama. (markt)
      </fix>

======= 0114b2d:"java/org/apache/catalina/servlets/DefaultServlet.java"

        ArrayList<Range> result = new ArrayList<Range>();
======= 0114b2d:"java/org/apache/catalina/servlets/DefaultServlet.java"

                    response.setHeader("ETag", getETag(resourceAttributes));
======= 0114b2d:"java/org/apache/catalina/servlets/DefaultServlet.java"

                    response.setHeader("ETag", getETag(resourceAttributes));
         <bug>39875</bug>: Fix BPE in RealmBase.init(). Port of yoavs's fix from
         Tomcat 5. (markt)
         <bug>42444</bug>: prevent NPE for AccessLogValve
         Patch provided by Nils Hammar (funkman)
      </fix>
      <fix>
         <bug>42449</bug>:
         JNDIRealm does not catch NullPointerException for Sun's
         LDAP provider (See bug for details) (funkman)
      </fix>
      <fix>
         <bug>42497</bug>: Ensure ETag header is present in a 304 response.
         Patch provided by Len Popp. (markt)

======= 71eccb3:"java/org/apache/catalina/valves/ErrorReportValve.java"

        if (response.isCommitted()) {

======= 0ea4c7c:"java/org/apache/catalina/realm/RealmBase.java"

        ArrayList<SecurityConstraint> results = null;
======= 0ea4c7c:"java/org/apache/catalina/realm/RealmBase.java"

                                results = new ArrayList<SecurityConstraint>();
======= 0ea4c7c:"java/org/apache/catalina/realm/RealmBase.java"

                            results = new ArrayList<SecurityConstraint>();
======= 0ea4c7c:"java/org/apache/catalina/realm/RealmBase.java"

                        results = new ArrayList<SecurityConstraint>();
======= 0ea4c7c:"java/org/apache/catalina/realm/RealmBase.java"

                        results = new ArrayList<SecurityConstraint>();
======= 0ea4c7c:"java/org/apache/catalina/realm/RealmBase.java"

    private SecurityConstraint [] resultsToArray(
            ArrayList<SecurityConstraint> results) {
======= 0ea4c7c:"java/org/apache/catalina/realm/RealmBase.java"

        // We want logger as soon as possible
        if (container != null) {
            this.containerLog = container.getLogger();
        }
      <fix>
         <bug>39875</bug>: Fix BPE in RealmBase.init(). Port of yoavs's fix from
         Tomcat 5. (markt)
      </fix>

======= 5e188bc:"java/org/apache/jasper/compiler/Node.java"

======= 5e188bc:"java/org/apache/jasper/compiler/Node.java"

            if (temporaryVariableName == null) {
                temporaryVariableName = JspUtil.nextTemporaryVariableName();
            }
  <subsection name="Jasper">
    <changelog>
      <fix>
        <bug>42438</bug> Duplicate temporary variables were created when
        jsp:attribute was used in conjunction with custom tags. Patch provided
        by Brian Lenz. (markt)
      </fix>
    </changelog>
  </subsection>

======= 33c9949:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "</tr>\n<tr></tr>\n";
======= 33c9949:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "</tr>\n<tr></tr>\n";
======= 33c9949:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        "</tr>\n<tr></tr>\n";
  <subsection name="Webapps">
    <changelog>
      <fix>
         <bug>42459</bug>: Tomcat Web Application Manager table error (rjung)
      </fix>
    </changelog>
  </subsection>

======= 776736f:"java/org/apache/catalina/valves/AccessLogValve.java"

         <bug>42444</bug>: prevent NPE 
         Patch provided by Nils Hammar (funkman)
      </fix>
      <fix>

======= 637acc5:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

                
                //If no content type specified, use default for POST
                String savedContentType = saved.getContentType();
                if (savedContentType == null) {
                    savedContentType = "application/x-www-form-urlencoded";
                }
                contentType.setString(savedContentType);
======= 637acc5:"java/org/apache/catalina/authenticator/FormAuthenticator.java"

            saved.setContentType(request.getContentType());
======= 637acc5:"java/org/apache/catalina/authenticator/SavedRequest.java"

    
    /**
     * The content type of the request, used if this is a POST.
     */
    private String contentType = null;
    
    public String getContentType() {
        return (this.contentType);
    }
    
    public void setContentType(String contentType) {
        this.contentType = contentType;
    }
  <subsection name="Catalina">
    <changelog>
      <fix>
         <bug>42361</bug>: Handle multi-part forms when saving requests during
         FORM authentication process. Patch provided by Peter Runge. (markt)
      </fix>
    </changelog>
  </subsection>

======= 9546005:"java/org/apache/catalina/startup/Embedded.java"

                connector.setProperty("SSLEnabled","true");
            } else {
                connector = new Connector(protocol);

======= 4a04722:"java/org/apache/coyote/http11/Http11AprProcessor.java"

            if (!comet) {
                // Next request
                inputBuffer.nextRequest();
                outputBuffer.nextRequest();
            }
            
======= 4a04722:"java/org/apache/coyote/http11/Http11AprProcessor.java"

======= 4a04722:"java/org/apache/coyote/http11/Http11AprProtocol.java"

======= 4a04722:"java/org/apache/coyote/http11/Http11NioProcessor.java"

            if (!comet) {
                // Next request
                inputBuffer.nextRequest();
                outputBuffer.nextRequest();
            }
======= 4a04722:"java/org/apache/coyote/http11/Http11NioProcessor.java"

======= 4a04722:"java/org/apache/coyote/http11/InternalNioInputBuffer.java"


======= f9ddaba:"java/org/apache/catalina/startup/TldConfig.java"

======= f9ddaba:"java/org/apache/catalina/startup/TldConfig.java"

        File file = null;
        try {
            file = new File(url.toURI());
        } catch (URISyntaxException e) {
            // Ignore, probably an unencoded char
            file = new File(url.getFile());
        }
        try {
            file = file.getCanonicalFile();
        } catch (IOException e) {
            // Ignore
        }
======= f9ddaba:"java/org/apache/catalina/startup/TldConfig.java"

                    // Expect file URLs, these are %xx encoded or not depending on
                    // the class loader
                    File file = null;
                    try {
                        file = new File(urls[i].toURI());
                    } catch (URISyntaxException e) {
                        // Ignore, probably an unencoded char
                        file = new File(urls[i].getFile());
                    }

======= 508f513:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                if (available > System.currentTimeMillis()) {
                    response.setDateHeader("Retry-After", available);
                    response.sendError
                        (HttpServletResponse.SC_SERVICE_UNAVAILABLE,
                         Localizer.getMessage("jsp.error.unavailable"));
                    return;
                } else {
                    // Wait period has expired. Reset.
                    available = 0;
                }
      <fix>
        <bug>42071</bug> Fix IllegalStateException on multiple requests to
        an unavailable JSP. Patch provided by Kawasima Kazuh. (markt)
      </fix>
      <fix>
        After a JSP throws an UnavailableException allow it to be accessed once
        the unavailable period has expired. (markt)
      </fix>

======= c3d2ce4:"java/org/apache/catalina/core/StandardWrapperValve.java"

======= c3d2ce4:"java/org/apache/catalina/core/StandardWrapperValve.java"

======= c3d2ce4:"java/org/apache/catalina/core/StandardWrapperValve.java"

            container.getLogger().error(
                    sm.getString("standardWrapper.allocateException",
                            wrapper.getName()), e);

======= 4cf171a:"java/org/apache/tomcat/util/http/ContentType.java"

    /**
     * Parse the character encoding from the specified content type header.
     * If the content type is null, or there is no explicit character encoding,
     * <code>null</code> is returned.
     *
     * @param contentType a content type header
     */
    public static String getCharsetFromContentType(String contentType) {
        if (contentType == null)
            return (null);
        int start = contentType.indexOf("charset=");
        if (start < 0)
            return (null);
        String encoding = contentType.substring(start + 8);
        int end = encoding.indexOf(';');
        if (end >= 0)
            encoding = encoding.substring(0, end);
        encoding = encoding.trim();
        if ((encoding.length() > 2) && (encoding.startsWith("\""))
            && (encoding.endsWith("\"")))
            encoding = encoding.substring(1, encoding.length() - 1);
        return (encoding.trim());
      <fix>
        <bug>42119</bug> Fix return value for request.getCharacterEncoding() when
        Content-Type headers contain parameters other than charset. Patch by
        Leigh L Klotz Jr. (markt)
      </fix>

======= fa2b746:"java/org/apache/juli/ClassLoaderLogManager.java"


======= 3d27771:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                    Servlet servlet = null;
                    
                        servlet = (Servlet) servletClass.newInstance();
                           annotationProcessor.processAnnotations(servlet);
                           annotationProcessor.postConstruct(servlet);
======= 3d27771:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                    servlet.init(config);
                    theServlet = servlet;
      <fix>
        <bug>42072</bug> Don't call destroy() if the associated init() fails.
        Patch provided by Kawasima Kazuh. (markt)
      </fix>

======= d721522:"java/org/apache/catalina/manager/ManagerServlet.java"

                        configBase.mkdirs();

======= 2049b78:"java/org/apache/catalina/ha/authenticator/SingleSignOnMessage.java"

        <bug>41703</bug> SingleSignOnMessage invalid setter, patch provided by Nils Hammar (fhanik)
      </fix>
      <fix>

======= 12d912d:"java/org/apache/catalina/ha/session/DeltaSession.java"

                                       ((ClusterManager)manager).getName(), 
        <bug>41682</bug> ClassCastException when logging is turned on (fhanik)
      </fix>
      <fix>

======= 4f96d21:"java/org/apache/catalina/core/ApplicationContext.java"

    protected StandardContext getContext() {
        return this.context;
    }
    
    protected Map getReadonlyAttributes() {
        return this.readOnlyAttributes;
    }
    protected void clearAttributes() {
======= 4f96d21:"java/org/apache/catalina/ha/context/ReplicatedContext.java"

======= 4f96d21:"java/org/apache/catalina/ha/context/ReplicatedContext.java"

        if (context == null) {
            context = new ReplApplContext(getBasePath(), this);
            if (getAltDDName() != null)
                context.setAttribute(Globals.ALT_DD_ATTR,getAltDDName());
        }
======= 4f96d21:"java/org/apache/catalina/ha/context/ReplicatedContext.java"

        
        public void removeAttribute(String name) {
            //do nothing
            super.removeAttribute(name);
        }
        
        public void setAttribute(String name, Object value) {
            //do nothing
            super.setAttribute(name,value);
        }
        
======= 4f96d21:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        return remove(key,true);
    }
    public Object remove(Object key, boolean notify) {
            if (getMapMembers().length > 0 && notify) {
======= 4f96d21:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

        
            clear(true);
        }
    
        public void clear(boolean notify) {
            if ( notify ) {
                //only delete active keys
                Iterator keys = keySet().iterator();
                while (keys.hasNext())
                    remove(keys.next());
            } else {
                super.clear();
            }
======= 4f96d21:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Object key = e.getKey();
                MapEntry entry = (MapEntry)super.get(key);
                if ( entry.isPrimary() ) set.add(entry.getValue());
======= 4f96d21:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

                Object key = e.getKey();
                MapEntry entry = (MapEntry)super.get(key);
                if ( entry.isPrimary() ) set.add(key);
======= 4f96d21:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            this.value = value;
======= 4f96d21:"java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java"

            this.key = key;

======= 7fd4fa8:"java/org/apache/coyote/http11/Http11Processor.java"

            if (log.isDebugEnabled()) {
                log.debug(sm.getString("http11processor.request.prepare")+
                          " Unsupported HTTP version \""+protocolMB+"\"");
            }
======= 7fd4fa8:"java/org/apache/coyote/http11/Http11Processor.java"

                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("http11processor.request.prepare")+
                              " Unsupported transfer encoding \""+encodingName+"\"");
                }
======= 7fd4fa8:"java/org/apache/coyote/http11/Http11Processor.java"

            if (log.isDebugEnabled()) {
                log.debug(sm.getString("http11processor.request.prepare")+
                          " host header missing");
            }
      <add>
        <bug>41675</bug> Add a couple of DEBUG-level logging statements to Http11Processors
          when sending error responses.  Patch by Ralf Hauser. (yoavs)
      </add>

======= 400d684:"java/org/apache/catalina/realm/JAASRealm.java"

    protected List<String> roleClasses = new ArrayList<String>();
======= 400d684:"java/org/apache/catalina/realm/JAASRealm.java"

    protected List<String> userClasses = new ArrayList<String>();
======= 400d684:"java/org/apache/catalina/realm/JAASRealm.java"

     /**
      * Comma-delimited list of <code>java.security.Principal</code> classes
      * that represent security roles.
      */
     protected String roleClassNames = null;
     
     public String getRoleClassNames() {
         return (this.roleClassNames);
     }
     
======= 400d684:"java/org/apache/catalina/realm/JAASRealm.java"

         parseClassNames(roleClassNames, roleClasses);
     }
     
     /**
      * Parses a comma-delimited list of class names, and store the class names
      * in the provided List. Each class must implement <codejava.security.Principal</code>.
      * 
      * @param classNamesString a comma-delimited list of fully qualified class names.
      * @param classNamesList the list in which the class names will be stored.
      *        The list is cleared before being populated. 
      */
     protected void parseClassNames(String classNamesString, List<String> classNamesList) {
         classNamesList.clear();
         if (classNamesString == null) return;
         
         String[] classNames = classNamesString.split("[ ]*,[ ]*");
         for (int i=0; i<classNames.length; i++) {
             if (classNames[i].length()==0) continue;        
             try {
                 Class principalClass = Class.forName(classNames[i]);
                 if (Principal.class.isAssignableFrom(principalClass)) {
                     classNamesList.add(classNames[i]);
                 } else {
                     log.error("Class "+classNames[i]+" is not implementing "+
                               "java.security.Principal! Class not added.");
                 }
             } catch (ClassNotFoundException e) {
                 log.error("Class "+classNames[i]+" not found! Class not added.");
             }
         }
     }     
     
     /**
      * Comma-delimited list of <code>java.security.Principal</code> classes
      * that represent individual users.
      */
     protected String userClassNames = null;
     
     public String getUserClassNames() {
         return (this.userClassNames);
     }
     
======= 400d684:"java/org/apache/catalina/realm/JAASRealm.java"

        parseClassNames(userClassNames, userClasses);
======= 400d684:"java/org/apache/catalina/realm/JAASRealm.java"

        List<String> roles = new ArrayList<String>();
      <fix>
        <bug>40150</bug> Ensure user and roll classnames are validated on startup.  Patch by
          Tom. (yoavs)
      </fix>

======= 455b6f8:"java/org/apache/jasper/compiler/JDTCompiler.java"

                FileInputStream is = null;
                    is = new FileInputStream(sourceFile);
                    Reader reader = 
                        new BufferedReader(new InputStreamReader(is, ctxt.getOptions().getJavaEncoding()));
======= 455b6f8:"java/org/apache/jasper/compiler/JDTCompiler.java"

                } finally {
                    if (is != null) {
                        try {
                            is.close();
                        } catch (IOException exc) {
                            // Ignore
                        }
                    }

======= e33b67a:"java/org/apache/catalina/realm/MemoryRealm.java"

            throw new LifecycleException
                (sm.getString("memoryRealm.readXml"), e);
      <fix>
        <bug>41752</bug> Correct error message on exception in MemoryRealm.
        (markt)
      </fix>

======= 9ac3428:"java/org/apache/catalina/servlets/DefaultServlet.java"

                    && (lastModified < headerValue + 1000)) {
======= 9ac3428:"java/org/apache/catalina/servlets/DefaultServlet.java"

                if ( lastModified >= (headerValue + 1000)) {
        <bug>41666</bug> Correct handling of boundary conditions for
        If-Unmodified-Since and If-Modified-Since headers. Patch provided by
        Suzuki Yuichiro. (markt)
      </fix>
      <fix>
      <fix>
        Requests with multiple content-length headers are now rejected. (markt)
      </fix>

======= 01d38a5:"java/org/apache/catalina/core/StandardContext.java"

      <fix>
        <bug>41739</bug> Correct handling of servlets with a load-on-startup
        value of zero. These are now the first servlets to be started. (markt)
      </fix>

======= 8ba8334:"java/org/apache/catalina/core/StandardWrapperValve.java"

            container.getLogger().error(sm.getString("standardWrapper.serviceException",
            container.getLogger().error(sm.getString("standardWrapper.serviceException",
======= 8ba8334:"java/org/apache/catalina/core/StandardWrapperValve.java"

            container.getLogger().error(sm.getString("standardWrapper.serviceException",
            container.getLogger().error(sm.getString("standardWrapper.serviceException",
      <fix>
        <bug>41608</bug> Make log levels consistent when Servlet.service()
        throws an exception. (markt)
      </fix>

======= 4612c8a:"java/org/apache/jasper/runtime/JspFactoryImpl.java"

    private static final int POOL_SIZE = 
        Integer.valueOf(System.getProperty("org.apache.jasper.runtime.JspFactoryImpl.POOL_SIZE", "8")).intValue();
    private ThreadLocal<PageContextPool> localPool = new ThreadLocal<PageContextPool>();
======= 4612c8a:"java/org/apache/jasper/runtime/JspFactoryImpl.java"

            if (USE_POOL) {
                PageContextPool pool = localPool.get();
                if (pool == null) {
                    pool = new PageContextPool();
                    localPool.set(pool);
                }
                pc = pool.get();
                if (pc == null) {
======= 4612c8a:"java/org/apache/jasper/runtime/JspFactoryImpl.java"

            localPool.get().put(pc);
======= 4612c8a:"java/org/apache/jasper/runtime/JspFactoryImpl.java"

    protected final class PageContextPool  {
        private PageContext[] pool;
        private int current = -1;
        public PageContextPool() {
            this.pool = new PageContext[POOL_SIZE];
        }
        public void put(PageContext o) {
            if (current < (POOL_SIZE - 1)) {
                current++;
                pool[current] = o;
            }
        }
        public PageContext get() {
            PageContext item = null;
            if (current >= 0) {
                item = pool[current];
                current--;
            }
            return item;
        }
    }

======= 1a8c492:"java/org/apache/jasper/compiler/Generator.java"

        out.print(" = _jspxFactory.getJspApplicationContext(");
======= 1a8c492:"java/org/apache/jasper/compiler/Generator.java"

        out.printil("private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();");
        out.println();
======= 1a8c492:"java/org/apache/jasper/compiler/Generator.java"

======= 1a8c492:"java/org/apache/jasper/compiler/Generator.java"

======= 1a8c492:"java/org/apache/jasper/compiler/Generator.java"

                .printil("_jspxFactory.releasePageContext(_jspx_page_context);");
======= 1a8c492:"java/org/apache/jasper/compiler/JspRuntimeContext.java"

        if( System.getSecurityManager() != null ) {
            String basePackage = "org.apache.jasper.";
            try {
                factory.getClass().getClassLoader().loadClass( basePackage +
                                                               "runtime.JspFactoryImpl$PrivilegedGetPageContext");
                factory.getClass().getClassLoader().loadClass( basePackage +
                                                               "runtime.JspFactoryImpl$PrivilegedReleasePageContext");
                factory.getClass().getClassLoader().loadClass( basePackage +
                                                               "runtime.JspRuntimeLibrary");
                factory.getClass().getClassLoader().loadClass( basePackage +
                                                               "runtime.JspRuntimeLibrary$PrivilegedIntrospectHelper");
                factory.getClass().getClassLoader().loadClass( basePackage +
                                                               "runtime.ServletResponseWrapperInclude");
                factory.getClass().getClassLoader().loadClass( basePackage +
                                                               "servlet.JspServletWrapper");
            } catch (ClassNotFoundException ex) {
                throw new IllegalStateException(ex);
            }
        }
======= 1a8c492:"java/org/apache/jasper/runtime/HttpJspBase.java"


======= 8b0d130:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

        if (filterMap.getMatchAllUrlPatterns())
======= 8b0d130:"java/org/apache/catalina/core/ApplicationFilterFactory.java"

        }
        // Check the specific "*" special servlet name
        else if (filterMap.getMatchAllServletNames()) {
            return (true);
======= 8b0d130:"java/org/apache/catalina/deploy/FilterMap.java"

        if ("*".equals(servletName)) {
            this.matchAllServletNames = true;
        } else {
            String[] results = new String[servletNames.length + 1];
            System.arraycopy(servletNames, 0, results, 0, servletNames.length);
            results[servletNames.length] = servletName;
            servletNames = results;
        }
     * The flag that indicates this mapping will match all url-patterns
    private boolean matchAllUrlPatterns = false;
    public boolean getMatchAllUrlPatterns() {
        return matchAllUrlPatterns;
     * The flag that indicates this mapping will match all servlet-names
     */
    private boolean matchAllServletNames = false;
    
    public boolean getMatchAllServletNames() {
        return matchAllServletNames;
    }
    
    /**
======= 8b0d130:"java/org/apache/catalina/deploy/FilterMap.java"

            this.matchAllUrlPatterns = true;

======= fce171f:"java/org/apache/tomcat/util/net/NioSelectorPool.java"

        if ( socket.getBufHandler().getWriteBuffer()!= buf ) {
            socket.getBufHandler().getWriteBuffer().put(buf);
            buf = socket.getBufHandler().getWriteBuffer();
        }

      <fix>
        <bug>39572</bug>: Improvements to CompressionFilter example provided by
        Eric Hedstrm. (markt)
      </fix>
======= f06d41f:"webapps/examples/WEB-INF/classes/compressionFilters/CompressionFilterTestServlet.java"

======= f06d41f:"webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java"

    protected OutputStream gzipstream = null;
======= f06d41f:"webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java"

            if (response.isCommitted()) {
                if (debug > 1)
                    System.out.print("Response already committed. Using original output stream");
                gzipstream = output;
            } else {
                response.addHeader("Content-Encoding", "gzip");
                gzipstream = new GZIPOutputStream(output);
            }
======= f06d41f:"webapps/examples/WEB-INF/classes/compressionFilters/CompressionServletResponseWrapper.java"

======= f06d41f:"webapps/examples/WEB-INF/classes/compressionFilters/CompressionServletResponseWrapper.java"


======= 39fe247:"java/org/apache/jasper/EmbeddedServletOptions.java"

        <bug>41265</bug>: Allow JspServlet checkInterval init parameter to be
        explicitly set to the stated default value of zero by removing the
        code that resets it to 300 if explicitly specified as zero. (markt)
      </fix>
      <fix>

======= dc33554:"java/org/apache/catalina/authenticator/Constants.java"

    public static final String CERT_METHOD = "CLIENT_CERT";
======= dc33554:"java/org/apache/catalina/authenticator/Constants.java"

     *     will return BASIC, CLIENT_CERT, DIGEST, FORM, or <code>null</code>
======= dc33554:"java/org/apache/catalina/authenticator/SSLAuthenticator.java"

        // BASIC or FORM, which are less secure than the CLIENT_CERT auth-type
======= dc33554:"java/org/apache/catalina/authenticator/SingleSignOn.java"

     * following DIGEST or CLIENT_CERT authentication) to be updated with
======= dc33554:"java/org/apache/catalina/authenticator/SingleSignOn.java"

     * @param authType  the type of authenticator used (BASIC, CLIENT_CERT,
======= dc33554:"java/org/apache/catalina/authenticator/SingleSignOnEntry.java"

     * @param authType  the type of authenticator used (BASIC, CLIENT_CERT,
======= dc33554:"java/org/apache/catalina/authenticator/SingleSignOnEntry.java"

     * @return "BASIC", "CLIENT_CERT", "DIGEST", "FORM" or "NONE"
======= dc33554:"java/org/apache/catalina/authenticator/SingleSignOnEntry.java"

     * @param authType  the type of authenticator used (BASIC, CLIENT_CERT,
      <fix>
        <bug>40524</bug>: HttpServletRequest.getAuthType() now returns
        CLIENT_CERT rather than CLIENT-CERT for certificate authentication
        as per the spec. Note that web.xml continues to use CLIENT-CERT to
        specify the certificate authentication should be used. (markt)
      </fix>

======= 11b9c92:"java/org/apache/catalina/authenticator/AuthenticatorBase.java"

            // Bugzilla 41217
            cookie.setSecure(request.isSecure());
      <fix>
        <bug>41217</bug>: Set secure attribute on SSO cookie when cookie is
        created during a secure request. Patch provided by Chris Halstead.
        (markt)
      </fix>

======= 3a6225a:"java/org/apache/jasper/servlet/JspServlet.java"

                                           request.getRequestURI());
      <fix>
        <bug>41327</bug>: Show full URI for a 404. Patch provided by Vijay.
        (markt)
      </fix>

======= a1b1bed:"java/org/apache/catalina/core/JasperListener.java"

 *
 *
======= a1b1bed:"java/org/apache/catalina/core/JasperListener.java"

======= a1b1bed:"java/org/apache/catalina/core/JasperListener.java"

                Class.forName("org.apache.jasper.compiler.JspRuntimeContext",
                              true,
                              this.getClass().getClassLoader());

======= 5f9c18d:"java/org/apache/jasper/compiler/Generator.java"

                        // out.println( "<param name=\"blah\"
                        out.printil("out.write( \"<param name=\\\""
======= 5f9c18d:"java/org/apache/jasper/compiler/Generator.java"

            // <object ...>
            String s0 = "<object"
======= 5f9c18d:"java/org/apache/jasper/compiler/Generator.java"

            // <param > for java_code
            s0 = "<param name=\"java_code\"" + makeAttr("value", code) + '>';
            // <param > for java_codebase
                s0 = "<param name=\"java_codebase\""
            // <param > for java_archive
                s0 = "<param name=\"java_archive\""
            // <param > for type
            s0 = "<param name=\"type\""
======= 5f9c18d:"java/org/apache/jasper/compiler/Generator.java"

             * generate a <param> for each <jsp:param> in the plugin body
======= 5f9c18d:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("out.write(" + quote("<comment>") + ");");
======= 5f9c18d:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("out.write(" + quote("<noembed>") + ");");
======= 5f9c18d:"java/org/apache/jasper/compiler/Generator.java"

            out.printil("out.write(" + quote("</noembed>") + ");");
            out.printil("out.write(" + quote("</comment>") + ");");
            out.printil("out.write(" + quote("</object>") + ");");
  <subsection name="Jasper">
    <changelog>
      <fix>
        <bug>41057</bug>: Make jsp:plugin output XHTML compliant. (markt)
      </fix>
    </changelog>
  </subsection>

======= c6b3f71:"java/org/apache/juli/FileHandler.java"

        this(null, null, null);
        configure();
        open();
======= c6b3f71:"java/org/apache/juli/FileHandler.java"

        if (directory == null)
            directory = getProperty(className + ".directory", "logs");
        if (prefix == null)
            prefix = getProperty(className + ".prefix", "juli.");
        if (suffix == null)
            suffix = getProperty(className + ".suffix", ".log");
  <subsection name="Catalina">
    <changelog>
      <fix>
        <bug>40585</bug>: Fix parameterised constructor for o.a.juli.FileHandler
        so parameters have an effect. (markt)
      </fix>
    </changelog>
  </subsection>

======= 514256e:"java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java"

    private static final String JSP_VERSION = "2.1";
======= 514256e:"java/org/apache/jasper/compiler/PageDataImpl.java"

    private static final String JSP_VERSION = "2.1";
======= 514256e:"java/org/apache/jasper/compiler/Validator.java"

            if (!version.equals("1.2") && !version.equals("2.0") && !version.equals("2.1")) {

======= de5c3b7:"java/org/apache/tomcat/util/buf/StringCache.java"

    protected static int maxStringSize = 
        Integer.parseInt(System.getProperty("tomcat.util.buf.StringCache.maxStringSize", "128"));
    
   /**
======= de5c3b7:"java/org/apache/tomcat/util/buf/StringCache.java"

            if (byteEnabled && (value.length() < maxStringSize)) {
======= de5c3b7:"java/org/apache/tomcat/util/buf/StringCache.java"

            if (charEnabled && (value.length() < maxStringSize)) {

======= b70962f:"java/org/apache/catalina/servlets/CGIServlet.java"

            // If the request method is GET, POST or HEAD and the query string
            // does not contain an unencoded "=" this is an indexed query.
            // The parsed query string becomes the command line parameters
            // for the cgi command.
            if (req.getMethod().equals("GET")
                || req.getMethod().equals("POST")
                || req.getMethod().equals("HEAD")) {
                String qs = req.getQueryString();
                if (qs != null && qs.indexOf("=") == -1) {
                    StringTokenizer qsTokens = new StringTokenizer(qs, "+");
                    while ( qsTokens.hasMoreTokens() ) {
                        cmdLineParameters.add(URLDecoder.decode(qsTokens.nextToken(),
                                              parameterEncoding));
                    }
                }
        <bug>41008</bug>: Allow POST to be used for indexed queries with CGI
        Servlet. Patch provided by Chris Halstead. (markt)
      </fix>
      <fix>

======= cb2c655:"java/org/apache/catalina/servlets/DefaultServlet.java"

======= cb2c655:"java/org/apache/catalina/servlets/DefaultServlet.java"

                sb.append(RequestUtil.filter(trimmed));
======= cb2c655:"java/org/apache/catalina/servlets/DefaultServlet.java"

                sb.append(RequestUtil.filter(trimmed));
       <fix>
        <bug>40901</bug>: Encode directory listing output. Based on a patch
        provided by Chris Halstead. (markt)
      </fix>

======= 6009702:"java/org/apache/catalina/loader/StandardClassLoader.java"

 * Subclass implementation of <b>java.net.URLClassLoader</b>. There are no
 * functional differences between this class and <b>java.net.URLClassLoader</b>.
        <bug>37509</bug>: Do not remove whitespace from the end of values
        defined in logging.properties files. (markt)
      </fix>
      <fix>
        <bug>40929</bug>: Correct JavaDoc for StandardClassLoader. (markt)
        (markt)

======= e713e77:"java/org/apache/catalina/connector/Request.java"

                context.getLogger().warn(
                        sm.getString("coyoteRequest.parseParameters"), t);
======= e713e77:"java/org/apache/tomcat/util/http/Parameters.java"

                log.warn("Parameters: Invalid chunk ignored.");
======= e713e77:"java/org/apache/tomcat/util/http/Parameters.java"

                log.warn("Parameters: Character decoding failed. " + 
                         "Parameter skipped.", e);
      <fix>
        <bug>40860</bug>: Log exceptions and other problems during parameter
        processing. (markt)
      </fix>

======= a6d6962:"java/org/apache/juli/ClassLoaderLogManager.java"

        String result = str;
      <fix>
        <bug>37509</bug>: Do not remove whitespace from the end of values
        defined in logging.properties files. (markt)
      </fix>

======= be9d523:"java/org/apache/catalina/realm/JDBCRealm.java"

======= be9d523:"java/org/apache/catalina/realm/JDBCRealm.java"

    protected synchronized String getPassword(String username) {
======= be9d523:"java/org/apache/catalina/realm/JDBCRealm.java"

    protected synchronized PreparedStatement roles(Connection dbConnection,
            String username)
  <subsection name="General">
    <changelog>
    </changelog>
  </subsection>
  <subsection name="Catalina">
    <changelog>
      <fix>
        <bug>40844</bug> Missing syncs in JDBCRealm. (markt)
      </fix>
    </changelog>
  </subsection>
  <subsection name="Coyote">
    <changelog>
    </changelog>
  </subsection> 

======= f7ca96d:"java/org/apache/jasper/compiler/Validator.java"

                                if (!deferred && !tldAttrs[j].canBeRequestTime()) {

======= 22d1ad7:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        if (Globals.STRICT_SERVLET_COMPLIANCE) {
            // Check SRV.8.2 / SRV.14.2.5.1 compliance
            checkSameObjects();
        }
======= 22d1ad7:"java/org/apache/catalina/core/ApplicationDispatcher.java"

        if (Globals.STRICT_SERVLET_COMPLIANCE) {
            // Check SRV.8.2 / SRV.14.2.5.1 compliance
            checkSameObjects();
        }
        
======= 22d1ad7:"java/org/apache/catalina/core/ApplicationDispatcher.java"

    private void checkSameObjects() throws ServletException {
        ServletRequest originalRequest =
            ApplicationFilterChain.getLastServicedRequest();
        ServletResponse originalResponse =
            ApplicationFilterChain.getLastServicedResponse();
        
        // Some forwards, eg from valves will not set original values 
        if (originalRequest == null || originalResponse == null) {
            return;
        }
        
        boolean same = false;
        ServletRequest dispatchedRequest = appRequest;
        
        while (!same) {
            if (originalRequest.equals(dispatchedRequest)) {
                same = true;
            }
            if (!same && dispatchedRequest instanceof ServletRequestWrapper) {
                dispatchedRequest =
                    ((ServletRequestWrapper) dispatchedRequest).getRequest();
            } else {
                break;
            }
        }
        if (!same) {
            throw new ServletException(sm.getString(
                    "applicationDispatcher.specViolation.request"));
        }
        
        same = false;
        ServletResponse dispatchedResponse = appResponse;
        
        while (!same) {
            if (originalResponse.equals(dispatchedResponse)) {
                same = true;
            }
            
            if (!same && dispatchedResponse instanceof ServletResponseWrapper) {
                dispatchedResponse =
                    ((ServletResponseWrapper) dispatchedResponse).getResponse();
            } else {
                break;
            }
        }
        if (!same) {
            throw new ServletException(sm.getString(
                    "applicationDispatcher.specViolation.response"));
        }
    }
======= 22d1ad7:"java/org/apache/catalina/core/ApplicationFilterChain.java"

======= 22d1ad7:"java/org/apache/catalina/core/ApplicationFilterChain.java"

    // Used to enforce requirements of SRV.8.2 / SRV.14.2.5.1
    private final static ThreadLocal lastServicedRequest;
    private final static ThreadLocal lastServicedResponse;
    static {
        if (Globals.STRICT_SERVLET_COMPLIANCE) {
            lastServicedRequest = new ThreadLocal();
            lastServicedResponse = new ThreadLocal();
        } else {
            lastServicedRequest = null;
            lastServicedResponse = null;
        }
    }
======= 22d1ad7:"java/org/apache/catalina/core/ApplicationFilterChain.java"

            if (Globals.STRICT_SERVLET_COMPLIANCE) {
                lastServicedRequest.set(request);
                lastServicedResponse.set(response);
            }
======= 22d1ad7:"java/org/apache/catalina/core/ApplicationFilterChain.java"

        } finally {
            if (Globals.STRICT_SERVLET_COMPLIANCE) {
                lastServicedRequest.set(null);
                lastServicedResponse.set(null);
            }
======= 22d1ad7:"java/org/apache/catalina/core/ApplicationFilterChain.java"

    
    /**
     * The last request passed to a servlet for servicing from the current
     * thread.
     * 
     * @return The last request to be serviced. 
     */
    public static ServletRequest getLastServicedRequest() {
        return (ServletRequest) lastServicedRequest.get();
    }
    
    /**
     * The last response passed to a servlet for servicing from the current
     * thread.
     * 
     * @return The last response to be serviced. 
     */
    public static ServletResponse getLastServicedResponse() {
        return (ServletResponse) lastServicedResponse.get();
    }
    
    

======= 6d274b4:"java/org/apache/catalina/servlets/CGIServlet.java"

                cginame = (currentLocation.getParent() + File.separator).
                        substring(webAppRootDir.length()) + name;
======= 6d274b4:"java/org/apache/catalina/servlets/CGIServlet.java"

            envp.put("SCRIPT_FILENAME", command);  //for PHP

======= 79631bb:"java/org/apache/catalina/loader/WebappClassLoader.java"

        synchronized (entry) {
            // Looking up the package
            String packageName = null;
            int pos = name.lastIndexOf('.');
            if (pos != -1)
                packageName = name.substring(0, pos);
        
            Package pkg = null;
        
            if (packageName != null) {
                synchronized (this) {
                    pkg = getPackage(packageName);
            
                    // Define the package (if null)
                    if (pkg == null) {
                        if (entry.manifest == null) {
                            definePackage(packageName, null, null, null, null,
                                    null, null, null);
                        } else {
                            definePackage(packageName, entry.manifest,
                                    entry.codeBase);
                        }
                    }
    
            if (securityManager != null) {
                // Checking sealing
                if (pkg != null) {
                    boolean sealCheck = true;
                    if (pkg.isSealed()) {
                        sealCheck = pkg.isSealed(entry.codeBase);
                    } else {
                        sealCheck = (entry.manifest == null)
                            || !isPackageSealed(packageName, entry.manifest);
                    }
                    if (!sealCheck)
                        throw new SecurityException
                            ("Sealing violation loading " + name + " : Package "
                             + packageName + " is sealed.");
    
                        new CodeSource(entry.codeBase, entry.certificates));

======= 9cb5aff:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

======= 9cb5aff:"java/org/apache/catalina/valves/JDBCAccessLogValve.java"

 * INDEX (timestamp),

======= 17eecdb:"java/org/apache/coyote/http11/filters/SavedRequestInputFilter.java"

        if(input.getOffset()>= input.getEnd())
            return -1;
        

======= b18c29e:"java/org/apache/catalina/core/StandardPipeline.java"

        if (first == basic) first = null;

======= 1a5e6e7:"java/org/apache/catalina/deploy/NamingResources.java"

            if (findEnvironment(environment.getName()).getOverride()) {
                removeEnvironment(environment.getName());
            } else {
                return;
            }
        
        entries.put(environment.getName(), environment.getType());

======= bbb8fe1:"java/org/apache/catalina/servlets/CGIServlet.java"

                throw e;

======= fda223a:"java/org/apache/catalina/core/StandardContextValve.java"

                    container.getLogger().error(sm.getString("standardContext.requestListener.requestInit",
======= fda223a:"java/org/apache/catalina/core/StandardContextValve.java"

                    container.getLogger().error(sm.getString("standardContext.requestListener.requestDestroy",
======= fda223a:"java/org/apache/catalina/core/StandardContextValve.java"


======= 9dd8a23:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

        boolean isDeployed = true;
======= 9dd8a23:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                try {
                    isDeployed = isDeployed(contextPath);
                } catch (Exception e) {
                    // Assume false on failure for safety
                    isDeployed = false;
                }
                
======= 9dd8a23:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

                } else if (context.getAvailable() && isDeployed) {
                    writer.print(MessageFormat.format(
                        STARTED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args));
                } else if (context.getAvailable() && !isDeployed) {
                        STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args));
                } else if (!context.getAvailable() && isDeployed) {
                    writer.print(MessageFormat.format(
                        STOPPED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args));
                        STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args));
======= 9dd8a23:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    private static final String STARTED_DEPLOYED_APPS_ROW_BUTTON_SECTION =
======= 9dd8a23:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    private static final String STOPPED_DEPLOYED_APPS_ROW_BUTTON_SECTION =
======= 9dd8a23:"java/org/apache/catalina/manager/HTMLManagerServlet.java"

    private static final String STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION =
        " <td class=\"row-left\" bgcolor=\"{8}\">\n" +
        "  <small>\n" +
        "  &nbsp;{1}&nbsp;\n" +
        "  &nbsp;<a href=\"{2}\" onclick=\"return(confirm('''Are you sure?'''))\">{3}</a>&nbsp;\n" +
        "  &nbsp;<a href=\"{4}\" onclick=\"return(confirm('''Are you sure?'''))\">{5}</a>&nbsp;\n" +
        "  &nbsp;{7}&nbsp;\n" +
        "  </small>\n" +
        " </td>\n" +
        "</tr>\n";
    private static final String STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION =
        " <td class=\"row-left\" bgcolor=\"{8}\">\n" +
        "  <small>\n" +
        "  &nbsp;<a href=\"{0}\" onclick=\"return(confirm('''Are you sure?'''))\">{1}</a>&nbsp;\n" +
        "  &nbsp;{3}&nbsp;\n" +
        "  &nbsp;{5}&nbsp;\n" +
        "  &nbsp;{7}&nbsp;\n" +
        "  </small>\n" +
        " </td>\n" +
        "</tr>\n";
======= 9dd8a23:"java/org/apache/catalina/manager/ManagerServlet.java"

            if (!isDeployed(path)) {
                writer.println(sm.getString("managerServlet.notDeployed",
                        RequestUtil.filter(displayPath)));
                return;
            }
======= 9dd8a23:"java/org/apache/catalina/manager/ManagerServlet.java"

     * Invoke the isDeployed method on the deployer.
     */
    protected boolean isDeployed(String name) 
        throws Exception {
        String[] params = { name };
        String[] signature = { "java.lang.String" };
        Boolean result = 
            (Boolean) mBeanServer.invoke(oname, "isDeployed", params, signature);
        return result.booleanValue();
    }
    
    /**
======= 9dd8a23:"java/org/apache/catalina/manager/ManagerServlet.java"

     * Invoke the isServiced method on the deployer.
======= 9dd8a23:"java/org/apache/catalina/manager/ManagerServlet.java"

     * Invoke the addServiced method on the deployer.
======= 9dd8a23:"java/org/apache/catalina/manager/ManagerServlet.java"

     * Invoke the removeServiced method on the deployer.
======= 9dd8a23:"java/org/apache/catalina/startup/HostConfig.java"

    /**
     * Has the specified application been deployed? Note applications defined
     * in server.xml will not have been deployed.
     * @return <code>true</code> if the application has been deployed and
     * <code>false</code> if the applciation has not been deployed or does not
     * exist
     */
    public boolean isDeployed(String name) {
        DeployedApplication app = (DeployedApplication) deployed.get(name);
        if (app == null) {
            return false;
        } else {
            return true;
        }
    }
    
    
======= 9dd8a23:"java/org/apache/catalina/startup/HostConfig.java"

    <operation name="isDeployed"
               description="Was this web application deployed by this component"
               impact="ACTION"
               returnType="boolean">
      <parameter name="name"
                 description="Application name"
                 type="java.lang.String"/>
    </operation>

======= 823101d:"java/org/apache/jasper/compiler/Generator.java"

                return JspUtil.makeJavaIdentifier(poolName);
======= 823101d:"java/org/apache/jasper/compiler/Generator.java"

            return JspUtil.makeJavaIdentifier(varName);

======= b55e9c2:"java/org/apache/jasper/compiler/ELParser.java"

                prev = 0;

======= 2d6d717:"java/org/apache/jasper/compiler/Generator.java"

            if (isTagFile && parent == null) {
                out.printin(tagHandlerVar);
                out.print(".setParent(");
                out.print("new javax.servlet.jsp.tagext.TagAdapter(");
                out.print("(javax.servlet.jsp.tagext.SimpleTag) this ));");
            } else if (!simpleTag) {

======= c7f0f60:"java/org/apache/jasper/JspCompilationContext.java"

 * Copyright 1999,2004-2006 The Apache Software Foundation.
======= c7f0f60:"java/org/apache/jasper/JspCompilationContext.java"

======= c7f0f60:"java/org/apache/jasper/JspCompilationContext.java"

        if (removed == 0 && rctxt != null) {
            rctxt.removeWrapper(jspUri);
======= c7f0f60:"java/org/apache/jasper/JspCompilationContext.java"

                jspCompiler.removeGeneratedFiles();
======= c7f0f60:"java/org/apache/jasper/JspCompilationContext.java"

======= c7f0f60:"java/org/apache/jasper/compiler/Compiler.java"

 * Copyright 1999,2004-2006 The Apache Software Foundation.
======= c7f0f60:"java/org/apache/jasper/compiler/Compiler.java"

======= c7f0f60:"java/org/apache/jasper/compiler/Compiler.java"

======= c7f0f60:"java/org/apache/jasper/servlet/JspServletWrapper.java"

 * Copyright 1999,2004-2006 The Apache Software Foundation.
======= c7f0f60:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        
======= c7f0f60:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        } catch (FileNotFoundException ex) {
            ctxt.incrementRemoved();
            String includeRequestUri = (String)
                request.getAttribute("javax.servlet.include.request_uri");
            if (includeRequestUri != null) {
                // This file was included. Throw an exception as
                // a response.sendError() will be ignored by the
                // servlet engine.
                throw new ServletException(ex);
            } else {
                try {
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, 
                                      ex.getMessage());
                } catch (IllegalStateException ise) {
                    log.error(Localizer.getMessage("jsp.error.file.not.found",
                           ex.getMessage()),
                  ex);
                }
            }
        } catch (ServletException ex) {
            if (options.getDevelopment()) {
                throw handleJspException(ex);
            } else {
                throw ex;
            }
        } catch (IOException ex) {
            if (options.getDevelopment()) {
                throw handleJspException(ex);
            } else {
                throw ex;
            }
        } catch (IllegalStateException ex) {
            if (options.getDevelopment()) {
                throw handleJspException(ex);
            } else {
                throw ex;
            }
        } catch (Exception ex) {
            if (options.getDevelopment()) {
                throw handleJspException(ex);
            } else {
                throw new JasperException(ex);
            }
        }
        try {
            
======= c7f0f60:"java/org/apache/jasper/servlet/JspServletWrapper.java"


======= a91b95e:"java/org/apache/coyote/ajp/AjpAprProcessor.java"

            request.setContentLength(-1); // reset content length
======= a91b95e:"java/org/apache/jk/core/MsgContext.java"

            req.setContentLength(-1); // reset content length

======= edc20fa:"java/org/apache/el/lang/ELSupport.java"

        } else if (obj0.getClass().isEnum()) {
            return obj0.equals(coerceToEnum(obj1, obj0.getClass()));
        } else if (obj1.getClass().isEnum()) {
            return obj1.equals(coerceToEnum(obj0, obj1.getClass()));
======= edc20fa:"java/org/apache/el/lang/ELSupport.java"

    
    /**
     * @param obj
     * @param type
     * @return
     */
    public final static Enum coerceToEnum(final Object obj, Class type) {
        if (obj == null || "".equals(obj)) {
            return null;
        }
        if (obj.getClass().isEnum()) {
            return (Enum) obj;
        }
        return Enum.valueOf(type, obj.toString());
    }
======= edc20fa:"java/org/apache/el/lang/ELSupport.java"

        } else if (obj instanceof Enum) {
            return ((Enum) obj).name();
======= edc20fa:"java/org/apache/el/lang/ELSupport.java"

        if (type.isEnum()) {
            return coerceToEnum(obj, type);
        }
======= edc20fa:"java/org/apache/jasper/servlet/JspServletWrapper.java"

                reload = false;
======= edc20fa:"java/org/apache/jasper/servlet/JspServletWrapper.java"

        try {
            Object target;
            if (isTagFile) {
                    reload = false;
                target = tagHandlerClass.newInstance();
            } else {
                target = getServlet();
            }
            if (target != null && target instanceof JspSourceDependent) {
                return ((java.util.List) ((JspSourceDependent) target).getDependants());
            }
        } catch (Throwable ex) {
        }
        return null;

======= 0f9844c:"java/org/apache/catalina/ssi/SSIServletExternalResolver.java"

            if (retVal.equals("") && !req.getMethod().equalsIgnoreCase(
                    org.apache.coyote.http11.Constants.HEAD)) {

======= 8ed77be:"java/org/apache/catalina/ssi/SSIProcessor.java"

        char endQuote = 0;
                while (bIdx < cmd.length() && !isQuote(cmd.charAt(bIdx)))
                endQuote = cmd.charAt(bIdx);
======= 8ed77be:"java/org/apache/catalina/ssi/SSIProcessor.java"

                    if (c == endQuote && !escaped) break;
======= 8ed77be:"java/org/apache/catalina/ssi/SSIProcessor.java"

    
    protected boolean isQuote(char c) {
        return c == '\'' || c == '\"' || c == '`';
    }

======= c30afec:"java/org/apache/catalina/servlets/CGIServlet.java"

            try {
                rt = Runtime.getRuntime();
                proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd);
    
                String sContentLength = (String) env.get("CONTENT_LENGTH");
                if(!"".equals(sContentLength)) {
                    commandsStdIn = new BufferedOutputStream(proc.getOutputStream());
                    IOTools.flow(stdin, commandsStdIn);
                    commandsStdIn.flush();
                    commandsStdIn.close();
                }
                /* we want to wait for the process to exit,  Process.waitFor()
                 * is useless in our situation; see
                 * http://developer.java.sun.com/developer/
                 *                               bugParade/bugs/4223650.html
                 */
                boolean isRunning = true;
                commandsStdErr = new BufferedReader
                    (new InputStreamReader(proc.getErrorStream()));
                final BufferedReader stdErrRdr = commandsStdErr ;
                new Thread() {
                    public void run () {
                        sendToLog(stdErrRdr) ;
                    } ;
                }.start() ;
                InputStream cgiHeaderStream =
                    new HTTPHeaderInputStream(proc.getInputStream());
                BufferedReader cgiHeaderReader =
                    new BufferedReader(new InputStreamReader(cgiHeaderStream));
                while (isRunning) {
                    try {
                        //set headers
                        String line = null;
                        while (((line = cgiHeaderReader.readLine()) != null)
                               && !("".equals(line))) {
                            if (debug >= 2) {
                                log("runCGI: addHeader(\"" + line + "\")");
                            }
                            if (line.startsWith("HTTP")) {
                                response.setStatus(getSCFromHttpStatusLine(line));
                            } else if (line.indexOf(":") >= 0) {
                                String header =
                                    line.substring(0, line.indexOf(":")).trim();
                                String value =
                                    line.substring(line.indexOf(":") + 1).trim(); 
                                if (header.equalsIgnoreCase("status")) {
                                    response.setStatus(getSCFromCGIStatusHeader(value));
                                } else {
                                    response.addHeader(header , value);
                                }
                                log("runCGI: bad header line \"" + line + "\"");
    
                        //write output
                        byte[] bBuf = new byte[2048];
    
                        OutputStream out = response.getOutputStream();
                        cgiOutput = proc.getInputStream();
    
                        try {
                            while ((bufRead = cgiOutput.read(bBuf)) != -1) {
                                if (debug >= 4) {
                                    log("runCGI: output " + bufRead +
                                        " bytes of data");
                                }
                                out.write(bBuf, 0, bufRead);
                            }
                        } finally {
                            // Attempt to consume any leftover byte if something bad happens,
                            // such as a socket disconnect on the servlet side; otherwise, the
                            // external process could hang
                            if (bufRead != -1) {
                                while ((bufRead = cgiOutput.read(bBuf)) != -1) {}
        
                        proc.exitValue(); // Throws exception if alive
    
                        isRunning = false;
    
                    } catch (IllegalThreadStateException e) {
                        try {
                            Thread.sleep(500);
                        } catch (InterruptedException ignored) {
                } //replacement for Process.waitFor()
                // Close the output stream used
                cgiOutput.close();
            }
            catch (IOException e){
                log ("Caught exception " + e);
                throw new IOException (e.toString());
            }
            finally{
                if (debug > 4) {
                    log ("Running finally block");
                if (proc != null){
                    proc.destroy();
                    proc = null;
                }
            }

======= 01a9b59:"java/org/apache/jasper/el/VariableResolverImpl.java"


======= 276e5ac:"java/org/apache/catalina/core/StandardWrapper.java"

======= 276e5ac:"java/org/apache/catalina/core/StandardWrapper.java"

======= 276e5ac:"java/org/apache/catalina/core/StandardWrapper.java"

======= 276e5ac:"java/org/apache/catalina/core/StandardWrapper.java"

======= 276e5ac:"java/org/apache/catalina/core/StandardWrapper.java"


======= 7b870a4:"java/org/apache/catalina/core/StandardContext.java"

======= 7b870a4:"java/org/apache/catalina/core/StandardContext.java"

        // Acquire clustered manager
        Manager contextManager = null;
        if (manager == null) {
        	if ((getCluster() != null) && distributable) {
        		try {
        			contextManager = getCluster().createManager(getName());
        		} catch (Exception ex) {
        			log.error("standardContext.clusterFail", ex);
        			ok = false;
        		}
        	} else {
        		contextManager = new StandardManager();
        	}
        }
        
        
======= 7b870a4:"java/org/apache/catalina/core/StandardContext.java"

                if (contextManager != null) {
                	setManager(contextManager);
