public String getLanguage(boolean useDefault) { return (language == null && useDefault ? defaultLanguage : language); }	public void setExtends(String value, Node.PageDirective n) { xtends = value; if (value.indexOf('.') < 0) n.addImport(value); }	@Override public void visit(Node.PageDirective n) throws JasperException { JspUtil.checkAttributes("Page directive", n, pageDirectiveAttrs, err); Attributes attrs = n.getAttributes(); for (int i = 0; attrs != null && i < attrs.getLength(); i++) { String attr = attrs.getQName(i); String value = attrs.getValue(i); if ("language".equals(attr)) { if (pageInfo.getLanguage(false) == null) { pageInfo.setLanguage(value, n, err, true); } else if (!pageInfo.getLanguage(false).equals(value)) { err.jspError(n, "jsp.error.page.conflict.language", pageInfo.getLanguage(false), value); } } else if ("extends".equals(attr)) { if (pageInfo.getExtends(false) == null) { pageInfo.setExtends(value, n); } else if (!pageInfo.getExtends(false).equals(value)) { err.jspError(n, "jsp.error.page.conflict.extends", pageInfo.getExtends(false), value); } } else if ("contentType".equals(attr)) { if (pageInfo.getContentType() == null) { pageInfo.setContentType(value); } else if (!pageInfo.getContentType().equals(value)) { err.jspError(n, "jsp.error.page.conflict.contenttype", pageInfo.getContentType(), value); } } else if ("session".equals(attr)) { if (pageInfo.getSession() == null) { pageInfo.setSession(value, n, err); } else if (!pageInfo.getSession().equals(value)) { err.jspError(n, "jsp.error.page.conflict.session", pageInfo.getSession(), value); } } else if ("buffer".equals(attr)) { if (pageInfo.getBufferValue() == null) { pageInfo.setBufferValue(value, n, err); } else if (!pageInfo.getBufferValue().equals(value)) { err.jspError(n, "jsp.error.page.conflict.buffer", pageInfo.getBufferValue(), value); } } else if ("autoFlush".equals(attr)) { if (pageInfo.getAutoFlush() == null) { pageInfo.setAutoFlush(value, n, err); } else if (!pageInfo.getAutoFlush().equals(value)) { err.jspError(n, "jsp.error.page.conflict.autoflush", pageInfo.getAutoFlush(), value); } } else if ("isThreadSafe".equals(attr)) { if (pageInfo.getIsThreadSafe() == null) { pageInfo.setIsThreadSafe(value, n, err); } else if (!pageInfo.getIsThreadSafe().equals(value)) { err.jspError(n, "jsp.error.page.conflict.isthreadsafe", pageInfo.getIsThreadSafe(), value); } } else if ("isELIgnored".equals(attr)) { if (pageInfo.getIsELIgnored() == null) { pageInfo.setIsELIgnored(value, n, err, true); } else if (!pageInfo.getIsELIgnored().equals(value)) { err.jspError(n, "jsp.error.page.conflict.iselignored", pageInfo.getIsELIgnored(), value); } } else if ("isErrorPage".equals(attr)) { if (pageInfo.getIsErrorPage() == null) { pageInfo.setIsErrorPage(value, n, err); } else if (!pageInfo.getIsErrorPage().equals(value)) { err.jspError(n, "jsp.error.page.conflict.iserrorpage", pageInfo.getIsErrorPage(), value); } } else if ("errorPage".equals(attr)) { if (pageInfo.getErrorPage() == null) { pageInfo.setErrorPage(value); } else if (!pageInfo.getErrorPage().equals(value)) { err.jspError(n, "jsp.error.page.conflict.errorpage", pageInfo.getErrorPage(), value); } } else if ("info".equals(attr)) { if (pageInfo.getInfo() == null) { pageInfo.setInfo(value); } else if (!pageInfo.getInfo().equals(value)) { err.jspError(n, "jsp.error.page.conflict.info", pageInfo.getInfo(), value); } } else if ("pageEncoding".equals(attr)) { if (pageEncodingSeen) err.jspError(n, "jsp.error.page.multi.pageencoding"); pageEncodingSeen = true; String actual = comparePageEncodings(value, n); n.getRoot().setPageEncoding(actual); } else if ("deferredSyntaxAllowedAsLiteral".equals(attr)) { if (pageInfo.getDeferredSyntaxAllowedAsLiteral() == null) { pageInfo.setDeferredSyntaxAllowedAsLiteral(value, n, err, true); } else if (!pageInfo.getDeferredSyntaxAllowedAsLiteral().equals(value)) { err.jspError(n, "jsp.error.page.conflict.deferredsyntaxallowedasliteral", pageInfo.getDeferredSyntaxAllowedAsLiteral(), value); } } else if ("trimDirectiveWhitespaces".equals(attr)) { if (pageInfo.getTrimDirectiveWhitespaces() == null) { pageInfo.setTrimDirectiveWhitespaces(value, n, err, true); } else if (!pageInfo.getTrimDirectiveWhitespaces().equals(value)) { err.jspError(n, "jsp.error.page.conflict.trimdirectivewhitespaces", pageInfo.getTrimDirectiveWhitespaces(), value); } } } if (pageInfo.getBuffer() == 0 && !pageInfo.isAutoFlush()) err.jspError(n, "jsp.error.page.badCombo"); // Attributes for imports for this node have been processed by pageInfo.addImports(n.getImports()); }
private String skipUntilEL() { char prev = 0; StringBuilder buf = new StringBuilder(); while (hasNextChar()) { char ch = nextChar(); if (prev == '\\') { prev = 0; if (ch == '\\') { buf.append('\\'); prev = '\\'; } else if (ch == '$' || (!isDeferredSyntaxAllowedAsLiteral && ch == '#')) { buf.append(ch); } // else error! } else if (prev == '$' || (!isDeferredSyntaxAllowedAsLiteral && prev == '#')) { if (ch == '{') { this.type = prev; prev = 0; break; } buf.append(prev); prev = 0; } if (ch == '\\' || ch == '$' || (!isDeferredSyntaxAllowedAsLiteral && ch == '#')) { prev = ch; } else { buf.append(ch); } } if (prev != 0) { buf.append(prev); } return buf.toString(); }	private Token nextToken() { prevToken = curToken; skipSpaces(); if (hasNextChar()) { char ch = nextChar(); if (Character.isJavaIdentifierStart(ch)) { StringBuilder buf = new StringBuilder(); buf.append(ch); while (index < expression.length() && Character.isJavaIdentifierPart(ch = expression.charAt(index))) { buf.append(ch); nextChar(); } return new Id(buf.toString()); } if (ch == '\'' || ch == '"') { return parseQuotedChars(ch); } else { return new Char(ch); } } return null; }	private Token parseQuotedChars(char quote) { StringBuilder buf = new StringBuilder(); buf.append(quote); while (hasNextChar()) { char ch = nextChar(); if (ch == '\\') { ch = nextChar(); if (ch == '\\' || ch == quote) { buf.append(ch); } // else error! } else if (ch == quote) { buf.append(ch); break; } else { buf.append(ch); } } return new QuotedString(buf.toString()); }	private boolean isELReserved(String id) { int i = 0; int j = reservedWords.length; while (i < j) { int k = (i + j) / 2; int result = reservedWords[k].compareTo(id); if (result == 0) { return true; } if (result < 0) { i = k + 1; } else { j = k; } } return false; }	private boolean parseFunction() { if (!(curToken instanceof Id) || isELReserved(curToken.toString()) || prevToken instanceof Char && prevToken.toChar() == '.') { return false; } String s1 = null; String s2 = curToken.toString(); if (hasNext()) { int mark = getIndex(); curToken = nextToken(); if (curToken.toChar() == ':') { if (hasNext()) { Token t2 = nextToken(); if (t2 instanceof Id) { s1 = s2; s2 = t2.toString(); if (hasNext()) { curToken = nextToken(); } } } } if (curToken.toChar() == '(') { ELexpr.add(new ELNode.Function(s1, s2)); return true; } curToken = prevToken; setIndex(mark); } return false; }	private ELNode.Nodes parseEL() { StringBuilder buf = new StringBuilder(); ELexpr = new ELNode.Nodes(); while (hasNext()) { curToken = nextToken(); if (curToken instanceof Char) { if (curToken.toChar() == '}') { break; } buf.append(curToken.toChar()); } else { if (buf.length() > 0) { ELexpr.add(new ELNode.ELText(buf.toString())); buf = new StringBuilder(); } if (!parseFunction()) { ELexpr.add(new ELNode.ELText(curToken.toString())); } } } if (buf.length() > 0) { ELexpr.add(new ELNode.ELText(buf.toString())); } return ELexpr; }	@Test public void testCompound03() throws JasperException { doTestParser("${foo}${bar}"); }
@Override public synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { if (log.isDebugEnabled()) log.debug("loadClass(" + name + ", " + resolve + ")"); Class<?> clazz = null; if (!started) { try { throw new IllegalStateException(); } catch (IllegalStateException e) { log.info(sm.getString("webappClassLoader.stopped", name), e); } } clazz = findLoadedClass0(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(" Returning class from cache"); if (resolve) resolveClass(clazz); return (clazz); } clazz = findLoadedClass(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(" Returning class from cache"); if (resolve) resolveClass(clazz); return (clazz); } // (0.2) Try loading the class with the system class loader, to prevent String resourceName = binaryNameToPath(name, false); if (system.getResource(resourceName) != null) { try { clazz = system.loadClass(name); if (clazz != null) { if (resolve) resolveClass(clazz); return (clazz); } } catch (ClassNotFoundException e) { // Ignore } } if (securityManager != null) { int i = name.lastIndexOf('.'); if (i >= 0) { try { securityManager.checkPackageAccess(name.substring(0, i)); } catch (SecurityException se) { String error = "Security Violation, attempt to use " + "Restricted Class: " + name; log.info(error, se); throw new ClassNotFoundException(error, se); } } } boolean delegateLoad = delegate || filter(name); if (delegateLoad) { if (log.isDebugEnabled()) log.debug(" Delegating to parent classloader1 " + parent); ClassLoader loader = parent; if (loader == null) loader = system; try { clazz = Class.forName(name, false, loader); if (clazz != null) { if (log.isDebugEnabled()) log.debug(" Loading class from parent"); if (resolve) resolveClass(clazz); return (clazz); } } catch (ClassNotFoundException e) { // Ignore } } if (log.isDebugEnabled()) log.debug(" Searching local repositories"); try { clazz = findClass(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(" Loading class from local repository"); if (resolve) resolveClass(clazz); return (clazz); } } catch (ClassNotFoundException e) { // Ignore } if (!delegateLoad) { if (log.isDebugEnabled()) log.debug(" Delegating to parent classloader at end: " + parent); ClassLoader loader = parent; if (loader == null) loader = system; try { clazz = Class.forName(name, false, loader); if (clazz != null) { if (log.isDebugEnabled()) log.debug(" Loading class from parent"); if (resolve) resolveClass(clazz); return (clazz); } } catch (ClassNotFoundException e) { // Ignore } } throw new ClassNotFoundException(name); }	@Override public URL getResource(String name) { if (log.isDebugEnabled()) log.debug("getResource(" + name + ")"); URL url = null; if (delegate) { if (log.isDebugEnabled()) log.debug(" Delegating to parent classloader " + parent); ClassLoader loader = parent; if (loader == null) loader = system; url = loader.getResource(name); if (url != null) { if (log.isDebugEnabled()) log.debug(" --> Returning '" + url.toString() + "'"); return (url); } } url = findResource(name); if (url != null) { if (log.isDebugEnabled()) log.debug(" --> Returning '" + url.toString() + "'"); return (url); } if (!delegate) { ClassLoader loader = parent; if (loader == null) loader = system; url = loader.getResource(name); if (url != null) { if (log.isDebugEnabled()) log.debug(" --> Returning '" + url.toString() + "'"); return (url); } } if (log.isDebugEnabled()) log.debug(" --> Resource not found, returning null"); return (null); }	@Override public WebappClassLoader copyWithoutTransformers() { WebappClassLoader result = new WebappClassLoader(this.parent); result.resources = this.resources; result.delegate = this.delegate; result.started = this.started; result.needConvert = this.needConvert; result.clearReferencesStatic = this.clearReferencesStatic; result.clearReferencesStopThreads = this.clearReferencesStopThreads; result.clearReferencesStopTimerThreads = this.clearReferencesStopTimerThreads; result.clearReferencesLogFactoryRelease = this.clearReferencesLogFactoryRelease; result.clearReferencesHttpClientKeepAliveThread = this.clearReferencesHttpClientKeepAliveThread; result.jarModificationTimes.putAll(this.jarModificationTimes); result.permissionList.addAll(this.permissionList); result.loaderPC.putAll(this.loaderPC); try { result.start(); } catch (LifecycleException e) { throw new IllegalStateException(e); } return result; }	public ClassLoader run() { return clazz.getClassLoader(); }	@Override public void stop() throws LifecycleException { // Clearing references should be done before setting started to clearReferences(); started = false; resourceEntries.clear(); jarModificationTimes.clear(); resources = null; parent = null; permissionList.clear(); loaderPC.clear(); }
public static void doUpgrade(WsServerContainer sc, HttpServletRequest req, HttpServletResponse resp, ServerEndpointConfig sec, Map<String, String> pathParams) throws ServletException, IOException { // Validate the rest of the headers and reject the request if that String key; String subProtocol = null; List<Extension> extensions = Collections.emptyList(); if (!headerContainsToken(req, Constants.CONNECTION_HEADER_NAME, Constants.CONNECTION_HEADER_VALUE)) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } if (!headerContainsToken(req, Constants.WS_VERSION_HEADER_NAME, Constants.WS_VERSION_HEADER_VALUE)) { resp.setStatus(426); resp.setHeader(Constants.WS_VERSION_HEADER_NAME, Constants.WS_VERSION_HEADER_VALUE); return; } key = req.getHeader(Constants.WS_KEY_HEADER_NAME); if (key == null) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } String origin = req.getHeader("Origin"); if (!sec.getConfigurator().checkOrigin(origin)) { resp.sendError(HttpServletResponse.SC_FORBIDDEN); return; } List<String> subProtocols = getTokensFromHeader(req, "Sec-WebSocket-Protocol"); if (!subProtocols.isEmpty()) { subProtocol = sec.getConfigurator().getNegotiatedSubprotocol(sec.getSubprotocols(), subProtocols); } // Extensions // Currently no extensions are supported by this implementation resp.setHeader(Constants.UPGRADE_HEADER_NAME, Constants.UPGRADE_HEADER_VALUE); resp.setHeader(Constants.CONNECTION_HEADER_NAME, Constants.CONNECTION_HEADER_VALUE); resp.setHeader(HandshakeResponse.SEC_WEBSOCKET_ACCEPT, getWebSocketAccept(key)); if (subProtocol != null) { resp.setHeader("Sec-WebSocket-Protocol", subProtocol); } if (!extensions.isEmpty()) { StringBuilder sb = new StringBuilder(); Iterator<Extension> iter = extensions.iterator(); sb.append(iter.next()); while (iter.hasNext()) { sb.append(','); sb.append(iter.next().getName()); } resp.setHeader("Sec-WebSocket-Extensions", sb.toString()); } Endpoint ep; try { Class<?> clazz = sec.getEndpointClass(); if (Endpoint.class.isAssignableFrom(clazz)) { ep = (Endpoint) sec.getConfigurator().getEndpointInstance(clazz); } else { ep = new PojoEndpointServer(); } } catch (InstantiationException e) { throw new ServletException(e); } WsHandshakeRequest wsRequest = new WsHandshakeRequest(req); WsHandshakeResponse wsResponse = new WsHandshakeResponse(); WsPerSessionServerEndpointConfig perSessionServerEndpointConfig = new WsPerSessionServerEndpointConfig(sec); sec.getConfigurator().modifyHandshake(perSessionServerEndpointConfig, wsRequest, wsResponse); wsRequest.finished(); for (Entry<String, List<String>> entry : wsResponse.getHeaders().entrySet()) { for (String headerValue : entry.getValue()) { resp.addHeader(entry.getKey(), headerValue); } } WsHttpUpgradeHandler wsHandler = req.upgrade(WsHttpUpgradeHandler.class); wsHandler.preInit(ep, perSessionServerEndpointConfig, sc, wsRequest, subProtocol, pathParams, req.isSecure()); }
public void initialize(Servlet servlet, ServletRequest request, ServletResponse response, String errorPageURL, boolean needsSession, int bufferSize, boolean autoFlush) throws IOException { this.servlet = servlet; this.config = servlet.getServletConfig(); this.context = config.getServletContext(); this.errorPageURL = errorPageURL; this.request = request; this.response = response; this.applicationContext = JspApplicationContextImpl.getInstance(context); if (request instanceof HttpServletRequest && needsSession) this.session = ((HttpServletRequest) request).getSession(); if (needsSession && session == null) throw new IllegalStateException("Page needs a session and none is available"); depth = -1; if (this.baseOut == null) { this.baseOut = new JspWriterImpl(response, bufferSize, autoFlush); } else { this.baseOut.init(response, bufferSize, autoFlush); } this.out = baseOut; setAttribute(OUT, this.out); setAttribute(REQUEST, request); setAttribute(RESPONSE, response); if (session != null) setAttribute(SESSION, session); setAttribute(PAGE, servlet); setAttribute(CONFIG, config); setAttribute(PAGECONTEXT, this); setAttribute(APPLICATION, context); isIncluded = request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH) != null; }	public void testDoForward() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp"); tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/test/bug5nnnn/bug53545.jsp", res, null); Assert.assertEquals(HttpServletResponse.SC_OK, rc); String body = res.toString(); Assert.assertTrue(body.contains("OK")); Assert.assertFalse(body.contains("FAIL")); }
public boolean getBlockingStatus() { return blockingStatus; }
private long[] getLastModified(TldResourcePath tldResourcePath) { long[] result = new long[2]; result[0] = -1; result[1] = -1; try { URL url = servletContext.getResource(tldResourcePath.getWebappPath()); URLConnection conn = url.openConnection(); result[0] = conn.getLastModified(); if ("file".equals(url.getProtocol())) { // Reading the last modified time opens an input stream so we // need to make sure it is closed again otherwise the TLD file conn.getInputStream().close(); } Jar jar = tldResourcePath.getJar(); if (jar != null) { result[1] = jar.getLastModified(tldResourcePath.getEntryName()); } } catch (IOException e) { // Ignore (shouldn't happen) } return result; }
private synchronized void close(boolean rename) { if (writer == null) { return; } writer.flush(); writer.close(); if (rename && renameOnRotate) { File newLogFile = getLogFile(true); if (!newLogFile.exists()) { try { if (!currentLogFile.renameTo(newLogFile)) { log.error(sm.getString("accessLogValve.renameFail", currentLogFile, newLogFile)); } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); log.error(sm.getString("accessLogValve.renameFail", currentLogFile, newLogFile), e); } } else { log.error(sm.getString("accessLogValve.alreadyExists", currentLogFile, newLogFile)); } } writer = null; dateStamp = ""; currentLogFile = null; }	protected DateFormatCache initialValue() { return new DateFormatCache(localCacheSize, Locale.getDefault(), globalDateCache); }	protected synchronized void open() { // Open the current log file File pathname = getLogFile(rotatable && !renameOnRotate); Charset charset = null; if (encoding != null) { try { charset = B2CConverter.getCharset(encoding); } catch (UnsupportedEncodingException ex) { log.error(sm.getString("accessLogValve.unsupportedEncoding", encoding), ex); } } if (charset == null) { charset = StandardCharsets.ISO_8859_1; } try { writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(pathname, true), charset), 128000), false); currentLogFile = pathname; } catch (IOException e) { writer = null; currentLogFile = null; log.error(sm.getString("accessLogValve.openFail", pathname), e); } }	@Override protected synchronized void startInternal() throws LifecycleException { String format = getFileDateFormat(); fileDateFormatter = new SimpleDateFormat(format, Locale.US); fileDateFormatter.setTimeZone(TimeZone.getDefault()); dateStamp = fileDateFormatter.format(new Date(System.currentTimeMillis())); if (rotatable && renameOnRotate) { restore(); } open(); setState(LifecycleState.STARTING); }	@Override protected synchronized void stopInternal() throws LifecycleException { setState(LifecycleState.STOPPING); close(false); }	@Override public synchronized void backgroundProcess() { if (getState().isAvailable() && getEnabled() && writer != null && buffered) { writer.flush(); } }	public void setDirectory(String directory) { this.directory = directory; }	public void setFileDateFormat(String fileDateFormat) { String newFormat; if (fileDateFormat == null) { newFormat = ""; } else { newFormat = fileDateFormat; } this.fileDateFormat = newFormat; synchronized (this) { fileDateFormatter = new SimpleDateFormat(newFormat, Locale.US); fileDateFormatter.setTimeZone(TimeZone.getDefault()); } }	public void setSuffix(String suffix) { this.suffix = suffix; }
private int doWriteInternal(byte[] b, int off, int len) throws IOException { int start = off; int left = len; int written; do { if (endpoint.isSSLEnabled()) { if (sslOutputBuffer.remaining() == 0) { sslOutputBuffer.clear(); if (left < SSL_OUTPUT_BUFFER_SIZE) { sslOutputBuffer.put(b, start, left); } else { sslOutputBuffer.put(b, start, SSL_OUTPUT_BUFFER_SIZE); } sslOutputBuffer.flip(); } else { // Buffer still has data from previous attempt to write // APR + SSL requires that exactly the same parameters are // passed when re-attempting the write } written = Socket.sendb(socket, sslOutputBuffer, sslOutputBuffer.position(), sslOutputBuffer.limit()); if (written > 0) { sslOutputBuffer.position(sslOutputBuffer.position() + written); } } else { written = Socket.send(socket, b, start, left); } if (Status.APR_STATUS_IS_EAGAIN(-written)) { written = 0; } else if (-written == Status.APR_EOF) { throw new EOFException(sm.getString("apr.clientAbort")); } else if ((OS.IS_WIN32 || OS.IS_WIN64) && (-written == Status.APR_OS_START_SYSERR + 10053)) { throw new EOFException(sm.getString("apr.clientAbort")); } else if (written < 0) { throw new IOException(sm.getString("apr.write.error", Integer.valueOf(-written), Long.valueOf(socket), wrapper)); } start += written; left -= written; } while (written > 0 && left > 0); if (left > 0) { endpoint.getPoller().add(socket, -1, false, true); } return len - left; }	private void doTestCheckClosed(Class<? extends HttpUpgradeHandler> upgradeHandlerClass) throws Exception { UpgradeConnection conn = doUpgrade(upgradeHandlerClass); Reader r = conn.getReader(); int c = r.read(); Assert.assertEquals(-1, c); }	protected final boolean isCloseRequired() { return closeRequired; }	protected final void onWritePossible() throws IOException { synchronized (writeLock) { try { writeInternal(buffer, 0, buffer.length); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); Thread thread = Thread.currentThread(); ClassLoader originalClassLoader = thread.getContextClassLoader(); try { thread.setContextClassLoader(applicationLoader); listener.onError(t); } finally { thread.setContextClassLoader(originalClassLoader); } if (t instanceof IOException) { throw t; } else { throw new IOException(t); } } // Make sure isReady() and onWritePossible() have a consistent view of boolean fire = false; synchronized (fireListenerLock) { if (buffer == null && fireListener) { fireListener = false; fire = true; } } if (fire) { Thread thread = Thread.currentThread(); ClassLoader originalClassLoader = thread.getContextClassLoader(); try { thread.setContextClassLoader(applicationLoader); listener.onWritePossible(); } finally { thread.setContextClassLoader(originalClassLoader); } } } }	@Override protected int doWrite(boolean block, byte[] b, int off, int len) throws IOException { if (closed) { throw new IOException(sm.getString("apr.closed", Long.valueOf(socket))); } Lock readLock = wrapper.getBlockingStatusReadLock(); WriteLock writeLock = wrapper.getBlockingStatusWriteLock(); try { readLock.lock(); if (wrapper.getBlockingStatus() == block) { return doWriteInternal(b, off, len); } } finally { readLock.unlock(); } try { writeLock.lock(); wrapper.setBlockingStatus(block); if (block) { Socket.timeoutSet(socket, endpoint.getSoTimeout() * 1000); } else { Socket.timeoutSet(socket, 0); } try { readLock.lock(); writeLock.unlock(); return doWriteInternal(b, off, len); } finally { readLock.unlock(); } } finally { if (writeLock.isHeldByCurrentThread()) { writeLock.unlock(); } } }	public SocketState process(SocketWrapper<S> wrapper, SocketStatus status) { if (wrapper == null) { return SocketState.CLOSED; } S socket = wrapper.getSocket(); if (socket == null) { return SocketState.CLOSED; } Processor<S> processor = connections.get(socket); if (status == SocketStatus.DISCONNECT && processor == null) { return SocketState.CLOSED; } wrapper.setAsync(false); try { if (processor == null) { processor = recycledProcessors.pop(); } if (processor == null) { processor = createProcessor(); } initSsl(wrapper, processor); SocketState state = SocketState.CLOSED; Iterator<DispatchType> dispatches = null; do { if (dispatches != null) { // Associate the processor with the connection as connections.put(socket, processor); DispatchType nextDispatch = dispatches.next(); state = processor.asyncDispatch(nextDispatch.getSocketStatus()); } else if (status == SocketStatus.DISCONNECT && !processor.isComet()) { // Do nothing here, just wait for it to get recycled // Don't do this for Comet we need to generate an end // event (see BZ 54022) } else if (processor.isAsync() || state == SocketState.ASYNC_END) { state = processor.asyncDispatch(status); } else if (processor.isComet()) { state = processor.event(status); } else if (processor.isUpgrade()) { state = processor.upgradeDispatch(status); } else { state = processor.process(wrapper); } if (state != SocketState.CLOSED && processor.isAsync()) { state = processor.asyncPostProcess(); } if (state == SocketState.UPGRADING) { HttpUpgradeHandler httpUpgradeHandler = processor.getHttpUpgradeHandler(); release(wrapper, processor, false, false); processor = createUpgradeProcessor(wrapper, httpUpgradeHandler); wrapper.setUpgraded(true); connections.put(socket, processor); // Initialise the upgrade handler (which may trigger // some IO using the new protocol which is why the lines // above are necessary) // This cast should be safe. If it fails the error // handling for the surrounding try/catch will deal with httpUpgradeHandler.init((WebConnection) processor); } if (getLog().isDebugEnabled()) { getLog().debug("Socket: [" + wrapper + "], Status in: [" + status + "], State out: [" + state + "]"); } if (dispatches == null || !dispatches.hasNext()) { // Only returns non-null iterator if there are dispatches = wrapper.getIteratorAndClearDispatches(); } } while (state == SocketState.ASYNC_END || state == SocketState.UPGRADING || dispatches != null && state != SocketState.CLOSED); if (state == SocketState.LONG) { // In the middle of processing a request/response. Keep the // socket associated with the processor. Exact requirements connections.put(socket, processor); longPoll(wrapper, processor); } else if (state == SocketState.OPEN) { // In keep-alive but between requests. OK to recycle connections.remove(socket); release(wrapper, processor, false, true); } else if (state == SocketState.SENDFILE) { // Sendfile in progress. If it fails, the socket will be // closed. If it works, the socket will be re-added to the connections.remove(socket); release(wrapper, processor, false, false); } else if (state == SocketState.UPGRADED) { if (status != SocketStatus.OPEN_WRITE) { longPoll(wrapper, processor); } } else { // Connection closed. OK to recycle the processor. Upgrade connections.remove(socket); if (processor.isUpgrade()) { processor.getHttpUpgradeHandler().destroy(); } else { release(wrapper, processor, true, false); } } return state; } catch (java.net.SocketException e) { getLog().debug(sm.getString("abstractConnectionHandler.socketexception.debug"), e); } catch (java.io.IOException e) { getLog().debug(sm.getString("abstractConnectionHandler.ioexception.debug"), e); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); // any other exception or error is odd. Here we log it // with "ERROR" level, so it will show up even on getLog().error(sm.getString("abstractConnectionHandler.error"), e); } // Make sure socket/processor is removed from the list of current connections.remove(socket); if (processor != null && !processor.isUpgrade()) { release(wrapper, processor, true, false); } return SocketState.CLOSED; }	public final boolean isReady() { if (listener == null) { throw new IllegalStateException(sm.getString("upgrade.sos.canWrite.is")); } synchronized (fireListenerLock) { boolean result = (buffer == null); fireListener = !result; return result; } }	@Override public final void setWriteListener(WriteListener listener) { if (listener == null) { throw new IllegalArgumentException(sm.getString("upgrade.sos.writeListener.null")); } if (this.listener != null) { throw new IllegalArgumentException(sm.getString("upgrade.sos.writeListener.set")); } this.listener = listener; this.applicationLoader = Thread.currentThread().getContextClassLoader(); }	@Override public void close() throws IOException { closeRequired = true; doClose(); }	@Override public void destroy() { // NO-OP }	@Override public void onError(Throwable throwable) { // NO-OP }	@Test public void testSetWriteListenerTwice() throws Exception { doTestCheckClosed(SetWriteListenerTwice.class); }
@Override protected boolean breakKeepAliveLoop(SocketWrapper<NioChannel> socketWrapper) { if (sendfileData != null && !error) { ((KeyAttachment) socketWrapper).setSendfileData(sendfileData); sendfileData.keepAlive = keepAlive; SelectionKey key = socketWrapper.getSocket().getIOChannel().keyFor(socketWrapper.getSocket().getPoller().getSelector()); openSocket = socketWrapper.getSocket().getPoller().processSendfile(key, (KeyAttachment) socketWrapper, true); return true; } return false; }
public Set<SAXParseException> getWarnings() { return warnings; }
public boolean modified() { if (log.isDebugEnabled()) log.debug("modified()"); for (Entry<String, ResourceEntry> entry : resourceEntries.entrySet()) { long cachedLastModified = entry.getValue().lastModified; long lastModified = resources.getClassLoaderResource(entry.getKey()).getLastModified(); if (lastModified != cachedLastModified) { if (log.isDebugEnabled()) log.debug(sm.getString("webappClassLoader.resourceModified", entry.getKey(), new Date(cachedLastModified), new Date(lastModified))); return true; } } WebResource[] jars = resources.listResources("/WEB-INF/lib"); if (jars.length > jarModificationTimes.size()) { log.info(sm.getString("webappClassLoader.jarsAdded", resources.getContext().getName())); return true; } else if (jars.length < jarModificationTimes.size()) { log.info(sm.getString("webappClassLoader.jarsRemoved", resources.getContext().getName())); return true; } for (WebResource jar : jars) { if (jar.getName().endsWith(".jar") && jar.isFile() && jar.canRead()) { Long recordedLastModified = jarModificationTimes.get(jar.getName()); if (recordedLastModified == null) { log.info(sm.getString("webappClassLoader.jarsAdded", resources.getContext().getName())); return true; } if (recordedLastModified.longValue() != jar.getLastModified()) { log.info(sm.getString("webappClassLoader.jarsModified", resources.getContext().getName())); return true; } jarModificationTimes.put(jar.getName(), Long.valueOf(jar.getLastModified())); } } return false; }
private void setUpLogin(Tomcat tomcat) throws Exception { Context ctxt = tomcat.addContext(CONTEXT_PATH_LOGIN, System.getProperty("java.io.tmpdir")); ctxt.setSessionTimeout(SHORT_TIMEOUT_SECS); Tomcat.addServlet(ctxt, "TesterServlet3", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, "TesterServlet3"); SecurityCollection collection = new SecurityCollection(); collection.addPattern(URI_PROTECTED); SecurityConstraint sc = new SecurityConstraint(); sc.addAuthRole(ROLE); sc.addCollection(collection); ctxt.addConstraint(sc); LoginConfig lc = new LoginConfig(); lc.setAuthMethod("BASIC"); ctxt.setLoginConfig(lc); ctxt.getPipeline().addValve(new BasicAuthenticator()); }	private void setUpNonLogin(Tomcat tomcat) throws Exception { Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty("java.io.tmpdir")); ctxt.setSessionTimeout(LONG_TIMEOUT_SECS); Tomcat.addServlet(ctxt, "TesterServlet1", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, "TesterServlet1"); SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); ctxt.addConstraint(sc1); Tomcat.addServlet(ctxt, "TesterServlet2", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, "TesterServlet2"); SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint(); sc2.addCollection(collection2); ctxt.addConstraint(sc2); LoginConfig lc = new LoginConfig(); lc.setAuthMethod("NONE"); ctxt.setLoginConfig(lc); ctxt.getPipeline().addValve(new NonLoginAuthenticator()); }	protected void addCookies(Map<String, List<String>> reqHeaders) { if ((cookies != null) && (cookies.size() > 0)) { reqHeaders.put(BROWSER_COOKIES + ":", cookies); } }	protected void saveCookies(Map<String, List<String>> respHeaders) { cookies = respHeaders.get(SERVER_COOKIES); }	public void doTestBasic(String user, String pwd, String uri, boolean expectedReject1, int expectedRC1, boolean expectedReject2, int expectedRC2) throws Exception { Map<String, List<String>> reqHeaders1 = new HashMap<>(); Map<String, List<String>> respHeaders1 = new HashMap<>(); ByteChunk bc = new ByteChunk(); int rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders1, respHeaders1); if (expectedReject1) { assertEquals(expectedRC1, rc); assertTrue(bc.getLength() > 0); } else { assertEquals(200, rc); assertEquals("OK", bc.toString()); return; } String credentials = user + ":" + pwd; String base64auth = Base64.encodeBase64String(credentials.getBytes(StandardCharsets.ISO_8859_1)); String authLine = "Basic " + base64auth; List<String> auth = new ArrayList<>(); auth.add(authLine); Map<String, List<String>> reqHeaders2 = new HashMap<>(); reqHeaders2.put(CLIENT_AUTH_HEADER, auth); Map<String, List<String>> respHeaders2 = new HashMap<>(); bc.recycle(); rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders2, respHeaders2); if (expectedReject2) { assertEquals(expectedRC2, rc); assertNull(bc.toString()); } else { assertEquals(200, rc); assertEquals("OK", bc.toString()); saveCookies(respHeaders2); } }	public void doTestNonLogin(String uri, boolean addCookies, boolean expectedReject, int expectedRC) throws Exception { Map<String, List<String>> reqHeaders = new HashMap<>(); if (addCookies) { addCookies(reqHeaders); } Map<String, List<String>> respHeaders = new HashMap<>(); ByteChunk bc = new ByteChunk(); int rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders, respHeaders); if (expectedReject) { assertEquals(expectedRC, rc); assertTrue(bc.getLength() > 0); } else { assertEquals(200, rc); assertEquals("OK", bc.toString()); saveCookies(respHeaders); } }	@Override public void setUp() throws Exception { super.setUp(); Tomcat tomcat = getTomcatInstance(); SingleSignOn sso = new SingleSignOn(); tomcat.getHost().getPipeline().addValve(sso); tomcat.addUser(USER, PWD); tomcat.addRole(USER, ROLE); setUpNonLogin(tomcat); setUpLogin(tomcat); tomcat.start(); }	public void testAcceptPublicNonLogin() throws Exception { doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PUBLIC, false, false, 200); }	@Test public void testBasicExpiredAcceptProtectedWithCookies() throws Exception { doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED, true, 401, false, 200); doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED, true, false, 200); // wait long enough for the BASIC session to expire, Thread.sleep(SHORT_TIMEOUT_DELAY_MSECS); doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED, true, false, 200); // wait long enough for my NonLogin session to expire Thread.sleep(LONG_TIMEOUT_DELAY_MSECS); doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED, false, true, 403); }	@Test public void testBasicLoginAcceptProtectedWithCookies() throws Exception { doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED, true, 401, false, 200); doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED, true, false, 200); }	@Test public void testBasicLoginRejectProtectedWithoutCookies() throws Exception { doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED, true, 401, false, 200); doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED, false, true, 403); }	@Test public void testBasicLoginSessionTimeout() throws Exception { doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED, true, 401, false, 200); Thread.sleep(SHORT_TIMEOUT_DELAY_MSECS); doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED, true, 401, false, 200); }	@Test public void testRejectProtectedNonLogin() throws Exception { doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED, false, true, 403); }
private void doTestConstructorString(ContextName src) { doCompare(src, new ContextName(src.getBaseName())); doCompare(src, new ContextName(src.getDisplayName())); doCompare(src, new ContextName(src.getName())); }	protected String upload(HttpServletRequest request, StringManager smClient) throws IOException, ServletException { String message = ""; Part warPart = null; String filename = null; Collection<Part> parts = request.getParts(); Iterator<Part> iter = parts.iterator(); try { while (iter.hasNext()) { Part part = iter.next(); if (part.getName().equals("deployWar") && warPart == null) { warPart = part; } else { part.delete(); } } while (true) { if (warPart == null) { message = smClient.getString("htmlManagerServlet.deployUploadNoFile"); break; } filename = warPart.getSubmittedFileName(); if (!filename.toLowerCase(Locale.ENGLISH).endsWith(".war")) { message = smClient.getString("htmlManagerServlet.deployUploadNotWar", filename); break; } if (filename.lastIndexOf('\\') >= 0) { filename = filename.substring(filename.lastIndexOf('\\') + 1); } if (filename.lastIndexOf('/') >= 0) { filename = filename.substring(filename.lastIndexOf('/') + 1); } // Identify the appBase of the owning Host of this Context File file = new File(host.getAppBaseFile(), filename); if (file.exists()) { message = smClient.getString("htmlManagerServlet.deployUploadWarExists", filename); break; } ContextName cn = new ContextName(filename); String name = cn.getName(); if ((host.findChild(name) != null) && !isDeployed(name)) { message = smClient.getString("htmlManagerServlet.deployUploadInServerXml", filename); break; } if (!isServiced(name)) { addServiced(name); try { warPart.write(file.getAbsolutePath()); check(name); } finally { removeServiced(name); } } break; } } catch (Exception e) { message = smClient.getString("htmlManagerServlet.deployUploadFail", e.getMessage()); log(message, e); } finally { if (warPart != null) { warPart.delete(); } warPart = null; } return message; }	protected void deployApps(String name) { File appBase = host.getAppBaseFile(); File configBase = host.getConfigBaseFile(); ContextName cn = new ContextName(name); String baseName = cn.getBaseName(); if (deploymentExists(baseName)) { return; } File xml = new File(configBase, baseName + ".xml"); if (xml.exists()) { deployDescriptor(cn, xml); return; } File war = new File(appBase, baseName + ".war"); if (war.exists()) { deployWAR(cn, war); return; } File dir = new File(appBase, baseName); if (dir.exists()) deployDirectory(cn, dir); }	protected void deployDescriptors(File configBase, String[] files) { if (files == null) return; ExecutorService es = host.getStartStopExecutor(); List<Future<?>> results = new ArrayList<>(); for (int i = 0; i < files.length; i++) { File contextXml = new File(configBase, files[i]); if (files[i].toLowerCase(Locale.ENGLISH).endsWith(".xml")) { ContextName cn = new ContextName(files[i]); if (isServiced(cn.getName()) || deploymentExists(cn.getName())) continue; results.add(es.submit(new DeployDescriptor(this, cn, contextXml))); } } for (Future<?> result : results) { try { result.get(); } catch (Exception e) { log.error(sm.getString("hostConfig.deployDescriptor.threaded.error"), e); } } }	protected void deployDirectories(File appBase, String[] files) { if (files == null) return; ExecutorService es = host.getStartStopExecutor(); List<Future<?>> results = new ArrayList<>(); for (int i = 0; i < files.length; i++) { if (files[i].equalsIgnoreCase("META-INF")) continue; if (files[i].equalsIgnoreCase("WEB-INF")) continue; File dir = new File(appBase, files[i]); if (dir.isDirectory()) { ContextName cn = new ContextName(files[i]); if (isServiced(cn.getName()) || deploymentExists(cn.getName())) continue; results.add(es.submit(new DeployDirectory(this, cn, dir))); } } for (Future<?> result : results) { try { result.get(); } catch (Exception e) { log.error(sm.getString("hostConfig.deployDir.threaded.error"), e); } } }	protected void deployWARs(File appBase, String[] files) { if (files == null) return; ExecutorService es = host.getStartStopExecutor(); List<Future<?>> results = new ArrayList<>(); for (int i = 0; i < files.length; i++) { if (files[i].equalsIgnoreCase("META-INF")) continue; if (files[i].equalsIgnoreCase("WEB-INF")) continue; File war = new File(appBase, files[i]); if (files[i].toLowerCase(Locale.ENGLISH).endsWith(".war") && war.isFile() && !invalidWars.contains(files[i])) { ContextName cn = new ContextName(files[i]); if (isServiced(cn.getName())) { continue; } if (deploymentExists(cn.getName())) { DeployedApplication app = deployed.get(cn.getName()); if (!unpackWARs && app != null) { // Need to check for a directory that should not be File dir = new File(appBase, cn.getBaseName()); if (dir.exists()) { if (!app.loggedDirWarning) { log.warn(sm.getString("hostConfig.deployWar.hiddenDir", dir.getAbsoluteFile(), war.getAbsoluteFile())); app.loggedDirWarning = true; } } else { app.loggedDirWarning = false; } } continue; } if (!validateContextPath(appBase, cn.getBaseName())) { log.error(sm.getString("hostConfig.illegalWarName", files[i])); invalidWars.add(files[i]); continue; } results.add(es.submit(new DeployWar(this, cn, war))); } } for (Future<?> result : results) { try { result.get(); } catch (Exception e) { log.error(sm.getString("hostConfig.deployWar.threaded.error"), e); } } }	public ObjectName[] getChildren() { ObjectName[] result = new ObjectName[children.size()]; Iterator<Container> it = children.values().iterator(); int i = 0; while (it.hasNext()) { Object next = it.next(); if (next instanceof ContainerBase) { result[i++] = ((ContainerBase) next).getObjectName(); } } return result; }	@Override public String getMBeanKeyProperties() { Container c = this; StringBuilder keyProperties = new StringBuilder(); int containerCount = 0; while (!(c instanceof Engine)) { if (c instanceof Context) { keyProperties.append(",context="); ContextName cn = new ContextName(c.getName()); keyProperties.append(cn.getDisplayName()); } else if (c instanceof Host) { keyProperties.append(",host="); keyProperties.append(c.getName()); } else if (c == null) { keyProperties.append(",container"); keyProperties.append(containerCount++); keyProperties.append("=null"); break; } else { keyProperties.append(",container"); keyProperties.append(containerCount++); keyProperties.append('='); keyProperties.append(c.getName()); } c = c.getParent(); } return keyProperties.toString(); }	public static ObjectName createObjectName(String domain, ContextResourceLink resourceLink) throws MalformedObjectNameException { ObjectName name = null; String quotedResourceLinkName = ObjectName.quote(resourceLink.getName()); Object container = resourceLink.getNamingResources().getContainer(); if (container instanceof Server) { name = new ObjectName(domain + ":type=ResourceLink" + ",resourcetype=Global" + ",name=" + quotedResourceLinkName); } else if (container instanceof Context) { Context context = ((Context) container); ContextName cn = new ContextName(context.getName()); Container host = context.getParent(); name = new ObjectName(domain + ":type=ResourceLink" + ",resourcetype=Context,host=" + host.getName() + ",context=" + cn.getDisplayName() + ",name=" + quotedResourceLinkName); } return (name); }	public synchronized void checkUndeploy() { SortedSet<String> sortedAppNames = new TreeSet<>(); sortedAppNames.addAll(deployed.keySet()); if (sortedAppNames.size() < 2) { return; } Iterator<String> iter = sortedAppNames.iterator(); ContextName previous = new ContextName(iter.next()); do { ContextName current = new ContextName(iter.next()); if (current.getPath().equals(previous.getPath())) { // Current and previous are same path - current will always Context previousContext = (Context) host.findChild(previous.getName()); Context currentContext = (Context) host.findChild(previous.getName()); if (previousContext != null && currentContext != null && currentContext.getState().isAvailable() && !isServiced(previous.getName())) { Manager manager = previousContext.getManager(); if (manager != null) { int sessionCount; if (manager instanceof DistributedManager) { sessionCount = ((DistributedManager) manager).getActiveSessionsFull(); } else { sessionCount = manager.getActiveSessions(); } if (sessionCount == 0) { if (log.isInfoEnabled()) { log.info(sm.getString("hostConfig.undeployVersion", previous.getName())); } DeployedApplication app = deployed.get(previous.getName()); String[] resources = app.redeployResources.keySet().toArray(new String[0]); // Version is unused - undeploy it completely // The -1 is a 'trick' to ensure all redeploy undeploy(app); deleteRedeployResources(app, resources, -1, true); } } } } previous = current; } while (iter.hasNext()); }	@Override public void fileModified(File newWar) { try { File deployWar = new File(getDeployDirFile(), newWar.getName()); ContextName cn = new ContextName(deployWar.getName()); if (deployWar.exists() && deployWar.lastModified() > newWar.lastModified()) { if (log.isInfoEnabled()) log.info(sm.getString("farmWarDeployer.alreadyDeployed", cn.getName())); return; } if (log.isInfoEnabled()) log.info(sm.getString("farmWarDeployer.modInstall", cn.getName(), deployWar.getAbsolutePath())); if (!isServiced(cn.getName())) { addServiced(cn.getName()); try { copy(newWar, deployWar); check(cn.getName()); } finally { removeServiced(cn.getName()); } } else { log.error(sm.getString("farmWarDeployer.servicingDeploy", cn.getName(), deployWar.getName())); } install(cn.getName(), deployWar); } catch (Exception x) { log.error(sm.getString("farmWarDeployer.modInstallFail"), x); } }	@Override public void fileRemoved(File removeWar) { try { ContextName cn = new ContextName(removeWar.getName()); if (log.isInfoEnabled()) log.info(sm.getString("farmWarDeployer.removeLocal", cn.getName())); remove(cn.getName(), true); } catch (Exception x) { log.error(sm.getString("farmWarDeployer.removeLocalFail"), x); } }	public void setUp() throws Exception { cn1 = new ContextName(null, null); cn2 = new ContextName("", null); cn3 = new ContextName("/", null); cn4 = new ContextName("/foo", null); cn5 = new ContextName("/foo/bar", null); cn6 = new ContextName(null, "A"); cn7 = new ContextName("", "B"); cn8 = new ContextName("/", "C"); cn9 = new ContextName("/foo", "D"); cn10 = new ContextName("/foo/bar", "E"); cn11 = new ContextName("ROOT"); cn12 = new ContextName("foo"); cn13 = new ContextName("foo#bar"); cn14 = new ContextName("ROOT##A"); cn15 = new ContextName("foo##D"); cn16 = new ContextName("foo#bar##E"); cn17 = new ContextName("/ROOT", null); cn18 = new ContextName("/ROOT#bar"); cn19 = new ContextName("/ROOT#bar##A"); cn20 = new ContextName("/ROOT##A"); }	public void store(PrintWriter aWriter, int indent, Object aContext) throws Exception { if (aContext instanceof StandardContext) { StoreDescription desc = getRegistry().findDescription(aContext.getClass()); if (desc.isStoreSeparate()) { URL configFile = ((StandardContext) aContext).getConfigFile(); if (configFile != null) { if (desc.isExternalAllowed()) { if (desc.isBackup()) storeWithBackup((StandardContext) aContext); else storeContextSeparate(aWriter, indent, (StandardContext) aContext); return; } } else if (desc.isExternalOnly()) { Context context = ((StandardContext) aContext); Host host = (Host) context.getParent(); File configBase = host.getConfigBaseFile(); ContextName cn = new ContextName(context.getName()); String baseName = cn.getBaseName(); File xml = new File(configBase, baseName + ".xml"); context.setConfigFile(xml.toURI().toURL()); if (desc.isBackup()) storeWithBackup((StandardContext) aContext); else storeContextSeparate(aWriter, indent, (StandardContext) aContext); return; } } } super.store(aWriter, indent, aContext); }	@Test public void testConstructorString() { doTestConstructorString(cn1); doTestConstructorString(cn2); doTestConstructorString(cn3); doTestConstructorString(cn4); doTestConstructorString(cn5); doTestConstructorString(cn6); doTestConstructorString(cn7); doTestConstructorString(cn8); doTestConstructorString(cn9); doTestConstructorString(cn10); doTestConstructorString(cn11); doTestConstructorString(cn12); doTestConstructorString(cn13); doTestConstructorString(cn14); doTestConstructorString(cn15); doTestConstructorString(cn16); doTestConstructorString(cn17); doTestConstructorString(cn18); doTestConstructorString(cn19); doTestConstructorString(cn20); }	@Test public void testGetBaseName() { assertEquals("ROOT", cn1.getBaseName()); assertEquals("ROOT", cn2.getBaseName()); assertEquals("ROOT", cn3.getBaseName()); assertEquals("foo", cn4.getBaseName()); assertEquals("foo#bar", cn5.getBaseName()); assertEquals("ROOT##A", cn6.getBaseName()); assertEquals("ROOT##B", cn7.getBaseName()); assertEquals("ROOT##C", cn8.getBaseName()); assertEquals("foo##D", cn9.getBaseName()); assertEquals("foo#bar##E", cn10.getBaseName()); assertEquals("ROOT", cn11.getBaseName()); assertEquals("foo", cn12.getBaseName()); assertEquals("foo#bar", cn13.getBaseName()); assertEquals("ROOT##A", cn14.getBaseName()); assertEquals("foo##D", cn15.getBaseName()); assertEquals("foo#bar##E", cn16.getBaseName()); assertEquals("ROOT", cn17.getBaseName()); assertEquals("ROOT#bar", cn18.getBaseName()); assertEquals("ROOT#bar##A", cn19.getBaseName()); assertEquals("ROOT##A", cn20.getBaseName()); }	@Test public void testGetDisplayName() { assertEquals("/", cn1.getDisplayName()); assertEquals("/", cn2.getDisplayName()); assertEquals("/", cn3.getDisplayName()); assertEquals("/foo", cn4.getDisplayName()); assertEquals("/foo/bar", cn5.getDisplayName()); assertEquals("/##A", cn6.getDisplayName()); assertEquals("/##B", cn7.getDisplayName()); assertEquals("/##C", cn8.getDisplayName()); assertEquals("/foo##D", cn9.getDisplayName()); assertEquals("/foo/bar##E", cn10.getDisplayName()); assertEquals("/", cn11.getDisplayName()); assertEquals("/foo", cn12.getDisplayName()); assertEquals("/foo/bar", cn13.getDisplayName()); assertEquals("/##A", cn14.getDisplayName()); assertEquals("/foo##D", cn15.getDisplayName()); assertEquals("/foo/bar##E", cn16.getDisplayName()); assertEquals("/", cn17.getDisplayName()); assertEquals("/ROOT/bar", cn18.getDisplayName()); assertEquals("/ROOT/bar##A", cn19.getDisplayName()); assertEquals("/##A", cn20.getDisplayName()); }	@Test public void testGetName() { assertEquals("", cn1.getName()); assertEquals("", cn2.getName()); assertEquals("", cn3.getName()); assertEquals("/foo", cn4.getName()); assertEquals("/foo/bar", cn5.getName()); assertEquals("##A", cn6.getName()); assertEquals("##B", cn7.getName()); assertEquals("##C", cn8.getName()); assertEquals("/foo##D", cn9.getName()); assertEquals("/foo/bar##E", cn10.getName()); assertEquals("", cn11.getName()); assertEquals("/foo", cn12.getName()); assertEquals("/foo/bar", cn13.getName()); assertEquals("##A", cn14.getName()); assertEquals("/foo##D", cn15.getName()); assertEquals("/foo/bar##E", cn16.getName()); assertEquals("", cn17.getName()); assertEquals("/ROOT/bar", cn18.getName()); assertEquals("/ROOT/bar##A", cn19.getName()); assertEquals("##A", cn20.getName()); }	@Test public void testGetPath() { assertEquals("", cn1.getPath()); assertEquals("", cn2.getPath()); assertEquals("", cn3.getPath()); assertEquals("/foo", cn4.getPath()); assertEquals("/foo/bar", cn5.getPath()); assertEquals("", cn6.getPath()); assertEquals("", cn7.getPath()); assertEquals("", cn8.getPath()); assertEquals("/foo", cn9.getPath()); assertEquals("/foo/bar", cn10.getPath()); assertEquals("", cn11.getPath()); assertEquals("/foo", cn12.getPath()); assertEquals("/foo/bar", cn13.getPath()); assertEquals("", cn14.getPath()); assertEquals("/foo", cn15.getPath()); assertEquals("/foo/bar", cn16.getPath()); assertEquals("", cn17.getPath()); assertEquals("/ROOT/bar", cn18.getPath()); assertEquals("/ROOT/bar", cn19.getPath()); assertEquals("", cn20.getPath()); }	@Test public void testGetVersion() { assertEquals("", cn1.getVersion()); assertEquals("", cn2.getVersion()); assertEquals("", cn3.getVersion()); assertEquals("", cn4.getVersion()); assertEquals("", cn5.getVersion()); assertEquals("A", cn6.getVersion()); assertEquals("B", cn7.getVersion()); assertEquals("C", cn8.getVersion()); assertEquals("D", cn9.getVersion()); assertEquals("E", cn10.getVersion()); assertEquals("", cn11.getVersion()); assertEquals("", cn12.getVersion()); assertEquals("", cn13.getVersion()); assertEquals("A", cn14.getVersion()); assertEquals("D", cn15.getVersion()); assertEquals("E", cn16.getVersion()); assertEquals("", cn17.getVersion()); assertEquals("", cn18.getVersion()); assertEquals("A", cn19.getVersion()); assertEquals("A", cn20.getVersion()); }	static ObjectName createObjectName(String domain, Loader loader) throws MalformedObjectNameException { ObjectName name = null; Context context = loader.getContext(); ContextName cn = new ContextName(context.getName()); Container host = context.getParent(); name = new ObjectName(domain + ":type=Loader,host=" + host.getName() + ",context=" + cn.getDisplayName()); return name; }
public void setUp() throws Exception { cn1 = new ContextName(null, null); cn2 = new ContextName("", null); cn3 = new ContextName("/", null); cn4 = new ContextName("/foo", null); cn5 = new ContextName("/foo/bar", null); cn6 = new ContextName(null, "A"); cn7 = new ContextName("", "B"); cn8 = new ContextName("/", "C"); cn9 = new ContextName("/foo", "D"); cn10 = new ContextName("/foo/bar", "E"); cn11 = new ContextName("ROOT"); cn12 = new ContextName("foo"); cn13 = new ContextName("foo#bar"); cn14 = new ContextName("ROOT##A"); cn15 = new ContextName("foo##D"); cn16 = new ContextName("foo#bar##E"); }	@Test public void testConstructorString() { doTestConstructorString(cn1); doTestConstructorString(cn2); doTestConstructorString(cn3); doTestConstructorString(cn4); doTestConstructorString(cn5); doTestConstructorString(cn6); doTestConstructorString(cn7); doTestConstructorString(cn8); doTestConstructorString(cn9); doTestConstructorString(cn10); doTestConstructorString(cn11); doTestConstructorString(cn12); doTestConstructorString(cn13); doTestConstructorString(cn14); doTestConstructorString(cn15); doTestConstructorString(cn16); }	@Test public void testGetBaseName() { assertEquals("ROOT", cn1.getBaseName()); assertEquals("ROOT", cn2.getBaseName()); assertEquals("ROOT", cn3.getBaseName()); assertEquals("foo", cn4.getBaseName()); assertEquals("foo#bar", cn5.getBaseName()); assertEquals("ROOT##A", cn6.getBaseName()); assertEquals("ROOT##B", cn7.getBaseName()); assertEquals("ROOT##C", cn8.getBaseName()); assertEquals("foo##D", cn9.getBaseName()); assertEquals("foo#bar##E", cn10.getBaseName()); assertEquals("ROOT", cn11.getBaseName()); assertEquals("foo", cn12.getBaseName()); assertEquals("foo#bar", cn13.getBaseName()); assertEquals("ROOT##A", cn14.getBaseName()); assertEquals("foo##D", cn15.getBaseName()); assertEquals("foo#bar##E", cn16.getBaseName()); }	@Test public void testGetDisplayName() { assertEquals("/", cn1.getDisplayName()); assertEquals("/", cn2.getDisplayName()); assertEquals("/", cn3.getDisplayName()); assertEquals("/foo", cn4.getDisplayName()); assertEquals("/foo/bar", cn5.getDisplayName()); assertEquals("/##A", cn6.getDisplayName()); assertEquals("/##B", cn7.getDisplayName()); assertEquals("/##C", cn8.getDisplayName()); assertEquals("/foo##D", cn9.getDisplayName()); assertEquals("/foo/bar##E", cn10.getDisplayName()); assertEquals("/", cn11.getDisplayName()); assertEquals("/foo", cn12.getDisplayName()); assertEquals("/foo/bar", cn13.getDisplayName()); assertEquals("/##A", cn14.getDisplayName()); assertEquals("/foo##D", cn15.getDisplayName()); assertEquals("/foo/bar##E", cn16.getDisplayName()); }	@Test public void testGetName() { assertEquals("", cn1.getName()); assertEquals("", cn2.getName()); assertEquals("", cn3.getName()); assertEquals("/foo", cn4.getName()); assertEquals("/foo/bar", cn5.getName()); assertEquals("##A", cn6.getName()); assertEquals("##B", cn7.getName()); assertEquals("##C", cn8.getName()); assertEquals("/foo##D", cn9.getName()); assertEquals("/foo/bar##E", cn10.getName()); assertEquals("", cn11.getName()); assertEquals("/foo", cn12.getName()); assertEquals("/foo/bar", cn13.getName()); assertEquals("##A", cn14.getName()); assertEquals("/foo##D", cn15.getName()); assertEquals("/foo/bar##E", cn16.getName()); }	@Test public void testGetPath() { assertEquals("", cn1.getPath()); assertEquals("", cn2.getPath()); assertEquals("", cn3.getPath()); assertEquals("/foo", cn4.getPath()); assertEquals("/foo/bar", cn5.getPath()); assertEquals("", cn6.getPath()); assertEquals("", cn7.getPath()); assertEquals("", cn8.getPath()); assertEquals("/foo", cn9.getPath()); assertEquals("/foo/bar", cn10.getPath()); assertEquals("", cn11.getPath()); assertEquals("/foo", cn12.getPath()); assertEquals("/foo/bar", cn13.getPath()); assertEquals("", cn14.getPath()); assertEquals("/foo", cn15.getPath()); assertEquals("/foo/bar", cn16.getPath()); }	@Test public void testGetVersion() { assertEquals("", cn1.getVersion()); assertEquals("", cn2.getVersion()); assertEquals("", cn3.getVersion()); assertEquals("", cn4.getVersion()); assertEquals("", cn5.getVersion()); assertEquals("A", cn6.getVersion()); assertEquals("B", cn7.getVersion()); assertEquals("C", cn8.getVersion()); assertEquals("D", cn9.getVersion()); assertEquals("E", cn10.getVersion()); assertEquals("", cn11.getVersion()); assertEquals("", cn12.getVersion()); assertEquals("", cn13.getVersion()); assertEquals("A", cn14.getVersion()); assertEquals("D", cn15.getVersion()); assertEquals("E", cn16.getVersion()); }
public void recycle() { contentType = null; contentLanguage = null; locale = DEFAULT_LOCALE; characterEncoding = Constants.DEFAULT_CHARACTER_ENCODING; charsetSet = false; contentLength = -1; status = 200; message = null; commited = false; commitTime = -1; errorException = null; headers.clear(); listener = null; contentWritten = 0; }
protected void scanJspConfig() throws IOException, SAXException { JspConfigDescriptor jspConfigDescriptor = context.getJspConfigDescriptor(); if (jspConfigDescriptor == null) { return; } Collection<TaglibDescriptor> descriptors = jspConfigDescriptor.getTaglibs(); for (TaglibDescriptor descriptor : descriptors) { String taglibURI = descriptor.getTaglibURI(); String resourcePath = descriptor.getTaglibLocation(); if (!resourcePath.startsWith("/")) { resourcePath = WEB_INF + resourcePath; } if (uriTldResourcePathMap.containsKey(taglibURI)) { log.warn(Localizer.getMessage(MSG + ".webxmlSkip", resourcePath, taglibURI)); continue; } if (log.isTraceEnabled()) { log.trace(Localizer.getMessage(MSG + ".webxmlAdd", resourcePath, taglibURI)); } URL url = context.getResource(resourcePath); TldResourcePath tldResourcePath; if (resourcePath.endsWith(".jar")) { // if the path points to a jar file, the TLD is presumed to be tldResourcePath = new TldResourcePath(url, resourcePath, "META-INF/taglib.tld"); } else { tldResourcePath = new TldResourcePath(url, resourcePath); } TaglibXml tld = tldParser.parse(tldResourcePath); uriTldResourcePathMap.put(taglibURI, tldResourcePath); tldResourcePathTaglibXmlMap.put(tldResourcePath, tld); if (tld.getListeners() != null) { listeners.addAll(tld.getListeners()); } } }
private String initClassPath() { StringBuilder cpath = new StringBuilder(); String sep = System.getProperty("path.separator"); if (parentClassLoader instanceof URLClassLoader) { URL[] urls = ((URLClassLoader) parentClassLoader).getURLs(); for (int i = 0; i < urls.length; i++) { if (urls[i].getProtocol().equals("file")) { cpath.append(urls[i].getFile() + sep); } } } cpath.append(options.getScratchDir() + sep); String cp = (String) context.getAttribute(Constants.SERVLET_CLASSPATH); if (cp == null || cp.equals("")) { cp = options.getClassPath(); } String path = cpath.toString() + cp; if (log.isDebugEnabled()) { log.debug("Compilation classpath initialized: " + path); } return path; }
protected static String listToCommaDelimitedString(List<String> stringList) { if (stringList == null) { return ""; } StringBuilder result = new StringBuilder(); for (Iterator<String> it = stringList.iterator(); it.hasNext(); ) { Object element = it.next(); if (element != null) { result.append(element); if (it.hasNext()) { result.append(", "); } } } return result.toString(); }	protected static String listToCommaDelimitedString(List<String> stringList) { if (stringList == null) { return ""; } StringBuilder result = new StringBuilder(); for (Iterator<String> it = stringList.iterator(); it.hasNext(); ) { Object element = it.next(); if (element != null) { result.append(element); if (it.hasNext()) { result.append(", "); } } } return result.toString(); }
private Map<String, WebXml> scanForFragments(WebXmlParser webXmlParser) throws JasperException { StandardJarScanner scanner = new StandardJarScanner(); scanner.setScanClassPath(false); scanner.setJarScanFilter(new StandardJarScanFilter()); FragmentJarScannerCallback callback = new FragmentJarScannerCallback(webXmlParser, false); scanner.scan(JarScanType.PLUGGABILITY, this, callback); if (!callback.isOk()) { throw new JasperException(Localizer.getMessage("jspc.error.invalidFragment")); } return callback.getFragments(); }	protected Map<String, WebXml> processJarsForWebFragments() { JarScanner jarScanner = context.getJarScanner(); boolean delegate = false; if (context instanceof StandardContext) { delegate = ((StandardContext) context).getDelegate(); } FragmentJarScannerCallback callback = new FragmentJarScannerCallback(webXmlParser, delegate); jarScanner.scan(JarScanType.PLUGGABILITY, context.getServletContext(), callback); if (!callback.isOk()) { ok = false; } return callback.getFragments(); }	protected void webConfig() { /* * Anything and everything can override the global and host defaults. * This is implemented in two parts * - Handle as a web fragment that gets added after everything else so * everything else takes priority * - Mark Servlets as overridable so SCI configuration can replace * configuration from the defaults */ Set<WebXml> defaults = new HashSet<>(); defaults.add(getDefaultWebXmlFragment()); WebXml webXml = createWebXml(); InputSource contextWebXml = getContextWebXmlSource(); if (!webXmlParser.parseWebXml(contextWebXml, webXml, false)) { ok = false; } ServletContext sContext = context.getServletContext(); // Ordering is important here // Step 1. Identify all the JARs packaged with the application and those // provided by the container. If any of the application JARs have a // web-fragment.xml it will be parsed at this point. web-fragment.xml Map<String, WebXml> fragments = processJarsForWebFragments(); Set<WebXml> orderedFragments = null; orderedFragments = WebXml.orderWebFragments(webXml, fragments, sContext); if (ok) { processServletContainerInitializers(sContext); } if (!webXml.isMetadataComplete() || typeInitializerMap.size() > 0) { if (ok) { WebResource[] webResources = context.getResources().listResources("/WEB-INF/classes"); for (WebResource webResource : webResources) { processAnnotationsWebResource(webResource, webXml, webXml.isMetadataComplete()); } } if (ok) { processAnnotations(orderedFragments, webXml.isMetadataComplete()); } javaClassCache.clear(); } if (!webXml.isMetadataComplete()) { if (ok) { ok = webXml.merge(orderedFragments); } // Step 7. Apply global defaults // Have to merge defaults before JSP conversion since defaults webXml.merge(defaults); if (ok) { convertJsps(webXml); } if (ok) { configureContext(webXml); } } else { webXml.merge(defaults); convertJsps(webXml); configureContext(webXml); } // Step 9a. Make the merged web.xml available to other // components, specifically Jasper, to save those components // from having to re-generate it. String mergedWebXml = webXml.toXml(); sContext.setAttribute(org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML, mergedWebXml); if (context.getLogEffectiveWebXml()) { log.info("web.xml:\n" + mergedWebXml); } if (ok) { // Spec does not define an order. Set<WebXml> resourceJars = new LinkedHashSet<>(); if (orderedFragments != null) { for (WebXml fragment : orderedFragments) { resourceJars.add(fragment); } } for (WebXml fragment : fragments.values()) { if (!resourceJars.contains(fragment)) { resourceJars.add(fragment); } } processResourceJARs(resourceJars); // See also StandardContext.resourcesStart() for // WEB-INF/classes/META-INF/resources configuration } if (ok) { for (Map.Entry<ServletContainerInitializer, Set<Class<?>>> entry : initializerClassMap.entrySet()) { if (entry.getValue().isEmpty()) { context.addServletContainerInitializer(entry.getKey(), null); } else { context.addServletContainerInitializer(entry.getKey(), entry.getValue()); } } } }	@Override public void scan(JarURLConnection jarConn, String webappPath, boolean isWebapp) throws IOException { URL url = jarConn.getURL(); URL resourceURL = jarConn.getJarFileURL(); Jar jar = null; InputStream is = null; WebXml fragment = new WebXml(); fragment.setWebappJar(isWebapp); fragment.setDelegate(delegate); try { if (isWebapp) { jar = JarFactory.newInstance(url); is = jar.getInputStream(FRAGMENT_LOCATION); } if (is == null) { // If there is no web.xml, normal JAR no impact on fragment.setDistributable(true); } else { InputSource source = new InputSource("jar:" + resourceURL.toString() + "!/" + FRAGMENT_LOCATION); source.setByteStream(is); if (!webXmlParser.parseWebXml(source, fragment, true)) { ok = false; } } } finally { if (jar != null) { jar.close(); } fragment.setURL(url); if (fragment.getName() == null) { fragment.setName(fragment.getURL().toString()); } fragment.setJarName(extractJarFileName(url)); fragments.put(fragment.getName(), fragment); } }
private SSLEngine createSSLEngine(Map<String, Object> userProperties) throws DeploymentException { try { SSLContext sslContext = SSLContext.getInstance("TLS"); String sslTrustStoreValue = (String) userProperties.get(SSL_TRUSTSTORE_PROPERTY); if (sslTrustStoreValue != null) { String sslTrustStorePwdValue = (String) userProperties.get(SSL_TRUSTSTORE_PWD_PROPERTY); if (sslTrustStorePwdValue == null) { sslTrustStorePwdValue = SSL_TRUSTSTORE_PWD_DEFAULT; } File keyStoreFile = new File(sslTrustStoreValue); KeyStore ks = KeyStore.getInstance("JKS"); try (InputStream is = new FileInputStream(keyStoreFile)) { ks.load(is, sslTrustStorePwdValue.toCharArray()); } TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(ks); sslContext.init(null, tmf.getTrustManagers(), null); } else { sslContext.init(null, null, null); } SSLEngine engine = sslContext.createSSLEngine(); String sslProtocolsValue = (String) userProperties.get(SSL_PROTOCOLS_PROPERTY); if (sslProtocolsValue != null) { engine.setEnabledProtocols(sslProtocolsValue.split(",")); } engine.setUseClientMode(true); return engine; } catch (Exception e) { throw new DeploymentException(sm.getString("wsWebSocketContainer.sslEngineFail"), e); } }

public void flushBuffer() throws IOException { if (out == null) { throw new IOException("Buffer overflow, no sink " + limit + " " + buff.length); } out.realWriteBytes(buff, start, end - start); end = start; }	@Override public void realWriteChars(char[] buf, int off, int len) throws IOException { outputCharChunk.setChars(buf, off, len); while (outputCharChunk.getLength() > 0) { conv.convert(outputCharChunk, bb); if (bb.getLength() == 0) { break; } if (outputCharChunk.getLength() > 0) { bb.flushBuffer(); } } }
private WebResource[] listResources(String path, boolean validate) { if (validate) { path = validate(path); } String[] resources = list(path, false); WebResource[] result = new WebResource[resources.length]; for (int i = 0; i < resources.length; i++) { if (path.charAt(path.length() - 1) == '/') { result[i] = getResource(path + resources[i], false, false); } else { result[i] = getResource(path + '/' + resources[i], false, false); } } return result; }	@Override public String getCanonicalPath() { return null; }	@Override public Set<String> listWebAppPaths(String path) { checkPath(path); String webAppMount = getWebAppMount(); ResourceSet<String> result = new ResourceSet<>(); if (path.startsWith(webAppMount)) { File f = file(path.substring(webAppMount.length()), true); if (f != null) { File[] list = f.listFiles(); if (list != null) { for (File entry : list) { StringBuilder sb = new StringBuilder(path); if (path.charAt(path.length() - 1) != '/') { sb.append('/'); } sb.append(entry.getName()); if (entry.isDirectory()) { sb.append('/'); } result.add(sb.toString()); } } } } else { if (!path.endsWith("/")) { path = path + "/"; } if (webAppMount.startsWith(path)) { int i = webAppMount.indexOf('/', path.length()); if (i == -1) { result.add(webAppMount + "/"); } else { result.add(webAppMount.substring(0, i + 1)); } } } result.setLocked(true); return result; }	@Test public final void testWrite() { InputStream is = new ByteArrayInputStream("test".getBytes()); if (isWriteable()) { Assert.assertTrue(resourceRoot.write(getMount() + "/new-test", is, false)); File file = new File(getBaseDir(), "new-test"); Assert.assertTrue(file.exists()); Assert.assertTrue(file.delete()); } else { Assert.assertFalse(resourceRoot.write(getMount() + "/new-test", is, false)); } }
@Override public Principal getUserPrincipal() { if (userPrincipal instanceof TomcatPrincipal) { return ((TomcatPrincipal) userPrincipal).getUserPrincipal(); } return userPrincipal; }
@Override public void open() throws Exception { synchronized (groups) { synchronized (users) { users.clear(); groups.clear(); roles.clear(); File file = new File(pathname); if (!file.isAbsolute()) { file = new File(System.getProperty(Globals.CATALINA_BASE_PROP), pathname); } if (!file.exists()) { return; } Digester digester = new Digester(); try { digester.setFeature("http://apache.org/xml/features/allow-java-encodings", true); } catch (Exception e) { log.warn(sm.getString("memoryUserDatabase.xmlFeatureEncoding"), e); } digester.addFactoryCreate("tomcat-users/group", new MemoryGroupCreationFactory(this), true); digester.addFactoryCreate("tomcat-users/role", new MemoryRoleCreationFactory(this), true); digester.addFactoryCreate("tomcat-users/user", new MemoryUserCreationFactory(this), true); FileInputStream fis = null; try { fis = new FileInputStream(file); digester.parse(fis); } finally { if (fis != null) { try { fis.close(); } catch (IOException ioe) { // Ignore } } } } } }
protected synchronized Principal getPrincipal(DirContext context, String username, GSSCredential gssCredential) throws NamingException { User user = null; List<String> roles = null; Hashtable<?, ?> preservedEnvironment = null; try { if (gssCredential != null && isUseDelegatedCredential()) { preservedEnvironment = context.getEnvironment(); context.addToEnvironment(Context.SECURITY_AUTHENTICATION, "GSSAPI"); context.addToEnvironment("javax.security.sasl.server.authentication", "true"); context.addToEnvironment("javax.security.sasl.qop", "auth-conf"); // Note: Subject already set in SPNEGO authenticator so no need // for Subject.doAs() here } user = getUser(context, username); if (user != null) { roles = getRoles(context, user); } } finally { restoreEnvironmentParameter(context, Context.SECURITY_AUTHENTICATION, preservedEnvironment); restoreEnvironmentParameter(context, "javax.security.sasl.server.authentication", preservedEnvironment); restoreEnvironmentParameter(context, "javax.security.sasl.qop", preservedEnvironment); } if (user != null) { return new GenericPrincipal(user.getUserName(), user.getPassword(), roles, null, null, gssCredential); } return null; }	public void setTimeLimit(int timeLimit) { this.timeLimit = timeLimit; }	public void setUseDelegatedCredential(boolean useDelegatedCredential) { this.useDelegatedCredential = useDelegatedCredential; }
private WebResource getResource(String path, boolean doStateCheck, boolean useClassLoaderResources) { if (doStateCheck) { checkState(); } if (isCachingAllowed()) { return cache.getResource(path, useClassLoaderResources); } else { return getResourceInternal(path, useClassLoaderResources); } }	private void checkPath(String path) { if (path == null || path.length() == 0 || !path.startsWith("/")) { throw new IllegalArgumentException(sm.getString("standardRoot.invalidPath", path)); } }	private WebResource[] listResources(String path, boolean doStateCheck) { if (doStateCheck) { checkState(); } String[] resources = list(path, false); WebResource[] result = new WebResource[resources.length]; for (int i = 0; i < resources.length; i++) { if (path.charAt(path.length() - 1) == '/') { result[i] = getResource(path + resources[i], false, false); } else { result[i] = getResource(path + '/' + resources[i], false, false); } } return result; }	@Override public Set<String> listWebAppPaths(String path) { checkState(); HashSet<String> result = new HashSet<>(); for (ArrayList<WebResourceSet> list : allResources) { for (WebResourceSet webResourceSet : list) { if (!webResourceSet.getClassLoaderOnly()) { result.addAll(webResourceSet.listWebAppPaths(path)); } } } if (result.size() == 0) { return null; } return result; }	@Override public WebResource[] getClassLoaderResources(String path) { checkPath(path); return getResources("/WEB-INF/classes" + path, true); }	@Override public WebResource getResource(String path) { return getResource(path, true, false); }	@Override public boolean mkdir(String path) { checkState(); if (preResourceExists(path)) { return false; } return main.mkdir(path); }	@Override public boolean write(String path, InputStream is, boolean overwrite) { checkState(); if (!overwrite && preResourceExists(path)) { return false; } return main.write(path, is, overwrite); }	@Override public void setContext(Context context) { this.context = context; }
private void doTestBug53677(boolean flush) throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctxt = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(ctxt, "LargeHeaderServlet", new LargeHeaderServlet(flush)); ctxt.addServletMapping("/test", "LargeHeaderServlet"); tomcat.start(); ByteChunk responseBody = new ByteChunk(); Map<String, List<String>> responseHeaders = new HashMap<>(); int rc = getUrl("http://localhost:" + getPort() + "/test", responseBody, responseHeaders); assertEquals(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, rc); if (responseBody.getLength() > 0) { // It will be >0 if the standard error page handlign has been assertFalse(responseBody.toString().contains("FAIL")); } }	@Override public final void action(ActionCode actionCode, Object param) { if (actionCode == ActionCode.CLOSE) { try { finish(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.COMMIT) { if (response.isCommitted()) return; try { prepareResponse(); } catch (IOException e) { error = true; } try { flush(false); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACK) { // NO_OP for AJP } else if (actionCode == ActionCode.CLIENT_FLUSH) { if (!response.isCommitted()) { try { prepareResponse(); } catch (IOException e) { error = true; return; } } try { flush(true); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.DISABLE_SWALLOW_INPUT) { // TODO: Do not swallow request input but error = true; } else if (actionCode == ActionCode.RESET) { // NO-OP } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE) { if (!certificates.isNull()) { ByteChunk certData = certificates.getByteChunk(); X509Certificate[] jsseCerts = null; ByteArrayInputStream bais = new ByteArrayInputStream(certData.getBytes(), certData.getStart(), certData.getLength()); try { CertificateFactory cf; if (clientCertProvider == null) { cf = CertificateFactory.getInstance("X.509"); } else { cf = CertificateFactory.getInstance("X.509", clientCertProvider); } while (bais.available() > 0) { X509Certificate cert = (X509Certificate) cf.generateCertificate(bais); if (jsseCerts == null) { jsseCerts = new X509Certificate[1]; jsseCerts[0] = cert; } else { X509Certificate[] temp = new X509Certificate[jsseCerts.length + 1]; System.arraycopy(jsseCerts, 0, temp, 0, jsseCerts.length); temp[jsseCerts.length] = cert; jsseCerts = temp; } } } catch (java.security.cert.CertificateException e) { getLog().error(sm.getString("ajpprocessor.certs.fail"), e); return; } catch (NoSuchProviderException e) { getLog().error(sm.getString("ajpprocessor.certs.fail"), e); return; } request.setAttribute(SSLSupport.CERTIFICATE_KEY, jsseCerts); } } else if (actionCode == ActionCode.REQ_SSL_CERTIFICATE) { // NO-OP. Can't force a new SSL handshake with the client when using // AJP as the reverse proxy controls that connection. } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) { if (request.remoteHost().isNull()) { try { request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName()); } catch (IOException iex) { // Ignore } } } else if (actionCode == ActionCode.REQ_HOST_ADDR_ATTRIBUTE) { // NO-OP // Automatically populated during prepareRequest() } else if (actionCode == ActionCode.REQ_LOCAL_NAME_ATTRIBUTE) { // NO-OP // Automatically populated during prepareRequest() } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) { request.localAddr().setString(request.localName().toString()); } else if (actionCode == ActionCode.REQ_REMOTEPORT_ATTRIBUTE) { // NO-OP // This information is not available when using the AJP protocol } else if (actionCode == ActionCode.REQ_LOCALPORT_ATTRIBUTE) { // NO-OP // Automatically populated during prepareRequest() } else if (actionCode == ActionCode.REQ_SET_BODY_REPLAY) { ByteChunk bc = (ByteChunk) param; int length = bc.getLength(); bodyBytes.setBytes(bc.getBytes(), bc.getStart(), length); request.setContentLength(length); first = false; empty = false; replay = true; endOfStream = false; } else if (actionCode == ActionCode.ASYNC_START) { asyncStateMachine.asyncStart((AsyncContextCallback) param); } else if (actionCode == ActionCode.ASYNC_COMPLETE) { socketWrapper.clearDispatches(); if (asyncStateMachine.asyncComplete()) { endpoint.processSocket(socketWrapper, SocketStatus.OPEN_READ, true); } } else if (actionCode == ActionCode.ASYNC_DISPATCH) { if (asyncStateMachine.asyncDispatch()) { endpoint.processSocket(socketWrapper, SocketStatus.OPEN_READ, true); } } else if (actionCode == ActionCode.ASYNC_DISPATCHED) { asyncStateMachine.asyncDispatched(); } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) { if (param == null) return; long timeout = ((Long) param).longValue(); socketWrapper.setTimeout(timeout); } else if (actionCode == ActionCode.ASYNC_TIMEOUT) { AtomicBoolean result = (AtomicBoolean) param; result.set(asyncStateMachine.asyncTimeout()); } else if (actionCode == ActionCode.ASYNC_RUN) { asyncStateMachine.asyncRun((Runnable) param); } else if (actionCode == ActionCode.ASYNC_ERROR) { asyncStateMachine.asyncError(); } else if (actionCode == ActionCode.ASYNC_IS_STARTED) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted()); } else if (actionCode == ActionCode.ASYNC_IS_DISPATCHING) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching()); } else if (actionCode == ActionCode.ASYNC_IS_ASYNC) { ((AtomicBoolean) param).set(asyncStateMachine.isAsync()); } else if (actionCode == ActionCode.ASYNC_IS_TIMINGOUT) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut()); } else if (actionCode == ActionCode.ASYNC_IS_ERROR) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncError()); } else if (actionCode == ActionCode.UPGRADE) { throw new UnsupportedOperationException(sm.getString("ajpprocessor.httpupgrade.notsupported")); } else if (actionCode == ActionCode.COMET_BEGIN) { throw new UnsupportedOperationException(sm.getString("ajpprocessor.comet.notsupported")); } else if (actionCode == ActionCode.COMET_END) { throw new UnsupportedOperationException(sm.getString("ajpprocessor.comet.notsupported")); } else if (actionCode == ActionCode.COMET_CLOSE) { throw new UnsupportedOperationException(sm.getString("ajpprocessor.comet.notsupported")); } else if (actionCode == ActionCode.COMET_SETTIMEOUT) { throw new UnsupportedOperationException(sm.getString("ajpprocessor.comet.notsupported")); } else if (actionCode == ActionCode.AVAILABLE) { if (available()) { request.setAvailable(1); } else { request.setAvailable(0); } } else if (actionCode == ActionCode.NB_READ_INTEREST) { if (!endOfStream) { registerForEvent(true, false); } } else if (actionCode == ActionCode.NB_WRITE_INTEREST) { AtomicBoolean isReady = (AtomicBoolean) param; boolean result = bufferedWrites.size() == 0 && responseMsgPos == -1; isReady.set(result); if (!result) { registerForEvent(false, true); } } else if (actionCode == ActionCode.REQUEST_BODY_FULLY_READ) { AtomicBoolean result = (AtomicBoolean) param; result.set(endOfStream); } else if (actionCode == ActionCode.DISPATCH_READ) { socketWrapper.addDispatch(DispatchType.NON_BLOCKING_READ); } else if (actionCode == ActionCode.DISPATCH_WRITE) { socketWrapper.addDispatch(DispatchType.NON_BLOCKING_WRITE); } }	@Override public final void action(ActionCode actionCode, Object param) { if (actionCode == ActionCode.CLOSE) { try { getOutputBuffer().endRequest(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.COMMIT) { if (response.isCommitted()) { return; } try { prepareResponse(); getOutputBuffer().commit(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACK) { if ((response.isCommitted()) || !expectation) { return; } getInputBuffer().setSwallowInput(true); try { getOutputBuffer().sendAck(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.CLIENT_FLUSH) { try { getOutputBuffer().flush(); } catch (IOException e) { error = true; response.setErrorException(e); } } else if (actionCode == ActionCode.DISABLE_SWALLOW_INPUT) { // Do not swallow request input but error = true; getInputBuffer().setSwallowInput(false); } else if (actionCode == ActionCode.RESET) { // Reset response getOutputBuffer().reset(); } else if (actionCode == ActionCode.REQ_SET_BODY_REPLAY) { ByteChunk body = (ByteChunk) param; InputFilter savedBody = new SavedRequestInputFilter(body); savedBody.setRequest(request); @SuppressWarnings("unchecked") AbstractInputBuffer<S> internalBuffer = (AbstractInputBuffer<S>) request.getInputBuffer(); internalBuffer.addActiveFilter(savedBody); } else if (actionCode == ActionCode.ASYNC_START) { asyncStateMachine.asyncStart((AsyncContextCallback) param); } else if (actionCode == ActionCode.ASYNC_DISPATCHED) { asyncStateMachine.asyncDispatched(); } else if (actionCode == ActionCode.ASYNC_TIMEOUT) { AtomicBoolean result = (AtomicBoolean) param; result.set(asyncStateMachine.asyncTimeout()); } else if (actionCode == ActionCode.ASYNC_RUN) { asyncStateMachine.asyncRun((Runnable) param); } else if (actionCode == ActionCode.ASYNC_ERROR) { asyncStateMachine.asyncError(); } else if (actionCode == ActionCode.ASYNC_IS_STARTED) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted()); } else if (actionCode == ActionCode.ASYNC_IS_DISPATCHING) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching()); } else if (actionCode == ActionCode.ASYNC_IS_ASYNC) { ((AtomicBoolean) param).set(asyncStateMachine.isAsync()); } else if (actionCode == ActionCode.ASYNC_IS_TIMINGOUT) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut()); } else if (actionCode == ActionCode.ASYNC_IS_ERROR) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncError()); } else if (actionCode == ActionCode.UPGRADE) { httpUpgradeHandler = (HttpUpgradeHandler) param; getOutputBuffer().finished = true; } else if (actionCode == ActionCode.AVAILABLE) { request.setAvailable(inputBuffer.available()); } else if (actionCode == ActionCode.NB_WRITE_INTEREST) { AtomicBoolean isReady = (AtomicBoolean) param; try { isReady.set(getOutputBuffer().isReady()); } catch (IOException e) { getLog().debug("isReady() failed", e); error = true; } } else if (actionCode == ActionCode.NB_READ_INTEREST) { registerForEvent(true, false); } else if (actionCode == ActionCode.REQUEST_BODY_FULLY_READ) { AtomicBoolean result = (AtomicBoolean) param; result.set(getInputBuffer().isFinished()); } else if (actionCode == ActionCode.DISPATCH_READ) { socketWrapper.addDispatch(DispatchType.NON_BLOCKING_READ); } else if (actionCode == ActionCode.DISPATCH_WRITE) { socketWrapper.addDispatch(DispatchType.NON_BLOCKING_WRITE); } else if (actionCode == ActionCode.DISPATCH_EXECUTE) { getEndpoint().executeNonBlockingDispatches(socketWrapper); } else { actionInternal(actionCode, param); } }	@Override public void action(ActionCode actionCode, Object param) { if (SpdyContext.debug) { // System.err.println(actionCode); } if (actionCode == ActionCode.COMMIT) { maybeCommit(); } else if (actionCode == ActionCode.CLIENT_FLUSH) { maybeCommit(); // try { // flush(true); // } catch (IOException e) { // // Set error flag // error = true; // } } else if (actionCode == ActionCode.DISABLE_SWALLOW_INPUT) { // TODO: Do not swallow request input but error = true; } else if (actionCode == ActionCode.CLOSE) { if (outClosed) { return; } outClosed = true; // Close // End the processing of the current request, and stop any further maybeCommit(); spdyStream.sendDataFrame(EMPTY, 0, 0, true); } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE) { // if (!certificates.isNull()) { // ByteChunk certData = certificates.getByteChunk(); // X509Certificate jsseCerts[] = null; // ByteArrayInputStream bais = // new ByteArrayInputStream(certData.getBytes(), // certData.getStart(), // certData.getLength()); // // Fill the elements. // try { // CertificateFactory cf; // if (clientCertProvider == null) { // cf = CertificateFactory.getInstance("X.509"); // } else { // cf = CertificateFactory.getInstance("X.509", // clientCertProvider); // } // while(bais.available() > 0) { // X509Certificate cert = (X509Certificate) // cf.generateCertificate(bais); // if(jsseCerts == null) { // jsseCerts = new X509Certificate[1]; // jsseCerts[0] = cert; // } else { // X509Certificate [] temp = new // X509Certificate[jsseCerts.length+1]; // System.arraycopy(jsseCerts,0,temp,0,jsseCerts.length); // temp[jsseCerts.length] = cert; // jsseCerts = temp; // } // } // } catch (java.security.cert.CertificateException e) { // getLog().error(sm.getString("ajpprocessor.certs.fail"), e); // return; // } catch (NoSuchProviderException e) { // getLog().error(sm.getString("ajpprocessor.certs.fail"), e); // return; // } // request.setAttribute(SSLSupport.CERTIFICATE_KEY, jsseCerts); // } } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) { if (request.remoteHost().isNull()) { try { request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName()); } catch (IOException iex) { // Ignore } } } else if (actionCode == ActionCode.REQ_LOCALPORT_ATTRIBUTE) { String configured = (String) endpoint.getAttribute("proxyPort"); int localPort = 0; if (configured != null) { localPort = Integer.parseInt(configured); } else { localPort = endpoint.getPort(); } request.setLocalPort(localPort); } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) { InetAddress localAddress = endpoint.getAddress(); String localIp = localAddress == null ? null : localAddress.getHostAddress(); if (localIp == null) { localIp = (String) endpoint.getAttribute("proxyIP"); } if (localIp == null) { localIp = "127.0.0.1"; } request.localAddr().setString(localIp); } else if (actionCode == ActionCode.REQ_HOST_ADDR_ATTRIBUTE) { InetAddress localAddress = endpoint.getAddress(); String localH = localAddress == null ? null : localAddress.getCanonicalHostName(); if (localH == null) { localH = (String) endpoint.getAttribute("proxyName"); } if (localH == null) { localH = "localhost"; } request.localAddr().setString(localH); } else if (actionCode == ActionCode.REQ_SET_BODY_REPLAY) { // // Set the given bytes as the content // ByteChunk bc = (ByteChunk) param; // int length = bc.getLength(); // bodyBytes.setBytes(bc.getBytes(), bc.getStart(), length); // request.setContentLength(length); // first = false; // empty = false; // replay = true; } else if (actionCode == ActionCode.ASYNC_START) { asyncStateMachine.asyncStart((AsyncContextCallback) param); } else if (actionCode == ActionCode.ASYNC_DISPATCHED) { asyncStateMachine.asyncDispatched(); } else if (actionCode == ActionCode.ASYNC_TIMEOUT) { AtomicBoolean result = (AtomicBoolean) param; result.set(asyncStateMachine.asyncTimeout()); } else if (actionCode == ActionCode.ASYNC_RUN) { asyncStateMachine.asyncRun((Runnable) param); } else if (actionCode == ActionCode.ASYNC_ERROR) { asyncStateMachine.asyncError(); } else if (actionCode == ActionCode.ASYNC_IS_STARTED) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted()); } else if (actionCode == ActionCode.ASYNC_IS_DISPATCHING) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching()); } else if (actionCode == ActionCode.ASYNC_IS_ASYNC) { ((AtomicBoolean) param).set(asyncStateMachine.isAsync()); } else if (actionCode == ActionCode.ASYNC_IS_TIMINGOUT) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut()); } else if (actionCode == ActionCode.ASYNC_IS_ERROR) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncError()); } else { // TODO: // actionInternal(actionCode, param); } }	@Override public void service(org.apache.coyote.Request req, org.apache.coyote.Response res) throws Exception { Request request = (Request) req.getNote(ADAPTER_NOTES); Response response = (Response) res.getNote(ADAPTER_NOTES); if (request == null) { request = connector.createRequest(); request.setCoyoteRequest(req); response = connector.createResponse(); response.setCoyoteResponse(res); request.setResponse(response); response.setRequest(request); req.setNote(ADAPTER_NOTES, request); res.setNote(ADAPTER_NOTES, response); req.getParameters().setQueryStringEncoding(connector.getURIEncoding()); } if (connector.getXpoweredBy()) { response.addHeader("X-Powered-By", POWERED_BY); } boolean comet = false; boolean async = false; try { // Parse and set Catalina and configuration specific req.getRequestProcessor().setWorkerThreadName(THREAD_NAME.get()); boolean postParseSuccess = postParseRequest(req, request, res, response); if (postParseSuccess) { request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported()); connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); if (request.isComet()) { if (!response.isClosed() && !response.isError()) { if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) { if (event(req, res, SocketStatus.OPEN_READ)) { comet = true; res.action(ActionCode.COMET_BEGIN, null); } } else { comet = true; res.action(ActionCode.COMET_BEGIN, null); } } else { // Clear the filter chain, as otherwise it will not be reset elsewhere request.setFilterChain(null); } } } AsyncContextImpl asyncConImpl = (AsyncContextImpl) request.getAsyncContext(); if (asyncConImpl != null) { async = true; ReadListener readListener = req.getReadListener(); if (readListener != null) { // Possible the all data may have been read during service() ClassLoader oldCL = Thread.currentThread().getContextClassLoader(); ClassLoader newCL = request.getContext().getLoader().getClassLoader(); try { Thread.currentThread().setContextClassLoader(newCL); if (request.isFinished()) { req.getReadListener().onAllDataRead(); } } finally { Thread.currentThread().setContextClassLoader(oldCL); } } } else if (!comet) { request.finishRequest(); response.finishResponse(); if (postParseSuccess && request.getMappingData().context != null) { // Log only if processing was invoked. // If postParseRequest() failed, it has already logged it. // If context is null this was the start of a comet request request.getMappingData().context.logAccess(request, response, System.currentTimeMillis() - req.getStartTime(), false); } } } catch (IOException e) { // Ignore } finally { req.getRequestProcessor().setWorkerThreadName(null); if (!comet && !async) { request.recycle(); response.recycle(); } else { // Clear converters so that the minimum amount of memory request.clearEncoders(); response.clearEncoders(); } } }
@Override protected void initInternal() throws LifecycleException { super.initInternal(); String krb5Conf = System.getProperty(Constants.KRB5_CONF_PROPERTY); if (krb5Conf == null) { File krb5ConfFile = new File(container.getCatalinaBase(), Constants.DEFAULT_KRB5_CONF); System.setProperty(Constants.KRB5_CONF_PROPERTY, krb5ConfFile.getAbsolutePath()); } String jaasConf = System.getProperty(Constants.JAAS_CONF_PROPERTY); if (jaasConf == null) { File jaasConfFile = new File(container.getCatalinaBase(), Constants.DEFAULT_JAAS_CONF); System.setProperty(Constants.JAAS_CONF_PROPERTY, jaasConfFile.getAbsolutePath()); } System.setProperty(Constants.USE_SUBJECT_CREDS_ONLY_PROPERTY, "false"); }
@Override public void bind() throws Exception { try { rootPool = Pool.create(0); } catch (UnsatisfiedLinkError e) { throw new Exception(sm.getString("endpoint.init.notavail")); } serverSockPool = Pool.create(rootPool); String addressStr = null; if (getAddress() != null) { addressStr = getAddress().getHostAddress(); } int family = Socket.APR_INET; if (Library.APR_HAVE_IPV6) { if (addressStr == null) { if (!OS.IS_BSD && !OS.IS_WIN32 && !OS.IS_WIN64) family = Socket.APR_UNSPEC; } else if (addressStr.indexOf(':') >= 0) { family = Socket.APR_UNSPEC; } } long inetAddress = Address.info(addressStr, family, getPort(), 0, rootPool); serverSock = Socket.create(Address.getInfo(inetAddress).family, Socket.SOCK_STREAM, Socket.APR_PROTO_TCP, rootPool); if (OS.IS_UNIX) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } Socket.optSet(serverSock, Socket.APR_SO_KEEPALIVE, 1); int ret = Socket.bind(serverSock, inetAddress); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.bind", "" + ret, Error.strerror(ret))); } ret = Socket.listen(serverSock, getBacklog()); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.listen", "" + ret, Error.strerror(ret))); } if (OS.IS_WIN32 || OS.IS_WIN64) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } if (!useSendFileSet) { useSendfile = Library.APR_HAS_SENDFILE; } else if (useSendfile && !Library.APR_HAS_SENDFILE) { useSendfile = false; } if (acceptorThreadCount == 0) { acceptorThreadCount = 1; } if (deferAccept) { if (Socket.optSet(serverSock, Socket.APR_TCP_DEFER_ACCEPT, 1) == Status.APR_ENOTIMPL) { deferAccept = false; } } if (isSSLEnabled()) { if (SSLCertificateFile == null) { throw new Exception(sm.getString("endpoint.apr.noSslCertFile")); } int value = SSL.SSL_PROTOCOL_NONE; if (SSLProtocol == null || SSLProtocol.length() == 0) { value = SSL.SSL_PROTOCOL_ALL; } else { for (String protocol : SSLProtocol.split("\\+")) { protocol = protocol.trim(); if ("SSLv2".equalsIgnoreCase(protocol)) { value |= SSL.SSL_PROTOCOL_SSLV2; } else if ("SSLv3".equalsIgnoreCase(protocol)) { value |= SSL.SSL_PROTOCOL_SSLV3; } else if ("TLSv1".equalsIgnoreCase(protocol)) { value |= SSL.SSL_PROTOCOL_TLSV1; } else if ("all".equalsIgnoreCase(protocol)) { value |= SSL.SSL_PROTOCOL_ALL; } else { throw new Exception(sm.getString("endpoint.apr.invalidSslProtocol", SSLProtocol)); } } } sslContext = SSLContext.make(rootPool, value, SSL.SSL_MODE_SERVER); if (SSLInsecureRenegotiation) { boolean legacyRenegSupported = false; try { legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); if (legacyRenegSupported) SSLContext.setOptions(sslContext, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); } catch (UnsatisfiedLinkError e) { // Ignore } if (!legacyRenegSupported) { log.warn(sm.getString("endpoint.warn.noInsecureReneg", SSL.versionString())); } } if (SSLHonorCipherOrder) { boolean orderCiphersSupported = false; try { orderCiphersSupported = SSL.hasOp(SSL.SSL_OP_CIPHER_SERVER_PREFERENCE); if (orderCiphersSupported) SSLContext.setOptions(sslContext, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE); } catch (UnsatisfiedLinkError e) { // Ignore } if (!orderCiphersSupported) { log.warn(sm.getString("endpoint.warn.noHonorCipherOrder", SSL.versionString())); } } if (SSLDisableCompression) { boolean disableCompressionSupported = false; try { disableCompressionSupported = SSL.hasOp(SSL.SSL_OP_NO_COMPRESSION); if (disableCompressionSupported) SSLContext.setOptions(sslContext, SSL.SSL_OP_NO_COMPRESSION); } catch (UnsatisfiedLinkError e) { // Ignore } if (!disableCompressionSupported) { log.warn(sm.getString("endpoint.warn.noDisableCompression", SSL.versionString())); } } SSLContext.setCipherSuite(sslContext, SSLCipherSuite); SSLContext.setCertificate(sslContext, SSLCertificateFile, SSLCertificateKeyFile, SSLPassword, SSL.SSL_AIDX_RSA); SSLContext.setCertificateChainFile(sslContext, SSLCertificateChainFile, false); SSLContext.setCACertificate(sslContext, SSLCACertificateFile, SSLCACertificatePath); SSLContext.setCARevocation(sslContext, SSLCARevocationFile, SSLCARevocationPath); value = SSL.SSL_CVERIFY_NONE; if ("optional".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL; } else if ("require".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_REQUIRE; } else if ("optionalNoCA".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA; } SSLContext.setVerify(sslContext, value, SSLVerifyDepth); if (useSendfile) { useSendfile = false; if (useSendFileSet) { log.warn(sm.getString("endpoint.apr.noSendfileWithSSL")); } } } }
private static void validateXmlView(PageData xmlView, Compiler compiler) throws JasperException { StringBuilder errMsg = null; ErrorDispatcher errDisp = compiler.getErrorDispatcher(); for (Iterator<TagLibraryInfo> iter = compiler.getPageInfo().getTaglibs().iterator(); iter.hasNext(); ) { Object o = iter.next(); if (!(o instanceof TagLibraryInfoImpl)) continue; TagLibraryInfoImpl tli = (TagLibraryInfoImpl) o; ValidationMessage[] errors = tli.validate(xmlView); if ((errors != null) && (errors.length != 0)) { if (errMsg == null) { errMsg = new StringBuilder(); } errMsg.append("<h3>"); errMsg.append(Localizer.getMessage("jsp.error.tlv.invalid.page", tli.getShortName(), compiler.getPageInfo().getJspFile())); errMsg.append("</h3>"); for (int i = 0; i < errors.length; i++) { if (errors[i] != null) { errMsg.append("<p>"); errMsg.append(errors[i].getId()); errMsg.append(": "); errMsg.append(errors[i].getMessage()); errMsg.append("</p>"); } } } } if (errMsg != null) { errDisp.jspError(errMsg.toString()); } }	private Node.JspAttribute getJspAttribute(TagAttributeInfo tai, String qName, String uri, String localName, String value, Node n, boolean dynamic) throws JasperException { Node.JspAttribute result = null; if (value != null) { if (n.getRoot().isXmlSyntax() && value.startsWith("%=")) { result = new Node.JspAttribute(tai, qName, uri, localName, value.substring(2, value.length() - 1), true, null, dynamic); } else if (!n.getRoot().isXmlSyntax() && value.startsWith("<%=")) { result = new Node.JspAttribute(tai, qName, uri, localName, value.substring(3, value.length() - 2), true, null, dynamic); } else if (pageInfo.isELIgnored()) { result = new Node.JspAttribute(tai, qName, uri, localName, value, false, null, dynamic); } else { // The attribute can contain expressions but is not a // scriptlet expression; thus, we want to run it through // the expression interpreter // validate expression syntax if string contains ELNode.Nodes el = ELParser.parse(value, pageInfo.isDeferredSyntaxAllowedAsLiteral()); if (el.containsEL()) { validateFunctions(el, n); result = new Node.JspAttribute(tai, qName, uri, localName, value, false, el, dynamic); ELContextImpl ctx = new ELContextImpl(expressionFactory); ctx.setFunctionMapper(getFunctionMapper(el)); try { result.validateEL(this.pageInfo.getExpressionFactory(), ctx); } catch (ELException e) { this.err.jspError(n.getStart(), "jsp.error.invalid.expression", value, e.toString()); } } else { result = new Node.JspAttribute(tai, qName, uri, localName, value, false, null, dynamic); } } } else { // Value is null. Check for any NamedAttribute subnodes // that might contain the value for this attribute. Node.NamedAttribute namedAttributeNode = n.getNamedAttributeNode(qName); if (namedAttributeNode != null) { result = new Node.JspAttribute(namedAttributeNode, tai, dynamic); } } return result; }	public Void run() throws Exception { doHandlePageException(t); return null; }	public static Object proprietaryEvaluate(final String expression, final Class<?> expectedType, final PageContext pageContext, final ProtectedFunctionMapper functionMap, final boolean escape) throws ELException { Object retValue; final ExpressionFactory exprFactory = jspf.getJspApplicationContext(pageContext.getServletContext()).getExpressionFactory(); if (SecurityUtil.isPackageProtectionEnabled()) { try { retValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() { @Override public Object run() throws Exception { ELContextImpl ctx = (ELContextImpl) pageContext.getELContext(); ctx.setFunctionMapper(functionMap); ValueExpression ve = exprFactory.createValueExpression(ctx, expression, expectedType); return ve.getValue(ctx); } }); } catch (PrivilegedActionException ex) { Exception realEx = ex.getException(); if (realEx instanceof ELException) { throw (ELException) realEx; } else { throw new ELException(realEx); } } } else { ELContextImpl ctx = (ELContextImpl) pageContext.getELContext(); ctx.setFunctionMapper(functionMap); ValueExpression ve = exprFactory.createValueExpression(ctx, expression, expectedType); retValue = ve.getValue(ctx); } if (escape && retValue != null) { retValue = XmlEscape(retValue.toString()); } return retValue; }	@Test public void testBug55198() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp"); tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/test/bug5nnnn/bug55198.jsp"); String result = res.toString(); Assert.assertTrue(result.contains("&quot;bar&quot;") || result.contains("&#034;bar&#034;")); Assert.assertTrue(result.contains("&quot;foo&quot;") || result.contains("&#034;foo&#034;")); }
private static void validateEncoders(Class<? extends Encoder>[] encoders) throws DeploymentException { for (Class<? extends Encoder> encoder : encoders) { // Need to instantiate decoder to ensure it is valid and that @SuppressWarnings("unused") Encoder instance; try { encoder.newInstance(); } catch (InstantiationException | IllegalAccessException e) { throw new DeploymentException(sm.getString("serverContainer.encoderFail", encoder.getName()), e); } } }	private void clearHandler(Throwable t) { // Setting the result marks this (partial) message as // complete which means the next one may be sent which // could update the value of the handler. Therefore, keep a // local copy before signalling the end of the (partial) SendHandler sh = handler; handler = null; if (sh != null) { if (t == null) { sh.onResult(new SendResult()); } else { sh.onResult(new SendResult(t)); } } }	protected long getTimeoutExpiry() { return timeoutExpiry; }	@Override protected void doClose() { if (handler != null) { clearHandler(new EOFException()); } try { sos.close(); } catch (IOException e) { if (log.isInfoEnabled()) { log.info(sm.getString("wsRemoteEndpointServer.closeFailed"), e); } } wsWriteTimeout.unregister(this); }	@Override protected void doWrite(SendHandler handler, ByteBuffer... buffers) { this.handler = handler; this.buffers = buffers; onWritePossible(); }	protected void onTimeout() { if (handler != null) { clearHandler(new SocketTimeoutException()); } close(); }	@Override public int compare(TemplatePathMatch tpm1, TemplatePathMatch tpm2) { return tpm1.getUriTemplate().getNormalizedPath().compareTo(tpm2.getUriTemplate().getNormalizedPath()); }	public void backgroundProcess() { backgroundProcessCount++; if (backgroundProcessCount >= processPeriod) { backgroundProcessCount = 0; long now = System.currentTimeMillis(); Iterator<WsRemoteEndpointImplServer> iter = endpoints.iterator(); while (iter.hasNext()) { WsRemoteEndpointImplServer endpoint = iter.next(); if (endpoint.getTimeoutExpiry() < now) { endpoint.onTimeout(); } else { break; } } } }	public void closeAuthenticatedSession(String httpSessionId) { Set<WsSession> wsSessions = authenticatedSessions.remove(httpSessionId); if (wsSessions != null && !wsSessions.isEmpty()) { for (WsSession wsSession : wsSessions) { try { wsSession.close(AUTHENTICATED_HTTP_SESSION_CLOSED); } catch (IOException e) { // Any IOExceptions during close will have been caught and the // onError method called. } } } }	@Override public void contextDestroyed(ServletContextEvent sce) { ServletContext sc = sce.getServletContext(); Object obj = sc.getAttribute(Constants.SERVER_CONTAINER_SERVLET_CONTEXT_ATTRIBUTE); if (obj instanceof WsServerContainer) { ((WsServerContainer) obj).destroy(); } }	@Override public void onWritePossible() { wsRemoteEndpointServer.onWritePossible(); }	public void onWritePossible() { boolean complete = true; try { while (sos.isReady()) { complete = true; for (ByteBuffer buffer : buffers) { if (buffer.hasRemaining()) { complete = false; sos.write(buffer.array(), buffer.arrayOffset(), buffer.limit()); buffer.position(buffer.limit()); break; } } if (complete) { wsWriteTimeout.unregister(this); clearHandler(null); if (close) { close(); } break; } } } catch (IOException ioe) { wsWriteTimeout.unregister(this); clearHandler(ioe); close(); } if (!complete) { long timeout = getSendTimeout(); if (timeout > 0) { timeoutExpiry = timeout + System.currentTimeMillis(); wsWriteTimeout.register(this); } } }
private InputStream getResourceAsStream(String uri) throws FileNotFoundException { if (uri.startsWith("file:")) { return new FileInputStream(new File(uri.substring(5))); } else { try { String real = ctxt.getRealPath(uri); if (real == null) { return ctxt.getResourceAsStream(uri); } else { return new FileInputStream(real); } } catch (FileNotFoundException ex) { return ctxt.getResourceAsStream(uri); } } }	@Override public String toString() { StringWriter sw = new StringWriter(); PrintWriter out = new PrintWriter(sw); print("tlibversion", tlibversion, out); print("jspversion", jspversion, out); print("shortname", shortname, out); print("urn", urn, out); print("info", info, out); print("uri", uri, out); print("tagLibraryValidator", "" + tagLibraryValidator, out); for (int i = 0; i < tags.length; i++) out.println(tags[i].toString()); for (int i = 0; i < tagFiles.length; i++) out.println(tagFiles[i].toString()); for (int i = 0; i < functions.length; i++) out.println(functions[i].toString()); return sw.toString(); }
Thread[] getThreads() { ThreadGroup tg = Thread.currentThread().getThreadGroup(); while (tg.getParent() != null) { tg = tg.getParent(); } int threadCountGuess = tg.activeCount() + 50; Thread[] threads = new Thread[threadCountGuess]; int threadCountActual = tg.enumerate(threads); while (threadCountActual == threadCountGuess) { threadCountGuess *= 2; threads = new Thread[threadCountGuess]; // Note tg.enumerate(Thread[]) silently ignores any threads that threadCountActual = tg.enumerate(threads); } return threads; }
private static Wrapper resolveAmbiguousWrapper(Set<Wrapper> candidates, Class<?>[] paramTypes) { Wrapper w = candidates.iterator().next(); int nonMatchIndex = 0; Class<?> nonMatchClass = null; for (int i = 0; i < paramTypes.length; i++) { if (w.getParameterTypes()[i] != paramTypes[i]) { nonMatchIndex = i; nonMatchClass = paramTypes[i]; break; } } if (nonMatchClass == null) { return null; } for (Wrapper c : candidates) { if (c.getParameterTypes()[nonMatchIndex] == paramTypes[nonMatchIndex]) { return null; } } Class<?> superClass = nonMatchClass.getSuperclass(); while (superClass != null) { for (Wrapper c : candidates) { if (c.getParameterTypes()[nonMatchIndex].equals(superClass)) { return c; } } superClass = superClass.getSuperclass(); } Wrapper match = null; if (Number.class.isAssignableFrom(nonMatchClass)) { for (Wrapper c : candidates) { Class<?> candidateType = c.getParameterTypes()[nonMatchIndex]; if (Number.class.isAssignableFrom(candidateType) || candidateType.isPrimitive()) { if (match == null) { match = c; } else { match = null; break; } } } } return match; }	@Override public void setValue(ELContext context, Object base, Object property, Object value) { if (context == null) { throw new NullPointerException(); } if (base != null && base.getClass().isArray()) { context.setPropertyResolved(base, property); if (this.readOnly) { throw new PropertyNotWritableException(Util.message(context, "resolverNotWriteable", base.getClass().getName())); } int idx = coerce(property); checkBounds(base, idx); if (value != null && !base.getClass().getComponentType().isAssignableFrom(value.getClass())) { throw new ClassCastException(Util.message(context, "objectNotAssignable", value.getClass().getName(), base.getClass().getComponentType().getName())); } Array.set(base, idx, value); } }	@Test(expected = ClassCastException.class) public void testSetValue07() { ArrayELResolver resolver = new ArrayELResolver(); ELContext context = new StandardELContext(ELManager.getExpressionFactory()); String[] base = new String[] { "element" }; resolver.setValue(context, base, new Integer(0), new Integer(1)); }
public static Set<MessageHandlerResult> getMessageHandlers(MessageHandler listener, EndpointConfig endpointConfig) { Class<?> target = Util.getMessageType(listener); Set<MessageHandlerResult> results = new HashSet<>(2); if (String.class.isAssignableFrom(target)) { MessageHandlerResult result = new MessageHandlerResult(listener, MessageHandlerResultType.TEXT); results.add(result); } else if (ByteBuffer.class.isAssignableFrom(target)) { MessageHandlerResult result = new MessageHandlerResult(listener, MessageHandlerResultType.BINARY); results.add(result); } else if (PongMessage.class.isAssignableFrom(target)) { MessageHandlerResult result = new MessageHandlerResult(listener, MessageHandlerResultType.PONG); results.add(result); // Relatively simple cases - handler needs wrapping but no decoder to // convert it to one of the types expected by the frame handling code } else if (byte[].class.isAssignableFrom(target)) { MessageHandlerResult result = new MessageHandlerResult(new PojoMessageHandlerWholeBinary(listener, getOnMessageMethod(listener), null, endpointConfig, null, new Object[1], 0, true, -1, false, -1), MessageHandlerResultType.BINARY); results.add(result); } else if (InputStream.class.isAssignableFrom(target)) { MessageHandlerResult result = new MessageHandlerResult(new PojoMessageHandlerWholeBinary(listener, getOnMessageMethod(listener), null, endpointConfig, null, new Object[1], 0, true, -1, true, -1), MessageHandlerResultType.BINARY); results.add(result); } else if (Reader.class.isAssignableFrom(target)) { MessageHandlerResult result = new MessageHandlerResult(new PojoMessageHandlerWholeText(listener, getOnMessageMethod(listener), null, endpointConfig, null, new Object[1], 0, true, -1, -1), MessageHandlerResultType.TEXT); results.add(result); } else { DecoderMatch decoderMatch; try { List<Class<? extends Decoder>> decoders = endpointConfig.getDecoders(); @SuppressWarnings("unchecked") List<DecoderEntry> decoderEntries = getDecoders(decoders.toArray(new Class[decoders.size()])); decoderMatch = new DecoderMatch(target, decoderEntries); } catch (DeploymentException e) { throw new IllegalArgumentException(e); } Method m = getOnMessageMethod(listener); if (decoderMatch.getBinaryDecoders().size() > 0) { MessageHandlerResult result = new MessageHandlerResult(new PojoMessageHandlerWholeBinary(listener, m, null, endpointConfig, decoderMatch.getBinaryDecoders(), new Object[1], 0, false, -1, false, -1), MessageHandlerResultType.BINARY); results.add(result); } if (decoderMatch.getTextDecoders().size() > 0) { MessageHandlerResult result = new MessageHandlerResult(new PojoMessageHandlerWholeText(listener, m, null, endpointConfig, decoderMatch.getTextDecoders(), new Object[1], 0, false, -1, -1), MessageHandlerResultType.TEXT); results.add(result); } } if (results.size() == 0) { throw new IllegalArgumentException(sm.getString("wsSession.unknownHandler", listener, target)); } return results; }	@Override public Set<MessageHandler> getMessageHandlers() { checkState(); Set<MessageHandler> result = new HashSet<>(); if (binaryMessageHandler != null) { result.add(binaryMessageHandler); } if (textMessageHandler != null) { result.add(textMessageHandler); } if (pongMessageHandler != null) { result.add(pongMessageHandler); } return result; }
private int testEvent(String name, int count) throws InterruptedException { int i = count; while (i < 50) { if (Server.isLifeCycleEventCalled(name)) { break; } i++; Thread.sleep(100); } Assert.assertTrue(Server.isLifeCycleEventCalled(name)); return i; }	private static Object getTypeParameter(Class<?> clazz, Type argType) { if (argType instanceof Class<?>) { return argType; } else { TypeVariable<?>[] tvs = clazz.getTypeParameters(); for (int i = 0; i < tvs.length; i++) { if (tvs[i].equals(argType)) { return Integer.valueOf(i); } } return null; } }	@Override public boolean willDecode(ByteBuffer bb) { bb.mark(); if (bb.get() == 0x12 && bb.get() == 0x34) { return true; } bb.reset(); return false; }	@Override public void doSomething(Boolean thing) { // NO-OP }	@Test public void testAnnotatedEndPoints() throws Exception { Server server = new Server(); SingletonConfigurator.setInstance(server); ServerConfigListener.setPojoClazz(Server.class); Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(new ApplicationListener(ServerConfigListener.class.getName(), false)); Tomcat.addServlet(ctx, "default", new DefaultServlet()); ctx.addServletMapping("/", "default"); WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); tomcat.start(); Client client = new Client(); URI uri = new URI("ws://localhost:" + getPort() + PATH_ANNOTATED_EP); Session session = wsContainer.connectToServer(client, uri); MsgString msg1 = new MsgString(); msg1.setData(MESSAGE_ONE); session.getBasicRemote().sendObject(msg1); int i = 0; while (i < 20) { if (server.received.size() > 0 && client.received.size() > 0) { break; } Thread.sleep(100); } Assert.assertEquals(1, server.received.size()); Assert.assertEquals(1, client.received.size()); Assert.assertEquals(MESSAGE_ONE, ((MsgString) server.received.peek()).getData()); Assert.assertEquals(MESSAGE_ONE, ((MsgString) client.received.peek()).getData()); session.close(); i = testEvent(MsgStringEncoder.class.getName() + ":init", 0); i = testEvent(MsgStringDecoder.class.getName() + ":init", i); i = testEvent(MsgByteEncoder.class.getName() + ":init", i); i = testEvent(MsgByteDecoder.class.getName() + ":init", i); i = testEvent(MsgStringEncoder.class.getName() + ":destroy", i); i = testEvent(MsgStringDecoder.class.getName() + ":destroy", i); i = testEvent(MsgByteEncoder.class.getName() + ":destroy", i); i = testEvent(MsgByteDecoder.class.getName() + ":destroy", i); }	@Test public void testGetEncoderTypeGenericMultipleSubclassSwap() { Assert.assertEquals(String.class, Util.getEncoderType(GenericMultipleSubSubSwapEncoder.class)); }	private static <T> Object getGenericType(Class<T> type, Class<? extends T> clazz) { // Look to see if this class implements the generic MessageHandler<> // interface Type[] interfaces = clazz.getGenericInterfaces(); for (Type iface : interfaces) { if (iface instanceof ParameterizedType) { ParameterizedType pi = (ParameterizedType) iface; if (pi.getRawType() instanceof Class) { if (type.isAssignableFrom((Class<?>) pi.getRawType())) { return getTypeParameter(clazz, pi.getActualTypeArguments()[0]); } } } } @SuppressWarnings("unchecked") Class<? extends T> superClazz = (Class<? extends T>) clazz.getSuperclass(); Object result = getGenericType(type, superClazz); if (result instanceof Class<?>) { return result; } else if (result instanceof Integer) { // Superclass implements interface and defines unknown type for // MessageHandler<> ParameterizedType superClassType = (ParameterizedType) clazz.getGenericSuperclass(); return getTypeParameter(clazz, superClassType.getActualTypeArguments()[((Integer) result).intValue()]); } else { return null; } }
protected Digester createStartDigester() { long t1 = System.currentTimeMillis(); Digester digester = new Digester(); digester.setValidating(false); digester.setRulesValidation(true); HashMap<Class<?>, List<String>> fakeAttributes = new HashMap<>(); ArrayList<String> attrs = new ArrayList<>(); attrs.add("className"); fakeAttributes.put(Object.class, attrs); digester.setFakeAttributes(fakeAttributes); digester.setClassLoader(StandardServer.class.getClassLoader()); digester.addObjectCreate("Server", "org.apache.catalina.core.StandardServer", "className"); digester.addSetProperties("Server"); digester.addSetNext("Server", "setServer", "org.apache.catalina.Server"); digester.addObjectCreate("Server/GlobalNamingResources", "org.apache.catalina.deploy.NamingResourcesImpl"); digester.addSetProperties("Server/GlobalNamingResources"); digester.addSetNext("Server/GlobalNamingResources", "setGlobalNamingResources", "org.apache.catalina.deploy.NamingResourcesImpl"); digester.addObjectCreate("Server/Listener", null, "className"); digester.addSetProperties("Server/Listener"); digester.addSetNext("Server/Listener", "addLifecycleListener", "org.apache.catalina.LifecycleListener"); digester.addObjectCreate("Server/Service", "org.apache.catalina.core.StandardService", "className"); digester.addSetProperties("Server/Service"); digester.addSetNext("Server/Service", "addService", "org.apache.catalina.Service"); digester.addObjectCreate("Server/Service/Listener", null, "className"); digester.addSetProperties("Server/Service/Listener"); digester.addSetNext("Server/Service/Listener", "addLifecycleListener", "org.apache.catalina.LifecycleListener"); digester.addObjectCreate("Server/Service/Executor", "org.apache.catalina.core.StandardThreadExecutor", "className"); digester.addSetProperties("Server/Service/Executor"); digester.addSetNext("Server/Service/Executor", "addExecutor", "org.apache.catalina.Executor"); digester.addRule("Server/Service/Connector", new ConnectorCreateRule()); digester.addRule("Server/Service/Connector", new SetAllPropertiesRule(new String[] { "executor" })); digester.addSetNext("Server/Service/Connector", "addConnector", "org.apache.catalina.connector.Connector"); digester.addObjectCreate("Server/Service/Connector/Listener", null, "className"); digester.addSetProperties("Server/Service/Connector/Listener"); digester.addSetNext("Server/Service/Connector/Listener", "addLifecycleListener", "org.apache.catalina.LifecycleListener"); digester.addRuleSet(new NamingRuleSet("Server/GlobalNamingResources/")); digester.addRuleSet(new EngineRuleSet("Server/Service/")); digester.addRuleSet(new HostRuleSet("Server/Service/Engine/")); digester.addRuleSet(new ContextRuleSet("Server/Service/Engine/Host/")); addClusterRuleSet(digester, "Server/Service/Engine/Host/Cluster/"); digester.addRuleSet(new NamingRuleSet("Server/Service/Engine/Host/Context/")); digester.addRule("Server/Service/Engine", new SetParentClassLoaderRule(parentClassLoader)); addClusterRuleSet(digester, "Server/Service/Engine/Cluster/"); long t2 = System.currentTimeMillis(); if (log.isDebugEnabled()) { log.debug("Digester for server.xml created " + (t2 - t1)); } return (digester); }	protected Digester createStopDigester() { Digester digester = new Digester(); digester.addObjectCreate("Server", "org.apache.catalina.core.StandardServer", "className"); digester.addSetProperties("Server"); digester.addSetNext("Server", "setServer", "org.apache.catalina.Server"); return (digester); }	public void stopServer(String[] arguments) { if (arguments != null) { arguments(arguments); } Server s = getServer(); if (s == null) { Digester digester = createStopDigester(); digester.setClassLoader(Thread.currentThread().getContextClassLoader()); File file = configFile(); FileInputStream fis = null; try { InputSource is = new InputSource(file.toURI().toURL().toString()); fis = new FileInputStream(file); is.setByteStream(fis); digester.push(this); digester.parse(is); } catch (Exception e) { log.error("Catalina.stop: ", e); System.exit(1); } finally { if (fis != null) { try { fis.close(); } catch (IOException e) { // Ignore } } } } else { try { s.stop(); } catch (LifecycleException e) { log.error("Catalina.stop: ", e); } return; } s = getServer(); if (s.getPort() > 0) { Socket socket = null; OutputStream stream = null; try { socket = new Socket(s.getAddress(), s.getPort()); stream = socket.getOutputStream(); String shutdown = s.getShutdown(); for (int i = 0; i < shutdown.length(); i++) { stream.write(shutdown.charAt(i)); } stream.flush(); } catch (ConnectException ce) { log.error(sm.getString("catalina.stopServer.connectException", s.getAddress(), String.valueOf(s.getPort()))); log.error("Catalina.stop: ", ce); System.exit(1); } catch (IOException e) { log.error("Catalina.stop: ", e); System.exit(1); } finally { if (stream != null) { try { stream.close(); } catch (IOException e) { // Ignore } } if (socket != null) { try { socket.close(); } catch (IOException e) { // Ignore } } } } else { log.error(sm.getString("catalina.stopServer")); System.exit(1); } }
protected boolean checkIfNoneMatch(HttpServletRequest request, HttpServletResponse response, WebResource resource) throws IOException { String eTag = resource.getETag(); String headerValue = request.getHeader("If-None-Match"); if (headerValue != null) { boolean conditionSatisfied = false; if (!headerValue.equals("*")) { StringTokenizer commaTokenizer = new StringTokenizer(headerValue, ","); while (!conditionSatisfied && commaTokenizer.hasMoreTokens()) { String currentToken = commaTokenizer.nextToken(); if (currentToken.trim().equals(eTag)) conditionSatisfied = true; } } else { conditionSatisfied = true; } if (conditionSatisfied) { if (("GET".equals(request.getMethod())) || ("HEAD".equals(request.getMethod()))) { response.setStatus(HttpServletResponse.SC_NOT_MODIFIED); response.setHeader("ETag", eTag); return false; } response.sendError(HttpServletResponse.SC_PRECONDITION_FAILED); return false; } } return true; }	protected void serveResource(HttpServletRequest request, HttpServletResponse response, boolean content, String encoding) throws IOException, ServletException { boolean serveContent = content; String path = getRelativePath(request); if (debug > 0) { if (serveContent) log("DefaultServlet.serveResource: Serving resource '" + path + "' headers and data"); else log("DefaultServlet.serveResource: Serving resource '" + path + "' headers only"); } WebResource resource = resources.getResource(path); if (!resource.exists()) { // Check if we're included so we can return the appropriate String requestUri = (String) request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI); if (requestUri == null) { requestUri = request.getRequestURI(); } else { throw new FileNotFoundException(sm.getString("defaultServlet.missingResource", requestUri)); } response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri); return; } if (resource.isFile()) { if (path.endsWith("/") || (path.endsWith("\\"))) { // Check if we're included so we can return the appropriate String requestUri = (String) request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI); if (requestUri == null) { requestUri = request.getRequestURI(); } response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri); return; } } boolean isError = response.getStatus() >= HttpServletResponse.SC_BAD_REQUEST; if (resource.isFile()) { boolean included = (request.getAttribute(RequestDispatcher.INCLUDE_CONTEXT_PATH) != null); if (!included && !isError && !checkIfHeaders(request, response, resource)) { return; } } String contentType = resource.getMimeType(); if (contentType == null) { contentType = getServletContext().getMimeType(resource.getName()); resource.setMimeType(contentType); } ArrayList<Range> ranges = null; long contentLength = -1L; if (resource.isDirectory()) { if (!listings) { response.sendError(HttpServletResponse.SC_NOT_FOUND, request.getRequestURI()); return; } contentType = "text/html;charset=UTF-8"; } else { if (!isError) { if (useAcceptRanges) { response.setHeader("Accept-Ranges", "bytes"); } ranges = parseRange(request, response, resource); response.setHeader("ETag", resource.getETag()); response.setHeader("Last-Modified", resource.getLastModifiedHttp()); } contentLength = resource.getContentLength(); if (contentLength == 0L) { serveContent = false; } } ServletOutputStream ostream = null; PrintWriter writer = null; if (serveContent) { try { ostream = response.getOutputStream(); } catch (IllegalStateException e) { if ((contentType == null) || (contentType.startsWith("text")) || (contentType.endsWith("xml")) || (contentType.contains("/javascript"))) { writer = response.getWriter(); ranges = FULL; } else { throw e; } } } // Check to see if a Filter, Valve of wrapper has written some content. // If it has, disable range requests and setting of a content length ServletResponse r = response; long contentWritten = 0; while (r instanceof ServletResponseWrapper) { r = ((ServletResponseWrapper) r).getResponse(); } if (r instanceof ResponseFacade) { contentWritten = ((ResponseFacade) r).getContentWritten(); } if (contentWritten > 0) { ranges = FULL; } if (resource.isDirectory() || isError || ((ranges == null || ranges.isEmpty()) && request.getHeader("Range") == null) || ranges == FULL) { if (contentType != null) { if (debug > 0) log("DefaultServlet.serveFile: contentType='" + contentType + "'"); response.setContentType(contentType); } if (resource.isFile() && contentLength >= 0 && (!serveContent || ostream != null)) { if (debug > 0) log("DefaultServlet.serveFile: contentLength=" + contentLength); if (contentWritten == 0) { response.setContentLengthLong(contentLength); } } InputStream renderResult = null; if (resource.isDirectory()) { if (serveContent) { renderResult = render(getPathPrefix(request), resource); } } if (serveContent) { try { response.setBufferSize(output); } catch (IllegalStateException e) { // Silent catch } if (ostream != null) { if (!checkSendfile(request, response, resource, contentLength, null)) copy(resource, renderResult, ostream); } else { copy(resource, renderResult, writer, encoding); } } } else { if ((ranges == null) || (ranges.isEmpty())) return; response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT); if (ranges.size() == 1) { Range range = ranges.get(0); response.addHeader("Content-Range", "bytes " + range.start + "-" + range.end + "/" + range.length); long length = range.end - range.start + 1; response.setContentLengthLong(length); if (contentType != null) { if (debug > 0) log("DefaultServlet.serveFile: contentType='" + contentType + "'"); response.setContentType(contentType); } if (serveContent) { try { response.setBufferSize(output); } catch (IllegalStateException e) { // Silent catch } if (ostream != null) { if (!checkSendfile(request, response, resource, range.end - range.start + 1, range)) copy(resource, ostream, range); } else { throw new IllegalStateException(); } } } else { response.setContentType("multipart/byteranges; boundary=" + mimeSeparation); if (serveContent) { try { response.setBufferSize(output); } catch (IllegalStateException e) { // Silent catch } if (ostream != null) { copy(resource, ostream, ranges.iterator(), contentType); } else { throw new IllegalStateException(); } } } } }	@Override public boolean isResponseBodyOK() { return true; }	@Override public void init() throws ServletException { if (getServletConfig().getInitParameter("debug") != null) debug = Integer.parseInt(getServletConfig().getInitParameter("debug")); if (getServletConfig().getInitParameter("input") != null) input = Integer.parseInt(getServletConfig().getInitParameter("input")); if (getServletConfig().getInitParameter("output") != null) output = Integer.parseInt(getServletConfig().getInitParameter("output")); listings = Boolean.parseBoolean(getServletConfig().getInitParameter("listings")); if (getServletConfig().getInitParameter("readonly") != null) readOnly = Boolean.parseBoolean(getServletConfig().getInitParameter("readonly")); if (getServletConfig().getInitParameter("sendfileSize") != null) sendfileSize = Integer.parseInt(getServletConfig().getInitParameter("sendfileSize")) * 1024; fileEncoding = getServletConfig().getInitParameter("fileEncoding"); globalXsltFile = getServletConfig().getInitParameter("globalXsltFile"); contextXsltFile = getServletConfig().getInitParameter("contextXsltFile"); localXsltFile = getServletConfig().getInitParameter("localXsltFile"); readmeFile = getServletConfig().getInitParameter("readmeFile"); if (getServletConfig().getInitParameter("useAcceptRanges") != null) useAcceptRanges = Boolean.parseBoolean(getServletConfig().getInitParameter("useAcceptRanges")); if (input < 256) input = 256; if (output < 256) output = 256; if (debug > 0) { log("DefaultServlet.init: input buffer size=" + input + ", output buffer size=" + output); } resources = (WebResourceRoot) getServletContext().getAttribute(Globals.RESOURCES_ATTR); if (resources == null) { throw new UnavailableException("No resources"); } }	public void testGetSpecials() throws Exception { Tomcat tomcat = getTomcatInstance(); String contextPath = "/examples"; File appDir = new File(getBuildDirectory(), "webapps" + contextPath); tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); tomcat.start(); final ByteChunk res = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + contextPath + "/WEB-INF/web.xml", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); rc = getUrl("http://localhost:" + getPort() + contextPath + "/WEB-INF/doesntexistanywhere", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); rc = getUrl("http://localhost:" + getPort() + contextPath + "/WEB-INF/", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); rc = getUrl("http://localhost:" + getPort() + contextPath + "/META-INF/MANIFEST.MF", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); rc = getUrl("http://localhost:" + getPort() + contextPath + "/META-INF/doesntexistanywhere", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); }
protected String nextFile() { if (fullstop) argPos++; if (argPos >= args.length) { return null; } else { return args[argPos++]; } }	protected void initWebXml() { try { if (webxmlLevel >= INC_WEBXML) { mapout = openWebxmlWriter(new File(webxmlFile)); servletout = new CharArrayWriter(); mappingout = new CharArrayWriter(); } else { mapout = null; servletout = null; mappingout = null; } if (webxmlLevel >= ALL_WEBXML) { mapout.write(Localizer.getMessage("jspc.webxml.header")); mapout.flush(); } else if ((webxmlLevel >= INC_WEBXML) && !addWebXmlMappings) { mapout.write(Localizer.getMessage("jspc.webinc.header")); mapout.flush(); } } catch (IOException ioe) { mapout = null; servletout = null; mappingout = null; } }
public boolean isLiteral() { return !expression && (el != null) && !namedAttribute; }
public static void release(ClassLoader classLoader) { Iterator<URLStreamHandlerFactory> iter = instance.userFactories.iterator(); while (iter.hasNext()) { ClassLoader factoryLoader = iter.next().getClass().getClassLoader(); while (factoryLoader != null) { if (classLoader.equals(factoryLoader)) { iter.remove(); break; } factoryLoader = factoryLoader.getParent(); } } }	public static TomcatURLStreamHandlerFactory getInstance() { return instance; }	public static void register() { // Calling this method loads this class which in turn triggers all the // necessary registration. }	public static void release(ClassLoader classLoader) { Iterator<URLStreamHandlerFactory> iter = instance.userFactories.iterator(); while (iter.hasNext()) { ClassLoader factoryLoader = iter.next().getClass().getClassLoader(); while (factoryLoader != null) { if (classLoader.equals(factoryLoader)) { iter.remove(); break; } factoryLoader = factoryLoader.getParent(); } } }
@Override public void destroy() { // No actions necessary }
protected ResourceEntry findResourceInternal(String name, String path) { if (!started) { log.info(sm.getString("webappClassLoader.stopped", name)); return null; } if ((name == null) || (path == null)) return null; ResourceEntry entry = resourceEntries.get(name); if (entry != null) return entry; int contentLength = -1; InputStream binaryStream = null; boolean isClassResource = path.endsWith(".class"); int jarFilesLength = jarFiles.length; WebResource resource = null; boolean fileNeedConvert = false; if (repositoryPath != null) { String fullPath = repositoryPath + path; resource = resources.getResource(fullPath); if (resource.exists()) { contentLength = (int) resource.getContentLength(); entry = new ResourceEntry(); entry.source = resource.getURL(); entry.codeBase = entry.source; entry.lastModified = resource.getLastModified(); binaryStream = resource.getInputStream(); if (needConvert) { if (path.endsWith(".properties")) { fileNeedConvert = true; } } synchronized (allPermission) { int j; long[] result2 = new long[lastModifiedDates.length + 1]; for (j = 0; j < lastModifiedDates.length; j++) { result2[j] = lastModifiedDates[j]; } result2[lastModifiedDates.length] = entry.lastModified; lastModifiedDates = result2; String[] result = new String[paths.length + 1]; for (j = 0; j < paths.length; j++) { result[j] = paths[j]; } result[paths.length] = fullPath; paths = result; } } } if ((entry == null) && (notFoundResources.containsKey(name))) return null; JarEntry jarEntry = null; synchronized (jarFiles) { try { if (!openJARs()) { return null; } for (int i = 0; (entry == null) && (i < jarFilesLength); i++) { jarEntry = jarFiles[i].getJarEntry(path); if (jarEntry != null) { entry = new ResourceEntry(); try { entry.codeBase = getURI(jarRealFiles[i]); String jarFakeUrl = entry.codeBase.toString(); jarFakeUrl = "jar:" + jarFakeUrl + "!/" + path; entry.source = new URL(jarFakeUrl); entry.lastModified = jarRealFiles[i].lastModified(); } catch (MalformedURLException e) { return null; } contentLength = (int) jarEntry.getSize(); try { entry.manifest = jarFiles[i].getManifest(); binaryStream = jarFiles[i].getInputStream(jarEntry); } catch (IOException e) { return null; } if (antiJARLocking && !(path.endsWith(".class"))) { byte[] buf = new byte[1024]; File resourceFile = new File(loaderDir, jarEntry.getName()); if (!resourceFile.exists()) { Enumeration<JarEntry> entries = jarFiles[i].entries(); while (entries.hasMoreElements()) { JarEntry jarEntry2 = entries.nextElement(); if (!(jarEntry2.isDirectory()) && (!jarEntry2.getName().endsWith(".class"))) { resourceFile = new File(loaderDir, jarEntry2.getName()); try { if (!resourceFile.getCanonicalPath().startsWith(canonicalLoaderDir)) { throw new IllegalArgumentException(sm.getString("webappClassLoader.illegalJarPath", jarEntry2.getName())); } } catch (IOException ioe) { throw new IllegalArgumentException(sm.getString("webappClassLoader.validationErrorJarPath", jarEntry2.getName()), ioe); } File parentFile = resourceFile.getParentFile(); if (!parentFile.mkdirs() && !parentFile.exists()) { // Ignore the error (like the IOExceptions below) } FileOutputStream os = null; InputStream is = null; try { is = jarFiles[i].getInputStream(jarEntry2); os = new FileOutputStream(resourceFile); while (true) { int n = is.read(buf); if (n <= 0) { break; } os.write(buf, 0, n); } resourceFile.setLastModified(jarEntry2.getTime()); } catch (IOException e) { // Ignore } finally { try { if (is != null) { is.close(); } } catch (IOException e) { // Ignore } try { if (os != null) { os.close(); } } catch (IOException e) { // Ignore } } } } } } } } if (entry == null) { synchronized (notFoundResources) { notFoundResources.put(name, name); } return null; } if (binaryStream != null && (isClassResource || fileNeedConvert)) { byte[] binaryContent = new byte[contentLength]; int pos = 0; try { while (true) { int n = binaryStream.read(binaryContent, pos, binaryContent.length - pos); if (n <= 0) break; pos += n; } } catch (IOException e) { log.error(sm.getString("webappClassLoader.readError", name), e); return null; } if (fileNeedConvert) { // Workaround for certain files on platforms that use // EBCDIC encoding, when they are read through FileInputStream. // See commit message of rev.303915 for details String str = new String(binaryContent, 0, pos); try { binaryContent = str.getBytes(StandardCharsets.UTF_8); } catch (Exception e) { return null; } } entry.binaryContent = binaryContent; if (jarEntry != null) { entry.certificates = jarEntry.getCertificates(); } } } finally { if (binaryStream != null) { try { binaryStream.close(); } catch (IOException e) { /* Ignore */ } } } } synchronized (resourceEntries) { // Ensures that all the threads which may be in a race to load // a particular class all end up with the same ResourceEntry ResourceEntry entry2 = resourceEntries.get(name); if (entry2 == null) { resourceEntries.put(name, entry); } else { entry = entry2; } } return entry; }	protected Class<?> findClassInternal(String name) throws ClassNotFoundException { if (!validate(name)) throw new ClassNotFoundException(name); String tempPath = name.replace('.', '/'); String classPath = tempPath + ".class"; ResourceEntry entry = null; if (securityManager != null) { PrivilegedAction<ResourceEntry> dp = new PrivilegedFindResourceByName(name, classPath); entry = AccessController.doPrivileged(dp); } else { entry = findResourceInternal(name, classPath); } if (entry == null) throw new ClassNotFoundException(name); Class<?> clazz = entry.loadedClass; if (clazz != null) return clazz; synchronized (this) { clazz = entry.loadedClass; if (clazz != null) return clazz; if (entry.binaryContent == null) throw new ClassNotFoundException(name); String packageName = null; int pos = name.lastIndexOf('.'); if (pos != -1) packageName = name.substring(0, pos); Package pkg = null; if (packageName != null) { pkg = getPackage(packageName); if (pkg == null) { try { if (entry.manifest == null) { definePackage(packageName, null, null, null, null, null, null, null); } else { definePackage(packageName, entry.manifest, entry.codeBase); } } catch (IllegalArgumentException e) { // Ignore: normal error due to dual definition of package } pkg = getPackage(packageName); } } if (securityManager != null) { if (pkg != null) { boolean sealCheck = true; if (pkg.isSealed()) { sealCheck = pkg.isSealed(entry.codeBase); } else { sealCheck = (entry.manifest == null) || !isPackageSealed(packageName, entry.manifest); } if (!sealCheck) throw new SecurityException("Sealing violation loading " + name + " : Package " + packageName + " is sealed."); } } try { clazz = defineClass(name, entry.binaryContent, 0, entry.binaryContent.length, new CodeSource(entry.codeBase, entry.certificates)); } catch (UnsupportedClassVersionError ucve) { throw new UnsupportedClassVersionError(ucve.getLocalizedMessage() + " " + sm.getString("webappClassLoader.wrongVersion", name)); } entry.loadedClass = clazz; entry.binaryContent = null; entry.source = null; entry.codeBase = null; entry.manifest = null; entry.certificates = null; } return clazz; }	protected boolean validateJarFile(File file) throws IOException { if (triggers == null) return (true); JarFile jarFile = null; try { jarFile = new JarFile(file); for (int i = 0; i < triggers.length; i++) { Class<?> clazz = null; try { if (parent != null) { clazz = parent.loadClass(triggers[i]); } else { clazz = Class.forName(triggers[i]); } } catch (Exception e) { clazz = null; } if (clazz == null) continue; String name = triggers[i].replace('.', '/') + ".class"; if (log.isDebugEnabled()) log.debug(" Checking for " + name); JarEntry jarEntry = jarFile.getJarEntry(name); if (jarEntry != null) { log.info("validateJarFile(" + file + ") - jar not loaded. See Servlet Spec 2.3, " + "section 9.7.2. Offending class: " + name); return false; } } return true; } finally { if (jarFile != null) { try { jarFile.close(); } catch (IOException ioe) { // Ignore } } } }	@Override public Class<?> findClass(String name) throws ClassNotFoundException { if (log.isDebugEnabled()) log.debug(" findClass(" + name + ")"); if (!started) { throw new ClassNotFoundException(name); } if (securityManager != null) { int i = name.lastIndexOf('.'); if (i >= 0) { try { if (log.isTraceEnabled()) log.trace(" securityManager.checkPackageDefinition"); securityManager.checkPackageDefinition(name.substring(0, i)); } catch (Exception se) { if (log.isTraceEnabled()) log.trace(" -->Exception-->ClassNotFoundException", se); throw new ClassNotFoundException(name, se); } } } // Ask our superclass to locate this class, if possible Class<?> clazz = null; try { if (log.isTraceEnabled()) log.trace(" findClassInternal(" + name + ")"); try { clazz = findClassInternal(name); } catch (ClassNotFoundException cnfe) { if (log.isDebugEnabled()) log.debug(" --> Returning ClassNotFoundException"); throw cnfe; } catch (AccessControlException ace) { log.warn("WebappClassLoader.findClassInternal(" + name + ") security exception: " + ace.getMessage(), ace); throw new ClassNotFoundException(name, ace); } catch (RuntimeException e) { if (log.isTraceEnabled()) log.trace(" -->RuntimeException Rethrown", e); throw e; } } catch (ClassNotFoundException e) { if (log.isTraceEnabled()) log.trace(" --> Passing on ClassNotFoundException"); throw e; } if (log.isTraceEnabled()) log.debug(" Returning class " + clazz); if (log.isTraceEnabled()) { ClassLoader cl; if (Globals.IS_SECURITY_ENABLED) { cl = AccessController.doPrivileged(new PrivilegedGetClassLoader(clazz)); } else { cl = clazz.getClassLoader(); } log.debug(" Loaded by " + cl.toString()); } return (clazz); }	@Override public URL getResource(String name) { if (log.isDebugEnabled()) log.debug("getResource(" + name + ")"); URL url = null; if (delegate) { if (log.isDebugEnabled()) log.debug(" Delegating to parent classloader " + parent); ClassLoader loader = parent; if (loader == null) loader = system; url = loader.getResource(name); if (url != null) { if (log.isDebugEnabled()) log.debug(" --> Returning '" + url.toString() + "'"); return (url); } } url = findResource(name); if (url != null) { if (antiJARLocking) { ResourceEntry entry = resourceEntries.get(name); try { String repository = entry.codeBase.toString(); if ((repository.endsWith(".jar")) && (!(name.endsWith(".class")))) { File resourceFile = new File(loaderDir, name); url = getURI(resourceFile); } } catch (Exception e) { // Ignore } } if (log.isDebugEnabled()) log.debug(" --> Returning '" + url.toString() + "'"); return (url); } if (!delegate) { ClassLoader loader = parent; if (loader == null) loader = system; url = loader.getResource(name); if (url != null) { if (log.isDebugEnabled()) log.debug(" --> Returning '" + url.toString() + "'"); return (url); } } if (log.isDebugEnabled()) log.debug(" --> Resource not found, returning null"); return (null); }	public void setClearReferencesHttpClientKeepAliveThread(boolean clearReferencesHttpClientKeepAliveThread) { this.clearReferencesHttpClientKeepAliveThread = clearReferencesHttpClientKeepAliveThread; }

Class<?> loadTagFile(Compiler compiler, String tagFilePath, TagInfo tagInfo, PageInfo parentPageInfo) throws JasperException { JarResource tagJarResouce = null; if (tagFilePath.startsWith("/META-INF/")) { tagJarResouce = compiler.getCompilationContext().getTldLocation(tagInfo.getTagLibrary().getURI()).getJarResource(); } String wrapperUri; if (tagJarResouce == null) { wrapperUri = tagFilePath; } else { wrapperUri = tagJarResouce.getEntry(tagFilePath).toString(); } JspCompilationContext ctxt = compiler.getCompilationContext(); JspRuntimeContext rctxt = ctxt.getRuntimeContext(); JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri); synchronized (rctxt) { if (wrapper == null) { wrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), tagJarResouce); rctxt.addWrapper(wrapperUri, wrapper); wrapper.getJspEngineContext().setClassLoader(ctxt.getClassLoader()); wrapper.getJspEngineContext().setClassPath(ctxt.getClassPath()); } else { // Make sure that JspCompilationContext gets the latest TagInfo // for the tag file. TagInfo instance was created the last // time the tag file was scanned for directives, and the tag wrapper.getJspEngineContext().setTagInfo(tagInfo); } Class<?> tagClazz; int tripCount = wrapper.incTripCount(); try { if (tripCount > 0) { // When tripCount is greater than zero, a circular // dependency exists. The circularly dependent tag // file is compiled in prototype mode, to avoid infinite JspServletWrapper tempWrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), ctxt.getTagFileJarResource(tagFilePath)); tempWrapper.getJspEngineContext().setClassLoader(ctxt.getClassLoader()); tempWrapper.getJspEngineContext().setClassPath(ctxt.getClassPath()); tagClazz = tempWrapper.loadTagFilePrototype(); tempVector.add(tempWrapper.getJspEngineContext().getCompiler()); } else { tagClazz = wrapper.loadTagFile(); } } finally { wrapper.decTripCount(); } try { Object tagIns = tagClazz.newInstance(); if (tagIns instanceof JspSourceDependent) { Iterator<Entry<String, Long>> iter = ((JspSourceDependent) tagIns).getDependants().entrySet().iterator(); while (iter.hasNext()) { Entry<String, Long> entry = iter.next(); parentPageInfo.addDependant(entry.getKey(), entry.getValue()); } } } catch (Exception e) { // ignore errors } return tagClazz; } }

protected String rewriteUrl(String path) { return urlEncoder.encode(path); }	protected void copy(WebResource resource, InputStream is, PrintWriter writer) throws IOException { IOException exception = null; InputStream resourceInputStream = null; if (resource.isFile()) { resourceInputStream = resource.getInputStream(); } else { resourceInputStream = is; } Reader reader; if (fileEncoding == null) { reader = new InputStreamReader(resourceInputStream); } else { reader = new InputStreamReader(resourceInputStream, fileEncoding); } exception = copyRange(reader, writer); reader.close(); if (exception != null) throw exception; }	protected void copy(WebResource resource, InputStream is, PrintWriter writer) throws IOException { IOException exception = null; InputStream resourceInputStream = null; if (resource.isFile()) { resourceInputStream = resource.getInputStream(); } else { resourceInputStream = is; } Reader reader; if (fileEncoding == null) { reader = new InputStreamReader(resourceInputStream); } else { reader = new InputStreamReader(resourceInputStream, fileEncoding); } exception = copyRange(reader, writer); reader.close(); if (exception != null) throw exception; }	@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { serveResource(request, response, true); }	@Override protected void doHead(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { serveResource(request, response, false); }	protected void serveResource(HttpServletRequest request, HttpServletResponse response, boolean content) throws IOException, ServletException { boolean serveContent = content; String path = getRelativePath(request); if (debug > 0) { if (serveContent) log("DefaultServlet.serveResource: Serving resource '" + path + "' headers and data"); else log("DefaultServlet.serveResource: Serving resource '" + path + "' headers only"); } WebResource resource = resources.getResource(path); if (!resource.exists()) { // Check if we're included so we can return the appropriate String requestUri = (String) request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI); if (requestUri == null) { requestUri = request.getRequestURI(); } else { throw new FileNotFoundException(sm.getString("defaultServlet.missingResource", requestUri)); } response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri); return; } if (resource.isFile()) { if (path.endsWith("/") || (path.endsWith("\\"))) { // Check if we're included so we can return the appropriate String requestUri = (String) request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI); if (requestUri == null) { requestUri = request.getRequestURI(); } response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri); return; } } boolean isError = response.getStatus() >= HttpServletResponse.SC_BAD_REQUEST; if (resource.isFile()) { boolean included = (request.getAttribute(RequestDispatcher.INCLUDE_CONTEXT_PATH) != null); if (!included && !isError && !checkIfHeaders(request, response, resource)) { return; } } String contentType = resource.getMimeType(); if (contentType == null) { contentType = getServletContext().getMimeType(resource.getName()); resource.setMimeType(contentType); } ArrayList<Range> ranges = null; long contentLength = -1L; if (resource.isDirectory()) { if (!listings) { response.sendError(HttpServletResponse.SC_NOT_FOUND, request.getRequestURI()); return; } contentType = "text/html;charset=UTF-8"; } else { if (!isError) { if (useAcceptRanges) { response.setHeader("Accept-Ranges", "bytes"); } ranges = parseRange(request, response, resource); response.setHeader("ETag", resource.getETag()); response.setHeader("Last-Modified", resource.getLastModifiedHttp()); } contentLength = resource.getContentLength(); if (contentLength == 0L) { serveContent = false; } } ServletOutputStream ostream = null; PrintWriter writer = null; if (serveContent) { try { ostream = response.getOutputStream(); } catch (IllegalStateException e) { if ((contentType == null) || (contentType.startsWith("text")) || (contentType.endsWith("xml")) || (contentType.contains("/javascript"))) { writer = response.getWriter(); ranges = FULL; } else { throw e; } } } // Check to see if a Filter, Valve of wrapper has written some content. // If it has, disable range requests and setting of a content length ServletResponse r = response; long contentWritten = 0; while (r instanceof ServletResponseWrapper) { r = ((ServletResponseWrapper) r).getResponse(); } if (r instanceof ResponseFacade) { contentWritten = ((ResponseFacade) r).getContentWritten(); } if (contentWritten > 0) { ranges = FULL; } if (resource.isDirectory() || isError || ((ranges == null || ranges.isEmpty()) && request.getHeader("Range") == null) || ranges == FULL) { if (contentType != null) { if (debug > 0) log("DefaultServlet.serveFile: contentType='" + contentType + "'"); response.setContentType(contentType); } if (resource.isFile() && contentLength >= 0 && (!serveContent || ostream != null)) { if (debug > 0) log("DefaultServlet.serveFile: contentLength=" + contentLength); if (contentWritten == 0) { response.setContentLengthLong(contentLength); } } InputStream renderResult = null; if (resource.isDirectory()) { if (serveContent) { renderResult = render(getPathPrefix(request), resource); } } if (serveContent) { try { response.setBufferSize(output); } catch (IllegalStateException e) { // Silent catch } if (ostream != null) { if (!checkSendfile(request, response, resource, contentLength, null)) copy(resource, renderResult, ostream); } else { copy(resource, renderResult, writer); } } } else { if ((ranges == null) || (ranges.isEmpty())) return; response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT); if (ranges.size() == 1) { Range range = ranges.get(0); response.addHeader("Content-Range", "bytes " + range.start + "-" + range.end + "/" + range.length); long length = range.end - range.start + 1; response.setContentLengthLong(length); if (contentType != null) { if (debug > 0) log("DefaultServlet.serveFile: contentType='" + contentType + "'"); response.setContentType(contentType); } if (serveContent) { try { response.setBufferSize(output); } catch (IllegalStateException e) { // Silent catch } if (ostream != null) { if (!checkSendfile(request, response, resource, range.end - range.start + 1, range)) copy(resource, ostream, range); } else { throw new IllegalStateException(); } } } else { response.setContentType("multipart/byteranges; boundary=" + mimeSeparation); if (serveContent) { try { response.setBufferSize(output); } catch (IllegalStateException e) { // Silent catch } if (ostream != null) { copy(resource, ostream, ranges.iterator(), contentType); } else { throw new IllegalStateException(); } } } } }
@Override public void event(Request request, Response response, CometEvent event) throws IOException, ServletException { boolean ok = false; try { getNext().event(request, response, event); ok = true; } finally { if (!ok || response.isClosed() || (event.getEventType() == CometEvent.EventType.END) || (event.getEventType() == CometEvent.EventType.ERROR && !(event.getEventSubType() == CometEvent.EventSubType.TIMEOUT))) { cometRequests.remove(request); // Remove connection from session expiration tracking // Note: can't get the session if it has been invalidated but HttpSession session = request.getSession(false); if (session != null) { synchronized (session) { Request[] reqs = null; try { reqs = (Request[]) session.getAttribute(cometRequestsAttribute); } catch (IllegalStateException ise) { // Ignore - session has been invalidated // Listener will have cleaned up } if (reqs != null) { boolean found = false; for (int i = 0; !found && (i < reqs.length); i++) { found = (reqs[i] == request); } if (found) { if (reqs.length > 1) { Request[] newConnectionInfos = new Request[reqs.length - 1]; int pos = 0; for (int i = 0; i < reqs.length; i++) { if (reqs[i] != request) { newConnectionInfos[pos++] = reqs[i]; } } try { session.setAttribute(cometRequestsAttribute, newConnectionInfos); } catch (IllegalStateException ise) { // Ignore - session has been invalidated // Listener will have cleaned up } } else { try { session.removeAttribute(cometRequestsAttribute); } catch (IllegalStateException ise) { // Ignore - session has been invalidated // Listener will have cleaned up } } } } } } } } }	@Override public void invoke(Request request, Response response) throws IOException, ServletException { getNext().invoke(request, response); if (request.isComet() && !response.isClosed()) { // Start tracking this connection, since this is a HttpSession session = request.getSession(true); cometRequests.add(request); synchronized (session) { Request[] requests = (Request[]) session.getAttribute(cometRequestsAttribute); if (requests == null) { requests = new Request[1]; requests[0] = request; session.setAttribute(cometRequestsAttribute, requests); } else { Request[] newRequests = new Request[requests.length + 1]; for (int i = 0; i < requests.length; i++) { newRequests[i] = requests[i]; } newRequests[requests.length] = request; session.setAttribute(cometRequestsAttribute, newRequests); } } } }	@Override public void sessionDestroyed(HttpSessionEvent se) { Request[] reqs = (Request[]) se.getSession().getAttribute(cometRequestsAttribute); if (reqs != null) { for (int i = 0; i < reqs.length; i++) { Request req = reqs[i]; try { CometEventImpl event = req.getEvent(); event.setEventType(CometEvent.EventType.END); event.setEventSubType(CometEvent.EventSubType.SESSION_END); ((CometProcessor) req.getWrapper().getServlet()).event(event); event.close(); } catch (Exception e) { req.getWrapper().getParent().getLogger().warn(sm.getString("cometConnectionManagerValve.listenerEvent"), e); } } } }
public static String interpreterCall(boolean isTagFile, String expression, Class<?> expectedType, String fnmapvar, boolean XmlEscape) { String jspCtxt = null; if (isTagFile) { jspCtxt = "this.getJspContext()"; } else { jspCtxt = "_jspx_page_context"; } String targetType = expectedType.getCanonicalName(); String primitiveConverterMethod = null; if (expectedType.isPrimitive()) { if (expectedType.equals(Boolean.TYPE)) { targetType = Boolean.class.getName(); primitiveConverterMethod = "booleanValue"; } else if (expectedType.equals(Byte.TYPE)) { targetType = Byte.class.getName(); primitiveConverterMethod = "byteValue"; } else if (expectedType.equals(Character.TYPE)) { targetType = Character.class.getName(); primitiveConverterMethod = "charValue"; } else if (expectedType.equals(Short.TYPE)) { targetType = Short.class.getName(); primitiveConverterMethod = "shortValue"; } else if (expectedType.equals(Integer.TYPE)) { targetType = Integer.class.getName(); primitiveConverterMethod = "intValue"; } else if (expectedType.equals(Long.TYPE)) { targetType = Long.class.getName(); primitiveConverterMethod = "longValue"; } else if (expectedType.equals(Float.TYPE)) { targetType = Float.class.getName(); primitiveConverterMethod = "floatValue"; } else if (expectedType.equals(Double.TYPE)) { targetType = Double.class.getName(); primitiveConverterMethod = "doubleValue"; } } if (primitiveConverterMethod != null) { XmlEscape = false; } /* * Build up the base call to the interpreter. */ // XXX - We use a proprietary call to the interpreter for now // as the current standard machinery is inefficient and requires // lots of wrappers and adapters. This should all clear up once // the EL interpreter moves out of JSTL and into its own project. // In the future, this should be replaced by code that calls // ExpressionEvaluator.parseExpression() and then cache the resulting // expression objects. The interpreterCall would simply select // one of the pre-cached expressions and evaluate it. // Note that PageContextImpl implements VariableResolver and // the generated Servlet/SimpleTag implements FunctionMapper, so targetType = toJavaSourceType(targetType); StringBuilder call = new StringBuilder("(" + targetType + ") " + "org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate" + "(" + Generator.quote(expression) + ", " + targetType + ".class, " + "(javax.servlet.jsp.PageContext)" + jspCtxt + ", " + fnmapvar + ", " + XmlEscape + ")"); if (primitiveConverterMethod != null) { call.insert(0, "("); call.append(")." + primitiveConverterMethod + "()"); } return call.toString(); }
protected PooledConnection createConnection(long now, PooledConnection notUsed, String username, String password) throws SQLException { PooledConnection con = create(false); if (username != null) con.getAttributes().put(PooledConnection.PROP_USER, username); if (password != null) con.getAttributes().put(PooledConnection.PROP_PASSWORD, password); boolean error = false; try { con.lock(); con.connect(); if (con.validate(PooledConnection.VALIDATE_INIT)) { con.setTimestamp(now); if (getPoolProperties().isLogAbandoned()) { con.setStackTrace(getThreadDump()); } if (!busy.offer(con)) { log.debug("Connection doesn't fit into busy array, connection will not be traceable."); } return con; } else { //validation failed, make sure we disconnect error = true; } //end if } catch (Exception e) { error = true; if (log.isDebugEnabled()) log.debug("Unable to create a new JDBC connection.", e); if (e instanceof SQLException) { throw (SQLException) e; } else { SQLException ex = new SQLException(e.getMessage()); ex.initCause(e); throw ex; } } finally { if (error) { release(con); } con.unlock(); } return null; }	@Override public String getValidationQuery() { return getPoolProperties().getValidationQuery(); }	@Override public String getValidationQuery() { return validationQuery; }	@Override public String getValidationQuery() { return getPoolProperties().getValidationQuery(); }	public boolean validate(int validateAction, String sql) { if (this.isDiscarded()) { return false; } if (!doValidate(validateAction)) { return true; } long now = System.currentTimeMillis(); if (validateAction != VALIDATE_INIT && poolProperties.getValidationInterval() > 0 && (now - this.lastValidated) < poolProperties.getValidationInterval()) { return true; } if (poolProperties.getValidator() != null) { if (poolProperties.getValidator().validate(connection, validateAction)) { this.lastValidated = now; return true; } else { if (getPoolProperties().getLogValidationErrors()) { log.error("Custom validation through " + poolProperties.getValidator() + " failed."); } return false; } } String query = sql; if (validateAction == VALIDATE_INIT && poolProperties.getInitSQL() != null) { query = poolProperties.getInitSQL(); } if (query == null) { query = poolProperties.getValidationQuery(); } Statement stmt = null; try { stmt = connection.createStatement(); stmt.execute(query); stmt.close(); this.lastValidated = now; return true; } catch (Exception ex) { if (getPoolProperties().getLogValidationErrors()) { log.warn("SQL Validation error", ex); } else if (log.isDebugEnabled()) { log.debug("Unable to validate object:", ex); } if (stmt != null) try { stmt.close(); } catch (Exception ignore2) { /*NOOP*/ } } return false; }	public static PoolConfiguration parsePoolProperties(Properties properties) { PoolConfiguration poolProperties = new PoolProperties(); String value = null; value = properties.getProperty(PROP_DEFAULTAUTOCOMMIT); if (value != null) { poolProperties.setDefaultAutoCommit(Boolean.valueOf(value)); } value = properties.getProperty(PROP_DEFAULTREADONLY); if (value != null) { poolProperties.setDefaultReadOnly(Boolean.valueOf(value)); } value = properties.getProperty(PROP_DEFAULTTRANSACTIONISOLATION); if (value != null) { int level = UNKNOWN_TRANSACTIONISOLATION; if ("NONE".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_NONE; } else if ("READ_COMMITTED".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_READ_COMMITTED; } else if ("READ_UNCOMMITTED".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_READ_UNCOMMITTED; } else if ("REPEATABLE_READ".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_REPEATABLE_READ; } else if ("SERIALIZABLE".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_SERIALIZABLE; } else { try { level = Integer.parseInt(value); } catch (NumberFormatException e) { System.err.println("Could not parse defaultTransactionIsolation: " + value); System.err.println("WARNING: defaultTransactionIsolation not set"); System.err.println("using default value of database driver"); level = UNKNOWN_TRANSACTIONISOLATION; } } poolProperties.setDefaultTransactionIsolation(level); } value = properties.getProperty(PROP_DEFAULTCATALOG); if (value != null) { poolProperties.setDefaultCatalog(value); } value = properties.getProperty(PROP_DRIVERCLASSNAME); if (value != null) { poolProperties.setDriverClassName(value); } value = properties.getProperty(PROP_MAXACTIVE); if (value != null) { poolProperties.setMaxActive(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXIDLE); if (value != null) { poolProperties.setMaxIdle(Integer.parseInt(value)); } value = properties.getProperty(PROP_MINIDLE); if (value != null) { poolProperties.setMinIdle(Integer.parseInt(value)); } value = properties.getProperty(PROP_INITIALSIZE); if (value != null) { poolProperties.setInitialSize(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXWAIT); if (value != null) { poolProperties.setMaxWait(Integer.parseInt(value)); } value = properties.getProperty(PROP_TESTONBORROW); if (value != null) { poolProperties.setTestOnBorrow(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TESTONRETURN); if (value != null) { poolProperties.setTestOnReturn(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TESTONCONNECT); if (value != null) { poolProperties.setTestOnConnect(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TIMEBETWEENEVICTIONRUNSMILLIS); if (value != null) { poolProperties.setTimeBetweenEvictionRunsMillis(Integer.parseInt(value)); } value = properties.getProperty(PROP_NUMTESTSPEREVICTIONRUN); if (value != null) { poolProperties.setNumTestsPerEvictionRun(Integer.parseInt(value)); } value = properties.getProperty(PROP_MINEVICTABLEIDLETIMEMILLIS); if (value != null) { poolProperties.setMinEvictableIdleTimeMillis(Integer.parseInt(value)); } value = properties.getProperty(PROP_TESTWHILEIDLE); if (value != null) { poolProperties.setTestWhileIdle(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_PASSWORD); if (value != null) { poolProperties.setPassword(value); } value = properties.getProperty(PROP_URL); if (value != null) { poolProperties.setUrl(value); } value = properties.getProperty(PROP_USERNAME); if (value != null) { poolProperties.setUsername(value); } value = properties.getProperty(PROP_VALIDATIONQUERY); if (value != null) { poolProperties.setValidationQuery(value); } value = properties.getProperty(PROP_VALIDATOR_CLASS_NAME); if (value != null) { poolProperties.setValidatorClassName(value); } value = properties.getProperty(PROP_VALIDATIONINTERVAL); if (value != null) { poolProperties.setValidationInterval(Long.parseLong(value)); } value = properties.getProperty(PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED); if (value != null) { poolProperties.setAccessToUnderlyingConnectionAllowed(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_REMOVEABANDONED); if (value != null) { poolProperties.setRemoveAbandoned(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_REMOVEABANDONEDTIMEOUT); if (value != null) { poolProperties.setRemoveAbandonedTimeout(Integer.parseInt(value)); } value = properties.getProperty(PROP_LOGABANDONED); if (value != null) { poolProperties.setLogAbandoned(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_POOLPREPAREDSTATEMENTS); if (value != null) { log.warn(PROP_POOLPREPAREDSTATEMENTS + " is not a valid setting, it will have no effect."); } value = properties.getProperty(PROP_MAXOPENPREPAREDSTATEMENTS); if (value != null) { log.warn(PROP_MAXOPENPREPAREDSTATEMENTS + " is not a valid setting, it will have no effect."); } value = properties.getProperty(PROP_CONNECTIONPROPERTIES); if (value != null) { Properties p = getProperties(value); poolProperties.setDbProperties(p); } else { poolProperties.setDbProperties(new Properties()); } if (poolProperties.getUsername() != null) { poolProperties.getDbProperties().setProperty("user", poolProperties.getUsername()); } if (poolProperties.getPassword() != null) { poolProperties.getDbProperties().setProperty("password", poolProperties.getPassword()); } value = properties.getProperty(PROP_INITSQL); if (value != null) { poolProperties.setInitSQL(value); } value = properties.getProperty(PROP_INTERCEPTORS); if (value != null) { poolProperties.setJdbcInterceptors(value); } value = properties.getProperty(PROP_JMX_ENABLED); if (value != null) { poolProperties.setJmxEnabled(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_FAIR_QUEUE); if (value != null) { poolProperties.setFairQueue(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_USE_EQUALS); if (value != null) { poolProperties.setUseEquals(Boolean.parseBoolean(value)); } value = properties.getProperty(OBJECT_NAME); if (value != null) { poolProperties.setName(ObjectName.quote(value)); } value = properties.getProperty(PROP_ABANDONWHENPERCENTAGEFULL); if (value != null) { poolProperties.setAbandonWhenPercentageFull(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXAGE); if (value != null) { poolProperties.setMaxAge(Long.parseLong(value)); } value = properties.getProperty(PROP_USE_CON_LOCK); if (value != null) { poolProperties.setUseLock(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_DATASOURCE); if (value != null) { throw new IllegalArgumentException("Can't set dataSource property as a string, this must be a javax.sql.DataSource object."); } value = properties.getProperty(PROP_DATASOURCE_JNDI); if (value != null) { poolProperties.setDataSourceJNDI(value); } value = properties.getProperty(PROP_SUSPECT_TIMEOUT); if (value != null) { poolProperties.setSuspectTimeout(Integer.parseInt(value)); } value = properties.getProperty(PROP_ALTERNATE_USERNAME_ALLOWED); if (value != null) { poolProperties.setAlternateUsernameAllowed(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_COMMITONRETURN); if (value != null) { poolProperties.setCommitOnReturn(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_ROLLBACKONRETURN); if (value != null) { poolProperties.setRollbackOnReturn(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_USEDISPOSABLECONNECTIONFACADE); if (value != null) { poolProperties.setUseDisposableConnectionFacade(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_LOGVALIDATIONERRORS); if (value != null) { poolProperties.setLogValidationErrors(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_PROPAGATEINTERRUPTSTATE); if (value != null) { poolProperties.setPropagateInterruptState(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_IGNOREEXCEPTIONONPRELOAD); if (value != null) { poolProperties.setIgnoreExceptionOnPreLoad(Boolean.parseBoolean(value)); } return poolProperties; }	@Override public void setValidationQuery(String validationQuery) { getPoolProperties().setValidationQuery(validationQuery); }	@Override public void setValidatorClassName(String className) { this.poolProperties.setValidatorClassName(className); }
protected boolean isValidInternal() { return (this.isValid || this.expiring); }	@Override public boolean isValid() { if (this.expiring) { return true; } if (!this.isValid) { return false; } if (ACTIVITY_CHECK && accessCount.get() > 0) { return true; } if (maxInactiveInterval > 0) { long timeNow = System.currentTimeMillis(); int timeIdle; if (LAST_ACCESS_AT_START) { timeIdle = (int) ((timeNow - lastAccessedTime) / 1000L); } else { timeIdle = (int) ((timeNow - thisAccessedTime) / 1000L); } if (isPrimarySession()) { if (timeIdle >= maxInactiveInterval) { expire(true); } } else { if (timeIdle >= (2 * maxInactiveInterval)) { //if the session has been idle twice as long as allowed, //the primary session has probably crashed, and no other //requests are coming in. that is why we do this. otherwise expire(true, false); } } } return (this.isValid); }	@Override public boolean isValid() { if (this.expiring) { return true; } if (!this.isValid) { return false; } if (ACTIVITY_CHECK && accessCount.get() > 0) { return true; } if (maxInactiveInterval > 0) { long timeNow = System.currentTimeMillis(); int timeIdle; if (LAST_ACCESS_AT_START) { timeIdle = (int) ((timeNow - lastAccessedTime) / 1000L); } else { timeIdle = (int) ((timeNow - thisAccessedTime) / 1000L); } if (timeIdle >= maxInactiveInterval) { expire(true); } } return (this.isValid); }	public void expire(boolean notify) { if (expiring || !isValid) return; synchronized (this) { if (expiring || !isValid) return; if (manager == null) return; expiring = true; // Notify interested application event listeners Context context = manager.getContext(); // The call to expire() may not have been triggered by the webapp. // Make sure the webapp's class loader is set when calling the ClassLoader oldTccl = null; if (context.getLoader() != null && context.getLoader().getClassLoader() != null) { oldTccl = Thread.currentThread().getContextClassLoader(); if (Globals.IS_SECURITY_ENABLED) { PrivilegedAction<Void> pa = new PrivilegedSetTccl(context.getLoader().getClassLoader()); AccessController.doPrivileged(pa); } else { Thread.currentThread().setContextClassLoader(context.getLoader().getClassLoader()); } } try { if (notify) { Object[] listeners = context.getApplicationLifecycleListeners(); if (listeners != null && listeners.length > 0) { HttpSessionEvent event = new HttpSessionEvent(getSession()); for (int i = 0; i < listeners.length; i++) { int j = (listeners.length - 1) - i; if (!(listeners[j] instanceof HttpSessionListener)) continue; HttpSessionListener listener = (HttpSessionListener) listeners[j]; try { context.fireContainerEvent("beforeSessionDestroyed", listener); listener.sessionDestroyed(event); context.fireContainerEvent("afterSessionDestroyed", listener); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); try { context.fireContainerEvent("afterSessionDestroyed", listener); } catch (Exception e) { // Ignore } manager.getContext().getLogger().error(sm.getString("standardSession.sessionEvent"), t); } } } } } finally { if (oldTccl != null) { if (Globals.IS_SECURITY_ENABLED) { PrivilegedAction<Void> pa = new PrivilegedSetTccl(oldTccl); AccessController.doPrivileged(pa); } else { Thread.currentThread().setContextClassLoader(oldTccl); } } } if (ACTIVITY_CHECK) { accessCount.set(0); } setValid(false); manager.remove(this, true); if (notify) { fireSessionEvent(Session.SESSION_DESTROYED_EVENT, null); } if (principal instanceof TomcatPrincipal) { TomcatPrincipal gp = (TomcatPrincipal) principal; try { gp.logout(); } catch (Exception e) { manager.getContext().getLogger().error(sm.getString("standardSession.logoutfail"), e); } } expiring = false; String[] keys = keys(); for (int i = 0; i < keys.length; i++) removeAttributeInternal(keys[i], notify); } }	public void expire(boolean notify, boolean notifyCluster) { if (expiring) return; String expiredId = getIdInternal(); if (notifyCluster && expiredId != null && manager != null && manager instanceof DeltaManager) { DeltaManager dmanager = (DeltaManager) manager; CatalinaCluster cluster = dmanager.getCluster(); ClusterMessage msg = dmanager.requestCompleted(expiredId, true); if (msg != null) { cluster.send(msg); } } super.expire(notify); if (notifyCluster) { if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.notifying", ((ClusterManager) manager).getName(), Boolean.valueOf(isPrimarySession()), expiredId)); if (manager instanceof DeltaManager) { ((DeltaManager) manager).sessionExpired(expiredId); } } }
protected TrustManager[] getTrustManagers(String keystoreType, String keystoreProvider, String algorithm) throws Exception { String crlf = endpoint.getCrlFile(); String className = endpoint.getTrustManagerClassName(); if (className != null && className.length() > 0) { ClassLoader classLoader = getClass().getClassLoader(); Class<?> clazz = classLoader.loadClass(className); if (!(TrustManager.class.isAssignableFrom(clazz))) { throw new InstantiationException(sm.getString("jsse.invalidTrustManagerClassName", className)); } Object trustManagerObject = clazz.newInstance(); TrustManager trustManager = (TrustManager) trustManagerObject; return new TrustManager[] { trustManager }; } TrustManager[] tms = null; KeyStore trustStore = getTrustStore(keystoreType, keystoreProvider); if (trustStore != null || endpoint.getTrustManagerClassName() != null) { if (crlf == null) { TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm); tmf.init(trustStore); tms = tmf.getTrustManagers(); } else { TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm); CertPathParameters params = getParameters(algorithm, crlf, trustStore); ManagerFactoryParameters mfp = new CertPathTrustManagerParameters(params); tmf.init(mfp); tms = tmf.getTrustManagers(); } } return tms; }
protected void init(PoolConfiguration properties) throws SQLException { poolProperties = properties; if (properties.getMaxActive() < 1) { log.warn("maxActive is smaller than 1, setting maxActive to: " + PoolProperties.DEFAULT_MAX_ACTIVE); properties.setMaxActive(PoolProperties.DEFAULT_MAX_ACTIVE); } if (properties.getMaxActive() < properties.getInitialSize()) { log.warn("initialSize is larger than maxActive, setting initialSize to: " + properties.getMaxActive()); properties.setInitialSize(properties.getMaxActive()); } if (properties.getMinIdle() > properties.getMaxActive()) { log.warn("minIdle is larger than maxActive, setting minIdle to: " + properties.getMaxActive()); properties.setMinIdle(properties.getMaxActive()); } if (properties.getMaxIdle() > properties.getMaxActive()) { log.warn("maxIdle is larger than maxActive, setting maxIdle to: " + properties.getMaxActive()); properties.setMaxIdle(properties.getMaxActive()); } if (properties.getMaxIdle() < properties.getMinIdle()) { log.warn("maxIdle is smaller than minIdle, setting maxIdle to: " + properties.getMinIdle()); properties.setMaxIdle(properties.getMinIdle()); } busy = new ArrayBlockingQueue<>(properties.getMaxActive(), false); if (properties.isFairQueue()) { idle = new FairBlockingQueue<>(); //idle = new MultiLockFairBlockingQueue<PooledConnection>(); //idle = new LinkedTransferQueue<PooledConnection>(); //idle = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(),false); } else { idle = new ArrayBlockingQueue<>(properties.getMaxActive(), properties.isFairQueue()); } initializePoolCleaner(properties); if (this.getPoolProperties().isJmxEnabled()) createMBean(); //Parse and create an initial set of interceptors. Letting them know the pool has started. PoolProperties.InterceptorDefinition[] proxies = getPoolProperties().getJdbcInterceptorsAsArray(); for (int i = 0; i < proxies.length; i++) { try { if (log.isDebugEnabled()) { log.debug("Creating interceptor instance of class:" + proxies[i].getInterceptorClass()); } JdbcInterceptor interceptor = proxies[i].getInterceptorClass().newInstance(); interceptor.setProperties(proxies[i].getProperties()); interceptor.poolStarted(this); } catch (Exception x) { log.error("Unable to inform interceptor of pool start.", x); if (jmxPool != null) jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_INIT, getStackTrace(x)); close(true); SQLException ex = new SQLException(); ex.initCause(x); throw ex; } } PooledConnection[] initialPool = new PooledConnection[poolProperties.getInitialSize()]; try { for (int i = 0; i < initialPool.length; i++) { initialPool[i] = this.borrowConnection(0, null, null); } //for } catch (SQLException x) { if (jmxPool != null) jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_INIT, getStackTrace(x)); close(true); throw x; } finally { for (int i = 0; i < initialPool.length; i++) { if (initialPool[i] != null) { try { this.returnConnection(initialPool[i]); } catch (Exception x) { /*NOOP*/ } } //end if } //for } closed = false; }	public static PoolConfiguration parsePoolProperties(Properties properties) { PoolConfiguration poolProperties = new PoolProperties(); String value = null; value = properties.getProperty(PROP_DEFAULTAUTOCOMMIT); if (value != null) { poolProperties.setDefaultAutoCommit(Boolean.valueOf(value)); } value = properties.getProperty(PROP_DEFAULTREADONLY); if (value != null) { poolProperties.setDefaultReadOnly(Boolean.valueOf(value)); } value = properties.getProperty(PROP_DEFAULTTRANSACTIONISOLATION); if (value != null) { int level = UNKNOWN_TRANSACTIONISOLATION; if ("NONE".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_NONE; } else if ("READ_COMMITTED".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_READ_COMMITTED; } else if ("READ_UNCOMMITTED".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_READ_UNCOMMITTED; } else if ("REPEATABLE_READ".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_REPEATABLE_READ; } else if ("SERIALIZABLE".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_SERIALIZABLE; } else { try { level = Integer.parseInt(value); } catch (NumberFormatException e) { System.err.println("Could not parse defaultTransactionIsolation: " + value); System.err.println("WARNING: defaultTransactionIsolation not set"); System.err.println("using default value of database driver"); level = UNKNOWN_TRANSACTIONISOLATION; } } poolProperties.setDefaultTransactionIsolation(level); } value = properties.getProperty(PROP_DEFAULTCATALOG); if (value != null) { poolProperties.setDefaultCatalog(value); } value = properties.getProperty(PROP_DRIVERCLASSNAME); if (value != null) { poolProperties.setDriverClassName(value); } value = properties.getProperty(PROP_MAXACTIVE); if (value != null) { poolProperties.setMaxActive(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXIDLE); if (value != null) { poolProperties.setMaxIdle(Integer.parseInt(value)); } value = properties.getProperty(PROP_MINIDLE); if (value != null) { poolProperties.setMinIdle(Integer.parseInt(value)); } value = properties.getProperty(PROP_INITIALSIZE); if (value != null) { poolProperties.setInitialSize(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXWAIT); if (value != null) { poolProperties.setMaxWait(Integer.parseInt(value)); } value = properties.getProperty(PROP_TESTONBORROW); if (value != null) { poolProperties.setTestOnBorrow(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TESTONRETURN); if (value != null) { poolProperties.setTestOnReturn(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TESTONCONNECT); if (value != null) { poolProperties.setTestOnConnect(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TIMEBETWEENEVICTIONRUNSMILLIS); if (value != null) { poolProperties.setTimeBetweenEvictionRunsMillis(Integer.parseInt(value)); } value = properties.getProperty(PROP_NUMTESTSPEREVICTIONRUN); if (value != null) { poolProperties.setNumTestsPerEvictionRun(Integer.parseInt(value)); } value = properties.getProperty(PROP_MINEVICTABLEIDLETIMEMILLIS); if (value != null) { poolProperties.setMinEvictableIdleTimeMillis(Integer.parseInt(value)); } value = properties.getProperty(PROP_TESTWHILEIDLE); if (value != null) { poolProperties.setTestWhileIdle(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_PASSWORD); if (value != null) { poolProperties.setPassword(value); } value = properties.getProperty(PROP_URL); if (value != null) { poolProperties.setUrl(value); } value = properties.getProperty(PROP_USERNAME); if (value != null) { poolProperties.setUsername(value); } value = properties.getProperty(PROP_VALIDATIONQUERY); if (value != null) { poolProperties.setValidationQuery(value); } value = properties.getProperty(PROP_VALIDATOR_CLASS_NAME); if (value != null) { poolProperties.setValidatorClassName(value); } value = properties.getProperty(PROP_VALIDATIONINTERVAL); if (value != null) { poolProperties.setValidationInterval(Long.parseLong(value)); } value = properties.getProperty(PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED); if (value != null) { poolProperties.setAccessToUnderlyingConnectionAllowed(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_REMOVEABANDONED); if (value != null) { poolProperties.setRemoveAbandoned(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_REMOVEABANDONEDTIMEOUT); if (value != null) { poolProperties.setRemoveAbandonedTimeout(Integer.parseInt(value)); } value = properties.getProperty(PROP_LOGABANDONED); if (value != null) { poolProperties.setLogAbandoned(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_POOLPREPAREDSTATEMENTS); if (value != null) { log.warn(PROP_POOLPREPAREDSTATEMENTS + " is not a valid setting, it will have no effect."); } value = properties.getProperty(PROP_MAXOPENPREPAREDSTATEMENTS); if (value != null) { log.warn(PROP_MAXOPENPREPAREDSTATEMENTS + " is not a valid setting, it will have no effect."); } value = properties.getProperty(PROP_CONNECTIONPROPERTIES); if (value != null) { Properties p = getProperties(value); poolProperties.setDbProperties(p); } else { poolProperties.setDbProperties(new Properties()); } if (poolProperties.getUsername() != null) { poolProperties.getDbProperties().setProperty("user", poolProperties.getUsername()); } if (poolProperties.getPassword() != null) { poolProperties.getDbProperties().setProperty("password", poolProperties.getPassword()); } value = properties.getProperty(PROP_INITSQL); if (value != null) { poolProperties.setInitSQL(value); } value = properties.getProperty(PROP_INTERCEPTORS); if (value != null) { poolProperties.setJdbcInterceptors(value); } value = properties.getProperty(PROP_JMX_ENABLED); if (value != null) { poolProperties.setJmxEnabled(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_FAIR_QUEUE); if (value != null) { poolProperties.setFairQueue(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_USE_EQUALS); if (value != null) { poolProperties.setUseEquals(Boolean.parseBoolean(value)); } value = properties.getProperty(OBJECT_NAME); if (value != null) { poolProperties.setName(ObjectName.quote(value)); } value = properties.getProperty(PROP_ABANDONWHENPERCENTAGEFULL); if (value != null) { poolProperties.setAbandonWhenPercentageFull(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXAGE); if (value != null) { poolProperties.setMaxAge(Long.parseLong(value)); } value = properties.getProperty(PROP_USE_CON_LOCK); if (value != null) { poolProperties.setUseLock(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_DATASOURCE); if (value != null) { throw new IllegalArgumentException("Can't set dataSource property as a string, this must be a javax.sql.DataSource object."); } value = properties.getProperty(PROP_DATASOURCE_JNDI); if (value != null) { poolProperties.setDataSourceJNDI(value); } value = properties.getProperty(PROP_SUSPECT_TIMEOUT); if (value != null) { poolProperties.setSuspectTimeout(Integer.parseInt(value)); } value = properties.getProperty(PROP_ALTERNATE_USERNAME_ALLOWED); if (value != null) { poolProperties.setAlternateUsernameAllowed(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_COMMITONRETURN); if (value != null) { poolProperties.setCommitOnReturn(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_ROLLBACKONRETURN); if (value != null) { poolProperties.setRollbackOnReturn(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_USEDISPOSABLECONNECTIONFACADE); if (value != null) { poolProperties.setUseDisposableConnectionFacade(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_LOGVALIDATIONERRORS); if (value != null) { poolProperties.setLogValidationErrors(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_PROPAGATEINTERRUPTSTATE); if (value != null) { poolProperties.setPropagateInterruptState(Boolean.parseBoolean(value)); } return poolProperties; }	@Override public void setPropagateInterruptState(boolean propagateInterruptState) { getPoolProperties().setPropagateInterruptState(propagateInterruptState); }	@Override public void setPropagateInterruptState(boolean propagateInterruptState) { this.propagateInterruptState = propagateInterruptState; }	@Override public void setPropagateInterruptState(boolean propagateInterruptState) { getPoolProperties().setPropagateInterruptState(propagateInterruptState); }
private PooledConnection borrowConnection(int wait, String username, String password) throws SQLException { if (isClosed()) { throw new SQLException("Connection pool closed."); } //end if long now = System.currentTimeMillis(); PooledConnection con = idle.poll(); while (true) { if (con != null) { PooledConnection result = borrowConnection(now, con, username, password); if (result != null) return result; } if (size.get() < getPoolProperties().getMaxActive()) { if (size.addAndGet(1) > getPoolProperties().getMaxActive()) { size.decrementAndGet(); } else { return createConnection(now, con, username, password); } } //end if long maxWait = wait; if (wait == -1) { maxWait = (getPoolProperties().getMaxWait() <= 0) ? Long.MAX_VALUE : getPoolProperties().getMaxWait(); } long timetowait = Math.max(0, maxWait - (System.currentTimeMillis() - now)); waitcount.incrementAndGet(); try { con = idle.poll(timetowait, TimeUnit.MILLISECONDS); } catch (InterruptedException ex) { if (getPoolProperties().getPropagateInterruptState()) { Thread.currentThread().interrupt(); } else { Thread.interrupted(); } SQLException sx = new SQLException("Pool wait interrupted."); sx.initCause(ex); throw sx; } finally { waitcount.decrementAndGet(); } if (maxWait == 0 && con == null) { if (jmxPool != null) { jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.POOL_EMPTY, "Pool empty - no wait."); } throw new PoolExhaustedException("[" + Thread.currentThread().getName() + "] " + "NoWait: Pool empty. Unable to fetch a connection, none available[" + busy.size() + " in use]."); } if (con == null) { if ((System.currentTimeMillis() - now) >= maxWait) { if (jmxPool != null) { jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.POOL_EMPTY, "Pool empty - timeout."); } throw new PoolExhaustedException("[" + Thread.currentThread().getName() + "] " + "Timeout: Pool empty. Unable to fetch a connection in " + (maxWait / 1000) + " seconds, none available[size:" + size.get() + "; busy:" + busy.size() + "; idle:" + idle.size() + "; lastwait:" + timetowait + "]."); } else { continue; } } } //while }	protected void close(boolean force) { if (this.closed) return; this.closed = true; if (poolCleaner != null) { poolCleaner.stopRunning(); } BlockingQueue<PooledConnection> pool = (idle.size() > 0) ? idle : (force ? busy : idle); while (pool.size() > 0) { try { PooledConnection con = pool.poll(1000, TimeUnit.MILLISECONDS); while (con != null) { if (pool == idle) release(con); else abandon(con); if (pool.size() > 0) { con = pool.poll(1000, TimeUnit.MILLISECONDS); } else { break; } } //while } catch (InterruptedException ex) { if (getPoolProperties().getPropagateInterruptState()) { Thread.currentThread().interrupt(); } else { Thread.interrupted(); } } if (pool.size() == 0 && force && pool != busy) pool = busy; } if (this.getPoolProperties().isJmxEnabled()) this.jmxPool = null; PoolProperties.InterceptorDefinition[] proxies = getPoolProperties().getJdbcInterceptorsAsArray(); for (int i = 0; i < proxies.length; i++) { try { JdbcInterceptor interceptor = proxies[i].getInterceptorClass().newInstance(); interceptor.setProperties(proxies[i].getProperties()); interceptor.poolClosed(this); } catch (Exception x) { log.debug("Unable to inform interceptor of pool closure.", x); } } }
@Override protected void actionInternal(ActionCode actionCode, Object param) { if (actionCode == ActionCode.ASYNC_COMPLETE) { socketWrapper.clearDispatches(); if (asyncStateMachine.asyncComplete()) { ((AprEndpoint) endpoint).processSocketAsync(this.socketWrapper, SocketStatus.OPEN_READ); } } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) { if (param == null) return; long timeout = ((Long) param).longValue(); socketWrapper.setTimeout(timeout); } else if (actionCode == ActionCode.ASYNC_DISPATCH) { if (asyncStateMachine.asyncDispatch()) { ((AprEndpoint) endpoint).processSocketAsync(this.socketWrapper, SocketStatus.OPEN_READ); } } }	@Override protected void actionInternal(ActionCode actionCode, Object param) { if (actionCode == ActionCode.ASYNC_COMPLETE) { socketWrapper.clearDispatches(); if (asyncStateMachine.asyncComplete()) { ((NioEndpoint) endpoint).dispatchForEvent(socketWrapper.getSocket(), SocketStatus.OPEN_READ, true); } } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) { if (param == null) return; long timeout = ((Long) param).longValue(); final KeyAttachment ka = (KeyAttachment) socketWrapper.getSocket().getAttachment(false); if (keepAliveTimeout > 0) { ka.setTimeout(timeout); } } else if (actionCode == ActionCode.ASYNC_DISPATCH) { if (asyncStateMachine.asyncDispatch()) { ((NioEndpoint) endpoint).dispatchForEvent(socketWrapper.getSocket(), SocketStatus.OPEN_READ, true); } } }	@Override protected void actionInternal(ActionCode actionCode, Object param) { if (actionCode == ActionCode.ASYNC_COMPLETE) { socketWrapper.clearDispatches(); if (asyncStateMachine.asyncComplete()) { ((JIoEndpoint) endpoint).processSocketAsync(this.socketWrapper, SocketStatus.OPEN_READ); } } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) { if (param == null) return; long timeout = ((Long) param).longValue(); socketWrapper.setTimeout(timeout); } else if (actionCode == ActionCode.ASYNC_DISPATCH) { if (asyncStateMachine.asyncDispatch()) { ((JIoEndpoint) endpoint).processSocketAsync(this.socketWrapper, SocketStatus.OPEN_READ); } } }	@Override public SocketState asyncDispatch(SocketStatus status) { RequestInfo rp = request.getRequestProcessor(); try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); error = !getAdapter().asyncDispatch(request, response, status); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getLog().error(sm.getString("http11processor.request.process"), t); error = true; } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (isAsync()) { if (error) { request.updateCounters(); return SocketState.CLOSED; } else { return SocketState.LONG; } } else { request.updateCounters(); if (error) { return SocketState.CLOSED; } else { return SocketState.OPEN; } } }	@Override public final void action(ActionCode actionCode, Object param) { if (actionCode == ActionCode.CLOSE) { try { finish(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.COMMIT) { if (response.isCommitted()) return; try { prepareResponse(); } catch (IOException e) { error = true; } try { flush(false); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACK) { // NO_OP for AJP } else if (actionCode == ActionCode.CLIENT_FLUSH) { if (!response.isCommitted()) { try { prepareResponse(); } catch (IOException e) { error = true; return; } } try { flush(true); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.DISABLE_SWALLOW_INPUT) { // TODO: Do not swallow request input but error = true; } else if (actionCode == ActionCode.RESET) { // NO-OP } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE) { if (!certificates.isNull()) { ByteChunk certData = certificates.getByteChunk(); X509Certificate[] jsseCerts = null; ByteArrayInputStream bais = new ByteArrayInputStream(certData.getBytes(), certData.getStart(), certData.getLength()); try { CertificateFactory cf; if (clientCertProvider == null) { cf = CertificateFactory.getInstance("X.509"); } else { cf = CertificateFactory.getInstance("X.509", clientCertProvider); } while (bais.available() > 0) { X509Certificate cert = (X509Certificate) cf.generateCertificate(bais); if (jsseCerts == null) { jsseCerts = new X509Certificate[1]; jsseCerts[0] = cert; } else { X509Certificate[] temp = new X509Certificate[jsseCerts.length + 1]; System.arraycopy(jsseCerts, 0, temp, 0, jsseCerts.length); temp[jsseCerts.length] = cert; jsseCerts = temp; } } } catch (java.security.cert.CertificateException e) { getLog().error(sm.getString("ajpprocessor.certs.fail"), e); return; } catch (NoSuchProviderException e) { getLog().error(sm.getString("ajpprocessor.certs.fail"), e); return; } request.setAttribute(SSLSupport.CERTIFICATE_KEY, jsseCerts); } } else if (actionCode == ActionCode.REQ_SSL_CERTIFICATE) { // NO-OP. Can't force a new SSL handshake with the client when using // AJP as the reverse proxy controls that connection. } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) { if (request.remoteHost().isNull()) { try { request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName()); } catch (IOException iex) { // Ignore } } } else if (actionCode == ActionCode.REQ_HOST_ADDR_ATTRIBUTE) { // NO-OP // Automatically populated during prepareRequest() } else if (actionCode == ActionCode.REQ_LOCAL_NAME_ATTRIBUTE) { // NO-OP // Automatically populated during prepareRequest() } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) { request.localAddr().setString(request.localName().toString()); } else if (actionCode == ActionCode.REQ_REMOTEPORT_ATTRIBUTE) { // NO-OP // This information is not available when using the AJP protocol } else if (actionCode == ActionCode.REQ_LOCALPORT_ATTRIBUTE) { // NO-OP // Automatically populated during prepareRequest() } else if (actionCode == ActionCode.REQ_SET_BODY_REPLAY) { ByteChunk bc = (ByteChunk) param; int length = bc.getLength(); bodyBytes.setBytes(bc.getBytes(), bc.getStart(), length); request.setContentLength(length); first = false; empty = false; replay = true; endOfStream = false; } else if (actionCode == ActionCode.ASYNC_START) { asyncStateMachine.asyncStart((AsyncContextCallback) param); } else if (actionCode == ActionCode.ASYNC_DISPATCHED) { asyncStateMachine.asyncDispatched(); } else if (actionCode == ActionCode.ASYNC_TIMEOUT) { AtomicBoolean result = (AtomicBoolean) param; result.set(asyncStateMachine.asyncTimeout()); } else if (actionCode == ActionCode.ASYNC_RUN) { asyncStateMachine.asyncRun((Runnable) param); } else if (actionCode == ActionCode.ASYNC_ERROR) { asyncStateMachine.asyncError(); } else if (actionCode == ActionCode.ASYNC_IS_STARTED) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted()); } else if (actionCode == ActionCode.ASYNC_IS_DISPATCHING) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching()); } else if (actionCode == ActionCode.ASYNC_IS_ASYNC) { ((AtomicBoolean) param).set(asyncStateMachine.isAsync()); } else if (actionCode == ActionCode.ASYNC_IS_TIMINGOUT) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut()); } else if (actionCode == ActionCode.ASYNC_IS_ERROR) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncError()); } else if (actionCode == ActionCode.UPGRADE) { throw new UnsupportedOperationException(sm.getString("ajpprocessor.httpupgrade.notsupported")); } else if (actionCode == ActionCode.COMET_BEGIN) { throw new UnsupportedOperationException(sm.getString("ajpprocessor.comet.notsupported")); } else if (actionCode == ActionCode.COMET_END) { throw new UnsupportedOperationException(sm.getString("ajpprocessor.comet.notsupported")); } else if (actionCode == ActionCode.COMET_CLOSE) { throw new UnsupportedOperationException(sm.getString("ajpprocessor.comet.notsupported")); } else if (actionCode == ActionCode.COMET_SETTIMEOUT) { throw new UnsupportedOperationException(sm.getString("ajpprocessor.comet.notsupported")); } else if (actionCode == ActionCode.AVAILABLE) { if (!endOfStream) { request.setAvailable(1); } } else if (actionCode == ActionCode.NB_WRITE_INTEREST) { // Until 'true' non-blocking IO is implemented, assume it is always AtomicBoolean isReady = (AtomicBoolean) param; isReady.set(true); } else if (actionCode == ActionCode.NB_READ_INTEREST) { // NO-OP. Not required until 'true' non-blocking IO is implemented. } else if (actionCode == ActionCode.REQUEST_BODY_FULLY_READ) { AtomicBoolean result = (AtomicBoolean) param; result.set(endOfStream); } else if (actionCode == ActionCode.DISPATCH_READ) { socketWrapper.addDispatch(DispatchType.NON_BLOCKING_READ); } else if (actionCode == ActionCode.DISPATCH_WRITE) { socketWrapper.addDispatch(DispatchType.NON_BLOCKING_WRITE); } else { actionInternal(actionCode, param); } }	@Override public void recycle(boolean socketClosing) { asyncStateMachine.recycle(); first = true; endOfStream = false; empty = true; replay = false; finished = false; request.recycle(); response.recycle(); certificates.recycle(); swallowResponse = false; bytesWritten = 0; }
protected Hashtable<String, String> getDirectoryContextEnvironment() { Hashtable<String, String> env = new Hashtable<>(); if (containerLog.isDebugEnabled() && connectionAttempt == 0) containerLog.debug("Connecting to URL " + connectionURL); }	@Override protected Principal getPrincipal(String username, GSSCredential gssCredential) { DirContext context = null; Principal principal = null; try { context = open(); try { principal = getPrincipal(context, username, gssCredential); } catch (CommunicationException e) { containerLog.warn(sm.getString("jndiRealm.exception"), e); if (context != null) close(context); context = open(); principal = getPrincipal(context, username, gssCredential); } catch (ServiceUnavailableException e) { containerLog.warn(sm.getString("jndiRealm.exception"), e); if (context != null) close(context); context = open(); principal = getPrincipal(context, username, gssCredential); } release(context); return (principal); } catch (NamingException e) { containerLog.error(sm.getString("jndiRealm.exception"), e); if (context != null) close(context); return (null); } }	@Override public Principal authenticate(String username, String credentials) { DirContext context = null; Principal principal = null; try { context = open(); try { principal = authenticate(context, username, credentials); } catch (NullPointerException e) { /* BZ 42449 - Kludge Sun's LDAP provider with broken SSL */ containerLog.warn(sm.getString("jndiRealm.exception"), e); if (context != null) close(context); context = open(); principal = authenticate(context, username, credentials); } catch (CommunicationException e) { containerLog.warn(sm.getString("jndiRealm.exception"), e); if (context != null) close(context); context = open(); principal = authenticate(context, username, credentials); } catch (ServiceUnavailableException e) { containerLog.warn(sm.getString("jndiRealm.exception"), e); if (context != null) close(context); context = open(); principal = authenticate(context, username, credentials); } release(context); return (principal); } catch (NamingException e) { containerLog.error(sm.getString("jndiRealm.exception"), e); if (context != null) close(context); if (containerLog.isDebugEnabled()) containerLog.debug("Returning null principal."); return (null); } }
private void validateCpong(TesterAjpMessage message) throws Exception { Assert.assertEquals((byte) 'A', message.buf[0]); Assert.assertEquals((byte) 'B', message.buf[1]); // CPONG should have a message length of 1 Assert.assertEquals(1, message.getLen()); Assert.assertEquals(9, message.buf[4]); }	protected void prepareResponse() throws IOException { response.setCommitted(true); responseMessage.reset(); responseMessage.appendByte(Constants.JK_AJP13_SEND_HEADERS); responseMessage.appendInt(response.getStatus()); String message = null; if (org.apache.coyote.Constants.USE_CUSTOM_STATUS_MSG_IN_HEADER && HttpMessages.isSafeInHttpHeader(response.getMessage())) { message = response.getMessage(); } if (message == null) { message = HttpMessages.getInstance(response.getLocale()).getMessage(response.getStatus()); } if (message == null) { message = Integer.toString(response.getStatus()); } tmpMB.setString(message); responseMessage.appendBytes(tmpMB); MimeHeaders headers = response.getMimeHeaders(); String contentType = response.getContentType(); if (contentType != null) { headers.setValue("Content-Type").setString(contentType); } String contentLanguage = response.getContentLanguage(); if (contentLanguage != null) { headers.setValue("Content-Language").setString(contentLanguage); } long contentLength = response.getContentLengthLong(); if (contentLength >= 0) { headers.setValue("Content-Length").setLong(contentLength); } int numHeaders = headers.size(); responseMessage.appendInt(numHeaders); for (int i = 0; i < numHeaders; i++) { MessageBytes hN = headers.getName(i); int hC = Constants.getResponseAjpIndex(hN.toString()); if (hC > 0) { responseMessage.appendInt(hC); } else { responseMessage.appendBytes(hN); } MessageBytes hV = headers.getValue(i); responseMessage.appendBytes(hV); } responseMessage.end(); output(responseMessage.getBuffer(), 0, responseMessage.getLen()); }	public int doRead(ByteChunk chunk, Request req) throws IOException { if (endOfStream) { return -1; } if (first && req.getContentLengthLong() > 0) { if (!receive()) { return 0; } } else if (empty) { if (!refillReadBuffer()) { return -1; } } ByteChunk bc = bodyBytes.getByteChunk(); chunk.setBytes(bc.getBuffer(), bc.getStart(), bc.getLength()); empty = true; return chunk.getLength(); }	@Override public void recycle(boolean socketClosing) { asyncStateMachine.recycle(); first = true; endOfStream = false; empty = true; replay = false; finished = false; request.recycle(); response.recycle(); certificates.recycle(); bytesWritten = 0; }	@Test public void testKeepAlive() throws Exception { Tomcat tomcat = getTomcatInstance(); tomcat.getConnector().setProperty("connectionTimeout", "-1"); tomcat.start(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(ctx, "helloWorld", new HelloWorldServlet()); ctx.addServletMapping("/", "helloWorld"); SimpleAjpClient ajpClient = new SimpleAjpClient(); ajpClient.setPort(getPort()); ajpClient.connect(); validateCpong(ajpClient.cping()); TesterAjpMessage forwardMessage = ajpClient.createForwardMessage("/"); forwardMessage.end(); for (int i = 0; i < 2; i++) { TesterAjpMessage responseHeaders = ajpClient.sendMessage(forwardMessage); validateResponseHeaders(responseHeaders, 200); TesterAjpMessage responseBody = ajpClient.readMessage(); validateResponseBody(responseBody, HelloWorldServlet.RESPONSE_TEXT); validateResponseEnd(ajpClient.readMessage(), true); Thread.sleep(2000); validateCpong(ajpClient.cping()); } ajpClient.disconnect(); }	@Test public void testSimplePost() throws Exception { Tomcat tomcat = getTomcatInstance(); File root = new File("test/webapp"); tomcat.addWebapp("", root.getAbsolutePath()); tomcat.start(); SimpleAjpClient ajpClient = new SimpleAjpClient(); ajpClient.setPort(getPort()); ajpClient.connect(); validateCpong(ajpClient.cping()); TesterAjpMessage forwardMessage = ajpClient.createForwardMessage("/echo-params.jsp", 4); forwardMessage.addHeader(0xA008, "9"); forwardMessage.addHeader(0xA007, "application/x-www-form-urlencoded"); forwardMessage.end(); TesterAjpMessage bodyMessage = ajpClient.createBodyMessage("test=data".getBytes()); TesterAjpMessage responseHeaders = ajpClient.sendMessage(forwardMessage, bodyMessage); validateResponseHeaders(responseHeaders, 200); TesterAjpMessage responseBody = ajpClient.readMessage(); validateResponseBody(responseBody, "test - data"); validateResponseEnd(ajpClient.readMessage(), true); validateCpong(ajpClient.cping()); ajpClient.disconnect(); }
private void silence(Host host, String ctx) { String base = "org.apache.catalina.core.ContainerBase.[default].["; if (host == null) { base += getHost().getName(); } else { base += host.getName(); } base += "].["; base += ctx; base += "]"; Logger.getLogger(base).setLevel(Level.WARNING); }	public Context addWebapp(Host host, String url, String name, String path) { silence(host, url); Context ctx = new StandardContext(); ctx.setName(name); ctx.setPath(url); ctx.setDocBase(path); ctx.addLifecycleListener(new DefaultWebXmlListener()); ContextConfig ctxCfg = new ContextConfig(); ctx.addLifecycleListener(ctxCfg); ctxCfg.setDefaultWebXml(noDefaultWebXmlPath()); if (host == null) { getHost().addChild(ctx); } else { host.addChild(ctx); } return ctx; }	@Override public String getServletClass() { return existing.getClass().getName(); }	public void setHostname(String s) { hostname = s; }	@Test public void testBug53301() throws Exception { Tomcat tomcat = getTomcatInstance(); org.apache.catalina.Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); InitCount initCount = new InitCount(); Tomcat.addServlet(ctx, "initCount", initCount); ctx.addServletMapping("/", "initCount"); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/"); assertEquals("OK", res.toString()); assertEquals(1, initCount.getCallCount()); }
protected Comparator<Session> getComparator(String sortBy) { Comparator<Session> comparator = null; if ("CreationTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(session.getCreationTime()); } }; } else if ("id".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { @Override public Comparable<String> getComparableObject(Session session) { return session.getId(); } }; } else if ("LastAccessedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(session.getLastAccessedTime()); } }; } else if ("MaxInactiveInterval".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Integer>() { @Override public Comparable<Integer> getComparableObject(Session session) { return Integer.valueOf(session.getMaxInactiveInterval()); } }; } else if ("new".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Boolean>() { @Override public Comparable<Boolean> getComparableObject(Session session) { return Boolean.valueOf(session.getSession().isNew()); } }; } else if ("locale".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { @Override public Comparable<String> getComparableObject(Session session) { return JspHelper.guessDisplayLocaleFromSession(session); } }; } else if ("user".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { @Override public Comparable<String> getComparableObject(Session session) { return JspHelper.guessDisplayUserFromSession(session); } }; } else if ("UsedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getUsedTimeForSession(session)); } }; } else if ("InactiveTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getInactiveTimeForSession(session)); } }; } else if ("TTL".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getTTLForSession(session)); } }; } return comparator; }
public static MediaType parseMediaType(StringReader input) throws IOException { String type = readToken(input); if (type == null || type.length() == 0) { return null; } if (skipConstant(input, "/") == SkipConstantResult.NOT_FOUND) { return null; } String subtype = readToken(input); if (subtype == null || subtype.length() == 0) { return null; } LinkedHashMap<String, String> parameters = new LinkedHashMap<>(); SkipConstantResult lookForSemiColon = skipConstant(input, ";"); if (lookForSemiColon == SkipConstantResult.NOT_FOUND) { return null; } while (lookForSemiColon == SkipConstantResult.FOUND) { String attribute = readToken(input); if (skipConstant(input, "=") == SkipConstantResult.FOUND) { String value = readTokenOrQuotedString(input, true); parameters.put(attribute.toLowerCase(Locale.ENGLISH), value); } else { parameters.put(attribute.toLowerCase(Locale.ENGLISH), ""); } lookForSemiColon = skipConstant(input, ";"); if (lookForSemiColon == SkipConstantResult.NOT_FOUND) { return null; } } return new MediaType(type, subtype, parameters); }	@Test public void testBug53353() throws IOException { String input = "text/html; UTF-8;charset=UTF-8"; StringReader sr = new StringReader(input); MediaType m = HttpParser.parseMediaType(sr); assertEquals("text", m.getType()); assertEquals("html", m.getSubtype()); assertTrue(m.getParameterCount() == 2); assertEquals("", m.getParameterValue("UTF-8")); assertEquals("UTF-8", m.getCharset()); assertEquals("text/html; charset=UTF-8", m.toString()); assertEquals("UTF-8", m.getCharset()); }
@Override public Object getValue(EvaluationContext ctx) throws ELException { FunctionMapper fnMapper = ctx.getFunctionMapper(); if (fnMapper == null) { throw new ELException(MessageFactory.get("error.fnMapper.null")); } Method m = fnMapper.resolveFunction(this.prefix, this.localName); if (m == null && this.prefix.length() == 0) { // TODO: Do we need to think about precedence of the various ways // a lambda expression may be obtained from something that Object obj = null; if (ctx.isLambdaArgument(this.localName)) { obj = ctx.getLambdaArgument(this.localName); } if (obj == null) { VariableMapper varMapper = ctx.getVariableMapper(); if (varMapper != null) { obj = varMapper.resolveVariable(this.localName); if (obj instanceof ValueExpression) { obj = ((ValueExpression) obj).getValue(ctx); } } } if (obj == null) { obj = ctx.getELResolver().getValue(ctx, null, this.localName); } if (obj instanceof LambdaExpression) { int i = 0; while (obj instanceof LambdaExpression && i < jjtGetNumChildren()) { Node args = jjtGetChild(i); obj = ((LambdaExpression) obj).invoke(((AstMethodParameters) args).getParameters(ctx)); i++; } if (i < jjtGetNumChildren()) { throw new ELException(MessageFactory.get("error.lambda.tooManyMethodParameterSets")); } return obj; } } if (m == null) { throw new ELException(MessageFactory.get("error.fnMapper.method", this.getOutputName())); } if (this.jjtGetNumChildren() != 1) { throw new ELException(MessageFactory.get("error.funciton.tooManyMethodParameterSets", getOutputName())); } Node parameters = jjtGetChild(0); Class<?>[] paramTypes = m.getParameterTypes(); Object[] params = null; Object result = null; int numParams = parameters.jjtGetNumChildren(); if (numParams > 0) { params = new Object[numParams]; try { for (int i = 0; i < numParams; i++) { params[i] = parameters.jjtGetChild(i).getValue(ctx); params[i] = coerceToType(params[i], paramTypes[i]); } } catch (ELException ele) { throw new ELException(MessageFactory.get("error.function", this.getOutputName()), ele); } } try { result = m.invoke(null, params); } catch (IllegalAccessException iae) { throw new ELException(MessageFactory.get("error.function", this.getOutputName()), iae); } catch (InvocationTargetException ite) { Throwable cause = ite.getCause(); if (cause instanceof ThreadDeath) { throw (ThreadDeath) cause; } if (cause instanceof VirtualMachineError) { throw (VirtualMachineError) cause; } throw new ELException(MessageFactory.get("error.function", this.getOutputName()), cause); } return result; }
public boolean isFinished() { return available() == 0; }	public boolean isFinished() { AtomicBoolean result = new AtomicBoolean(false); coyoteRequest.action(ActionCode.REQUEST_BODY_FULLY_READ, result); return result.get(); }	@Override public void onComplete(AsyncEvent event) throws IOException { log.info("onComplete"); }	@Override public void onError(Throwable throwable) { log.info("ReadListener.onError"); throwable.printStackTrace(); }	public void setAvailable(int available) { this.available = available; }	public void setReadListener(ReadListener listener) { coyoteRequest.setReadListener(listener); if (isFinished() || isReady()) { coyoteRequest.action(ActionCode.DISPATCH_READ, null); } }	@Test public void testNonBlockingWriteError() throws Exception { Tomcat tomcat = getTomcatInstance(); StandardContext ctx = (StandardContext) tomcat.addContext("", System.getProperty("java.io.tmpdir")); TesterAccessLogValve alv = new TesterAccessLogValve(); ctx.getPipeline().addValve(alv); NBWriteServlet servlet = new NBWriteServlet(); String servletName = NBWriteServlet.class.getName(); Tomcat.addServlet(ctx, servletName, servlet); ctx.addServletMapping("/", servletName); tomcat.getConnector().setProperty("socket.txBufSize", "1024"); tomcat.start(); SocketFactory factory = SocketFactory.getDefault(); Socket s = factory.createSocket("localhost", getPort()); ByteChunk result = new ByteChunk(); OutputStream os = s.getOutputStream(); os.write(("GET / HTTP/1.1\r\n" + "Host: localhost:" + getPort() + "\r\n" + "Connection: close\r\n" + "\r\n").getBytes(StandardCharsets.ISO_8859_1)); os.flush(); InputStream is = s.getInputStream(); byte[] buffer = new byte[8192]; int read = 0; int readSinceLastPause = 0; int readTotal = 0; while (read != -1 && readTotal < WRITE_SIZE / 2) { long start = System.currentTimeMillis(); read = is.read(buffer); long end = System.currentTimeMillis(); log.info("Client read [" + read + "] bytes in [" + (end - start) + "] ms"); if (read > 0) { result.append(buffer, 0, read); } readSinceLastPause += read; readTotal += read; if (readSinceLastPause > WRITE_SIZE / 16) { readSinceLastPause = 0; Thread.sleep(WRITE_PAUSE_MS); } } os.close(); is.close(); s.close(); String resultString = result.toString(); log.info("Client read " + resultString.length() + " bytes"); int lineStart = 0; int lineEnd = resultString.indexOf('\n', 0); String line = resultString.substring(lineStart, lineEnd + 1); Assert.assertEquals("HTTP/1.1 200 OK\r\n", line); try { Thread.sleep(1000); } catch (Exception e) { } Assert.assertTrue("Error listener should have been invoked.", servlet.wlistener.onErrorInvoked); // TODO Figure out why non-blocking writes with the NIO connector appear alv.validateAccessLog(1, 500, WRITE_PAUSE_MS * 7, WRITE_PAUSE_MS * 7 + 30 * 1000); }
private Map<String, Segment> getSegments() { return segments; }	public Map<String, String> match(UriTemplate candidate) { Map<String, String> result = new HashMap<>(); if (candidate.getSegmentCount() != getSegmentCount()) { return null; } Iterator<Segment> candidateSegments = candidate.getSegments().values().iterator(); Iterator<Segment> targetSegments = segments.values().iterator(); while (candidateSegments.hasNext()) { Segment candidateSegment = candidateSegments.next(); Segment targetSegment = targetSegments.next(); if (targetSegment.getParameterIndex() == -1) { if (!targetSegment.getValue().equals(candidateSegment.getValue())) { return null; } } else { result.put(targetSegment.getValue(), candidateSegment.getValue()); } } return result; }	@Test(expected = java.lang.IllegalArgumentException.class) public void testDuplicate() throws Exception { @SuppressWarnings("unused") UriTemplate t = new UriTemplate("/{var}/{var}"); }	@Test public void testSpecExample2_03() throws Exception { UriTemplate t = new UriTemplate("/a/{var}"); Map<String, String> result = t.match(new UriTemplate("/a")); Assert.assertNull(result); }	@Test public void testSpecExample2_04() throws Exception { UriTemplate t = new UriTemplate("/a/{var}"); Map<String, String> result = t.match(new UriTemplate("/a/b/c")); Assert.assertNull(result); }
protected synchronized Principal getPrincipal(DirContext context, String username, GSSCredential gssCredential) throws NamingException { User user = null; List<String> roles = null; try { if (gssCredential != null && isUseDelegatedCredential()) { context.addToEnvironment(Context.SECURITY_AUTHENTICATION, "GSSAPI"); context.addToEnvironment("javax.security.sasl.server.authentication", "true"); context.addToEnvironment("javax.security.sasl.qop", "auth-conf"); // Note: Subject already set in SPNEGO authenticator so no need // for Subject.doAs() here } user = getUser(context, username); if (user != null) { roles = getRoles(context, user); } } finally { try { context.removeFromEnvironment(Context.SECURITY_AUTHENTICATION); } catch (NamingException e) { // Ignore } try { context.removeFromEnvironment("javax.security.sasl.server.authentication"); } catch (NamingException e) { // Ignore } try { context.removeFromEnvironment("javax.security.sasl.qop"); } catch (NamingException e) { // Ignore } } if (user != null) { return new GenericPrincipal(user.getUserName(), user.getPassword(), roles, null, null, gssCredential); } return null; }
@Override public Session load(String id) throws ClassNotFoundException, IOException { File file = file(id); if (file == null) { return (null); } if (!file.exists()) { return (null); } if (manager.getContext().getLogger().isDebugEnabled()) { manager.getContext().getLogger().debug(sm.getString(getStoreName() + ".loading", id, file.getAbsolutePath())); } FileInputStream fis = null; BufferedInputStream bis = null; ObjectInputStream ois = null; Loader loader = null; ClassLoader classLoader = null; try { fis = new FileInputStream(file.getAbsolutePath()); bis = new BufferedInputStream(fis); Context context = manager.getContext(); if (context != null) loader = context.getLoader(); if (loader != null) classLoader = loader.getClassLoader(); if (classLoader != null) ois = new CustomObjectInputStream(bis, classLoader); else ois = new ObjectInputStream(bis); } catch (FileNotFoundException e) { if (manager.getContext().getLogger().isDebugEnabled()) manager.getContext().getLogger().debug("No persisted data file found"); return (null); } catch (IOException e) { if (bis != null) { try { bis.close(); } catch (IOException f) { // Ignore } } if (fis != null) { try { fis.close(); } catch (IOException f) { // Ignore } } throw e; } try { StandardSession session = (StandardSession) manager.createEmptySession(); session.readObjectData(ois); session.setManager(manager); return (session); } finally { try { ois.close(); } catch (IOException f) { // Ignore } } }	@Override public Session load(String id) throws ClassNotFoundException, IOException { ResultSet rst = null; StandardSession _session = null; Loader loader = null; ClassLoader classLoader = null; ObjectInputStream ois = null; BufferedInputStream bis = null; org.apache.catalina.Context context = manager.getContext(); synchronized (this) { int numberOfTries = 2; while (numberOfTries > 0) { Connection _conn = getConnection(); if (_conn == null) { return (null); } try { if (preparedLoadSql == null) { String loadSql = "SELECT " + sessionIdCol + ", " + sessionDataCol + " FROM " + sessionTable + " WHERE " + sessionIdCol + " = ? AND " + sessionAppCol + " = ?"; preparedLoadSql = _conn.prepareStatement(loadSql); } preparedLoadSql.setString(1, id); preparedLoadSql.setString(2, getName()); rst = preparedLoadSql.executeQuery(); if (rst.next()) { bis = new BufferedInputStream(rst.getBinaryStream(2)); if (context != null) { loader = context.getLoader(); } if (loader != null) { classLoader = loader.getClassLoader(); } if (classLoader != null) { ois = new CustomObjectInputStream(bis, classLoader); } else { ois = new ObjectInputStream(bis); } if (manager.getContext().getLogger().isDebugEnabled()) { manager.getContext().getLogger().debug(sm.getString(getStoreName() + ".loading", id, sessionTable)); } _session = (StandardSession) manager.createEmptySession(); _session.readObjectData(ois); _session.setManager(manager); } else if (manager.getContext().getLogger().isDebugEnabled()) { manager.getContext().getLogger().debug(getStoreName() + ": No persisted data object found"); } numberOfTries = 0; } catch (SQLException e) { manager.getContext().getLogger().error(sm.getString(getStoreName() + ".SQLException", e)); if (dbConnection != null) close(dbConnection); } finally { try { if (rst != null) { rst.close(); } } catch (SQLException e) { // Ignore } if (ois != null) { try { ois.close(); } catch (IOException e) { // Ignore } } release(_conn); } numberOfTries--; } } return (_session); }

protected void validateSecurityRoles() { SecurityConstraint[] constraints = context.findConstraints(); for (int i = 0; i < constraints.length; i++) { String[] roles = constraints[i].findAuthRoles(); for (int j = 0; j < roles.length; j++) { if (!"*".equals(roles[j]) && !context.findSecurityRole(roles[j])) { log.info(sm.getString("contextConfig.role.auth", roles[j])); context.addSecurityRole(roles[j]); } } } Container[] wrappers = context.findChildren(); for (int i = 0; i < wrappers.length; i++) { Wrapper wrapper = (Wrapper) wrappers[i]; String runAs = wrapper.getRunAs(); if ((runAs != null) && !context.findSecurityRole(runAs)) { log.info(sm.getString("contextConfig.role.runas", runAs)); context.addSecurityRole(runAs); } String[] names = wrapper.findSecurityReferences(); for (int j = 0; j < names.length; j++) { String link = wrapper.findSecurityReference(names[j]); if ((link != null) && !context.findSecurityRole(link)) { log.info(sm.getString("contextConfig.role.link", link)); context.addSecurityRole(link); } } } }
private void configure() { Timestamp ts = new Timestamp(System.currentTimeMillis()); String tsString = ts.toString().substring(0, 19); date = tsString.substring(0, 10); String className = this.getClass().getName(); ClassLoader cl = Thread.currentThread().getContextClassLoader(); rotatable = Boolean.parseBoolean(getProperty(className + ".rotatable", "true")); if (directory == null) directory = getProperty(className + ".directory", "logs"); if (prefix == null) prefix = getProperty(className + ".prefix", "juli."); if (suffix == null) suffix = getProperty(className + ".suffix", ".log"); String sBufferSize = getProperty(className + ".bufferSize", String.valueOf(bufferSize)); try { bufferSize = Integer.parseInt(sBufferSize); } catch (NumberFormatException ignore) { //no op } String encoding = getProperty(className + ".encoding", null); if (encoding != null && encoding.length() > 0) { try { setEncoding(encoding); } catch (UnsupportedEncodingException ex) { // Ignore } } setLevel(Level.parse(getProperty(className + ".level", "" + Level.ALL))); String filterName = getProperty(className + ".filter", null); if (filterName != null) { try { setFilter((Filter) cl.loadClass(filterName).newInstance()); } catch (Exception e) { // Ignore } } String formatterName = getProperty(className + ".formatter", null); if (formatterName != null) { try { setFormatter((Formatter) cl.loadClass(formatterName).newInstance()); } catch (Exception e) { setFormatter(new SimpleFormatter()); } } else { setFormatter(new SimpleFormatter()); } setErrorManager(new ErrorManager()); }
public long getStartTime() { return startTime; }
@Override protected synchronized String getPassword(String username) { String dbCredentials = null; PreparedStatement stmt = null; ResultSet rs = null; // Number of tries is the number of attempts to connect to the database // during this login attempt (if we need to open the database) // This needs rewritten with better pooling support, the existing code // needs signature changes since the Prepared statements needs cached // with the connections. // The code below will try twice if there is a SQLException so the // connection may try to be opened again. On normal conditions (including int numberOfTries = 2; while (numberOfTries > 0) { try { open(); stmt = credentials(dbConnection, username); rs = stmt.executeQuery(); dbConnection.commit(); if (rs.next()) { dbCredentials = rs.getString(1); } if (dbCredentials != null) { dbCredentials = dbCredentials.trim(); } return dbCredentials; } catch (SQLException e) { containerLog.error(sm.getString("jdbcRealm.exception"), e); } finally { if (rs != null) { try { rs.close(); } catch (SQLException e) { containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet")); } } } if (dbConnection != null) { close(dbConnection); } numberOfTries--; } return (null); }
private void sendCloseMessage(CloseReason closeReason) { ByteBuffer msg = ByteBuffer.allocate(125); msg.putShort((short) closeReason.getCloseCode().getCode()); String reason = closeReason.getReasonPhrase(); if (reason != null && reason.length() > 0) { appendCloseReasonWithTruncation(msg, reason); } msg.flip(); try { wsRemoteEndpoint.startMessageBlock(Constants.OPCODE_CLOSE, msg, true); } catch (IOException ioe) { // Failed to send close message. Close the socket and let the caller log.error(sm.getString("wsSession.sendCloseFail"), ioe); wsRemoteEndpoint.close(); localEndpoint.onError(this, ioe); } finally { webSocketContainer.unregisterSession(localEndpoint, this); } }
private String getJarName(URL url) { String name = null; String path = url.getPath(); int end = path.indexOf(Constants.JAR_EXT); if (end != -1) { int start = path.lastIndexOf('/', end); name = path.substring(start + 1, end + 4); } else if (isScanAllDirectories()) { int start = path.lastIndexOf('/'); name = path.substring(start + 1); } return name; }	private boolean isWebappClassLoader(ClassLoader classLoader) { ClassLoader nonWebappLoader = StandardJarScanner.class.getClassLoader(); while (nonWebappLoader != null) { if (nonWebappLoader == classLoader) { return false; } nonWebappLoader = nonWebappLoader.getParent(); } return true; }	private void process(JarScannerCallback callback, URL url, boolean isWebapp) throws IOException { if (log.isTraceEnabled()) { log.trace(sm.getString("jarScan.jarUrlStart", url)); } URLConnection conn = url.openConnection(); if (conn instanceof JarURLConnection) { callback.scan((JarURLConnection) conn, isWebapp); } else { String urlStr = url.toString(); if (urlStr.startsWith("file:") || urlStr.startsWith("jndi:") || urlStr.startsWith("http:") || urlStr.startsWith("https:")) { if (urlStr.endsWith(Constants.JAR_EXT)) { URL jarURL = new URL("jar:" + urlStr + "!/"); callback.scan((JarURLConnection) jarURL.openConnection(), isWebapp); } else { File f; try { f = new File(url.toURI()); if (f.isFile() && scanAllFiles) { URL jarURL = new URL("jar:" + urlStr + "!/"); callback.scan((JarURLConnection) jarURL.openConnection(), isWebapp); } else if (f.isDirectory() && scanAllDirectories) { File metainf = new File(f.getAbsoluteFile() + File.separator + "META-INF"); if (metainf.isDirectory()) { callback.scan(f, isWebapp); } } } catch (URISyntaxException e) { IOException ioe = new IOException(); ioe.initCause(e); throw ioe; } } } } }	@Override public void scan(JarScanType scanType, ServletContext context, JarScannerCallback callback) { if (log.isTraceEnabled()) { log.trace(sm.getString("jarScan.webinflibStart")); } Set<String> dirList = context.getResourcePaths(Constants.WEB_INF_LIB); if (dirList != null) { Iterator<String> it = dirList.iterator(); while (it.hasNext()) { String path = it.next(); if (path.endsWith(Constants.JAR_EXT) && jarScanFilter.check(scanType, path.substring(path.lastIndexOf('/') + 1))) { if (log.isDebugEnabled()) { log.debug(sm.getString("jarScan.webinflibJarScan", path)); } URL url = null; try { // File URLs are always faster to work with so use them String realPath = context.getRealPath(path); if (realPath == null) { url = context.getResource(path); } else { url = (new File(realPath)).toURI().toURL(); } process(callback, url, true); } catch (IOException e) { log.warn(sm.getString("jarScan.webinflibFail", url), e); } } else { if (log.isTraceEnabled()) { log.trace(sm.getString("jarScan.webinflibJarNoScan", path)); } } } } if (scanAllDirectories) { try { URL url = context.getResource("/WEB-INF/classes/META-INF"); if (url != null) { try { callback.scanWebInfClasses(); } catch (IOException e) { log.warn(sm.getString("jarScan.webinfclassesFail"), e); } } } catch (MalformedURLException e) { // Ignore } } if (scanClassPath) { if (log.isTraceEnabled()) { log.trace(sm.getString("jarScan.classloaderStart")); } ClassLoader stopLoader = null; if (!scanBootstrapClassPath) { stopLoader = ClassLoader.getSystemClassLoader().getParent(); } ClassLoader classLoader = context.getClassLoader(); // No need to scan the web application class loader - we have classLoader = classLoader.getParent(); // JARs are treated as application provided until the common class boolean isWebapp = true; while (classLoader != null && classLoader != stopLoader) { if (classLoader instanceof URLClassLoader) { if (isWebapp) { isWebapp = isWebappClassLoader(classLoader); } URL[] urls = ((URLClassLoader) classLoader).getURLs(); for (int i = 0; i < urls.length; i++) { String jarName = getJarName(urls[i]); if (jarName != null && jarScanFilter.check(scanType, jarName)) { if (log.isDebugEnabled()) { log.debug(sm.getString("jarScan.classloaderJarScan", urls[i])); } try { process(callback, urls[i], isWebapp); } catch (IOException ioe) { log.warn(sm.getString("jarScan.classloaderFail", urls[i]), ioe); } } else { if (log.isTraceEnabled()) { log.trace(sm.getString("jarScan.classloaderJarNoScan", urls[i])); } } } } classLoader = classLoader.getParent(); } } }
private void invokePlugin(Node.CustomTag n) { TagPlugin tagPlugin = tagPlugins.get(n.getTagHandlerClass().getName()); if (tagPlugin == null) { return; } TagPluginContext tagPluginContext = new TagPluginContextImpl(n, pageInfo); n.setTagPluginContext(tagPluginContext); tagPlugin.doTag(tagPluginContext); }	private void loadTagPlugins(ErrorDispatcher err, InputStream is) throws JasperException { TreeNode root = (new ParserUtils()).parseXMLDocument(TAG_PLUGINS_XML, is); if (root == null) { return; } if (!TAG_PLUGINS_ROOT_ELEM.equals(root.getName())) { err.jspError("jsp.error.plugin.wrongRootElement", TAG_PLUGINS_XML, TAG_PLUGINS_ROOT_ELEM); } tagPlugins = new HashMap<>(); Iterator<TreeNode> pluginList = root.findChildren("tag-plugin"); while (pluginList.hasNext()) { TreeNode pluginNode = pluginList.next(); TreeNode tagClassNode = pluginNode.findChild("tag-class"); if (tagClassNode == null) { return; } String tagClass = tagClassNode.getBody().trim(); TreeNode pluginClassNode = pluginNode.findChild("plugin-class"); if (pluginClassNode == null) { return; } String pluginClassStr = pluginClassNode.getBody(); TagPlugin tagPlugin = null; try { Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginClassStr); tagPlugin = (TagPlugin) pluginClass.newInstance(); } catch (Exception e) { throw new JasperException(e); } if (tagPlugin == null) { return; } tagPlugins.put(tagClass, tagPlugin); } initialized = true; }	public void apply(Node.Nodes page, ErrorDispatcher err, PageInfo pageInfo) throws JasperException { init(err); if (tagPlugins == null || tagPlugins.size() == 0) { return; } this.pageInfo = pageInfo; page.visit(new Node.Visitor() { @Override } }
protected ServletContainerInitializer getServletContainerInitializer(String className) throws IOException { ServletContainerInitializer sci = null; try { Class<?> clazz = Class.forName(className, true, context.getLoader().getClassLoader()); sci = (ServletContainerInitializer) clazz.newInstance(); } catch (ClassNotFoundException e) { log.error(sm.getString("contextConfig.invalidSci", className), e); throw new IOException(e); } catch (InstantiationException e) { log.error(sm.getString("contextConfig.invalidSci", className), e); throw new IOException(e); } catch (IllegalAccessException e) { log.error(sm.getString("contextConfig.invalidSci", className), e); throw new IOException(e); } return sci; }	protected WebXml createWebXml() { return new WebXml(); }	protected List<ServletContainerInitializer> getServletContainerInitializers(InputStream is) throws IOException { List<ServletContainerInitializer> initializers = new ArrayList<>(); if (is != null) { String line = null; try { BufferedReader br = new BufferedReader(new InputStreamReader(is, "UTF-8")); while ((line = br.readLine()) != null) { line = line.trim(); if (line.length() > 0) { int i = line.indexOf('#'); if (i > -1) { if (i == 0) { continue; } line = line.substring(0, i).trim(); } initializers.add(getServletContainerInitializer(line)); } } } catch (UnsupportedEncodingException e) { // Should never happen with UTF-8 // If it does - ignore & return null } } return initializers; }	protected void webConfig() { /* * Anything and everything can override the global and host defaults. * This is implemented in two parts * - Handle as a web fragment that gets added after everything else so * everything else takes priority * - Mark Servlets as overridable so SCI configuration can replace * configuration from the defaults */ Set<WebXml> defaults = new HashSet<>(); defaults.add(getDefaultWebXmlFragment()); WebXml webXml = createWebXml(); InputSource contextWebXml = getContextWebXmlSource(); if (!webXmlParser.parseWebXml(contextWebXml, webXml, false)) { ok = false; } ServletContext sContext = context.getServletContext(); // Ordering is important here // Step 1. Identify all the JARs packaged with the application and those // provided by the container. If any of the application JARs have a // web-fragment.xml it will be parsed at this point. web-fragment.xml Map<String, WebXml> fragments = processJarsForWebFragments(); Set<WebXml> orderedFragments = null; orderedFragments = WebXml.orderWebFragments(webXml, fragments, sContext); if (ok) { processServletContainerInitializers(orderedFragments); } if (!webXml.isMetadataComplete() || typeInitializerMap.size() > 0) { if (ok) { WebResource[] webResources = context.getResources().listResources("/WEB-INF/classes"); for (WebResource webResource : webResources) { processAnnotationsWebResource(webResource, webXml, webXml.isMetadataComplete()); } } if (ok) { processAnnotations(orderedFragments, webXml.isMetadataComplete()); } javaClassCache.clear(); } if (!webXml.isMetadataComplete()) { if (ok) { ok = webXml.merge(orderedFragments); } // Step 7. Apply global defaults // Have to merge defaults before JSP conversion since defaults webXml.merge(defaults); if (ok) { convertJsps(webXml); } if (ok) { configureContext(webXml); } } else { webXml.merge(defaults); convertJsps(webXml); configureContext(webXml); } // Step 9a. Make the merged web.xml available to other // components, specifically Jasper, to save those components // from having to re-generate it. String mergedWebXml = webXml.toXml(); sContext.setAttribute(org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML, mergedWebXml); if (context.getLogEffectiveWebXml()) { log.info("web.xml:\n" + mergedWebXml); } if (ok) { // Spec does not define an order. Set<WebXml> resourceJars = new LinkedHashSet<>(); if (orderedFragments != null) { for (WebXml fragment : orderedFragments) { resourceJars.add(fragment); } } for (WebXml fragment : fragments.values()) { if (!resourceJars.contains(fragment)) { resourceJars.add(fragment); } } processResourceJARs(resourceJars); // See also StandardContext.resourcesStart() for // WEB-INF/classes/META-INF/resources configuration } if (ok) { for (Map.Entry<ServletContainerInitializer, Set<Class<?>>> entry : initializerClassMap.entrySet()) { if (entry.getValue().isEmpty()) { context.addServletContainerInitializer(entry.getKey(), null); } else { context.addServletContainerInitializer(entry.getKey(), entry.getValue()); } } } }
private int doWriteInternal(boolean block, byte[] b, int off, int len) throws IOException { channel.getBufHandler().getWriteBuffer().clear(); channel.getBufHandler().getWriteBuffer().put(b, off, len); channel.getBufHandler().getWriteBuffer().flip(); int written = 0; NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment) channel.getAttachment(false); if (att == null) { throw new IOException("Key must be cancelled"); } long writeTimeout = att.getTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) { //ignore } try { written = pool.write(channel.getBufHandler().getWriteBuffer(), channel, selector, writeTimeout, block); } finally { if (selector != null) { pool.put(selector); } } if (written < len) { channel.getPoller().add(channel, SelectionKey.OP_WRITE); } return written; }	private synchronized int writeToSocket(ByteBuffer bytebuffer, boolean block, boolean flip) throws IOException { if (flip) { bytebuffer.flip(); flipped = true; } int written = 0; NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment) socket.getAttachment(false); if (att == null) throw new IOException("Key must be cancelled"); long writeTimeout = att.getTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) { //ignore } try { written = pool.write(bytebuffer, socket, selector, writeTimeout, block); do { if (socket.flush(true, selector, writeTimeout)) break; } while (true); } finally { if (selector != null) pool.put(selector); } if (block || bytebuffer.remaining() == 0) { //blocking writes must empty the buffer bytebuffer.clear(); flipped = false; } return written; }	public SendfileData getSendfileData() { return this.sendfileData; }	@Override protected void doFlush() throws IOException { NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment) channel.getAttachment(false); if (att == null) { throw new IOException("Key must be cancelled"); } long writeTimeout = att.getTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) { //ignore } try { do { if (channel.flush(true, selector, writeTimeout)) { break; } } while (true); } finally { if (selector != null) { pool.put(selector); } } }	@Override protected void output(byte[] src, int offset, int length) throws IOException { NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment) socket.getAttachment(false); if (att == null) throw new IOException("Key must be cancelled"); ByteBuffer writeBuffer = socket.getBufHandler().getWriteBuffer(); writeBuffer.put(src, offset, length); writeBuffer.flip(); long writeTimeout = att.getTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) { //ignore } try { pool.write(writeBuffer, socket, selector, writeTimeout, true); } finally { writeBuffer.clear(); if (selector != null) pool.put(selector); } }	public void reset(Poller poller, NioChannel channel, long soTimeout) { this.socket = channel; this.poller = poller; lastAccess = System.currentTimeMillis(); setComet(false); setTimeout(soTimeout); error = false; sendfileData = null; if (readLatch != null) { try { for (int i = 0; i < (int) readLatch.getCount(); i++) { readLatch.countDown(); } } catch (Exception ignore) { } } readLatch = null; if (writeLatch != null) { try { for (int i = 0; i < (int) writeLatch.getCount(); i++) { writeLatch.countDown(); } } catch (Exception ignore) { } } writeLatch = null; cometNotify = false; sendfileData = null; keepAliveLeft = 100; async = false; }
private void registerAuthenticatedSession(WsSession wsSession, String httpSessionId) { Set<WsSession> wsSessions = authenticatedSessions.get(httpSessionId); if (wsSession == null) { wsSessions = Collections.newSetFromMap(new ConcurrentHashMap<WsSession, Boolean>()); authenticatedSessions.putIfAbsent(httpSessionId, wsSessions); wsSessions = authenticatedSessions.get(httpSessionId); } wsSessions.add(wsSession); }
public Set<String> getIncludeCodas() { return includeCodas; }	public Set<String> getIncludePreludes() { return includePreludes; }	public Boolean getElIgnored() { return elIgnored; }	@Test public void testBug51584() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-fragments"); tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); tomcat.start(); // No further tests required. The bug triggers an infinite loop on // context start so the test will crash before it reaches this point if // it fails }	public void testWebapp() throws Exception { File appDir = new File("test/webapp"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL()); Assert.assertEquals(3, context.getEffectiveMajorVersion()); Assert.assertEquals(1, context.getEffectiveMinorVersion()); JspConfigDescriptor jspConfigDescriptor = context.getJspConfigDescriptor(); Assert.assertTrue(jspConfigDescriptor.getTaglibs().isEmpty()); Collection<JspPropertyGroupDescriptor> propertyGroups = jspConfigDescriptor.getJspPropertyGroups(); Assert.assertEquals(1, propertyGroups.size()); JspPropertyGroupDescriptor groupDescriptor = propertyGroups.iterator().next(); Assert.assertEquals("text/plain", groupDescriptor.getDefaultContentType()); Collection<String> urlPatterns = groupDescriptor.getUrlPatterns(); Assert.assertEquals(2, urlPatterns.size()); Iterator<String> iterator = urlPatterns.iterator(); Assert.assertEquals("/bug49nnn/bug49726a.jsp", iterator.next()); Assert.assertEquals("/bug49nnn/bug49726b.jsp", iterator.next()); }
private void processWebDotXml() { if (ctxt.getEffectiveMajorVersion() < 2) { defaultIsELIgnored = "true"; defaultDeferedSyntaxAllowedAsLiteral = "true"; return; } if (ctxt.getEffectiveMajorVersion() == 2) { if (ctxt.getEffectiveMinorVersion() < 5) { defaultDeferedSyntaxAllowedAsLiteral = "true"; } if (ctxt.getEffectiveMinorVersion() < 4) { defaultIsELIgnored = "true"; return; } } JspConfigDescriptor jspConfig = ctxt.getJspConfigDescriptor(); if (jspConfig == null) { return; } jspProperties = new Vector<>(); Collection<JspPropertyGroupDescriptor> jspPropertyGroups = jspConfig.getJspPropertyGroups(); for (JspPropertyGroupDescriptor jspPropertyGroup : jspPropertyGroups) { Collection<String> urlPatterns = jspPropertyGroup.getUrlPatterns(); if (urlPatterns.size() == 0) { continue; } for (String urlPattern : urlPatterns) { String path = null; String extension = null; if (urlPattern.indexOf('*') < 0) { path = urlPattern; } else { int i = urlPattern.lastIndexOf('/'); String file; if (i >= 0) { path = urlPattern.substring(0, i + 1); file = urlPattern.substring(i + 1); } else { file = urlPattern; } if (file.equals("*")) { extension = "*"; } else if (file.startsWith("*.")) { extension = file.substring(file.indexOf('.') + 1); } // The url patterns are reconstructed as the following: // path != null, extension == null: / or /foo/bar.ext // path == null, extension != null: *.ext boolean isStar = "*".equals(extension); if ((path == null && (extension == null || isStar)) || (path != null && !isStar)) { if (log.isWarnEnabled()) { log.warn(Localizer.getMessage("jsp.warning.bad.urlpattern.propertygroup", urlPattern)); } continue; } } Vector<String> includePreludes = new Vector<>(); includePreludes.addAll(jspPropertyGroup.getIncludePreludes()); Vector<String> includeCodas = new Vector<>(); includeCodas.addAll(jspPropertyGroup.getIncludeCodas()); JspProperty property = new JspProperty(jspPropertyGroup.getIsXml(), jspPropertyGroup.getElIgnored(), jspPropertyGroup.getScriptingInvalid(), jspPropertyGroup.getPageEncoding(), includePreludes, includeCodas, jspPropertyGroup.getDeferredSyntaxAllowedAsLiteral(), jspPropertyGroup.getTrimDirectiveWhitespaces(), jspPropertyGroup.getDefaultContentType(), jspPropertyGroup.getBuffer(), jspPropertyGroup.getErrorOnUndeclaredNamespace()); JspPropertyGroup propertyGroup = new JspPropertyGroup(path, extension, property); jspProperties.addElement(propertyGroup); } } }

protected void initServletContext() throws IOException, JasperException { PrintWriter log = new PrintWriter(System.out); URL resourceBase = new File(uriRoot).getCanonicalFile().toURI().toURL(); context = new JspCServletContext(log, resourceBase); rctxt = new JspRuntimeContext(context, this); jspConfig = new JspConfig(context); tagPluginManager = new TagPluginManager(context); }
public boolean parseWebXml(InputSource source, WebXml dest, boolean fragment) { boolean ok = true; if (source == null) { return ok; } XmlErrorHandler handler = new XmlErrorHandler(); Digester digester; WebRuleSet ruleSet; if (fragment) { digester = webFragmentDigester; ruleSet = webFragmentRuleSet; } else { digester = webDigester; ruleSet = webRuleSet; } digester.push(dest); digester.setErrorHandler(handler); if (log.isDebugEnabled()) { log.debug(sm.getString("webXmlParser.applicationStart", source.getSystemId())); } try { digester.parse(source); if (handler.getWarnings().size() > 0 || handler.getErrors().size() > 0) { ok = false; handler.logFindings(log, source.getSystemId()); } } catch (SAXParseException e) { log.error(sm.getString("webXmlParser.applicationParse", source.getSystemId()), e); log.error(sm.getString("webXmlParser.applicationPosition", "" + e.getLineNumber(), "" + e.getColumnNumber())); ok = false; } catch (Exception e) { log.error(sm.getString("webXmlParser.applicationParse", source.getSystemId()), e); ok = false; } finally { InputStream is = source.getByteStream(); if (is != null) { try { is.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } digester.reset(); ruleSet.recycle(); } return ok; }
private void doRun(SelectionKey key, KeyAttachment ka) { boolean launch = false; try { int handshake = -1; try { if (key != null) { if (socket.isHandshakeComplete()) { handshake = 0; } else { handshake = socket.handshake(key.isReadable(), key.isWritable()); // The handshake process reads/writes from/to the // socket. status may therefore be OPEN_WRITE once // the handshake completes. However, the handshake // happens when the socket is opened so the status // must always be OPEN_READ after it completes. It // is OK to always set this as it is only used if status = SocketStatus.OPEN_READ; } } } catch (IOException x) { handshake = -1; if (log.isDebugEnabled()) log.debug("Error during SSL handshake", x); } catch (CancelledKeyException ckx) { handshake = -1; } if (handshake == 0) { SocketState state = SocketState.OPEN; if (status == null) { state = handler.process(ka, SocketStatus.OPEN_READ); } else { state = handler.process(ka, status); } if (state == SocketState.CLOSED) { try { if (ka != null) ka.setComet(false); socket.getPoller().cancelledKey(key, SocketStatus.ERROR); if (running && !paused) { nioChannels.push(socket); } socket = null; if (running && !paused && ka != null) { keyCache.push(ka); } ka = null; } catch (Exception x) { log.error("", x); } } else if (state == SocketState.LONG && ka != null && ka.isAsync() && ka.interestOps() > 0) { ka.getPoller().add(socket, ka.interestOps()); } } else if (handshake == -1) { if (key != null) { socket.getPoller().cancelledKey(key, SocketStatus.DISCONNECT); } if (running && !paused) { nioChannels.push(socket); } socket = null; if (running && !paused && ka != null) { keyCache.push(ka); } ka = null; } else { ka.getPoller().add(socket, handshake); } } catch (CancelledKeyException cx) { socket.getPoller().cancelledKey(key, null); } catch (OutOfMemoryError oom) { try { oomParachuteData = null; log.error("", oom); if (socket != null) { socket.getPoller().cancelledKey(key, SocketStatus.ERROR); } releaseCaches(); } catch (Throwable oomt) { try { System.err.println(oomParachuteMsg); oomt.printStackTrace(); } catch (Throwable letsHopeWeDontGetHere) { ExceptionUtils.handleThrowable(letsHopeWeDontGetHere); } } } catch (Throwable t) { log.error("", t); if (socket != null) { socket.getPoller().cancelledKey(key, SocketStatus.ERROR); } } finally { if (launch) { try { getExecutor().execute(new SocketProcessor(socket, SocketStatus.OPEN_READ)); } catch (NullPointerException npe) { if (running) { log.error(sm.getString("endpoint.launch.fail"), npe); } } } socket = null; status = null; if (running && !paused) { processorCache.push(this); } } }	@Override public final SocketState upgradeDispatch(SocketStatus status) throws IOException { if (status == SocketStatus.OPEN_READ) { upgradeServletInputStream.onDataAvailable(); } else if (status == SocketStatus.OPEN_WRITE) { upgradeServletOutputStream.onWritePossible(); } else { return SocketState.CLOSED; } if (upgradeServletInputStream.isCloseRequired() || upgradeServletOutputStream.isCloseRequired()) { return SocketState.CLOSED; } return SocketState.UPGRADED; }
private void clearHandler(Throwable t) { SendHandler sh = handler; handler = null; if (t == null) { sh.onResult(new SendResult()); } else { sh.onResult(new SendResult(t)); } }	protected void onTimeout() { clearHandler(new SocketTimeoutException()); close(); }
private void prepareResponse() { boolean entityBody = true; contentDelimitation = false; OutputFilter[] outputFilters = getOutputBuffer().getFilters(); if (http09 == true) { getOutputBuffer().addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); return; } int statusCode = response.getStatus(); if (statusCode < 200 || statusCode == 204 || statusCode == 205 || statusCode == 304) { getOutputBuffer().addActiveFilter(outputFilters[Constants.VOID_FILTER]); entityBody = false; contentDelimitation = true; } MessageBytes methodMB = request.method(); if (methodMB.equals("HEAD")) { getOutputBuffer().addActiveFilter(outputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } boolean sendingWithSendfile = false; if (getEndpoint().getUseSendfile()) { sendingWithSendfile = prepareSendfile(outputFilters); } boolean isCompressable = false; boolean useCompression = false; if (entityBody && (compressionLevel > 0) && !sendingWithSendfile) { isCompressable = isCompressable(); if (isCompressable) { useCompression = useCompression(); } if (useCompression) { response.setContentLength(-1); } } MimeHeaders headers = response.getMimeHeaders(); if (!entityBody) { response.setContentLength(-1); } if (entityBody || statusCode == HttpServletResponse.SC_NO_CONTENT) { String contentType = response.getContentType(); if (contentType != null) { headers.setValue("Content-Type").setString(contentType); } String contentLanguage = response.getContentLanguage(); if (contentLanguage != null) { headers.setValue("Content-Language").setString(contentLanguage); } } long contentLength = response.getContentLengthLong(); boolean connectionClosePresent = false; if (contentLength != -1) { headers.setValue("Content-Length").setLong(contentLength); getOutputBuffer().addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } else { // If the response code supports an entity body and we're on connectionClosePresent = isConnectionClose(headers); if (entityBody && http11 && !connectionClosePresent) { getOutputBuffer().addActiveFilter(outputFilters[Constants.CHUNKED_FILTER]); contentDelimitation = true; headers.addValue(Constants.TRANSFERENCODING).setString(Constants.CHUNKED); } else { getOutputBuffer().addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); } } if (useCompression) { getOutputBuffer().addActiveFilter(outputFilters[Constants.GZIP_FILTER]); headers.setValue("Content-Encoding").setString("gzip"); } if (isCompressable) { MessageBytes vary = headers.getValue("Vary"); if (vary == null) { headers.setValue("Vary").setString("Accept-Encoding"); } else if (vary.equals("*")) { // No action required } else { headers.setValue("Vary").setString(vary.getString() + ",Accept-Encoding"); } } headers.setValue("Date").setString(FastHttpDateFormat.getCurrentDate()); if ((entityBody) && (!contentDelimitation)) { // Mark as close the connection after the request, and add the keepAlive = false; } // If we know that the request is bad this early, add the keepAlive = keepAlive && !statusDropsConnection(statusCode); if (!keepAlive) { if (!connectionClosePresent) { headers.addValue(Constants.CONNECTION).setString(Constants.CLOSE); } } else if (!http11 && !error) { headers.addValue(Constants.CONNECTION).setString(Constants.KEEPALIVE); } getOutputBuffer().sendStatus(); if (server != null) { headers.setValue("Server").setString(server); } else if (headers.getValue("Server") == null) { getOutputBuffer().write(Constants.SERVER_BYTES); } int size = headers.size(); for (int i = 0; i < size; i++) { getOutputBuffer().sendHeader(headers.getName(i), headers.getValue(i)); } getOutputBuffer().endHeaders(); }
@Override public void startElement(String uri, String localName, String qName, Attributes attrs) throws SAXException { AttributesImpl taglibAttrs = null; AttributesImpl nonTaglibAttrs = null; AttributesImpl nonTaglibXmlnsAttrs = null; processChars(); checkPrefixes(uri, qName, attrs); if (directivesOnly && !(JSP_URI.equals(uri) && localName.startsWith(DIRECTIVE_ACTION))) { return; } String currentPrefix = getPrefix(current.getQName()); if (JSP_URI.equals(uri) && TEXT_ACTION.equals(current.getLocalName()) && "jsp".equals(currentPrefix)) { throw new SAXParseException(Localizer.getMessage("jsp.error.text.has_subelement"), locator); } startMark = new Mark(ctxt, path, locator.getLineNumber(), locator.getColumnNumber()); if (attrs != null) { boolean isTaglib = false; for (int i = attrs.getLength() - 1; i >= 0; i--) { isTaglib = false; String attrQName = attrs.getQName(i); if (!attrQName.startsWith("xmlns")) { if (nonTaglibAttrs == null) { nonTaglibAttrs = new AttributesImpl(); } nonTaglibAttrs.addAttribute(attrs.getURI(i), attrs.getLocalName(i), attrs.getQName(i), attrs.getType(i), attrs.getValue(i)); } else { if (attrQName.startsWith("xmlns:jsp")) { isTaglib = true; } else { String attrUri = attrs.getValue(i); // TaglibInfo for this uri already established in isTaglib = pageInfo.hasTaglib(attrUri); } if (isTaglib) { if (taglibAttrs == null) { taglibAttrs = new AttributesImpl(); } taglibAttrs.addAttribute(attrs.getURI(i), attrs.getLocalName(i), attrs.getQName(i), attrs.getType(i), attrs.getValue(i)); } else { if (nonTaglibXmlnsAttrs == null) { nonTaglibXmlnsAttrs = new AttributesImpl(); } nonTaglibXmlnsAttrs.addAttribute(attrs.getURI(i), attrs.getLocalName(i), attrs.getQName(i), attrs.getType(i), attrs.getValue(i)); } } } } Node node = null; if (tagDependentPending && JSP_URI.equals(uri) && localName.equals(BODY_ACTION)) { tagDependentPending = false; tagDependentNesting++; current = parseStandardAction(qName, localName, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, startMark); return; } if (tagDependentPending && JSP_URI.equals(uri) && localName.equals(ATTRIBUTE_ACTION)) { current = parseStandardAction(qName, localName, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, startMark); return; } if (tagDependentPending) { tagDependentPending = false; tagDependentNesting++; } if (tagDependentNesting > 0) { node = new Node.UninterpretedTag(qName, localName, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, startMark, current); } else if (JSP_URI.equals(uri)) { node = parseStandardAction(qName, localName, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, startMark); } else { node = parseCustomAction(qName, localName, uri, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, startMark, current); if (node == null) { node = new Node.UninterpretedTag(qName, localName, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, startMark, current); } else { String bodyType = getBodyType((Node.CustomTag) node); if (scriptlessBodyNode == null && bodyType.equalsIgnoreCase(TagInfo.BODY_CONTENT_SCRIPTLESS)) { scriptlessBodyNode = node; } } } }
private void processWebDotXml() { if (ctxt.getMajorVersion() < 2) { defaultIsELIgnored = "true"; defaultDeferedSyntaxAllowedAsLiteral = "true"; return; } if (ctxt.getMajorVersion() == 2) { if (ctxt.getMinorVersion() < 5) { defaultDeferedSyntaxAllowedAsLiteral = "true"; } if (ctxt.getMinorVersion() < 4) { defaultIsELIgnored = "true"; return; } } JspConfigDescriptor jspConfig = ctxt.getJspConfigDescriptor(); if (jspConfig == null) { return; } Collection<JspPropertyGroupDescriptor> jspPropertyGroups = jspConfig.getJspPropertyGroups(); for (JspPropertyGroupDescriptor jspPropertyGroup : jspPropertyGroups) { Collection<String> urlPatterns = jspPropertyGroup.getUrlPatterns(); if (urlPatterns.size() == 0) { continue; } for (String urlPattern : urlPatterns) { String path = null; String extension = null; if (urlPattern.indexOf('*') < 0) { path = urlPattern; } else { int i = urlPattern.lastIndexOf('/'); String file; if (i >= 0) { path = urlPattern.substring(0, i + 1); file = urlPattern.substring(i + 1); } else { file = urlPattern; } if (file.equals("*")) { extension = "*"; } else if (file.startsWith("*.")) { extension = file.substring(file.indexOf('.') + 1); } // The url patterns are reconstructed as the following: // path != null, extension == null: / or /foo/bar.ext // path == null, extension != null: *.ext boolean isStar = "*".equals(extension); if ((path == null && (extension == null || isStar)) || (path != null && !isStar)) { if (log.isWarnEnabled()) { log.warn(Localizer.getMessage("jsp.warning.bad.urlpattern.propertygroup", urlPattern)); } continue; } } Vector<String> includePreludes = new Vector<>(); includePreludes.addAll(jspPropertyGroup.getIncludePreludes()); Vector<String> includeCodas = new Vector<>(); includeCodas.addAll(jspPropertyGroup.getIncludeCodas()); JspProperty property = new JspProperty(jspPropertyGroup.getIsXml(), jspPropertyGroup.getElIgnored(), jspPropertyGroup.getScriptingInvalid(), jspPropertyGroup.getPageEncoding(), includePreludes, includeCodas, jspPropertyGroup.getDeferredSyntaxAllowedAsLiteral(), jspPropertyGroup.getTrimDirectiveWhitespaces(), jspPropertyGroup.getDefaultContentType(), jspPropertyGroup.getBuffer(), jspPropertyGroup.getErrorOnUndeclaredNamespace()); JspPropertyGroup propertyGroup = new JspPropertyGroup(path, extension, property); jspProperties.addElement(propertyGroup); } } }
public EntityResolver getEntityResolver() { return entityResolver; }	@Override public InputSource resolveEntity(String publicId, String systemId) throws SAXException { if (saxLog.isDebugEnabled()) { saxLog.debug("resolveEntity('" + publicId + "', '" + systemId + "')"); } if (publicId != null) this.publicId = publicId; String entityURL = null; if (publicId != null) { entityURL = entityValidator.get(publicId); } if (entityURL == null) { if (systemId == null) { if (log.isDebugEnabled()) { log.debug(" Cannot resolve entity: '" + publicId + "'"); } return (null); } else { if (log.isDebugEnabled()) { log.debug(" Trying to resolve using system ID '" + systemId + "'"); } entityURL = systemId; } } if (log.isDebugEnabled()) { log.debug(" Resolving to alternate DTD '" + entityURL + "'"); } try { return (new InputSource(entityURL)); } catch (Exception e) { throw createSAXException(e); } }	public XMLReader getXMLReader() throws SAXException { if (reader == null) { reader = getParser().getXMLReader(); } reader.setDTDHandler(this); reader.setContentHandler(this); if (entityResolver == null) { reader.setEntityResolver(this); } else { reader.setEntityResolver(entityResolver); } reader.setErrorHandler(this); return reader; }	@Override public Set<String> addServletSecurity(ServletRegistration.Dynamic registration, ServletSecurityElement servletSecurityElement) { Set<String> conflicts = new HashSet<>(); Collection<String> urlPatterns = registration.getMappings(); for (String urlPattern : urlPatterns) { boolean foundConflict = false; SecurityConstraint[] securityConstraints = findConstraints(); for (SecurityConstraint securityConstraint : securityConstraints) { SecurityCollection[] collections = securityConstraint.findCollections(); for (SecurityCollection collection : collections) { if (collection.findPattern(urlPattern)) { if (collection.isFromDescriptor()) { foundConflict = true; conflicts.add(urlPattern); break; } else { collection.removePattern(urlPattern); if (collection.findPatterns().length == 0) { securityConstraint.removeCollection(collection); } } } } if (securityConstraint.findCollections().length == 0) { removeConstraint(securityConstraint); } if (foundConflict) { break; } } if (!foundConflict) { SecurityConstraint[] newSecurityConstraints = SecurityConstraint.createConstraints(servletSecurityElement, urlPattern); for (SecurityConstraint securityConstraint : newSecurityConstraints) { addConstraint(securityConstraint); } checkConstraintsForUncoveredMethods(newSecurityConstraints); } } return conflicts; }	public boolean isMetadataComplete() { return metadataComplete; }	public String getPublicId() { return publicId; }	@Test public void testParsePublicIdVersion22() { WebXml webxml = new WebXml(); webxml.setPublicId(org.apache.catalina.startup.Constants.WebDtdPublicId_22); Assert.assertEquals(2, webxml.getMajorVersion()); Assert.assertEquals(2, webxml.getMinorVersion()); Assert.assertEquals("2.2", webxml.getVersion()); }	@Test public void testParsePublicIdVersion23() { WebXml webxml = new WebXml(); webxml.setPublicId(org.apache.catalina.startup.Constants.WebDtdPublicId_23); Assert.assertEquals(2, webxml.getMajorVersion()); Assert.assertEquals(3, webxml.getMinorVersion()); Assert.assertEquals("2.3", webxml.getVersion()); }	@Test public void testParsePublicIdVersion24() { WebXml webxml = new WebXml(); webxml.setPublicId(org.apache.catalina.startup.Constants.WebSchemaPublicId_24); Assert.assertEquals(2, webxml.getMajorVersion()); Assert.assertEquals(4, webxml.getMinorVersion()); Assert.assertEquals("2.4", webxml.getVersion()); }	@Test public void testParsePublicIdVersion25() { WebXml webxml = new WebXml(); webxml.setPublicId(org.apache.catalina.startup.Constants.WebSchemaPublicId_25); Assert.assertEquals(2, webxml.getMajorVersion()); Assert.assertEquals(5, webxml.getMinorVersion()); Assert.assertEquals("2.5", webxml.getVersion()); }	@Test public void testParsePublicIdVersion30() { WebXml webxml = new WebXml(); webxml.setPublicId(org.apache.catalina.startup.Constants.WebSchemaPublicId_30); Assert.assertEquals(3, webxml.getMajorVersion()); Assert.assertEquals(0, webxml.getMinorVersion()); Assert.assertEquals("3.0", webxml.getVersion()); }	@Test public void testParsePublicIdVersion31() { WebXml webxml = new WebXml(); webxml.setPublicId(org.apache.catalina.startup.Constants.WebSchemaPublicId_31); Assert.assertEquals(3, webxml.getMajorVersion()); Assert.assertEquals(1, webxml.getMinorVersion()); Assert.assertEquals("3.1", webxml.getVersion()); }	public void testParseVersion() { WebXml webxml = new WebXml(); Assert.assertEquals(3, webxml.getMajorVersion()); Assert.assertEquals(0, webxml.getMinorVersion()); webxml.setVersion("2.5"); Assert.assertEquals(2, webxml.getMajorVersion()); Assert.assertEquals(5, webxml.getMinorVersion()); webxml.setVersion("0.0"); Assert.assertEquals(0, webxml.getMajorVersion()); Assert.assertEquals(0, webxml.getMinorVersion()); webxml.setVersion(null); Assert.assertEquals(0, webxml.getMajorVersion()); Assert.assertEquals(0, webxml.getMinorVersion()); webxml.setVersion("3"); Assert.assertEquals(3, webxml.getMajorVersion()); Assert.assertEquals(0, webxml.getMinorVersion()); // no minor digit webxml.setVersion("0.0"); webxml.setVersion("3."); Assert.assertEquals(3, webxml.getMajorVersion()); Assert.assertEquals(0, webxml.getMinorVersion()); // minor only webxml.setVersion("0.0"); webxml.setVersion(".5"); Assert.assertEquals(0, webxml.getMajorVersion()); Assert.assertEquals(5, webxml.getMinorVersion()); // leading & training zeros webxml.setVersion("0.0"); webxml.setVersion("002.500"); Assert.assertEquals(2, webxml.getMajorVersion()); Assert.assertEquals(500, webxml.getMinorVersion()); }


protected ServletContainerInitializer getServletContainerInitializer(InputStream is) throws IOException { String className = null; if (is != null) { String line = null; try { BufferedReader br = new BufferedReader(new InputStreamReader(is, "UTF-8")); line = br.readLine(); if (line != null && line.trim().length() > 0) { className = line.trim(); } } catch (UnsupportedEncodingException e) { // Should never happen with UTF-8 // If it does - ignore & return null } } ServletContainerInitializer sci = null; try { Class<?> clazz = Class.forName(className, true, context.getLoader().getClassLoader()); sci = (ServletContainerInitializer) clazz.newInstance(); } catch (ClassNotFoundException e) { log.error(sm.getString("contextConfig.invalidSci", className), e); throw new IOException(e); } catch (InstantiationException e) { log.error(sm.getString("contextConfig.invalidSci", className), e); throw new IOException(e); } catch (IllegalAccessException e) { log.error(sm.getString("contextConfig.invalidSci", className), e); throw new IOException(e); } return sci; }	protected void processServletContainerInitializers(Set<WebXml> fragments) { for (WebXml fragment : fragments) { URL url = fragment.getURL(); Jar jar = null; InputStream is = null; ServletContainerInitializer sci = null; try { if ("jar".equals(url.getProtocol())) { jar = JarFactory.newInstance(url); is = jar.getInputStream(SCI_LOCATION); } else if ("file".equals(url.getProtocol())) { String path = url.getPath(); File file = new File(path, SCI_LOCATION); if (file.exists()) { is = new FileInputStream(file); } } if (is != null) { sci = getServletContainerInitializer(is); } } catch (IOException ioe) { log.error(sm.getString("contextConfig.servletContainerInitializerFail", url, context.getName())); ok = false; return; } finally { if (is != null) { try { is.close(); } catch (IOException e) { // Ignore } } if (jar != null) { jar.close(); } } if (sci == null) { continue; } initializerClassMap.put(sci, new HashSet<Class<?>>()); HandlesTypes ht = null; try { ht = sci.getClass().getAnnotation(HandlesTypes.class); } catch (Exception e) { if (log.isDebugEnabled()) { log.info(sm.getString("contextConfig.sci.debug", url), e); } else { log.info(sm.getString("contextConfig.sci.info", url)); } } if (ht != null) { Class<?>[] types = ht.value(); if (types != null) { for (Class<?> type : types) { if (type.isAnnotation()) { handlesTypesAnnotations = true; } else { handlesTypesNonAnnotations = true; } Set<ServletContainerInitializer> scis = typeInitializerMap.get(type); if (scis == null) { scis = new HashSet<>(); typeInitializerMap.put(type, scis); } scis.add(sci); } } } } }
@Override public void run() { long written = 0; try { for (int i = offset; i < offset + length; i++) { ByteBuffer src = srcs[i]; while (src.hasRemaining()) { socketWriteBuffer.clear(); SSLEngineResult r = sslEngine.wrap(src, socketWriteBuffer); written += r.bytesConsumed(); Status s = r.getStatus(); if (s == Status.OK || s == Status.BUFFER_OVERFLOW) { // Need to write out the bytes and may need to read from // the source again to empty it } else { throw new IllegalStateException(sm.getString("asyncChannelWrapperSecure.statusWrap")); } if (r.getHandshakeStatus() == HandshakeStatus.NEED_TASK) { Runnable runnable = sslEngine.getDelegatedTask(); while (runnable != null) { runnable.run(); runnable = sslEngine.getDelegatedTask(); } } socketWriteBuffer.flip(); Future<Integer> f = socketChannel.write(socketWriteBuffer); Integer socketWrite = f.get(); if (socketWrite.intValue() != r.bytesProduced()) { throw new IOException(sm.getString("asyncChannelWrapperSecure.writeFail", Integer.valueOf(socketWrite.intValue()), Integer.valueOf(r.bytesProduced()))); } } } if (writing.compareAndSet(true, false)) { future.complete(Long.valueOf(written)); } else { future.fail(new IllegalStateException(sm.getString("asyncChannelWrapperSecure.wrongStateWrite"))); } } catch (Exception e) { future.fail(e); } }
public void recycle() { bytesRead = 0; contentLength = -1; contentTypeMB = null; charEncoding = null; headers.recycle(); serverNameMB.recycle(); serverPort = -1; localPort = -1; remotePort = -1; available = 0; cookies.recycle(); parameters.recycle(); unparsedURIMB.recycle(); uriMB.recycle(); decodedUriMB.recycle(); queryMB.recycle(); methodMB.recycle(); protoMB.recycle(); schemeMB.recycle(); instanceId.recycle(); remoteUser.recycle(); authType.recycle(); attributes.clear(); listener = null; startTime = -1; }
private static Object[] buildArgs(PojoPathParam[] pathParams, Map<String, String> pathParameters, Session session, EndpointConfig config, Throwable throwable, CloseReason closeReason) throws DecodeException { Object[] result = new Object[pathParams.length]; for (int i = 0; i < pathParams.length; i++) { Class<?> type = pathParams[i].getType(); if (type.equals(Session.class)) { result[i] = session; } else if (type.equals(EndpointConfig.class)) { result[i] = config; } else if (type.equals(Throwable.class)) { result[i] = throwable; } else if (type.equals(CloseReason.class)) { result[i] = closeReason; } else { String name = pathParams[i].getName(); String value = pathParameters.get(name); try { result[i] = Util.coerceToType(type, value); } catch (Exception e) { throw new DecodeException(value, sm.getString("pojoMethodMapping.decodePathParamFail", value, type), e); } } } return result; }
private void parseHeaders(String line, Map<String, List<String>> headers) { int index = line.indexOf(':'); if (index == -1) { log.warn(sm.getString("wsWebSocketContainer.invalidHeader", line)); return; } String headerName = line.substring(0, index).trim().toLowerCase(); String headerValue = line.substring(index + 1).trim(); List<String> values = headers.get(headerName); if (values == null) { values = new ArrayList<>(1); headers.put(headerName, values); } values.add(headerValue); }	@Override public Session connectToServer(Endpoint endpoint, ClientEndpointConfig clientEndpointConfiguration, URI path) throws DeploymentException { boolean secure = false; String scheme = path.getScheme(); if (!("ws".equalsIgnoreCase(scheme) || "wss".equalsIgnoreCase(scheme))) { throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme", scheme)); } String host = path.getHost(); if (host == null) { throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost")); } int port = path.getPort(); Map<String, List<String>> reqHeaders = createRequestHeaders(host, port, clientEndpointConfiguration.getPreferredSubprotocols(), clientEndpointConfiguration.getExtensions()); clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders); ByteBuffer request = createRequest(path, reqHeaders); SocketAddress sa; if (port == -1) { if ("ws".equalsIgnoreCase(scheme)) { sa = new InetSocketAddress(host, 80); } else if ("wss".equalsIgnoreCase(scheme)) { sa = new InetSocketAddress(host, 443); secure = true; } else { throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidScheme")); } } else { if ("wss".equalsIgnoreCase(scheme)) { secure = true; } sa = new InetSocketAddress(host, port); } AsynchronousSocketChannel socketChannel; try { socketChannel = AsynchronousSocketChannel.open(asynchronousChannelGroup); } catch (IOException ioe) { throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"), ioe); } Future<Void> fConnect = socketChannel.connect(sa); AsyncChannelWrapper channel; if (secure) { SSLEngine sslEngine = createSSLEngine(clientEndpointConfiguration.getUserProperties()); channel = new AsyncChannelWrapperSecure(socketChannel, sslEngine); } else { channel = new AsyncChannelWrapperNonSecure(socketChannel); } ByteBuffer response; String subProtocol; try { fConnect.get(); Future<Void> fHandshake = channel.handshake(); fHandshake.get(); int toWrite = request.limit(); Future<Integer> fWrite = channel.write(request); Integer thisWrite = fWrite.get(); toWrite -= thisWrite.intValue(); while (toWrite > 0) { fWrite = channel.write(request); thisWrite = fWrite.get(); toWrite -= thisWrite.intValue(); } response = ByteBuffer.allocate(maxBinaryMessageBufferSize); HandshakeResponse handshakeResponse = processResponse(response, channel); clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse); List<String> values = handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME); if (values == null || values.size() == 0) { subProtocol = null; } else if (values.size() == 1) { subProtocol = values.get(0); } else { throw new DeploymentException(sm.getString("Sec-WebSocket-Protocol")); } } catch (ExecutionException | InterruptedException | SSLException | EOFException e) { throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"), e); } WsRemoteEndpointImplClient wsRemoteEndpointClient = new WsRemoteEndpointImplClient(channel); WsSession wsSession = new WsSession(endpoint, wsRemoteEndpointClient, this, null, null, null, null, null, subProtocol, Collections.EMPTY_MAP, false, clientEndpointConfiguration); endpoint.onOpen(wsSession, clientEndpointConfiguration); registerSession(endpoint, wsSession); @SuppressWarnings("unused") WsFrameClient wsFrameClient = new WsFrameClient(response, channel, wsSession); return wsSession; }
@Override public void addEndpoint(Class<?> pojo) throws DeploymentException { ServerEndpoint annotation = pojo.getAnnotation(ServerEndpoint.class); if (annotation == null) { throw new DeploymentException(sm.getString("serverContainer.missingAnnotation", pojo.getName())); } String path = annotation.value(); validateEncoders(annotation.encoders()); PojoMethodMapping methodMapping = new PojoMethodMapping(pojo, annotation.decoders(), path); ServerEndpointConfig sec; Class<? extends Configurator> configuratorClazz = annotation.configurator(); Configurator configurator = null; if (!configuratorClazz.equals(Configurator.class)) { try { configurator = annotation.configurator().newInstance(); } catch (InstantiationException | IllegalAccessException e) { throw new DeploymentException(sm.getString("serverContainer.configuratorFail", annotation.configurator().getName(), pojo.getClass().getName()), e); } } sec = ServerEndpointConfig.Builder.create(pojo, path).decoders(Arrays.asList(annotation.decoders())).encoders(Arrays.asList(annotation.encoders())).configurator(configurator).build(); sec.getUserProperties().put(PojoEndpointServer.POJO_METHOD_MAPPING_KEY, methodMapping); addEndpoint(sec); }

@Override public SocketState process(SocketWrapper<S> socketWrapper) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); setSocketWrapper(socketWrapper); getInputBuffer().init(socketWrapper, endpoint); getOutputBuffer().init(socketWrapper, endpoint); error = false; keepAlive = true; comet = false; openSocket = false; sendfileInProgress = false; readComplete = true; if (endpoint.getUsePolling()) { keptAlive = false; } else { keptAlive = socketWrapper.isKeptAlive(); } if (disableKeepAlive()) { socketWrapper.setKeepAliveLeft(0); } while (!error && keepAlive && !comet && !isAsync() && httpUpgradeHandler == null && !endpoint.isPaused()) { try { setRequestLineReadTimeout(); if (!getInputBuffer().parseRequestLine(keptAlive)) { if (handleIncompleteRequestLineRead()) { break; } } if (endpoint.isPaused()) { response.setStatus(503); error = true; } else { if (request.getStartTime() < 0) { request.setStartTime(System.currentTimeMillis()); } keptAlive = true; request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount()); if (!getInputBuffer().parseHeaders()) { // We've read part of the request, don't recycle it openSocket = true; readComplete = false; break; } if (!disableUploadTimeout) { setSocketTimeout(connectionUploadTimeout); } } } catch (IOException e) { if (getLog().isDebugEnabled()) { getLog().debug(sm.getString("http11processor.header.parse"), e); } error = true; break; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); UserDataHelper.Mode logMode = userDataHelper.getNextMode(); if (logMode != null) { String message = sm.getString("http11processor.header.parse"); switch(logMode) { case INFO_THEN_DEBUG: message += sm.getString("http11processor.fallToDebug"); case INFO: getLog().info(message); break; case DEBUG: getLog().debug(message); } } response.setStatus(400); getAdapter().log(request, response, 0); error = true; } if (!error) { rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); if (getLog().isDebugEnabled()) { getLog().debug(sm.getString("http11processor.request.prepare"), t); } response.setStatus(400); getAdapter().log(request, response, 0); error = true; } } if (maxKeepAliveRequests == 1) { keepAlive = false; } else if (maxKeepAliveRequests > 0 && socketWrapper.decrementKeepAlive() <= 0) { keepAlive = false; } if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); getAdapter().service(request, response); if (keepAlive && !error) { error = response.getErrorException() != null || (!isAsync() && statusDropsConnection(response.getStatus())); } setCometTimeouts(socketWrapper); } catch (InterruptedIOException e) { error = true; } catch (HeadersTooLargeException e) { error = true; if (!response.isCommitted()) { response.reset(); response.setStatus(500); response.setHeader("Connection", "close"); } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getLog().error(sm.getString("http11processor.request.process"), t); response.setStatus(500); getAdapter().log(request, response, 0); error = true; } } rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT); if (!isAsync() && !comet) { if (error) { // If we know we are closing the connection, don't drain // input. This way uploading a 100GB file doesn't tie up the getInputBuffer().setSwallowInput(false); } endRequest(); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT); if (error) { response.setStatus(500); } request.updateCounters(); if (!isAsync() && !comet || error) { getInputBuffer().nextRequest(); getOutputBuffer().nextRequest(); } if (!disableUploadTimeout) { setSocketTimeout(endpoint.getSoTimeout()); } rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); if (breakKeepAliveLoop(socketWrapper)) { break; } } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (error || endpoint.isPaused()) { return SocketState.CLOSED; } else if (isAsync() || comet) { return SocketState.LONG; } else if (isUpgrade()) { return SocketState.UPGRADING; } else { if (sendfileInProgress) { return SocketState.SENDFILE; } else { if (openSocket) { if (readComplete) { return SocketState.OPEN; } else { return SocketState.LONG; } } else { return SocketState.CLOSED; } } } }
private boolean processDataControl() throws IOException { if (!appendPayloadToMessage(controlBufferBinary)) { return false; } controlBufferBinary.flip(); if (opCode == Constants.OPCODE_CLOSE) { open = false; String reason = null; int code = CloseCodes.NORMAL_CLOSURE.getCode(); if (controlBufferBinary.remaining() == 1) { controlBufferBinary.clear(); throw new WsIOException(new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.oneByteCloseCode"))); } if (controlBufferBinary.remaining() > 1) { code = controlBufferBinary.getShort(); if (controlBufferBinary.remaining() > 0) { CoderResult cr = utf8DecoderControl.decode(controlBufferBinary, controlBufferText, true); if (cr.isError()) { controlBufferBinary.clear(); controlBufferText.clear(); throw new WsIOException(new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.invalidUtf8Close"))); } // There will be no overflow as the output buffer is big // enough. There will be no underflow as all the data is controlBufferText.flip(); reason = controlBufferText.toString(); } } wsSession.onClose(new CloseReason(Util.getCloseCode(code), reason)); } else if (opCode == Constants.OPCODE_PING) { if (wsSession.isOpen()) { wsSession.getBasicRemote().sendPong(controlBufferBinary); } } else if (opCode == Constants.OPCODE_PONG) { MessageHandler.Whole<PongMessage> mhPong = wsSession.getPongMessageHandler(); if (mhPong != null) { mhPong.onMessage(new WsPongMessage(controlBufferBinary)); } } else { controlBufferBinary.clear(); throw new WsIOException(new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.invalidOpCode", Integer.valueOf(opCode)))); } controlBufferBinary.clear(); newFrame(); return true; }	@SuppressWarnings("unchecked") private void sendMessageBinary(ByteBuffer msg, boolean last) throws WsIOException { MessageHandler mh = wsSession.getBinaryMessageHandler(); if (mh != null) { if (mh instanceof WrappedMessageHandler) { long maxMessageSize = ((WrappedMessageHandler) mh).getMaxMessageSize(); if (maxMessageSize > -1 && msg.remaining() > maxMessageSize) { throw new WsIOException(new CloseReason(CloseCodes.TOO_BIG, sm.getString("wsFrame.messageTooBig", Long.valueOf(msg.remaining()), Long.valueOf(maxMessageSize)))); } } if (mh instanceof MessageHandler.Partial<?>) { ((MessageHandler.Partial<ByteBuffer>) mh).onMessage(msg, last); } else { ((MessageHandler.Whole<ByteBuffer>) mh).onMessage(msg); } } }	@SuppressWarnings("unchecked") private void sendMessageText(boolean last) throws WsIOException { MessageHandler mh = wsSession.getTextMessageHandler(); if (mh != null) { if (mh instanceof WrappedMessageHandler) { long maxMessageSize = ((WrappedMessageHandler) mh).getMaxMessageSize(); if (maxMessageSize > -1 && messageBufferText.remaining() > maxMessageSize) { throw new WsIOException(new CloseReason(CloseCodes.TOO_BIG, sm.getString("wsFrame.messageTooBig", Long.valueOf(messageBufferText.remaining()), Long.valueOf(maxMessageSize)))); } } if (mh instanceof MessageHandler.Partial<?>) { ((MessageHandler.Partial<String>) mh).onMessage(messageBufferText.toString(), last); } else { ((MessageHandler.Whole<String>) mh).onMessage(messageBufferText.toString()); } messageBufferText.clear(); } }

@Override protected void setRequestLineReadTimeout() throws IOException { if (inputBuffer.lastValid == 0 && socket.getLastAccess() > -1) { int firstReadTimeout; if (keepAliveTimeout == -1) { firstReadTimeout = 0; } else { long queueTime = System.currentTimeMillis() - socket.getLastAccess(); if (queueTime >= keepAliveTimeout) { // Queued for longer than timeout but there might be firstReadTimeout = 1; } else { // Cast is safe since queueTime must be less than firstReadTimeout = keepAliveTimeout - (int) queueTime; } } socket.getSocket().setSoTimeout(firstReadTimeout); if (!inputBuffer.fill(true)) { throw new EOFException(sm.getString("iib.eof.error")); } // Once the first byte has been read, the standard timeout should be socket.getSocket().setSoTimeout(endpoint.getSoTimeout()); } }
protected Principal authenticate(String username, CallbackHandler callbackHandler) { try { LoginContext loginContext = null; if (appName == null) appName = "Tomcat"; if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.beginLogin", username, appName)); ClassLoader ocl = null; if (!isUseContextClassLoader()) { ocl = Thread.currentThread().getContextClassLoader(); Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); } try { loginContext = new LoginContext(appName, callbackHandler); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); log.error(sm.getString("jaasRealm.unexpectedError"), e); return (null); } finally { if (!isUseContextClassLoader()) { Thread.currentThread().setContextClassLoader(ocl); } } if (log.isDebugEnabled()) log.debug("Login context created " + username); Subject subject = null; try { loginContext.login(); subject = loginContext.getSubject(); if (subject == null) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.failedLogin", username)); return (null); } } catch (AccountExpiredException e) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.accountExpired", username)); return (null); } catch (CredentialExpiredException e) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.credentialExpired", username)); return (null); } catch (FailedLoginException e) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.failedLogin", username)); return (null); } catch (LoginException e) { log.warn(sm.getString("jaasRealm.loginException", username), e); return (null); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); log.error(sm.getString("jaasRealm.unexpectedError"), e); return (null); } if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.loginContextCreated", username)); Principal principal = createPrincipal(username, subject, loginContext); if (principal == null) { log.debug(sm.getString("jaasRealm.authenticateFailure", username)); return (null); } if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.authenticateSuccess", username)); } return (principal); } catch (Throwable t) { log.error("error ", t); return null; } }	@Override protected void startInternal() throws LifecycleException { // These need to be called after loading configuration, in case parseClassNames(userClassNames, userClasses); parseClassNames(roleClassNames, roleClasses); super.startInternal(); }
private int readSocket(boolean timeout, boolean block) throws IOException { int nRead = 0; socket.getBufHandler().getReadBuffer().clear(); if (block) { Selector selector = null; try { selector = pool.get(); } catch (IOException x) { // Ignore } try { NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment) socket.getAttachment(false); if (att == null) throw new IOException("Key must be cancelled."); nRead = pool.read(socket.getBufHandler().getReadBuffer(), socket, selector, att.getTimeout()); } catch (EOFException eof) { nRead = -1; } finally { if (selector != null) pool.put(selector); } } else { nRead = socket.read(socket.getBufHandler().getReadBuffer()); } if (nRead > 0) { socket.getBufHandler().getReadBuffer().flip(); socket.getBufHandler().getReadBuffer().limit(nRead); expand(nRead + pos); socket.getBufHandler().getReadBuffer().get(buf, pos, nRead); lastValid = pos + nRead; return nRead; } else if (nRead == -1) { throw new EOFException(sm.getString("iib.eof.error")); } else { return 0; } }
private void mergeParameters() { if ((queryParamString == null) || (queryParamString.length() < 1)) return; HashMap<String, String[]> queryParameters = new HashMap<>(); String encoding = getCharacterEncoding(); if (encoding == null) encoding = "ISO-8859-1"; RequestUtil.parseParameters(queryParameters, queryParamString, encoding); Iterator<String> keys = parameters.keySet().iterator(); while (keys.hasNext()) { String key = keys.next(); Object value = queryParameters.get(key); if (value == null) { queryParameters.put(key, parameters.get(key)); continue; } queryParameters.put(key, mergeValues(value, parameters.get(key))); } parameters = queryParameters; }
protected String getPartialServletStackTrace(Throwable t) { StringBuilder trace = new StringBuilder(); trace.append(t.toString()).append('\n'); StackTraceElement[] elements = t.getStackTrace(); int pos = elements.length; for (int i = 0; i < elements.length; i++) { if ((elements[i].getClassName().startsWith("org.apache.catalina.core.ApplicationFilterChain")) && (elements[i].getMethodName().equals("internalDoFilter"))) { pos = i; } } for (int i = 0; i < pos; i++) { if (!(elements[i].getClassName().startsWith("org.apache.catalina.core."))) { trace.append('\t').append(elements[i].toString()).append('\n'); } } return trace.toString(); }
private JMXConnectorServer createServer(String serverName, int theRmiRegistryPort, int theRmiServerPort, HashMap<String, Object> theEnv, MBeanServer theMBeanServer) { try { LocateRegistry.createRegistry(theRmiRegistryPort); } catch (RemoteException e) { log.error(sm.getString("jmxRemoteLifecycleListener.createRegistryFailed", serverName, Integer.toString(theRmiRegistryPort)), e); return null; } StringBuilder url = new StringBuilder(); url.append("service:jmx:rmi://localhost:"); url.append(theRmiServerPort); url.append("/jndi/rmi://localhost:"); url.append(theRmiRegistryPort); url.append("/jmxrmi"); JMXServiceURL serviceUrl; try { serviceUrl = new JMXServiceURL(url.toString()); } catch (MalformedURLException e) { log.error(sm.getString("jmxRemoteLifecycleListener.invalidURL", serverName, url.toString()), e); return null; } JMXConnectorServer cs = null; try { cs = JMXConnectorServerFactory.newJMXConnectorServer(serviceUrl, theEnv, theMBeanServer); cs.start(); log.info(sm.getString("jmxRemoteLifecycleListener.start", Integer.toString(theRmiRegistryPort), Integer.toString(theRmiServerPort), serverName)); } catch (IOException e) { log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed", serverName), e); } return cs; }	private void destroyServer(String serverName, JMXConnectorServer theConnectorServer) { if (theConnectorServer != null) { try { theConnectorServer.stop(); } catch (IOException e) { log.error(sm.getString("jmxRemoteLifecycleListener.destroyServerFailed", serverName), e); } } }	@Override public Socket createSocket(String host, int port) throws IOException { if (factory == null) { return new Socket(FORCED_HOST, port); } else { return factory.createSocket(FORCED_HOST, port); } }	@Override public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.START_EVENT == event.getType()) { init(); System.setProperty("java.rmi.server.randomIDs", "true"); HashMap<String, Object> env = new HashMap<>(); RMIClientSocketFactory csf = null; RMIServerSocketFactory ssf = null; if (rmiSSL) { csf = new SslRMIClientSocketFactory(); ssf = new SslRMIServerSocketFactory(ciphers, protocols, clientAuth); } if (useLocalPorts) { csf = new RmiClientLocalhostSocketFactory(csf); } if (csf != null) { env.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE, csf); } if (ssf != null) { env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, ssf); } if (authenticate) { env.put("jmx.remote.x.password.file", passwordFile); env.put("jmx.remote.x.access.file", accessFile); env.put("jmx.remote.x.login.config", loginModuleName); } csPlatform = createServer("Platform", rmiRegistryPortPlatform, rmiServerPortPlatform, env, ManagementFactory.getPlatformMBeanServer()); } else if (Lifecycle.STOP_EVENT == event.getType()) { destroyServer("Platform", csPlatform); } }
@Override public ByteBuffer encode(MsgByte msg) throws EncodeException { byte[] data = msg.getData(); ByteBuffer reply = ByteBuffer.allocate(2 + data.length); reply.put((byte) 0x12); reply.put((byte) 0x34); reply.put(data); return reply; }	@Override public MsgByte decode(ByteBuffer bb) throws DecodeException { MsgByte result = new MsgByte(); bb.position(bb.position() + 2); byte[] data = new byte[bb.limit() - bb.position()]; bb.get(data); result.setData(data); return result; }	@Override public void onMessage(MsgString in) { received.add(in); try { MsgString msg = new MsgString(); msg.setData(MESSAGE_ONE); session.getBasicRemote().sendObject(msg); } catch (IOException | EncodeException e) { e.printStackTrace(); } }	public void testProgrammaticEndPoints() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(new ApplicationListener(ProgramaticServerEndpointConfig.class.getName(), false)); Tomcat.addServlet(ctx, "default", new DefaultServlet()); ctx.addServletMapping("/", "default"); WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); tomcat.start(); Client client = new Client(); URI uri = new URI("ws://localhost:" + getPort() + PATH_PROGRAMMATIC_EP); Session session = wsContainer.connectToServer(client, uri); MsgString msg1 = new MsgString(); msg1.setData(MESSAGE_ONE); session.getBasicRemote().sendObject(msg1); int i = 0; while (i < 20) { if (MsgStringMessageHandler.received.size() > 0 && client.received.size() > 0) { break; } Thread.sleep(100); i++; } Assert.assertEquals(1, MsgStringMessageHandler.received.size()); Assert.assertEquals(1, client.received.size()); Assert.assertEquals(MESSAGE_ONE, ((MsgString) MsgStringMessageHandler.received.peek()).getData()); Assert.assertEquals(MESSAGE_ONE, ((MsgString) client.received.peek()).getData()); session.close(); }
protected AccessLogElement createAccessLogElement(char pattern) { switch(pattern) { case 'a': return new RemoteAddrElement(); case 'A': return new LocalAddrElement(); case 'b': return new ByteSentElement(true); case 'B': return new ByteSentElement(false); case 'D': return new ElapsedTimeElement(true); case 'h': return new HostElement(); case 'H': return new ProtocolElement(); case 'l': return new LogicalUserNameElement(); case 'm': return new MethodElement(); case 'p': return new LocalPortElement(); case 'q': return new QueryElement(); case 'r': return new RequestElement(); case 's': return new HttpStatusCodeElement(); case 'S': return new SessionIdElement(); case 't': return new DateAndTimeElement(); case 'T': return new ElapsedTimeElement(false); case 'u': return new UserElement(); case 'U': return new RequestURIElement(); case 'v': return new LocalServerNameElement(); case 'I': return new ThreadNameElement(); default: return new StringElement("???" + pattern + "???"); } }	protected AccessLogElement[] createLogElements() { List<AccessLogElement> list = new ArrayList<>(); boolean replace = false; StringBuilder buf = new StringBuilder(); for (int i = 0; i < pattern.length(); i++) { char ch = pattern.charAt(i); if (replace) { if ('{' == ch) { StringBuilder name = new StringBuilder(); int j = i + 1; for (; j < pattern.length() && '}' != pattern.charAt(j); j++) { name.append(pattern.charAt(j)); } if (j + 1 < pattern.length()) { j++; list.add(createAccessLogElement(name.toString(), pattern.charAt(j))); i = j; /* Since we walked more than one character */ } else { // D'oh - end of string - pretend we never did this list.add(createAccessLogElement(ch)); } } else { list.add(createAccessLogElement(ch)); } replace = false; } else if (ch == '%') { replace = true; list.add(new StringElement(buf.toString())); buf = new StringBuilder(); } else { buf.append(ch); } } if (buf.length() > 0) { list.add(new StringElement(buf.toString())); } return list.toArray(new AccessLogElement[0]); }	public void recycle() { contentType = null; contentLanguage = null; locale = DEFAULT_LOCALE; characterEncoding = Constants.DEFAULT_CHARACTER_ENCODING; charsetSet = false; contentLength = -1; status = 200; message = null; commited = false; errorException = null; headers.clear(); listener = null; contentWritten = 0; }	public void sendHeaders() { action(ActionCode.COMMIT, this); commited = true; }	public void setCommitted(boolean v) { this.commited = v; }
@Override protected void stopInternal() throws LifecycleException { synchronized (connectorsLock) { for (Connector connector : connectors) { try { connector.pause(); } catch (Exception e) { log.error(sm.getString("standardService.connector.pauseFailed", connector), e); } } } if (log.isInfoEnabled()) log.info(sm.getString("standardService.stop.name", this.name)); setState(LifecycleState.STOPPING); if (container != null) { synchronized (container) { container.stop(); } } synchronized (connectorsLock) { for (Connector connector : connectors) { if (!LifecycleState.STARTED.equals(connector.getState())) { continue; } try { connector.stop(); } catch (Exception e) { log.error(sm.getString("standardService.connector.stopFailed", connector), e); } } } mapperListener.stop(); synchronized (executors) { for (Executor executor : executors) { executor.stop(); } } }	public void start() { if (getServer() == null) { load(); } if (getServer() == null) { log.fatal("Cannot start server. Server instance is not configured."); return; } long t1 = System.nanoTime(); try { getServer().start(); } catch (LifecycleException e) { log.error("Catalina.start: ", e); } long t2 = System.nanoTime(); if (log.isInfoEnabled()) { log.info("Server startup in " + ((t2 - t1) / 1000000) + " ms"); } if (useShutdownHook) { if (shutdownHook == null) { shutdownHook = new CatalinaShutdownHook(); } Runtime.getRuntime().addShutdownHook(shutdownHook); // If JULI is being used, disable JULI's shutdown hook since // shutdown hooks run in parallel and log messages may be lost LogManager logManager = LogManager.getLogManager(); if (logManager instanceof ClassLoaderLogManager) { ((ClassLoaderLogManager) logManager).setUseShutdownHook(false); } } if (await) { await(); stop(); } }
private Encoder findEncoder(Object obj) { for (EncoderEntry entry : encoderEntries) { if (entry.getClazz().isAssignableFrom(obj.getClass())) { return entry.getEncoder(); } } return null; }	@Override protected void doWrite(SendHandler handler, ByteBuffer... data) { long timeout = getSendTimeout(); if (timeout < 1) { timeout = Long.MAX_VALUE; } SendHandlerToCompletionHandler sh2ch = new SendHandlerToCompletionHandler(handler); channel.write(data, 0, data.length, timeout, TimeUnit.MILLISECONDS, null, sh2ch); }	protected void setEncoders(List<Class<? extends Encoder>> encoders) throws DeploymentException { encoderEntries.clear(); for (Class<? extends Encoder> encoderClazz : encoders) { Encoder instance; try { instance = encoderClazz.newInstance(); } catch (InstantiationException | IllegalAccessException e) { throw new DeploymentException(sm.getString("wsRemoteEndpoint.invalidEncoder", encoderClazz.getName()), e); } EncoderEntry entry = new EncoderEntry(Util.getEncoderType(encoderClazz), instance); encoderEntries.add(entry); } }	protected void setSession(WsSession wsSession) { this.wsSession = wsSession; }	@OnMessage public MsgByte rx(MsgByte in) { received.add(in); return in; }	@Override public Session connectToServer(Endpoint endpoint, ClientEndpointConfig clientEndpointConfiguration, URI path) throws DeploymentException { boolean secure = false; String scheme = path.getScheme(); if (!("ws".equalsIgnoreCase(scheme) || "wss".equalsIgnoreCase(scheme))) { throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme", scheme)); } String host = path.getHost(); if (host == null) { throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost")); } int port = path.getPort(); Map<String, List<String>> reqHeaders = createRequestHeaders(host, port, clientEndpointConfiguration.getPreferredSubprotocols()); clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders); ByteBuffer request = createRequest(path, reqHeaders); SocketAddress sa; if (port == -1) { if ("ws".equalsIgnoreCase(scheme)) { sa = new InetSocketAddress(host, 80); } else if ("wss".equalsIgnoreCase(scheme)) { sa = new InetSocketAddress(host, 443); secure = true; } else { throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidScheme")); } } else { if ("wss".equalsIgnoreCase(scheme)) { secure = true; } sa = new InetSocketAddress(host, port); } AsynchronousSocketChannel socketChannel; try { socketChannel = AsynchronousSocketChannel.open(asynchronousChannelGroup); } catch (IOException ioe) { throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"), ioe); } Future<Void> fConnect = socketChannel.connect(sa); AsyncChannelWrapper channel; if (secure) { SSLEngine sslEngine = createSSLEngine(clientEndpointConfiguration.getUserProperties()); channel = new AsyncChannelWrapperSecure(socketChannel, sslEngine); } else { channel = new AsyncChannelWrapperNonSecure(socketChannel); } ByteBuffer response; String subProtocol; try { fConnect.get(); Future<Void> fHandshake = channel.handshake(); fHandshake.get(); int toWrite = request.limit(); Future<Integer> fWrite = channel.write(request); Integer thisWrite = fWrite.get(); toWrite -= thisWrite.intValue(); while (toWrite > 0) { fWrite = channel.write(request); thisWrite = fWrite.get(); toWrite -= thisWrite.intValue(); } response = ByteBuffer.allocate(maxBinaryMessageBufferSize); HandshakeResponse handshakeResponse = processResponse(response, channel); clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse); List<String> values = handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME); if (values == null || values.size() == 0) { subProtocol = null; } else if (values.size() == 1) { subProtocol = values.get(0); } else { throw new DeploymentException(sm.getString("Sec-WebSocket-Protocol")); } } catch (ExecutionException | InterruptedException | SSLException | EOFException e) { throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"), e); } WsRemoteEndpointImplClient wsRemoteEndpointClient = new WsRemoteEndpointImplClient(channel); WsSession wsSession = new WsSession(endpoint, wsRemoteEndpointClient, this, null, null, null, null, subProtocol, Collections.EMPTY_MAP, false, clientEndpointConfiguration.getEncoders(), clientEndpointConfiguration.getUserProperties()); endpoint.onOpen(wsSession, clientEndpointConfiguration); registerSession(endpoint.getClass(), wsSession); @SuppressWarnings("unused") WsFrameClient wsFrameClient = new WsFrameClient(response, channel, wsSession); return wsSession; }	@Override public String encode(MsgString msg) throws EncodeException { return "MsgString:" + msg.getData(); }	public MsgByte rx(MsgByte in) { received.add(in); return in; }	@Override public void init(WebConnection connection) { if (ep == null) { throw new IllegalStateException(sm.getString("wsHttpUpgradeHandler.noPreInit")); } this.connection = connection; ServletInputStream sis; ServletOutputStream sos; try { sis = connection.getInputStream(); sos = connection.getOutputStream(); } catch (IOException e) { throw new IllegalStateException(e); } // Need to call onOpen using the web application's class loader // Create the frame using the application's class loader so it can pick Thread t = Thread.currentThread(); ClassLoader cl = t.getContextClassLoader(); t.setContextClassLoader(applicationClassLoader); try { WsRemoteEndpointImplServer wsRemoteEndpointServer = new WsRemoteEndpointImplServer(sos, webSocketContainer); wsSession = new WsSession(ep, wsRemoteEndpointServer, webSocketContainer, handshakeRequest.getRequestURI(), handshakeRequest.getParameterMap(), handshakeRequest.getQueryString(), handshakeRequest.getUserPrincipal(), subProtocol, pathParameters, secure, endpointConfig.getEncoders(), endpointConfig.getUserProperties()); WsFrameServer wsFrame = new WsFrameServer(sis, wsSession); sis.setReadListener(new WsReadListener(this, wsFrame)); sos.setWriteListener(new WsWriteListener(this, wsRemoteEndpointServer)); ep.onOpen(wsSession, endpointConfig); webSocketContainer.registerSession(ep.getClass(), wsSession); } catch (DeploymentException e) { throw new IllegalArgumentException(e); } finally { t.setContextClassLoader(cl); } }	public void onWritePossible() { boolean complete = true; try { while (sos.isReady()) { complete = true; for (ByteBuffer buffer : buffers) { if (buffer.hasRemaining()) { complete = false; sos.write(buffer.array(), buffer.arrayOffset(), buffer.limit()); buffer.position(buffer.limit()); break; } } if (complete) { wsWriteTimeout.unregister(this); if (close) { close(); } // Setting the result marks this (partial) message as // complete which means the next one may be sent which // could update the value of the handler. Therefore, keep a // local copy before signalling the end of the (partial) SendHandler sh = handler; handler = null; sh.onResult(new SendResult()); break; } } } catch (IOException ioe) { wsWriteTimeout.unregister(this); close(); SendHandler sh = handler; handler = null; sh.onResult(new SendResult(ioe)); } if (!complete) { long timeout = getSendTimeout(); if (timeout > 0) { timeoutExpiry = timeout + System.currentTimeMillis(); wsWriteTimeout.register(this); } } }	public void test() throws Exception { Server server = new Server(); SingletonConfigurator.setInstance(server); ServerConfigListener.setPojoClazz(Server.class); Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(new ApplicationListener(ServerConfigListener.class.getName(), false)); Tomcat.addServlet(ctx, "default", new DefaultServlet()); ctx.addServletMapping("/", "default"); WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); tomcat.start(); Client client = new Client(); URI uri = new URI("ws://localhost:" + getPort() + "/"); Session session = wsContainer.connectToServer(client, uri); MsgString msg1 = new MsgString(); msg1.setData(MESSAGE_ONE); session.getBasicRemote().sendObject(msg1); int i = 0; while (i < 20) { if (server.received.size() > 0 && client.received.size() > 0) { break; } Thread.sleep(100); } Assert.assertEquals(1, server.received.size()); Assert.assertEquals(1, client.received.size()); Assert.assertEquals(MESSAGE_ONE, ((MsgString) server.received.peek()).getData()); Assert.assertEquals(MESSAGE_ONE, ((MsgString) client.received.peek()).getData()); }
private static Object[] buildArgs(PojoPathParam[] pathParams, Map<String, String> pathParameters, Session session, EndpointConfig config, Throwable throwable, CloseReason closeReason) throws DecodeException { Object[] result = new Object[pathParams.length]; for (int i = 0; i < pathParams.length; i++) { Class<?> type = pathParams[i].getType(); if (type.equals(Session.class)) { result[i] = session; } else if (type.equals(EndpointConfig.class)) { result[i] = config; } else if (type.equals(Throwable.class)) { result[i] = throwable; } else if (type.equals(CloseReason.class)) { result[i] = closeReason; } else { String name = pathParams[i].getName(); String value = pathParameters.get(name); try { result[i] = Util.coerceToType(type, value); } catch (Exception e) { throw new DecodeException(value, sm.getString("pojoMethodMapping.decodePathParamFail", value, type), e); } } } return result; }
public boolean authenticate(Request request, HttpServletResponse response) throws IOException { Principal principal = request.getUserPrincipal(); String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (principal != null) { if (log.isDebugEnabled()) { log.debug("Already authenticated '" + principal.getName() + "'"); } if (ssoId != null) { associate(ssoId, request.getSessionInternal(true)); } return (true); } if (ssoId != null) { if (log.isDebugEnabled()) { log.debug("SSO Id " + ssoId + " set; attempting " + "reauthentication"); } if (reauthenticateFromSSO(ssoId, request)) { return true; } } String username = null; String password = null; MessageBytes authorization = request.getCoyoteRequest().getMimeHeaders().getValue("authorization"); if (authorization != null) { authorization.toBytes(); ByteChunk authorizationBC = authorization.getByteChunk(); if (authorizationBC.startsWithIgnoreCase("basic ", 0)) { authorizationBC.setOffset(authorizationBC.getOffset() + 6); byte[] decoded = Base64.decodeBase64(authorizationBC.getBuffer(), authorizationBC.getOffset(), authorizationBC.getLength()); int colon = -1; for (int i = 0; i < decoded.length; i++) { if (decoded[i] == ':') { colon = i; break; } } if (colon < 0) { username = new String(decoded, B2CConverter.ISO_8859_1); } else { username = new String(decoded, 0, colon, B2CConverter.ISO_8859_1); password = new String(decoded, colon + 1, decoded.length - colon - 1, B2CConverter.ISO_8859_1); } authorizationBC.setOffset(authorizationBC.getOffset() - 6); } principal = context.getRealm().authenticate(username, password); if (principal != null) { register(request, response, principal, HttpServletRequest.BASIC_AUTH, username, password); return (true); } } StringBuilder value = new StringBuilder(16); value.append("Basic realm=\""); value.append(getRealmName(context)); value.append('\"'); response.setHeader(AUTH_HEADER_NAME, value.toString()); response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return (false); }	@Override protected String getAuthMethod() { return HttpServletRequest.BASIC_AUTH; }	@Test public void testAuthMethodExtraSpace() throws Exception { doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED, NO_CREDENTIALS, NO_COOKIES, HttpServletResponse.SC_UNAUTHORIZED); doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED, SPACED_BASE64, NO_COOKIES, HttpServletResponse.SC_OK); }	@Test public void testPasswordExtraSpace() throws Exception { doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED, NO_CREDENTIALS, NO_COOKIES, HttpServletResponse.SC_UNAUTHORIZED); doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED, SPACED_PASSWORD, NO_COOKIES, HttpServletResponse.SC_UNAUTHORIZED); }	@Test public void testUserExtraSpace() throws Exception { doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED, NO_CREDENTIALS, NO_COOKIES, HttpServletResponse.SC_UNAUTHORIZED); doTestBasic(CONTEXT_PATH_LOGIN + URI_PROTECTED, SPACED_USERNAME, NO_COOKIES, HttpServletResponse.SC_UNAUTHORIZED); }
private void process(JarScannerCallback callback, URL url, boolean isWebapp) throws IOException { if (log.isTraceEnabled()) { log.trace(sm.getString("jarScan.jarUrlStart", url)); } URLConnection conn = url.openConnection(); if (conn instanceof JarURLConnection) { callback.scan((JarURLConnection) conn, isWebapp); } else { String urlStr = url.toString(); if (urlStr.startsWith("file:") || urlStr.startsWith("jndi:")) { if (urlStr.endsWith(Constants.JAR_EXT)) { URL jarURL = new URL("jar:" + urlStr + "!/"); callback.scan((JarURLConnection) jarURL.openConnection(), isWebapp); } else { File f; try { f = new File(url.toURI()); if (f.isFile() && scanAllFiles) { URL jarURL = new URL("jar:" + urlStr + "!/"); callback.scan((JarURLConnection) jarURL.openConnection(), isWebapp); } else if (f.isDirectory() && scanAllDirectories) { File metainf = new File(f.getAbsoluteFile() + File.separator + "META-INF"); if (metainf.isDirectory()) { callback.scan(f, isWebapp); } } } catch (URISyntaxException e) { IOException ioe = new IOException(); ioe.initCause(e); throw ioe; } } } } }
@Override protected synchronized void startInternal() throws LifecycleException { if (log.isDebugEnabled()) log.debug("Starting " + getBaseName()); if (this.getObjectName() != null) { Notification notification = new Notification("j2ee.state.starting", this.getObjectName(), sequenceNumber.getAndIncrement()); broadcaster.sendNotification(notification); } setConfigured(false); boolean ok = true; if (namingResources != null) { namingResources.start(); } if (getResources() == null) { if (log.isDebugEnabled()) log.debug("Configuring default Resources"); try { setResources(new StandardRoot(this)); } catch (IllegalArgumentException e) { log.error("Error initializing resources: " + e.getMessage()); ok = false; } } if (ok) { if (!resourcesStart()) { log.error("Error in resourceStart()"); ok = false; } } if (getLoader() == null) { WebappLoader webappLoader = new WebappLoader(getParentClassLoader()); webappLoader.setDelegate(getDelegate()); setLoader(webappLoader); } getCharsetMapper(); postWorkDirectory(); boolean dependencyCheck = true; try { dependencyCheck = ExtensionValidator.validateApplication(getResources(), this); } catch (IOException ioe) { log.error("Error in dependencyCheck", ioe); dependencyCheck = false; } if (!dependencyCheck) { ok = false; } String useNamingProperty = System.getProperty("catalina.useNaming"); if ((useNamingProperty != null) && (useNamingProperty.equals("false"))) { useNaming = false; } if (ok && isUseNaming()) { if (getNamingContextListener() == null) { NamingContextListener ncl = new NamingContextListener(); ncl.setName(getNamingContextName()); ncl.setExceptionOnFailedWrite(getJndiExceptionOnFailedWrite()); addLifecycleListener(ncl); setNamingContextListener(ncl); } } if (log.isDebugEnabled()) log.debug("Processing standard container startup"); ClassLoader oldCCL = bindThread(); try { if (ok) { Loader loader = getLoader(); if ((loader != null) && (loader instanceof Lifecycle)) ((Lifecycle) loader).start(); // since the loader just started, the webapp classloader is now setClassLoaderProperty("antiJARLocking", getAntiJARLocking()); setClassLoaderProperty("clearReferencesStatic", getClearReferencesStatic()); setClassLoaderProperty("clearReferencesStopThreads", getClearReferencesStopThreads()); setClassLoaderProperty("clearReferencesStopTimerThreads", getClearReferencesStopTimerThreads()); setClassLoaderProperty("clearReferencesHttpClientKeepAliveThread", getClearReferencesHttpClientKeepAliveThread()); // By calling unbindThread and bindThread in a row, we setup the unbindThread(oldCCL); oldCCL = bindThread(); // Initialize logger again. Other components might have used it logger = null; getLogger(); Cluster cluster = getClusterInternal(); if ((cluster != null) && (cluster instanceof Lifecycle)) ((Lifecycle) cluster).start(); Realm realm = getRealmInternal(); if ((realm != null) && (realm instanceof Lifecycle)) ((Lifecycle) realm).start(); fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, null); for (Container child : findChildren()) { if (!child.getState().isAvailable()) { child.start(); } } if (pipeline instanceof Lifecycle) { ((Lifecycle) pipeline).start(); } Manager contextManager = null; Manager manager = getManager(); if (manager == null) { if (log.isDebugEnabled()) { log.debug(sm.getString("standardContext.cluster.noManager", Boolean.valueOf((getCluster() != null)), Boolean.valueOf(distributable))); } if ((getCluster() != null) && distributable) { try { contextManager = getCluster().createManager(getName()); } catch (Exception ex) { log.error("standardContext.clusterFail", ex); ok = false; } } else { contextManager = new StandardManager(); } } if (contextManager != null) { if (log.isDebugEnabled()) { log.debug(sm.getString("standardContext.manager", contextManager.getClass().getName())); } setManager(contextManager); } if (manager != null && (getCluster() != null) && distributable) { //let the cluster know that there is a context that is distributable getCluster().registerManager(manager); } } } finally { unbindThread(oldCCL); } if (!getConfigured()) { log.error("Error getConfigured"); ok = false; } if (ok) getServletContext().setAttribute(Globals.RESOURCES_ATTR, getResources()); oldCCL = bindThread(); if (ok) { if (getInstanceManager() == null) { javax.naming.Context context = null; if (isUseNaming() && getNamingContextListener() != null) { context = getNamingContextListener().getEnvContext(); } Map<String, Map<String, String>> injectionMap = buildInjectionMap(getIgnoreAnnotations() ? new NamingResources() : getNamingResources()); setInstanceManager(new DefaultInstanceManager(context, injectionMap, this, this.getClass().getClassLoader())); getServletContext().setAttribute(InstanceManager.class.getName(), getInstanceManager()); } } try { if (ok) { getServletContext().setAttribute(JarScanner.class.getName(), getJarScanner()); } mergeParameters(); for (Map.Entry<ServletContainerInitializer, Set<Class<?>>> entry : initializers.entrySet()) { try { entry.getKey().onStartup(entry.getValue(), getServletContext()); } catch (ServletException e) { log.error(sm.getString("standardContext.sciFail"), e); ok = false; break; } } if (ok) { if (!listenerStart()) { log.error("Error listenerStart"); ok = false; } } try { Manager manager = getManager(); if ((manager != null) && (manager instanceof Lifecycle)) { ((Lifecycle) getManager()).start(); } } catch (Exception e) { log.error("Error manager.start()", e); ok = false; } if (ok) { if (!filterStart()) { log.error("Error filterStart"); ok = false; } } if (ok) { loadOnStartup(findChildren()); } super.threadStart(); } finally { unbindThread(oldCCL); } if (ok) { if (log.isDebugEnabled()) log.debug("Starting completed"); } else { log.error(sm.getString("standardContext.startFailed", getName())); } startTime = System.currentTimeMillis(); if (ok && (this.getObjectName() != null)) { Notification notification = new Notification("j2ee.state.running", this.getObjectName(), sequenceNumber.getAndIncrement()); broadcaster.sendNotification(notification); } if (getLoader() instanceof WebappLoader) { ((WebappLoader) getLoader()).closeJARs(true); } if (!ok) { setState(LifecycleState.FAILED); } else { setState(LifecycleState.STARTING); } }
private boolean isExpression(Node n, String value, boolean checkDeferred) { boolean runtimeExpression = ((n.getRoot().isXmlSyntax() && value.startsWith("%=")) || (!n.getRoot().isXmlSyntax() && value.startsWith("<%="))); boolean elExpression = false; if (!runtimeExpression && !pageInfo.isELIgnored()) { Iterator<ELNode> nodes = ELParser.parse(value, pageInfo.isDeferredSyntaxAllowedAsLiteral()).iterator(); while (nodes.hasNext()) { ELNode node = nodes.next(); if (node instanceof ELNode.Root) { if (((ELNode.Root) node).getType() == '$') { elExpression = true; } else if (checkDeferred && !pageInfo.isDeferredSyntaxAllowedAsLiteral() && ((ELNode.Root) node).getType() == '#') { elExpression = true; } } } } return runtimeExpression || elExpression; }
public Member[] excludeFromSet(Member[] mbrs, Member[] set) { ArrayList<Member> result = new ArrayList<>(); for (int i = 0; i < set.length; i++) { boolean include = true; for (int j = 0; j < mbrs.length; j++) if (mbrs[j].equals(set[i])) include = false; if (include) result.add(set[i]); } return result.toArray(new Member[result.size()]); }
private boolean isLocked(String path, String ifHeader) { LockInfo lock = resourceLocks.get(path); Enumeration<String> tokenList = null; if ((lock != null) && (lock.hasExpired())) { resourceLocks.remove(path); } else if (lock != null) { tokenList = lock.tokens.elements(); boolean tokenMatch = false; while (tokenList.hasMoreElements()) { String token = tokenList.nextElement(); if (ifHeader.indexOf(token) != -1) tokenMatch = true; } if (!tokenMatch) return true; } Enumeration<LockInfo> collectionLocksList = collectionLocks.elements(); while (collectionLocksList.hasMoreElements()) { lock = collectionLocksList.nextElement(); if (lock.hasExpired()) { collectionLocks.removeElement(lock); } else if (path.startsWith(lock.path)) { tokenList = lock.tokens.elements(); boolean tokenMatch = false; while (tokenList.hasMoreElements()) { String token = tokenList.nextElement(); if (ifHeader.indexOf(token) != -1) tokenMatch = true; } if (!tokenMatch) return true; } } return false; }
private void doTestBasic(String uri, BasicCredentials credentials, boolean useCookie, int expectedRC) throws Exception { Map<String, List<String>> reqHeaders = new HashMap<>(); Map<String, List<String>> respHeaders = new HashMap<>(); if (useCookie && (cookies != null)) { reqHeaders.put(CLIENT_COOKIE_HEADER + ":", cookies); } else { if (credentials != null) { List<String> auth = new ArrayList<>(); auth.add(credentials.getCredentials()); reqHeaders.put(CLIENT_AUTH_HEADER, auth); } } ByteChunk bc = new ByteChunk(); int rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders, respHeaders); if (expectedRC != HttpServletResponse.SC_OK) { assertEquals(expectedRC, rc); assertTrue(bc.getLength() > 0); if (expectedRC == HttpServletResponse.SC_UNAUTHORIZED) { boolean methodFound = false; List<String> authHeaders = respHeaders.get(SERVER_AUTH_HEADER); for (String authHeader : authHeaders) { if (authHeader.indexOf(NICE_METHOD) > -1) { methodFound = true; } } assertTrue(methodFound); } } else { assertEquals("OK", bc.toString()); List<String> newCookies = respHeaders.get(SERVER_COOKIE_HEADER); if (newCookies != null) { cookies = newCookies; } } }	@Test public void testSessionExpiryContainer() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(new ApplicationListener(TesterEchoServer.Config.class.getName(), false)); Tomcat.addServlet(ctx, "default", new DefaultServlet()); ctx.addServletMapping("/", "default"); tomcat.start(); WsWebSocketContainer wsContainer = (WsWebSocketContainer) ContainerProvider.getWebSocketContainer(); wsContainer.setDefaultMaxSessionIdleTimeout(5000); wsContainer.setProcessPeriod(1); connectToEchoServerBasic(wsContainer, EndpointA.class); connectToEchoServerBasic(wsContainer, EndpointA.class); Session s3a = connectToEchoServerBasic(wsContainer, EndpointA.class); Set<Session> setA = s3a.getOpenSessions(); Assert.assertEquals(3, setA.size()); int count = 0; boolean isOpen = true; while (isOpen && count < 8) { count++; Thread.sleep(1000); isOpen = false; for (Session session : setA) { if (session.isOpen()) { isOpen = true; } } } if (isOpen) { for (Session session : setA) { if (session.isOpen()) { System.err.println("Session with ID [" + session.getId() + "] is open"); } } Assert.fail("There were open sessions"); } }
@Override public String getProperty(String name) { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); String prefix = this.prefix.get(); if (prefix != null) { name = prefix + name; } ClassLoaderLogInfo info = getClassLoaderInfo(classLoader); String result = info.props.getProperty(name); if ((result == null) && (info.props.isEmpty())) { ClassLoader current = classLoader.getParent(); while (current != null) { info = classLoaderLoggers.get(current); if (info != null) { result = info.props.getProperty(name); if ((result != null) || (!info.props.isEmpty())) { break; } } current = current.getParent(); } if (result == null) { result = super.getProperty(name); } } if (result != null) { result = replace(result); } return result; }
@Override public boolean isCommitted() { return false; }	@Override public void addDateHeader(String name, long value) { /* NOOP */ }	@Override public void setDateHeader(String name, long value) { /* NOOP */ }	@Override public void setIntHeader(String name, int value) { /* NOOP */ }	@Override public int getStatus() { return -1; }
@Override public void execute() throws BuildException { super.execute(); if (path == null) { throw new BuildException("Must specify 'path' attribute"); } if ((war == null) && (localWar == null) && (config == null) && (tag == null)) { throw new BuildException("Must specify either 'war', 'localWar', 'config', or 'tag' attribute"); } BufferedInputStream stream = null; String contentType = null; int contentLength = -1; if (war != null) { if (war.startsWith("file:")) { try { URL url = new URL(war); URLConnection conn = url.openConnection(); contentLength = conn.getContentLength(); stream = new BufferedInputStream(conn.getInputStream(), 1024); } catch (IOException e) { throw new BuildException(e); } } else { try { FileInputStream fsInput = new FileInputStream(war); long size = fsInput.getChannel().size(); if (size > Integer.MAX_VALUE) throw new UnsupportedOperationException("DeployTask does not support WAR files " + "greater than 2 Gb"); contentLength = (int) size; stream = new BufferedInputStream(fsInput, 1024); } catch (IOException e) { throw new BuildException(e); } } contentType = "application/octet-stream"; } StringBuilder sb = new StringBuilder("/deploy?path="); try { sb.append(URLEncoder.encode(this.path, getCharset())); if ((war == null) && (config != null)) { sb.append("&config="); sb.append(URLEncoder.encode(config, getCharset())); } if ((war == null) && (localWar != null)) { sb.append("&war="); sb.append(URLEncoder.encode(localWar, getCharset())); } if (update) { sb.append("&update=true"); } if (tag != null) { sb.append("&tag="); sb.append(URLEncoder.encode(tag, getCharset())); } } catch (UnsupportedEncodingException e) { throw new BuildException("Invalid 'charset' attribute: " + getCharset()); } execute(sb.toString(), stream, contentType, contentLength); }	public void setLocalWar(String localWar) { this.localWar = localWar; }
public void register(Request request, HttpServletResponse response, Principal principal, String authType, String username, String password) { if (log.isDebugEnabled()) { String name = (principal == null) ? "none" : principal.getName(); log.debug("Authenticated '" + name + "' with type '" + authType + "'"); } request.setAuthType(authType); request.setUserPrincipal(principal); Session session = request.getSessionInternal(false); if (session != null) { if (changeSessionIdOnAuthentication) { Manager manager = request.getContext().getManager(); manager.changeSessionId(session); request.changeSessionId(session.getId()); } } else if (alwaysUseSession) { session = request.getSessionInternal(true); } if (cache) { if (session != null) { session.setAuthType(authType); session.setPrincipal(principal); if (username != null) { session.setNote(Constants.SESS_USERNAME_NOTE, username); } else { session.removeNote(Constants.SESS_USERNAME_NOTE); } if (password != null) { session.setNote(Constants.SESS_PASSWORD_NOTE, password); } else { session.removeNote(Constants.SESS_PASSWORD_NOTE); } } } if (sso == null) { return; } // Only create a new SSO entry if the SSO did not already set a note // for an existing entry (as it would do with subsequent requests String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (ssoId == null) { ssoId = sessionIdGenerator.generateSessionId(); Cookie cookie = new Cookie(Constants.SINGLE_SIGN_ON_COOKIE, ssoId); cookie.setMaxAge(-1); cookie.setPath("/"); cookie.setSecure(request.isSecure()); String ssoDomain = sso.getCookieDomain(); if (ssoDomain != null) { cookie.setDomain(ssoDomain); } if (request.getServletContext().getSessionCookieConfig().isHttpOnly() || request.getContext().getUseHttpOnly()) { cookie.setHttpOnly(true); } response.addCookie(cookie); sso.register(ssoId, principal, authType, username, password); request.setNote(Constants.REQ_SSOID_NOTE, ssoId); } else { if (principal == null) { sso.deregister(ssoId); return; } else { sso.update(ssoId, principal, authType, username, password); } } if (session == null) { session = request.getSessionInternal(true); } sso.associate(ssoId, session); }
private HandshakeStatus checkResult(SSLEngineResult result, boolean wrap) throws SSLException { if (result.getStatus() != Status.OK) { throw new SSLException("TODO"); } if (wrap && result.bytesConsumed() != 0) { throw new SSLException("TODO"); } if (!wrap && result.bytesProduced() != 0) { throw new SSLException("TODO"); } return result.getHandshakeStatus(); }	@Override public void run() { long written = 0; try { for (int i = offset; i < offset + length; i++) { ByteBuffer src = srcs[i]; while (src.hasRemaining()) { socketWriteBuffer.clear(); SSLEngineResult r = sslEngine.wrap(src, socketWriteBuffer); written += r.bytesConsumed(); Status s = r.getStatus(); if (s == Status.OK || s == Status.BUFFER_OVERFLOW) { // Need to write out the bytes and may need to read from // the source again to empty it } else { throw new IllegalStateException(); } if (r.getHandshakeStatus() == HandshakeStatus.NEED_TASK) { Runnable runnable = sslEngine.getDelegatedTask(); while (runnable != null) { runnable.run(); runnable = sslEngine.getDelegatedTask(); } } socketWriteBuffer.flip(); Future<Integer> f = socketChannel.write(socketWriteBuffer); Integer socketWrite = f.get(); if (socketWrite.intValue() != r.bytesProduced()) { throw new IOException(); } } } if (writing.compareAndSet(true, false)) { future.complete(Long.valueOf(written)); } else { future.fail(new IllegalStateException()); } } catch (Exception e) { future.fail(e); } }
private void parseParts() { if (parts != null || partsParseException != null) { return; } MultipartConfigElement mce = getWrapper().getMultipartConfigElement(); if (mce == null) { if (getContext().getAllowCasualMultipartParsing()) { mce = new MultipartConfigElement(null, connector.getMaxPostSize(), connector.getMaxPostSize(), connector.getMaxPostSize()); } else { parts = Collections.emptyList(); return; } } Parameters parameters = coyoteRequest.getParameters(); parameters.setLimit(getConnector().getMaxParameterCount()); boolean success = false; try { File location; String locationStr = mce.getLocation(); if (locationStr == null || locationStr.length() == 0) { location = ((File) context.getServletContext().getAttribute(ServletContext.TEMPDIR)); } else { location = new File(locationStr); if (!location.isAbsolute()) { location = new File((File) context.getServletContext().getAttribute(ServletContext.TEMPDIR), locationStr).getAbsoluteFile(); } } if (!location.isDirectory()) { partsParseException = new IOException(sm.getString("coyoteRequest.uploadLocationInvalid", location)); return; } DiskFileItemFactory factory = new DiskFileItemFactory(); try { factory.setRepository(location.getCanonicalFile()); } catch (IOException ioe) { partsParseException = ioe; return; } factory.setSizeThreshold(mce.getFileSizeThreshold()); ServletFileUpload upload = new ServletFileUpload(); upload.setFileItemFactory(factory); upload.setFileSizeMax(mce.getMaxFileSize()); upload.setSizeMax(mce.getMaxRequestSize()); parts = new ArrayList<>(); try { List<FileItem> items = upload.parseRequest(new ServletRequestContext(this)); int maxPostSize = getConnector().getMaxPostSize(); int postSize = 0; String enc = getCharacterEncoding(); Charset charset = null; if (enc != null) { try { charset = B2CConverter.getCharset(enc); } catch (UnsupportedEncodingException e) { // Ignore } } for (FileItem item : items) { ApplicationPart part = new ApplicationPart(item, mce); parts.add(part); if (part.getSubmittedFileName() == null) { String name = part.getName(); String value = null; try { String encoding = parameters.getEncoding(); if (encoding == null) { if (enc == null) { encoding = Parameters.DEFAULT_ENCODING; } else { encoding = enc; } } value = part.getString(encoding); } catch (UnsupportedEncodingException uee) { try { value = part.getString(Parameters.DEFAULT_ENCODING); } catch (UnsupportedEncodingException e) { // Should not be possible } } if (maxPostSize > 0) { if (charset == null) { postSize += name.getBytes().length; } else { postSize += name.getBytes(charset).length; } if (value != null) { postSize++; postSize += part.getSize(); } postSize++; if (postSize > maxPostSize) { throw new IllegalStateException(sm.getString("coyoteRequest.maxPostSizeExceeded")); } } parameters.addParameter(name, value); } } success = true; } catch (InvalidContentTypeException e) { partsParseException = new ServletException(e); } catch (FileUploadBase.SizeException e) { checkSwallowInput(); partsParseException = new IllegalStateException(e); } catch (FileUploadException e) { partsParseException = new IOException(e); } catch (IllegalStateException e) { checkSwallowInput(); partsParseException = e; } } finally { if (partsParseException != null || !success) { parameters.setParseFailed(true); } } }	@Override public void write(String fileName) throws IOException { File file = new File(fileName); if (!file.isAbsolute()) { file = new File(mce.getLocation(), fileName); } try { fileItem.write(file); } catch (Exception e) { throw new IOException(e); } }
private void loadTagPlugins(ErrorDispatcher err, InputStream is) throws JasperException { TreeNode root = (new ParserUtils()).parseXMLDocument(TAG_PLUGINS_XML, is); if (root == null) { return; } if (!TAG_PLUGINS_ROOT_ELEM.equals(root.getName())) { err.jspError("jsp.error.plugin.wrongRootElement", TAG_PLUGINS_XML, TAG_PLUGINS_ROOT_ELEM); } tagPlugins = new HashMap<>(); Iterator<TreeNode> pluginList = root.findChildren("tag-plugin"); while (pluginList.hasNext()) { TreeNode pluginNode = pluginList.next(); TreeNode tagClassNode = pluginNode.findChild("tag-class"); if (tagClassNode == null) { return; } String tagClass = tagClassNode.getBody().trim(); TreeNode pluginClassNode = pluginNode.findChild("plugin-class"); if (pluginClassNode == null) { return; } String pluginClassStr = pluginClassNode.getBody(); TagPlugin tagPlugin = null; try { Class<?> pluginClass = Class.forName(pluginClassStr); tagPlugin = (TagPlugin) pluginClass.newInstance(); } catch (Exception e) { throw new JasperException(e); } if (tagPlugin == null) { return; } tagPlugins.put(tagClass, tagPlugin); } initialized = true; }
@Override public void onAccept(Object socket) { SpdyConnectionSocket ch = new SpdyConnectionSocket(ctx, (Socket) socket); ctx.getExecutor().execute(ch.inputThread); ch.onBlockingSocket(); }
public void start() throws Exception { super.start(); spdyContext = new SpdyContext(); spdyContext.setTlsComprression(false, false); spdyContext.setHandler(new SpdyHandler() { @Override public void onStream(SpdyConnection con, SpdyStream ch) throws IOException { SpdyProcessor sp = new SpdyProcessor(con, endpoint); sp.setAdapter(getAdapter()); sp.onSynStream(ch); } }); spdyContext.setNetSupport(new NetSupportSocket()); spdyContext.setExecutor(endpoint.getExecutor()); }	@Override public void start() throws Exception { super.start(); spdyContext = new SpdyContext(); spdyContext.setTlsComprression(false, false); spdyContext.setHandler(new SpdyHandler() { @Override } }
@Test public void testNewLinesExcessive() { NewLinesClient client = new NewLinesClient(10000); // If the connection is closed fast enough, writing the request will Exception e = client.doRequest(); if (e == null) { assertTrue(client.isResponse400()); } assertFalse(client.isResponseBodyOK()); }	@Override public boolean parseRequestLine(boolean useAvailableDataOnly) throws IOException { if (!parsingRequestLine) return true; if (parsingRequestLinePhase == 0) { byte chr = 0; do { if (pos >= lastValid) { if (useAvailableDataOnly) { return false; } if (!fill(true, false)) { return false; } } chr = buf[pos++]; } while ((chr == Constants.CR) || (chr == Constants.LF)); pos--; parsingRequestLineStart = pos; parsingRequestLinePhase = 2; if (log.isDebugEnabled()) { log.debug("Received [" + new String(buf, pos, lastValid - pos, DEFAULT_CHARSET) + "]"); } } if (parsingRequestLinePhase == 2) { // // Reading the method name // Method name is always US-ASCII boolean space = false; while (!space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) { throw new IllegalArgumentException(sm.getString("iib.invalidmethod")); } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; request.method().setBytes(buf, parsingRequestLineStart, pos - parsingRequestLineStart); } pos++; } parsingRequestLinePhase = 3; } if (parsingRequestLinePhase == 3) { boolean space = true; while (space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { pos++; } else { space = false; } } parsingRequestLineStart = pos; parsingRequestLinePhase = 4; } if (parsingRequestLinePhase == 4) { int end = 0; // // Reading the URI boolean space = false; while (!space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; end = pos; } else if ((buf[pos] == Constants.CR) || (buf[pos] == Constants.LF)) { parsingRequestLineEol = true; space = true; end = pos; } else if ((buf[pos] == Constants.QUESTION) && (parsingRequestLineQPos == -1)) { parsingRequestLineQPos = pos; } pos++; } request.unparsedURI().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); if (parsingRequestLineQPos >= 0) { request.queryString().setBytes(buf, parsingRequestLineQPos + 1, end - parsingRequestLineQPos - 1); request.requestURI().setBytes(buf, parsingRequestLineStart, parsingRequestLineQPos - parsingRequestLineStart); } else { request.requestURI().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); } parsingRequestLinePhase = 5; } if (parsingRequestLinePhase == 5) { boolean space = true; while (space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { pos++; } else { space = false; } } parsingRequestLineStart = pos; parsingRequestLinePhase = 6; } if (parsingRequestLinePhase == 6) { end = 0; while (!parsingRequestLineEol) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.CR) { end = pos; } else if (buf[pos] == Constants.LF) { if (end == 0) end = pos; parsingRequestLineEol = true; } pos++; } if ((end - parsingRequestLineStart) > 0) { request.protocol().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); } else { request.protocol().setString(""); } parsingRequestLine = false; parsingRequestLinePhase = 0; parsingRequestLineEol = false; parsingRequestLineStart = 0; return true; } throw new IllegalStateException("Invalid request line parse phase:" + parsingRequestLinePhase); }
private void doTest(String resourceMethod, String redirectMethod, boolean useContinue) throws Exception { FormAuthClient client = new FormAuthClient(); client.setUseContinue(useContinue); client.doResourceRequest(resourceMethod); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.setUseContinue(useContinue); client.doLoginRequest(); assertTrue(client.isResponse302()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doResourceRequest(redirectMethod); if ("POST".equals(redirectMethod)) { client.setUseContinue(useContinue); } assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); for (int i = 0; i < 5; i++) { client.setUseContinue(useContinue); client.doResourceRequest(resourceMethod); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); } }	private void assertContains(String body, String expected) { if (!body.contains(expected)) { fail("Response body check failure.\n" + "Expected to contain substring: [" + expected + "]\nActual: [" + body + "]"); } }	private void doLoginRequest() throws Exception { StringBuilder requestHead = new StringBuilder(128); requestHead.append("POST ").append(protectedLocation).append(LOGIN_PAGE).append(" HTTP/1.1").append(CRLF); requestHead.append("Host: localhost").append(CRLF); requestHead.append("Connection: close").append(CRLF); if (getUseContinue()) { requestHead.append("Expect: 100-continue").append(CRLF); } if (sessionId != null) { requestHead.append("Cookie: JSESSIONID=").append(sessionId).append(CRLF); } requestHead.append("Content-Type: application/x-www-form-urlencoded").append(CRLF); requestHead.append("Content-length: 35").append(CRLF); requestHead.append(CRLF); String[] request = new String[2]; request[0] = requestHead.toString(); request[1] = "j_username=tomcat&j_password=tomcat"; doRequest(request); }	private void doRequest(String[] request) throws Exception { setRequest(request); connect(); processRequest(); String newSessionId = getSessionId(); if (newSessionId != null) { sessionId = newSessionId; } disconnect(); requestCount++; }	private void doResourceRequest(String method) throws Exception { StringBuilder requestHead = new StringBuilder(128); String requestTail; requestHead.append(method).append(" ").append(protectedLocation).append(protectedPage); if ("GET".equals(method)) { requestHead.append("?role=bar"); } requestHead.append(" HTTP/1.1").append(CRLF); requestHead.append("Host: localhost").append(CRLF); requestHead.append("Connection: close").append(CRLF); if (getUseContinue()) { requestHead.append("Expect: 100-continue").append(CRLF); } if (sessionId != null) { requestHead.append("Cookie: JSESSIONID=").append(sessionId).append(CRLF); } if ("POST".equals(method)) { requestHead.append("Content-Type: application/x-www-form-urlencoded").append(CRLF); requestHead.append("Content-length: 8").append(CRLF); requestHead.append(CRLF); requestTail = "role=bar"; } else { requestTail = CRLF; } String[] request = new String[2]; request[0] = requestHead.toString(); request[1] = requestTail; doRequest(request); }	private void doTest(String resourceMethod, String redirectMethod, boolean useContinue) throws Exception { FormAuthClient client = new FormAuthClient(); client.setUseContinue(useContinue); client.doResourceRequest(resourceMethod); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.setUseContinue(useContinue); client.doLoginRequest(); assertTrue(client.isResponse302()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doResourceRequest(redirectMethod); if ("POST".equals(redirectMethod)) { client.setUseContinue(useContinue); } assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); for (int i = 0; i < 5; i++) { client.setUseContinue(useContinue); client.doResourceRequest(resourceMethod); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); } }	@Override public boolean isResponseBodyOK() { if (requestCount == 1) { assertContains(getResponseBody(), "<title>Login Page for Examples</title>"); return true; } else if (requestCount == 2) { return true; } else { // Subsequent requests should result in the protected page String body = getResponseBody(); assertContains(body, "<title>Protected Page for Examples</title>"); assertContains(body, "<input type=\"text\" name=\"role\" value=\"bar\""); return true; } }	public void testGet() throws Exception { doTest("GET", "GET", false); }	@Test public void testPostNoContinue() throws Exception { doTest("POST", "GET", false); }	@Test public void testPostNoContinuePostRedirect() throws Exception { doTest("POST", "POST", false); }	@Test public void testPostWithContinue() throws Exception { doTest("POST", "GET", true); }	@Test public void testPostWithContinuePostRedirect() throws Exception { doTest("POST", "POST", true); }

public void testBug48692() { Bug48692Client client = new Bug48692Client(); client.doRequest("GET", "foo=bar", null, null, false); assertTrue("Non-200 response for GET request", client.isResponse200()); assertEquals("Incorrect response for GET request", "foo=bar", client.getResponseBody()); client.reset(); // // Make sure POST works properly // client.doRequest("POST", "foo=bar", "application/x-www-form-urlencoded", "bar=baz", true); assertTrue("Non-200 response for POST request", client.isResponse200()); assertEquals("Incorrect response for POST request", "bar=baz,foo=bar", client.getResponseBody()); client.reset(); client.doRequest("POST", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", true); assertTrue("Non-200 response for POST request", client.isResponse200()); assertEquals("Incorrect response for POST request", "bar=baz,bar=foo,foo=bar,foo=baz", client.getResponseBody()); client.reset(); client.doRequest("PUT", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", false); assertTrue("Non-200 response for PUT/noparse request", client.isResponse200()); assertEquals("Incorrect response for PUT request", "bar=foo,foo=bar", client.getResponseBody()); client.reset(); client.doRequest("PUT", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", true); assertTrue("Non-200 response for PUT request", client.isResponse200()); assertEquals("Incorrect response for PUT/parse request", "bar=baz,bar=foo,foo=bar,foo=baz", client.getResponseBody()); client.reset(); /* private Exception doRequest(String method, String queryString, String contentType, String requestBody, boolean allowBody) { */ }	HttpURLConnection getConnection() throws IOException { final String query = "http://localhost:" + getPort() + "/"; URL postURL; postURL = new URL(query); HttpURLConnection conn = (HttpURLConnection) postURL.openConnection(); conn.setRequestMethod("POST"); conn.setDoInput(true); conn.setDoOutput(true); conn.setUseCaches(false); conn.setAllowUserInteraction(false); return conn; }	private void parseParts() { if (parts != null || partsParseException != null) { return; } MultipartConfigElement mce = getWrapper().getMultipartConfigElement(); if (mce == null) { if (getContext().getAllowCasualMultipartParsing()) { mce = new MultipartConfigElement(null, connector.getMaxPostSize(), connector.getMaxPostSize(), connector.getMaxPostSize()); } else { parts = Collections.emptyList(); return; } } Parameters parameters = coyoteRequest.getParameters(); parameters.setLimit(getConnector().getMaxParameterCount()); boolean success = false; try { File location; String locationStr = mce.getLocation(); if (locationStr == null || locationStr.length() == 0) { location = ((File) context.getServletContext().getAttribute(ServletContext.TEMPDIR)); } else { location = new File(locationStr); if (!location.isAbsolute()) { location = new File((File) context.getServletContext().getAttribute(ServletContext.TEMPDIR), locationStr).getAbsoluteFile(); } } if (!location.isDirectory()) { partsParseException = new IOException(sm.getString("coyoteRequest.uploadLocationInvalid", location)); return; } DiskFileItemFactory factory = new DiskFileItemFactory(); try { factory.setRepository(location.getCanonicalFile()); } catch (IOException ioe) { partsParseException = ioe; return; } factory.setSizeThreshold(mce.getFileSizeThreshold()); ServletFileUpload upload = new ServletFileUpload(); upload.setFileItemFactory(factory); upload.setFileSizeMax(mce.getMaxFileSize()); upload.setSizeMax(mce.getMaxRequestSize()); parts = new ArrayList<>(); try { List<FileItem> items = upload.parseRequest(new ServletRequestContext(this)); int maxPostSize = getConnector().getMaxPostSize(); int postSize = 0; String enc = getCharacterEncoding(); Charset charset = null; if (enc != null) { try { charset = B2CConverter.getCharset(enc); } catch (UnsupportedEncodingException e) { // Ignore } } for (FileItem item : items) { ApplicationPart part = new ApplicationPart(item, mce); parts.add(part); if (part.getSubmittedFileName() == null) { String name = part.getName(); String value = null; try { String encoding = parameters.getEncoding(); if (encoding == null) { encoding = Parameters.DEFAULT_ENCODING; } value = part.getString(encoding); } catch (UnsupportedEncodingException uee) { try { value = part.getString(Parameters.DEFAULT_ENCODING); } catch (UnsupportedEncodingException e) { // Should not be possible } } if (maxPostSize > 0) { if (charset == null) { postSize += name.getBytes().length; } else { postSize += name.getBytes(charset).length; } if (value != null) { postSize++; postSize += part.getSize(); } postSize++; if (postSize > maxPostSize) { throw new IllegalStateException(sm.getString("coyoteRequest.maxPostSizeExceeded")); } } parameters.addParameter(name, value); } } success = true; } catch (InvalidContentTypeException e) { partsParseException = new ServletException(e); } catch (FileUploadBase.SizeException e) { checkSwallowInput(); partsParseException = new IllegalStateException(e); } catch (FileUploadException e) { partsParseException = new IOException(e); } catch (IllegalStateException e) { checkSwallowInput(); partsParseException = e; } } finally { if (partsParseException != null || !success) { parameters.setParseFailed(true); } } }	@Test public void testBug48692() { Bug48692Client client = new Bug48692Client(); client.doRequest("GET", "foo=bar", null, null, false); assertTrue("Non-200 response for GET request", client.isResponse200()); assertEquals("Incorrect response for GET request", "foo=bar", client.getResponseBody()); client.reset(); // // Make sure POST works properly // client.doRequest("POST", "foo=bar", "application/x-www-form-urlencoded", "bar=baz", true); assertTrue("Non-200 response for POST request", client.isResponse200()); assertEquals("Incorrect response for POST request", "bar=baz,foo=bar", client.getResponseBody()); client.reset(); client.doRequest("POST", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", true); assertTrue("Non-200 response for POST request", client.isResponse200()); assertEquals("Incorrect response for POST request", "bar=baz,bar=foo,foo=bar,foo=baz", client.getResponseBody()); client.reset(); client.doRequest("PUT", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", false); assertTrue("Non-200 response for PUT/noparse request", client.isResponse200()); assertEquals("Incorrect response for PUT request", "bar=foo,foo=bar", client.getResponseBody()); client.reset(); client.doRequest("PUT", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", true); assertTrue("Non-200 response for PUT request", client.isResponse200()); assertEquals("Incorrect response for PUT/parse request", "bar=baz,bar=foo,foo=bar,foo=baz", client.getResponseBody()); client.reset(); /* private Exception doRequest(String method, String queryString, String contentType, String requestBody, boolean allowBody) { */ }	@Test public void testBug49424NoChunking() throws Exception { Tomcat tomcat = getTomcatInstance(); Context root = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(root, "Bug37794", new Bug37794Servlet()); root.addServletMapping("/", "Bug37794"); tomcat.start(); HttpURLConnection conn = getConnection(); InputStream is = conn.getInputStream(); assertNotNull(is); }	@Test public void testBug49424WithChunking() throws Exception { Tomcat tomcat = getTomcatInstance(); Context root = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(root, "Bug37794", new Bug37794Servlet()); root.addServletMapping("/", "Bug37794"); tomcat.start(); HttpURLConnection conn = getConnection(); conn.setChunkedStreamingMode(8 * 1024); InputStream is = conn.getInputStream(); assertNotNull(is); }
private void doTestUriDecoding(String path, String encoding, String expectedPathInfo) throws Exception { Tomcat tomcat = getTomcatInstance(); tomcat.getConnector().setURIEncoding(encoding); Context ctx = tomcat.addContext("/", System.getProperty("java.io.tmpdir")); PathInfoServlet servlet = new PathInfoServlet(); Tomcat.addServlet(ctx, "servlet", servlet); ctx.addServletMapping("/*", "servlet"); tomcat.start(); int rc = getUrl("http://localhost:" + getPort() + path, new ByteChunk(), null); Assert.assertEquals(HttpServletResponse.SC_OK, rc); Assert.assertEquals(expectedPathInfo, servlet.getPathInfo()); }
protected void removeWrapper(ContextVersion context, String path) { if (log.isDebugEnabled()) { log.debug(sm.getString("mapper.removeWrapper", context.name, path)); } synchronized (context) { if (path.endsWith("/*")) { String name = path.substring(0, path.length() - 2); MappedWrapper[] oldWrappers = context.wildcardWrappers; if (oldWrappers.length == 0) { return; } MappedWrapper[] newWrappers = new MappedWrapper[oldWrappers.length - 1]; if (removeMap(oldWrappers, newWrappers, name)) { context.nesting = 0; for (int i = 0; i < newWrappers.length; i++) { int slashCount = slashCount(newWrappers[i].name); if (slashCount > context.nesting) { context.nesting = slashCount; } } context.wildcardWrappers = newWrappers; } } else if (path.startsWith("*.")) { String name = path.substring(2); MappedWrapper[] oldWrappers = context.extensionWrappers; if (oldWrappers.length == 0) { return; } MappedWrapper[] newWrappers = new MappedWrapper[oldWrappers.length - 1]; if (removeMap(oldWrappers, newWrappers, name)) { context.extensionWrappers = newWrappers; } } else if (path.equals("/")) { context.defaultWrapper = null; } else { String name = path; MappedWrapper[] oldWrappers = context.exactWrappers; if (oldWrappers.length == 0) { return; } MappedWrapper[] newWrappers = new MappedWrapper[oldWrappers.length - 1]; if (removeMap(oldWrappers, newWrappers, name)) { context.exactWrappers = newWrappers; } } } }
@Override public Map<String, ? extends ServletRegistration> getServletRegistrations() { Map<String, ApplicationServletRegistration> result = new HashMap<>(); Container[] wrappers = context.findChildren(); for (Container wrapper : wrappers) { result.put(((Wrapper) wrapper).getName(), new ApplicationServletRegistration((Wrapper) wrapper, context)); } return result; }	@Test(expected = IllegalArgumentException.class) public void testAddServletWithServletNameEmptyString() { getServletContext().addServlet("", (Servlet) null); }
@Override public void setComment(String comment) { this.comment = comment; }	@Override public void setDomain(String domain) { this.domain = domain; }	@Override public void setHttpOnly(boolean httpOnly) { this.httpOnly = httpOnly; }	@Override public void setMaxAge(int maxAge) { this.maxAge = maxAge; }	@Override public void setName(String name) { this.name = name; }	@Override public void setPath(String path) { this.path = path; }	@Override public void setSecure(boolean secure) { this.secure = secure; }
private static SkipConstantResult skipConstant(StringReader input, String constant) throws IOException { int len = constant.length(); int c = input.read(); while (c == 32 || c == 9) { c = input.read(); } for (int i = 0; i < len; i++) { if (i == 0 && c == -1) { return SkipConstantResult.EOF; } if (c != constant.charAt(i)) { input.skip(-(i + 1)); return SkipConstantResult.NOT_FOUND; } if (i != (len - 1)) { c = input.read(); } } return SkipConstantResult.FOUND; }	private static String readLhex(StringReader input) throws IOException { StringBuilder result = new StringBuilder(); boolean quoted = false; int c = input.read(); while (c == 32 || c == 9) { c = input.read(); } if (c == '"') { quoted = true; } else if (c == -1 || !isHex(c)) { return null; } else { if ('A' <= c && c <= 'F') { c -= ('A' - 'a'); } result.append((char) c); } c = input.read(); while (c != -1 && isHex(c)) { if ('A' <= c && c <= 'F') { c -= ('A' - 'a'); } result.append((char) c); c = input.read(); } if (quoted) { if (c != '"') { return null; } } else { input.skip(-1); } if (c != -1 && result.length() == 0) { return null; } else { return result.toString(); } }	private static String readQuotedString(StringReader input, boolean returnQuoted) throws IOException { int c = input.read(); while (c == 32 || c == 9) { c = input.read(); } if (c != '"') { return null; } StringBuilder result = new StringBuilder(); if (returnQuoted) { result.append('\"'); } c = input.read(); while (c != '"') { if (c == -1) { return null; } else if (c == '\\') { c = input.read(); if (returnQuoted) { result.append('\\'); } result.append(c); } else { result.append((char) c); } c = input.read(); } if (returnQuoted) { result.append('\"'); } return result.toString(); }	private static String readQuotedToken(StringReader input) throws IOException { StringBuilder result = new StringBuilder(); boolean quoted = false; int c = input.read(); while (c == 32 || c == 9) { c = input.read(); } if (c == '"') { quoted = true; } else if (c == -1 || !isToken(c)) { return null; } else { result.append((char) c); } c = input.read(); while (c != -1 && isToken(c)) { result.append((char) c); c = input.read(); } if (quoted) { if (c != '"') { return null; } } else { input.skip(-1); } if (c != -1 && result.length() == 0) { return null; } else { return result.toString(); } }	private static String readToken(StringReader input) throws IOException { StringBuilder result = new StringBuilder(); int c = input.read(); while (c == 32 || c == 9) { c = input.read(); } while (c != -1 && isToken(c)) { result.append((char) c); c = input.read(); } input.skip(-1); if (c != -1 && result.length() == 0) { return null; } else { return result.toString(); } }	private static String readTokenOrQuotedString(StringReader input, boolean returnQuoted) throws IOException { // Use mark/reset as skip(-1) fails when reading the last character of input.mark(1); int c = input.read(); input.reset(); if (c == '"') { return readQuotedString(input, returnQuoted); } else { return readToken(input); } }	private static boolean isHex(int c) { try { return isHex[c]; } catch (ArrayIndexOutOfBoundsException ex) { return false; } }	private void doTest(Parameter... parameters) throws IOException { StringBuilder sb = new StringBuilder(); sb.append(TYPES); for (Parameter p : parameters) { sb.append(p.toString()); } StringReader sr = new StringReader(sb.toString()); MediaType m = HttpParser.parseMediaType(sr); assertTrue(m.getParameterCount() == parameters.length); assertEquals(TYPE.trim(), m.getType()); assertEquals(SUBTYPE.trim(), m.getSubtype()); for (int i = 0; i < parameters.length; i++) { assertEquals(parameters[i].getValue().trim(), m.getParameterValue(parameters[i].getName().trim())); } }	@Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(";"); sb.append(name); sb.append("="); sb.append(value); return sb.toString(); }
Thread[] getThreads() { ThreadGroup tg = Thread.currentThread().getThreadGroup(); while (tg.getParent() != null) { tg = tg.getParent(); } int threadCountGuess = tg.activeCount() + 50; Thread[] threads = new Thread[threadCountGuess]; int threadCountActual = tg.enumerate(threads); while (threadCountActual == threadCountGuess) { threadCountGuess *= 2; threads = new Thread[threadCountGuess]; // Note tg.enumerate(Thread[]) silently ignores any threads that threadCountActual = tg.enumerate(threads); } return threads; }
@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (!(request instanceof HttpServletRequest) || !(response instanceof HttpServletResponse) || !headerContainsToken((HttpServletRequest) request, Constants.UPGRADE_HEADER_NAME, Constants.UPGRADE_HEADER_VALUE)) { // Not an HTTP request that includes a valid upgrade request to chain.doFilter(request, response); return; } // HTTP request with an upgrade header for WebSocket present // Validate the rest of the headers and reject the request if that HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; String key; String subProtocol = null; List<Extension> extensions = Collections.emptyList(); if (!headerContainsToken(req, Constants.CONNECTION_HEADER_NAME, Constants.CONNECTION_HEADER_VALUE)) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } if (!headerContainsToken(req, Constants.WS_VERSION_HEADER_NAME, Constants.WS_VERSION_HEADER_VALUE)) { resp.setStatus(426); resp.setHeader(Constants.WS_VERSION_HEADER_NAME, Constants.WS_VERSION_HEADER_VALUE); return; } key = req.getHeader(Constants.WS_KEY_HEADER_NAME); if (key == null) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } WsServerContainer sc = WsServerContainer.getServerContainer(); String path; String pathInfo = req.getPathInfo(); if (pathInfo == null) { path = req.getServletPath(); } else { path = req.getServletPath() + pathInfo; } WsMappingResult mappingResult = sc.findMapping(path); if (mappingResult == null) { // No endpoint registered for the requested path. Let the chain.doFilter(request, response); return; } ServerEndpointConfig sec = mappingResult.getConfig(); String origin = req.getHeader("Origin"); if (!sec.getConfigurator().checkOrigin(origin)) { resp.sendError(HttpServletResponse.SC_FORBIDDEN); return; } List<String> subProtocols = getTokensFromHeader(req, "Sec-WebSocket-Protocol"); if (!subProtocols.isEmpty()) { subProtocol = sec.getConfigurator().getNegotiatedSubprotocol(sec.getSubprotocols(), subProtocols); } // Extensions // Currently no extensions are supported by this implementation resp.setHeader(Constants.UPGRADE_HEADER_NAME, Constants.UPGRADE_HEADER_VALUE); resp.setHeader(Constants.CONNECTION_HEADER_NAME, Constants.CONNECTION_HEADER_VALUE); resp.setHeader(HandshakeResponse.SEC_WEBSOCKET_ACCEPT, getWebSocketAccept(key)); if (subProtocol != null) { resp.setHeader("Sec-WebSocket-Protocol", subProtocol); } if (!extensions.isEmpty()) { StringBuilder sb = new StringBuilder(); Iterator<Extension> iter = extensions.iterator(); sb.append(iter.next()); while (iter.hasNext()) { sb.append(','); sb.append(iter.next().getName()); } resp.setHeader("Sec-WebSocket-Extensions", sb.toString()); } Endpoint ep; try { Class<?> clazz = sec.getEndpointClass(); if (Endpoint.class.isAssignableFrom(clazz)) { ep = (Endpoint) sec.getConfigurator().getEndpointInstance(clazz); } else { ep = new PojoEndpointServer(); } } catch (InstantiationException e) { throw new ServletException(e); } WsHandshakeRequest wsRequest = new WsHandshakeRequest(req); WsHandshakeResponse wsResponse = new WsHandshakeResponse(); sec.getConfigurator().modifyHandshake(sec, wsRequest, wsResponse); wsRequest.finished(); for (Entry<String, List<String>> entry : wsResponse.getHeaders().entrySet()) { for (String headerValue : entry.getValue()) { resp.addHeader(entry.getKey(), headerValue); } } WsHttpUpgradeHandler wsHandler = req.upgrade(WsHttpUpgradeHandler.class); wsHandler.preInit(ep, sec, sc, wsRequest, subProtocol, mappingResult.getPathParams(), req.isSecure()); }
private void doCollection(TagPluginContext ctxt) { ctxt.generateImport("java.util.*"); generateIterators(ctxt); String itemsV = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource("Object " + itemsV + "= "); ctxt.generateAttribute("items"); ctxt.generateJavaSource(";"); String indexV = null, beginV = null, endV = null, stepV = null; if (hasBegin) { beginV = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource("int " + beginV + " = "); ctxt.generateAttribute("begin"); ctxt.generateJavaSource(";"); } if (hasEnd) { indexV = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource("int " + indexV + " = 0;"); endV = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource("int " + endV + " = "); ctxt.generateAttribute("end"); ctxt.generateJavaSource(";"); } if (hasStep) { stepV = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource("int " + stepV + " = "); ctxt.generateAttribute("step"); ctxt.generateJavaSource(";"); } String iterV = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource("Iterator " + iterV + " = null;"); ctxt.generateJavaSource("if (" + itemsV + " instanceof Object[])"); ctxt.generateJavaSource(iterV + "=toIterator((Object[])" + itemsV + ");"); ctxt.generateJavaSource("else if (" + itemsV + " instanceof boolean[])"); ctxt.generateJavaSource(iterV + "=toIterator((boolean[])" + itemsV + ");"); ctxt.generateJavaSource("else if (" + itemsV + " instanceof byte[])"); ctxt.generateJavaSource(iterV + "=toIterator((byte[])" + itemsV + ");"); ctxt.generateJavaSource("else if (" + itemsV + " instanceof char[])"); ctxt.generateJavaSource(iterV + "=toIterator((char[])" + itemsV + ");"); ctxt.generateJavaSource("else if (" + itemsV + " instanceof short[])"); ctxt.generateJavaSource(iterV + "=toIterator((short[])" + itemsV + ");"); ctxt.generateJavaSource("else if (" + itemsV + " instanceof int[])"); ctxt.generateJavaSource(iterV + "=toIterator((int[])" + itemsV + ");"); ctxt.generateJavaSource("else if (" + itemsV + " instanceof long[])"); ctxt.generateJavaSource(iterV + "=toIterator((long[])" + itemsV + ");"); ctxt.generateJavaSource("else if (" + itemsV + " instanceof float[])"); ctxt.generateJavaSource(iterV + "=toIterator((float[])" + itemsV + ");"); ctxt.generateJavaSource("else if (" + itemsV + " instanceof double[])"); ctxt.generateJavaSource(iterV + "=toIterator((double[])" + itemsV + ");"); ctxt.generateJavaSource("else if (" + itemsV + " instanceof Collection)"); ctxt.generateJavaSource(iterV + "=((Collection)" + itemsV + ").iterator();"); ctxt.generateJavaSource("else if (" + itemsV + " instanceof Iterator)"); ctxt.generateJavaSource(iterV + "=(Iterator)" + itemsV + ";"); ctxt.generateJavaSource("else if (" + itemsV + " instanceof Enumeration)"); ctxt.generateJavaSource(iterV + "=toIterator((Enumeration)" + itemsV + ");"); ctxt.generateJavaSource("else if (" + itemsV + " instanceof Map)"); ctxt.generateJavaSource(iterV + "=((Map)" + itemsV + ").entrySet().iterator();"); ctxt.generateJavaSource("if (" + iterV + " != null) {"); if (hasBegin) { String tV = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource("for (int " + tV + "=" + beginV + ";" + tV + ">0 && " + iterV + ".hasNext(); " + tV + "--)"); ctxt.generateJavaSource(iterV + ".next();"); } ctxt.generateJavaSource("while (" + iterV + ".hasNext()){"); if (hasVar) { ctxt.generateJavaSource("_jspx_page_context.setAttribute("); ctxt.generateAttribute("var"); ctxt.generateJavaSource(", " + iterV + ".next());"); } ctxt.generateBody(); if (hasStep) { String tV = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource("for (int " + tV + "=" + stepV + "-1;" + tV + ">0 && " + iterV + ".hasNext(); " + tV + "--)"); ctxt.generateJavaSource(iterV + ".next();"); } if (hasEnd) { if (hasStep) { ctxt.generateJavaSource(indexV + "+=" + stepV + ";"); } else { ctxt.generateJavaSource(indexV + "++;"); } if (hasBegin) { ctxt.generateJavaSource("if(" + beginV + "+" + indexV + ">" + endV + ")"); } else { ctxt.generateJavaSource("if(" + indexV + ">" + endV + ")"); } ctxt.generateJavaSource("break;"); } ctxt.generateJavaSource("}"); ctxt.generateJavaSource("}"); }	public void testBug54242() throws Exception { ByteChunk res = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/test/bug5nnnn/bug54242.jsp", res, null); Assert.assertEquals(HttpServletResponse.SC_OK, rc); String body = res.toString(); Assert.assertTrue(body.contains("OK - 1")); Assert.assertTrue(body.contains("OK - 2")); Assert.assertFalse(body.contains("FAIL")); }
private void processChars() throws SAXException { if (charBuffer == null || directivesOnly) { return; } boolean isAllSpace = true; if (!(current instanceof Node.JspText) && !(current instanceof Node.NamedAttribute)) { for (int i = 0; i < charBuffer.length(); i++) { char ch = charBuffer.charAt(i); if (!(ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t')) { isAllSpace = false; break; } } } if (!isAllSpace && tagDependentPending) { tagDependentPending = false; tagDependentNesting++; } if (tagDependentNesting > 0) { if (charBuffer.length() > 0) { @SuppressWarnings("unused") Node unused = new Node.TemplateText(charBuffer.toString(), startMark, current); } startMark = new Mark(ctxt, path, locator.getLineNumber(), locator.getColumnNumber()); charBuffer = null; return; } if ((current instanceof Node.JspText) || (current instanceof Node.NamedAttribute) || !isAllSpace) { int line = startMark.getLineNumber(); int column = startMark.getColumnNumber(); CharArrayWriter ttext = new CharArrayWriter(); int lastCh = 0, elType = 0; for (int i = 0; i < charBuffer.length(); i++) { int ch = charBuffer.charAt(i); if (ch == '\n') { column = 1; line++; } else { column++; } if ((lastCh == '$' || lastCh == '#') && ch == '{') { elType = lastCh; if (ttext.size() > 0) { @SuppressWarnings("unused") Node unused = new Node.TemplateText(ttext.toString(), startMark, current); ttext.reset(); //We subtract two from the column number to startMark = new Mark(ctxt, path, line, column - 2); } i++; boolean singleQ = false; boolean doubleQ = false; lastCh = 0; for (; ; i++) { if (i >= charBuffer.length()) { throw new SAXParseException(Localizer.getMessage("jsp.error.unterminated", (char) elType + "{"), locator); } ch = charBuffer.charAt(i); if (ch == '\n') { column = 1; line++; } else { column++; } if (lastCh == '\\' && (singleQ || doubleQ)) { ttext.write(ch); lastCh = 0; continue; } if (ch == '}') { @SuppressWarnings("unused") Node unused = new Node.ELExpression((char) elType, ttext.toString(), startMark, current); ttext.reset(); startMark = new Mark(ctxt, path, line, column); break; } if (ch == '"') doubleQ = !doubleQ; } } } } }	public void testBug47977() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0"); tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); tomcat.start(); int rc = getUrl("http://localhost:" + getPort() + "/test/bug47977.jspx", new ByteChunk(), null); assertEquals(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, rc); }	@Test public void testBug48827() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0"); tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); tomcat.start(); Exception e = null; try { getUrl("http://localhost:" + getPort() + "/test/bug48nnn/bug48827.jspx"); } catch (IOException ioe) { e = ioe; } assertNull(e); }
private void doTestTimeoutErrorDispatch(Boolean asyncError, ErrorPageAsyncMode mode) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); TimeoutServlet timeout = new TimeoutServlet(null, null); Wrapper w1 = Tomcat.addServlet(ctx, "time", timeout); w1.setAsyncSupported(true); ctx.addServletMapping("/async", "time"); NonAsyncServlet nonAsync = new NonAsyncServlet(); Wrapper w2 = Tomcat.addServlet(ctx, "nonAsync", nonAsync); w2.setAsyncSupported(true); ctx.addServletMapping("/error/nonasync", "nonAsync"); AsyncErrorPage asyncErrorPage = new AsyncErrorPage(mode); Wrapper w3 = Tomcat.addServlet(ctx, "asyncErrorPage", asyncErrorPage); w3.setAsyncSupported(true); ctx.addServletMapping("/error/async", "asyncErrorPage"); if (asyncError != null) { ErrorPage ep = new ErrorPage(); ep.setErrorCode(500); if (asyncError.booleanValue()) { ep.setLocation("/error/async"); } else { ep.setLocation("/error/nonasync"); } ctx.addErrorPage(ep); } ctx.addApplicationListener(TrackingRequestListener.class.getName()); TesterAccessLogValve alv = new TesterAccessLogValve(); ctx.getPipeline().addValve(alv); TesterAccessLogValve alvGlobal = new TesterAccessLogValve(); tomcat.getHost().getPipeline().addValve(alvGlobal); tomcat.start(); ByteChunk res = new ByteChunk(); try { getUrl("http://localhost:" + getPort() + "/async", res, null); } catch (IOException ioe) { // Ignore - expected for some error conditions } StringBuilder expected = new StringBuilder(); if (asyncError == null) { expected.append("requestInitialized-TimeoutServletGet-"); // Note: With an error handler the response will be reset and these // will be lost } if (asyncError != null) { if (asyncError.booleanValue()) { expected.append("AsyncErrorPageGet-"); if (mode == ErrorPageAsyncMode.NO_COMPLETE) { expected.append("NoOp-"); } else if (mode == ErrorPageAsyncMode.COMPLETE) { expected.append("Complete-"); } else if (mode == ErrorPageAsyncMode.DISPATCH) { expected.append("Dispatch-NonAsyncServletGet-"); } } else { expected.append("NonAsyncServletGet-"); } } expected.append("requestDestroyed"); Assert.assertEquals(expected.toString(), res.toString()); alvGlobal.validateAccessLog(1, 500, TimeoutServlet.ASYNC_TIMEOUT, TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME); alv.validateAccessLog(1, 500, TimeoutServlet.ASYNC_TIMEOUT, TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME); }	public boolean timeout() { AtomicBoolean result = new AtomicBoolean(); request.getCoyoteRequest().action(ActionCode.ASYNC_TIMEOUT, result); if (result.get()) { ClassLoader oldCL = Thread.currentThread().getContextClassLoader(); ClassLoader newCL = request.getContext().getLoader().getClassLoader(); try { Thread.currentThread().setContextClassLoader(newCL); List<AsyncListenerWrapper> listenersCopy = new ArrayList<>(); listenersCopy.addAll(listeners); for (AsyncListenerWrapper listener : listenersCopy) { try { listener.fireOnTimeout(event); } catch (IOException ioe) { log.warn("onTimeout() failed for listener of type [" + listener.getClass().getName() + "]", ioe); } } request.getCoyoteRequest().action(ActionCode.ASYNC_IS_TIMINGOUT, result); return !result.get(); } finally { Thread.currentThread().setContextClassLoader(oldCL); } } return true; }	@Override public void fireOnComplete() { List<AsyncListenerWrapper> listenersCopy = new ArrayList<>(); listenersCopy.addAll(listeners); ClassLoader oldCL; if (Globals.IS_SECURITY_ENABLED) { PrivilegedAction<ClassLoader> pa = new PrivilegedGetTccl(); oldCL = AccessController.doPrivileged(pa); } else { oldCL = Thread.currentThread().getContextClassLoader(); } ClassLoader newCL = context.getLoader().getClassLoader(); try { if (Globals.IS_SECURITY_ENABLED) { PrivilegedAction<Void> pa = new PrivilegedSetTccl(newCL); AccessController.doPrivileged(pa); } else { Thread.currentThread().setContextClassLoader(newCL); } for (AsyncListenerWrapper listener : listenersCopy) { try { listener.fireOnComplete(event); } catch (IOException ioe) { log.warn("onComplete() failed for listener of type [" + listener.getClass().getName() + "]", ioe); } } } finally { if (Globals.IS_SECURITY_ENABLED) { PrivilegedAction<Void> pa = new PrivilegedSetTccl(oldCL); AccessController.doPrivileged(pa); } else { Thread.currentThread().setContextClassLoader(oldCL); } } }	public void setErrorState(Throwable t, boolean fireOnError) { if (t != null) request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t); request.getCoyoteRequest().action(ActionCode.ASYNC_ERROR, null); if (fireOnError) { AsyncEvent errorEvent = new AsyncEvent(event.getAsyncContext(), event.getSuppliedRequest(), event.getSuppliedResponse(), t); List<AsyncListenerWrapper> listenersCopy = new ArrayList<>(); listenersCopy.addAll(listeners); for (AsyncListenerWrapper listener : listenersCopy) { try { listener.fireOnError(errorEvent); } catch (IOException ioe) { log.warn("onError() failed for listener of type [" + listener.getClass().getName() + "]", ioe); } } } AtomicBoolean result = new AtomicBoolean(); request.getCoyoteRequest().action(ActionCode.ASYNC_IS_ERROR, result); if (result.get()) { if (servletResponse instanceof HttpServletResponse) { ((HttpServletResponse) servletResponse).setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); } Host host = (Host) context.getParent(); Valve stdHostValve = host.getPipeline().getBasic(); if (stdHostValve instanceof StandardHostValve) { ((StandardHostValve) stdHostValve).throwable(request, request.getResponse(), t); } request.getCoyoteRequest().action(ActionCode.ASYNC_IS_ERROR, result); if (result.get()) { // Still in the error state. The error page did not call complete(); } } }	public void setStarted(Context context, ServletRequest request, ServletResponse response, boolean originalRequestResponse) { this.request.getCoyoteRequest().action(ActionCode.ASYNC_START, this); this.context = context; this.servletRequest = request; this.servletResponse = response; this.hasOriginalRequestAndResponse = originalRequestResponse; this.event = new AsyncEvent(this, request, response); List<AsyncListenerWrapper> listenersCopy = new ArrayList<>(); listenersCopy.addAll(listeners); for (AsyncListenerWrapper listener : listenersCopy) { try { listener.fireOnStartAsync(event); } catch (IOException ioe) { log.warn("onStartAsync() failed for listener of type [" + listener.getClass().getName() + "]", ioe); } } listeners.clear(); }	@Test public void testCommitOnComplete() throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); AsyncStatusServlet asyncStatusServlet = new AsyncStatusServlet(HttpServletResponse.SC_BAD_REQUEST); Wrapper wrapper = Tomcat.addServlet(ctx, "asyncStatusServlet", asyncStatusServlet); wrapper.setAsyncSupported(true); ctx.addServletMapping("/asyncStatusServlet", "asyncStatusServlet"); TesterAccessLogValve alv = new TesterAccessLogValve(); ctx.getPipeline().addValve(alv); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/asyncStatusServlet"); int rc = getUrl(url.toString(), new ByteChunk(), null); assertEquals(HttpServletResponse.SC_BAD_REQUEST, rc); // Without this test may complete before access log has a chance to log Thread.sleep(REQUEST_TIME); alv.validateAccessLog(1, HttpServletResponse.SC_BAD_REQUEST, 0, REQUEST_TIME); }
private void postWorkDirectory() { String workDir = getWorkDir(); if (workDir == null || workDir.length() == 0) { String hostName = null; String engineName = null; String hostWorkDir = null; Container parentHost = getParent(); if (parentHost != null) { hostName = parentHost.getName(); if (parentHost instanceof StandardHost) { hostWorkDir = ((StandardHost) parentHost).getWorkDir(); } Container parentEngine = parentHost.getParent(); if (parentEngine != null) { engineName = parentEngine.getName(); } } if ((hostName == null) || (hostName.length() < 1)) hostName = "_"; if ((engineName == null) || (engineName.length() < 1)) engineName = "_"; String temp = getName(); if (temp.startsWith("/")) temp = temp.substring(1); temp = temp.replace('/', '_'); temp = temp.replace('\\', '_'); if (temp.length() < 1) temp = ContextName.ROOT_NAME; if (hostWorkDir != null) { workDir = hostWorkDir + File.separator + temp; } else { workDir = "work" + File.separator + engineName + File.separator + hostName + File.separator + temp; } setWorkDir(workDir); } File dir = new File(workDir); if (!dir.isAbsolute()) { String catalinaHomePath = null; try { catalinaHomePath = getCatalinaBase().getCanonicalPath(); dir = new File(catalinaHomePath, workDir); } catch (IOException e) { log.warn(sm.getString("standardContext.workCreateException", workDir, catalinaHomePath, getName()), e); } } if (!dir.mkdirs() && !dir.isDirectory()) { log.warn(sm.getString("standardContext.workCreateFail", dir, getName())); } if (context == null) { getServletContext(); } context.setAttribute(ServletContext.TEMPDIR, dir); context.setAttributeReadOnly(ServletContext.TEMPDIR); }
public WsMappingResult findMapping(String path) { ServerEndpointConfig sec = configExactMatchMap.get(path); if (sec != null) { return new WsMappingResult(sec, Collections.EMPTY_MAP); } UriTemplate pathUriTemplate = new UriTemplate(path); Integer key = Integer.valueOf(pathUriTemplate.getSegmentCount()); SortedSet<TemplatePathMatch> templateMatches = configTemplateMatchMap.get(key); // List is in alphabetical order of normalised templates. Map<String, String> pathParams = null; for (TemplatePathMatch templateMatch : templateMatches) { pathParams = templateMatch.getUriTemplate().match(pathUriTemplate); if (pathParams != null) { sec = templateMatch.getConfig(); break; } } if (sec == null) { return null; } if (!PojoEndpointServer.class.isAssignableFrom(sec.getEndpointClass())) { sec.getUserProperties().put(PojoEndpointServer.POJO_PATH_PARAM_KEY, pathParams); } return new WsMappingResult(sec, pathParams); }	@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (!(request instanceof HttpServletRequest) || !(response instanceof HttpServletResponse) || !headerContainsToken((HttpServletRequest) request, Constants.UPGRADE_HEADER_NAME, Constants.UPGRADE_HEADER_VALUE)) { // Note an HTTP request that includes a valid upgrade request to chain.doFilter(request, response); return; } // HTTP request with an upgrade header for WebSocket present // Validate the rest of the headers and reject the request if that HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; String key; String subProtocol = null; List<Extension> extensions = Collections.emptyList(); if (!headerContainsToken(req, Constants.CONNECTION_HEADER_NAME, Constants.CONNECTION_HEADER_VALUE)) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } if (!headerContainsToken(req, Constants.WS_VERSION_HEADER_NAME, Constants.WS_VERSION_HEADER_VALUE)) { resp.setStatus(426); resp.setHeader(Constants.WS_VERSION_HEADER_NAME, Constants.WS_VERSION_HEADER_VALUE); return; } key = req.getHeader(Constants.WS_KEY_HEADER_NAME); if (key == null) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } WsServerContainer sc = WsServerContainer.getServerContainer(); String path; String pathInfo = req.getPathInfo(); if (pathInfo == null) { path = req.getServletPath(); } else { path = req.getServletPath() + pathInfo; } WsMappingResult mappingResult = sc.findMapping(path); ServerEndpointConfig sec = mappingResult.getConfig(); String origin = req.getHeader("Origin"); if (!sec.getConfigurator().checkOrigin(origin)) { resp.sendError(HttpServletResponse.SC_FORBIDDEN); return; } List<String> subProtocols = getTokensFromHeader(req, "Sec-WebSocket-Protocol"); if (!subProtocols.isEmpty()) { subProtocol = sec.getConfigurator().getNegotiatedSubprotocol(sec.getSubprotocols(), subProtocols); } // Extensions // Currently no extensions are supported by this implementation resp.setHeader(Constants.UPGRADE_HEADER_NAME, Constants.UPGRADE_HEADER_VALUE); resp.setHeader(Constants.CONNECTION_HEADER_NAME, Constants.CONNECTION_HEADER_VALUE); resp.setHeader(HandshakeResponse.SEC_WEBSOCKET_ACCEPT, getWebSocketAccept(key)); if (subProtocol != null) { resp.setHeader("Sec-WebSocket-Protocol", subProtocol); } if (!extensions.isEmpty()) { StringBuilder sb = new StringBuilder(); Iterator<Extension> iter = extensions.iterator(); sb.append(iter.next()); while (iter.hasNext()) { sb.append(','); sb.append(iter.next().getName()); } resp.setHeader("Sec-WebSocket-Extensions", sb.toString()); } Endpoint ep; try { Class<?> clazz = sec.getEndpointClass(); if (Endpoint.class.isAssignableFrom(clazz)) { ep = (Endpoint) sec.getConfigurator().getEndpointInstance(clazz); } else { ep = new PojoEndpointServer(); } } catch (InstantiationException e) { throw new ServletException(e); } WsHandshakeRequest wsRequest = new WsHandshakeRequest(req); WsHandshakeResponse wsResponse = new WsHandshakeResponse(); sec.getConfigurator().modifyHandshake(sec, wsRequest, wsResponse); wsRequest.finished(); for (Entry<String, List<String>> entry : wsResponse.getHeaders().entrySet()) { for (String headerValue : entry.getValue()) { resp.addHeader(entry.getKey(), headerValue); } } WsHttpUpgradeHandler wsHandler = req.upgrade(WsHttpUpgradeHandler.class); wsHandler.preInit(ep, sec, sc, wsRequest, subProtocol, mappingResult.getPathParams(), req.isSecure()); }	public void setServletContext(ServletContext servletContext) { if (this.servletContext == servletContext) { return; } this.servletContext = servletContext; String value = servletContext.getInitParameter(Constants.BINARY_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM); if (value != null) { setDefaultMaxBinaryMessageBufferSize(Integer.parseInt(value)); } value = servletContext.getInitParameter(Constants.TEXT_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM); if (value != null) { setDefaultMaxTextMessageBufferSize(Integer.parseInt(value)); } FilterRegistration fr = servletContext.addFilter(WsFilter.class.getName(), WsFilter.class); fr.addMappingForUrlPatterns(null, false, "/*"); }
@OnClose public void end() { try { session.close(); } catch (IOException e) { e.printStackTrace(); } connections.remove(this); String message = String.format("* %s %s", nickname, "has disconnected."); broadcast(message); }
private SSLEngine createSSLEngine(Map<String, Object> userProperties) throws DeploymentException { try { SSLContext sslContext = SSLContext.getInstance("TLS"); String sslTrustStoreValue = (String) userProperties.get(SSL_TRUSTSTORE_PROPERTY); if (sslTrustStoreValue != null) { String sslTrustStorePwdValue = (String) userProperties.get(SSL_TRUSTSTORE_PWD_PROPERTY); if (sslTrustStorePwdValue == null) { sslTrustStorePwdValue = SSL_TRUSTSTORE_PWD_DEFAULT; } File keyStoreFile = new File(sslTrustStoreValue); KeyStore ks = KeyStore.getInstance("JKS"); try (InputStream is = new FileInputStream(keyStoreFile)) { ks.load(is, sslTrustStorePwdValue.toCharArray()); } TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(ks); sslContext.init(null, tmf.getTrustManagers(), null); } else { sslContext.init(null, null, null); } SSLEngine engine = sslContext.createSSLEngine(); String sslProtocolsValue = (String) userProperties.get(SSL_PROTOCOLS_PROPERTY); if (sslProtocolsValue != null) { engine.setEnabledProtocols(sslProtocolsValue.split(",")); } engine.setUseClientMode(true); return engine; } catch (Exception e) { throw new DeploymentException("TODO", e); } }	@Override public Session connectToServer(Endpoint endpoint, ClientEndpointConfig clientEndpointConfiguration, URI path) throws DeploymentException { boolean secure = false; String scheme = path.getScheme(); if (!("ws".equalsIgnoreCase(scheme) || "wss".equalsIgnoreCase(scheme))) { throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme", scheme)); } String host = path.getHost(); if (host == null) { throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost")); } int port = path.getPort(); Map<String, List<String>> reqHeaders = createRequestHeaders(host, port, clientEndpointConfiguration.getPreferredSubprotocols()); clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders); ByteBuffer request = createRequest(path, reqHeaders); SocketAddress sa; if (port == -1) { if ("ws".equalsIgnoreCase(scheme)) { sa = new InetSocketAddress(host, 80); } else if ("wss".equalsIgnoreCase(scheme)) { sa = new InetSocketAddress(host, 443); secure = true; } else { throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidScheme")); } } else { if ("wss".equalsIgnoreCase(scheme)) { secure = true; } sa = new InetSocketAddress(host, port); } AsynchronousSocketChannel socketChannel; try { socketChannel = AsynchronousSocketChannel.open(); } catch (IOException ioe) { throw new DeploymentException("TODO", ioe); } Future<Void> fConnect = socketChannel.connect(sa); AsyncChannelWrapper channel; if (secure) { SSLEngine sslEngine = createSSLEngine(clientEndpointConfiguration.getUserProperties()); channel = new AsyncChannelWrapperSecure(socketChannel, sslEngine); } else { channel = new AsyncChannelWrapperNonSecure(socketChannel); } ByteBuffer response; String subProtocol; try { fConnect.get(); Future<Void> fHandshake = channel.handshake(); fHandshake.get(); int toWrite = request.limit(); Future<Integer> fWrite = channel.write(request); Integer thisWrite = fWrite.get(); toWrite -= thisWrite.intValue(); while (toWrite > 0) { fWrite = channel.write(request); thisWrite = fWrite.get(); toWrite -= thisWrite.intValue(); } response = ByteBuffer.allocate(maxBinaryMessageBufferSize); HandshakeResponse handshakeResponse = processResponse(response, channel); clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse); List<String> values = handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME); if (values == null || values.size() == 0) { subProtocol = null; } else if (values.size() == 1) { subProtocol = values.get(0); } else { throw new DeploymentException(sm.getString("Sec-WebSocket-Protocol")); } } catch (ExecutionException | InterruptedException | SSLException e) { throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"), e); } WsRemoteEndpointImplClient wsRemoteEndpointClient = new WsRemoteEndpointImplClient(channel); WsSession wsSession = new WsSession(endpoint, wsRemoteEndpointClient, this, null, null, null, null, subProtocol, Collections.EMPTY_MAP, false, clientEndpointConfiguration.getEncoders(), clientEndpointConfiguration.getUserProperties()); endpoint.onOpen(wsSession, clientEndpointConfiguration); registerSession(endpoint.getClass(), wsSession); @SuppressWarnings("unused") WsFrameClient wsFrameClient = new WsFrameClient(response, channel, wsSession); return wsSession; }	@Override public int getProcessPeriod() { return processPeriod; }
public UriTemplate getUriTemplate() { return uriTemplate; }	@Override public void addEndpoint(Class<?> pojo) throws DeploymentException { ServerEndpoint annotation = pojo.getAnnotation(ServerEndpoint.class); if (annotation == null) { throw new DeploymentException(sm.getString("serverContainer.missingAnnotation", pojo.getName())); } String path = annotation.value(); UriTemplate uriTemplate = new UriTemplate(path); PojoMethodMapping methodMapping = new PojoMethodMapping(pojo, annotation.decoders(), path); ServerEndpointConfig sec; Class<? extends Configurator> configuratorClazz = annotation.configurator(); Configurator configurator = null; if (!configuratorClazz.equals(Configurator.class)) { try { configurator = annotation.configurator().newInstance(); } catch (InstantiationException | IllegalAccessException e) { throw new IllegalStateException(sm.getString("serverContainer.configuratorFail", annotation.configurator().getName(), pojo.getClass().getName()), e); } } sec = ServerEndpointConfig.Builder.create(pojo, path).decoders(Arrays.asList(annotation.decoders())).encoders(Arrays.asList(annotation.encoders())).configurator(configurator).build(); sec.getUserProperties().put(PojoEndpointServer.POJO_METHOD_MAPPING_KEY, methodMapping); if (uriTemplate.hasParameters()) { Integer key = Integer.valueOf(uriTemplate.getSegmentCount()); SortedSet<TemplatePathMatch> templateMatches = configTemplateMatchMap.get(key); if (templateMatches == null) { templateMatches = new TreeSet<>(new TemplatePathMatchComparator()); configTemplateMatchMap.put(key, templateMatches); } templateMatches.add(new TemplatePathMatch(sec, uriTemplate)); } else { configExactMatchMap.put(path, sec); } }	@Override public void addEndpoint(ServerEndpointConfig sec) throws DeploymentException { if (servletContext == null) { throw new DeploymentException(sm.getString("serverContainer.servletContextMissing")); } String path = sec.getPath(); UriTemplate uriTemplate = new UriTemplate(path); if (uriTemplate.hasParameters()) { Integer key = Integer.valueOf(uriTemplate.getSegmentCount()); SortedSet<TemplatePathMatch> templateMatches = configTemplateMatchMap.get(key); if (templateMatches == null) { templateMatches = new TreeSet<>(); configTemplateMatchMap.put(key, templateMatches); } templateMatches.add(new TemplatePathMatch(sec, uriTemplate)); } else { configExactMatchMap.put(path, sec); } }
public void onSynStream(SpdyStream str) throws IOException { this.spdyStream = str; SpdyFrame frame = str.reqFrame; // We need to make a copy - the frame buffer will be reused. // We use the 'wrap' methods of MimeHeaders - which should be RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); MimeHeaders mimeHeaders = request.getMimeHeaders(); mimeHeaders.setLimit(endpoint.getMaxHeaderCount()); for (int i = 0; i < frame.nvCount; i++) { int nameLen = frame.read16(); if (nameLen > frame.remaining()) { throw new IOException("Name too long"); } keyBuffer.setBytes(frame.data, frame.off, nameLen); if (keyBuffer.equals("method")) { frame.advance(nameLen); int valueLen = frame.read16(); if (valueLen > frame.remaining()) { throw new IOException("Name too long"); } request.method().setBytes(frame.data, frame.off, valueLen); frame.advance(valueLen); } else if (keyBuffer.equals("url")) { frame.advance(nameLen); int valueLen = frame.read16(); if (valueLen > frame.remaining()) { throw new IOException("Name too long"); } request.requestURI().setBytes(frame.data, frame.off, valueLen); if (SpdyContext.debug) { System.err.println("URL= " + request.requestURI()); } frame.advance(valueLen); } else if (keyBuffer.equals("version")) { frame.advance(nameLen); int valueLen = frame.read16(); if (valueLen > frame.remaining()) { throw new IOException("Name too long"); } frame.advance(valueLen); } else { MessageBytes value = mimeHeaders.addValue(frame.data, frame.off, nameLen); frame.advance(nameLen); int valueLen = frame.read16(); if (valueLen > frame.remaining()) { throw new IOException("Name too long"); } value.setBytes(frame.data, frame.off, valueLen); frame.advance(valueLen); } } onRequest(); }
@Override public void scan(File file) throws IOException { InputStream stream = null; WebXml fragment = new WebXml(); try { File fragmentFile = new File(file, FRAGMENT_LOCATION); if (fragmentFile.isFile()) { stream = new FileInputStream(fragmentFile); InputSource source = new InputSource(fragmentFile.toURI().toURL().toString()); source.setByteStream(stream); parseWebXml(source, fragment, true); } } finally { fragment.setURL(file.toURI().toURL()); if (fragment.getName() == null) { fragment.setName(fragment.getURL().toString()); } fragment.setJarName(file.getName()); fragments.put(fragment.getName(), fragment); } }
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String key; String subProtocol = null; List<Extension> extensions = Collections.emptyList(); if (!headerContainsToken(req, Constants.UPGRADE_HEADER_NAME, Constants.UPGRADE_HEADER_VALUE)) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } if (!headerContainsToken(req, Constants.CONNECTION_HEADER_NAME, Constants.CONNECTION_HEADER_VALUE)) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } if (!headerContainsToken(req, Constants.WS_VERSION_HEADER_NAME, Constants.WS_VERSION_HEADER_VALUE)) { resp.setStatus(426); resp.setHeader(Constants.WS_VERSION_HEADER_NAME, Constants.WS_VERSION_HEADER_VALUE); return; } key = req.getHeader(Constants.WS_KEY_HEADER_NAME); if (key == null) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } WsServerContainer sc = WsServerContainer.getServerContainer(); Map<String, String> pathParameters = sc.getPathParameters(req.getServletPath(), req.getPathInfo()); ServerEndpointConfig sec = sc.getServerEndpointConfiguration(req.getServletPath(), pathParameters); String origin = req.getHeader("Origin"); if (!sec.getConfigurator().checkOrigin(origin)) { resp.sendError(HttpServletResponse.SC_FORBIDDEN); return; } List<String> subProtocols = getTokensFromHeader(req, "Sec-WebSocket-Protocol"); if (!subProtocols.isEmpty()) { subProtocol = sec.getConfigurator().getNegotiatedSubprotocol(sec.getSubprotocols(), subProtocols); } // Extensions // Currently no extensions are supported by this implementation resp.setHeader(Constants.UPGRADE_HEADER_NAME, Constants.UPGRADE_HEADER_VALUE); resp.setHeader(Constants.CONNECTION_HEADER_NAME, Constants.CONNECTION_HEADER_VALUE); resp.setHeader(HandshakeResponse.SEC_WEBSOCKET_ACCEPT, getWebSocketAccept(key)); if (subProtocol != null) { resp.setHeader("Sec-WebSocket-Protocol", subProtocol); } if (!extensions.isEmpty()) { StringBuilder sb = new StringBuilder(); Iterator<Extension> iter = extensions.iterator(); sb.append(iter.next()); while (iter.hasNext()) { sb.append(','); sb.append(iter.next().getName()); } resp.setHeader("Sec-WebSocket-Extensions", sb.toString()); } Endpoint ep; try { Class<?> clazz = sec.getEndpointClass(); if (Endpoint.class.isAssignableFrom(clazz)) { ep = (Endpoint) sec.getEndpointClass().newInstance(); } else { ep = new PojoEndpointServer(); } } catch (InstantiationException | IllegalAccessException e) { throw new ServletException(e); } WsHandshakeRequest wsRequest = new WsHandshakeRequest(req); WsHandshakeResponse wsResponse = new WsHandshakeResponse(); sec.getConfigurator().modifyHandshake(sec, wsRequest, wsResponse); wsRequest.finished(); for (Entry<String, List<String>> entry : wsResponse.getHeaders().entrySet()) { for (String headerValue : entry.getValue()) { resp.addHeader(entry.getKey(), headerValue); } } WsHttpUpgradeHandler wsHandler = req.upgrade(WsHttpUpgradeHandler.class); wsHandler.preInit(ep, sec, sc, wsRequest, subProtocol, pathParameters, req.isSecure()); }
private boolean processDataControl() throws IOException { if (!appendPayloadToMessage(controlBufferBinary)) { return false; } controlBufferBinary.flip(); if (opCode == Constants.OPCODE_CLOSE) { closed = true; String reason = null; int code = CloseCodes.NORMAL_CLOSURE.getCode(); if (controlBufferBinary.remaining() == 1) { controlBufferBinary.clear(); throw new WsIOException(new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.oneByteCloseCode"))); } if (controlBufferBinary.remaining() > 1) { code = controlBufferBinary.getShort(); if (controlBufferBinary.remaining() > 0) { CoderResult cr = utf8DecoderControl.decode(controlBufferBinary, controlBufferText, true); if (cr.isError()) { controlBufferBinary.clear(); controlBufferText.clear(); throw new WsIOException(new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.invalidUtf8Close"))); } // There will be no overflow as the output buffer is big // enough. There will be no underflow as all the data is controlBufferText.flip(); reason = controlBufferText.toString(); } } wsSession.onClose(new CloseReason(Util.getCloseCode(code), reason)); } else if (opCode == Constants.OPCODE_PING) { if (wsSession.isOpen()) { wsSession.getBasicRemote().sendPong(controlBufferBinary); } } else if (opCode == Constants.OPCODE_PONG) { MessageHandler.Whole<PongMessage> mhPong = wsSession.getPongMessageHandler(); if (mhPong != null) { mhPong.onMessage(new WsPongMessage(controlBufferBinary)); } } else { controlBufferBinary.clear(); throw new WsIOException(new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.invalidOpCode", Integer.valueOf(opCode)))); } controlBufferBinary.clear(); newFrame(); return true; }	private void processSocketRead() throws IOException { while (response.hasRemaining()) { int remaining = response.remaining(); int toCopy = Math.min(remaining, inputBuffer.length - writePos); // Copy remaining bytes read in HTTP phase to input buffer used by response.get(inputBuffer, writePos, toCopy); writePos += toCopy; processInputBuffer(); } response.clear(); channel.read(response, null, handler); }	protected static long byteArrayToLong(byte[] b, int start, int len) throws IOException { if (len > 8) { throw new IOException(sm.getString("wsFrame.byteToLongFail", Long.valueOf(len))); } int shift = 0; long result = 0; for (int i = start + len - 1; i >= start; i--) { result = result + ((b[i] & 0xFF) << shift); shift += 8; } return result; }	protected void processInputBuffer() throws IOException { while (true) { wsSession.updateLastActive(); if (state == State.NEW_FRAME) { if (closed) { throw new IOException(sm.getString("wsFrame.closed")); } if (!processInitialHeader()) { break; } } if (state == State.PARTIAL_HEADER) { if (!processRemainingHeader()) { break; } } if (state == State.DATA) { if (!processData()) { break; } } } }	public void onDataAvailable() throws IOException { synchronized (connectionReadLock) { while (sis.isReady()) { int read = sis.read(inputBuffer, writePos, inputBuffer.length - writePos); if (read == 0) { return; } if (read == -1) { throw new EOFException(); } writePos += read; processInputBuffer(); } } }
public void testMaxCacheSize() throws Exception { init(); config(true, false, 100); Connection con1 = datasource.getConnection(); Connection con2 = datasource.getConnection(); for (int i = 0; i < 120; i++) { @SuppressWarnings("resource") Connection con = (i % 2 == 0) ? con1 : con2; PreparedStatement ps = con.prepareStatement("select " + i); ps.close(); } Assert.assertEquals(100, interceptor.getCacheSize().get()); con1.close(); con2.close(); }	@Override public void closeInvoked() { boolean shouldClose = true; if (cacheSize.get() < maxCacheSize) { CachedStatement proxy = new CachedStatement(getDelegate(), getSql()); try { Object actualProxy = getConstructor().newInstance(new Object[] { proxy }); proxy.setActualProxy(actualProxy); proxy.setConnection(getConnection()); proxy.setConstructor(getConstructor()); if (cacheStatement(proxy)) { proxy.cached = true; shouldClose = false; } } catch (Exception x) { removeStatement(proxy); } } closed = true; delegate = null; if (shouldClose) { super.closeInvoked(); } }	@Test public void testPreparedStatementCache2() throws Exception { init(); config(false, false, 100); Connection con = datasource.getConnection(); PreparedStatement ps1 = con.prepareStatement("select 1"); PreparedStatement ps2 = con.prepareStatement("select 1"); Assert.assertEquals(0, interceptor.getCacheSize().get()); ps1.close(); Assert.assertTrue(ps1.isClosed()); Assert.assertEquals(0, interceptor.getCacheSize().get()); PreparedStatement ps3 = con.prepareStatement("select 1"); Assert.assertEquals(0, interceptor.getCacheSize().get()); ps2.close(); Assert.assertTrue(ps2.isClosed()); ps3.close(); Assert.assertTrue(ps3.isClosed()); Assert.assertEquals(0, interceptor.getCacheSize().get()); }
@Override public String toString() { StringBuilder buf = new StringBuilder("ConnectionPool["); try { String[] fields = DataSourceFactory.ALL_PROPERTIES; for (int i = 0; i < fields.length; i++) { final String[] prefix = new String[] { "get", "is" }; for (int j = 0; j < prefix.length; j++) { String name = prefix[j] + fields[i].substring(0, 1).toUpperCase(Locale.ENGLISH) + fields[i].substring(1); Method m = null; try { m = getClass().getMethod(name); } catch (NoSuchMethodException nm) { continue; } buf.append(fields[i]); buf.append("="); buf.append(m.invoke(this, new Object[0])); buf.append("; "); break; } } } catch (Exception x) { x.printStackTrace(); } return buf.toString(); }
private void sendCloseMessage(CloseReason closeReason) { ByteBuffer msg = ByteBuffer.allocate(125); msg.putShort((short) closeReason.getCloseCode().getCode()); String reason = closeReason.getReasonPhrase(); if (reason != null && reason.length() > 0) { msg.put(reason.getBytes(UTF8)); } msg.flip(); try { wsRemoteEndpoint.startMessageBlock(Constants.OPCODE_CLOSE, msg, true); } catch (IOException ioe) { // Failed to send close message. Close the socket and let the caller log.error(sm.getString("wsSession.sendCloseFail"), ioe); wsRemoteEndpoint.close(); localEndpoint.onError(this, ioe); } finally { webSocketContainer.unregisterSession(localEndpoint.getClass(), this); Thread t = Thread.currentThread(); ClassLoader cl = t.getContextClassLoader(); t.setContextClassLoader(applicationClassLoader); try { localEndpoint.onClose(this, closeReason); } finally { t.setContextClassLoader(cl); } } }	protected void expire() { long timeout = maxIdleTimeout; if (timeout < 1) { return; } if (System.currentTimeMillis() - lastActive > timeout) { try { close(new CloseReason(CloseCodes.GOING_AWAY, sm.getString("wsSession.timeout"))); } catch (IOException e) { log.warn(sm.getString("wsSession.expireFailed"), e); } } }	@Override public Map<String, String> getPathParameters() { return pathParameters; }	@Override public Map<String, Object> getUserProperties() { return userProperties; }	@Override public List<Extension> getNegotiatedExtensions() { return Collections.EMPTY_LIST; }	@Override public String getProtocolVersion() { return Constants.WS_VERSION_HEADER_VALUE; }	@Override public String getQueryString() { return queryString; }	@Override public Map<String, List<String>> getRequestParameterMap() { return requestParameterMap; }	@Override public WebSocketContainer getContainer() { return webSocketContainer; }	@Override public boolean isSecure() { return secure; }	@Override public int getMaxBinaryMessageBufferSize() { return maxBinaryMessageBufferSize; }	@Override public RemoteEndpoint.Basic getBasicRemote() { return remoteEndpointBasic; }	@Override public long getMaxIdleTimeout() { return maxIdleTimeout; }	@Override public Set<MessageHandler> getMessageHandlers() { Set<MessageHandler> result = new HashSet<>(); if (binaryMessageHandler != null) { result.add(binaryMessageHandler); } if (textMessageHandler != null) { result.add(textMessageHandler); } if (pongMessageHandler != null) { result.add(pongMessageHandler); } return result; }	@Override public void close(CloseReason closeReason) throws IOException { if (state != State.OPEN) { return; } synchronized (stateLock) { if (state != State.OPEN) { return; } state = State.CLOSING; sendCloseMessage(closeReason); } }	@Override public void removeMessageHandler(MessageHandler listener) { if (listener == null) { return; } if (listener.equals(textMessageHandler)) { textMessageHandler = null; } else if (listener.equals(binaryMessageHandler)) { binaryMessageHandler = null; } else if (listener.equals(pongMessageHandler)) { pongMessageHandler = null; } throw new IllegalStateException(sm.getString("wsSession.removeHandlerFailed", listener)); }	@Override public void setMaxBinaryMessageBufferSize(int max) { this.maxBinaryMessageBufferSize = max; }	@Override public void setMaxIdleTimeout(long timeout) { this.maxIdleTimeout = timeout; }	@Override public void setMaxTextMessageBufferSize(int max) { this.maxTextMessageBufferSize = max; }	@Test public void testSessionExpiryContainer() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(TesterEchoServer.Config.class.getName()); tomcat.start(); WsWebSocketContainer wsContainer = (WsWebSocketContainer) ContainerProvider.getWebSocketContainer(); wsContainer.setDefaultMaxSessionIdleTimeout(5000); wsContainer.setProcessPeriod(1); connectToEchoServerBasic(wsContainer, EndpointA.class); connectToEchoServerBasic(wsContainer, EndpointA.class); Session s3a = connectToEchoServerBasic(wsContainer, EndpointA.class); Set<Session> setA = s3a.getOpenSessions(); Assert.assertEquals(3, setA.size()); int count = 0; setA = s3a.getOpenSessions(); while (setA.size() > 0 && count < 8) { count++; Thread.sleep(1000); setA = s3a.getOpenSessions(); } if (setA.size() > 0) { Assert.fail("There were [" + setA.size() + "] open sessions"); } }	@Test public void testSessionExpirySession() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(TesterEchoServer.Config.class.getName()); tomcat.start(); WsWebSocketContainer wsContainer = (WsWebSocketContainer) ContainerProvider.getWebSocketContainer(); wsContainer.setDefaultMaxSessionIdleTimeout(5000); wsContainer.setProcessPeriod(1); Session s1a = connectToEchoServerBasic(wsContainer, EndpointA.class); s1a.setMaxIdleTimeout(3000); Session s2a = connectToEchoServerBasic(wsContainer, EndpointA.class); s2a.setMaxIdleTimeout(6000); Session s3a = connectToEchoServerBasic(wsContainer, EndpointA.class); s3a.setMaxIdleTimeout(9000); Set<Session> setA = s3a.getOpenSessions(); int expected = 3; while (expected > 0) { Assert.assertEquals(expected, setA.size()); int count = 0; while (setA.size() == expected && count < 5) { count++; Thread.sleep(1000); setA = s3a.getOpenSessions(); } expected--; } Assert.assertEquals(0, setA.size()); }	void onClose(CloseReason closeReason) { boolean sendCloseMessage = false; synchronized (stateLock) { if (state == State.OPEN) { sendCloseMessage = true; } state = State.CLOSED; if (sendCloseMessage) { sendCloseMessage(closeReason); } wsRemoteEndpoint.close(); } }
@SuppressWarnings({ "unchecked", "rawtypes" }) public void sendObjectByCompletion(Object obj, SendHandler completion) { Encoder encoder = findEncoder(obj); try { if (encoder instanceof Encoder.Text) { String msg = ((Encoder.Text) encoder).encode(obj); sendStringByCompletion(msg, completion); } else if (encoder instanceof Encoder.TextStream) { Writer w = getSendWriter(); ((Encoder.TextStream) encoder).encode(obj, w); } else if (encoder instanceof Encoder.Binary) { ByteBuffer msg = ((Encoder.Binary) encoder).encode(obj); sendBytesByCompletion(msg, completion); } else if (encoder instanceof Encoder.BinaryStream) { OutputStream os = getSendStream(); ((Encoder.BinaryStream) encoder).encode(obj, os); } else { throw new EncodeException(obj, sm.getString("wsRemoteEndpoint.noEncoder", obj.getClass())); } } catch (EncodeException | IOException e) { SendResult sr = new SendResult(e); completion.onResult(sr); } }
private static Object coerceToType(Class<?> type, String value) { if (type.equals(String.class)) { return value; } else if (type.equals(boolean.class) || type.equals(Boolean.class)) { return Boolean.valueOf(value); } else if (type.equals(byte.class) || type.equals(Byte.class)) { return Byte.valueOf(value); } else if (value.length() == 1 && (type.equals(char.class) || type.equals(Character.class))) { return Character.valueOf(value.charAt(0)); } else if (type.equals(double.class) || type.equals(Double.class)) { return Double.valueOf(value); } else if (type.equals(float.class) || type.equals(Float.class)) { return Float.valueOf(value); } else if (type.equals(int.class) || type.equals(Integer.class)) { return Integer.valueOf(value); } else if (type.equals(long.class) || type.equals(Long.class)) { return Long.valueOf(value); } else if (type.equals(short.class) || type.equals(Short.class)) { return Short.valueOf(value); } else { throw new IllegalArgumentException(sm.getString("pojoMethodMapping.invalidType", value, type.getName())); } }	@Override protected Object decode(ByteBuffer message) throws DecodeException { for (Decoder decoder : decoders) { if (decoder instanceof Binary) { if (((Binary<?>) decoder).willDecode(message)) { return ((Binary<?>) decoder).decode(message); } } else { byte[] array = new byte[message.limit() - message.position()]; message.get(array); ByteArrayInputStream bais = new ByteArrayInputStream(array); try { return ((BinaryStream<?>) decoder).decode(bais); } catch (IOException ioe) { throw new DecodeException(message, sm.getString("pojoMessageHandlerWhole.decodeIoFail"), ioe); } } } return null; }	@Override protected Object decode(String message) throws DecodeException { for (Decoder decoder : decoders) { if (decoder instanceof Text) { if (((Text<?>) decoder).willDecode(message)) { return ((Text<?>) decoder).decode(message); } } else { StringReader r = new StringReader(message); try { return ((TextStream<?>) decoder).decode(r); } catch (IOException ioe) { throw new DecodeException(message, sm.getString("pojoMessageHandlerWhole.decodeIoFail"), ioe); } } } return null; }	public MessageHandler getMessageHandler(Object pojo, Map<String, String> pathParameters, Session session, EndpointConfig config) { Object[] params = new Object[m.getParameterTypes().length]; for (Map.Entry<Integer, PojoPathParam> entry : indexPathParams.entrySet()) { PojoPathParam pathParam = entry.getValue(); String valueString = pathParameters.get(pathParam.getName()); Object value = null; if (valueString != null) { value = coerceToType(pathParam.getType(), valueString); } params[entry.getKey().intValue()] = value; } MessageHandler mh = null; if (indexBoolean == -1) { if (indexString != -1) { mh = new PojoMessageHandlerWholeText(pojo, m, session, config, params, indexString, false, indexSession); } else if (indexByteArray != -1) { mh = new PojoMessageHandlerWholeBinary(pojo, m, session, config, params, indexByteArray, true, indexSession); } else if (indexByteBuffer != -1) { mh = new PojoMessageHandlerWholeBinary(pojo, m, session, config, params, indexByteBuffer, false, indexSession); } else { mh = new PojoMessageHandlerWholePong(pojo, m, session, params, indexPong, false, indexSession); } } else { if (indexString != -1) { mh = new PojoMessageHandlerPartialText(pojo, m, session, params, indexString, false, indexBoolean, indexSession); } else if (indexByteArray != -1) { mh = new PojoMessageHandlerPartialBinary(pojo, m, session, params, indexByteArray, true, indexBoolean, indexSession); } else { mh = new PojoMessageHandlerPartialBinary(pojo, m, session, params, indexByteBuffer, false, indexBoolean, indexSession); } } return mh; }	private static Object coerceToType(Class<?> type, String value) { if (type.equals(String.class)) { return value; } else if (type.equals(boolean.class) || type.equals(Boolean.class)) { return Boolean.valueOf(value); } else if (type.equals(byte.class) || type.equals(Byte.class)) { return Byte.valueOf(value); } else if (value.length() == 1 && (type.equals(char.class) || type.equals(Character.class))) { return Character.valueOf(value.charAt(0)); } else if (type.equals(double.class) || type.equals(Double.class)) { return Double.valueOf(value); } else if (type.equals(float.class) || type.equals(Float.class)) { return Float.valueOf(value); } else if (type.equals(int.class) || type.equals(Integer.class)) { return Integer.valueOf(value); } else if (type.equals(long.class) || type.equals(Long.class)) { return Long.valueOf(value); } else if (type.equals(short.class) || type.equals(Short.class)) { return Short.valueOf(value); } else { throw new IllegalArgumentException(sm.getString("pojoMethodMapping.invalidType", value, type.getName())); } }	public Object[] getOnCloseArgs(Map<String, String> pathParameters, Session session) { return buildArgs(onCloseParams, pathParameters, session, null); }	private static Object[] buildArgs(PojoPathParam[] pathParams, Map<String, String> pathParameters, Session session, Throwable throwable) { Object[] result = new Object[pathParams.length]; for (int i = 0; i < pathParams.length; i++) { Class<?> type = pathParams[i].getType(); if (type.equals(Session.class)) { result[i] = session; } else if (type.equals(Throwable.class)) { result[i] = throwable; } else { String name = pathParams[i].getName(); String value = pathParameters.get(name); if (value == null) { result[i] = null; } else { result[i] = coerceToType(type, value); } } } return result; }	public Object[] getOnOpenArgs(Map<String, String> pathParameters, Session session) { return buildArgs(onOpenParams, pathParameters, session, null); }	@Override public final void onClose(Session session, CloseReason closeReason) { if (methodMapping.getOnClose() != null) { try { methodMapping.getOnClose().invoke(pojo, methodMapping.getOnCloseArgs(pathParameters, session)); } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) { log.error(sm.getString("pojoEndpointBase.onCloseFail", pojo.getClass().getName()), e); } } Set<MessageHandler> messageHandlers = session.getMessageHandlers(); for (MessageHandler messageHandler : messageHandlers) { if (messageHandler instanceof PojoMessageHandlerWholeBase<?>) { ((PojoMessageHandlerWholeBase<?>) messageHandler).onClose(); } } }	@Override public final void onMessage(T message) { Object payload; try { payload = decode(message); } catch (DecodeException de) { SessionException se = new SessionException(sm.getString("pojoMessageHandlerWhole.decodeFail"), de, session); ((WsSession) session).getLocal().onError(session, se); return; } if (payload == null) { if (unwrap) { ByteBuffer bb = (ByteBuffer) message; byte[] array = new byte[bb.remaining()]; bb.get(array); payload = array; } else { payload = message; } } Object[] parameters = params.clone(); if (indexSession != -1) { parameters[indexSession] = session; } parameters[indexPayload] = payload; Object result; try { result = method.invoke(pojo, parameters); } catch (IllegalAccessException | InvocationTargetException e) { throw new IllegalArgumentException(); } processResult(result); }	@Override public final void onMessage(T message, boolean last) { Object[] parameters = params.clone(); if (indexBoolean != -1) { parameters[indexBoolean] = Boolean.valueOf(last); } if (indexSession != -1) { parameters[indexSession] = session; } if (unwrap) { parameters[indexPayload] = ((ByteBuffer) message).array(); } else { parameters[indexPayload] = message; } Object result; try { result = method.invoke(pojo, parameters); } catch (IllegalAccessException | InvocationTargetException e) { throw new IllegalArgumentException(e); } processResult(result); }
private Session connectToEchoServerBasic(WebSocketContainer wsContainer, Class<? extends Endpoint> clazz) throws Exception { return wsContainer.connectToServer(clazz, ClientEndpointConfig.Builder.create().build(), new URI("http://localhost:" + getPort() + TesterEchoServer.Config.PATH_BASIC)); }	private void doBufferTest(boolean isTextBuffer, boolean isServerBuffer, boolean isTextMessage, boolean pass) throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(TesterEchoServer.Config.class.getName()); WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); if (isServerBuffer) { if (isTextBuffer) { ctx.addParameter(org.apache.tomcat.websocket.server.Constants.TEXT_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM, "1024"); } else { ctx.addParameter(org.apache.tomcat.websocket.server.Constants.BINARY_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM, "1024"); } } else { if (isTextBuffer) { wsContainer.setDefaultMaxTextMessageBufferSize(1024); } else { wsContainer.setDefaultMaxBinaryMessageBufferSize(1024); } } tomcat.start(); Session wsSession = wsContainer.connectToServer(TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder.create().build(), new URI("http://localhost:" + getPort() + TesterEchoServer.Config.PATH_BASIC)); BasicHandler<?> handler; CountDownLatch latch = new CountDownLatch(1); wsSession.getUserProperties().put("latch", latch); if (isTextMessage) { handler = new BasicText(latch); } else { handler = new BasicBinary(latch); } wsSession.addMessageHandler(handler); if (isTextMessage) { wsSession.getBasicRemote().sendText(MESSAGE_TEXT_4K); } else { wsSession.getBasicRemote().sendBinary(ByteBuffer.wrap(MESSAGE_BINARY_4K)); } boolean latchResult = handler.getLatch().await(10, TimeUnit.SECONDS); Assert.assertTrue(latchResult); List<?> messages = handler.getMessages(); if (pass) { Assert.assertEquals(1, messages.size()); if (isTextMessage) { Assert.assertEquals(MESSAGE_TEXT_4K, messages.get(0)); } else { Assert.assertEquals(ByteBuffer.wrap(MESSAGE_BINARY_4K), messages.get(0)); } } else { Assert.assertFalse(wsSession.isOpen()); } }	private void doTestWriteTimeoutClient(boolean setTimeoutOnContainer) throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(BlockingConfig.class.getName()); WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); if (setTimeoutOnContainer) { wsContainer.setAsyncSendTimeout(TIMEOUT_MS); } tomcat.start(); Session wsSession = wsContainer.connectToServer(TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder.create().build(), new URI("http://localhost:" + getPort() + BlockingConfig.PATH)); if (!setTimeoutOnContainer) { wsSession.getAsyncRemote().setSendTimeout(TIMEOUT_MS); } long lastSend = 0; // Should send quickly until the network buffers fill up and then block Exception exception = null; try { while (true) { Future<Void> f = wsSession.getAsyncRemote().sendBinary(ByteBuffer.wrap(MESSAGE_BINARY_4K)); lastSend = System.currentTimeMillis(); f.get(); } } catch (Exception e) { exception = e; } long timeout = System.currentTimeMillis() - lastSend; String msg = "Time out was [" + timeout + "] ms"; Assert.assertTrue(msg, timeout >= TIMEOUT_MS - MARGIN); Assert.assertTrue(msg, timeout < TIMEOUT_MS * 2); Assert.assertNotNull(exception); }	private void doTestWriteTimeoutServer(boolean setTimeoutOnContainer) throws Exception { timoutOnContainer = setTimeoutOnContainer; Tomcat tomcat = getTomcatInstance(); if (getProtocol().equals(Http11Protocol.class.getName())) { return; } Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(WsListener.class.getName()); ctx.addApplicationListener(ConstantTxConfig.class.getName()); WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); tomcat.start(); Session wsSession = wsContainer.connectToServer(TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder.create().build(), new URI("http://localhost:" + getPort() + ConstantTxConfig.PATH)); wsSession.addMessageHandler(new BlockingBinaryHandler()); int loops = 0; while (loops < 15) { Thread.sleep(1000); if (!ConstantTxEndpoint.getRunning()) { break; } loops++; } Assert.assertNotNull(ConstantTxEndpoint.getException()); Assert.assertEquals(ExecutionException.class, ConstantTxEndpoint.getException().getClass()); Assert.assertNotNull(ConstantTxEndpoint.getException().getCause()); Assert.assertEquals(SocketTimeoutException.class, ConstantTxEndpoint.getException().getCause().getClass()); Assert.assertTrue(ConstantTxEndpoint.getTimeout() >= TIMEOUT_MS); Assert.assertTrue(ConstantTxEndpoint.getTimeout() < TIMEOUT_MS * 2); }	private void doTestWriter(Class<?> clazz) throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(TesterEchoServer.Config.class.getName()); WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); tomcat.start(); Session wsSession; URI uri = new URI("http://localhost:" + getPort() + TesterEchoServer.Config.PATH_ASYNC); if (Endpoint.class.isAssignableFrom(clazz)) { @SuppressWarnings("unchecked") Class<? extends Endpoint> endpointClazz = (Class<? extends Endpoint>) clazz; wsSession = wsContainer.connectToServer(endpointClazz, Builder.create().build(), uri); } else { wsSession = wsContainer.connectToServer(clazz, uri); } CountDownLatch latch = new CountDownLatch(1); wsSession.getUserProperties().put("latch", latch); AsyncHandler<?> handler = new AsyncText(latch); wsSession.addMessageHandler(handler); Writer w = wsSession.getBasicRemote().getSendWriter(); for (int i = 0; i < 8; i++) { w.write(TEST_MESSAGE_5K); } w.close(); boolean latchResult = handler.getLatch().await(10, TimeUnit.SECONDS); Assert.assertTrue(latchResult); List<String> messages = (List<String>) handler.getMessages(); int offset = 0; int i = 0; for (String message : messages) { Assert.assertEquals(SEQUENCE.substring(offset, S_LEN), message.substring(0, S_LEN - offset)); i = S_LEN - offset; while (i + S_LEN < message.length()) { if (!SEQUENCE.equals(message.substring(i, i + S_LEN))) { Assert.fail(); } i += S_LEN; } offset = message.length() - i; if (!SEQUENCE.substring(0, offset).equals(message.substring(i))) { Assert.fail(); } } }	@Override public Session connectToServer(Endpoint endpoint, ClientEndpointConfig clientEndpointConfiguration, URI path) throws DeploymentException { String scheme = path.getScheme(); if (!("http".equalsIgnoreCase(scheme) || "https".equalsIgnoreCase(scheme))) { throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme", scheme)); } String host = path.getHost(); if (host == null) { throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost")); } int port = path.getPort(); Map<String, List<String>> reqHeaders = createRequestHeaders(host, port); clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders); ByteBuffer request = createRequest(path.getRawPath(), reqHeaders); SocketAddress sa; if (port == -1) { if ("http".equalsIgnoreCase(scheme)) { sa = new InetSocketAddress(host, 80); } else { throw new DeploymentException("TODO: HTTPS"); } } else { sa = new InetSocketAddress(host, port); } AsynchronousSocketChannel channel; try { channel = AsynchronousSocketChannel.open(); } catch (IOException ioe) { throw new DeploymentException("TODO", ioe); } Future<Void> fConnect = channel.connect(sa); ByteBuffer response; String subProtocol; try { fConnect.get(); int toWrite = request.limit(); Future<Integer> fWrite = channel.write(request); Integer thisWrite = fWrite.get(); toWrite -= thisWrite.intValue(); while (toWrite > 0) { fWrite = channel.write(request); thisWrite = fWrite.get(); toWrite -= thisWrite.intValue(); } response = ByteBuffer.allocate(maxBinaryMessageBufferSize); HandshakeResponse handshakeResponse = processResponse(response, channel); clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse); List<String> values = handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME); if (values == null || values.size() == 0) { subProtocol = null; } else if (values.size() == 1) { subProtocol = values.get(0); } else { throw new DeploymentException(sm.getString("Sec-WebSocket-Protocol")); } } catch (ExecutionException | InterruptedException e) { throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"), e); } WsRemoteEndpointImplClient wsRemoteEndpointClient = new WsRemoteEndpointImplClient(channel); WsSession wsSession = new WsSession(endpoint, wsRemoteEndpointClient, this, null, subProtocol, Collections.EMPTY_MAP, false, clientEndpointConfiguration.getEncoders()); endpoint.onOpen(wsSession, clientEndpointConfiguration); registerSession(endpoint.getClass(), wsSession); @SuppressWarnings("unused") WsFrameClient wsFrameClient = new WsFrameClient(response, channel, wsSession); return wsSession; }	public void test() throws Exception { Server server = new Server(); SingletonConfigurator.setInstance(server); ServerConfigListener.setPojoClazz(Server.class); Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(ServerConfigListener.class.getName()); WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); tomcat.start(); Client client = new Client(); URI uri = new URI("http://localhost:" + getPort() + "/"); Session session = wsContainer.connectToServer(client, uri); MsgString msg1 = new MsgString(); msg1.setData(MESSAGE_ONE); session.getBasicRemote().sendObject(msg1); int i = 0; while (i < 20) { if (server.received.size() > 0 && client.received.size() > 0) { break; } Thread.sleep(100); } Assert.assertEquals(1, server.received.size()); Assert.assertEquals(1, client.received.size()); Assert.assertEquals(MESSAGE_ONE, ((MsgString) server.received.peek()).getData()); Assert.assertEquals(MESSAGE_ONE, ((MsgString) client.received.peek()).getData()); }	public void test() throws Exception { Server server = new Server(); SingletonConfigurator.setInstance(server); ServerConfigListener.setPojoClazz(Server.class); Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(ServerConfigListener.class.getName()); WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); tomcat.start(); Client client = new Client(); URI uri = new URI("http://localhost:" + getPort() + "/" + PARAM_ONE + "/" + PARAM_TWO + "/" + PARAM_THREE); Session session = wsContainer.connectToServer(client, uri); session.getBasicRemote().sendText("NO-OP"); session.close(); int count = 0; while (count < 50) { if (server.isClosed()) { break; } count++; Thread.sleep(100); } if (count == 50) { Assert.fail("Server did not process an onClose event within 5 " + "seconds of the client sending a close message"); } List<String> errors = server.getErrors(); for (String error : errors) { System.err.println(error); } Assert.assertEquals("Found errors", 0, errors.size()); }	public void testConnectToServerEndpoint() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(TesterEchoServer.Config.class.getName()); tomcat.start(); WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); Session wsSession = wsContainer.connectToServer(TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder.create().build(), new URI("http://localhost:" + getPort() + TesterEchoServer.Config.PATH_ASYNC)); CountDownLatch latch = new CountDownLatch(1); BasicText handler = new BasicText(latch); wsSession.addMessageHandler(handler); wsSession.getBasicRemote().sendText(MESSAGE_STRING_1); boolean latchResult = handler.getLatch().await(10, TimeUnit.SECONDS); Assert.assertTrue(latchResult); List<String> messages = handler.getMessages(); Assert.assertEquals(1, messages.size()); Assert.assertEquals(MESSAGE_STRING_1, messages.get(0)); }	@Test(expected = javax.websocket.DeploymentException.class) public void testConnectToServerEndpointNoHost() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); ctx.addApplicationListener(TesterEchoServer.Config.class.getName()); tomcat.start(); WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder.create().build(), new URI("http://" + TesterEchoServer.Config.PATH_ASYNC)); }
public String getParameterValue(String parameter) { return parameters.get(parameter.toLowerCase(Locale.US)); }	@Override public String toString() { StringBuilder buf = new StringBuilder("ConnectionPool["); try { String[] fields = DataSourceFactory.ALL_PROPERTIES; for (int i = 0; i < fields.length; i++) { final String[] prefix = new String[] { "get", "is" }; for (int j = 0; j < prefix.length; j++) { String name = prefix[j] + fields[i].substring(0, 1).toUpperCase(Locale.US) + fields[i].substring(1); Method m = null; try { m = getClass().getMethod(name); } catch (NoSuchMethodException nm) { continue; } buf.append(fields[i]); buf.append("="); buf.append(m.invoke(this, new Object[0])); buf.append("; "); break; } } } catch (Exception x) { x.printStackTrace(); } return buf.toString(); }	public static Charset getCharset(String enc) throws UnsupportedEncodingException { String lowerCaseEnc = enc.toLowerCase(Locale.US); return getCharsetLower(lowerCaseEnc); }	public static MediaType parseMediaType(StringReader input) throws IOException { String type = readToken(input); if (type == null || type.length() == 0) { return null; } if (skipConstant(input, "/") == SkipConstantResult.NOT_FOUND) { return null; } String subtype = readToken(input); if (subtype == null || subtype.length() == 0) { return null; } LinkedHashMap<String, String> parameters = new LinkedHashMap<>(); SkipConstantResult lookForSemiColon = skipConstant(input, ";"); if (lookForSemiColon == SkipConstantResult.NOT_FOUND) { return null; } while (lookForSemiColon == SkipConstantResult.FOUND) { String attribute = readToken(input); if (skipConstant(input, "=") == SkipConstantResult.FOUND) { String value = readTokenOrQuotedString(input, true); parameters.put(attribute.toLowerCase(Locale.US), value); } else { parameters.put(attribute.toLowerCase(Locale.US), ""); } lookForSemiColon = skipConstant(input, ";"); if (lookForSemiColon == SkipConstantResult.NOT_FOUND) { return null; } } return new MediaType(type, subtype, parameters); }	public void setURIEncoding(String URIEncoding) { this.URIEncoding = URIEncoding; if (URIEncoding == null) { URIEncodingLower = null; } else { this.URIEncodingLower = URIEncoding.toLowerCase(Locale.US); } setProperty("uRIEncoding", URIEncoding); }

protected InputSource getWebXmlSource(String filename, String path) { File file = new File(filename); if (!file.isAbsolute()) { file = new File(path, filename); } InputStream stream = null; InputSource source = null; try { if (!file.exists()) { stream = getClass().getClassLoader().getResourceAsStream(filename); if (stream != null) { source = new InputSource(getClass().getClassLoader().getResource(filename).toURI().toString()); } } else { source = new InputSource(file.getAbsoluteFile().toURI().toString()); stream = new FileInputStream(file); } if (stream != null && source != null) { source.setByteStream(stream); } } catch (Exception e) { log.error(sm.getString("contextConfig.defaultError", filename, file), e); } return source; }	protected Map<String, WebXml> processJarsForWebFragments() { JarScanner jarScanner = context.getJarScanner(); FragmentJarScannerCallback callback = new FragmentJarScannerCallback(); jarScanner.scan(context.getServletContext(), context.getLoader().getClassLoader(), callback, pluggabilityJarsToSkip); return callback.getFragments(); }	@Override public void scan(File file) throws IOException { InputStream stream = null; WebXml fragment = new WebXml(); try { File fragmentFile = new File(file, FRAGMENT_LOCATION); if (fragmentFile.isFile()) { stream = new FileInputStream(fragmentFile); InputSource source = new InputSource(fragmentFile.toURI().toURL().toString()); source.setByteStream(stream); parseWebXml(source, fragment, true); } } finally { if (stream != null) { try { stream.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } fragment.setURL(file.toURI().toURL()); if (fragment.getName() == null) { fragment.setName(fragment.getURL().toString()); } fragment.setJarName(file.getName()); fragments.put(fragment.getName(), fragment); } }	protected Map<String, String> processAnnotationWebInitParams(ElementValue ev) { Map<String, String> result = new HashMap<>(); if (ev instanceof ArrayElementValue) { ElementValue[] arrayValues = ((ArrayElementValue) ev).getElementValuesArray(); for (ElementValue value : arrayValues) { if (value instanceof AnnotationElementValue) { ElementValuePair[] evps = ((AnnotationElementValue) value).getAnnotationEntry().getElementValuePairs(); String initParamName = null; String initParamValue = null; for (ElementValuePair evp : evps) { if ("name".equals(evp.getNameString())) { initParamName = evp.getValue().stringifyValue(); } else if ("value".equals(evp.getNameString())) { initParamValue = evp.getValue().stringifyValue(); } else { // Ignore } } result.put(initParamName, initParamValue); } } } return result; }
private void parseParts() { if (parts != null || partsParseException != null) { return; } MultipartConfigElement mce = getWrapper().getMultipartConfigElement(); if (mce == null) { if (getContext().getAllowCasualMultipartParsing()) { mce = new MultipartConfigElement(null, connector.getMaxPostSize(), connector.getMaxPostSize(), connector.getMaxPostSize()); } else { parts = Collections.emptyList(); return; } } Parameters parameters = coyoteRequest.getParameters(); parameters.setLimit(getConnector().getMaxParameterCount()); boolean success = false; try { File location; String locationStr = mce.getLocation(); if (locationStr == null || locationStr.length() == 0) { location = ((File) context.getServletContext().getAttribute(ServletContext.TEMPDIR)); } else { location = new File(locationStr); if (!location.isAbsolute()) { location = new File((File) context.getServletContext().getAttribute(ServletContext.TEMPDIR), locationStr).getAbsoluteFile(); } } if (!location.isDirectory()) { partsParseException = new IOException(sm.getString("coyoteRequest.uploadLocationInvalid", location)); return; } DiskFileItemFactory factory = new DiskFileItemFactory(); try { factory.setRepository(location.getCanonicalFile()); } catch (IOException ioe) { partsParseException = ioe; return; } factory.setSizeThreshold(mce.getFileSizeThreshold()); ServletFileUpload upload = new ServletFileUpload(); upload.setFileItemFactory(factory); upload.setFileSizeMax(mce.getMaxFileSize()); upload.setSizeMax(mce.getMaxRequestSize()); parts = new ArrayList<>(); try { List<FileItem> items = upload.parseRequest(this); int maxPostSize = getConnector().getMaxPostSize(); int postSize = 0; String enc = getCharacterEncoding(); Charset charset = null; if (enc != null) { try { charset = B2CConverter.getCharset(enc); } catch (UnsupportedEncodingException e) { // Ignore } } for (FileItem item : items) { ApplicationPart part = new ApplicationPart(item, mce); parts.add(part); if (part.getFilename() == null) { String name = part.getName(); String value = null; try { String encoding = parameters.getEncoding(); if (encoding == null) { encoding = Parameters.DEFAULT_ENCODING; } value = part.getString(encoding); } catch (UnsupportedEncodingException uee) { try { value = part.getString(Parameters.DEFAULT_ENCODING); } catch (UnsupportedEncodingException e) { // Should not be possible } } if (maxPostSize > 0) { if (charset == null) { postSize += name.getBytes().length; } else { postSize += name.getBytes(charset).length; } if (value != null) { postSize++; postSize += part.getSize(); } postSize++; if (postSize > maxPostSize) { throw new IllegalStateException(sm.getString("coyoteRequest.maxPostSizeExceeded")); } } parameters.addParameter(name, value); } } success = true; } catch (InvalidContentTypeException e) { partsParseException = new ServletException(e); } catch (FileUploadBase.SizeException e) { checkSwallowInput(); partsParseException = new IllegalStateException(e); } catch (FileUploadException e) { partsParseException = new IOException(e); } catch (IllegalStateException e) { checkSwallowInput(); partsParseException = e; } } finally { if (partsParseException != null || !success) { parameters.setParseFailed(true); } } }	protected String upload(HttpServletRequest request, StringManager smClient) throws IOException, ServletException { String message = ""; Part warPart = null; String filename = null; Collection<Part> parts = request.getParts(); Iterator<Part> iter = parts.iterator(); try { while (iter.hasNext()) { Part part = iter.next(); if (part.getName().equals("deployWar") && warPart == null) { warPart = part; } else { part.delete(); } } while (true) { if (warPart == null) { message = smClient.getString("htmlManagerServlet.deployUploadNoFile"); break; } filename = extractFilename(warPart.getHeader("Content-Disposition")); if (!filename.toLowerCase(Locale.ENGLISH).endsWith(".war")) { message = smClient.getString("htmlManagerServlet.deployUploadNotWar", filename); break; } if (filename.lastIndexOf('\\') >= 0) { filename = filename.substring(filename.lastIndexOf('\\') + 1); } if (filename.lastIndexOf('/') >= 0) { filename = filename.substring(filename.lastIndexOf('/') + 1); } // Identify the appBase of the owning Host of this Context File file = new File(host.getAppBaseFile(), filename); if (file.exists()) { message = smClient.getString("htmlManagerServlet.deployUploadWarExists", filename); break; } ContextName cn = new ContextName(filename); String name = cn.getName(); if ((host.findChild(name) != null) && !isDeployed(name)) { message = smClient.getString("htmlManagerServlet.deployUploadInServerXml", filename); break; } if (!isServiced(name)) { addServiced(name); try { warPart.write(file.getAbsolutePath()); check(name); } finally { removeServiced(name); } } break; } } catch (Exception e) { message = smClient.getString("htmlManagerServlet.deployUploadFail", e.getMessage()); log(message, e); } finally { if (warPart != null) { warPart.delete(); } warPart = null; } return message; }	public String getString(String encoding) throws UnsupportedEncodingException { return fileItem.getString(encoding); }
@Override protected synchronized void startInternal() throws LifecycleException { String format = getFileDateFormat(); if (format == null) { format = ""; setFileDateFormat(format); } fileDateFormatter = new SimpleDateFormat(format, Locale.US); fileDateFormatter.setTimeZone(TimeZone.getDefault()); dateStamp = fileDateFormatter.format(new Date(System.currentTimeMillis())); if (rotatable && renameOnRotate) { restore(); } open(); setState(LifecycleState.STARTING); }	public void log(CharArrayWriter message) { if (rotatable) { long systime = System.currentTimeMillis(); if ((systime - rotationLastChecked) > 1000) { synchronized (this) { if ((systime - rotationLastChecked) > 1000) { rotationLastChecked = systime; String tsDate; tsDate = fileDateFormatter.format(new Date(systime)); if (!dateStamp.equals(tsDate)) { close(true); dateStamp = tsDate; open(); } } } } } if (checkExists) { synchronized (this) { if (currentLogFile != null && !currentLogFile.exists()) { try { close(false); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); log.info(sm.getString("accessLogValve.closeFail"), e); } dateStamp = fileDateFormatter.format(new Date(System.currentTimeMillis())); open(); } } } try { synchronized (this) { if (writer != null) { message.writeTo(writer); writer.println(""); if (!buffered) { writer.flush(); } } } } catch (IOException ioe) { log.warn(sm.getString("accessLogValve.writeFail", message.toString()), ioe); } }	@Override public void log(Request request, Response response, long time) { if (!getState().isAvailable() || !getEnabled() || logElements == null || condition != null && null != request.getRequest().getAttribute(condition) || conditionIf != null && null == request.getRequest().getAttribute(conditionIf)) { return; } long start = request.getCoyoteRequest().getStartTime(); Date date = getDate(start + time); CharArrayWriter result = charArrayWriters.pop(); if (result == null) { result = new CharArrayWriter(128); } for (int i = 0; i < logElements.length; i++) { logElements[i].addElement(result, date, request, response, time); } log(result); if (result.size() <= maxLogMessageBufferSize) { result.reset(); charArrayWriters.push(result); } }	public void setFileDateFormat(String fileDateFormat) { this.fileDateFormat = fileDateFormat; }
@Override public String[] getEnableableProtocols(SSLContext context) { String[] requestedProtocols = endpoint.getSslEnabledProtocolsArray(); if ((requestedProtocols == null) || (requestedProtocols.length == 0)) { return context.getDefaultSSLParameters().getProtocols(); } List<String> protocols = new ArrayList<>(Arrays.asList(requestedProtocols)); protocols.retainAll(Arrays.asList(context.getSupportedSSLParameters().getProtocols())); if (protocols.isEmpty()) { log.warn(sm.getString("jsse.requested_protocols_not_supported", Arrays.asList(requestedProtocols))); } if (log.isDebugEnabled()) { log.debug(sm.getString("jsse.enableable_protocols", protocols)); if (protocols.size() != requestedProtocols.length) { List<String> skipped = new ArrayList<>(Arrays.asList(requestedProtocols)); skipped.removeAll(protocols); log.debug(sm.getString("jsse.unsupported_protocols", skipped)); } } return protocols.toArray(new String[protocols.size()]); }	public String[] getEnabledCiphers() { return enabledCiphers; }

private void doWriteBytes(ByteBuffer buffer, boolean finalFragment) throws IOException { if (closed) { throw new IOException(sm.getString("outbound.closed")); } int first = 0x00; if (finalFragment) { first = first + 0x80; } if (firstFrame) { if (text.booleanValue()) { first = first + 0x1; } else { first = first + 0x2; } } outputStream.write(first); if (buffer.limit() < 126) { outputStream.write(buffer.limit()); } else if (buffer.limit() < 65536) { outputStream.write(126); outputStream.write(buffer.limit() >>> 8); outputStream.write(buffer.limit() & 0xFF); } else { outputStream.write(127); outputStream.write(0); outputStream.write(0); outputStream.write(0); outputStream.write(0); outputStream.write(buffer.limit() >>> 24); outputStream.write(buffer.limit() >>> 16); outputStream.write(buffer.limit() >>> 8); outputStream.write(buffer.limit() & 0xFF); } outputStream.write(buffer.array(), 0, buffer.limit()); outputStream.flush(); if (finalFragment) { text = null; firstFrame = true; } else { firstFrame = false; } bb.clear(); }
protected boolean restoreRequest(Request request, Session session) throws IOException { SavedRequest saved = (SavedRequest) session.getNote(Constants.FORM_REQUEST_NOTE); session.removeNote(Constants.FORM_REQUEST_NOTE); session.removeNote(Constants.FORM_PRINCIPAL_NOTE); if (saved == null) { return false; } request.clearCookies(); Iterator<Cookie> cookies = saved.getCookies(); while (cookies.hasNext()) { request.addCookie(cookies.next()); } String method = saved.getMethod(); MimeHeaders rmh = request.getCoyoteRequest().getMimeHeaders(); rmh.recycle(); boolean cachable = "GET".equalsIgnoreCase(method) || "HEAD".equalsIgnoreCase(method); Iterator<String> names = saved.getHeaderNames(); while (names.hasNext()) { String name = names.next(); if (!("If-Modified-Since".equalsIgnoreCase(name) || (cachable && "If-None-Match".equalsIgnoreCase(name)))) { Iterator<String> values = saved.getHeaderValues(name); while (values.hasNext()) { rmh.addValue(name).setString(values.next()); } } } request.clearLocales(); Iterator<Locale> locales = saved.getLocales(); while (locales.hasNext()) { request.addLocale(locales.next()); } request.getCoyoteRequest().getParameters().recycle(); request.getCoyoteRequest().getParameters().setQueryStringEncoding(request.getConnector().getURIEncoding()); byte[] buffer = new byte[4096]; InputStream is = request.createInputStream(); while (is.read(buffer) >= 0) { // Ignore request body } ByteChunk body = saved.getBody(); if (body != null) { request.getCoyoteRequest().action(ActionCode.REQ_SET_BODY_REPLAY, body); MessageBytes contentType = MessageBytes.newInstance(); String savedContentType = saved.getContentType(); if (savedContentType == null && "POST".equalsIgnoreCase(method)) { savedContentType = "application/x-www-form-urlencoded"; } contentType.setString(savedContentType); request.getCoyoteRequest().setContentType(contentType); } request.getCoyoteRequest().method().setString(method); return true; }
private void doWriteBytes(ByteBuffer buffer, boolean finalFragment) throws IOException { int first = 0x00; if (finalFragment) { first = first + 0x80; } if (firstFrame) { if (text.booleanValue()) { first = first + 0x1; } else { first = first + 0x2; } } outputStream.write(first); if (buffer.limit() < 126) { outputStream.write(buffer.limit()); } else if (buffer.limit() < 65536) { outputStream.write(126); outputStream.write(buffer.limit() >>> 8); outputStream.write(buffer.limit() & 0xFF); } else { outputStream.write(127); outputStream.write(0); outputStream.write(0); outputStream.write(0); outputStream.write(0); outputStream.write(buffer.limit() >>> 24); outputStream.write(buffer.limit() >>> 16); outputStream.write(buffer.limit() >>> 8); outputStream.write(buffer.limit() & 0xFF); } outputStream.write(buffer.array(), 0, buffer.limit()); outputStream.flush(); if (finalFragment) { text = null; firstFrame = true; } else { firstFrame = false; } bb.clear(); }	public synchronized void close(int status, ByteBuffer data) throws IOException { if (closed) { return; } closed = true; outputStream.write(0x88); if (status == 0) { outputStream.write(0); } else if (data == null || data.position() == data.limit()) { outputStream.write(2); outputStream.write(status >>> 8); outputStream.write(status); } else { outputStream.write(2 + data.limit() - data.position()); outputStream.write(status >>> 8); outputStream.write(status); outputStream.write(data.array(), data.position(), data.limit() - data.position()); } outputStream.flush(); bb = null; cb = null; outputStream = null; }
public static void writeVMState(PrintWriter writer, int mode) throws Exception { SortedMap<String, MemoryPoolMXBean> memoryPoolMBeans = new TreeMap<>(); for (MemoryPoolMXBean mbean : ManagementFactory.getMemoryPoolMXBeans()) { String sortKey = mbean.getType() + ":" + mbean.getName(); memoryPoolMBeans.put(sortKey, mbean); } if (mode == 0) { writer.print("<h1>JVM</h1>"); writer.print("<p>"); writer.print(" Free memory: "); writer.print(formatSize(Long.valueOf(Runtime.getRuntime().freeMemory()), true)); writer.print(" Total memory: "); writer.print(formatSize(Long.valueOf(Runtime.getRuntime().totalMemory()), true)); writer.print(" Max memory: "); writer.print(formatSize(Long.valueOf(Runtime.getRuntime().maxMemory()), true)); writer.print("</p>"); writer.write("<table border=\"0\"><thead><tr><th>Memory Pool</th><th>Type</th><th>Initial</th><th>Total</th><th>Maximum</th><th>Used</th></tr></thead><tbody>"); for (MemoryPoolMXBean memoryPoolMBean : memoryPoolMBeans.values()) { MemoryUsage usage = memoryPoolMBean.getUsage(); writer.write("<tr><td>"); writer.print(memoryPoolMBean.getName()); writer.write("</td><td>"); writer.print(memoryPoolMBean.getType()); writer.write("</td><td>"); writer.print(formatSize(Long.valueOf(usage.getInit()), true)); writer.write("</td><td>"); writer.print(formatSize(Long.valueOf(usage.getCommitted()), true)); writer.write("</td><td>"); writer.print(formatSize(Long.valueOf(usage.getMax()), true)); writer.write("</td><td>"); writer.print(formatSize(Long.valueOf(usage.getUsed()), true)); if (usage.getMax() > 0) { writer.write(" (" + (usage.getUsed() * 100 / usage.getMax()) + "%)"); } writer.write("</td></tr>"); } writer.write("</tbody></table>"); } else if (mode == 1) { writer.write("<jvm>"); writer.write("<memory"); writer.write(" free='" + Runtime.getRuntime().freeMemory() + "'"); writer.write(" total='" + Runtime.getRuntime().totalMemory() + "'"); writer.write(" max='" + Runtime.getRuntime().maxMemory() + "'/>"); for (MemoryPoolMXBean memoryPoolMBean : memoryPoolMBeans.values()) { MemoryUsage usage = memoryPoolMBean.getUsage(); writer.write("<memorypool"); writer.write(" name='" + memoryPoolMBean.getName() + "'"); writer.write(" type='" + memoryPoolMBean.getType() + "'"); writer.write(" usageInit='" + usage.getInit() + "'"); writer.write(" usageCommitted='" + usage.getCommitted() + "'"); writer.write(" usageMax='" + usage.getMax() + "'"); writer.write(" usageUsed='" + usage.getInit() + "'/>"); } writer.write("</jvm>"); } }
private void setClassPath() { if (context == null) return; ServletContext servletContext = context.getServletContext(); if (servletContext == null) return; StringBuilder classpath = new StringBuilder(); ClassLoader loader = getClassLoader(); while (loader != null) { if (!buildClassPath(servletContext, classpath, loader)) { break; } loader = loader.getParent(); } this.classpath = classpath.toString(); servletContext.setAttribute(Globals.CLASS_PATH_ATTR, classpath.toString()); }
protected void convertURI(MessageBytes uri, Request request) throws Exception { ByteChunk bc = uri.getByteChunk(); int length = bc.getLength(); CharChunk cc = uri.getCharChunk(); cc.allocate(length, -1); String enc = connector.getURIEncoding(); if (enc != null) { B2CConverter conv = request.getURIConverter(); try { if (conv == null) { conv = new B2CConverter(enc); request.setURIConverter(conv); } } catch (IOException e) { log.error("Invalid URI encoding; using HTTP default"); connector.setURIEncoding(null); } if (conv != null) { try { conv.convert(bc, cc); uri.setChars(cc.getBuffer(), cc.getStart(), cc.getLength()); return; } catch (IOException e) { log.error("Invalid URI character encoding; trying ascii"); cc.recycle(); } } } byte[] bbuf = bc.getBuffer(); char[] cbuf = cc.getBuffer(); int start = bc.getStart(); for (int i = 0; i < length; i++) { cbuf[i] = (char) (bbuf[i + start] & 0xff); } uri.setChars(cbuf, 0, length); }

protected void handleCHANGE_SESSION_ID(SessionMessage msg, Member sender) throws IOException { counterReceive_EVT_CHANGE_SESSION_ID++; DeltaSession session = (DeltaSession) findSession(msg.getSessionID()); if (session != null) { String newSessionID = deserializeSessionId(msg.getSession()); session.setPrimarySession(false); session.setId(newSessionID, false); if (notifyContainerListenersOnReplication) { getContext().fireContainerEvent(Context.CHANGE_SESSION_ID_EVENT, new String[] { msg.getSessionID(), newSessionID }); } } }	@Override public HttpSession getSession() { return this._getHttpServletRequest().getSession(); }	@Override public HttpSession getSession() { if (request == null) { throw new IllegalStateException(sm.getString("requestFacade.nullRequest")); } return getSession(true); }	@Override public HttpSession getSession() { return getRequest().getSession(); }	public boolean listenerStart() { if (log.isDebugEnabled()) log.debug("Configuring application event listeners"); String[] listeners = findApplicationListeners(); Object[] results = new Object[listeners.length]; boolean ok = true; for (int i = 0; i < results.length; i++) { if (getLogger().isDebugEnabled()) getLogger().debug(" Configuring event listener class '" + listeners[i] + "'"); try { results[i] = instanceManager.newInstance(listeners[i]); } catch (Throwable t) { t = ExceptionUtils.unwrapInvocationTargetException(t); ExceptionUtils.handleThrowable(t); getLogger().error(sm.getString("standardContext.applicationListener", listeners[i]), t); ok = false; } } if (!ok) { getLogger().error(sm.getString("standardContext.applicationSkipped")); return (false); } ArrayList<Object> eventListeners = new ArrayList<>(); ArrayList<Object> lifecycleListeners = new ArrayList<>(); for (int i = 0; i < results.length; i++) { if ((results[i] instanceof ServletContextAttributeListener) || (results[i] instanceof ServletRequestAttributeListener) || (results[i] instanceof ServletRequestListener) || (results[i] instanceof HttpSessionAttributeListener)) { eventListeners.add(results[i]); } if ((results[i] instanceof ServletContextListener) || (results[i] instanceof HttpSessionListener)) { lifecycleListeners.add(results[i]); } } for (Object eventListener : getApplicationEventListeners()) { eventListeners.add(eventListener); } setApplicationEventListeners(eventListeners.toArray()); for (Object lifecycleListener : getApplicationLifecycleListeners()) { lifecycleListeners.add(lifecycleListener); } setApplicationLifecycleListeners(lifecycleListeners.toArray()); if (getLogger().isDebugEnabled()) getLogger().debug("Sending application start events"); getServletContext(); context.setNewServletContextListenerAllowed(false); Object[] instances = getApplicationLifecycleListeners(); if (instances == null || instances.length == 0) return (ok); ServletContextEvent event = new ServletContextEvent(getServletContext()); for (int i = 0; i < instances.length; i++) { if (instances[i] == null) continue; if (!(instances[i] instanceof ServletContextListener)) continue; ServletContextListener listener = (ServletContextListener) instances[i]; try { fireContainerEvent("beforeContextInitialized", listener); listener.contextInitialized(event); fireContainerEvent("afterContextInitialized", listener); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); fireContainerEvent("afterContextInitialized", listener); getLogger().error(sm.getString("standardContext.listenerStart", instances[i].getClass().getName()), t); ok = false; } } return (ok); }	@Override public <T extends EventListener> T createListener(Class<T> c) throws ServletException { try { T listener = (T) context.getInstanceManager().newInstance(c.getName()); if (listener instanceof ServletContextListener || listener instanceof ServletContextAttributeListener || listener instanceof ServletRequestListener || listener instanceof ServletRequestAttributeListener || listener instanceof HttpSessionListener || listener instanceof HttpSessionAttributeListener) { return listener; } throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.wrongType", listener.getClass().getName())); } catch (IllegalAccessException e) { throw new ServletException(e); } catch (InvocationTargetException e) { ExceptionUtils.handleThrowable(e.getCause()); throw new ServletException(e); } catch (NamingException e) { throw new ServletException(e); } catch (InstantiationException e) { throw new ServletException(e); } catch (ClassNotFoundException e) { throw new ServletException(e); } }	@Override public void changeSessionId(Session session) { String oldId = session.getIdInternal(); session.setId(generateSessionId(), false); String newId = session.getIdInternal(); context.fireContainerEvent(Context.CHANGE_SESSION_ID_EVENT, new String[] { oldId, newId }); }	public void changeSessionId(String newSessionId) { if (requestedSessionId != null && requestedSessionId.length() > 0) { requestedSessionId = newSessionId; } if (context != null && !context.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.COOKIE)) { return; } if (response != null) { Cookie newCookie = ApplicationSessionCookieConfig.createSessionCookie(context, newSessionId, secure); response.addSessionCookieInternal(newCookie); } }
@Test public void testBug54220SetNotFound() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(ctx, "bug54220", new Bug54220Servlet(true)); ctx.addServletMapping("/", "bug54220"); tomcat.start(); ByteChunk res = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort(), res, null); Assert.assertNull(res.toString()); Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); }	protected void report(Request request, Response response, Throwable throwable) { int statusCode = response.getStatus(); if (statusCode < 400 || response.getContentWritten() > 0 || !response.isError()) { return; } String message = RequestUtil.filter(response.getMessage()); if (message == null) { if (throwable != null) { String exceptionMessage = throwable.getMessage(); if (exceptionMessage != null && exceptionMessage.length() > 0) { message = RequestUtil.filter((new Scanner(exceptionMessage)).nextLine()); } } if (message == null) { message = ""; } } String report = null; try { report = sm.getString("http." + statusCode); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } if (report == null) { return; } StringBuilder sb = new StringBuilder(); sb.append("<html><head><title>"); sb.append(ServerInfo.getServerInfo()).append(" - "); sb.append(sm.getString("errorReportValve.errorReport")); sb.append("</title>"); sb.append("<style><!--"); sb.append(org.apache.catalina.util.TomcatCSS.TOMCAT_CSS); sb.append("--></style> "); sb.append("</head><body>"); sb.append("<h1>"); sb.append(sm.getString("errorReportValve.statusHeader", "" + statusCode, message)).append("</h1>"); sb.append("<HR size=\"1\" noshade=\"noshade\">"); sb.append("<p><b>type</b> "); if (throwable != null) { sb.append(sm.getString("errorReportValve.exceptionReport")); } else { sb.append(sm.getString("errorReportValve.statusReport")); } sb.append("</p>"); sb.append("<p><b>"); sb.append(sm.getString("errorReportValve.message")); sb.append("</b> <u>"); sb.append(message).append("</u></p>"); sb.append("<p><b>"); sb.append(sm.getString("errorReportValve.description")); sb.append("</b> <u>"); sb.append(report); sb.append("</u></p>"); if (throwable != null) { String stackTrace = getPartialServletStackTrace(throwable); sb.append("<p><b>"); sb.append(sm.getString("errorReportValve.exception")); sb.append("</b> <pre>"); sb.append(RequestUtil.filter(stackTrace)); sb.append("</pre></p>"); int loops = 0; Throwable rootCause = throwable.getCause(); while (rootCause != null && (loops < 10)) { stackTrace = getPartialServletStackTrace(rootCause); sb.append("<p><b>"); sb.append(sm.getString("errorReportValve.rootCause")); sb.append("</b> <pre>"); sb.append(RequestUtil.filter(stackTrace)); sb.append("</pre></p>"); rootCause = rootCause.getCause(); loops++; } sb.append("<p><b>"); sb.append(sm.getString("errorReportValve.note")); sb.append("</b> <u>"); sb.append(sm.getString("errorReportValve.rootCauseInLogs", ServerInfo.getServerInfo())); sb.append("</u></p>"); } sb.append("<HR size=\"1\" noshade=\"noshade\">"); sb.append("<h3>").append(ServerInfo.getServerInfo()).append("</h3>"); sb.append("</body></html>"); try { try { response.setContentType("text/html"); response.setCharacterEncoding("utf-8"); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); if (container.getLogger().isDebugEnabled()) { container.getLogger().debug("status.setContentType", t); } } Writer writer = response.getReporter(); if (writer != null) { // If writer is null, it's an indication that the response has writer.write(sb.toString()); } } catch (IOException e) { // Ignore } catch (IllegalStateException e) { // Ignore } }
private String attributeValue(Node.JspAttribute attr, boolean encode, Class<?> expectedType) { String v = attr.getValue(); if (!attr.isNamedAttribute() && (v == null)) return ""; if (attr.isExpression()) { if (encode) { return "org.apache.jasper.runtime.JspRuntimeLibrary.URLEncode(String.valueOf(" + v + "), request.getCharacterEncoding())"; } return v; } else if (attr.isELInterpreterInput()) { v = JspUtil.interpreterCall(this.isTagFile, v, expectedType, attr.getEL().getMapName(), false); if (encode) { return "org.apache.jasper.runtime.JspRuntimeLibrary.URLEncode(" + v + ", request.getCharacterEncoding())"; } return v; } else if (attr.isNamedAttribute()) { return attr.getNamedAttributeNode().getTemporaryVariableName(); } else { if (encode) { return "org.apache.jasper.runtime.JspRuntimeLibrary.URLEncode(" + quote(v) + ", request.getCharacterEncoding())"; } return quote(v); } }	@SuppressWarnings("null") private String evaluateAttribute(TagHandlerInfo handlerInfo, Node.JspAttribute attr, Node.CustomTag n, String tagHandlerVar) throws JasperException { String attrValue = attr.getValue(); if (attrValue == null) { if (attr.isNamedAttribute()) { if (n.checkIfAttributeIsJspFragment(attr.getName())) { attrValue = generateNamedAttributeJspFragment(attr.getNamedAttributeNode(), tagHandlerVar); } else { attrValue = generateNamedAttributeValue(attr.getNamedAttributeNode()); } } else { return null; } } String localName = attr.getLocalName(); Method m = null; Class<?>[] c = null; if (attr.isDynamic()) { c = OBJECT_CLASS; } else { m = handlerInfo.getSetterMethod(localName); if (m == null) { err.jspError(n, "jsp.error.unable.to_find_method", attr.getName()); } c = m.getParameterTypes(); // XXX assert(c.length > 0) } if (attr.isExpression()) { // Do nothing } else if (attr.isNamedAttribute()) { if (!n.checkIfAttributeIsJspFragment(attr.getName()) && !attr.isDynamic()) { attrValue = convertString(c[0], attrValue, localName, handlerInfo.getPropertyEditorClass(localName), true); } } else if (attr.isELInterpreterInput()) { StringBuilder sb = new StringBuilder(64); TagAttributeInfo tai = attr.getTagAttributeInfo(); sb.append(getJspContextVar()); sb.append(".getELContext()"); String elContext = sb.toString(); if (attr.getEL() != null && attr.getEL().getMapName() != null) { sb.setLength(0); sb.append("new org.apache.jasper.el.ELContextWrapper("); sb.append(elContext); sb.append(','); sb.append(attr.getEL().getMapName()); sb.append(')'); elContext = sb.toString(); } sb.setLength(0); sb.append(n.getStart().toString()); sb.append(" '"); sb.append(attrValue); sb.append('\''); String mark = sb.toString(); sb.setLength(0); if (attr.isDeferredInput() || ((tai != null) && ValueExpression.class.getName().equals(tai.getTypeName()))) { sb.append("new org.apache.jasper.el.JspValueExpression("); sb.append(quote(mark)); sb.append(','); sb.append(getExpressionFactoryVar()); sb.append(".createValueExpression("); if (attr.getEL() != null) { sb.append(elContext); sb.append(','); } sb.append(quote(attrValue)); sb.append(','); sb.append(JspUtil.toJavaSourceTypeFromTld(attr.getExpectedTypeName())); sb.append("))"); // should the expression be evaluated before passing to boolean evaluate = false; if (tai != null && tai.canBeRequestTime()) { evaluate = true; } if (attr.isDeferredInput()) { evaluate = false; } if (attr.isDeferredInput() && tai != null && tai.canBeRequestTime()) { evaluate = !attrValue.contains("#{"); } if (evaluate) { sb.append(".getValue("); sb.append(getJspContextVar()); sb.append(".getELContext()"); sb.append(")"); } attrValue = sb.toString(); } else if (attr.isDeferredMethodInput() || ((tai != null) && MethodExpression.class.getName().equals(tai.getTypeName()))) { sb.append("new org.apache.jasper.el.JspMethodExpression("); sb.append(quote(mark)); sb.append(','); sb.append(getExpressionFactoryVar()); sb.append(".createMethodExpression("); sb.append(elContext); sb.append(','); sb.append(quote(attrValue)); sb.append(','); sb.append(JspUtil.toJavaSourceTypeFromTld(attr.getExpectedTypeName())); sb.append(','); sb.append("new java.lang.Class[] {"); String[] p = attr.getParameterTypeNames(); for (int i = 0; i < p.length; i++) { sb.append(JspUtil.toJavaSourceTypeFromTld(p[i])); sb.append(','); } if (p.length > 0) { sb.setLength(sb.length() - 1); } sb.append("}))"); attrValue = sb.toString(); } else { String mapName = (attr.getEL() != null) ? attr.getEL().getMapName() : null; attrValue = JspUtil.interpreterCall(this.isTagFile, attrValue, c[0], mapName, false); } } else { attrValue = convertString(c[0], attrValue, localName, handlerInfo.getPropertyEditorClass(localName), false); } return attrValue; }	private void generatePostamble() { out.popIndent(); out.printil("} catch (java.lang.Throwable t) {"); out.pushIndent(); out.printil("if (!(t instanceof javax.servlet.jsp.SkipPageException)){"); out.pushIndent(); out.printil("out = _jspx_out;"); out.printil("if (out != null && out.getBufferSize() != 0)"); out.pushIndent(); out.printil("try { out.clearBuffer(); } catch (java.io.IOException e) {}"); out.popIndent(); out.printil("if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);"); out.printil("else throw new ServletException(t);"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("} finally {"); out.pushIndent(); out.printil("_jspxFactory.releasePageContext(_jspx_page_context);"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); genCommonPostamble(); }	@Override public void visit(Node.ELExpression n) throws JasperException { n.setBeginJavaLine(out.getJavaLine()); if (!pageInfo.isELIgnored() && (n.getEL() != null)) { out.printil("out.write(" + JspUtil.interpreterCall(this.isTagFile, n.getType() + "{" + n.getText() + "}", String.class, n.getEL().getMapName(), false) + ");"); } else { out.printil("out.write(" + quote(n.getType() + "{" + n.getText() + "}") + ");"); } n.setEndJavaLine(out.getJavaLine()); }
protected void parseEndChunk() throws IOException { while (parseHeader()) { // Loop until we run out of headers } }	@Override public int doRead(ByteChunk chunk, Request req) throws IOException { if (endChunk) return -1; if (needCRLFParse) { needCRLFParse = false; parseCRLF(false); } if (remaining <= 0) { if (!parseChunkHeader()) { throw new IOException("Invalid chunk header"); } if (endChunk) { parseEndChunk(); return -1; } } int result = 0; if (pos >= lastValid) { readBytes(); } if (remaining > (lastValid - pos)) { result = lastValid - pos; remaining = remaining - result; chunk.setBytes(buf, pos, result); pos = lastValid; } else { result = remaining; chunk.setBytes(buf, pos, remaining); pos = pos + remaining; remaining = 0; if ((pos + 1) >= lastValid) { //if we call parseCRLF we overrun the buffer here needCRLFParse = true; } else { parseCRLF(false); } } return result; }
private static String digest(String input) { return MD5Encoder.encode(ConcurrentMessageDigest.digestMD5(input.getBytes())); }	protected String generateNonce(Request request) { long currentTime = System.currentTimeMillis(); String ipTimeKey = request.getRemoteAddr() + ":" + currentTime + ":" + getKey(); byte[] buffer = ConcurrentMessageDigest.digestMD5(ipTimeKey.getBytes(B2CConverter.ISO_8859_1)); String nonce = currentTime + ":" + MD5Encoder.encode(buffer); NonceInfo info = new NonceInfo(currentTime, getNonceCountWindowSize()); synchronized (nonces) { nonces.put(nonce, info); } return nonce; }
public boolean isSingleThreadModel() { if (singleThreadModel || instance != null) { return singleThreadModel; } try { Servlet s = allocate(); deallocate(s); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } return (singleThreadModel); }
@Override public void run() { int maintain = 0; while (running) { while (paused) { try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } } while (connectionCount < 1 && addList.size() < 1) { try { if (getSoTimeout() > 0 && running) { maintain(); } synchronized (this) { this.wait(10000); } } catch (InterruptedException e) { // Ignore } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getLog().warn(sm.getString("endpoint.timeout.err")); } } try { if (addList.size() > 0) { synchronized (this) { // Duplicate to another list, so that the syncing is addList.duplicate(localAddList); addList.clear(); } SocketInfo info = localAddList.get(); while (info != null) { if (info.read() || info.write()) { AprSocketWrapper wrapper = connections.get(Long.valueOf(info.socket)); boolean comet = wrapper.isComet(); if (comet) { removeFromPoller(info.socket); } wrapper.pollerFlags = wrapper.pollerFlags | (info.read() ? Poll.APR_POLLIN : 0) | (info.write() ? Poll.APR_POLLOUT : 0); if (!addToPoller(info.socket, wrapper.pollerFlags)) { if (!comet || (comet && !processSocket(info.socket, SocketStatus.ERROR))) { destroySocket(info.socket); } } else { timeouts.add(info.socket, System.currentTimeMillis() + info.timeout); } } else { timeouts.remove(info.socket); destroySocket(info.socket); getLog().warn(sm.getString("endpoint.apr.pollAddInvalid", info)); } info = localAddList.get(); } } for (int i = 0; i < pollers.length; i++) { boolean reset = false; int rv = 0; if (pollerSpace[i] < actualPollerSize) { rv = Poll.poll(pollers[i], pollerTime, desc, true); } if (rv > 0) { pollerSpace[i] += rv; connectionCount -= rv; for (int n = 0; n < rv; n++) { timeouts.remove(desc[n * 2 + 1]); AprSocketWrapper wrapper = connections.get(Long.valueOf(desc[n * 2 + 1])); wrapper.pollerFlags = wrapper.pollerFlags & ~((int) desc[n * 2]); if (wrapper.pollerFlags != 0) { add(desc[n * 2 + 1], 1, wrapper.pollerFlags); } if (wrapper.isComet()) { if (((desc[n * 2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP) || ((desc[n * 2] & Poll.APR_POLLERR) == Poll.APR_POLLERR) || ((desc[n * 2] & Poll.APR_POLLNVAL) == Poll.APR_POLLNVAL)) { if (!processSocket(desc[n * 2 + 1], SocketStatus.ERROR)) { destroySocket(desc[n * 2 + 1]); } } else if ((desc[n * 2] & Poll.APR_POLLIN) == Poll.APR_POLLIN) { if (!processSocket(desc[n * 2 + 1], SocketStatus.OPEN_READ)) { destroySocket(desc[n * 2 + 1]); } } else if ((desc[n * 2] & Poll.APR_POLLOUT) == Poll.APR_POLLOUT) { if (!processSocket(desc[n * 2 + 1], SocketStatus.OPEN_WRITE)) { destroySocket(desc[n * 2 + 1]); } } else { getLog().warn(sm.getString("endpoint.apr.pollUnknownEvent", Long.valueOf(desc[n * 2]))); if (!processSocket(desc[n * 2 + 1], SocketStatus.ERROR)) { destroySocket(desc[n * 2 + 1]); } } } else if (((desc[n * 2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP) || ((desc[n * 2] & Poll.APR_POLLERR) == Poll.APR_POLLERR) || ((desc[n * 2] & Poll.APR_POLLNVAL) == Poll.APR_POLLNVAL)) { destroySocket(desc[n * 2 + 1]); } else if (((desc[n * 2] & Poll.APR_POLLIN) == Poll.APR_POLLIN) || ((desc[n * 2] & Poll.APR_POLLOUT) == Poll.APR_POLLOUT)) { boolean error = false; if (((desc[n * 2] & Poll.APR_POLLIN) == Poll.APR_POLLIN) && !processSocket(desc[n * 2 + 1], SocketStatus.OPEN_READ)) { error = true; destroySocket(desc[n * 2 + 1]); } if (!error && ((desc[n * 2] & Poll.APR_POLLOUT) == Poll.APR_POLLOUT) && !processSocket(desc[n * 2 + 1], SocketStatus.OPEN_WRITE)) { destroySocket(desc[n * 2 + 1]); } } else { getLog().warn(sm.getString("endpoint.apr.pollUnknownEvent", Long.valueOf(desc[n * 2]))); destroySocket(desc[n * 2 + 1]); } } } else if (rv < 0) { int errn = -rv; if ((errn != Status.TIMEUP) && (errn != Status.EINTR)) { if (errn > Status.APR_OS_START_USERERR) { errn -= Status.APR_OS_START_USERERR; } getLog().error(sm.getString("endpoint.apr.pollError", Integer.valueOf(errn), Error.strerror(errn))); reset = true; } } if (reset) { int count = Poll.pollset(pollers[i], desc); long newPoller = allocatePoller(actualPollerSize, pool, -1); pollerSpace[i] = actualPollerSize; connectionCount -= count; Poll.destroy(pollers[i]); pollers[i] = newPoller; } } if (getSoTimeout() > 0 && maintain++ > 1000 && running) { // This works and uses only one timeout mechanism for everything, but the maintain = 0; maintain(); } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); if (maintain == 0) { getLog().warn(sm.getString("endpoint.timeout.error"), t); } else { getLog().warn(sm.getString("endpoint.poll.error"), t); } } } synchronized (this) { this.notifyAll(); } }	public void duplicate(SocketList copy) { copy.size = size; copy.pos = pos; System.arraycopy(sockets, 0, copy.sockets, 0, size); System.arraycopy(timeouts, 0, copy.timeouts, 0, size); System.arraycopy(flags, 0, copy.flags, 0, size); }	public Poller getPoller() { return poller; }	public void duplicate(SocketList copy) { copy.size = size; copy.pos = pos; System.arraycopy(sockets, 0, copy.sockets, 0, size); System.arraycopy(timeouts, 0, copy.timeouts, 0, size); System.arraycopy(flags, 0, copy.flags, 0, size); }	protected Log getLog() { return log; }	@Override public void startInternal() throws Exception { if (!running) { running = true; paused = false; if (getExecutor() == null) { createExecutor(); } initializeConnectionLatch(); poller = new Poller(); poller.init(); Thread pollerThread = new Thread(poller, getName() + "-Poller"); pollerThread.setPriority(threadPriority); pollerThread.setDaemon(true); pollerThread.start(); if (useSendfile) { sendfile = new Sendfile(); sendfile.init(); Thread sendfileThread = new Thread(sendfile, getName() + "-Sendfile"); sendfileThread.setPriority(threadPriority); sendfileThread.setDaemon(true); sendfileThread.start(); } startAcceptorThreads(); Thread timeoutThread = new Thread(new AsyncTimeout(), getName() + "-AsyncTimeout"); timeoutThread.setPriority(threadPriority); timeoutThread.setDaemon(true); timeoutThread.start(); } }	@Override public void stopInternal() { releaseConnectionLatch(); if (!paused) { pause(); } if (running) { running = false; unlockAccept(); for (AbstractEndpoint.Acceptor acceptor : acceptors) { long waitLeft = 10000; while (waitLeft > 0 && acceptor.getState() != AcceptorState.ENDED && serverSock != 0) { try { Thread.sleep(50); } catch (InterruptedException e) { // Ignore } waitLeft -= 50; } if (waitLeft == 0) { log.warn(sm.getString("endpoint.warn.unlockAcceptorFailed", acceptor.getThreadName())); if (serverSock != 0) { Socket.shutdown(serverSock, Socket.APR_SHUTDOWN_READ); serverSock = 0; } } } try { poller.destroy(); } catch (Exception e) { // Ignore } poller = null; connections.clear(); if (useSendfile) { try { sendfile.destroy(); } catch (Exception e) { // Ignore } sendfile = null; } } shutdownExecutor(); }
private void checkThreadLocalsForLeaks() { Thread[] threads = getThreads(); try { // Make the fields in the Thread class that store ThreadLocals Field threadLocalsField = Thread.class.getDeclaredField("threadLocals"); threadLocalsField.setAccessible(true); Field inheritableThreadLocalsField = Thread.class.getDeclaredField("inheritableThreadLocals"); inheritableThreadLocalsField.setAccessible(true); // Make the underlying array of ThreadLoad.ThreadLocalMap.Entry objects Class<?> tlmClass = Class.forName("java.lang.ThreadLocal$ThreadLocalMap"); Field tableField = tlmClass.getDeclaredField("table"); tableField.setAccessible(true); Method expungeStaleEntriesMethod = tlmClass.getDeclaredMethod("expungeStaleEntries"); expungeStaleEntriesMethod.setAccessible(true); for (int i = 0; i < threads.length; i++) { Object threadLocalMap; if (threads[i] != null) { threadLocalMap = threadLocalsField.get(threads[i]); if (null != threadLocalMap) { expungeStaleEntriesMethod.invoke(threadLocalMap); checkThreadLocalMapForLeaks(threadLocalMap, tableField); } threadLocalMap = inheritableThreadLocalsField.get(threads[i]); if (null != threadLocalMap) { expungeStaleEntriesMethod.invoke(threadLocalMap); checkThreadLocalMapForLeaks(threadLocalMap, tableField); } } } } catch (SecurityException e) { log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail", getContextName()), e); } catch (NoSuchFieldException e) { log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail", getContextName()), e); } catch (ClassNotFoundException e) { log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail", getContextName()), e); } catch (IllegalArgumentException e) { log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail", getContextName()), e); } catch (IllegalAccessException e) { log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail", getContextName()), e); } catch (InvocationTargetException e) { log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail", getContextName()), e); } catch (NoSuchMethodException e) { log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail", getContextName()), e); } }

@Override public ELContext getELContext() { return this.invokingJspCtxt.getELContext(); /* if (this.elContext != null) { JspFactory jspFact = JspFactory.getDefaultFactory(); ServletContext servletContext = this.getServletContext(); JspApplicationContextImpl jspCtx = (JspApplicationContextImpl) jspFact .getJspApplicationContext(servletContext); this.elContext = jspCtx.createELContext(this); } return this.elContext; */ }	@Override public HttpSession getSession() { return invokingJspCtxt.getSession(); }	@Override public JspWriter getOut() { return invokingJspCtxt.getOut(); }	@Override public Object findAttribute(String name) { if (name == null) { throw new NullPointerException(Localizer.getMessage("jsp.error.attribute.null_name")); } Object o = pageAttributes.get(name); if (o == null) { o = invokingJspCtxt.getAttribute(name, REQUEST_SCOPE); if (o == null) { if (getSession() != null) { o = invokingJspCtxt.getAttribute(name, SESSION_SCOPE); } if (o == null) { o = invokingJspCtxt.getAttribute(name, APPLICATION_SCOPE); } } } return o; }	@Override public Object getAttribute(String name, int scope) { if (name == null) { throw new NullPointerException(Localizer.getMessage("jsp.error.attribute.null_name")); } if (scope == PAGE_SCOPE) { return pageAttributes.get(name); } return invokingJspCtxt.getAttribute(name, scope); }	@Override public ServletContext getServletContext() { return invokingJspCtxt.getServletContext(); }	@Override public ServletResponse getResponse() { return invokingJspCtxt.getResponse(); }	@Override public Enumeration<String> getAttributeNamesInScope(int scope) { if (scope == PAGE_SCOPE) { return Collections.enumeration(pageAttributes.keySet()); } return invokingJspCtxt.getAttributeNamesInScope(scope); }	@Override public void removeAttribute(String name) { if (name == null) { throw new NullPointerException(Localizer.getMessage("jsp.error.attribute.null_name")); } pageAttributes.remove(name); invokingJspCtxt.removeAttribute(name, REQUEST_SCOPE); if (getSession() != null) { invokingJspCtxt.removeAttribute(name, SESSION_SCOPE); } invokingJspCtxt.removeAttribute(name, APPLICATION_SCOPE); }	@Override public void removeAttribute(String name, int scope) { if (name == null) { throw new NullPointerException(Localizer.getMessage("jsp.error.attribute.null_name")); } if (scope == PAGE_SCOPE) { pageAttributes.remove(name); } else { invokingJspCtxt.removeAttribute(name, scope); } }	@Override public void setAttribute(String name, Object value, int scope) { if (name == null) { throw new NullPointerException(Localizer.getMessage("jsp.error.attribute.null_name")); } if (scope == PAGE_SCOPE) { if (value != null) { pageAttributes.put(name, value); } else { removeAttribute(name, PAGE_SCOPE); } } else { invokingJspCtxt.setAttribute(name, value, scope); } }
@Override public UniqueId send(Member[] destination, Serializable msg, int options) throws ChannelException { return send(destination, msg, options, null); }	@Override public void heartbeat() { super.heartbeat(); Iterator<Object> i = membershipListeners.iterator(); while (i.hasNext()) { Object o = i.next(); if (o instanceof Heartbeat) ((Heartbeat) o).heartbeat(); } i = channelListeners.iterator(); while (i.hasNext()) { Object o = i.next(); if (o instanceof Heartbeat) ((Heartbeat) o).heartbeat(); } }
@Override public void javacError(JavacErrorDetail[] details) throws JasperException { if (details == null) { return; } Object[] args = null; StringBuilder buf = new StringBuilder(); for (int i = 0; i < details.length; i++) { if (details[i].getJspBeginLineNumber() >= 0) { args = new Object[] { Integer.valueOf(details[i].getJspBeginLineNumber()), details[i].getJspFileName() }; buf.append(Constants.NEWLINE); buf.append(Constants.NEWLINE); buf.append(Localizer.getMessage("jsp.error.single.line.number", args)); buf.append(Constants.NEWLINE); buf.append(details[i].getErrorMessage()); buf.append(Constants.NEWLINE); buf.append(details[i].getJspExtract()); } else { args = new Object[] { Integer.valueOf(details[i].getJavaLineNumber()) }; buf.append(Constants.NEWLINE); buf.append(Constants.NEWLINE); buf.append(Localizer.getMessage("jsp.error.java.line.number", args)); buf.append(Constants.NEWLINE); buf.append(details[i].getErrorMessage()); } } buf.append(Constants.NEWLINE); buf.append(Constants.NEWLINE); buf.append("Stacktrace:"); throw new JasperException(Localizer.getMessage("jsp.error.unable.compile") + ": " + buf); }
protected ArrayList<String> getRoles(Connection dbConnection, String username) { if (allRolesMode != AllRolesMode.STRICT_MODE && !isRoleStoreDefined()) { return null; } ResultSet rs = null; PreparedStatement stmt = null; ArrayList<String> list = null; try { stmt = roles(dbConnection, username); rs = stmt.executeQuery(); list = new ArrayList<>(); while (rs.next()) { String role = rs.getString(1); if (role != null) { list.add(role.trim()); } } return list; } catch (SQLException e) { containerLog.error(sm.getString("dataSourceRealm.getRoles.exception", username)); } finally { try { if (rs != null) { rs.close(); } if (stmt != null) { stmt.close(); } } catch (SQLException e) { containerLog.error(sm.getString("dataSourceRealm.getRoles.exception", username)); } } return null; }	protected String getPassword(Connection dbConnection, String username) { ResultSet rs = null; PreparedStatement stmt = null; String dbCredentials = null; try { stmt = credentials(dbConnection, username); rs = stmt.executeQuery(); if (rs.next()) { dbCredentials = rs.getString(1); } return (dbCredentials != null) ? dbCredentials.trim() : null; } catch (SQLException e) { containerLog.error(sm.getString("dataSourceRealm.getPassword.exception", username)); } finally { try { if (rs != null) { rs.close(); } if (stmt != null) { stmt.close(); } } catch (SQLException e) { containerLog.error(sm.getString("dataSourceRealm.getPassword.exception", username)); } } return null; }
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType("text/plain"); resp.getWriter().print("envEntry: " + envEntry); }	protected void populateAnnotationsCache(Class<?> clazz, Map<String, String> injections) throws IllegalAccessException, InvocationTargetException, NamingException { List<AnnotationCacheEntry> annotations = null; while (clazz != null) { AnnotationCacheEntry[] annotationsArray = null; synchronized (annotationCache) { annotationsArray = annotationCache.get(clazz); } if (annotationsArray == null) { if (annotations == null) { annotations = new ArrayList<>(); } else { annotations.clear(); } if (context != null) { // Initialize fields annotations for resource injection if Field[] fields = Introspection.getDeclaredFields(clazz); for (Field field : fields) { if (injections != null && injections.containsKey(field.getName())) { annotations.add(new AnnotationCacheEntry(field.getName(), null, injections.get(field.getName()), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(Resource.class)) { Resource annotation = field.getAnnotation(Resource.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(EJB.class)) { EJB annotation = field.getAnnotation(EJB.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(WebServiceRef.class)) { WebServiceRef annotation = field.getAnnotation(WebServiceRef.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(PersistenceContext.class)) { PersistenceContext annotation = field.getAnnotation(PersistenceContext.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(PersistenceUnit.class)) { PersistenceUnit annotation = field.getAnnotation(PersistenceUnit.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } } } Method[] methods = Introspection.getDeclaredMethods(clazz); Method postConstruct = null; String postConstructFromXml = postConstructMethods.get(clazz.getName()); Method preDestroy = null; String preDestroyFromXml = preDestroyMethods.get(clazz.getName()); for (Method method : methods) { if (context != null) { if (injections != null && Introspection.isValidSetter(method)) { String fieldName = Introspection.getPropertyName(method); if (injections.containsKey(fieldName)) { annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), injections.get(method.getName()), AnnotationCacheEntryType.SETTER)); break; } } if (method.isAnnotationPresent(Resource.class)) { Resource annotation = method.getAnnotation(Resource.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(EJB.class)) { EJB annotation = method.getAnnotation(EJB.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(WebServiceRef.class)) { WebServiceRef annotation = method.getAnnotation(WebServiceRef.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(PersistenceContext.class)) { PersistenceContext annotation = method.getAnnotation(PersistenceContext.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(PersistenceUnit.class)) { PersistenceUnit annotation = method.getAnnotation(PersistenceUnit.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } } postConstruct = findPostConstruct(postConstruct, postConstructFromXml, method); preDestroy = findPreDestroy(preDestroy, preDestroyFromXml, method); } if (postConstruct != null) { annotations.add(new AnnotationCacheEntry(postConstruct.getName(), postConstruct.getParameterTypes(), null, AnnotationCacheEntryType.POST_CONSTRUCT)); } else if (postConstructFromXml != null) { throw new IllegalArgumentException("Post construct method " + postConstructFromXml + " for class " + clazz.getName() + " is declared in deployment descriptor but cannot be found."); } if (preDestroy != null) { annotations.add(new AnnotationCacheEntry(preDestroy.getName(), preDestroy.getParameterTypes(), null, AnnotationCacheEntryType.PRE_DESTROY)); } else if (preDestroyFromXml != null) { throw new IllegalArgumentException("Pre destroy method " + preDestroyFromXml + " for class " + clazz.getName() + " is declared in deployment descriptor but cannot be found."); } if (annotations.isEmpty()) { annotationsArray = ANNOTATIONS_EMPTY; } else { annotationsArray = annotations.toArray(new AnnotationCacheEntry[annotations.size()]); } synchronized (annotationCache) { annotationCache.put(clazz, annotationsArray); } } clazz = clazz.getSuperclass(); } }	@Test public void testBug54379() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0-fragments"); Context context = tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); Tomcat.addServlet(context, "TestServlet", "org.apache.catalina.startup.TesterServletWithLifeCycleMethods"); context.addServletMapping("/testServlet", "TestServlet"); tomcat.enableNaming(); tomcat.start(); assertPageContains("/test/testServlet", "postConstruct1()"); }	@Test public void testBug54448() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0-fragments"); Context context = tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); Tomcat.addServlet(context, "TestServlet", "org.apache.catalina.startup.TesterServletWithAnnotations"); context.addServletMapping("/testServlet", "TestServlet"); tomcat.enableNaming(); tomcat.start(); assertPageContains("/test/testServlet", "envEntry: 1"); }
private Class<?> convertPrimitiveType(Class<?> clazz) { if (clazz.equals(char.class)) { return Character.class; } else if (clazz.equals(int.class)) { return Integer.class; } else if (clazz.equals(boolean.class)) { return Boolean.class; } else if (clazz.equals(double.class)) { return Double.class; } else if (clazz.equals(byte.class)) { return Byte.class; } else if (clazz.equals(short.class)) { return Short.class; } else if (clazz.equals(long.class)) { return Long.class; } else if (clazz.equals(float.class)) { return Float.class; } else { return clazz; } }	static String getType(Resource annotation, String defaultType) { String type = annotation.type().getCanonicalName(); if (type == null || type.equals("java.lang.Object")) { if (defaultType != null) { type = defaultType; } } return type; }	protected static void addResource(Context context, Resource annotation, String defaultName, String defaultType) { String name = getName(annotation, defaultName); String type = getType(annotation, defaultType); if (type.equals("java.lang.String") || type.equals("java.lang.Character") || type.equals("java.lang.Integer") || type.equals("java.lang.Boolean") || type.equals("java.lang.Double") || type.equals("java.lang.Byte") || type.equals("java.lang.Short") || type.equals("java.lang.Long") || type.equals("java.lang.Float")) { ContextEnvironment resource = new ContextEnvironment(); resource.setName(name); resource.setType(type); resource.setDescription(annotation.description()); resource.setValue(annotation.mappedName()); context.getNamingResources().addEnvironment(resource); } else if (type.equals("javax.xml.rpc.Service")) { ContextService service = new ContextService(); service.setName(name); service.setWsdlfile(annotation.mappedName()); service.setType(type); service.setDescription(annotation.description()); context.getNamingResources().addService(service); } else if (type.equals("javax.sql.DataSource") || type.equals("javax.jms.ConnectionFactory") || type.equals("javax.jms.QueueConnectionFactory") || type.equals("javax.jms.TopicConnectionFactory") || type.equals("javax.mail.Session") || type.equals("java.net.URL") || type.equals("javax.resource.cci.ConnectionFactory") || type.equals("org.omg.CORBA_2_3.ORB") || type.endsWith("ConnectionFactory")) { ContextResource resource = new ContextResource(); resource.setName(name); resource.setType(type); if (annotation.authenticationType() == Resource.AuthenticationType.CONTAINER) { resource.setAuth("Container"); } } }	protected static void loadFieldsAnnotation(Context context, Class<?> classClass) { Field[] fields = Introspection.getDeclaredFields(classClass); if (fields != null && fields.length > 0) { for (Field field : fields) { if (field.isAnnotationPresent(Resource.class)) { Resource annotation = field.getAnnotation(Resource.class); String defaultName = classClass.getName() + SEPARATOR + field.getName(); String defaultType = field.getType().getCanonicalName(); addResource(context, annotation, defaultName, defaultType); } } } }	protected static void loadMethodsAnnotation(Context context, Class<?> classClass) { Method[] methods = Introspection.getDeclaredMethods(classClass); if (methods != null && methods.length > 0) { for (Method method : methods) { if (method.isAnnotationPresent(Resource.class)) { Resource annotation = method.getAnnotation(Resource.class); if (!Introspection.isValidSetter(method)) { throw new IllegalArgumentException(sm.getString("webAnnotationSet.invalidInjection")); } String defaultName = classClass.getName() + SEPARATOR + Introspection.getPropertyName(method); String defaultType = (method.getParameterTypes()[0]).getCanonicalName(); addResource(context, annotation, defaultName, defaultType); } } } }	public static Class<?> loadClass(Context context, String className) { ClassLoader cl = context.getLoader().getClassLoader(); Log log = context.getLogger(); Class<?> clazz = null; try { clazz = cl.loadClass(className); } catch (ClassNotFoundException e) { log.debug(sm.getString("introspection.classLoadFailed"), e); } catch (NoClassDefFoundError e) { log.debug(sm.getString("introspection.classLoadFailed"), e); } catch (ClassFormatError e) { log.debug(sm.getString("introspection.classLoadFailed"), e); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("introspection.classLoadFailed"), t); } return clazz; }	@Test public void testBug54379() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0-fragments"); Context context = tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); Tomcat.addServlet(context, "TestServlet", "org.apache.catalina.startup.TesterServletWithLifeCycleMethods"); context.addServletMapping("/testServlet", "TestServlet"); tomcat.enableNaming(); tomcat.start(); assertPageContains("/test/testServlet", "postConstruct1()"); }
public void setSSLVerifyDepth(int SSLVerifyDepth) { ((AprEndpoint) endpoint).setSSLVerifyDepth(SSLVerifyDepth); }	public boolean getSSLHonorCipherOrder() { return SSLHonorCipherOrder; }	@Override public void bind() throws Exception { try { rootPool = Pool.create(0); } catch (UnsatisfiedLinkError e) { throw new Exception(sm.getString("endpoint.init.notavail")); } serverSockPool = Pool.create(rootPool); String addressStr = null; if (getAddress() != null) { addressStr = getAddress().getHostAddress(); } int family = Socket.APR_INET; if (Library.APR_HAVE_IPV6) { if (addressStr == null) { if (!OS.IS_BSD && !OS.IS_WIN32 && !OS.IS_WIN64) family = Socket.APR_UNSPEC; } else if (addressStr.indexOf(':') >= 0) { family = Socket.APR_UNSPEC; } } long inetAddress = Address.info(addressStr, family, getPort(), 0, rootPool); serverSock = Socket.create(Address.getInfo(inetAddress).family, Socket.SOCK_STREAM, Socket.APR_PROTO_TCP, rootPool); if (OS.IS_UNIX) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } Socket.optSet(serverSock, Socket.APR_SO_KEEPALIVE, 1); int ret = Socket.bind(serverSock, inetAddress); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.bind", "" + ret, Error.strerror(ret))); } ret = Socket.listen(serverSock, getBacklog()); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.listen", "" + ret, Error.strerror(ret))); } if (OS.IS_WIN32 || OS.IS_WIN64) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } if (useSendfile && !Library.APR_HAS_SENDFILE) { useSendfile = false; } if (acceptorThreadCount == 0) { acceptorThreadCount = 1; } if (deferAccept) { if (Socket.optSet(serverSock, Socket.APR_TCP_DEFER_ACCEPT, 1) == Status.APR_ENOTIMPL) { deferAccept = false; } } if (isSSLEnabled()) { if (SSLCertificateFile == null) { throw new Exception(sm.getString("endpoint.apr.noSslCertFile")); } int value = SSL.SSL_PROTOCOL_NONE; if (SSLProtocol == null || SSLProtocol.length() == 0) { value = SSL.SSL_PROTOCOL_ALL; } else { for (String protocol : SSLProtocol.split("\\+")) { protocol = protocol.trim(); if ("SSLv2".equalsIgnoreCase(protocol)) { value |= SSL.SSL_PROTOCOL_SSLV2; } else if ("SSLv3".equalsIgnoreCase(protocol)) { value |= SSL.SSL_PROTOCOL_SSLV3; } else if ("TLSv1".equalsIgnoreCase(protocol)) { value |= SSL.SSL_PROTOCOL_TLSV1; } else if ("all".equalsIgnoreCase(protocol)) { value |= SSL.SSL_PROTOCOL_ALL; } else { throw new Exception(sm.getString("endpoint.apr.invalidSslProtocol", SSLProtocol)); } } } sslContext = SSLContext.make(rootPool, value, SSL.SSL_MODE_SERVER); if (SSLInsecureRenegotiation) { boolean legacyRenegSupported = false; try { legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); if (legacyRenegSupported) SSLContext.setOptions(sslContext, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); } catch (UnsatisfiedLinkError e) { // Ignore } if (!legacyRenegSupported) { log.warn(sm.getString("endpoint.warn.noInsecureReneg", SSL.versionString())); } } if (SSLHonorCipherOrder) { boolean orderCiphersSupported = false; try { orderCiphersSupported = SSL.hasOp(SSL.SSL_OP_CIPHER_SERVER_PREFERENCE); if (orderCiphersSupported) SSLContext.setOptions(sslContext, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE); } catch (UnsatisfiedLinkError e) { // Ignore } if (!orderCiphersSupported) { log.warn(sm.getString("endpoint.warn.noHonorCipherOrder", SSL.versionString())); } } SSLContext.setCipherSuite(sslContext, SSLCipherSuite); SSLContext.setCertificate(sslContext, SSLCertificateFile, SSLCertificateKeyFile, SSLPassword, SSL.SSL_AIDX_RSA); SSLContext.setCertificateChainFile(sslContext, SSLCertificateChainFile, false); SSLContext.setCACertificate(sslContext, SSLCACertificateFile, SSLCACertificatePath); SSLContext.setCARevocation(sslContext, SSLCARevocationFile, SSLCARevocationPath); value = SSL.SSL_CVERIFY_NONE; if ("optional".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL; } else if ("require".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_REQUIRE; } else if ("optionalNoCA".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA; } SSLContext.setVerify(sslContext, value, SSLVerifyDepth); useSendfile = false; } }
@Override public Principal authenticate(String username, String clientDigest, String nonce, String nc, String cnonce, String qop, String realm, String md5a2) { String md5a1 = getDigest(username, realm).toLowerCase(Locale.ENGLISH); if (md5a1 == null) return null; String serverDigestValue; if (qop == null) { serverDigestValue = md5a1 + ":" + nonce + ":" + md5a2; } else { serverDigestValue = md5a1 + ":" + nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + md5a2; } byte[] valueBytes = null; try { valueBytes = serverDigestValue.getBytes(getDigestCharset()); } catch (UnsupportedEncodingException uee) { log.error("Illegal digestEncoding: " + getDigestEncoding(), uee); throw new IllegalArgumentException(uee.getMessage()); } String serverDigest = null; synchronized (md5Helper) { serverDigest = MD5Encoder.encode(md5Helper.digest(valueBytes)); } if (log.isDebugEnabled()) { log.debug("Digest : " + clientDigest + " Username:" + username + " ClientSigest:" + clientDigest + " nonce:" + nonce + " nc:" + nc + " cnonce:" + cnonce + " qop:" + qop + " realm:" + realm + "md5a2:" + md5a2 + " Server digest:" + serverDigest); } if (serverDigest.equals(clientDigest)) { return getPrincipal(username); } return null; }
protected void initClassLoader(JspCompilationContext clctxt) throws IOException { classPath = getClassPath(); ClassLoader jspcLoader = getClass().getClassLoader(); if (jspcLoader instanceof AntClassLoader) { classPath += File.pathSeparator + ((AntClassLoader) jspcLoader).getClasspath(); } ArrayList<URL> urls = new ArrayList<>(); StringTokenizer tokenizer = new StringTokenizer(classPath, File.pathSeparator); while (tokenizer.hasMoreTokens()) { String path = tokenizer.nextToken(); try { File libFile = new File(path); urls.add(libFile.toURI().toURL()); } catch (IOException ioe) { throw new RuntimeException(ioe.toString()); } } File webappBase = new File(uriRoot); if (webappBase.exists()) { File classes = new File(webappBase, "/WEB-INF/classes"); try { if (classes.exists()) { classPath = classPath + File.pathSeparator + classes.getCanonicalPath(); urls.add(classes.getCanonicalFile().toURI().toURL()); } } catch (IOException ioe) { throw new RuntimeException(ioe.toString()); } File lib = new File(webappBase, "/WEB-INF/lib"); if (lib.exists() && lib.isDirectory()) { String[] libs = lib.list(); for (int i = 0; i < libs.length; i++) { if (libs[i].length() < 5) continue; String ext = libs[i].substring(libs[i].length() - 4); if (!".jar".equalsIgnoreCase(ext)) { if (".tld".equalsIgnoreCase(ext)) { log.warn("TLD files should not be placed in " + "/WEB-INF/lib"); } continue; } try { File libFile = new File(lib, libs[i]); classPath = classPath + File.pathSeparator + libFile.getAbsolutePath(); urls.add(libFile.getAbsoluteFile().toURI().toURL()); } catch (IOException ioe) { throw new RuntimeException(ioe.toString()); } } } } urls.add(new File(clctxt.getRealPath("/")).getCanonicalFile().toURI().toURL()); URL[] urlsA = new URL[urls.size()]; urls.toArray(urlsA); loader = new URLClassLoader(urlsA, this.getClass().getClassLoader()); }	@Override public ClassLoader getClassLoader() { return null; }
private void initServerSocket(ServerSocket ssocket) { SSLServerSocket socket = (SSLServerSocket) ssocket; if (enabledCiphers != null) { socket.setEnabledCipherSuites(enabledCiphers); } String[] requestedProtocols = endpoint.getSslEnabledProtocolsArray(); setEnabledProtocols(socket, getEnabledProtocols(socket, requestedProtocols)); // we don't know if client auth is needed - configureClientAuth(socket); }	protected Collection<? extends CRL> getCRLs(String crlf) throws IOException, CRLException, CertificateException { File crlFile = new File(crlf); if (!crlFile.isAbsolute()) { crlFile = new File(System.getProperty(Constants.CATALINA_BASE_PROP), crlf); } Collection<? extends CRL> crls = null; InputStream is = null; try { CertificateFactory cf = CertificateFactory.getInstance("X.509"); is = new FileInputStream(crlFile); crls = cf.generateCRLs(is); } catch (IOException iex) { throw iex; } catch (CRLException crle) { throw crle; } catch (CertificateException ce) { throw ce; } finally { if (is != null) { try { is.close(); } catch (Exception ex) { // Ignore } } } return crls; }	protected SSLEngine createSSLEngine() { SSLEngine engine = sslContext.createSSLEngine(); if ("false".equals(getClientAuth())) { engine.setNeedClientAuth(false); engine.setWantClientAuth(false); } else if ("true".equals(getClientAuth()) || "yes".equals(getClientAuth())) { engine.setNeedClientAuth(true); } else if ("want".equals(getClientAuth())) { engine.setWantClientAuth(true); } engine.setUseClientMode(false); if (getCiphersArray().length > 0) engine.setEnabledCipherSuites(getCiphersArray()); if (getSslEnabledProtocolsArray().length > 0) engine.setEnabledProtocols(getSslEnabledProtocolsArray()); handler.onCreateSSLEngine(engine); return engine; }	protected String[] getEnabledProtocols(SSLServerSocket socket, String[] requestedProtocols) { String[] supportedProtocols = socket.getSupportedProtocols(); String[] enabledProtocols = null; if (requestedProtocols != null && requestedProtocols.length > 0) { Vector<String> vec = null; for (String protocol : requestedProtocols) { for (int i = 0; supportedProtocols != null && i < supportedProtocols.length; i++) { if (supportedProtocols[i].equals(protocol)) { if (vec == null) { vec = new Vector<>(); } vec.addElement(protocol); break; } } } if (vec != null) { enabledProtocols = new String[vec.size()]; vec.copyInto(enabledProtocols); } } return enabledProtocols; }	@Override public String[] getCiphersUsed() { SSLContext sslContext = getSSLContext(); if (sslContext != null) { SSLEngine engine = getSSLContext().createSSLEngine(); if (getCiphersArray().length > 0) { engine.setEnabledCipherSuites(getCiphersArray()); } return engine.getEnabledCipherSuites(); } else { return new String[0]; } }	public KeyManager[] wrap(KeyManager[] managers) { if (managers == null) return null; KeyManager[] result = new KeyManager[managers.length]; for (int i = 0; i < result.length; i++) { if (managers[i] instanceof X509KeyManager && getKeyAlias() != null) { result[i] = new NioX509KeyManager((X509KeyManager) managers[i], getKeyAlias()); } else { result[i] = managers[i]; } } return result; }	public String[] getEnabledCiphers() { return enabledCiphers; }	public void setSSLContext(SSLContext c) { sslContext = c; }	void init() throws IOException { try { String clientAuthStr = endpoint.getClientAuth(); if ("true".equalsIgnoreCase(clientAuthStr) || "yes".equalsIgnoreCase(clientAuthStr)) { requireClientAuth = true; } else if ("want".equalsIgnoreCase(clientAuthStr)) { wantClientAuth = true; } SSLContext context = createSSLContext(); context.init(getKeyManagers(), getTrustManagers(), null); SSLSessionContext sessionContext = context.getServerSessionContext(); if (sessionContext != null) { configureSessionContext(sessionContext); } sslProxy = context.getServerSocketFactory(); String requestedCiphers = endpoint.getCiphers(); enabledCiphers = getEnabledCiphers(requestedCiphers, sslProxy.getSupportedCipherSuites()); allowUnsafeLegacyRenegotiation = "true".equals(endpoint.getAllowUnsafeLegacyRenegotiation()); checkConfig(); } catch (Exception e) { if (e instanceof IOException) throw (IOException) e; throw new IOException(e.getMessage(), e); } }
public Map<String, String> getServletMappings() { return servletMappings; }	@Test public void testLifecycleMethodsWebFragmentsWithConflicts() { WebXml webxml = new WebXml(); WebXml fragment1 = new WebXml(); fragment1.addPostConstructMethods("a", "a"); fragment1.addPreDestroyMethods("b", "a"); WebXml fragment2 = new WebXml(); fragment2.addPostConstructMethods("a", "b"); Set<WebXml> fragments = new HashSet<>(); fragments.add(fragment1); fragments.add(fragment2); Assert.assertFalse(webxml.merge(fragments)); Assert.assertEquals(0, webxml.getPostConstructMethods().size()); WebXml fragment3 = new WebXml(); fragment3.addPreDestroyMethods("b", "b"); fragments.remove(fragment2); fragments.add(fragment3); Assert.assertFalse(webxml.merge(fragments)); Assert.assertEquals(0, webxml.getPreDestroyMethods().size()); }
public static Set<WebXml> orderWebFragments(WebXml application, Map<String, WebXml> fragments, ServletContext servletContext) { Set<WebXml> orderedFragments = new LinkedHashSet<>(); boolean absoluteOrdering = (application.getAbsoluteOrdering() != null); boolean orderingPresent = false; if (absoluteOrdering) { orderingPresent = true; Set<String> requestedOrder = application.getAbsoluteOrdering(); for (String requestedName : requestedOrder) { if (WebXml.ORDER_OTHERS.equals(requestedName)) { for (Entry<String, WebXml> entry : fragments.entrySet()) { if (!requestedOrder.contains(entry.getKey())) { WebXml fragment = entry.getValue(); if (fragment != null) { orderedFragments.add(fragment); } } } } else { WebXml fragment = fragments.get(requestedName); if (fragment != null) { orderedFragments.add(fragment); } else { log.warn(sm.getString("webXml.wrongFragmentName", requestedName)); } } } } else { for (WebXml fragment : fragments.values()) { Iterator<String> before = fragment.getBeforeOrdering().iterator(); while (before.hasNext()) { orderingPresent = true; String beforeEntry = before.next(); if (!beforeEntry.equals(ORDER_OTHERS)) { WebXml beforeFragment = fragments.get(beforeEntry); if (beforeFragment == null) { before.remove(); } else { beforeFragment.addAfterOrdering(fragment.getName()); } } } Iterator<String> after = fragment.getAfterOrdering().iterator(); while (after.hasNext()) { orderingPresent = true; String afterEntry = after.next(); if (!afterEntry.equals(ORDER_OTHERS)) { WebXml afterFragment = fragments.get(afterEntry); if (afterFragment == null) { after.remove(); } else { afterFragment.addBeforeOrdering(fragment.getName()); } } } } for (WebXml fragment : fragments.values()) { if (fragment.getBeforeOrdering().contains(ORDER_OTHERS)) { makeBeforeOthersExplicit(fragment.getAfterOrdering(), fragments); } if (fragment.getAfterOrdering().contains(ORDER_OTHERS)) { makeAfterOthersExplicit(fragment.getBeforeOrdering(), fragments); } } Set<WebXml> beforeSet = new HashSet<>(); Set<WebXml> othersSet = new HashSet<>(); Set<WebXml> afterSet = new HashSet<>(); for (WebXml fragment : fragments.values()) { if (fragment.getBeforeOrdering().contains(ORDER_OTHERS)) { beforeSet.add(fragment); fragment.getBeforeOrdering().remove(ORDER_OTHERS); } else if (fragment.getAfterOrdering().contains(ORDER_OTHERS)) { afterSet.add(fragment); fragment.getAfterOrdering().remove(ORDER_OTHERS); } else { othersSet.add(fragment); } } // Stage 4. Decouple the groups so the ordering requirements for // each fragment in the group only refer to other fragments // in the group. Ordering requirements outside the group // will be handled by processing the groups in order. // Note: Only after ordering requirements are considered. decoupleOtherGroups(beforeSet); decoupleOtherGroups(othersSet); decoupleOtherGroups(afterSet); // Stage 5. Order each group // Note: Only after ordering requirements are considered. orderFragments(orderedFragments, beforeSet); orderFragments(orderedFragments, othersSet); orderFragments(orderedFragments, afterSet); } if (servletContext != null) { List<String> orderedJarFileNames = null; if (orderingPresent) { orderedJarFileNames = new ArrayList<>(); for (WebXml fragment : orderedFragments) { orderedJarFileNames.add(fragment.getJarName()); } } servletContext.setAttribute(ServletContext.ORDERED_LIBS, orderedJarFileNames); } return orderedFragments; }	protected void populateAnnotationsCache(Class<?> clazz, Map<String, String> injections) throws IllegalAccessException, InvocationTargetException, NamingException { List<AnnotationCacheEntry> annotations = null; while (clazz != null) { AnnotationCacheEntry[] annotationsArray = null; synchronized (annotationCache) { annotationsArray = annotationCache.get(clazz); } if (annotationsArray == null) { if (annotations == null) { annotations = new ArrayList<>(); } else { annotations.clear(); } if (context != null) { // Initialize fields annotations for resource injection if Field[] fields = Introspection.getDeclaredFields(clazz); for (Field field : fields) { if (injections != null && injections.containsKey(field.getName())) { annotations.add(new AnnotationCacheEntry(field.getName(), null, injections.get(field.getName()), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(Resource.class)) { Resource annotation = field.getAnnotation(Resource.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(EJB.class)) { EJB annotation = field.getAnnotation(EJB.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(WebServiceRef.class)) { WebServiceRef annotation = field.getAnnotation(WebServiceRef.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(PersistenceContext.class)) { PersistenceContext annotation = field.getAnnotation(PersistenceContext.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(PersistenceUnit.class)) { PersistenceUnit annotation = field.getAnnotation(PersistenceUnit.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } } } Method[] methods = Introspection.getDeclaredMethods(clazz); Method postConstruct = null; Method preDestroy = null; for (Method method : methods) { if (context != null) { if (injections != null && Introspection.isValidSetter(method)) { String fieldName = Introspection.getPropertyName(method); if (injections.containsKey(fieldName)) { annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), injections.get(method.getName()), AnnotationCacheEntryType.SETTER)); break; } } if (method.isAnnotationPresent(Resource.class)) { Resource annotation = method.getAnnotation(Resource.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(EJB.class)) { EJB annotation = method.getAnnotation(EJB.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(WebServiceRef.class)) { WebServiceRef annotation = method.getAnnotation(WebServiceRef.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(PersistenceContext.class)) { PersistenceContext annotation = method.getAnnotation(PersistenceContext.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(PersistenceUnit.class)) { PersistenceUnit annotation = method.getAnnotation(PersistenceUnit.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } } if (method.isAnnotationPresent(PostConstruct.class)) { if ((postConstruct != null) || (method.getParameterTypes().length != 0) || (Modifier.isStatic(method.getModifiers())) || (method.getExceptionTypes().length > 0) || (!method.getReturnType().getName().equals("void"))) { throw new IllegalArgumentException("Invalid PostConstruct annotation"); } postConstruct = method; } if (method.isAnnotationPresent(PreDestroy.class)) { if ((preDestroy != null || method.getParameterTypes().length != 0) || (Modifier.isStatic(method.getModifiers())) || (method.getExceptionTypes().length > 0) || (!method.getReturnType().getName().equals("void"))) { throw new IllegalArgumentException("Invalid PreDestroy annotation"); } preDestroy = method; } } if (postConstruct != null) { annotations.add(new AnnotationCacheEntry(postConstruct.getName(), postConstruct.getParameterTypes(), null, AnnotationCacheEntryType.POST_CONSTRUCT)); } if (preDestroy != null) { annotations.add(new AnnotationCacheEntry(preDestroy.getName(), preDestroy.getParameterTypes(), null, AnnotationCacheEntryType.PRE_DESTROY)); } if (annotations.isEmpty()) { annotationsArray = ANNOTATIONS_EMPTY; } else { annotationsArray = annotations.toArray(new AnnotationCacheEntry[annotations.size()]); } synchronized (annotationCache) { annotationCache.put(clazz, annotationsArray); } } clazz = clazz.getSuperclass(); } }	private static Field getField(final Class<?> clazz, final AnnotationCacheEntry entry) { Field result = null; if (Globals.IS_SECURITY_ENABLED) { result = AccessController.doPrivileged(new PrivilegedAction<Field>() { @Override public Field run() { Field result = null; try { result = clazz.getDeclaredField(entry.getAccessibleObjectName()); } catch (NoSuchFieldException e) { // Should never happen. On that basis don't log // it. } return result; } }); } else { try { result = clazz.getDeclaredField(entry.getAccessibleObjectName()); } catch (NoSuchFieldException e) { // Should never happen. On that basis don't log it. } } return result; }	public String toXml() { StringBuilder sb = new StringBuilder(2048); // TODO - Various, icon, description etc elements are skipped - mainly // because they are ignored when web.xml is parsed - see above sb.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"); sb.append("<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"); sb.append(" xmlns:xsi="); sb.append("\"http://www.w3.org/2001/XMLSchema-instance\"\n"); sb.append(" xsi:schemaLocation="); sb.append("\"http://java.sun.com/xml/ns/javaee" + " http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"); sb.append(" version=\""); sb.append(getVersion()); sb.append("\"\n"); sb.append(" metadata-complete=\"true\">\n\n"); appendElement(sb, INDENT2, "display-name", displayName); if (isDistributable()) { sb.append(" <distributable/>\n\n"); } for (Map.Entry<String, String> entry : contextParams.entrySet()) { sb.append(" <context-param>\n"); appendElement(sb, INDENT4, "param-name", entry.getKey()); appendElement(sb, INDENT4, "param-value", entry.getValue()); sb.append(" </context-param>\n"); } sb.append('\n'); for (Map.Entry<String, FilterDef> entry : filters.entrySet()) { FilterDef filterDef = entry.getValue(); sb.append(" <filter>\n"); appendElement(sb, INDENT4, "description", filterDef.getDescription()); appendElement(sb, INDENT4, "display-name", filterDef.getDisplayName()); appendElement(sb, INDENT4, "filter-name", filterDef.getFilterName()); appendElement(sb, INDENT4, "filter-class", filterDef.getFilterClass()); appendElement(sb, INDENT4, "async-supported", filterDef.getAsyncSupported()); for (Map.Entry<String, String> param : filterDef.getParameterMap().entrySet()) { sb.append(" <init-param>\n"); appendElement(sb, INDENT6, "param-name", param.getKey()); appendElement(sb, INDENT6, "param-value", param.getValue()); sb.append(" </init-param>\n"); } sb.append(" </filter>\n"); } sb.append('\n'); for (FilterMap filterMap : filterMaps) { sb.append(" <filter-mapping>\n"); appendElement(sb, INDENT4, "filter-name", filterMap.getFilterName()); if (filterMap.getMatchAllServletNames()) { sb.append(" <servlet-name>*</servlet-name>\n"); } else { for (String servletName : filterMap.getServletNames()) { appendElement(sb, INDENT4, "servlet-name", servletName); } } if (filterMap.getMatchAllUrlPatterns()) { sb.append(" <url-pattern>*</url-pattern>\n"); } else { for (String urlPattern : filterMap.getURLPatterns()) { appendElement(sb, INDENT4, "url-pattern", urlPattern); } } for (String dispatcher : filterMap.getDispatcherNames()) { appendElement(sb, INDENT4, "dispatcher", dispatcher); } sb.append(" </filter-mapping>\n"); } sb.append('\n'); for (String listener : listeners) { sb.append(" <listener>\n"); appendElement(sb, INDENT4, "listener-class", listener); sb.append(" </listener>\n"); } sb.append('\n'); for (Map.Entry<String, ServletDef> entry : servlets.entrySet()) { ServletDef servletDef = entry.getValue(); sb.append(" <servlet>\n"); appendElement(sb, INDENT4, "description", servletDef.getDescription()); appendElement(sb, INDENT4, "display-name", servletDef.getDisplayName()); appendElement(sb, INDENT4, "servlet-name", entry.getKey()); appendElement(sb, INDENT4, "servlet-class", servletDef.getServletClass()); appendElement(sb, INDENT4, "jsp-file", servletDef.getJspFile()); for (Map.Entry<String, String> param : servletDef.getParameterMap().entrySet()) { sb.append(" <init-param>\n"); appendElement(sb, INDENT6, "param-name", param.getKey()); appendElement(sb, INDENT6, "param-value", param.getValue()); sb.append(" </init-param>\n"); } appendElement(sb, INDENT4, "load-on-startup", servletDef.getLoadOnStartup()); appendElement(sb, INDENT4, "enabled", servletDef.getEnabled()); appendElement(sb, INDENT4, "async-supported", servletDef.getAsyncSupported()); if (servletDef.getRunAs() != null) { sb.append(" <run-as>\n"); appendElement(sb, INDENT6, "role-name", servletDef.getRunAs()); sb.append(" </run-as>\n"); } for (SecurityRoleRef roleRef : servletDef.getSecurityRoleRefs()) { sb.append(" <security-role-ref>\n"); appendElement(sb, INDENT6, "role-name", roleRef.getName()); appendElement(sb, INDENT6, "role-link", roleRef.getLink()); sb.append(" </security-role-ref>\n"); } MultipartDef multipartDef = servletDef.getMultipartDef(); if (multipartDef != null) { sb.append(" <multipart-config>\n"); appendElement(sb, INDENT6, "location", multipartDef.getLocation()); appendElement(sb, INDENT6, "max-file-size", multipartDef.getMaxFileSize()); appendElement(sb, INDENT6, "max-request-size", multipartDef.getMaxRequestSize()); appendElement(sb, INDENT6, "file-size-threshold", multipartDef.getFileSizeThreshold()); sb.append(" </multipart-config>\n"); } sb.append(" </servlet>\n"); } sb.append('\n'); for (Map.Entry<String, String> entry : servletMappings.entrySet()) { sb.append(" <servlet-mapping>\n"); appendElement(sb, INDENT4, "servlet-name", entry.getValue()); appendElement(sb, INDENT4, "url-pattern", entry.getKey()); sb.append(" </servlet-mapping>\n"); } sb.append('\n'); if (sessionConfig != null) { sb.append(" <session-config>\n"); appendElement(sb, INDENT4, "session-timeout", sessionConfig.getSessionTimeout()); sb.append(" <cookie-config>\n"); appendElement(sb, INDENT6, "name", sessionConfig.getCookieName()); appendElement(sb, INDENT6, "domain", sessionConfig.getCookieDomain()); appendElement(sb, INDENT6, "path", sessionConfig.getCookiePath()); appendElement(sb, INDENT6, "comment", sessionConfig.getCookieComment()); appendElement(sb, INDENT6, "http-only", sessionConfig.getCookieHttpOnly()); appendElement(sb, INDENT6, "secure", sessionConfig.getCookieSecure()); appendElement(sb, INDENT6, "max-age", sessionConfig.getCookieMaxAge()); sb.append(" </cookie-config>\n"); for (SessionTrackingMode stm : sessionConfig.getSessionTrackingModes()) { appendElement(sb, INDENT4, "tracking-mode", stm.name()); } sb.append(" </session-config>\n\n"); } for (Map.Entry<String, String> entry : mimeMappings.entrySet()) { sb.append(" <mime-mapping>\n"); appendElement(sb, INDENT4, "extension", entry.getKey()); appendElement(sb, INDENT4, "mime-type", entry.getValue()); sb.append(" </mime-mapping>\n"); } sb.append('\n'); if (welcomeFiles.size() > 0) { sb.append(" <welcome-file-list>\n"); for (String welcomeFile : welcomeFiles) { appendElement(sb, INDENT4, "welcome-file", welcomeFile); } sb.append(" </welcome-file-list>\n\n"); } for (ErrorPage errorPage : errorPages.values()) { sb.append(" <error-page>\n"); if (errorPage.getExceptionType() == null) { appendElement(sb, INDENT4, "error-code", Integer.toString(errorPage.getErrorCode())); } else { appendElement(sb, INDENT4, "exception-type", errorPage.getExceptionType()); } appendElement(sb, INDENT4, "location", errorPage.getLocation()); sb.append(" </error-page>\n"); } sb.append('\n'); if (taglibs.size() > 0 || jspPropertyGroups.size() > 0) { sb.append(" <jsp-config>\n"); for (Map.Entry<String, String> entry : taglibs.entrySet()) { sb.append(" <taglib>\n"); appendElement(sb, INDENT6, "taglib-uri", entry.getKey()); appendElement(sb, INDENT6, "taglib-location", entry.getValue()); sb.append(" </taglib>\n"); } for (JspPropertyGroup jpg : jspPropertyGroups) { sb.append(" <jsp-property-group>\n"); for (String urlPattern : jpg.getUrlPatterns()) { appendElement(sb, INDENT6, "url-pattern", urlPattern); } appendElement(sb, INDENT6, "el-ignored", jpg.getElIgnored()); appendElement(sb, INDENT6, "page-encoding", jpg.getPageEncoding()); appendElement(sb, INDENT6, "scripting-invalid", jpg.getScriptingInvalid()); appendElement(sb, INDENT6, "is-xml", jpg.getIsXml()); for (String prelude : jpg.getIncludePreludes()) { appendElement(sb, INDENT6, "include-prelude", prelude); } for (String coda : jpg.getIncludeCodas()) { appendElement(sb, INDENT6, "include-coda", coda); } appendElement(sb, INDENT6, "deferred-syntax-allowed-as-literal", jpg.getDeferredSyntax()); appendElement(sb, INDENT6, "trim-directive-whitespaces", jpg.getTrimWhitespace()); appendElement(sb, INDENT6, "default-content-type", jpg.getDefaultContentType()); appendElement(sb, INDENT6, "buffer", jpg.getBuffer()); appendElement(sb, INDENT6, "error-on-undeclared-namespace", jpg.getErrorOnUndeclaredNamespace()); sb.append(" </jsp-property-group>\n"); } sb.append(" </jsp-config>\n\n"); } for (SecurityConstraint constraint : securityConstraints) { sb.append(" <security-constraint>\n"); appendElement(sb, INDENT4, "display-name", constraint.getDisplayName()); for (SecurityCollection collection : constraint.findCollections()) { sb.append(" <web-resource-collection>\n"); appendElement(sb, INDENT6, "web-resource-name", collection.getName()); appendElement(sb, INDENT6, "description", collection.getDescription()); for (String urlPattern : collection.findPatterns()) { appendElement(sb, INDENT6, "url-pattern", urlPattern); } for (String method : collection.findMethods()) { appendElement(sb, INDENT6, "http-method", method); } for (String method : collection.findOmittedMethods()) { appendElement(sb, INDENT6, "http-method-omission", method); } sb.append(" </web-resource-collection>\n"); } if (constraint.findAuthRoles().length > 0) { sb.append(" <auth-constraint>\n"); for (String role : constraint.findAuthRoles()) { appendElement(sb, INDENT6, "role-name", role); } sb.append(" </auth-constraint>\n"); } if (constraint.getUserConstraint() != null) { sb.append(" <user-data-constraint>\n"); appendElement(sb, INDENT6, "transport-guarantee", constraint.getUserConstraint()); sb.append(" </user-data-constraint>\n"); } sb.append(" </security-constraint>\n"); } sb.append('\n'); if (loginConfig != null) { sb.append(" <login-config>\n"); appendElement(sb, INDENT4, "auth-method", loginConfig.getAuthMethod()); appendElement(sb, INDENT4, "realm-name", loginConfig.getRealmName()); if (loginConfig.getErrorPage() != null || loginConfig.getLoginPage() != null) { sb.append(" <form-login-config>\n"); appendElement(sb, INDENT6, "form-login-page", loginConfig.getLoginPage()); appendElement(sb, INDENT6, "form-error-page", loginConfig.getErrorPage()); sb.append(" </form-login-config>\n"); } sb.append(" </login-config>\n\n"); } for (String roleName : securityRoles) { sb.append(" <security-role>\n"); appendElement(sb, INDENT4, "role-name", roleName); sb.append(" </security-role>\n"); } for (ContextEnvironment envEntry : envEntries.values()) { sb.append(" <env-entry>\n"); appendElement(sb, INDENT4, "description", envEntry.getDescription()); appendElement(sb, INDENT4, "env-entry-name", envEntry.getName()); appendElement(sb, INDENT4, "env-entry-type", envEntry.getType()); appendElement(sb, INDENT4, "env-entry-value", envEntry.getValue()); for (InjectionTarget target : envEntry.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </env-entry>\n"); } sb.append('\n'); for (ContextEjb ejbRef : ejbRefs.values()) { sb.append(" <ejb-ref>\n"); appendElement(sb, INDENT4, "description", ejbRef.getDescription()); appendElement(sb, INDENT4, "ejb-ref-name", ejbRef.getName()); appendElement(sb, INDENT4, "ejb-ref-type", ejbRef.getType()); appendElement(sb, INDENT4, "home", ejbRef.getHome()); appendElement(sb, INDENT4, "remote", ejbRef.getRemote()); appendElement(sb, INDENT4, "ejb-link", ejbRef.getLink()); for (InjectionTarget target : ejbRef.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </ejb-ref>\n"); } sb.append('\n'); for (ContextLocalEjb ejbLocalRef : ejbLocalRefs.values()) { sb.append(" <ejb-local-ref>\n"); appendElement(sb, INDENT4, "description", ejbLocalRef.getDescription()); appendElement(sb, INDENT4, "ejb-ref-name", ejbLocalRef.getName()); appendElement(sb, INDENT4, "ejb-ref-type", ejbLocalRef.getType()); appendElement(sb, INDENT4, "local-home", ejbLocalRef.getHome()); appendElement(sb, INDENT4, "local", ejbLocalRef.getLocal()); appendElement(sb, INDENT4, "ejb-link", ejbLocalRef.getLink()); for (InjectionTarget target : ejbLocalRef.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </ejb-local-ref>\n"); } sb.append('\n'); for (ContextService serviceRef : serviceRefs.values()) { sb.append(" <service-ref>\n"); appendElement(sb, INDENT4, "description", serviceRef.getDescription()); appendElement(sb, INDENT4, "display-name", serviceRef.getDisplayname()); appendElement(sb, INDENT4, "service-ref-name", serviceRef.getName()); appendElement(sb, INDENT4, "service-interface", serviceRef.getInterface()); appendElement(sb, INDENT4, "service-ref-type", serviceRef.getType()); appendElement(sb, INDENT4, "wsdl-file", serviceRef.getWsdlfile()); appendElement(sb, INDENT4, "jaxrpc-mapping-file", serviceRef.getJaxrpcmappingfile()); String qname = serviceRef.getServiceqnameNamespaceURI(); if (qname != null) { qname = qname + ":"; } qname = qname + serviceRef.getServiceqnameLocalpart(); appendElement(sb, INDENT4, "service-qname", qname); Iterator<String> endpointIter = serviceRef.getServiceendpoints(); while (endpointIter.hasNext()) { String endpoint = endpointIter.next(); sb.append(" <port-component-ref>\n"); appendElement(sb, INDENT6, "service-endpoint-interface", endpoint); appendElement(sb, INDENT6, "port-component-link", serviceRef.getProperty(endpoint)); sb.append(" </port-component-ref>\n"); } Iterator<String> handlerIter = serviceRef.getHandlers(); while (handlerIter.hasNext()) { String handler = handlerIter.next(); sb.append(" <handler>\n"); ContextHandler ch = serviceRef.getHandler(handler); appendElement(sb, INDENT6, "handler-name", ch.getName()); appendElement(sb, INDENT6, "handler-class", ch.getHandlerclass()); sb.append(" </handler>\n"); } for (InjectionTarget target : serviceRef.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </service-ref>\n"); } sb.append('\n'); for (ContextResource resourceRef : resourceRefs.values()) { sb.append(" <resource-ref>\n"); appendElement(sb, INDENT4, "description", resourceRef.getDescription()); appendElement(sb, INDENT4, "res-ref-name", resourceRef.getName()); appendElement(sb, INDENT4, "res-type", resourceRef.getType()); appendElement(sb, INDENT4, "res-auth", resourceRef.getAuth()); appendElement(sb, INDENT4, "res-sharing-scope", resourceRef.getScope()); for (InjectionTarget target : resourceRef.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </resource-ref>\n"); } sb.append('\n'); for (ContextResourceEnvRef resourceEnvRef : resourceEnvRefs.values()) { sb.append(" <resource-env-ref>\n"); appendElement(sb, INDENT4, "description", resourceEnvRef.getDescription()); appendElement(sb, INDENT4, "resource-env-ref-name", resourceEnvRef.getName()); appendElement(sb, INDENT4, "resource-env-ref-type", resourceEnvRef.getType()); for (InjectionTarget target : resourceEnvRef.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </resource-env-ref>\n"); } sb.append('\n'); for (MessageDestinationRef mdr : messageDestinationRefs.values()) { sb.append(" <message-destination-ref>\n"); appendElement(sb, INDENT4, "description", mdr.getDescription()); appendElement(sb, INDENT4, "message-destination-ref-name", mdr.getName()); appendElement(sb, INDENT4, "message-destination-type", mdr.getType()); appendElement(sb, INDENT4, "message-destination-usage", mdr.getUsage()); appendElement(sb, INDENT4, "message-destination-link", mdr.getLink()); for (InjectionTarget target : mdr.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </message-destination-ref>\n"); } sb.append('\n'); for (MessageDestination md : messageDestinations.values()) { sb.append(" <message-destination>\n"); appendElement(sb, INDENT4, "description", md.getDescription()); appendElement(sb, INDENT4, "display-name", md.getDisplayName()); appendElement(sb, INDENT4, "message-destination-name", md.getName()); sb.append(" </message-destination>\n"); } sb.append('\n'); if (localeEncodingMappings.size() > 0) { sb.append(" <locale-encoding-mapping-list>\n"); for (Map.Entry<String, String> entry : localeEncodingMappings.entrySet()) { sb.append(" <locale-encoding-mapping>\n"); appendElement(sb, INDENT6, "locale", entry.getKey()); appendElement(sb, INDENT6, "encoding", entry.getValue()); sb.append(" </locale-encoding-mapping>\n"); } sb.append(" </locale-encoding-mapping-list>\n"); } sb.append("</web-app>"); return sb.toString(); }	@Override public boolean fireRequestDestroyEvent(ServletRequest request) { Object[] instances = getApplicationEventListeners(); if ((instances != null) && (instances.length > 0)) { ServletRequestEvent event = new ServletRequestEvent(getServletContext(), request); for (int i = 0; i < instances.length; i++) { int j = (instances.length - 1) - i; if (instances[j] == null) continue; if (!(instances[j] instanceof ServletRequestListener)) continue; ServletRequestListener listener = (ServletRequestListener) instances[j]; try { listener.requestDestroyed(event); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getLogger().error(sm.getString("standardContext.requestListener.requestInit", instances[j].getClass().getName()), t); request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t); return false; } } } return true; }	@Override public boolean getAddWebinfClassesResources() { return false; }	@Test public void testBug49711() { Bug49711Client client = new Bug49711Client(); client.doRequest("/regular", false, false); assertEquals("Incorrect response for GET request", "parts=0", client.getResponseBody()); client.reset(); // Make sure regular multipart works properly client.doRequest("/multipart", false, true); assertEquals("Regular multipart doesn't work", "parts=1", client.getResponseBody()); client.reset(); // Make casual multipart request to "regular" servlet w/o config // We expect that no parts will be available client.doRequest("/regular", false, true); assertEquals("Incorrect response for non-configured casual multipart request", "parts=0", client.getResponseBody()); client.reset(); // Make casual multipart request to "regular" servlet w/config // We expect that the server /will/ parse the parts, even though // there is no @MultipartConfig client.doRequest("/regular", true, true); assertEquals("Incorrect response for configured casual multipart request", "parts=1", client.getResponseBody()); client.reset(); }	private static <T> boolean mergeMap(Map<String, T> fragmentMap, Map<String, T> mainMap, Map<String, T> tempMap, WebXml fragment, String mapName) { for (Entry<String, T> entry : fragmentMap.entrySet()) { final String key = entry.getKey(); if (!mainMap.containsKey(key)) { T value = entry.getValue(); if (tempMap.containsKey(key)) { if (value != null && !value.equals(tempMap.get(key))) { log.error(sm.getString("webXml.mergeConflictString", mapName, key, fragment.getName(), fragment.getURL())); return false; } } else { tempMap.put(key, value); } } } return true; }	public static Class<?> loadClass(Context context, String className) { ClassLoader cl = context.getLoader().getClassLoader(); Log log = context.getLogger(); Class<?> clazz = null; try { clazz = cl.loadClass(className); } catch (ClassNotFoundException e) { log.debug(sm.getString("introspection.classLoadFailed"), e); } catch (NoClassDefFoundError e) { log.debug(sm.getString("introspection.classLoadFailed"), e); } catch (ClassFormatError e) { log.debug(sm.getString("introspection.classLoadFailed"), e); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("introspection.classLoadFailed"), t); } return clazz; }	public String getJarName() { return jarName; }	@Override public void addRuleInstances(Digester digester) { digester.addRule(fullPrefix, new SetPublicIdRule("setPublicId")); digester.addRule(fullPrefix, new IgnoreAnnotationsRule()); digester.addRule(fullPrefix, new VersionRule()); digester.addRule(fullPrefix + "/absolute-ordering", absoluteOrdering); digester.addRule(fullPrefix + "/ordering", relativeOrdering); if (fragment) { digester.addRule(fullPrefix + "/name", name); digester.addCallMethod(fullPrefix + "/ordering/after/name", "addAfterOrdering", 0); digester.addCallMethod(fullPrefix + "/ordering/after/others", "addAfterOrderingOthers"); digester.addCallMethod(fullPrefix + "/ordering/before/name", "addBeforeOrdering", 0); digester.addCallMethod(fullPrefix + "/ordering/before/others", "addBeforeOrderingOthers"); } else { digester.addCallMethod(fullPrefix + "/absolute-ordering/name", "addAbsoluteOrdering", 0); digester.addCallMethod(fullPrefix + "/absolute-ordering/others", "addAbsoluteOrderingOthers"); } digester.addCallMethod(fullPrefix + "/context-param", "addContextParam", 2); digester.addCallParam(fullPrefix + "/context-param/param-name", 0); digester.addCallParam(fullPrefix + "/context-param/param-value", 1); digester.addCallMethod(fullPrefix + "/display-name", "setDisplayName", 0); digester.addRule(fullPrefix + "/distributable", new SetDistributableRule()); configureNamingRules(digester); digester.addObjectCreate(fullPrefix + "/error-page", "org.apache.catalina.deploy.ErrorPage"); digester.addSetNext(fullPrefix + "/error-page", "addErrorPage", "org.apache.catalina.deploy.ErrorPage"); digester.addCallMethod(fullPrefix + "/error-page/error-code", "setErrorCode", 0); digester.addCallMethod(fullPrefix + "/error-page/exception-type", "setExceptionType", 0); digester.addCallMethod(fullPrefix + "/error-page/location", "setLocation", 0); digester.addObjectCreate(fullPrefix + "/filter", "org.apache.catalina.deploy.FilterDef"); digester.addSetNext(fullPrefix + "/filter", "addFilter", "org.apache.catalina.deploy.FilterDef"); digester.addCallMethod(fullPrefix + "/filter/description", "setDescription", 0); digester.addCallMethod(fullPrefix + "/filter/display-name", "setDisplayName", 0); digester.addCallMethod(fullPrefix + "/filter/filter-class", "setFilterClass", 0); digester.addCallMethod(fullPrefix + "/filter/filter-name", "setFilterName", 0); digester.addCallMethod(fullPrefix + "/filter/icon/large-icon", "setLargeIcon", 0); digester.addCallMethod(fullPrefix + "/filter/icon/small-icon", "setSmallIcon", 0); digester.addCallMethod(fullPrefix + "/filter/async-supported", "setAsyncSupported", 0); digester.addCallMethod(fullPrefix + "/filter/init-param", "addInitParameter", 2); digester.addCallParam(fullPrefix + "/filter/init-param/param-name", 0); digester.addCallParam(fullPrefix + "/filter/init-param/param-value", 1); digester.addObjectCreate(fullPrefix + "/filter-mapping", "org.apache.catalina.deploy.FilterMap"); digester.addSetNext(fullPrefix + "/filter-mapping", "addFilterMapping", "org.apache.catalina.deploy.FilterMap"); digester.addCallMethod(fullPrefix + "/filter-mapping/filter-name", "setFilterName", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/servlet-name", "addServletName", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/url-pattern", "addURLPattern", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/dispatcher", "setDispatcher", 0); digester.addCallMethod(fullPrefix + "/listener/listener-class", "addListener", 0); digester.addRule(fullPrefix + "/jsp-config", jspConfig); digester.addObjectCreate(fullPrefix + "/jsp-config/jsp-property-group", "org.apache.catalina.deploy.JspPropertyGroup"); digester.addSetNext(fullPrefix + "/jsp-config/jsp-property-group", "addJspPropertyGroup", "org.apache.catalina.deploy.JspPropertyGroup"); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/deferred-syntax-allowed-as-literal", "setDeferredSyntax", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/el-ignored", "setElIgnored", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/include-coda", "addIncludeCoda", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/include-prelude", "addIncludePrelude", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/is-xml", "setIsXml", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/page-encoding", "setPageEncoding", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/scripting-invalid", "setScriptingInvalid", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/trim-directive-whitespaces", "setTrimWhitespace", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/url-pattern", "addUrlPattern", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/default-content-type", "setDefaultContentType", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/buffer", "setBuffer", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/error-on-undeclared-namespace", "setErrorOnUndeclaredNamespace", 0); digester.addRule(fullPrefix + "/login-config", loginConfig); digester.addObjectCreate(fullPrefix + "/login-config", "org.apache.catalina.deploy.LoginConfig"); digester.addSetNext(fullPrefix + "/login-config", "setLoginConfig", "org.apache.catalina.deploy.LoginConfig"); digester.addCallMethod(fullPrefix + "/login-config/auth-method", "setAuthMethod", 0); digester.addCallMethod(fullPrefix + "/login-config/realm-name", "setRealmName", 0); digester.addCallMethod(fullPrefix + "/login-config/form-login-config/form-error-page", "setErrorPage", 0); digester.addCallMethod(fullPrefix + "/login-config/form-login-config/form-login-page", "setLoginPage", 0); digester.addCallMethod(fullPrefix + "/mime-mapping", "addMimeMapping", 2); digester.addCallParam(fullPrefix + "/mime-mapping/extension", 0); digester.addCallParam(fullPrefix + "/mime-mapping/mime-type", 1); digester.addObjectCreate(fullPrefix + "/security-constraint", "org.apache.catalina.deploy.SecurityConstraint"); digester.addSetNext(fullPrefix + "/security-constraint", "addSecurityConstraint", "org.apache.catalina.deploy.SecurityConstraint"); digester.addRule(fullPrefix + "/security-constraint/auth-constraint", new SetAuthConstraintRule()); digester.addCallMethod(fullPrefix + "/security-constraint/auth-constraint/role-name", "addAuthRole", 0); digester.addCallMethod(fullPrefix + "/security-constraint/display-name", "setDisplayName", 0); digester.addCallMethod(fullPrefix + "/security-constraint/user-data-constraint/transport-guarantee", "setUserConstraint", 0); digester.addObjectCreate(fullPrefix + "/security-constraint/web-resource-collection", "org.apache.catalina.deploy.SecurityCollection"); digester.addSetNext(fullPrefix + "/security-constraint/web-resource-collection", "addCollection", "org.apache.catalina.deploy.SecurityCollection"); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/http-method", "addMethod", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/http-method-omission", "addOmittedMethod", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/url-pattern", "addPattern", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/web-resource-name", "setName", 0); digester.addCallMethod(fullPrefix + "/security-role/role-name", "addSecurityRole", 0); digester.addRule(fullPrefix + "/servlet", new ServletDefCreateRule()); digester.addSetNext(fullPrefix + "/servlet", "addServlet", "org.apache.catalina.deploy.ServletDef"); digester.addCallMethod(fullPrefix + "/servlet/init-param", "addInitParameter", 2); digester.addCallParam(fullPrefix + "/servlet/init-param/param-name", 0); digester.addCallParam(fullPrefix + "/servlet/init-param/param-value", 1); digester.addCallMethod(fullPrefix + "/servlet/jsp-file", "setJspFile", 0); digester.addCallMethod(fullPrefix + "/servlet/load-on-startup", "setLoadOnStartup", 0); digester.addCallMethod(fullPrefix + "/servlet/run-as/role-name", "setRunAs", 0); digester.addObjectCreate(fullPrefix + "/servlet/security-role-ref", "org.apache.catalina.deploy.SecurityRoleRef"); digester.addSetNext(fullPrefix + "/servlet/security-role-ref", "addSecurityRoleRef", "org.apache.catalina.deploy.SecurityRoleRef"); digester.addCallMethod(fullPrefix + "/servlet/security-role-ref/role-link", "setLink", 0); digester.addCallMethod(fullPrefix + "/servlet/security-role-ref/role-name", "setName", 0); digester.addCallMethod(fullPrefix + "/servlet/servlet-class", "setServletClass", 0); digester.addCallMethod(fullPrefix + "/servlet/servlet-name", "setServletName", 0); digester.addObjectCreate(fullPrefix + "/servlet/multipart-config", "org.apache.catalina.deploy.MultipartDef"); digester.addSetNext(fullPrefix + "/servlet/multipart-config", "setMultipartDef", "org.apache.catalina.deploy.MultipartDef"); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/location", "setLocation", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/max-file-size", "setMaxFileSize", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/max-request-size", "setMaxRequestSize", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/file-size-threshold", "setFileSizeThreshold", 0); digester.addCallMethod(fullPrefix + "/servlet/async-supported", "setAsyncSupported", 0); digester.addCallMethod(fullPrefix + "/servlet/enabled", "setEnabled", 0); digester.addRule(fullPrefix + "/servlet-mapping", new CallMethodMultiRule("addServletMapping", 2, 0)); digester.addCallParam(fullPrefix + "/servlet-mapping/servlet-name", 1); digester.addRule(fullPrefix + "/servlet-mapping/url-pattern", new CallParamMultiRule(0)); digester.addRule(fullPrefix + "/session-config", sessionConfig); digester.addObjectCreate(fullPrefix + "/session-config", "org.apache.catalina.deploy.SessionConfig"); digester.addSetNext(fullPrefix + "/session-config", "setSessionConfig", "org.apache.catalina.deploy.SessionConfig"); digester.addCallMethod(fullPrefix + "/session-config/session-timeout", "setSessionTimeout", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/name", "setCookieName", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/domain", "setCookieDomain", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/path", "setCookiePath", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/comment", "setCookieComment", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/http-only", "setCookieHttpOnly", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/secure", "setCookieSecure", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/max-age", "setCookieMaxAge", 0); digester.addCallMethod(fullPrefix + "/session-config/tracking-mode", "addSessionTrackingMode", 0); digester.addRule(fullPrefix + "/taglib", new TaglibLocationRule(false)); digester.addCallMethod(fullPrefix + "/taglib", "addTaglib", 2); digester.addCallParam(fullPrefix + "/taglib/taglib-location", 1); digester.addCallParam(fullPrefix + "/taglib/taglib-uri", 0); digester.addRule(fullPrefix + "/jsp-config/taglib", new TaglibLocationRule(true)); digester.addCallMethod(fullPrefix + "/jsp-config/taglib", "addTaglib", 2); digester.addCallParam(fullPrefix + "/jsp-config/taglib/taglib-location", 1); digester.addCallParam(fullPrefix + "/jsp-config/taglib/taglib-uri", 0); digester.addCallMethod(fullPrefix + "/welcome-file-list/welcome-file", "addWelcomeFile", 0); digester.addCallMethod(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping", "addLocaleEncodingMapping", 2); digester.addCallParam(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping/locale", 0); digester.addCallParam(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping/encoding", 1); }	@Override public void body(String namespace, String name, String text) throws Exception { super.body(namespace, name, text); ((WebXml) digester.peek()).setName(text); }	public void configureContext(Context context) { // As far as possible, process in alphabetical order so it is easy to // check everything is present context.setPublicId(publicId); context.setEffectiveMajorVersion(getMajorVersion()); context.setEffectiveMinorVersion(getMinorVersion()); for (Entry<String, String> entry : contextParams.entrySet()) { context.addParameter(entry.getKey(), entry.getValue()); } context.setDisplayName(displayName); context.setDistributable(distributable); for (ContextLocalEjb ejbLocalRef : ejbLocalRefs.values()) { context.getNamingResources().addLocalEjb(ejbLocalRef); } for (ContextEjb ejbRef : ejbRefs.values()) { context.getNamingResources().addEjb(ejbRef); } for (ContextEnvironment environment : envEntries.values()) { context.getNamingResources().addEnvironment(environment); } for (ErrorPage errorPage : errorPages.values()) { context.addErrorPage(errorPage); } for (FilterDef filter : filters.values()) { if (filter.getAsyncSupported() == null) { filter.setAsyncSupported("false"); } context.addFilterDef(filter); } for (FilterMap filterMap : filterMaps) { context.addFilterMap(filterMap); } for (JspPropertyGroup jspPropertyGroup : jspPropertyGroups) { JspPropertyGroupDescriptor descriptor = new ApplicationJspPropertyGroupDescriptor(jspPropertyGroup); context.getJspConfigDescriptor().getJspPropertyGroups().add(descriptor); } for (String listener : listeners) { context.addApplicationListener(listener); } for (Entry<String, String> entry : localeEncodingMappings.entrySet()) { context.addLocaleEncodingMappingParameter(entry.getKey(), entry.getValue()); } if (loginConfig != null) { context.setLoginConfig(loginConfig); } for (MessageDestinationRef mdr : messageDestinationRefs.values()) { context.getNamingResources().addMessageDestinationRef(mdr); } context.setIgnoreAnnotations(metadataComplete); for (Entry<String, String> entry : mimeMappings.entrySet()) { context.addMimeMapping(entry.getKey(), entry.getValue()); } for (ContextResourceEnvRef resource : resourceEnvRefs.values()) { context.getNamingResources().addResourceEnvRef(resource); } for (ContextResource resource : resourceRefs.values()) { context.getNamingResources().addResource(resource); } for (SecurityConstraint constraint : securityConstraints) { context.addConstraint(constraint); } for (String role : securityRoles) { context.addSecurityRole(role); } for (ContextService service : serviceRefs.values()) { context.getNamingResources().addService(service); } for (ServletDef servlet : servlets.values()) { Wrapper wrapper = context.createWrapper(); if (servlet.getLoadOnStartup() != null) { wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue()); } if (servlet.getEnabled() != null) { wrapper.setEnabled(servlet.getEnabled().booleanValue()); } wrapper.setName(servlet.getServletName()); Map<String, String> params = servlet.getParameterMap(); for (Entry<String, String> entry : params.entrySet()) { wrapper.addInitParameter(entry.getKey(), entry.getValue()); } wrapper.setRunAs(servlet.getRunAs()); Set<SecurityRoleRef> roleRefs = servlet.getSecurityRoleRefs(); for (SecurityRoleRef roleRef : roleRefs) { wrapper.addSecurityReference(roleRef.getName(), roleRef.getLink()); } wrapper.setServletClass(servlet.getServletClass()); MultipartDef multipartdef = servlet.getMultipartDef(); if (multipartdef != null) { if (multipartdef.getMaxFileSize() != null && multipartdef.getMaxRequestSize() != null && multipartdef.getFileSizeThreshold() != null) { wrapper.setMultipartConfigElement(new MultipartConfigElement(multipartdef.getLocation(), Long.parseLong(multipartdef.getMaxFileSize()), Long.parseLong(multipartdef.getMaxRequestSize()), Integer.parseInt(multipartdef.getFileSizeThreshold()))); } else { wrapper.setMultipartConfigElement(new MultipartConfigElement(multipartdef.getLocation())); } } if (servlet.getAsyncSupported() != null) { wrapper.setAsyncSupported(servlet.getAsyncSupported().booleanValue()); } wrapper.setOverridable(servlet.isOverridable()); context.addChild(wrapper); } for (Entry<String, String> entry : servletMappings.entrySet()) { context.addServletMapping(entry.getKey(), entry.getValue()); } if (sessionConfig != null) { if (sessionConfig.getSessionTimeout() != null) { context.setSessionTimeout(sessionConfig.getSessionTimeout().intValue()); } SessionCookieConfig scc = context.getServletContext().getSessionCookieConfig(); scc.setName(sessionConfig.getCookieName()); scc.setDomain(sessionConfig.getCookieDomain()); scc.setPath(sessionConfig.getCookiePath()); scc.setComment(sessionConfig.getCookieComment()); if (sessionConfig.getCookieHttpOnly() != null) { scc.setHttpOnly(sessionConfig.getCookieHttpOnly().booleanValue()); } if (sessionConfig.getCookieSecure() != null) { scc.setSecure(sessionConfig.getCookieSecure().booleanValue()); } if (sessionConfig.getCookieMaxAge() != null) { scc.setMaxAge(sessionConfig.getCookieMaxAge().intValue()); } if (sessionConfig.getSessionTrackingModes().size() > 0) { context.getServletContext().setSessionTrackingModes(sessionConfig.getSessionTrackingModes()); } } for (Entry<String, String> entry : taglibs.entrySet()) { TaglibDescriptor descriptor = new ApplicationTaglibDescriptor(entry.getValue(), entry.getKey()); context.getJspConfigDescriptor().getTaglibs().add(descriptor); } for (String welcomeFile : welcomeFiles) { if (welcomeFile != null && welcomeFile.length() > 0) { context.addWelcomeFile(welcomeFile); } } for (JspPropertyGroup jspPropertyGroup : jspPropertyGroups) { String jspServletName = context.findServletMapping("*.jsp"); if (jspServletName == null) { jspServletName = "jsp"; } if (context.findChild(jspServletName) != null) { for (String urlPattern : jspPropertyGroup.getUrlPatterns()) { context.addServletMapping(urlPattern, jspServletName, true); } } else { if (log.isDebugEnabled()) { for (String urlPattern : jspPropertyGroup.getUrlPatterns()) { log.debug("Skiping " + urlPattern + " , no servlet " + jspServletName); } } } } }	@Override public boolean getAddWebinfClassesResources() { return false; }	@Test public void testBug54262() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0-fragments-empty-absolute-ordering"); tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); tomcat.start(); assertPageContains("/test/resourceA.jsp", "resourceA.jsp in resources.jar"); assertPageContains("/test/resources/HelloWorldExample", null, HttpServletResponse.SC_NOT_FOUND); }	@Test public void testParsePublicIdVersion22() { WebXml webxml = new WebXml(); webxml.setPublicId(org.apache.catalina.startup.Constants.WebDtdPublicId_22); assertEquals(2, webxml.getMajorVersion()); assertEquals(2, webxml.getMinorVersion()); assertEquals("2.2", webxml.getVersion()); }	@Test public void testParsePublicIdVersion23() { WebXml webxml = new WebXml(); webxml.setPublicId(org.apache.catalina.startup.Constants.WebDtdPublicId_23); assertEquals(2, webxml.getMajorVersion()); assertEquals(3, webxml.getMinorVersion()); assertEquals("2.3", webxml.getVersion()); }	@Test public void testParsePublicIdVersion24() { WebXml webxml = new WebXml(); webxml.setPublicId(org.apache.catalina.startup.Constants.WebSchemaPublicId_24); assertEquals(2, webxml.getMajorVersion()); assertEquals(4, webxml.getMinorVersion()); assertEquals("2.4", webxml.getVersion()); }	@Test public void testParsePublicIdVersion25() { WebXml webxml = new WebXml(); webxml.setPublicId(org.apache.catalina.startup.Constants.WebSchemaPublicId_25); assertEquals(2, webxml.getMajorVersion()); assertEquals(5, webxml.getMinorVersion()); assertEquals("2.5", webxml.getVersion()); }	@Test public void testParsePublicIdVersion30() { WebXml webxml = new WebXml(); webxml.setPublicId(org.apache.catalina.startup.Constants.WebSchemaPublicId_30); assertEquals(3, webxml.getMajorVersion()); assertEquals(0, webxml.getMinorVersion()); assertEquals("3.0", webxml.getVersion()); }	public void testParseVersion() { WebXml webxml = new WebXml(); assertEquals(3, webxml.getMajorVersion()); assertEquals(0, webxml.getMinorVersion()); webxml.setVersion("2.5"); assertEquals(2, webxml.getMajorVersion()); assertEquals(5, webxml.getMinorVersion()); webxml.setVersion("0.0"); assertEquals(0, webxml.getMajorVersion()); assertEquals(0, webxml.getMinorVersion()); webxml.setVersion(null); assertEquals(0, webxml.getMajorVersion()); assertEquals(0, webxml.getMinorVersion()); webxml.setVersion("3"); assertEquals(3, webxml.getMajorVersion()); assertEquals(0, webxml.getMinorVersion()); // no minor digit webxml.setVersion("0.0"); webxml.setVersion("3."); assertEquals(3, webxml.getMajorVersion()); assertEquals(0, webxml.getMinorVersion()); // minor only webxml.setVersion("0.0"); webxml.setVersion(".5"); assertEquals(0, webxml.getMajorVersion()); assertEquals(5, webxml.getMinorVersion()); // leading & training zeros webxml.setVersion("0.0"); webxml.setVersion("002.500"); assertEquals(2, webxml.getMajorVersion()); assertEquals(500, webxml.getMinorVersion()); }	@Test public void testRecycle() throws Exception { parse(new WebXml(), "web-fragment-2name.xml", true, false); parse(new WebXml(), "web-fragment-1name.xml", true, true); parse(new WebXml(), "web-fragment-2name.xml", true, false); parse(new WebXml(), "web-fragment-1name.xml", true, true); parse(new WebXml(), "web-fragment-2ordering.xml", true, false); parse(new WebXml(), "web-fragment-1ordering.xml", true, true); parse(new WebXml(), "web-fragment-2ordering.xml", true, false); parse(new WebXml(), "web-fragment-1ordering.xml", true, true); parse(new WebXml(), "web-2ordering.xml", false, false); parse(new WebXml(), "web-1ordering.xml", false, true); parse(new WebXml(), "web-2ordering.xml", false, false); parse(new WebXml(), "web-1ordering.xml", false, true); }
private String parseCmd(StringBuilder cmd) { int firstLetter = -1; int lastLetter = -1; for (int i = 0; i < cmd.length(); i++) { char c = cmd.charAt(i); if (Character.isLetter(c)) { if (firstLetter == -1) { firstLetter = i; } lastLetter = i; } else if (isSpace(c)) { if (lastLetter > -1) { break; } } else { break; } } String command = null; if (firstLetter != -1) { command = cmd.substring(firstLetter, lastLetter + 1); } return command; }
private void doOnClose(int status) { Thread t = Thread.currentThread(); ClassLoader cl = t.getContextClassLoader(); t.setContextClassLoader(applicationClassLoader); try { onClose(status); } finally { t.setContextClassLoader(cl); } }	protected void onClose(int status) { // NO-OP }	public final SocketState onData() { // Must be start the start of a message (which may consist of multiple WsInputStream wsIs = new WsInputStream(inputStream, getWsOutbound()); try { WsFrame frame = wsIs.nextFrame(false); while (frame != null) { if (frame.getRsv() > 0) { closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR, null); return SocketState.CLOSED; } byte opCode = frame.getOpCode(); if (opCode == Constants.OPCODE_BINARY) { doOnBinaryData(wsIs); } else if (opCode == Constants.OPCODE_TEXT) { InputStreamReader r = new InputStreamReader(wsIs, new Utf8Decoder()); doOnTextData(r); } else if (opCode == Constants.OPCODE_CLOSE) { closeOutboundConnection(frame); return SocketState.CLOSED; } else if (opCode == Constants.OPCODE_PING) { getWsOutbound().pong(frame.getPayLoad()); } else if (opCode == Constants.OPCODE_PONG) { // NO-OP } else { closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR, null); return SocketState.CLOSED; } frame = wsIs.nextFrame(false); } } catch (MalformedInputException mie) { try { closeOutboundConnection(Constants.STATUS_BAD_DATA, null); } catch (IOException e) { // TODO } return SocketState.CLOSED; } catch (UnmappableCharacterException uce) { try { closeOutboundConnection(Constants.STATUS_BAD_DATA, null); } catch (IOException e) { // TODO } return SocketState.CLOSED; } catch (IOException ioe) { try { closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR, null); } catch (IOException e) { // TODO } return SocketState.CLOSED; } return SocketState.UPGRADED; }
private HttpServletRequest testRemoteIpFilter(FilterDef filterDef, Request request) throws LifecycleException, IOException, ServletException { Tomcat tomcat = getTomcatInstance(); Context root = tomcat.addContext("", TEMP_DIR); RemoteIpFilter remoteIpFilter = new RemoteIpFilter(); filterDef.setFilterClass(RemoteIpFilter.class.getName()); filterDef.setFilter(remoteIpFilter); filterDef.setFilterName(RemoteIpFilter.class.getName()); root.addFilterDef(filterDef); FilterMap filterMap = new FilterMap(); filterMap.setFilterName(RemoteIpFilter.class.getName()); filterMap.addURLPattern("*"); root.addFilterMap(filterMap); getTomcatInstance().start(); MockFilterChain filterChain = new MockFilterChain(); remoteIpFilter.doFilter(request, new Response(), filterChain); return filterChain.getRequest(); }	public void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { if (internalProxies != null && internalProxies.matcher(request.getRemoteAddr()).matches()) { String remoteIp = null; LinkedList<String> proxiesHeaderValue = new LinkedList<>(); StringBuilder concatRemoteIpHeaderValue = new StringBuilder(); for (Enumeration<String> e = request.getHeaders(remoteIpHeader); e.hasMoreElements(); ) { if (concatRemoteIpHeaderValue.length() > 0) { concatRemoteIpHeaderValue.append(", "); } concatRemoteIpHeaderValue.append(e.nextElement()); } String[] remoteIpHeaderValue = commaDelimitedListToStringArray(concatRemoteIpHeaderValue.toString()); int idx; for (idx = remoteIpHeaderValue.length - 1; idx >= 0; idx--) { String currentRemoteIp = remoteIpHeaderValue[idx]; remoteIp = currentRemoteIp; if (internalProxies.matcher(currentRemoteIp).matches()) { // do nothing, internalProxies IPs are not appended to the } else if (trustedProxies != null && trustedProxies.matcher(currentRemoteIp).matches()) { proxiesHeaderValue.addFirst(currentRemoteIp); } else { idx--; break; } } LinkedList<String> newRemoteIpHeaderValue = new LinkedList<>(); for (; idx >= 0; idx--) { String currentRemoteIp = remoteIpHeaderValue[idx]; newRemoteIpHeaderValue.addFirst(currentRemoteIp); } XForwardedRequest xRequest = new XForwardedRequest(request); if (remoteIp != null) { xRequest.setRemoteAddr(remoteIp); xRequest.setRemoteHost(remoteIp); if (proxiesHeaderValue.size() == 0) { xRequest.removeHeader(proxiesHeader); } else { String commaDelimitedListOfProxies = listToCommaDelimitedString(proxiesHeaderValue); xRequest.setHeader(proxiesHeader, commaDelimitedListOfProxies); } if (newRemoteIpHeaderValue.size() == 0) { xRequest.removeHeader(remoteIpHeader); } else { String commaDelimitedRemoteIpHeaderValue = listToCommaDelimitedString(newRemoteIpHeaderValue); xRequest.setHeader(remoteIpHeader, commaDelimitedRemoteIpHeaderValue); } } if (protocolHeader != null) { String protocolHeaderValue = request.getHeader(protocolHeader); if (protocolHeaderValue == null) { // don't modify the secure,scheme and serverPort attributes of the request } else if (protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) { xRequest.setSecure(true); xRequest.setScheme("https"); setPorts(xRequest, httpsServerPort); } else { xRequest.setSecure(false); xRequest.setScheme("http"); setPorts(xRequest, httpServerPort); } } if (log.isDebugEnabled()) { log.debug("Incoming request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "', originalRemoteHost='" + request.getRemoteHost() + "', originalSecure='" + request.isSecure() + "', originalScheme='" + request.getScheme() + "', original[" + remoteIpHeader + "]='" + concatRemoteIpHeaderValue + "', original[" + protocolHeader + "]='" + (protocolHeader == null ? null : request.getHeader(protocolHeader)) + "' will be seen as newRemoteAddr='" + xRequest.getRemoteAddr() + "', newRemoteHost='" + xRequest.getRemoteHost() + "', newScheme='" + xRequest.getScheme() + "', newSecure='" + xRequest.isSecure() + "', new[" + remoteIpHeader + "]='" + xRequest.getHeader(remoteIpHeader) + "', new[" + proxiesHeader + "]='" + xRequest.getHeader(proxiesHeader) + "'"); } if (requestAttributesEnabled) { request.setAttribute(AccessLog.REMOTE_ADDR_ATTRIBUTE, request.getRemoteAddr()); request.setAttribute(AccessLog.REMOTE_HOST_ATTRIBUTE, request.getRemoteHost()); request.setAttribute(AccessLog.PROTOCOL_ATTRIBUTE, request.getProtocol()); request.setAttribute(AccessLog.SERVER_PORT_ATTRIBUTE, Integer.valueOf(request.getServerPort())); } chain.doFilter(xRequest, response); } else { if (log.isDebugEnabled()) { log.debug("Skip RemoteIpFilter for request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "'"); } chain.doFilter(request, response); } }	@Override public void setAttribute(String name, Object value) { // NOOP. Prevents NPE during testing. }	public void invoke(Request request, Response response) throws IOException, ServletException { this.remoteHost = request.getRemoteHost(); this.remoteAddr = request.getRemoteAddr(); this.scheme = request.getScheme(); this.secure = request.isSecure(); this.serverPort = request.getServerPort(); }	@Test public void testCommaDelimitedListToStringArrayMixedSpaceChars() { String[] actual = RemoteIpValve.commaDelimitedListToStringArray("element1 , element2,\t element3"); String[] expected = new String[] { "element1", "element2", "element3" }; assertArrayEquals(expected, actual); }
@Override public void lifecycleEvent(LifecycleEvent event) { if (event.getType().equals(Lifecycle.AFTER_START_EVENT)) { Object obj = event.getSource(); if (obj instanceof Wrapper) { registerWrapper((Wrapper) obj); } else if (obj instanceof Context) { registerContext((Context) obj); } else if (obj instanceof Host) { registerHost((Host) obj); } } else if (event.getType().equals(Lifecycle.BEFORE_STOP_EVENT)) { Object obj = event.getSource(); if (obj instanceof Wrapper) { unregisterWrapper((Wrapper) obj); } else if (obj instanceof Context) { Context c = (Context) obj; if (!c.getPaused()) { unregisterContext(c); } } else if (obj instanceof Host) { unregisterHost((Host) obj); } } }
public static Charset getCharsetLower(String lowerCaseEnc) throws UnsupportedEncodingException { Charset charset = encodingToCharsetCache.get(lowerCaseEnc); if (charset == null) { throw new UnsupportedEncodingException(sm.getString("b2cConverter.unknownEncoding", lowerCaseEnc)); } return charset; }	public void convert(ByteChunk bb, CharChunk cb, int limit) throws IOException { iis.setByteChunk(bb); try { int bbLengthBeforeRead = 0; while (limit > 0) { int size = limit < BUFFER_SIZE ? limit : BUFFER_SIZE; bbLengthBeforeRead = bb.getLength(); int cnt = conv.read(result, 0, size); if (cnt <= 0) { if (log.isDebugEnabled()) { log.debug("B2CConverter: EOF"); } return; } if (log.isDebugEnabled()) { log.debug("B2CConverter: Converted: " + new String(result, 0, cnt)); } cb.append(result, 0, cnt); limit = limit - (bbLengthBeforeRead - bb.getLength()); } } catch (IOException ex) { if (log.isDebugEnabled()) { log.debug("B2CConverter: Reseting the converter " + ex.toString()); } reset(); throw ex; } }	public void reset() throws IOException { iis = new IntermediateInputStream(); conv = new ReadConvertor(iis, getCharset(encoding)); }
@Override public <T extends Servlet> T createServlet(Class<T> c) throws ServletException { try { T servlet = (T) context.getInstanceManager().newInstance(c.getName()); context.dynamicServletCreated(servlet); return servlet; } catch (IllegalAccessException e) { throw new ServletException(e); } catch (InvocationTargetException e) { ExceptionUtils.handleThrowable(e.getCause()); throw new ServletException(e); } catch (NamingException e) { throw new ServletException(e); } catch (InstantiationException e) { throw new ServletException(e); } catch (ClassNotFoundException e) { throw new ServletException(e); } }	@Override public <T extends Filter> T createFilter(Class<T> c) throws ServletException { try { T filter = (T) context.getInstanceManager().newInstance(c.getName()); return filter; } catch (IllegalAccessException e) { throw new ServletException(e); } catch (InvocationTargetException e) { ExceptionUtils.handleThrowable(e.getCause()); throw new ServletException(e); } catch (NamingException e) { throw new ServletException(e); } catch (InstantiationException e) { throw new ServletException(e); } catch (ClassNotFoundException e) { throw new ServletException(e); } }	public void setFilterName(String filterName) { this.filterName = filterName; }	public void setServletName(String servletName) { this.servletName = servletName; }	@Test public void testBug53467() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0"); tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/test/bug5nnnn/bug53467].jsp", res, null); Assert.assertEquals(HttpServletResponse.SC_OK, rc); Assert.assertTrue(res.toString().contains("<p>OK</p>")); }
private void doTestOverrideDefaultServletWithSCI(String servletName) throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0"); StandardContext ctxt = (StandardContext) tomcat.addContext(null, "/test", appDir.getAbsolutePath()); ctxt.setDefaultWebXml(new File("conf/web.xml").getAbsolutePath()); ctxt.addLifecycleListener(new ContextConfig()); ctxt.addServletContainerInitializer(new CustomDefaultServletSCI(servletName), null); tomcat.start(); ByteChunk res = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/test", res, null); assertEquals(HttpServletResponse.SC_OK, rc); assertEquals("OK - Custom default Servlet", res.toString()); }	public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException { Servlet s = new CustomDefaultServlet(); ServletRegistration.Dynamic r = ctx.addServlet(servletName, s); r.addMapping("/"); }	public void addAbsoluteOrdering(String fragmentName) { if (absoluteOrdering == null) { absoluteOrdering = new LinkedHashSet<>(); } absoluteOrdering.add(fragmentName); }	public Set<String> getAbsoluteOrdering() { return absoluteOrdering; }	@Override public void begin(String namespace, String name, Attributes attributes) throws Exception { if (isLoginConfigSet) { throw new IllegalArgumentException("<login-config> element is limited to 1 occurrence"); } isLoginConfigSet = true; }	public void setOverridable(boolean overridable) { this.overridable = overridable; }	@Test public void testBug51396() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0-fragments"); tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); tomcat.start(); ByteChunk bc = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/test/bug51396.jsp", bc, null); assertEquals(HttpServletResponse.SC_OK, rc); assertTrue(bc.toString().contains("<p>OK</p>")); }	@Test public void testBug53574() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0"); tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/test/bug53574", res, null); Assert.assertEquals(HttpServletResponse.SC_OK, rc); String body = res.toString(); Assert.assertTrue(body.contains("OK")); }
@SuppressWarnings("null") private static Method resolveAmbiguousMethod(Set<Method> candidates, Class<?>[] paramTypes) { Method m = candidates.iterator().next(); int nonMatchIndex = 0; Class<?> nonMatchClass = null; for (int i = 0; i < paramTypes.length; i++) { if (m.getParameterTypes()[i] != paramTypes[i]) { nonMatchIndex = i; nonMatchClass = paramTypes[i]; break; } } for (Method c : candidates) { if (c.getParameterTypes()[nonMatchIndex] == paramTypes[nonMatchIndex]) { return null; } } nonMatchClass = nonMatchClass.getSuperclass(); while (nonMatchClass != null) { for (Method c : candidates) { if (c.getParameterTypes()[nonMatchIndex].equals(nonMatchClass)) { return c; } } nonMatchClass = nonMatchClass.getSuperclass(); } return null; }	private static boolean isAssignableFrom(Class<?> src, Class<?> target) { Class<?> targetClass; if (target.isPrimitive()) { if (target == Boolean.TYPE) { targetClass = Boolean.class; } else if (target == Character.TYPE) { targetClass = Character.class; } else if (target == Byte.TYPE) { targetClass = Byte.class; } else if (target == Short.TYPE) { targetClass = Short.class; } else if (target == Integer.TYPE) { targetClass = Integer.class; } else if (target == Long.TYPE) { targetClass = Long.class; } else if (target == Float.TYPE) { targetClass = Float.class; } else { targetClass = Double.class; } } else { targetClass = target; } return targetClass.isAssignableFrom(src); }	protected static final String paramString(Class<?>[] types) { if (types != null) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < types.length; i++) { sb.append(types[i].getName()).append(", "); } if (sb.length() > 2) { sb.setLength(sb.length() - 2); } return sb.toString(); } return null; }	@SuppressWarnings("null") public static Method getMethod(Object base, Object property, Class<?>[] paramTypes, Object[] paramValues) throws MethodNotFoundException { if (base == null || property == null) { throw new MethodNotFoundException(MessageFactory.get("error.method.notfound", base, property, paramString(paramTypes))); } String methodName = (property instanceof String) ? (String) property : property.toString(); int paramCount; if (paramTypes == null) { paramCount = 0; } else { paramCount = paramTypes.length; } Method[] methods = base.getClass().getMethods(); Map<Method, Integer> candidates = new HashMap<>(); for (Method m : methods) { if (!m.getName().equals(methodName)) { continue; } Class<?>[] mParamTypes = m.getParameterTypes(); int mParamCount; if (mParamTypes == null) { mParamCount = 0; } else { mParamCount = mParamTypes.length; } if (!(paramCount == mParamCount || (m.isVarArgs() && paramCount >= mParamCount))) { continue; } int exactMatch = 0; boolean noMatch = false; for (int i = 0; i < mParamCount; i++) { if (mParamTypes[i].equals(paramTypes[i])) { exactMatch++; } else if (i == (mParamCount - 1) && m.isVarArgs()) { Class<?> varType = mParamTypes[i].getComponentType(); for (int j = i; j < paramCount; j++) { if (!isAssignableFrom(paramTypes[j], varType)) { if (paramValues == null) { noMatch = true; break; } else { if (!isCoercibleFrom(paramValues[j], varType)) { noMatch = true; break; } } } // Don't treat a varArgs match as an exact match, it can // lead to a varArgs method matching when the result // should be ambiguous } } else if (!isAssignableFrom(paramTypes[i], mParamTypes[i])) { if (paramValues == null) { noMatch = true; break; } else { if (!isCoercibleFrom(paramValues[i], mParamTypes[i])) { noMatch = true; break; } } } } if (noMatch) { continue; } if (exactMatch == paramCount) { return m; } candidates.put(m, Integer.valueOf(exactMatch)); } // Look for the method that has the highest number of parameters where int bestMatch = 0; Method match = null; boolean multiple = false; for (Map.Entry<Method, Integer> entry : candidates.entrySet()) { if (entry.getValue().intValue() > bestMatch || match == null) { bestMatch = entry.getValue().intValue(); match = entry.getKey(); multiple = false; } else if (entry.getValue().intValue() == bestMatch) { multiple = true; } } if (multiple) { if (bestMatch == paramCount - 1) { // Only one parameter is not an exact match - try using the match = resolveAmbiguousMethod(candidates.keySet(), paramTypes); } else { match = null; } if (match == null) { throw new MethodNotFoundException(MessageFactory.get("error.method.ambiguous", base, property, paramString(paramTypes))); } } if (match == null) { throw new MethodNotFoundException(MessageFactory.get("error.method.notfound", base, property, paramString(paramTypes))); } return match; }
public synchronized void remove(final Entry element) { if (!element.getValid()) { return; } Entry next = element.getNext(); Entry prev = element.getPrevious(); if (next != null) { next.setPrevious(prev); } else { last = prev; } if (prev != null) { prev.setNext(next); } else { first = next; } size--; element.setValid(false); }
public static synchronized boolean validateApplication(WebResourceRoot resources, Context context) throws IOException { String appName = context.getName(); ArrayList<ManifestResource> appManifestResources = new ArrayList<>(); if (resources == null) return false; InputStream inputStream = null; try { WebResource resource = resources.getResource("/META-INF/MANIFEST.MF"); if (resource.isFile()) { inputStream = resource.getInputStream(); Manifest manifest = new Manifest(inputStream); inputStream.close(); inputStream = null; ManifestResource mre = new ManifestResource(sm.getString("extensionValidator.web-application-manifest"), manifest, ManifestResource.WAR); appManifestResources.add(mre); } } finally { if (inputStream != null) { try { inputStream.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } } try { WebResource[] jars = resources.listResources("/WEB-INF/lib"); for (WebResource jar : jars) { if (jar.getName().toLowerCase(Locale.ENGLISH).endsWith(".jar") && jar.isFile()) { inputStream = jar.getInputStream(); Manifest jmanifest = getManifest(inputStream); if (jmanifest != null) { ManifestResource mre = new ManifestResource(jar.getName(), jmanifest, ManifestResource.APPLICATION); appManifestResources.add(mre); } } } } finally { if (inputStream != null) { try { inputStream.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } } return validateManifestResources(appName, appManifestResources); }
public static void main(String[] args) { if (daemon == null) { Bootstrap bootstrap = new Bootstrap(); try { bootstrap.init(); } catch (Throwable t) { handleThrowable(t); t.printStackTrace(); return; } daemon = bootstrap; } try { String command = "start"; if (args.length > 0) { command = args[args.length - 1]; } if (command.equals("startd")) { args[args.length - 1] = "start"; daemon.load(args); daemon.start(); } else if (command.equals("stopd")) { args[args.length - 1] = "stop"; daemon.stop(); } else if (command.equals("start")) { daemon.setAwait(true); daemon.load(args); daemon.start(); } else if (command.equals("stop")) { daemon.stopServer(args); } else if (command.equals("configtest")) { daemon.load(args); if (null == daemon.getServer()) { System.exit(1); } System.exit(0); } else { log.warn("Bootstrap: command \"" + command + "\" does not exist."); } } catch (Throwable t) { if (t instanceof InvocationTargetException && t.getCause() != null) { t = t.getCause(); } handleThrowable(t); t.printStackTrace(); System.exit(1); } }
@Override public void write(String s, int off, int len) throws IOException { ensureOpen(); if (bufferSize == 0) { initOut(); out.write(s, off, len); return; } int b = off, t = off + len; while (b < t) { int d = min(bufferSize - nextChar, t - b); s.getChars(b, b + d, cb, nextChar); b += d; nextChar += d; if (nextChar >= bufferSize) if (autoFlush) flushBuffer(); else bufferOverflow(); } }
@Override public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception { try { this.oname = createObjectName(name); if (oname != null) registerJmx(); } catch (MalformedObjectNameException x) { log.error("Unable to create object name for JDBC pool.", x); } return name; }
protected void close(boolean force) { if (this.closed) return; this.closed = true; if (poolCleaner != null) { poolCleaner.stopRunning(); } BlockingQueue<PooledConnection> pool = (idle.size() > 0) ? idle : (force ? busy : idle); while (pool.size() > 0) { try { PooledConnection con = pool.poll(1000, TimeUnit.MILLISECONDS); while (con != null) { if (pool == idle) release(con); else abandon(con); if (pool.size() > 0) { con = pool.poll(1000, TimeUnit.MILLISECONDS); } else { break; } } //while } catch (InterruptedException ex) { if (getPoolProperties().getPropagateInterruptState()) { Thread.currentThread().interrupt(); } else { Thread.interrupted(); } } if (pool.size() == 0 && force && pool != busy) pool = busy; } if (this.getPoolProperties().isJmxEnabled()) this.jmxPool = null; PoolProperties.InterceptorDefinition[] proxies = getPoolProperties().getJdbcInterceptorsAsArray(); for (int i = 0; i < proxies.length; i++) { try { proxies[i].getInterceptorClass().newInstance().poolClosed(this); } catch (Exception x) { log.debug("Unable to inform interceptor of pool closure.", x); } } }
public void testBug53071() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(ctx, "errorServlet", new ErrorServlet()); ctx.addServletMapping("/", "errorServlet"); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort()); Assert.assertTrue(res.toString().contains("<p><b>message</b> <u>" + ErrorServlet.ERROR_TEXT + "</u></p>")); }	protected void report(Request request, Response response, Throwable throwable) { int statusCode = response.getStatus(); if ((statusCode < 400) || (response.getContentWritten() > 0)) { return; } String message = RequestUtil.filter(response.getMessage()); if (message == null) { if (throwable != null) { String exceptionMessage = throwable.getMessage(); if (exceptionMessage != null && exceptionMessage.length() > 0) { message = RequestUtil.filter((new Scanner(exceptionMessage)).nextLine()); } } if (message == null) { message = ""; } } String report = null; try { report = sm.getString("http." + statusCode); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } if (report == null) { return; } StringBuilder sb = new StringBuilder(); sb.append("<html><head><title>"); sb.append(ServerInfo.getServerInfo()).append(" - "); sb.append(sm.getString("errorReportValve.errorReport")); sb.append("</title>"); sb.append("<style><!--"); sb.append(org.apache.catalina.util.TomcatCSS.TOMCAT_CSS); sb.append("--></style> "); sb.append("</head><body>"); sb.append("<h1>"); sb.append(sm.getString("errorReportValve.statusHeader", "" + statusCode, message)).append("</h1>"); sb.append("<HR size=\"1\" noshade=\"noshade\">"); sb.append("<p><b>type</b> "); if (throwable != null) { sb.append(sm.getString("errorReportValve.exceptionReport")); } else { sb.append(sm.getString("errorReportValve.statusReport")); } sb.append("</p>"); sb.append("<p><b>"); sb.append(sm.getString("errorReportValve.message")); sb.append("</b> <u>"); sb.append(message).append("</u></p>"); sb.append("<p><b>"); sb.append(sm.getString("errorReportValve.description")); sb.append("</b> <u>"); sb.append(report); sb.append("</u></p>"); if (throwable != null) { String stackTrace = getPartialServletStackTrace(throwable); sb.append("<p><b>"); sb.append(sm.getString("errorReportValve.exception")); sb.append("</b> <pre>"); sb.append(RequestUtil.filter(stackTrace)); sb.append("</pre></p>"); int loops = 0; Throwable rootCause = throwable.getCause(); while (rootCause != null && (loops < 10)) { stackTrace = getPartialServletStackTrace(rootCause); sb.append("<p><b>"); sb.append(sm.getString("errorReportValve.rootCause")); sb.append("</b> <pre>"); sb.append(RequestUtil.filter(stackTrace)); sb.append("</pre></p>"); rootCause = rootCause.getCause(); loops++; } sb.append("<p><b>"); sb.append(sm.getString("errorReportValve.note")); sb.append("</b> <u>"); sb.append(sm.getString("errorReportValve.rootCauseInLogs", ServerInfo.getServerInfo())); sb.append("</u></p>"); } sb.append("<HR size=\"1\" noshade=\"noshade\">"); sb.append("<h3>").append(ServerInfo.getServerInfo()).append("</h3>"); sb.append("</body></html>"); try { try { response.setContentType("text/html"); response.setCharacterEncoding("utf-8"); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); if (container.getLogger().isDebugEnabled()) { container.getLogger().debug("status.setContentType", t); } } Writer writer = response.getReporter(); if (writer != null) { // If writer is null, it's an indication that the response has writer.write(sb.toString()); } } catch (IOException e) { // Ignore } catch (IllegalStateException e) { // Ignore } }
public static Timer getPoolTimer() { return poolCleanTimer; }	public static Timer getPoolTimer() { return poolCleanTimer; }


@SuppressWarnings("null") public static String escapeXml(String buffer) { int start = 0; int length = buffer.length(); char[] arrayBuffer = buffer.toCharArray(); StringBuilder escapedBuffer = null; for (int i = 0; i < length; i++) { char c = arrayBuffer[i]; if (c <= HIGHEST_SPECIAL) { char[] escaped = specialCharactersRepresentation[c]; if (escaped != null) { if (start == 0) { escapedBuffer = new StringBuilder(length + 5); } if (start < i) { escapedBuffer.append(arrayBuffer, start, i - start); } start = i + 1; escapedBuffer.append(escaped); } } } if (start == 0) { return buffer; } if (start < length) { escapedBuffer.append(arrayBuffer, start, length - start); } return escapedBuffer.toString(); }	public static String stripSession(String url) { StringBuilder u = new StringBuilder(url); int sessionStart; while ((sessionStart = u.toString().indexOf(";" + Constants.SESSION_PARAMETER_NAME + "=")) != -1) { int sessionEnd = u.toString().indexOf(";", sessionStart + 1); if (sessionEnd == -1) sessionEnd = u.toString().indexOf("?", sessionStart + 1); if (sessionEnd == -1) sessionEnd = u.length(); u.delete(sessionStart, sessionEnd); } return u.toString(); }	public static boolean output(JspWriter out, String value, String defaultValue, boolean escapeXml) throws IOException { String v = value != null ? value : defaultValue; if (v != null) { if (escapeXml) { v = org.apache.jasper.tagplugins.jstl.Util.escapeXml(v); } out.write(v); return true; } else { return false; } }	public void doTag(TagPluginContext ctxt) { //these two data member are to indicate boolean hasDefault = false, hasEscapeXml = false; hasDefault = ctxt.isAttributeSpecified("default"); hasEscapeXml = ctxt.isAttributeSpecified("escapeXml"); //strValName, strEscapeXmlName & strDefName are two variables' name String strValName = ctxt.getTemporaryVariableName(); String strDefName = ctxt.getTemporaryVariableName(); String strEscapeXmlName = ctxt.getTemporaryVariableName(); String strSkipBodyName = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource("String " + strValName + " = null;"); ctxt.generateJavaSource("if("); ctxt.generateAttribute("value"); ctxt.generateJavaSource("!=null){"); ctxt.generateJavaSource(" " + strValName + " = ("); ctxt.generateAttribute("value"); ctxt.generateJavaSource(").toString();"); ctxt.generateJavaSource("}"); //initiate the strDefName with null. ctxt.generateJavaSource("String " + strDefName + " = null;\n"); if (hasDefault) { ctxt.generateJavaSource("if("); ctxt.generateAttribute("default"); ctxt.generateJavaSource(" != null){"); ctxt.generateJavaSource(strDefName + " = ("); ctxt.generateAttribute("default"); ctxt.generateJavaSource(").toString();"); ctxt.generateJavaSource("}"); } //initiate the strEscapeXmlName with true; ctxt.generateJavaSource("boolean " + strEscapeXmlName + " = true;"); if (hasEscapeXml) { ctxt.generateJavaSource(strEscapeXmlName + " = "); ctxt.generateAttribute("escapeXml"); ctxt.generateJavaSource(";"); } ctxt.generateJavaSource("boolean " + strSkipBodyName + " = " + "org.apache.jasper.tagplugins.jstl.core.Out.output(out, " + strValName + ", " + strDefName + ", " + strEscapeXmlName + ");"); ctxt.generateJavaSource("if(!" + strSkipBodyName + ") {"); ctxt.generateBody(); ctxt.generateJavaSource("}"); }	@Test public void testBug54144() throws Exception { ByteChunk res = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/test/bug54144.jsp", res, null); Assert.assertEquals(HttpServletResponse.SC_OK, rc); String body = res.toString(); Assert.assertTrue(body.contains("OK - 1")); Assert.assertTrue(body.contains("OK - 2")); Assert.assertTrue(body.contains("OK - 3")); Assert.assertFalse(body.contains("FAIL")); }
public static void writeVMState(PrintWriter writer, int mode) throws Exception { if (mode == 0) { writer.print("<h1>JVM</h1>"); writer.print("<p>"); writer.print(" Free memory: "); writer.print(formatSize(Long.valueOf(Runtime.getRuntime().freeMemory()), true)); writer.print(" Total memory: "); writer.print(formatSize(Long.valueOf(Runtime.getRuntime().totalMemory()), true)); writer.print(" Max memory: "); writer.print(formatSize(Long.valueOf(Runtime.getRuntime().maxMemory()), true)); writer.print("</p>"); } else if (mode == 1) { writer.write("<jvm>"); writer.write("<memory"); writer.write(" free='" + Runtime.getRuntime().freeMemory() + "'"); writer.write(" total='" + Runtime.getRuntime().totalMemory() + "'"); writer.write(" max='" + Runtime.getRuntime().maxMemory() + "'/>"); writer.write("</jvm>"); } }
@Override public void addRuleInstances(Digester digester) { digester.addObjectCreate(prefix + "Realm", null, "className"); digester.addSetProperties(prefix + "Realm"); digester.addSetNext(prefix + "Realm", "setRealm", "org.apache.catalina.Realm"); digester.addObjectCreate(prefix + "Realm/Realm", null, "className"); digester.addSetProperties(prefix + "Realm/Realm"); digester.addSetNext(prefix + "Realm/Realm", "addRealm", "org.apache.catalina.Realm"); }
protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getMethod(); if (method.equals(METHOD_GET)) { long lastModified = getLastModified(req); if (lastModified == -1) { // servlet doesn't support if-modified-since, no reason doGet(req, resp); } else { long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince < (lastModified / 1000 * 1000)) { // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare maybeSetLastModified(resp, lastModified); doGet(req, resp); } else { resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); } } } else if (method.equals(METHOD_HEAD)) { long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); } else if (method.equals(METHOD_POST)) { doPost(req, resp); } else if (method.equals(METHOD_PUT)) { doPut(req, resp); } else if (method.equals(METHOD_DELETE)) { doDelete(req, resp); } else if (method.equals(METHOD_OPTIONS)) { doOptions(req, resp); } else if (method.equals(METHOD_TRACE)) { doTrace(req, resp); } else { // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. String errMsg = lStrings.getString("http.method_not_implemented"); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); } }
public String getResponseBody() { return responseBody; }	public void processRequest(boolean wantBody) throws IOException, InterruptedException { sendRequest(); readResponse(wantBody); }	public void sendRequest() throws InterruptedException, IOException { boolean first = true; for (String requestPart : request) { if (first) { first = false; } else { Thread.sleep(requestPause); } writer.write(requestPart); writer.flush(); } }	public void setRequest(String[] theRequest) { request = theRequest; }
@Override public void dispatch(ServletContext context, String path) { if (log.isDebugEnabled()) { logDebug("dispatch "); } check(); if (request.getAttribute(ASYNC_REQUEST_URI)==null) { request.setAttribute(ASYNC_REQUEST_URI, request.getRequestURI()+"?"+request.getQueryString()); request.setAttribute(ASYNC_CONTEXT_PATH, request.getContextPath()); request.setAttribute(ASYNC_SERVLET_PATH, request.getServletPath()); request.setAttribute(ASYNC_QUERY_STRING, request.getQueryString()); } final RequestDispatcher requestDispatcher = context.getRequestDispatcher(path); if (!(requestDispatcher instanceof AsyncDispatcher)) { throw new UnsupportedOperationException( sm.getString("asyncContextImpl.noAsyncDispatcher")); } final AsyncDispatcher applicationDispatcher = (AsyncDispatcher) requestDispatcher; final HttpServletRequest servletRequest = (HttpServletRequest) getRequest(); final HttpServletResponse servletResponse = (HttpServletResponse) getResponse(); Runnable run = new Runnable() { @Override } }
private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); File foo = new File(docBase, "async"); addDeleteOnTearDown(foo); if (!foo.mkdirs() && !foo.isDirectory()) { fail("Unable to create async directory in docBase"); } Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); TimeoutServlet timeout = new TimeoutServlet(completeOnTimeout, dispatchUrl); Wrapper wrapper = Tomcat.addServlet(ctx, "time", timeout); wrapper.setAsyncSupported(true); ctx.addServletMapping("/async", "time"); if (dispatchUrl != null) { NonAsyncServlet nonAsync = new NonAsyncServlet(); Tomcat.addServlet(ctx, "nonasync", nonAsync); ctx.addServletMapping(dispatchUrl, "nonasync"); } ctx.addApplicationListener(TrackingRequestListener.class.getName()); TesterAccessLogValve alv = new TesterAccessLogValve(); ctx.getPipeline().addValve(alv); TesterAccessLogValve alvGlobal = new TesterAccessLogValve(); tomcat.getHost().getPipeline().addValve(alvGlobal); tomcat.start(); ByteChunk res = new ByteChunk(); try { getUrl("http://localhost:" + getPort() + "/async", res, null); } catch (IOException ioe) { // Ignore - expected for some error conditions } StringBuilder expected = new StringBuilder("requestInitialized-"); expected.append("TimeoutServletGet-onTimeout-"); if (completeOnTimeout) { if (dispatchUrl == null) { expected.append("onComplete-"); expected.append("requestDestroyed"); } else { // Error - no further output // There is no onComplete- since the complete event would be // fired during post processing but since there is an error that // never happens. } } else { if (dispatchUrl == null) { expected.append("onError-"); } else { expected.append("NonAsyncServletGet-"); } expected.append("onComplete-"); expected.append("requestDestroyed"); } assertEquals(expected.toString(), res.toString()); if (completeOnTimeout && dispatchUrl != null) { alvGlobal.validateAccessLog(1, 500, 0, TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME); alv.validateAccessLog(0, 500, 0, 0); } else { alvGlobal.validateAccessLog(1, 200, TimeoutServlet.ASYNC_TIMEOUT, TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME); alv.validateAccessLog(1, 200, TimeoutServlet.ASYNC_TIMEOUT, TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME); } }	private void status(Request request, Response response) { int statusCode = response.getStatus(); Context context = request.getContext(); if (context == null) { return; } if (!response.isError()) { return; } ErrorPage errorPage = context.findErrorPage(statusCode); if (errorPage == null) { errorPage = context.findErrorPage(0); } if (errorPage != null) { response.setAppCommitted(false); request.setAttribute(RequestDispatcher.ERROR_STATUS_CODE, Integer.valueOf(statusCode)); String message = response.getMessage(); if (message == null) { message = ""; } request.setAttribute(RequestDispatcher.ERROR_MESSAGE, message); request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, errorPage.getLocation()); request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, DispatcherType.ERROR); Wrapper wrapper = request.getWrapper(); if (wrapper != null) { request.setAttribute(RequestDispatcher.ERROR_SERVLET_NAME, wrapper.getName()); } request.setAttribute(RequestDispatcher.ERROR_REQUEST_URI, request.getRequestURI()); if (custom(request, response, errorPage)) { try { response.flushBuffer(); } catch (ClientAbortException e) { // Ignore } catch (IOException e) { container.getLogger().warn("Exception Processing " + errorPage, e); } } } }	@Test public void testBug53843() throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); Bug53843ServletA servletA = new Bug53843ServletA(); Wrapper a = Tomcat.addServlet(ctx, "ServletA", servletA); a.setAsyncSupported(true); Tomcat.addServlet(ctx, "ServletB", new Bug53843ServletB()); ctx.addServletMapping("/ServletA", "ServletA"); ctx.addServletMapping("/ServletB", "ServletB"); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/ServletA"); ByteChunk body = new ByteChunk(); int rc = getUrl(url.toString(), body, null); assertEquals(HttpServletResponse.SC_OK, rc); assertEquals("OK", body.toString()); assertTrue(servletA.isAsyncWhenExpected()); }	public boolean timeout() throws IOException { AtomicBoolean result = new AtomicBoolean(); request.getCoyoteRequest().action(ActionCode.ASYNC_TIMEOUT, result); if (result.get()) { ClassLoader oldCL = Thread.currentThread().getContextClassLoader(); ClassLoader newCL = request.getContext().getLoader().getClassLoader(); try { Thread.currentThread().setContextClassLoader(newCL); boolean listenerInvoked = false; List<AsyncListenerWrapper> listenersCopy = new ArrayList<>(); listenersCopy.addAll(listeners); for (AsyncListenerWrapper listener : listenersCopy) { listener.fireOnTimeout(event); listenerInvoked = true; } if (listenerInvoked) { request.getCoyoteRequest().action(ActionCode.ASYNC_IS_TIMINGOUT, result); return !result.get(); } else { complete(); } } finally { Thread.currentThread().setContextClassLoader(oldCL); } } return true; }	@Override public final void invoke(Request request, Response response) throws IOException, ServletException { Context context = request.getContext(); if (context == null) { response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, sm.getString("standardHost.noContext")); return; } if (context.getLoader() != null) { if (Globals.IS_SECURITY_ENABLED) { PrivilegedAction<Void> pa = new PrivilegedSetTccl(context.getLoader().getClassLoader()); AccessController.doPrivileged(pa); } else { Thread.currentThread().setContextClassLoader(context.getLoader().getClassLoader()); } } if (request.isAsyncSupported()) { request.setAsyncSupported(context.getPipeline().isAsyncSupported()); } // Don't fire listeners during async processing // If a request init listener throws an exception, the request is boolean asyncAtStart = request.isAsync(); if (asyncAtStart || context.fireRequestInitEvent(request)) { try { context.getPipeline().getFirst().invoke(request, response); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t); throwable(request, response, t); } if (!(request.isAsync() || (asyncAtStart && request.getAttribute(RequestDispatcher.ERROR_EXCEPTION) != null))) { if (context.getState().isAvailable()) { response.setSuspended(false); Throwable t = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION); if (t != null) { throwable(request, response, t); } else { status(request, response); } context.fireRequestDestroyEvent(request); } } } if (ACCESS_SESSION) { request.getSession(false); } if (Globals.IS_SECURITY_ENABLED) { PrivilegedAction<Void> pa = new PrivilegedSetTccl(MY_CLASSLOADER); AccessController.doPrivileged(pa); } else { Thread.currentThread().setContextClassLoader(MY_CLASSLOADER); } }	public synchronized boolean asyncDispatch() { boolean doDispatch = false; if (state == AsyncState.STARTING) { state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.STARTED || state == AsyncState.TIMING_OUT) { state = AsyncState.DISPATCHING; doDispatch = true; } else { throw new IllegalStateException(sm.getString("asyncStateMachine.invalidAsyncState", "asyncDispatch()", state)); } return doDispatch; }	public void setErrorState(Throwable t) { if (t != null) request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t); request.getCoyoteRequest().action(ActionCode.ASYNC_ERROR, null); AsyncEvent errorEvent = new AsyncEvent(event.getAsyncContext(), event.getSuppliedRequest(), event.getSuppliedResponse(), t); List<AsyncListenerWrapper> listenersCopy = new ArrayList<>(); listenersCopy.addAll(listeners); for (AsyncListenerWrapper listener : listenersCopy) { try { listener.fireOnError(errorEvent); } catch (IOException ioe) { log.warn("onStartAsync() failed for listener of type [" + listener.getClass().getName() + "]", ioe); } } }	@Test public void testAsyncStartNoComplete() throws Exception { Tomcat tomcat = getTomcatInstance(); tomcat.getConnector().setAttribute("connectionTimeout", Integer.valueOf(3000)); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); AsyncStartNoCompleteServlet servlet = new AsyncStartNoCompleteServlet(); Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet); wrapper.setAsyncSupported(true); ctx.addServletMapping("/", "servlet"); TesterAccessLogValve alv = new TesterAccessLogValve(); ctx.getPipeline().addValve(alv); tomcat.start(); ByteChunk bc1 = getUrl("http://localhost:" + getPort() + "/?echo=run1"); assertEquals("OK-run1", bc1.toString()); ByteChunk bc2 = getUrl("http://localhost:" + getPort() + "/?echo=run2"); assertEquals("OK-run2", bc2.toString()); alv.validateAccessLog(2, 200, AsyncStartNoCompleteServlet.ASYNC_TIMEOUT, AsyncStartNoCompleteServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME); }	@Test public void testListeners() throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); TrackingServlet tracking = new TrackingServlet(); Wrapper wrapper = Tomcat.addServlet(ctx, "tracking", tracking); wrapper.setAsyncSupported(true); ctx.addServletMapping("/stage1", "tracking"); TimeoutServlet timeout = new TimeoutServlet(true, null); Wrapper wrapper2 = Tomcat.addServlet(ctx, "timeout", timeout); wrapper2.setAsyncSupported(true); ctx.addServletMapping("/stage2", "timeout"); TesterAccessLogValve alv = new TesterAccessLogValve(); ctx.getPipeline().addValve(alv); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/stage1"); ByteChunk res = getUrl(url.toString()); assertEquals("DispatchingServletGet-DispatchingServletGet-onStartAsync-" + "TimeoutServletGet-onStartAsync-onTimeout-onComplete-", res.toString()); alv.validateAccessLog(1, 200, TimeoutServlet.ASYNC_TIMEOUT, TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME); }	@Test public void testTimeoutListenerCompleteDispatch() throws Exception { doTestTimeout(true, "/nonasync"); }	@Test public void testTimeoutListenerCompleteNoDispatch() throws Exception { doTestTimeout(true, null); }	@Test public void testTimeoutListenerNoCompleteDispatch() throws Exception { doTestTimeout(false, "/nonasync"); }	@Test public void testTimeoutListenerNoCompleteNoDispatch() throws Exception { doTestTimeout(false, null); }
public synchronized void pong(ByteBuffer data) throws IOException { if (closed) { throw new IOException(sm.getString("outbound.closed")); } doFlush(true); upgradeOutbound.write(0x8A); if (data == null) { upgradeOutbound.write(0); } else { upgradeOutbound.write(data.limit() - data.position()); upgradeOutbound.write(data.array(), data.position(), data.limit() - data.position()); } upgradeOutbound.flush(); }
public void addEnvironment(ContextEnvironment env) { Object value = null; // Instantiating a new instance of the correct object type, and String type = env.getType(); try { if (type.equals("java.lang.String")) { value = env.getValue(); } else if (type.equals("java.lang.Byte")) { if (env.getValue() == null) { value = Byte.valueOf((byte) 0); } else { value = Byte.decode(env.getValue()); } } else if (type.equals("java.lang.Short")) { if (env.getValue() == null) { value = Short.valueOf((short) 0); } else { value = Short.decode(env.getValue()); } } else if (type.equals("java.lang.Integer")) { if (env.getValue() == null) { value = Integer.valueOf(0); } else { value = Integer.decode(env.getValue()); } } else if (type.equals("java.lang.Long")) { if (env.getValue() == null) { value = Long.valueOf(0); } else { value = Long.decode(env.getValue()); } } else if (type.equals("java.lang.Boolean")) { value = Boolean.valueOf(env.getValue()); } else if (type.equals("java.lang.Double")) { if (env.getValue() == null) { value = Double.valueOf(0); } else { value = Double.valueOf(env.getValue()); } } else if (type.equals("java.lang.Float")) { if (env.getValue() == null) { value = Float.valueOf(0); } else { value = Float.valueOf(env.getValue()); } } else if (type.equals("java.lang.Character")) { if (env.getValue() == null) { value = Character.valueOf((char) 0); } else { if (env.getValue().length() == 1) { value = Character.valueOf(env.getValue().charAt(0)); } else { throw new IllegalArgumentException(); } } } else { logger.error(sm.getString("naming.invalidEnvEntryType", env.getName())); } } catch (NumberFormatException e) { logger.error(sm.getString("naming.invalidEnvEntryValue", env.getName())); } catch (IllegalArgumentException e) { logger.error(sm.getString("naming.invalidEnvEntryValue", env.getName())); } if (value != null) { try { if (logger.isDebugEnabled()) logger.debug(" Adding environment entry " + env.getName()); createSubcontexts(envCtx, env.getName()); envCtx.bind(env.getName(), value); } catch (NamingException e) { logger.error(sm.getString("naming.invalidEnvEntryValue", e)); } } }	@Override public void contextInitialized(ServletContextEvent sce) { javax.naming.Context initCtx; try { initCtx = new InitialContext(); javax.naming.Context envCtx = (javax.naming.Context) initCtx.lookup("java:comp/env"); String value = (String) envCtx.lookup(JNDI_NAME); if (!JNDI_VALUE.equals(value)) { throw new RuntimeException(); } } catch (NamingException e) { throw new RuntimeException(e); } }	public void testBug49132() throws Exception { Tomcat tomcat = getTomcatInstance(); org.apache.catalina.Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); tomcat.enableNaming(); ContextEnvironment environment = new ContextEnvironment(); environment.setType(JNDI_VALUE.getClass().getName()); environment.setName(JNDI_NAME); environment.setValue(JNDI_VALUE); ctx.getNamingResources().addEnvironment(environment); ctx.addApplicationListener(Bug49132Listener.class.getName()); tomcat.start(); assertEquals(LifecycleState.STARTED, ctx.getState()); }
public void setStoreDelegatedCredential(boolean storeDelegatedCredential) { this.storeDelegatedCredential = storeDelegatedCredential; }
public static Set<WebXml> orderWebFragments(WebXml application, Map<String, WebXml> fragments) { Set<WebXml> orderedFragments = new LinkedHashSet<>(); boolean absoluteOrdering = (application.getAbsoluteOrdering() != null); if (absoluteOrdering) { Set<String> requestedOrder = application.getAbsoluteOrdering(); for (String requestedName : requestedOrder) { if (WebXml.ORDER_OTHERS.equals(requestedName)) { for (Entry<String, WebXml> entry : fragments.entrySet()) { if (!requestedOrder.contains(entry.getKey())) { WebXml fragment = entry.getValue(); if (fragment != null) { orderedFragments.add(fragment); } } } } else { WebXml fragment = fragments.get(requestedName); if (fragment != null) { orderedFragments.add(fragment); } else { log.warn(sm.getString("webXml.wrongFragmentName", requestedName)); } } } } else { List<String> order = new LinkedList<>(); order.addAll(fragments.keySet()); for (WebXml fragment : fragments.values()) { String name = fragment.getName(); if (fragment.getBeforeOrdering().contains(WebXml.ORDER_OTHERS)) { order.remove(name); order.add(0, name); } else if (fragment.getAfterOrdering().contains(WebXml.ORDER_OTHERS)) { order.remove(name); order.add(name); } } for (WebXml fragment : fragments.values()) { String name = fragment.getName(); for (String before : fragment.getBeforeOrdering()) { if (!before.equals(WebXml.ORDER_OTHERS) && order.contains(before) && order.indexOf(before) < order.indexOf(name)) { order.remove(name); order.add(order.indexOf(before), name); } } for (String after : fragment.getAfterOrdering()) { if (!after.equals(WebXml.ORDER_OTHERS) && order.contains(after) && order.indexOf(after) > order.indexOf(name)) { order.remove(name); order.add(order.indexOf(after) + 1, name); } } } for (WebXml fragment : fragments.values()) { String name = fragment.getName(); for (String before : fragment.getBeforeOrdering()) { if (!before.equals(WebXml.ORDER_OTHERS) && order.contains(before) && order.indexOf(before) < order.indexOf(name)) { throw new IllegalArgumentException(sm.getString("webXml.mergeConflictOrder")); } } for (String after : fragment.getAfterOrdering()) { if (!after.equals(WebXml.ORDER_OTHERS) && order.contains(after) && order.indexOf(after) > order.indexOf(name)) { throw new IllegalArgumentException(sm.getString("webXml.mergeConflictOrder")); } } } for (String name : order) { orderedFragments.add(fragments.get(name)); } } return orderedFragments; }	public void setUp() throws Exception { app = new WebXml(); a = new WebXml(); a.setName("a"); b = new WebXml(); b.setName("b"); c = new WebXml(); c.setName("c"); d = new WebXml(); d.setName("d"); e = new WebXml(); e.setName("e"); f = new WebXml(); f.setName("f"); fragments = new HashMap<>(); fragments.put("a", a); fragments.put("b", b); fragments.put("c", c); fragments.put("d", d); fragments.put("e", e); fragments.put("f", f); }	@Test public void testOrderWebFragmentsAbsoluteOthersEnd() { app.addAbsoluteOrdering("b"); app.addAbsoluteOrdering("d"); app.addAbsoluteOrdering(WebXml.ORDER_OTHERS); Set<WebXml> others = new HashSet<>(); others.add(a); others.add(c); others.add(e); others.add(f); Set<WebXml> ordered = WebXml.orderWebFragments(app, fragments); Iterator<WebXml> iter = ordered.iterator(); assertEquals(b, iter.next()); assertEquals(d, iter.next()); while (others.size() > 0) { WebXml o = iter.next(); assertTrue(others.contains(o)); others.remove(o); } assertFalse(iter.hasNext()); }	@Test public void testOrderWebFragmentsRelative1() { a.addAfterOrderingOthers(); a.addAfterOrdering("c"); b.addBeforeOrderingOthers(); c.addAfterOrderingOthers(); f.addBeforeOrderingOthers(); f.addBeforeOrdering("b"); Set<WebXml> ordered = WebXml.orderWebFragments(app, fragments); Iterator<WebXml> iter = ordered.iterator(); assertEquals(f, iter.next()); assertEquals(b, iter.next()); assertEquals(d, iter.next()); assertEquals(e, iter.next()); assertEquals(c, iter.next()); assertEquals(a, iter.next()); }	@Test public void testOrderWebFragmentsRelative2() { a.addAfterOrderingOthers(); a.addBeforeOrdering("c"); b.addBeforeOrderingOthers(); d.addAfterOrderingOthers(); e.addBeforeOrderingOthers(); Set<WebXml> ordered = WebXml.orderWebFragments(app, fragments); Iterator<WebXml> iter = ordered.iterator(); // A number of orders are possible but the algorithm is deterministic // and this order is valid. If this fails after a change to the assertEquals(b, iter.next()); assertEquals(e, iter.next()); assertEquals(f, iter.next()); assertEquals(a, iter.next()); assertEquals(c, iter.next()); assertEquals(d, iter.next()); }	@Test public void testOrderWebFragmentsRelative3() { a.addAfterOrdering("b"); c.addBeforeOrderingOthers(); fragments.remove("e"); fragments.remove("f"); Set<WebXml> ordered = WebXml.orderWebFragments(app, fragments); Iterator<WebXml> iter = ordered.iterator(); // A number of orders are possible but the algorithm is deterministic // and this order is valid. If this fails after a change to the assertEquals(c, iter.next()); assertEquals(d, iter.next()); assertEquals(b, iter.next()); assertEquals(a, iter.next()); }	@Test public void testOrderWebFragmentsrelativeCircular() { a.addBeforeOrdering("b"); b.addBeforeOrdering("a"); Exception exception = null; try { WebXml.orderWebFragments(app, fragments); } catch (Exception e1) { exception = e1; } assertTrue(exception instanceof IllegalArgumentException); }
private void prepareResponse() { boolean entityBody = true; contentDelimitation = false; OutputFilter[] outputFilters = getOutputBuffer().getFilters(); if (http09 == true) { getOutputBuffer().addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); return; } int statusCode = response.getStatus(); if ((statusCode == 204) || (statusCode == 205) || (statusCode == 304)) { getOutputBuffer().addActiveFilter(outputFilters[Constants.VOID_FILTER]); entityBody = false; contentDelimitation = true; } MessageBytes methodMB = request.method(); if (methodMB.equals("HEAD")) { getOutputBuffer().addActiveFilter(outputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } boolean sendingWithSendfile = false; if (getEndpoint().getUseSendfile()) { sendingWithSendfile = prepareSendfile(outputFilters); } boolean isCompressable = false; boolean useCompression = false; if (entityBody && (compressionLevel > 0) && !sendingWithSendfile) { isCompressable = isCompressable(); if (isCompressable) { useCompression = useCompression(); } if (useCompression) { response.setContentLength(-1); } } MimeHeaders headers = response.getMimeHeaders(); if (!entityBody) { response.setContentLength(-1); } else { String contentType = response.getContentType(); if (contentType != null) { headers.setValue("Content-Type").setString(contentType); } String contentLanguage = response.getContentLanguage(); if (contentLanguage != null) { headers.setValue("Content-Language").setString(contentLanguage); } } long contentLength = response.getContentLengthLong(); boolean connectionClosePresent = false; if (contentLength != -1) { headers.setValue("Content-Length").setLong(contentLength); getOutputBuffer().addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } else { // If the response code supports an entity body and we're on connectionClosePresent = isConnectionClose(headers); if (entityBody && http11 && !connectionClosePresent) { getOutputBuffer().addActiveFilter(outputFilters[Constants.CHUNKED_FILTER]); contentDelimitation = true; headers.addValue(Constants.TRANSFERENCODING).setString(Constants.CHUNKED); } else { getOutputBuffer().addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); } } if (useCompression) { getOutputBuffer().addActiveFilter(outputFilters[Constants.GZIP_FILTER]); headers.setValue("Content-Encoding").setString("gzip"); } if (isCompressable) { MessageBytes vary = headers.getValue("Vary"); if (vary == null) { headers.setValue("Vary").setString("Accept-Encoding"); } else if (vary.equals("*")) { // No action required } else { headers.setValue("Vary").setString(vary.getString() + ",Accept-Encoding"); } } headers.setValue("Date").setString(FastHttpDateFormat.getCurrentDate()); if ((entityBody) && (!contentDelimitation)) { // Mark as close the connection after the request, and add the keepAlive = false; } // If we know that the request is bad this early, add the keepAlive = keepAlive && !statusDropsConnection(statusCode); if (!keepAlive) { if (!connectionClosePresent) { headers.addValue(Constants.CONNECTION).setString(Constants.CLOSE); } } else if (!http11 && !error) { headers.addValue(Constants.CONNECTION).setString(Constants.KEEPALIVE); } getOutputBuffer().sendStatus(); if (server != null) { headers.setValue("Server").setString(server); } else if (headers.getValue("Server") == null) { getOutputBuffer().write(Constants.SERVER_BYTES); } int size = headers.size(); for (int i = 0; i < size; i++) { getOutputBuffer().sendHeader(headers.getName(i), headers.getValue(i)); } getOutputBuffer().endHeaders(); }
private static String XmlEscape(String s) { if (s == null) return null; StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c == '<') { sb.append("&lt;"); } else if (c == '>') { sb.append("&gt;"); } else if (c == '\'') { sb.append("&#039;"); } else if (c == '&') { sb.append("&amp;"); } else if (c == '"') { sb.append("&#034;"); } else { sb.append(c); } } return sb.toString(); }	void doHandlePageException(Throwable t) throws IOException, ServletException { if (errorPageURL != null && !errorPageURL.equals("")) { request.setAttribute(PageContext.EXCEPTION, t); request.setAttribute(RequestDispatcher.ERROR_STATUS_CODE, new Integer(HttpServletResponse.SC_INTERNAL_SERVER_ERROR)); request.setAttribute(RequestDispatcher.ERROR_REQUEST_URI, ((HttpServletRequest) request).getRequestURI()); request.setAttribute(RequestDispatcher.ERROR_SERVLET_NAME, config.getServletName()); try { forward(errorPageURL); } catch (IllegalStateException ise) { include(errorPageURL); } Object newException = request.getAttribute(RequestDispatcher.ERROR_EXCEPTION); if ((newException != null) && (newException == t)) { request.removeAttribute(RequestDispatcher.ERROR_EXCEPTION); } request.removeAttribute(RequestDispatcher.ERROR_STATUS_CODE); request.removeAttribute(RequestDispatcher.ERROR_REQUEST_URI); request.removeAttribute(RequestDispatcher.ERROR_SERVLET_NAME); request.removeAttribute(PageContext.EXCEPTION); } else { if (t instanceof IOException) throw (IOException) t; if (t instanceof ServletException) throw (ServletException) t; if (t instanceof RuntimeException) throw (RuntimeException) t; Throwable rootCause = null; if (t instanceof JspException) { rootCause = ((JspException) t).getCause(); } else if (t instanceof ELException) { rootCause = ((ELException) t).getCause(); } if (rootCause != null) { throw new ServletException(t.getClass().getName() + ": " + t.getMessage(), rootCause); } throw new ServletException(t); } }

public SocketState process(SocketWrapper<S> socket, SocketStatus status) { Processor<S> processor = connections.remove(socket.getSocket()); if (status == SocketStatus.DISCONNECT && processor == null) { return SocketState.CLOSED; } socket.setAsync(false); try { if (processor == null) { processor = recycledProcessors.pop(); } if (processor == null) { processor = createProcessor(); } initSsl(socket, processor); SocketState state = SocketState.CLOSED; do { if (status == SocketStatus.DISCONNECT) { //do nothing here, just wait for it to get recycled } else if (processor.isAsync() || state == SocketState.ASYNC_END) { state = processor.asyncDispatch(status); } else if (processor.isComet()) { state = processor.event(status); } else if (processor.isUpgrade()) { state = processor.upgradeDispatch(); } else { state = processor.process(socket); } if (state != SocketState.CLOSED && processor.isAsync()) { state = processor.asyncPostProcess(); } if (state == SocketState.UPGRADING) { UpgradeInbound inbound = processor.getUpgradeInbound(); release(socket, processor, false, false); processor = createUpgradeProcessor(socket, inbound); inbound.onUpgradeComplete(); } } while (state == SocketState.ASYNC_END || state == SocketState.UPGRADING); if (state == SocketState.LONG) { // In the middle of processing a request/response. Keep the // socket associated with the processor. Exact requirements longPoll(socket, processor); } else if (state == SocketState.OPEN) { // In keep-alive but between requests. OK to recycle release(socket, processor, false, true); } else if (state == SocketState.SENDFILE) { // Sendfile in progress. If it fails, the socket will be // closed. If it works, the socket will be re-added to the release(socket, processor, false, false); } else if (state == SocketState.UPGRADED) { longPoll(socket, processor); } else { if (!processor.isUpgrade()) { release(socket, processor, true, false); } } return state; } catch (java.net.SocketException e) { getLog().debug(sm.getString("abstractConnectionHandler.socketexception.debug"), e); } catch (java.io.IOException e) { getLog().debug(sm.getString("abstractConnectionHandler.ioexception.debug"), e); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); // any other exception or error is odd. Here we log it // with "ERROR" level, so it will show up even on getLog().error(sm.getString("abstractConnectionHandler.error"), e); } if (processor != null && !processor.isUpgrade()) { release(socket, processor, true, false); } return SocketState.CLOSED; }
private String convertString(Class<?> c, String s, String attrName, Class<?> propEditorClass, boolean isNamedAttribute) { String quoted = s; if (!isNamedAttribute) { quoted = quote(s); } if (propEditorClass != null) { String className = c.getCanonicalName(); return "(" + className + ")org.apache.jasper.runtime.JspRuntimeLibrary.getValueFromBeanInfoPropertyEditor(" + className + ".class, \"" + attrName + "\", " + quoted + ", " + propEditorClass.getCanonicalName() + ".class)"; } else if (c == String.class) { return quoted; } else if (c == boolean.class) { return JspUtil.coerceToPrimitiveBoolean(s, isNamedAttribute); } else if (c == Boolean.class) { return JspUtil.coerceToBoolean(s, isNamedAttribute); } else if (c == byte.class) { return JspUtil.coerceToPrimitiveByte(s, isNamedAttribute); } else if (c == Byte.class) { return JspUtil.coerceToByte(s, isNamedAttribute); } else if (c == char.class) { return JspUtil.coerceToChar(s, isNamedAttribute); } else if (c == Character.class) { return JspUtil.coerceToCharacter(s, isNamedAttribute); } else if (c == double.class) { return JspUtil.coerceToPrimitiveDouble(s, isNamedAttribute); } else if (c == Double.class) { return JspUtil.coerceToDouble(s, isNamedAttribute); } else if (c == float.class) { return JspUtil.coerceToPrimitiveFloat(s, isNamedAttribute); } else if (c == Float.class) { return JspUtil.coerceToFloat(s, isNamedAttribute); } else if (c == int.class) { return JspUtil.coerceToInt(s, isNamedAttribute); } else if (c == Integer.class) { return JspUtil.coerceToInteger(s, isNamedAttribute); } else if (c == short.class) { return JspUtil.coerceToPrimitiveShort(s, isNamedAttribute); } else if (c == Short.class) { return JspUtil.coerceToShort(s, isNamedAttribute); } else if (c == long.class) { return JspUtil.coerceToPrimitiveLong(s, isNamedAttribute); } else if (c == Long.class) { return JspUtil.coerceToLong(s, isNamedAttribute); } else if (c == Object.class) { return "new String(" + quoted + ")"; } else { String className = c.getCanonicalName(); return "(" + className + ")org.apache.jasper.runtime.JspRuntimeLibrary.getValueFromPropertyEditorManager(" + className + ".class, \"" + attrName + "\", " + quoted + ")"; } }
public void doTag(TagPluginContext ctxt) { boolean hasValue = false, hasVar = false, hasScope = false, hasTarget = false; String strScope; int iScope; hasValue = ctxt.isAttributeSpecified("value"); hasVar = ctxt.isAttributeSpecified("var"); hasScope = ctxt.isAttributeSpecified("scope"); hasTarget = ctxt.isAttributeSpecified("target"); String resultName = ctxt.getTemporaryVariableName(); String targetName = ctxt.getTemporaryVariableName(); String propertyName = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource("Object " + resultName + " = null;"); if (hasValue) { ctxt.generateJavaSource(resultName + " = "); ctxt.generateAttribute("value"); ctxt.generateJavaSource(";"); } else { ctxt.dontUseTagPlugin(); return; } if (hasScope) { strScope = ctxt.getConstantAttribute("scope"); } else { strScope = "page"; } iScope = Util.getScope(strScope); if (hasVar) { String strVar = ctxt.getConstantAttribute("var"); ctxt.generateJavaSource("if(null != " + resultName + "){"); ctxt.generateJavaSource(" pageContext.setAttribute(\"" + strVar + "\"," + resultName + "," + iScope + ");"); ctxt.generateJavaSource("} else {"); if (hasScope) { ctxt.generateJavaSource(" pageContext.removeAttribute(\"" + strVar + "\"," + iScope + ");"); } else { ctxt.generateJavaSource(" pageContext.removeAttribute(\"" + strVar + "\");"); } ctxt.generateJavaSource("}"); //else assign the result to the target.property } else if (hasTarget) { String pdName = ctxt.getTemporaryVariableName(); String successFlagName = ctxt.getTemporaryVariableName(); String index = ctxt.getTemporaryVariableName(); String methodName = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource("String " + propertyName + " = null;"); ctxt.generateJavaSource("if("); ctxt.generateAttribute("property"); ctxt.generateJavaSource(" != null){"); ctxt.generateJavaSource(" " + propertyName + " = ("); ctxt.generateAttribute("property"); ctxt.generateJavaSource(").toString();"); ctxt.generateJavaSource("}"); ctxt.generateJavaSource("Object " + targetName + " = "); ctxt.generateAttribute("target"); ctxt.generateJavaSource(";"); ctxt.generateJavaSource("if(" + targetName + " != null){"); ctxt.generateJavaSource(" if(" + targetName + " instanceof java.util.Map){"); ctxt.generateJavaSource(" if(null != " + resultName + "){"); ctxt.generateJavaSource(" ((java.util.Map) " + targetName + ").put(" + propertyName + "," + resultName + ");"); ctxt.generateJavaSource(" }else{"); ctxt.generateJavaSource(" ((java.util.Map) " + targetName + ").remove(" + propertyName + ");"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" }else{"); ctxt.generateJavaSource(" try{"); ctxt.generateJavaSource(" java.beans.PropertyDescriptor " + pdName + "[] = java.beans.Introspector.getBeanInfo(" + targetName + ".getClass()).getPropertyDescriptors();"); ctxt.generateJavaSource(" boolean " + successFlagName + " = false;"); ctxt.generateJavaSource(" for(int " + index + "=0;" + index + "<" + pdName + ".length;" + index + "++){"); ctxt.generateJavaSource(" if(" + pdName + "[" + index + "].getName().equals(" + propertyName + ")){"); ctxt.generateJavaSource(" java.lang.reflect.Method " + methodName + " = " + pdName + "[" + index + "].getWriteMethod();"); ctxt.generateJavaSource(" if(null == " + methodName + "){"); ctxt.generateJavaSource(" throw new JspException(\"No setter method in &lt;set&gt; for property \"+" + propertyName + ");"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" if(" + resultName + " != null){"); ctxt.generateJavaSource(" " + methodName + ".invoke(" + targetName + ", new Object[]{(" + methodName + ".getParameterTypes()[0]).cast(" + resultName + ")});"); ctxt.generateJavaSource(" }else{"); ctxt.generateJavaSource(" " + methodName + ".invoke(" + targetName + ", new Object[]{null});"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" " + successFlagName + " = true;"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" if(!" + successFlagName + "){"); ctxt.generateJavaSource(" throw new JspException(\"Invalid property in &lt;set&gt;:\"+" + propertyName + ");"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" catch (IllegalAccessException ex) {"); ctxt.generateJavaSource(" throw new JspException(ex);"); ctxt.generateJavaSource(" } catch (java.beans.IntrospectionException ex) {"); ctxt.generateJavaSource(" throw new JspException(ex);"); ctxt.generateJavaSource(" } catch (java.lang.reflect.InvocationTargetException ex) {"); ctxt.generateJavaSource(" if (ex.getCause() instanceof ThreadDeath) {"); ctxt.generateJavaSource(" throw (ThreadDeath) ex.getCause();"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" if (ex.getCause() instanceof VirtualMachineError) {"); ctxt.generateJavaSource(" throw (VirtualMachineError) ex.getCause();"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" throw new JspException(ex);"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource("}else{"); ctxt.generateJavaSource(" throw new JspException();"); ctxt.generateJavaSource("}"); } }	private Node.JspAttribute getNodeAttribute(String attribute) { Node.JspAttribute[] attrs = node.getJspAttributes(); for (int i = 0; attrs != null && i < attrs.length; i++) { if (attrs[i].getName().equals(attribute)) { return attrs[i]; } } return null; }	protected String[] generateJava() throws Exception { String[] smapStr = null; long t1, t2, t3, t4; t1 = t2 = t3 = t4 = 0; if (log.isDebugEnabled()) { t1 = System.currentTimeMillis(); } pageInfo = new PageInfo(new BeanRepository(ctxt.getClassLoader(), errDispatcher), ctxt.getJspFile()); JspConfig jspConfig = options.getJspConfig(); JspConfig.JspProperty jspProperty = jspConfig.findJspProperty(ctxt.getJspFile()); if (jspProperty.isELIgnored() != null) { pageInfo.setELIgnored(JspUtil.booleanValue(jspProperty.isELIgnored())); } if (jspProperty.isScriptingInvalid() != null) { pageInfo.setScriptingInvalid(JspUtil.booleanValue(jspProperty.isScriptingInvalid())); } if (jspProperty.getIncludePrelude() != null) { pageInfo.setIncludePrelude(jspProperty.getIncludePrelude()); } if (jspProperty.getIncludeCoda() != null) { pageInfo.setIncludeCoda(jspProperty.getIncludeCoda()); } if (jspProperty.isDeferedSyntaxAllowedAsLiteral() != null) { pageInfo.setDeferredSyntaxAllowedAsLiteral(JspUtil.booleanValue(jspProperty.isDeferedSyntaxAllowedAsLiteral())); } if (jspProperty.isTrimDirectiveWhitespaces() != null) { pageInfo.setTrimDirectiveWhitespaces(JspUtil.booleanValue(jspProperty.isTrimDirectiveWhitespaces())); } if (jspProperty.getBuffer() != null) { pageInfo.setBufferValue(jspProperty.getBuffer(), null, errDispatcher); } if (jspProperty.isErrorOnUndeclaredNamespace() != null) { pageInfo.setErrorOnUndeclaredNamespace(JspUtil.booleanValue(jspProperty.isErrorOnUndeclaredNamespace())); } if (ctxt.isTagFile()) { try { double libraryVersion = Double.parseDouble(ctxt.getTagInfo().getTagLibrary().getRequiredVersion()); if (libraryVersion < 2.0) { pageInfo.setIsELIgnored("true", null, errDispatcher, true); } if (libraryVersion < 2.1) { pageInfo.setDeferredSyntaxAllowedAsLiteral("true", null, errDispatcher, true); } } catch (NumberFormatException ex) { errDispatcher.jspError(ex); } } ctxt.checkOutputDir(); String javaFileName = ctxt.getServletJavaFileName(); ServletWriter writer = null; try { /* * The setting of isELIgnored changes the behaviour of the parser * in subtle ways. To add to the 'fun', isELIgnored can be set in * any file that forms part of the translation unit so setting it * in a file included towards the end of the translation unit can * change how the parser should have behaved when parsing content * up to the point where isELIgnored was set. Arghh! * Previous attempts to hack around this have only provided partial * solutions. We now use two passes to parse the translation unit. * The first just parses the directives and the second parses the * whole translation unit once we know how isELIgnored has been set. * TODO There are some possible optimisations of this process. */ ParserController parserCtl = new ParserController(ctxt, this); Node.Nodes directives = parserCtl.parseDirectives(ctxt.getJspFile()); Validator.validateDirectives(this, directives); pageNodes = parserCtl.parse(ctxt.getJspFile()); if (pageInfo.getContentType() == null && jspProperty.getDefaultContentType() != null) { pageInfo.setContentType(jspProperty.getDefaultContentType()); } if (ctxt.isPrototypeMode()) { writer = setupContextWriter(javaFileName); Generator.generate(writer, this, pageNodes); writer.close(); writer = null; return null; } // Validate and process attributes - don't re-validate the Validator.validateExDirectives(this, pageNodes); if (log.isDebugEnabled()) { t2 = System.currentTimeMillis(); } Collector.collect(this, pageNodes); // Compile (if necessary) and load the tag files referenced in tfp = new TagFileProcessor(); tfp.loadTagFiles(this, pageNodes); if (log.isDebugEnabled()) { t3 = System.currentTimeMillis(); } ScriptingVariabler.set(pageNodes, errDispatcher); TagPluginManager tagPluginManager = options.getTagPluginManager(); tagPluginManager.apply(pageNodes, errDispatcher, pageInfo); TextOptimizer.concatenate(this, pageNodes); ELFunctionMapper.map(pageNodes); writer = setupContextWriter(javaFileName); Generator.generate(writer, this, pageNodes); writer.close(); writer = null; // The writer is only used during the compile, dereference // it in the JspCompilationContext when done to allow it ctxt.setWriter(null); if (log.isDebugEnabled()) { t4 = System.currentTimeMillis(); log.debug("Generated " + javaFileName + " total=" + (t4 - t1) + " generate=" + (t4 - t3) + " validate=" + (t2 - t1)); } } catch (Exception e) { if (writer != null) { try { writer.close(); writer = null; } catch (Exception e1) { // do nothing } } File file = new File(javaFileName); if (file.exists()) { if (!file.delete()) { log.warn(Localizer.getMessage("jsp.warning.compiler.javafile.delete.fail", file.getAbsolutePath())); } } throw e; } finally { if (writer != null) { try { writer.close(); } catch (Exception e2) { // do nothing } } } if (!options.isSmapSuppressed()) { smapStr = SmapUtil.generateSmap(ctxt, pageNodes); } // If any proto type .java and .class files was generated, // the prototype .java may have been replaced by the current // compilation (if the tag file is self referencing), but the // .class file need to be removed, to make sure that javac would tfp.removeProtoTypeFiles(ctxt.getClassFileName()); return smapStr; }
protected void performBasicCheck() { Member[] members = super.getMembers(); for (int i = 0; members != null && i < members.length; i++) { if (membership.memberAlive((MemberImpl) members[i])) { if (memberAlive(members[i])) { log.warn("Member added, even though we werent notified:" + members[i]); super.memberAdded(members[i]); } else { membership.removeMember((MemberImpl) members[i]); } //end if } //end if } //for //check suspect members if they are still alive, MemberImpl[] keys = removeSuspects.keySet().toArray(new MemberImpl[removeSuspects.size()]); for (int i = 0; i < keys.length; i++) { MemberImpl m = keys[i]; if (membership.getMember(m) != null && (!memberAlive(m))) { membership.removeMember(m); super.memberDisappeared(m); removeSuspects.remove(m); if (log.isInfoEnabled()) log.info("Suspect member, confirmed dead.[" + m + "]"); } //end if } //check add suspects members if they are alive now, keys = addSuspects.keySet().toArray(new MemberImpl[addSuspects.size()]); for (int i = 0; i < keys.length; i++) { MemberImpl m = keys[i]; if (membership.getMember(m) == null && (memberAlive(m))) { membership.memberAlive(m); super.memberAdded(m); addSuspects.remove(m); if (log.isInfoEnabled()) log.info("Suspect member, confirmed alive.[" + m + "]"); } //end if } }	protected void performForcedCheck() { Member[] members = super.getMembers(); for (int i = 0; members != null && i < members.length; i++) { if (memberAlive(members[i])) { if (membership.memberAlive((MemberImpl) members[i])) super.memberAdded(members[i]); addSuspects.remove(members[i]); } else { if (membership.getMember(members[i]) != null) { membership.removeMember((MemberImpl) members[i]); removeSuspects.remove(members[i]); super.memberDisappeared(members[i]); } } //end if } //for }	@Override public void memberDisappeared(Member member) { if (membership == null) setupMembership(); boolean notify = false; boolean shutdown = Arrays.equals(member.getCommand(), Member.SHUTDOWN_PAYLOAD); if (!shutdown) if (log.isInfoEnabled()) log.info("Received memberDisappeared[" + member + "] message. Will verify."); synchronized (membership) { if (!membership.contains(member)) { if (log.isInfoEnabled()) log.info("Verification complete. Member already disappeared[" + member + "]"); return; } if (shutdown || !memberAlive(member)) { membership.removeMember((MemberImpl) member); removeSuspects.remove(member); notify = true; } else { removeSuspects.put(member, Long.valueOf(System.currentTimeMillis())); } } if (notify) { if (log.isInfoEnabled()) log.info("Verification complete. Member disappeared[" + member + "]"); super.memberDisappeared(member); } else { if (log.isInfoEnabled()) log.info("Verification complete. Member still alive[" + member + "]"); } }
protected void prepareRequest() { byte methodCode = requestHeaderMessage.getByte(); if (methodCode != Constants.SC_M_JK_STORED) { String methodName = Constants.getMethodForCode(methodCode - 1); request.method().setString(methodName); } requestHeaderMessage.getBytes(request.protocol()); requestHeaderMessage.getBytes(request.requestURI()); requestHeaderMessage.getBytes(request.remoteAddr()); requestHeaderMessage.getBytes(request.remoteHost()); requestHeaderMessage.getBytes(request.localName()); request.setLocalPort(requestHeaderMessage.getInt()); boolean isSSL = requestHeaderMessage.getByte() != 0; if (isSSL) { request.scheme().setString("https"); } MimeHeaders headers = request.getMimeHeaders(); headers.setLimit(endpoint.getMaxHeaderCount()); int hCount = requestHeaderMessage.getInt(); for (int i = 0; i < hCount; i++) { String hName = null; // Header names are encoded as either an integer code starting // with 0xA0, or as a normal string (in which case the first int isc = requestHeaderMessage.peekInt(); int hId = isc & 0xFF; MessageBytes vMB = null; isc &= 0xFF00; if (0xA000 == isc) { requestHeaderMessage.getInt(); hName = Constants.getHeaderForCode(hId - 1); vMB = headers.addValue(hName); } else { // reset hId -- if the header currently being read // happens to be 7 or 8 bytes long, the code below // will think it's the content-type header or the // content-length header - SC_REQ_CONTENT_TYPE=7, // SC_REQ_CONTENT_LENGTH=8 - leading to unexpected hId = -1; requestHeaderMessage.getBytes(tmpMB); ByteChunk bc = tmpMB.getByteChunk(); vMB = headers.addValue(bc.getBuffer(), bc.getStart(), bc.getLength()); } requestHeaderMessage.getBytes(vMB); if (hId == Constants.SC_REQ_CONTENT_LENGTH || (hId == -1 && tmpMB.equalsIgnoreCase("Content-Length"))) { long cl = vMB.getLong(); if (cl < Integer.MAX_VALUE) request.setContentLength((int) cl); } else if (hId == Constants.SC_REQ_CONTENT_TYPE || (hId == -1 && tmpMB.equalsIgnoreCase("Content-Type"))) { ByteChunk bchunk = vMB.getByteChunk(); request.contentType().setBytes(bchunk.getBytes(), bchunk.getOffset(), bchunk.getLength()); } } boolean secret = false; byte attributeCode; while ((attributeCode = requestHeaderMessage.getByte()) != Constants.SC_A_ARE_DONE) { switch(attributeCode) { case Constants.SC_A_REQ_ATTRIBUTE: requestHeaderMessage.getBytes(tmpMB); String n = tmpMB.toString(); requestHeaderMessage.getBytes(tmpMB); String v = tmpMB.toString(); if (n.equals(Constants.SC_A_REQ_REMOTE_PORT)) { try { request.setRemotePort(Integer.parseInt(v)); } catch (NumberFormatException nfe) { // Ignore invalid value } } else { request.setAttribute(n, v); } break; case Constants.SC_A_CONTEXT: requestHeaderMessage.getBytes(tmpMB); break; case Constants.SC_A_SERVLET_PATH: requestHeaderMessage.getBytes(tmpMB); break; case Constants.SC_A_REMOTE_USER: if (tomcatAuthentication) { requestHeaderMessage.getBytes(tmpMB); } else { requestHeaderMessage.getBytes(request.getRemoteUser()); } break; case Constants.SC_A_AUTH_TYPE: if (tomcatAuthentication) { requestHeaderMessage.getBytes(tmpMB); } else { requestHeaderMessage.getBytes(request.getAuthType()); } break; case Constants.SC_A_QUERY_STRING: requestHeaderMessage.getBytes(request.queryString()); break; case Constants.SC_A_JVM_ROUTE: requestHeaderMessage.getBytes(request.instanceId()); break; case Constants.SC_A_SSL_CERT: request.scheme().setString("https"); requestHeaderMessage.getBytes(certificates); break; case Constants.SC_A_SSL_CIPHER: request.scheme().setString("https"); requestHeaderMessage.getBytes(tmpMB); request.setAttribute(SSLSupport.CIPHER_SUITE_KEY, tmpMB.toString()); break; case Constants.SC_A_SSL_SESSION: request.scheme().setString("https"); requestHeaderMessage.getBytes(tmpMB); request.setAttribute(SSLSupport.SESSION_ID_KEY, tmpMB.toString()); break; case Constants.SC_A_SSL_KEY_SIZE: request.setAttribute(SSLSupport.KEY_SIZE_KEY, Integer.valueOf(requestHeaderMessage.getInt())); break; case Constants.SC_A_STORED_METHOD: requestHeaderMessage.getBytes(request.method()); break; case Constants.SC_A_SECRET: requestHeaderMessage.getBytes(tmpMB); if (requiredSecret != null) { secret = true; if (!tmpMB.equals(requiredSecret)) { response.setStatus(403); error = true; } } break; default: break; } } if ((requiredSecret != null) && !secret) { response.setStatus(403); error = true; } ByteChunk uriBC = request.requestURI().getByteChunk(); if (uriBC.startsWithIgnoreCase("http", 0)) { int pos = uriBC.indexOf("://", 0, 3, 4); int uriBCStart = uriBC.getStart(); int slashPos = -1; if (pos != -1) { byte[] uriB = uriBC.getBytes(); slashPos = uriBC.indexOf('/', pos + 3); if (slashPos == -1) { slashPos = uriBC.getLength(); request.requestURI().setBytes(uriB, uriBCStart + pos + 1, 1); } else { request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos); } MessageBytes hostMB = headers.setValue("host"); hostMB.setBytes(uriB, uriBCStart + pos + 3, slashPos - pos - 3); } } MessageBytes valueMB = request.getMimeHeaders().getValue("host"); parseHost(valueMB); if (error) { getAdapter().log(request, response, 0); } }
protected AccessLogElement[] createLogElements() { List<AccessLogElement> list = new ArrayList<>(); boolean replace = false; StringBuilder buf = new StringBuilder(); for (int i = 0; i < pattern.length(); i++) { char ch = pattern.charAt(i); if (replace) { if ('{' == ch) { StringBuilder name = new StringBuilder(); int j = i + 1; for (; j < pattern.length() && '}' != pattern.charAt(j); j++) { name.append(pattern.charAt(j)); } if (j + 1 < pattern.length()) { j++; list.add(createAccessLogElement(name.toString(), pattern.charAt(j))); i = j; /* Since we walked more than one character */ } else { // D'oh - end of string - pretend we never did this list.add(createAccessLogElement(ch)); } } else { list.add(createAccessLogElement(ch)); } replace = false; } else if (ch == '%') { replace = true; list.add(new StringElement(buf.toString())); buf = new StringBuilder(); } else { buf.append(ch); } } if (buf.length() > 0) { list.add(new StringElement(buf.toString())); } return list.toArray(new AccessLogElement[0]); }
Mark skipUntil(String limit) throws JasperException { Mark ret = mark(); int limlen = limit.length(); char firstChar = limit.charAt(0); Boolean result = null; Mark restart = null; skip: while ((result = indexOf(firstChar, ret)) != null) { if (result.booleanValue()) { if (restart != null) { restart.init(current, singleFile); } else { restart = mark(); } for (int i = 1; i < limlen; i++) { if (peekChar() == limit.charAt(i)) { nextChar(); } else { setCurrent(restart); continue skip; } } return ret; } } return null; }
@Override public final NamingEnumeration<Binding> listBindings(String name) throws NamingException { if (!aliases.isEmpty()) { AliasResult result = findAlias(name); if (result.dirContext != null) { return result.dirContext.listBindings(result.aliasName); } } List<NamingEntry> bindings = doListBindings(name); List<NamingEntry> altBindings = null; for (DirContext altDirContext : altDirContexts) { if (altDirContext instanceof BaseDirContext) { altBindings = ((BaseDirContext) altDirContext).doListBindings("/META-INF/resources" + name); } if (altBindings != null) { if (bindings == null) { bindings = altBindings; } else { bindings.addAll(altBindings); } } } if (bindings != null) { return new NamingContextBindingsEnumeration(bindings.iterator(), this); } throw new NameNotFoundException(sm.getString("resources.notFound", name)); }	@Override protected List<NamingEntry> doListBindings(String name) throws NamingException { File file = file(name); if (file == null) return null; return list(file); }	@Override protected List<NamingEntry> doListBindings(String strName) throws NamingException { Name name = getEscapedJndiName(strName); if (name.isEmpty()) return list(entries); Entry entry = treeLookup(name); if (entry == null) return null; return list(entry); }
public static void initWebappDefaults(Context ctx) { Wrapper servlet = addServlet(ctx, "default", "org.apache.catalina.servlets.DefaultServlet"); servlet.setLoadOnStartup(1); servlet = addServlet(ctx, "jsp", "org.apache.jasper.servlet.JspServlet"); servlet.addInitParameter("fork", "false"); servlet.setLoadOnStartup(3); ctx.addServletMapping("/", "default"); ctx.addServletMapping("*.jsp", "jsp"); ctx.addServletMapping("*.jspx", "jsp"); ctx.setSessionTimeout(30); for (int i = 0; i < DEFAULT_MIME_MAPPINGS.length; ) { ctx.addMimeMapping(DEFAULT_MIME_MAPPINGS[i++], DEFAULT_MIME_MAPPINGS[i++]); } ctx.addWelcomeFile("index.html"); ctx.addWelcomeFile("index.htm"); ctx.addWelcomeFile("index.jsp"); }
protected synchronized void checkResources(DeployedApplication app) { String[] resources = app.redeployResources.keySet().toArray(new String[0]); for (int i = 0; i < resources.length; i++) { File resource = new File(resources[i]); if (log.isDebugEnabled()) log.debug("Checking context[" + app.name + "] redeploy resource " + resource); if (resource.exists()) { long lastModified = app.redeployResources.get(resources[i]).longValue(); if ((!resource.isDirectory()) && resource.lastModified() > lastModified) { if (log.isInfoEnabled()) log.info(sm.getString("hostConfig.undeploy", app.name)); Container context = host.findChild(app.name); try { host.removeChild(context); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.warn(sm.getString("hostConfig.context.remove", app.name), t); } for (int j = i + 1; j < resources.length; j++) { try { File current = new File(resources[j]); current = current.getCanonicalFile(); if (Constants.HostContextXml.equals(current.getName())) { continue; } if ((current.getAbsolutePath().startsWith(host.getAppBaseFile().getAbsolutePath() + File.separator)) || (current.getAbsolutePath().startsWith(host.getConfigBaseFile().getAbsolutePath()))) { if (log.isDebugEnabled()) log.debug("Delete " + current); ExpandWar.delete(current); } } catch (IOException e) { log.warn(sm.getString("hostConfig.canonicalizing", app.name), e); } } deployed.remove(app.name); return; } } else { try { Thread.sleep(500); } catch (InterruptedException e1) { // Ignore } if (resource.exists()) { continue; } long lastModified = app.redeployResources.get(resources[i]).longValue(); if (lastModified == 0L) { continue; } if (log.isInfoEnabled()) log.info(sm.getString("hostConfig.undeploy", app.name)); Container context = host.findChild(app.name); try { host.removeChild(context); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.warn(sm.getString("hostConfig.context.remove", app.name), t); } for (int j = i + 1; j < resources.length; j++) { try { File current = new File(resources[j]); current = current.getCanonicalFile(); if (Constants.HostContextXml.equals(current.getName())) { continue; } if ((current.getAbsolutePath().startsWith(host.getAppBaseFile().getAbsolutePath() + File.separator)) || (current.getAbsolutePath().startsWith(host.getConfigBaseFile().getAbsolutePath()))) { if (log.isDebugEnabled()) log.debug("Delete " + current); ExpandWar.delete(current); } } catch (IOException e) { log.warn(sm.getString("hostConfig.canonicalizing", app.name), e); } } // Delete reload resources as well (to remove any remaining .xml String[] resources2 = app.reloadResources.keySet().toArray(new String[0]); for (int j = 0; j < resources2.length; j++) { try { File current = new File(resources2[j]); current = current.getCanonicalFile(); if (Constants.HostContextXml.equals(current.getName())) { continue; } if ((current.getAbsolutePath().startsWith(host.getAppBaseFile().getAbsolutePath() + File.separator)) || ((current.getAbsolutePath().startsWith(host.getConfigBaseFile().getAbsolutePath()) && (current.getAbsolutePath().endsWith(".xml"))))) { if (log.isDebugEnabled()) log.debug("Delete " + current); ExpandWar.delete(current); } } catch (IOException e) { log.warn(sm.getString("hostConfig.canonicalizing", app.name), e); } } deployed.remove(app.name); return; } } resources = app.reloadResources.keySet().toArray(new String[0]); for (int i = 0; i < resources.length; i++) { File resource = new File(resources[i]); if (log.isDebugEnabled()) log.debug("Checking context[" + app.name + "] reload resource " + resource); long lastModified = app.reloadResources.get(resources[i]).longValue(); if ((!resource.exists() && lastModified != 0L) || (resource.lastModified() != lastModified)) { if (log.isInfoEnabled()) log.info(sm.getString("hostConfig.reload", app.name)); Context context = (Context) host.findChild(app.name); if (context.getState().isAvailable()) { context.reload(); } else { try { context.start(); } catch (Exception e) { log.warn(sm.getString("hostConfig.context.restart", app.name), e); } } app.reloadResources.put(resources[i], Long.valueOf(resource.lastModified())); app.timestamp = System.currentTimeMillis(); return; } } }	protected void check() { if (host.getAutoDeploy()) { DeployedApplication[] apps = deployed.values().toArray(new DeployedApplication[0]); for (int i = 0; i < apps.length; i++) { if (!isServiced(apps[i].name)) checkResources(apps[i]); } deployApps(); } }	public void check(String name) { DeployedApplication app = deployed.get(name); if (app != null) { checkResources(app); } else { deployApps(name); } }
Mark mark() { return new Mark(current); }	Mark skipUntil(String limit) throws JasperException { Mark ret = null; int limlen = limit.length(); int ch; skip: for (ret = mark(), ch = nextChar(); ch != -1; ret = mark(), ch = nextChar()) { if (ch == limit.charAt(0)) { Mark restart = mark(); for (int i = 1; i < limlen; i++) { if (peekChar() == limit.charAt(i)) nextChar(); else { reset(restart); continue skip; } } return ret; } } return null; }	Mark skipUntilIgnoreEsc(String limit) throws JasperException { Mark ret = null; int limlen = limit.length(); int ch; int prev = 'x'; skip: for (ret = mark(), ch = nextChar(); ch != -1; ret = mark(), prev = ch, ch = nextChar()) { if (ch == '\\' && prev == '\\') { ch = 0; } } }	String getText(Mark start, Mark stop) throws JasperException { Mark oldstart = mark(); reset(start); CharArrayWriter caw = new CharArrayWriter(); while (!stop.equals(mark())) caw.write(nextChar()); caw.close(); reset(oldstart); return caw.toString(); }	boolean matches(String string) throws JasperException { Mark mark = mark(); int ch = 0; int i = 0; do { ch = nextChar(); if (((char) ch) != string.charAt(i++)) { reset(mark); return false; } } while (i < string.length()); return true; }	boolean matchesETag(String tagName) throws JasperException { Mark mark = mark(); if (!matches("</" + tagName)) return false; skipSpaces(); if (nextChar() == '>') return true; reset(mark); return false; }	boolean matchesETagWithoutLessThan(String tagName) throws JasperException { Mark mark = mark(); if (!matches("/" + tagName)) return false; skipSpaces(); if (nextChar() == '>') return true; reset(mark); return false; }	boolean matchesOptionalSpacesFollowedBy(String s) throws JasperException { Mark mark = mark(); skipSpaces(); boolean result = matches(s); if (!result) { reset(mark); } return result; }	int nextChar() throws JasperException { if (!hasMoreInput()) return -1; int ch = current.stream[current.cursor]; current.cursor++; if (ch == '\n') { current.line++; current.col = 0; } else { current.col++; } return ch; }	private boolean isDelimiter() throws JasperException { if (!isSpace()) { int ch = peekChar(); if (ch == '=' || ch == '>' || ch == '"' || ch == '\'' || ch == '/') { return true; } if (ch == '-') { Mark mark = mark(); if (((ch = nextChar()) == '>') || ((ch == '-') && (nextChar() == '>'))) { reset(mark); return true; } else { reset(mark); return false; } } return false; } else { return true; } }	void reset(Mark mark) { current = new Mark(mark); }
private void closeOutboundConnection(WsFrame frame) throws IOException { try { getWsOutbound().close(frame); } finally { doOnClose(Constants.OPCODE_CLOSE); } }
private SecurityConstraint[] resultsToArray(ArrayList<SecurityConstraint> results) { if (results == null) { return null; } SecurityConstraint[] array = new SecurityConstraint[results.size()]; results.toArray(array); return array; }
protected List<NamingEntry> list(File file) { List<NamingEntry> entries = new ArrayList<NamingEntry>(); if (!file.isDirectory()) return entries; String[] names = file.list(); if (names == null) { log.warn(sm.getString("fileResources.listingNull", file.getAbsolutePath())); return entries; } Arrays.sort(names); NamingEntry entry = null; for (int i = 0; i < names.length; i++) { File currentFile = new File(file, names[i]); Object object = null; if (currentFile.isDirectory()) { FileDirContext tempContext = new FileDirContext(env); tempContext.setDocBase(file.getPath()); tempContext.setAllowLinking(getAllowLinking()); object = tempContext; } else { object = new FileResource(currentFile); } entry = new NamingEntry(names[i], object, NamingEntry.ENTRY); entries.add(entry); } return entries; }
protected void list(HttpServletRequest request, HttpServletResponse response, String message, StringManager smClient) throws IOException { if (debug >= 1) log("list: Listing contexts for virtual host '" + host.getName() + "'"); PrintWriter writer = response.getWriter(); writer.print(Constants.HTML_HEADER_SECTION); Object[] args = new Object[2]; args[0] = request.getContextPath(); args[1] = smClient.getString("htmlManagerServlet.title"); writer.print(MessageFormat.format(Constants.BODY_HEADER_SECTION, args)); args = new Object[3]; args[0] = smClient.getString("htmlManagerServlet.messageLabel"); if (message == null || message.length() == 0) { args[1] = "OK"; } else { args[1] = RequestUtil.filter(message); } writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args)); args = new Object[9]; args[0] = smClient.getString("htmlManagerServlet.manager"); args[1] = response.encodeURL(request.getContextPath() + "/html/list"); args[2] = smClient.getString("htmlManagerServlet.list"); args[3] = response.encodeURL(request.getContextPath() + "/" + smClient.getString("htmlManagerServlet.helpHtmlManagerFile")); args[4] = smClient.getString("htmlManagerServlet.helpHtmlManager"); args[5] = response.encodeURL(request.getContextPath() + "/" + smClient.getString("htmlManagerServlet.helpManagerFile")); args[6] = smClient.getString("htmlManagerServlet.helpManager"); args[7] = response.encodeURL(request.getContextPath() + "/status"); args[8] = smClient.getString("statusServlet.title"); writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args)); args = new Object[7]; args[0] = smClient.getString("htmlManagerServlet.appsTitle"); args[1] = smClient.getString("htmlManagerServlet.appsPath"); args[2] = smClient.getString("htmlManagerServlet.appsVersion"); args[3] = smClient.getString("htmlManagerServlet.appsName"); args[4] = smClient.getString("htmlManagerServlet.appsAvailable"); args[5] = smClient.getString("htmlManagerServlet.appsSessions"); args[6] = smClient.getString("htmlManagerServlet.appsTasks"); writer.print(MessageFormat.format(APPS_HEADER_SECTION, args)); // Apps Row Section Container[] children = host.findChildren(); String[] contextNames = new String[children.length]; for (int i = 0; i < children.length; i++) contextNames[i] = children[i].getName(); Arrays.sort(contextNames); String appsStart = smClient.getString("htmlManagerServlet.appsStart"); String appsStop = smClient.getString("htmlManagerServlet.appsStop"); String appsReload = smClient.getString("htmlManagerServlet.appsReload"); String appsUndeploy = smClient.getString("htmlManagerServlet.appsUndeploy"); String appsExpire = smClient.getString("htmlManagerServlet.appsExpire"); String noVersion = "<i>" + smClient.getString("htmlManagerServlet.noVersion") + "</i>"; boolean isHighlighted = true; boolean isDeployed = true; String highlightColor = null; for (String contextName : contextNames) { Context ctxt = (Context) host.findChild(contextName); if (ctxt != null) { isHighlighted = !isHighlighted; if (isHighlighted) { highlightColor = "#C3F3C3"; } else { highlightColor = "#FFFFFF"; } String contextPath = ctxt.getPath(); String displayPath = contextPath; if (displayPath.equals("")) { displayPath = "/"; } StringBuilder tmp = new StringBuilder(); tmp.append("path="); tmp.append(URL_ENCODER.encode(displayPath)); if (ctxt.getWebappVersion().length() > 0) { tmp.append("&version="); tmp.append(URL_ENCODER.encode(ctxt.getWebappVersion())); } String pathVersion = tmp.toString(); try { isDeployed = isDeployed(contextName); } catch (Exception e) { isDeployed = false; } args = new Object[7]; args[0] = "<a href=\"" + URL_ENCODER.encode(displayPath) + "\">" + RequestUtil.filter(displayPath) + "</a>"; if ("".equals(ctxt.getWebappVersion())) { args[1] = noVersion; } else { args[1] = RequestUtil.filter(ctxt.getWebappVersion()); } if (ctxt.getDisplayName() == null) { args[2] = "&nbsp;"; } else { args[2] = RequestUtil.filter(ctxt.getDisplayName()); } args[3] = Boolean.valueOf(ctxt.getAvailable()); args[4] = RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/sessions?" + pathVersion)); Manager manager = ctxt.getManager(); if (manager instanceof DistributedManager && showProxySessions) { args[5] = Integer.valueOf(((DistributedManager) manager).getActiveSessionsFull()); } else if (ctxt.getManager() != null) { args[5] = Integer.valueOf(manager.getActiveSessions()); } else { args[5] = Integer.valueOf(0); } args[6] = highlightColor; writer.print(MessageFormat.format(APPS_ROW_DETAILS_SECTION, args)); args = new Object[14]; args[0] = RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/start?" + pathVersion)); args[1] = appsStart; args[2] = RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/stop?" + pathVersion)); args[3] = appsStop; args[4] = RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/reload?" + pathVersion)); args[5] = appsReload; args[6] = RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/undeploy?" + pathVersion)); args[7] = appsUndeploy; args[8] = RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/expire?" + pathVersion)); args[9] = appsExpire; args[10] = smClient.getString("htmlManagerServlet.expire.explain"); if (manager == null) { args[11] = smClient.getString("htmlManagerServlet.noManager"); } else { args[11] = Integer.valueOf(ctxt.getManager().getMaxInactiveInterval() / 60); } args[12] = smClient.getString("htmlManagerServlet.expire.unit"); args[13] = highlightColor; if (ctxt.getName().equals(this.context.getName())) { writer.print(MessageFormat.format(MANAGER_APP_ROW_BUTTON_SECTION, args)); } else if (ctxt.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STARTED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (ctxt.getAvailable() && !isDeployed) { writer.print(MessageFormat.format(STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (!ctxt.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STOPPED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else { writer.print(MessageFormat.format(STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } } } args = new Object[7]; args[0] = smClient.getString("htmlManagerServlet.deployTitle"); args[1] = smClient.getString("htmlManagerServlet.deployServer"); args[2] = response.encodeURL(request.getContextPath() + "/html/deploy"); args[3] = smClient.getString("htmlManagerServlet.deployPath"); args[4] = smClient.getString("htmlManagerServlet.deployConfig"); args[5] = smClient.getString("htmlManagerServlet.deployWar"); args[6] = smClient.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(DEPLOY_SECTION, args)); args = new Object[4]; args[0] = smClient.getString("htmlManagerServlet.deployUpload"); args[1] = response.encodeURL(request.getContextPath() + "/html/upload"); args[2] = smClient.getString("htmlManagerServlet.deployUploadFile"); args[3] = smClient.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(UPLOAD_SECTION, args)); args = new Object[5]; args[0] = smClient.getString("htmlManagerServlet.diagnosticsTitle"); args[1] = smClient.getString("htmlManagerServlet.diagnosticsLeak"); args[2] = response.encodeURL(request.getContextPath() + "/html/findleaks"); args[3] = smClient.getString("htmlManagerServlet.diagnosticsLeakWarning"); args[4] = smClient.getString("htmlManagerServlet.diagnosticsLeakButton"); writer.print(MessageFormat.format(DIAGNOSTICS_SECTION, args)); args = new Object[9]; args[0] = smClient.getString("htmlManagerServlet.serverTitle"); args[1] = smClient.getString("htmlManagerServlet.serverVersion"); args[2] = smClient.getString("htmlManagerServlet.serverJVMVersion"); args[3] = smClient.getString("htmlManagerServlet.serverJVMVendor"); args[4] = smClient.getString("htmlManagerServlet.serverOSName"); args[5] = smClient.getString("htmlManagerServlet.serverOSVersion"); args[6] = smClient.getString("htmlManagerServlet.serverOSArch"); args[7] = sm.getString("htmlManagerServlet.serverHostname"); args[8] = sm.getString("htmlManagerServlet.serverIPAddress"); writer.print(MessageFormat.format(Constants.SERVER_HEADER_SECTION, args)); args = new Object[8]; args[0] = ServerInfo.getServerInfo(); args[1] = System.getProperty("java.runtime.version"); args[2] = System.getProperty("java.vm.vendor"); args[3] = System.getProperty("os.name"); args[4] = System.getProperty("os.version"); args[5] = System.getProperty("os.arch"); try { InetAddress address = InetAddress.getLocalHost(); args[6] = address.getHostName(); args[7] = address.getHostAddress(); } catch (UnknownHostException e) { args[6] = "-"; args[7] = "-"; } writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args)); writer.print(Constants.HTML_TAIL_SECTION); writer.flush(); writer.close(); }
protected boolean parseChunkHeader() throws IOException { int result = 0; boolean eol = false; boolean readDigit = false; boolean trailer = false; while (!eol) { if (pos >= lastValid) { if (readBytes() <= 0) return false; } if (buf[pos] == Constants.CR) { // FIXME: Improve parsing to check for CRLF } else if (buf[pos] == Constants.LF) { eol = true; } else if (buf[pos] == Constants.SEMI_COLON) { trailer = true; } else if (!trailer) { if (HexUtils.getDec(buf[pos]) != -1) { readDigit = true; result *= 16; result += HexUtils.getDec(buf[pos]); } else { return false; } } pos++; } if (!readDigit) return false; if (result == 0) endChunk = true; remaining = result; if (remaining < 0) return false; return true; }	public static int getDec(int index) { return DEC[index]; }
protected void processResourceJARs(Set<WebXml> fragments) { for (WebXml fragment : fragments) { URL url = fragment.getURL(); Jar jar = null; try { if ("jar".equals(url.getProtocol())) { jar = JarFactory.newInstance(url); if (jar.entryExists("META-INF/resources/")) { context.addResourceJarUrl(url); } } else if ("file".equals(url.getProtocol())) { FileDirContext fileDirContext = new FileDirContext(); fileDirContext.setDocBase(new File(url.toURI()).getAbsolutePath()); try { fileDirContext.lookup("META-INF/resources/"); if (context instanceof StandardContext) { ((StandardContext) context).addResourcesDirContext(fileDirContext); } } catch (NamingException e) { //not found, ignore } } } catch (IOException ioe) { log.error(sm.getString("contextConfig.resourceJarFail", url, context.getName())); } catch (URISyntaxException e) { log.error(sm.getString("contextConfig.resourceJarFail", url, context.getName())); } finally { if (jar != null) { jar.close(); } } } }
@Override public void addMappingForServletNames(EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter, String... servletNames) { FilterMap filterMap = new FilterMap(); filterMap.setFilterName(filterDef.getFilterName()); if (dispatcherTypes != null) { for (DispatcherType dispatcherType : dispatcherTypes) { filterMap.setDispatcher(dispatcherType.name()); } } if (servletNames != null) { for (String servletName : servletNames) { filterMap.addServletName(servletName); } if (isMatchAfter) { context.addFilterMapBefore(filterMap); } else { context.addFilterMap(filterMap); } } // else error? }	@Override public Collection<String> getUrlPatternMappings() { Collection<String> result = new HashSet<>(); FilterMap[] filterMaps = context.findFilterMaps(); for (FilterMap filterMap : filterMaps) { if (filterMap.getFilterName().equals(filterDef.getFilterName())) { for (String urlPattern : filterMap.getURLPatterns()) { result.add(urlPattern); } } } return result; }
@Override protected void deflate() throws IOException { int len; do { len = def.deflate(buf, 0, buf.length); if (len > 0) { out.write(buf, 0, len); } } while (len != 0); }
private static Digester createTldDigester(boolean namespaceAware, boolean validation) { Digester digester = null; if (!namespaceAware && !validation) { if (tldDigesters[0] == null) { tldDigesters[0] = DigesterFactory.newDigester(validation, namespaceAware, new TldRuleSet()); tldDigesters[0].getParser(); } digester = tldDigesters[0]; } else if (!namespaceAware && validation) { if (tldDigesters[1] == null) { tldDigesters[1] = DigesterFactory.newDigester(validation, namespaceAware, new TldRuleSet()); tldDigesters[1].getParser(); } digester = tldDigesters[1]; } else if (namespaceAware && !validation) { if (tldDigesters[2] == null) { tldDigesters[2] = DigesterFactory.newDigester(validation, namespaceAware, new TldRuleSet()); tldDigesters[2].getParser(); } digester = tldDigesters[2]; } else { if (tldDigesters[3] == null) { tldDigesters[3] = DigesterFactory.newDigester(validation, namespaceAware, new TldRuleSet()); tldDigesters[3].getParser(); } digester = tldDigesters[3]; } return digester; }	protected Map<String, WebXml> processJarsForWebFragments() { JarScanner jarScanner = context.getJarScanner(); FragmentJarScannerCallback callback = new FragmentJarScannerCallback(); jarScanner.scan(context.getServletContext(), context.getLoader().getClassLoader(), callback, null); return callback.getFragments(); }	public boolean isKnownWebxmlTaglibUri(String uri) { return webxmlTaglibUris.contains(uri); }	public static void setNoTldJars(String jarNames) { if (jarNames == null) { noTldJars = null; } else { if (noTldJars == null) { noTldJars = new HashSet<String>(); } else { noTldJars.clear(); } StringTokenizer tokenizer = new StringTokenizer(jarNames, ","); while (tokenizer.hasMoreElements()) { noTldJars.add(tokenizer.nextToken()); } } }
@Override public final void recycle(boolean isSocketClosing) { if (getInputBuffer() != null) { getInputBuffer().recycle(); } if (getOutputBuffer() != null) { getOutputBuffer().recycle(); } if (asyncStateMachine != null) { asyncStateMachine.recycle(); } upgradeInbound = null; remoteAddr = null; remoteHost = null; localAddr = null; localName = null; remotePort = -1; localPort = -1; recycleInternal(); }	@Override public void recycleInternal() { socket = null; comet = false; sendfileData = null; wantOnWritePossible = false; }
@Override public Collection<String> getUrlPatterns() { Collection<String> result = new HashSet<>(); if (jspPropertyGroup.getUrlPattern() != null) { result.add(jspPropertyGroup.getUrlPattern()); } return result; }	public String toXml() { StringBuilder sb = new StringBuilder(2048); // TODO - Various, icon, description etc elements are skipped - mainly // because they are ignored when web.xml is parsed - see above sb.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"); sb.append("<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"); sb.append(" xmlns:xsi="); sb.append("\"http://www.w3.org/2001/XMLSchema-instance\"\n"); sb.append(" xsi:schemaLocation="); sb.append("\"http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"); sb.append(" version=\""); sb.append(getVersion()); sb.append("\"\n"); sb.append(" metadata-complete=\"true\">\n\n"); appendElement(sb, INDENT2, "display-name", displayName); if (isDistributable()) { sb.append(" <distributable/>\n\n"); } for (Map.Entry<String, String> entry : contextParams.entrySet()) { sb.append(" <context-param>\n"); appendElement(sb, INDENT4, "param-name", entry.getKey()); appendElement(sb, INDENT4, "param-valuee", entry.getValue()); sb.append(" </context-param>\n"); } sb.append('\n'); for (Map.Entry<String, FilterDef> entry : filters.entrySet()) { FilterDef filterDef = entry.getValue(); sb.append(" <filter>\n"); appendElement(sb, INDENT4, "description", filterDef.getDescription()); appendElement(sb, INDENT4, "display-name", filterDef.getDisplayName()); appendElement(sb, INDENT4, "filter-name", filterDef.getFilterName()); appendElement(sb, INDENT4, "filter-class", filterDef.getFilterClass()); appendElement(sb, INDENT4, "async-supported", filterDef.getAsyncSupported()); for (Map.Entry<String, String> param : filterDef.getParameterMap().entrySet()) { sb.append(" <init-param>\n"); appendElement(sb, INDENT6, "param-name", param.getKey()); appendElement(sb, INDENT6, "param-value", param.getValue()); sb.append(" </init-param>\n"); } sb.append(" </filter>\n"); } sb.append('\n'); for (FilterMap filterMap : filterMaps) { sb.append(" <filter-mapping>\n"); appendElement(sb, INDENT4, "filter-name", filterMap.getFilterName()); if (filterMap.getMatchAllServletNames()) { sb.append(" <servlet-name>*</servlet-name>\n"); } else { for (String servletName : filterMap.getServletNames()) { appendElement(sb, INDENT4, "servlet-name", servletName); } } if (filterMap.getMatchAllUrlPatterns()) { sb.append(" <url-pattern>*</url-pattern>\n"); } else { for (String urlPattern : filterMap.getURLPatterns()) { appendElement(sb, INDENT4, "url-pattern", urlPattern); } } for (String dispatcher : filterMap.getDispatcherNames()) { appendElement(sb, INDENT4, "dispatcher", dispatcher); } sb.append(" </filter-mapping>\n"); } sb.append('\n'); for (String listener : listeners) { sb.append(" <listener>\n"); appendElement(sb, INDENT4, "listener-class", listener); sb.append(" </listener>\n"); } sb.append('\n'); for (Map.Entry<String, ServletDef> entry : servlets.entrySet()) { ServletDef servletDef = entry.getValue(); sb.append(" <servlet>\n"); appendElement(sb, INDENT4, "description", servletDef.getDescription()); appendElement(sb, INDENT4, "display-name", servletDef.getDisplayName()); appendElement(sb, INDENT4, "servlet-name", entry.getKey()); appendElement(sb, INDENT4, "servlet-class", servletDef.getServletClass()); appendElement(sb, INDENT4, "jsp-file", servletDef.getJspFile()); for (Map.Entry<String, String> param : servletDef.getParameterMap().entrySet()) { sb.append(" <init-param>\n"); appendElement(sb, INDENT6, "param-name", param.getKey()); appendElement(sb, INDENT6, "param-value", param.getValue()); sb.append(" </init-param>\n"); } appendElement(sb, INDENT4, "load-on-startup", servletDef.getLoadOnStartup()); appendElement(sb, INDENT4, "enabled", servletDef.getEnabled()); appendElement(sb, INDENT4, "async-supported", servletDef.getAsyncSupported()); if (servletDef.getRunAs() != null) { sb.append(" <run-as>\n"); appendElement(sb, INDENT6, "role-name", servletDef.getRunAs()); sb.append(" </run-as>\n"); } for (SecurityRoleRef roleRef : servletDef.getSecurityRoleRefs()) { sb.append(" <security-role-ref>\n"); appendElement(sb, INDENT6, "role-name", roleRef.getName()); appendElement(sb, INDENT6, "role-link", roleRef.getLink()); sb.append(" </security-role-ref>\n"); } MultipartDef multipartDef = servletDef.getMultipartDef(); if (multipartDef != null) { sb.append(" <multipart-config>\n"); appendElement(sb, INDENT6, "location", multipartDef.getLocation()); appendElement(sb, INDENT6, "max-file-size", multipartDef.getMaxFileSize()); appendElement(sb, INDENT6, "max-request-size", multipartDef.getMaxRequestSize()); appendElement(sb, INDENT6, "file-size-threshold", multipartDef.getFileSizeThreshold()); sb.append(" </multipart-config>\n"); } sb.append(" </servlet>\n"); } sb.append('\n'); for (Map.Entry<String, String> entry : servletMappings.entrySet()) { sb.append(" <servlet-mapping>\n"); appendElement(sb, INDENT4, "servlet-name", entry.getValue()); appendElement(sb, INDENT4, "url-pattern", entry.getKey()); sb.append(" </servlet-mapping>\n"); } sb.append('\n'); if (sessionConfig != null) { sb.append(" <session-config>\n"); appendElement(sb, INDENT4, "session-timeout", sessionConfig.getSessionTimeout()); sb.append(" <cookie-config>\n"); appendElement(sb, INDENT6, "name", sessionConfig.getCookieName()); appendElement(sb, INDENT6, "domain", sessionConfig.getCookieDomain()); appendElement(sb, INDENT6, "path", sessionConfig.getCookiePath()); appendElement(sb, INDENT6, "comment", sessionConfig.getCookieComment()); appendElement(sb, INDENT6, "http-only", sessionConfig.getCookieHttpOnly()); appendElement(sb, INDENT6, "secure", sessionConfig.getCookieSecure()); appendElement(sb, INDENT6, "max-age", sessionConfig.getCookieMaxAge()); sb.append(" </cookie-config>\n"); for (SessionTrackingMode stm : sessionConfig.getSessionTrackingModes()) { appendElement(sb, INDENT4, "tracking-mode", stm.name()); } sb.append(" </session-config>\n\n"); } for (Map.Entry<String, String> entry : mimeMappings.entrySet()) { sb.append(" <mime-mapping>\n"); appendElement(sb, INDENT4, "extension", entry.getKey()); appendElement(sb, INDENT4, "mime-type", entry.getValue()); sb.append(" </mime-mapping>\n"); } sb.append('\n'); if (welcomeFiles.size() > 0) { sb.append(" <welcome-file-list>\n"); for (String welcomeFile : welcomeFiles) { appendElement(sb, INDENT4, "welcome-file", welcomeFile); } sb.append(" </welcome-file-list>\n\n"); } for (ErrorPage errorPage : errorPages.values()) { sb.append(" <error-page>\n"); if (errorPage.getExceptionType() == null) { appendElement(sb, INDENT4, "error-code", Integer.toString(errorPage.getErrorCode())); } else { appendElement(sb, INDENT4, "exception-type", errorPage.getExceptionType()); } appendElement(sb, INDENT4, "location", errorPage.getLocation()); sb.append(" </error-page>\n"); } sb.append('\n'); if (taglibs.size() > 0 || jspPropertyGroups.size() > 0) { sb.append(" <jsp-config>\n"); for (Map.Entry<String, String> entry : taglibs.entrySet()) { sb.append(" <taglib>\n"); appendElement(sb, INDENT6, "taglib-uri", entry.getKey()); appendElement(sb, INDENT6, "taglib-location", entry.getValue()); sb.append(" </taglib>\n"); } for (JspPropertyGroup jpg : jspPropertyGroups) { sb.append(" <jsp-property-group>\n"); appendElement(sb, INDENT6, "url-pattern", jpg.getUrlPattern()); appendElement(sb, INDENT6, "el-ignored", jpg.getElIgnored()); appendElement(sb, INDENT6, "scripting-invalid", jpg.getScriptingInvalid()); appendElement(sb, INDENT6, "page-encoding", jpg.getPageEncoding()); for (String prelude : jpg.getIncludePreludes()) { appendElement(sb, INDENT6, "include-prelude", prelude); } for (String coda : jpg.getIncludeCodas()) { appendElement(sb, INDENT6, "include-coda", coda); } appendElement(sb, INDENT6, "is-xml", jpg.getIsXml()); appendElement(sb, INDENT6, "deferred-syntax-allowed-as-literal", jpg.getDeferredSyntax()); appendElement(sb, INDENT6, "trim-directive-whitespaces", jpg.getTrimWhitespace()); appendElement(sb, INDENT6, "default-content-type", jpg.getDefaultContentType()); appendElement(sb, INDENT6, "buffer", jpg.getBuffer()); appendElement(sb, INDENT6, "error-on-undeclared-namespace", jpg.getErrorOnUndeclaredNamespace()); sb.append(" </jsp-property-group>\n"); } sb.append(" </jsp-config>\n\n"); } for (SecurityConstraint constraint : securityConstraints) { sb.append(" <security-constraint>\n"); appendElement(sb, INDENT4, "display-name", constraint.getDisplayName()); for (SecurityCollection collection : constraint.findCollections()) { sb.append(" <web-resource-collection>\n"); appendElement(sb, INDENT6, "web-resource-name", collection.getName()); appendElement(sb, INDENT6, "description", collection.getDescription()); for (String urlPattern : collection.findPatterns()) { appendElement(sb, INDENT6, "url-pattern", urlPattern); } for (String method : collection.findMethods()) { appendElement(sb, INDENT6, "http-method", method); } for (String method : collection.findOmittedMethods()) { appendElement(sb, INDENT6, "http-method-omission", method); } sb.append(" </web-resource-collection>\n"); } if (constraint.findAuthRoles().length > 0) { sb.append(" <auth-constraint>\n"); for (String role : constraint.findAuthRoles()) { appendElement(sb, INDENT6, "role-name", role); } sb.append(" </auth-constraint>\n"); } if (constraint.getUserConstraint() != null) { sb.append(" <user-data-constraint>\n"); appendElement(sb, INDENT6, "transport-guarantee", constraint.getUserConstraint()); sb.append(" </user-data-constraint>\n"); } sb.append(" </security-constraint>\n"); } sb.append('\n'); if (loginConfig != null) { sb.append(" <login-config>\n"); appendElement(sb, INDENT4, "auth-method", loginConfig.getAuthMethod()); appendElement(sb, INDENT4, "realm-name", loginConfig.getRealmName()); if (loginConfig.getErrorPage() != null || loginConfig.getLoginPage() != null) { sb.append(" <form-login-config>\n"); appendElement(sb, INDENT6, "form-login-page", loginConfig.getLoginPage()); appendElement(sb, INDENT6, "form-error-page", loginConfig.getErrorPage()); sb.append(" </form-login-config>\n"); } sb.append(" </login-config>\n\n"); } for (String roleName : securityRoles) { sb.append(" <security-role>\n"); appendElement(sb, INDENT4, "role-name", roleName); sb.append(" </security-role>\n"); } for (ContextEnvironment envEntry : envEntries.values()) { sb.append(" <env-entry>\n"); appendElement(sb, INDENT4, "description", envEntry.getDescription()); appendElement(sb, INDENT4, "env-entry-name", envEntry.getName()); appendElement(sb, INDENT4, "env-entry-type", envEntry.getType()); appendElement(sb, INDENT4, "env-entry-value", envEntry.getValue()); for (InjectionTarget target : envEntry.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </env-entry>\n"); } sb.append('\n'); for (ContextEjb ejbRef : ejbRefs.values()) { sb.append(" <ejb-ref>\n"); appendElement(sb, INDENT4, "description", ejbRef.getDescription()); appendElement(sb, INDENT4, "ejb-ref-name", ejbRef.getName()); appendElement(sb, INDENT4, "ejb-ref-type", ejbRef.getType()); appendElement(sb, INDENT4, "home", ejbRef.getHome()); appendElement(sb, INDENT4, "remote", ejbRef.getRemote()); appendElement(sb, INDENT4, "ejb-link", ejbRef.getLink()); for (InjectionTarget target : ejbRef.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </ejb-ref>\n"); } sb.append('\n'); for (ContextLocalEjb ejbLocalRef : ejbLocalRefs.values()) { sb.append(" <ejb-local-ref>\n"); appendElement(sb, INDENT4, "description", ejbLocalRef.getDescription()); appendElement(sb, INDENT4, "ejb-ref-name", ejbLocalRef.getName()); appendElement(sb, INDENT4, "ejb-ref-type", ejbLocalRef.getType()); appendElement(sb, INDENT4, "local-home", ejbLocalRef.getHome()); appendElement(sb, INDENT4, "local", ejbLocalRef.getLocal()); appendElement(sb, INDENT4, "ejb-link", ejbLocalRef.getLink()); for (InjectionTarget target : ejbLocalRef.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </ejb-local-ref>\n"); } sb.append('\n'); for (ContextService serviceRef : serviceRefs.values()) { sb.append(" <service-ref>\n"); appendElement(sb, INDENT4, "description", serviceRef.getDescription()); appendElement(sb, INDENT4, "display-name", serviceRef.getDisplayname()); appendElement(sb, INDENT4, "service-ref-name", serviceRef.getName()); appendElement(sb, INDENT4, "service-interface", serviceRef.getInterface()); appendElement(sb, INDENT4, "service-ref-type", serviceRef.getType()); appendElement(sb, INDENT4, "wsdl-file", serviceRef.getWsdlfile()); appendElement(sb, INDENT4, "jaxrpc-mapping-file", serviceRef.getJaxrpcmappingfile()); String qname = serviceRef.getServiceqnameNamespaceURI(); if (qname != null) { qname = qname + ":"; } qname = qname + serviceRef.getServiceqnameLocalpart(); appendElement(sb, INDENT4, "service-qname", qname); Iterator<String> endpointIter = serviceRef.getServiceendpoints(); while (endpointIter.hasNext()) { String endpoint = endpointIter.next(); sb.append(" <port-component-ref>\n"); appendElement(sb, INDENT6, "service-endpoint-interface", endpoint); appendElement(sb, INDENT6, "port-component-link", serviceRef.getProperty(endpoint)); sb.append(" </port-component-ref>\n"); } Iterator<String> handlerIter = serviceRef.getHandlers(); while (handlerIter.hasNext()) { String handler = handlerIter.next(); sb.append(" <handler>\n"); ContextHandler ch = serviceRef.getHandler(handler); appendElement(sb, INDENT6, "handler-name", ch.getName()); appendElement(sb, INDENT6, "handler-class", ch.getHandlerclass()); sb.append(" </handler>\n"); } for (InjectionTarget target : serviceRef.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </service-ref>\n"); } sb.append('\n'); for (ContextResource resourceRef : resourceRefs.values()) { sb.append(" <resource-ref>\n"); appendElement(sb, INDENT4, "description", resourceRef.getDescription()); appendElement(sb, INDENT4, "res-ref-name", resourceRef.getName()); appendElement(sb, INDENT4, "res-type", resourceRef.getType()); appendElement(sb, INDENT4, "res-auth", resourceRef.getAuth()); appendElement(sb, INDENT4, "res-sharing-scope", resourceRef.getScope()); for (InjectionTarget target : resourceRef.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </resource-ref>\n"); } sb.append('\n'); for (ContextResourceEnvRef resourceEnvRef : resourceEnvRefs.values()) { sb.append(" <resource-env-ref>\n"); appendElement(sb, INDENT4, "description", resourceEnvRef.getDescription()); appendElement(sb, INDENT4, "resource-env-ref-name", resourceEnvRef.getName()); appendElement(sb, INDENT4, "resource-env-ref-type", resourceEnvRef.getType()); for (InjectionTarget target : resourceEnvRef.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </resource-env-ref>\n"); } sb.append('\n'); for (MessageDestinationRef mdr : messageDestinationRefs.values()) { sb.append(" <message-destination-ref>\n"); appendElement(sb, INDENT4, "description", mdr.getDescription()); appendElement(sb, INDENT4, "message-destination-ref-name", mdr.getName()); appendElement(sb, INDENT4, "message-destination-type", mdr.getType()); appendElement(sb, INDENT4, "message-destination-usage", mdr.getUsage()); appendElement(sb, INDENT4, "message-destination-link", mdr.getLink()); for (InjectionTarget target : mdr.getInjectionTargets()) { sb.append(" <injection-target>\n"); appendElement(sb, INDENT6, "injection-target-class", target.getTargetClass()); appendElement(sb, INDENT6, "injection-target-name", target.getTargetName()); sb.append(" </injection-target>\n"); } sb.append(" </message-destination-ref>\n"); } sb.append('\n'); for (MessageDestination md : messageDestinations.values()) { sb.append(" <message-destination>\n"); appendElement(sb, INDENT4, "description", md.getDescription()); appendElement(sb, INDENT4, "display-name", md.getDisplayName()); appendElement(sb, INDENT4, "message-destination-name", md.getName()); sb.append(" </message-destination>\n"); } sb.append('\n'); if (localeEncodingMappings.size() > 0) { sb.append(" <locale-encoding-mapping-list>\n"); for (Map.Entry<String, String> entry : localeEncodingMappings.entrySet()) { sb.append(" <locale-encoding-mapping>\n"); appendElement(sb, INDENT6, "locale", entry.getKey()); appendElement(sb, INDENT6, "encoding", entry.getValue()); sb.append(" </locale-encoding-mapping>\n"); } sb.append(" </locale-encoding-mapping-list>\n"); } sb.append("</web-app>"); return sb.toString(); }	@Override public void addRuleInstances(Digester digester) { digester.addRule(fullPrefix, new SetPublicIdRule("setPublicId")); digester.addRule(fullPrefix, new IgnoreAnnotationsRule()); digester.addRule(fullPrefix, new VersionRule()); digester.addRule(fullPrefix + "/absolute-ordering", absoluteOrdering); digester.addRule(fullPrefix + "/ordering", relativeOrdering); if (fragment) { digester.addRule(fullPrefix + "/name", name); digester.addCallMethod(fullPrefix + "/ordering/after/name", "addAfterOrdering", 0); digester.addCallMethod(fullPrefix + "/ordering/after/others", "addAfterOrderingOthers"); digester.addCallMethod(fullPrefix + "/ordering/before/name", "addBeforeOrdering", 0); digester.addCallMethod(fullPrefix + "/ordering/before/others", "addBeforeOrderingOthers"); } else { digester.addCallMethod(fullPrefix + "/absolute-ordering/name", "addAbsoluteOrdering", 0); digester.addCallMethod(fullPrefix + "/absolute-ordering/others", "addAbsoluteOrderingOthers"); } digester.addCallMethod(fullPrefix + "/context-param", "addContextParam", 2); digester.addCallParam(fullPrefix + "/context-param/param-name", 0); digester.addCallParam(fullPrefix + "/context-param/param-value", 1); digester.addCallMethod(fullPrefix + "/display-name", "setDisplayName", 0); digester.addRule(fullPrefix + "/distributable", new SetDistributableRule()); configureNamingRules(digester); digester.addObjectCreate(fullPrefix + "/error-page", "org.apache.catalina.deploy.ErrorPage"); digester.addSetNext(fullPrefix + "/error-page", "addErrorPage", "org.apache.catalina.deploy.ErrorPage"); digester.addCallMethod(fullPrefix + "/error-page/error-code", "setErrorCode", 0); digester.addCallMethod(fullPrefix + "/error-page/exception-type", "setExceptionType", 0); digester.addCallMethod(fullPrefix + "/error-page/location", "setLocation", 0); digester.addObjectCreate(fullPrefix + "/filter", "org.apache.catalina.deploy.FilterDef"); digester.addSetNext(fullPrefix + "/filter", "addFilter", "org.apache.catalina.deploy.FilterDef"); digester.addCallMethod(fullPrefix + "/filter/description", "setDescription", 0); digester.addCallMethod(fullPrefix + "/filter/display-name", "setDisplayName", 0); digester.addCallMethod(fullPrefix + "/filter/filter-class", "setFilterClass", 0); digester.addCallMethod(fullPrefix + "/filter/filter-name", "setFilterName", 0); digester.addCallMethod(fullPrefix + "/filter/icon/large-icon", "setLargeIcon", 0); digester.addCallMethod(fullPrefix + "/filter/icon/small-icon", "setSmallIcon", 0); digester.addCallMethod(fullPrefix + "/filter/async-supported", "setAsyncSupported", 0); digester.addCallMethod(fullPrefix + "/filter/init-param", "addInitParameter", 2); digester.addCallParam(fullPrefix + "/filter/init-param/param-name", 0); digester.addCallParam(fullPrefix + "/filter/init-param/param-value", 1); digester.addObjectCreate(fullPrefix + "/filter-mapping", "org.apache.catalina.deploy.FilterMap"); digester.addSetNext(fullPrefix + "/filter-mapping", "addFilterMapping", "org.apache.catalina.deploy.FilterMap"); digester.addCallMethod(fullPrefix + "/filter-mapping/filter-name", "setFilterName", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/servlet-name", "addServletName", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/url-pattern", "addURLPattern", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/dispatcher", "setDispatcher", 0); digester.addCallMethod(fullPrefix + "/listener/listener-class", "addListener", 0); digester.addRule(fullPrefix + "/jsp-config", jspConfig); digester.addObjectCreate(fullPrefix + "/jsp-config/jsp-property-group", "org.apache.catalina.deploy.JspPropertyGroup"); digester.addSetNext(fullPrefix + "/jsp-config/jsp-property-group", "addJspPropertyGroup", "org.apache.catalina.deploy.JspPropertyGroup"); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/deferred-syntax-allowed-as-literal", "setDeferredSyntax", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/el-ignored", "setElIgnored", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/include-coda", "addIncludeCoda", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/include-prelude", "addIncludePrelude", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/is-xml", "setIsXml", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/page-encoding", "setPageEncoding", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/scripting-invalid", "setScriptingInvalid", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/trim-directive-whitespaces", "setTrimWhitespace", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/url-pattern", "setUrlPattern", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/default-content-type", "setDefaultContentType", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/buffer", "setBuffer", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/error-on-undeclared-namespace", "setErrorOnUndeclaredNamespace", 0); digester.addRule(fullPrefix + "/login-config", loginConfig); digester.addObjectCreate(fullPrefix + "/login-config", "org.apache.catalina.deploy.LoginConfig"); digester.addSetNext(fullPrefix + "/login-config", "setLoginConfig", "org.apache.catalina.deploy.LoginConfig"); digester.addCallMethod(fullPrefix + "/login-config/auth-method", "setAuthMethod", 0); digester.addCallMethod(fullPrefix + "/login-config/realm-name", "setRealmName", 0); digester.addCallMethod(fullPrefix + "/login-config/form-login-config/form-error-page", "setErrorPage", 0); digester.addCallMethod(fullPrefix + "/login-config/form-login-config/form-login-page", "setLoginPage", 0); digester.addCallMethod(fullPrefix + "/mime-mapping", "addMimeMapping", 2); digester.addCallParam(fullPrefix + "/mime-mapping/extension", 0); digester.addCallParam(fullPrefix + "/mime-mapping/mime-type", 1); digester.addObjectCreate(fullPrefix + "/security-constraint", "org.apache.catalina.deploy.SecurityConstraint"); digester.addSetNext(fullPrefix + "/security-constraint", "addSecurityConstraint", "org.apache.catalina.deploy.SecurityConstraint"); digester.addRule(fullPrefix + "/security-constraint/auth-constraint", new SetAuthConstraintRule()); digester.addCallMethod(fullPrefix + "/security-constraint/auth-constraint/role-name", "addAuthRole", 0); digester.addCallMethod(fullPrefix + "/security-constraint/display-name", "setDisplayName", 0); digester.addCallMethod(fullPrefix + "/security-constraint/user-data-constraint/transport-guarantee", "setUserConstraint", 0); digester.addObjectCreate(fullPrefix + "/security-constraint/web-resource-collection", "org.apache.catalina.deploy.SecurityCollection"); digester.addSetNext(fullPrefix + "/security-constraint/web-resource-collection", "addCollection", "org.apache.catalina.deploy.SecurityCollection"); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/http-method", "addMethod", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/http-method-omission", "addOmittedMethod", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/url-pattern", "addPattern", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/web-resource-name", "setName", 0); digester.addCallMethod(fullPrefix + "/security-role/role-name", "addSecurityRole", 0); digester.addRule(fullPrefix + "/servlet", new ServletDefCreateRule()); digester.addSetNext(fullPrefix + "/servlet", "addServlet", "org.apache.catalina.deploy.ServletDef"); digester.addCallMethod(fullPrefix + "/servlet/init-param", "addInitParameter", 2); digester.addCallParam(fullPrefix + "/servlet/init-param/param-name", 0); digester.addCallParam(fullPrefix + "/servlet/init-param/param-value", 1); digester.addCallMethod(fullPrefix + "/servlet/jsp-file", "setJspFile", 0); digester.addCallMethod(fullPrefix + "/servlet/load-on-startup", "setLoadOnStartup", 0); digester.addCallMethod(fullPrefix + "/servlet/run-as/role-name", "setRunAs", 0); digester.addObjectCreate(fullPrefix + "/servlet/security-role-ref", "org.apache.catalina.deploy.SecurityRoleRef"); digester.addSetNext(fullPrefix + "/servlet/security-role-ref", "addSecurityRoleRef", "org.apache.catalina.deploy.SecurityRoleRef"); digester.addCallMethod(fullPrefix + "/servlet/security-role-ref/role-link", "setLink", 0); digester.addCallMethod(fullPrefix + "/servlet/security-role-ref/role-name", "setName", 0); digester.addCallMethod(fullPrefix + "/servlet/servlet-class", "setServletClass", 0); digester.addCallMethod(fullPrefix + "/servlet/servlet-name", "setServletName", 0); digester.addObjectCreate(fullPrefix + "/servlet/multipart-config", "org.apache.catalina.deploy.MultipartDef"); digester.addSetNext(fullPrefix + "/servlet/multipart-config", "setMultipartDef", "org.apache.catalina.deploy.MultipartDef"); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/location", "setLocation", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/max-file-size", "setMaxFileSize", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/max-request-size", "setMaxRequestSize", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/file-size-threshold", "setFileSizeThreshold", 0); digester.addCallMethod(fullPrefix + "/servlet/async-supported", "setAsyncSupported", 0); digester.addCallMethod(fullPrefix + "/servlet/enabled", "setEnabled", 0); digester.addRule(fullPrefix + "/servlet-mapping", new CallMethodMultiRule("addServletMapping", 2, 0)); digester.addCallParam(fullPrefix + "/servlet-mapping/servlet-name", 1); digester.addRule(fullPrefix + "/servlet-mapping/url-pattern", new CallParamMultiRule(0)); digester.addRule(fullPrefix + "/session-config", sessionConfig); digester.addObjectCreate(fullPrefix + "/session-config", "org.apache.catalina.deploy.SessionConfig"); digester.addSetNext(fullPrefix + "/session-config", "setSessionConfig", "org.apache.catalina.deploy.SessionConfig"); digester.addCallMethod(fullPrefix + "/session-config/session-timeout", "setSessionTimeout", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/name", "setCookieName", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/domain", "setCookieDomain", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/path", "setCookiePath", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/comment", "setCookieComment", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/http-only", "setCookieHttpOnly", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/secure", "setCookieSecure", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/max-age", "setCookieMaxAge", 0); digester.addCallMethod(fullPrefix + "/session-config/tracking-mode", "addSessionTrackingMode", 0); digester.addRule(fullPrefix + "/taglib", new TaglibLocationRule(false)); digester.addCallMethod(fullPrefix + "/taglib", "addTaglib", 2); digester.addCallParam(fullPrefix + "/taglib/taglib-location", 1); digester.addCallParam(fullPrefix + "/taglib/taglib-uri", 0); digester.addRule(fullPrefix + "/jsp-config/taglib", new TaglibLocationRule(true)); digester.addCallMethod(fullPrefix + "/jsp-config/taglib", "addTaglib", 2); digester.addCallParam(fullPrefix + "/jsp-config/taglib/taglib-location", 1); digester.addCallParam(fullPrefix + "/jsp-config/taglib/taglib-uri", 0); digester.addCallMethod(fullPrefix + "/welcome-file-list/welcome-file", "addWelcomeFile", 0); digester.addCallMethod(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping", "addLocaleEncodingMapping", 2); digester.addCallParam(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping/locale", 0); digester.addCallParam(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping/encoding", 1); }	public void configureContext(Context context) { // As far as possible, process in alphabetical order so it is easy to // check everything is present context.setPublicId(publicId); context.setEffectiveMajorVersion(getMajorVersion()); context.setEffectiveMinorVersion(getMinorVersion()); for (Entry<String, String> entry : contextParams.entrySet()) { context.addParameter(entry.getKey(), entry.getValue()); } context.setDisplayName(displayName); context.setDistributable(distributable); for (ContextLocalEjb ejbLocalRef : ejbLocalRefs.values()) { context.getNamingResources().addLocalEjb(ejbLocalRef); } for (ContextEjb ejbRef : ejbRefs.values()) { context.getNamingResources().addEjb(ejbRef); } for (ContextEnvironment environment : envEntries.values()) { context.getNamingResources().addEnvironment(environment); } for (ErrorPage errorPage : errorPages.values()) { context.addErrorPage(errorPage); } for (FilterDef filter : filters.values()) { if (filter.getAsyncSupported() == null) { filter.setAsyncSupported("false"); } context.addFilterDef(filter); } for (FilterMap filterMap : filterMaps) { context.addFilterMap(filterMap); } for (JspPropertyGroup jspPropertyGroup : jspPropertyGroups) { JspPropertyGroupDescriptor descriptor = new ApplicationJspPropertyGroupDescriptor(jspPropertyGroup); context.getJspConfigDescriptor().getJspPropertyGroups().add(descriptor); } for (String listener : listeners) { context.addApplicationListener(listener); } for (Entry<String, String> entry : localeEncodingMappings.entrySet()) { context.addLocaleEncodingMappingParameter(entry.getKey(), entry.getValue()); } if (loginConfig != null) { context.setLoginConfig(loginConfig); } for (MessageDestinationRef mdr : messageDestinationRefs.values()) { context.getNamingResources().addMessageDestinationRef(mdr); } context.setIgnoreAnnotations(metadataComplete); for (Entry<String, String> entry : mimeMappings.entrySet()) { context.addMimeMapping(entry.getKey(), entry.getValue()); } for (ContextResourceEnvRef resource : resourceEnvRefs.values()) { context.getNamingResources().addResourceEnvRef(resource); } for (ContextResource resource : resourceRefs.values()) { context.getNamingResources().addResource(resource); } for (SecurityConstraint constraint : securityConstraints) { context.addConstraint(constraint); } for (String role : securityRoles) { context.addSecurityRole(role); } for (ContextService service : serviceRefs.values()) { context.getNamingResources().addService(service); } for (ServletDef servlet : servlets.values()) { Wrapper wrapper = context.createWrapper(); if (servlet.getLoadOnStartup() != null) { wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue()); } if (servlet.getEnabled() != null) { wrapper.setEnabled(servlet.getEnabled().booleanValue()); } wrapper.setName(servlet.getServletName()); Map<String, String> params = servlet.getParameterMap(); for (Entry<String, String> entry : params.entrySet()) { wrapper.addInitParameter(entry.getKey(), entry.getValue()); } wrapper.setRunAs(servlet.getRunAs()); Set<SecurityRoleRef> roleRefs = servlet.getSecurityRoleRefs(); for (SecurityRoleRef roleRef : roleRefs) { wrapper.addSecurityReference(roleRef.getName(), roleRef.getLink()); } wrapper.setServletClass(servlet.getServletClass()); MultipartDef multipartdef = servlet.getMultipartDef(); if (multipartdef != null) { if (multipartdef.getMaxFileSize() != null && multipartdef.getMaxRequestSize() != null && multipartdef.getFileSizeThreshold() != null) { wrapper.setMultipartConfigElement(new MultipartConfigElement(multipartdef.getLocation(), Long.parseLong(multipartdef.getMaxFileSize()), Long.parseLong(multipartdef.getMaxRequestSize()), Integer.parseInt(multipartdef.getFileSizeThreshold()))); } else { wrapper.setMultipartConfigElement(new MultipartConfigElement(multipartdef.getLocation())); } } if (servlet.getAsyncSupported() != null) { wrapper.setAsyncSupported(servlet.getAsyncSupported().booleanValue()); } wrapper.setOverridable(servlet.isOverridable()); context.addChild(wrapper); } for (Entry<String, String> entry : servletMappings.entrySet()) { context.addServletMapping(entry.getKey(), entry.getValue()); } if (sessionConfig != null) { if (sessionConfig.getSessionTimeout() != null) { context.setSessionTimeout(sessionConfig.getSessionTimeout().intValue()); } SessionCookieConfig scc = context.getServletContext().getSessionCookieConfig(); scc.setName(sessionConfig.getCookieName()); scc.setDomain(sessionConfig.getCookieDomain()); scc.setPath(sessionConfig.getCookiePath()); scc.setComment(sessionConfig.getCookieComment()); if (sessionConfig.getCookieHttpOnly() != null) { scc.setHttpOnly(sessionConfig.getCookieHttpOnly().booleanValue()); } if (sessionConfig.getCookieSecure() != null) { scc.setSecure(sessionConfig.getCookieSecure().booleanValue()); } if (sessionConfig.getCookieMaxAge() != null) { scc.setMaxAge(sessionConfig.getCookieMaxAge().intValue()); } if (sessionConfig.getSessionTrackingModes().size() > 0) { context.getServletContext().setSessionTrackingModes(sessionConfig.getSessionTrackingModes()); } } for (Entry<String, String> entry : taglibs.entrySet()) { TaglibDescriptor descriptor = new ApplicationTaglibDescriptor(entry.getValue(), entry.getKey()); context.getJspConfigDescriptor().getTaglibs().add(descriptor); } for (String welcomeFile : welcomeFiles) { if (welcomeFile != null && welcomeFile.length() > 0) { context.addWelcomeFile(welcomeFile); } } for (JspPropertyGroup jspPropertyGroup : jspPropertyGroups) { String jspServletName = context.findServletMapping("*.jsp"); if (jspServletName == null) { jspServletName = "jsp"; } if (context.findChild(jspServletName) != null) { context.addServletMapping(jspPropertyGroup.getUrlPattern(), jspServletName, true); } else { if (log.isDebugEnabled()) log.debug("Skiping " + jspPropertyGroup.getUrlPattern() + " , no servlet " + jspServletName); } } }	public Boolean getTrimWhitespace() { return trimWhitespace; }	public String getUrlPattern() { return this.urlPattern; }
public boolean isOutDated(boolean checkClass) { if (jsw != null && (ctxt.getOptions().getModificationTestInterval() > 0)) { if (jsw.getLastModificationTest() + (ctxt.getOptions().getModificationTestInterval() * 1000) > System.currentTimeMillis()) { return false; } jsw.setLastModificationTest(System.currentTimeMillis()); } Long jspRealLastModified = ctxt.getLastModified(ctxt.getJspFile()); if (jspRealLastModified.longValue() < 0) { return true; } long targetLastModified = 0; File targetFile; if (checkClass) { targetFile = new File(ctxt.getClassFileName()); } else { targetFile = new File(ctxt.getServletJavaFileName()); } if (!targetFile.exists()) { return true; } targetLastModified = targetFile.lastModified(); if (checkClass && jsw != null) { jsw.setServletClassLastModifiedTime(targetLastModified); } if (targetLastModified != jspRealLastModified.longValue()) { if (log.isDebugEnabled()) { log.debug("Compiler: outdated: " + targetFile + " " + targetLastModified); } return true; } if (jsw == null) { return false; } Map<String, Long> depends = jsw.getDependants(); if (depends == null) { return false; } Iterator<Entry<String, Long>> it = depends.entrySet().iterator(); while (it.hasNext()) { Entry<String, Long> include = it.next(); try { String key = include.getKey(); URL includeUrl; if (key.startsWith("jar:")) { includeUrl = new URL(key); } else { includeUrl = ctxt.getResource(include.getKey()); } if (includeUrl == null) { return true; } URLConnection iuc = includeUrl.openConnection(); long includeLastModified = 0; if (iuc instanceof JarURLConnection) { includeLastModified = ((JarURLConnection) iuc).getJarEntry().getTime(); } else { includeLastModified = iuc.getLastModified(); } iuc.getInputStream().close(); if (includeLastModified != include.getValue().longValue()) { return true; } } catch (Exception e) { if (log.isDebugEnabled()) log.debug("Problem accessing resource. Treat as outdated.", e); return true; } } return false; }
private void doDispatch(ServletRequest request, ServletResponse response) throws ServletException, IOException { State state = new State(request, response, true); wrapResponse(state); ApplicationHttpRequest wrequest = (ApplicationHttpRequest) wrapRequest(state); String contextPath = context.getPath(); if (requestURI != null) wrequest.setAttribute(RequestDispatcher.INCLUDE_REQUEST_URI, requestURI); if (contextPath != null) wrequest.setAttribute(RequestDispatcher.INCLUDE_CONTEXT_PATH, contextPath); if (servletPath != null) wrequest.setAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH, servletPath); if (pathInfo != null) wrequest.setAttribute(RequestDispatcher.INCLUDE_PATH_INFO, pathInfo); if (queryString != null) { wrequest.setAttribute(RequestDispatcher.INCLUDE_QUERY_STRING, queryString); wrequest.setQueryParams(queryString); } wrequest.setAttribute(Globals.DISPATCHER_TYPE_ATTR, DispatcherType.ASYNC); wrequest.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, getCombinedPath()); wrequest.setContextPath(contextPath); wrequest.setRequestURI(requestURI); wrequest.setServletPath(servletPath); wrequest.setPathInfo(pathInfo); if (queryString != null) { wrequest.setQueryString(queryString); wrequest.setQueryParams(queryString); } invoke(state.outerRequest, state.outerResponse, state); }
@Override public Context createSubcontext(Name name) throws NamingException { return getBoundContext().createSubcontext(parseName(name)); }	@Override public Object lookup(String name) throws NamingException { if (log.isDebugEnabled()) { log.debug(sm.getString("selectorContext.methodUsingString", "lookup", name)); } return getBoundContext().lookup(parseName(name)); }	public int readLine(byte[] b, int off, int len) throws IOException { if (len <= 0) { return 0; } int count = 0, c; while ((c = read()) != -1) { b[off++] = (byte) c; count++; if (c == '\n' || count == len) { break; } } return count > 0 ? count : -1; }	@Override public void bind(Name name, Object obj) throws NamingException { getBoundContext().bind(parseName(name), obj); }	@Override public void bind(String name, Object obj) throws NamingException { getBoundContext().bind(parseName(name), obj); }	@Override public void destroySubcontext(String name) throws NamingException { getBoundContext().destroySubcontext(parseName(name)); }	public void println(double d) throws IOException { print(d); println(); }	@Override public void rebind(Name name, Object obj) throws NamingException { getBoundContext().rebind(parseName(name), obj); }
private synchronized int writeToSocket(ByteBuffer bytebuffer, boolean block, boolean flip) throws IOException { if (flip) { bytebuffer.flip(); flipped = true; } int written = 0; NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment) socket.getAttachment(false); if (att == null) throw new IOException("Key must be cancelled"); long writeTimeout = att.getTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) { //ignore } try { written = pool.write(bytebuffer, socket, selector, writeTimeout, block); do { if (socket.flush(true, selector, writeTimeout)) break; } while (true); } finally { if (selector != null) pool.put(selector); } if (block || bytebuffer.remaining() == 0) { //blocking writes must empty the buffer bytebuffer.clear(); flipped = false; } total += written; return written; }	@Override public void sendAck() throws IOException { if (!committed) { socket.getBufHandler().getWriteBuffer().put(Constants.ACK_BYTES, 0, Constants.ACK_BYTES.length); writeToSocket(socket.getBufHandler().getWriteBuffer(), true, true); } }
protected void webConfig() { /* * Anything and everything can override the global and host defaults. * This is implemented in two parts * - Handle as a web fragment that gets added after everything else so * everything else takes priority * - Mark Servlets as overridable so SCI configuration can replace * configuration from the defaults */ Set<WebXml> defaults = new HashSet<>(); defaults.add(getDefaultWebXmlFragment()); WebXml webXml = createWebXml(); InputSource contextWebXml = getContextWebXmlSource(); parseWebXml(contextWebXml, webXml, false); ServletContext sContext = context.getServletContext(); // Ordering is important here // Step 1. Identify all the JARs packaged with the application // If the JARs have a web-fragment.xml it will be parsed at this Map<String, WebXml> fragments = processJarsForWebFragments(); Set<WebXml> orderedFragments = null; orderedFragments = WebXml.orderWebFragments(webXml, fragments); if (ok) { processServletContainerInitializers(orderedFragments); } if (!webXml.isMetadataComplete() || typeInitializerMap.size() > 0) { if (ok) { // Hack required by Eclipse's "serve modules without // publishing" feature since this backs WEB-INF/classes by NamingEnumeration<Binding> listBindings = null; try { try { listBindings = context.getResources().listBindings("/WEB-INF/classes"); } catch (NameNotFoundException ignore) { // Safe to ignore } while (listBindings != null && listBindings.hasMoreElements()) { Binding binding = listBindings.nextElement(); if (binding.getObject() instanceof FileDirContext) { File webInfClassDir = new File(((FileDirContext) binding.getObject()).getDocBase()); processAnnotationsFile(webInfClassDir, webXml, webXml.isMetadataComplete()); } else { String resource = "/WEB-INF/classes/" + binding.getName(); try { URL url = sContext.getResource(resource); processAnnotationsUrl(url, webXml, webXml.isMetadataComplete()); } catch (MalformedURLException e) { log.error(sm.getString("contextConfig.webinfClassesUrl", resource), e); } } } } catch (NamingException e) { log.error(sm.getString("contextConfig.webinfClassesUrl", "/WEB-INF/classes"), e); } } if (ok) { processAnnotations(orderedFragments, webXml.isMetadataComplete()); } javaClassCache.clear(); } if (!webXml.isMetadataComplete()) { if (ok) { ok = webXml.merge(orderedFragments); } // Step 7. Apply global defaults // Have to merge defaults before JSP conversion since defaults webXml.merge(defaults); if (ok) { convertJsps(webXml); } if (ok) { webXml.configureContext(context); // Step 9a. Make the merged web.xml available to other // components, specifically Jasper, to save those components // from having to re-generate it. String mergedWebXml = webXml.toXml(); sContext.setAttribute(org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML, mergedWebXml); if (context.getLogEffectiveWebXml()) { log.info("web.xml:\n" + mergedWebXml); } } } else { webXml.merge(defaults); webXml.configureContext(context); } if (ok) { // Spec does not define an order. Set<WebXml> resourceJars = new LinkedHashSet<>(); if (orderedFragments != null) { for (WebXml fragment : orderedFragments) { resourceJars.add(fragment); } } for (WebXml fragment : fragments.values()) { if (!resourceJars.contains(fragment)) { resourceJars.add(fragment); } } processResourceJARs(resourceJars); // See also StandardContext.resourcesStart() for // WEB-INF/classes/META-INF/resources configuration } if (ok) { for (Map.Entry<ServletContainerInitializer, Set<Class<?>>> entry : initializerClassMap.entrySet()) { if (entry.getValue().isEmpty()) { context.addServletContainerInitializer(entry.getKey(), null); } else { context.addServletContainerInitializer(entry.getKey(), entry.getValue()); } } } }	@Test public void testBug51396() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0-fragments"); tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); tomcat.start(); ByteChunk bc = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/test/bug51396.jsp", bc, null); assertEquals(HttpServletResponse.SC_OK, rc); assertTrue(bc.toString().contains("<p>OK</p>")); }
void doForward(String relativeUrlPath) throws ServletException, IOException { try { out.clear(); } catch (IOException ex) { IllegalStateException ise = new IllegalStateException(Localizer.getMessage("jsp.error.attempt_to_clear_flushed_buffer")); ise.initCause(ex); throw ise; } while (response instanceof ServletResponseWrapperInclude) { response = ((ServletResponseWrapperInclude) response).getResponse(); } final String path = getAbsolutePathRelativeToContext(relativeUrlPath); String includeUri = (String) request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH); if (includeUri != null) request.removeAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH); try { context.getRequestDispatcher(path).forward(request, response); } finally { if (includeUri != null) request.setAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH, includeUri); } }
@Override protected Object doLookup(String name) { Object retSuper = super.doLookup(name); if (retSuper != null || mappedResourcePaths == null) { return retSuper; } for (Map.Entry<String, List<String>> mapping : mappedResourcePaths.entrySet()) { String path = mapping.getKey(); List<String> dirList = mapping.getValue(); if (name.equals(path)) { for (String resourcesDir : dirList) { File f = new File(resourcesDir); if (f.exists() && f.canRead()) { if (f.isFile()) { return new FileResource(f); } else { // never goes here, if f is a directory the super // implementation already returned a value } } } } path += "/"; if (name.startsWith(path)) { String res = name.substring(path.length()); for (String resourcesDir : dirList) { File f = new File(resourcesDir + "/" + res); if (f.exists() && f.canRead()) { if (f.isFile()) { return new FileResource(f); } else { // never goes here, if f is a directory the super // implementation already returned a value } } } } } return retSuper; }
public void setSSLVerifyDepth(int SSLVerifyDepth) { ((AprEndpoint) endpoint).setSSLVerifyDepth(SSLVerifyDepth); }	public boolean getSSLInsecureRenegotiation() { return SSLInsecureRenegotiation; }	@Override public void bind() throws Exception { try { rootPool = Pool.create(0); } catch (UnsatisfiedLinkError e) { throw new Exception(sm.getString("endpoint.init.notavail")); } serverSockPool = Pool.create(rootPool); String addressStr = null; if (getAddress() != null) { addressStr = getAddress().getHostAddress(); } int family = Socket.APR_INET; if (Library.APR_HAVE_IPV6) { if (addressStr == null) { if (!OS.IS_BSD && !OS.IS_WIN32 && !OS.IS_WIN64) family = Socket.APR_UNSPEC; } else if (addressStr.indexOf(':') >= 0) { family = Socket.APR_UNSPEC; } } long inetAddress = Address.info(addressStr, family, getPort(), 0, rootPool); serverSock = Socket.create(Address.getInfo(inetAddress).family, Socket.SOCK_STREAM, Socket.APR_PROTO_TCP, rootPool); if (OS.IS_UNIX) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } Socket.optSet(serverSock, Socket.APR_SO_KEEPALIVE, 1); int ret = Socket.bind(serverSock, inetAddress); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.bind", "" + ret, Error.strerror(ret))); } ret = Socket.listen(serverSock, getBacklog()); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.listen", "" + ret, Error.strerror(ret))); } if (OS.IS_WIN32 || OS.IS_WIN64) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } if (useSendfile && !Library.APR_HAS_SENDFILE) { useSendfile = false; } if (acceptorThreadCount == 0) { acceptorThreadCount = 1; } if (pollerThreadCount == 0) { if ((OS.IS_WIN32 || OS.IS_WIN64) && (getMaxConnections() > 1024)) { pollerThreadCount = getMaxConnections() / 1024; setMaxConnections(getMaxConnections() - (getMaxConnections() % 1024)); } else { pollerThreadCount = 1; } } if (sendfileThreadCount == 0) { if ((OS.IS_WIN32 || OS.IS_WIN64) && (sendfileSize > 1024)) { sendfileThreadCount = sendfileSize / 1024; sendfileSize = sendfileSize - (sendfileSize % 1024); } else { // No explicit poller size limitation sendfileThreadCount = 1; } } if (deferAccept) { if (Socket.optSet(serverSock, Socket.APR_TCP_DEFER_ACCEPT, 1) == Status.APR_ENOTIMPL) { deferAccept = false; } } if (isSSLEnabled()) { if (SSLCertificateFile == null) { throw new Exception(sm.getString("endpoint.apr.noSslCertFile")); } int value = SSL.SSL_PROTOCOL_NONE; if (SSLProtocol == null || SSLProtocol.length() == 0) { value = SSL.SSL_PROTOCOL_ALL; } else { for (String protocol : SSLProtocol.split("\\+")) { protocol = protocol.trim(); if ("SSLv2".equalsIgnoreCase(protocol)) { value |= SSL.SSL_PROTOCOL_SSLV2; } else if ("SSLv3".equalsIgnoreCase(protocol)) { value |= SSL.SSL_PROTOCOL_SSLV3; } else if ("TLSv1".equalsIgnoreCase(protocol)) { value |= SSL.SSL_PROTOCOL_TLSV1; } else if ("all".equalsIgnoreCase(protocol)) { value |= SSL.SSL_PROTOCOL_ALL; } else { throw new Exception(sm.getString("endpoint.apr.invalidSslProtocol", SSLProtocol)); } } } sslContext = SSLContext.make(rootPool, value, SSL.SSL_MODE_SERVER); if (SSLInsecureRenegotiation) { boolean legacyRenegSupported = false; try { legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); if (legacyRenegSupported) SSLContext.setOptions(sslContext, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); } catch (UnsatisfiedLinkError e) { // Ignore } if (!legacyRenegSupported) { log.warn(sm.getString("endpoint.warn.noInsecureReneg", SSL.versionString())); } } SSLContext.setCipherSuite(sslContext, SSLCipherSuite); SSLContext.setCertificate(sslContext, SSLCertificateFile, SSLCertificateKeyFile, SSLPassword, SSL.SSL_AIDX_RSA); SSLContext.setCertificateChainFile(sslContext, SSLCertificateChainFile, false); SSLContext.setCACertificate(sslContext, SSLCACertificateFile, SSLCACertificatePath); SSLContext.setCARevocation(sslContext, SSLCARevocationFile, SSLCARevocationPath); value = SSL.SSL_CVERIFY_NONE; if ("optional".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL; } else if ("require".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_REQUIRE; } else if ("optionalNoCA".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA; } SSLContext.setVerify(sslContext, value, SSLVerifyDepth); useSendfile = false; } }
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String key; String subProtocol = null; List<String> extensions = Collections.emptyList(); if (!headerContainsToken(req, "upgrade", "websocket")) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } if (!headerContainsToken(req, "connection", "upgrade")) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } if (!headerContainsToken(req, "sec-websocket-version", "13")) { resp.setStatus(426); resp.setHeader("Sec-WebSocket-Version", "13"); return; } key = req.getHeader("Sec-WebSocket-Key"); if (key == null) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } String origin = req.getHeader("Origin"); if (!verifyOrigin(origin)) { resp.sendError(HttpServletResponse.SC_FORBIDDEN); return; } List<String> subProtocols = getTokensFromHeader(req, "Sec-WebSocket-Protocol-Client"); if (!subProtocols.isEmpty()) { subProtocol = selectSubProtocol(subProtocols); } // TODO Read client handshake - Sec-WebSocket-Extensions // TODO Extensions require the ability to specify something (API TBD) // that can be passed to the Tomcat internals and process extension // data present when the frame is fragmented. resp.setHeader("Upgrade", "websocket"); resp.setHeader("Connection", "upgrade"); resp.setHeader("Sec-WebSocket-Accept", getWebSocketAccept(key)); if (subProtocol != null) { resp.setHeader("Sec-WebSocket-Protocol", subProtocol); } if (!extensions.isEmpty()) { // TODO } WsHttpServletRequestWrapper wrapper = new WsHttpServletRequestWrapper(req); StreamInbound inbound = createWebSocketInbound(subProtocol, wrapper); wrapper.invalidate(); ServletRequest inner = req; while (inner instanceof ServletRequestWrapper) { inner = ((ServletRequestWrapper) inner).getRequest(); } if (inner instanceof RequestFacade) { ((RequestFacade) inner).doUpgrade(inbound); } else { resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, sm.getString("servlet.reqUpgradeFail")); } }
protected void sendPingMessage(Member[] members) { if (members == null || members.length == 0) return; ChannelData data = new ChannelData(true); data.setAddress(getLocalMember(false)); data.setTimestamp(System.currentTimeMillis()); data.setOptions(getOptionFlag()); try { super.sendMessage(members, data, null); } catch (ChannelException x) { log.warn("Unable to send TCP ping.", x); } }
protected void sendPing() { if (failureDetector.get() != null) { // We have a reference to the failure detector failureDetector.get().checkMembers(true); } else { StaticMembershipInterceptor smi = staticMembers.get(); if (staticOnly && smi != null) { sendPingMessage(smi.getMembers()); } else { sendPingMessage(getMembers()); } } }
private Set<ServletContainerInitializer> getSCIsForClass(String className) { for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry : typeInitializerMap.entrySet()) { Class<?> clazz = entry.getKey(); if (!clazz.isAnnotation()) { if (clazz.getName().equals(className)) { return entry.getValue(); } } } return Collections.emptySet(); }	public long getHostTimeStamp() { return hostTimeStamp; }	public long getHostTimeStamp() { return hostTimeStamp; }
void normalize(CharChunk cc) { // Strip query string and/or fragment first as doing it this way makes int truncate = cc.indexOf('?'); if (truncate == -1) { truncate = cc.indexOf('#'); } char[] truncateCC = null; if (truncate > -1) { truncateCC = Arrays.copyOfRange(cc.getBuffer(), cc.getStart() + truncate, cc.getEnd()); cc.setEnd(cc.getStart() + truncate); } if (cc.endsWith("/.") || cc.endsWith("/..")) { try { cc.append('/'); } catch (IOException e) { throw new IllegalArgumentException(cc.toString(), e); } } char[] c = cc.getChars(); int start = cc.getStart(); int end = cc.getEnd(); int index = 0; int startIndex = 0; for (int i = 0; i < 3; i++) { startIndex = cc.indexOf('/', startIndex + 1); } index = startIndex; while (true) { index = cc.indexOf("/./", 0, 3, index); if (index < 0) { break; } copyChars(c, start + index, start + index + 2, end - start - index - 2); end = end - 2; cc.setEnd(end); } index = startIndex; int pos; while (true) { index = cc.indexOf("/../", 0, 4, index); if (index < 0) { break; } if (index == startIndex) { throw new IllegalArgumentException(); } int index2 = -1; for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos--) { if (c[pos] == (byte) '/') { index2 = pos; } } copyChars(c, start + index2, start + index + 3, end - start - index - 3); end = end + index2 - index - 3; cc.setEnd(end); index = index2; } if (truncateCC != null) { try { cc.append(truncateCC, 0, truncateCC.length); } catch (IOException ioe) { throw new IllegalArgumentException(ioe); } } }	@Override public String encodeURL(String url) { String absolute = toAbsolute(url); if (isEncodeable(absolute)) { if (url.equalsIgnoreCase("")) { url = absolute; } else if (url.equals(absolute) && !hasPath(url)) { url += '/'; } return (toEncoded(url, request.getSessionInternal().getIdInternal())); } else { return (url); } }	@Test public void testBug53062p() throws Exception { Request req = new TesterMockRequest(); Response resp = new Response(); resp.setRequest(req); String result = resp.toAbsolute("./..#/../.."); Assert.assertEquals("http://localhost:8080/level1/#/../..", result); }
public int read(ByteBuffer buf, NioChannel socket, long readTimeout) throws IOException { SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); if (key == null) throw new IOException("Key no longer registered"); KeyReference reference = new KeyReference(); KeyAttachment att = (KeyAttachment) key.attachment(); int read = 0; boolean timedout = false; int keycount = 1; long time = System.currentTimeMillis(); try { while (!timedout) { if (keycount > 0) { read = socket.read(buf); if (read == -1) throw new EOFException(); if (read > 0) break; } try { if (att.getReadLatch() == null || att.getReadLatch().getCount() == 0) att.startReadLatch(1); poller.add(att, SelectionKey.OP_READ, reference); if (readTimeout < 0) { att.awaitReadLatch(Long.MAX_VALUE, TimeUnit.MILLISECONDS); } else { att.awaitReadLatch(readTimeout, TimeUnit.MILLISECONDS); } } catch (InterruptedException ignore) { Thread.interrupted(); } if (att.getReadLatch() != null && att.getReadLatch().getCount() > 0) { keycount = 0; } else { keycount = 1; att.resetReadLatch(); } if (readTimeout >= 0 && (keycount == 0)) timedout = (System.currentTimeMillis() - time) >= readTimeout; } if (timedout) throw new SocketTimeoutException(); } finally { poller.remove(att, SelectionKey.OP_READ); if (timedout && reference.key != null) { poller.cancelKey(reference.key); } reference.key = null; } return read; }	public int write(ByteBuffer buf, NioChannel socket, long writeTimeout) throws IOException { SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); if (key == null) throw new IOException("Key no longer registered"); KeyReference reference = new KeyReference(); KeyAttachment att = (KeyAttachment) key.attachment(); int written = 0; boolean timedout = false; int keycount = 1; long time = System.currentTimeMillis(); try { while ((!timedout) && buf.hasRemaining()) { if (keycount > 0) { //only write if we were registered for a write int cnt = socket.write(buf); if (cnt == -1) throw new EOFException(); written += cnt; if (cnt > 0) { time = System.currentTimeMillis(); continue; } } try { if (att.getWriteLatch() == null || att.getWriteLatch().getCount() == 0) att.startWriteLatch(1); poller.add(att, SelectionKey.OP_WRITE, reference); if (writeTimeout < 0) { att.awaitWriteLatch(Long.MAX_VALUE, TimeUnit.MILLISECONDS); } else { att.awaitWriteLatch(writeTimeout, TimeUnit.MILLISECONDS); } } catch (InterruptedException ignore) { Thread.interrupted(); } if (att.getWriteLatch() != null && att.getWriteLatch().getCount() > 0) { keycount = 0; } else { keycount = 1; att.resetWriteLatch(); } if (writeTimeout > 0 && (keycount == 0)) timedout = (System.currentTimeMillis() - time) >= writeTimeout; } if (timedout) throw new SocketTimeoutException(); } finally { poller.remove(att, SelectionKey.OP_WRITE); if (timedout && reference.key != null) { poller.cancelKey(reference.key); } reference.key = null; } return written; }	public void execute(Runnable command, long timeout, TimeUnit unit) { submittedCount.incrementAndGet(); try { super.execute(command); } catch (RejectedExecutionException rx) { if (super.getQueue() instanceof TaskQueue) { final TaskQueue queue = (TaskQueue) super.getQueue(); try { if (!queue.force(command, timeout, unit)) { submittedCount.decrementAndGet(); throw new RejectedExecutionException("Queue capacity is full."); } } catch (InterruptedException x) { submittedCount.decrementAndGet(); Thread.interrupted(); throw new RejectedExecutionException(x); } } else { submittedCount.decrementAndGet(); throw rx; } } }	@Override public void publish(LogRecord record) { if (!isLoggable(record)) { return; } LogEntry entry = new LogEntry(record, this); boolean added = false; try { while (!added && !queue.offer(entry)) { switch(OVERFLOW_DROP_TYPE) { case OVERFLOW_DROP_LAST: { queue.pollLast(); break; } case OVERFLOW_DROP_FIRST: { queue.pollFirst(); break; } case OVERFLOW_DROP_FLUSH: { added = queue.offer(entry, 1000, TimeUnit.MILLISECONDS); break; } case OVERFLOW_DROP_CURRENT: { added = true; break; } } //switch } //while } catch (InterruptedException x) { //allow thread to be interrupted and back out of the publish operation Thread.interrupted(); } }	@Override public void run() { while (doRun) { try { Thread.sleep(sleepTime); channel.heartbeat(); } catch (InterruptedException x) { interrupted(); } catch (Exception x) { log.error("Unable to send heartbeat through Tribes interceptor stack. Will try to sleep again.", x); } //catch } //while }	public void messageReceived(ChannelMessage msg) { boolean process = true; if (okToProcess(msg.getOptions())) { process = ((msg.getMessage().getLength() != TCP_PING_DATA.length) || (!Arrays.equals(TCP_PING_DATA, msg.getMessage().getBytes()))); } if (process) super.messageReceived(msg); else if (log.isDebugEnabled()) log.debug("Received a TCP ping packet:" + msg); }	public long getRecoverySleepTime() { return recoverySleepTime; }	@Override public void run() { while (run) { try { LogEntry entry = queue.poll(LOGGER_SLEEP_TIME, TimeUnit.MILLISECONDS); if (entry != null) entry.flush(); } catch (InterruptedException x) { Thread.interrupted(); } catch (Exception x) { x.printStackTrace(); } } //while }	public void startElection(boolean force) throws ChannelException { synchronized (electionMutex) { MemberImpl local = (MemberImpl) getLocalMember(false); MemberImpl[] others = membership.getMembers(); fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT, this, "Election initated")); if (others.length == 0) { this.viewId = new UniqueId(UUIDGenerator.randomUUID(false)); this.view = new Membership(local, AbsoluteOrder.comp, true); this.handleViewConf(this.createElectionMsg(local, others, local), view); return; } if (suggestedviewId != null) { if (view != null && Arrays.diff(view, suggestedView, local).length == 0 && Arrays.diff(suggestedView, view, local).length == 0) { suggestedviewId = null; suggestedView = null; fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED, this, "Election abandoned, running election matches view")); } else { fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED, this, "Election abandoned, election running")); } return; } if (view != null && Arrays.diff(view, membership, local).length == 0 && Arrays.diff(membership, view, local).length == 0) { fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED, this, "Election abandoned, view matches membership")); return; } int prio = AbsoluteOrder.comp.compare(local, others[0]); MemberImpl leader = (prio < 0) ? local : others[0]; if (local.equals(leader) || force) { CoordinationMessage msg = createElectionMsg(local, others, leader); suggestedviewId = msg.getId(); suggestedView = new Membership(local, AbsoluteOrder.comp, true); Arrays.fill(suggestedView, msg.getMembers()); fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_PROCESS_ELECT, this, "Election, sending request")); sendElectionMsg(local, others[0], msg); } else { try { coordMsgReceived.set(false); fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_WAIT_FOR_MSG, this, "Election, waiting for request")); electionMutex.wait(waitForCoordMsgTimeout); } catch (InterruptedException x) { Thread.interrupted(); } if (suggestedviewId == null && (!coordMsgReceived.get())) { //no message arrived, send the coord msg // fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_WAIT_FOR_MSG,this,"Election, waiting timed out.")); fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED, this, "Election abandoned, waiting timed out.")); } else { fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED, this, "Election abandoned, received a message")); } } //end if } }	@Override public void stopInternal() { releaseConnectionLatch(); if (!paused) { pause(); } if (running) { running = false; unlockAccept(); for (AbstractEndpoint.Acceptor acceptor : acceptors) { long waitLeft = 10000; while (waitLeft > 0 && acceptor.getState() != AcceptorState.ENDED && serverSock != 0) { try { Thread.sleep(50); } catch (InterruptedException e) { Thread.interrupted(); } waitLeft -= 50; } if (waitLeft == 0) { log.warn(sm.getString("endpoint.warn.unlockAcceptorFailed", acceptor.getThreadName())); if (serverSock != 0) { Socket.shutdown(serverSock, Socket.APR_SHUTDOWN_READ); serverSock = 0; } } } for (int i = 0; i < pollers.length; i++) { try { pollers[i].destroy(); } catch (Exception e) { // Ignore } } pollers = null; for (int i = 0; i < cometPollers.length; i++) { try { cometPollers[i].destroy(); } catch (Exception e) { // Ignore } } cometPollers = null; if (useSendfile) { for (int i = 0; i < sendfiles.length; i++) { try { sendfiles[i].destroy(); } catch (Exception e) { // Ignore } } sendfiles = null; } } shutdownExecutor(); }
protected boolean terminateTransaction(PooledConnection con) { try { if (con.getPoolProperties().getDefaultAutoCommit() == Boolean.FALSE) { if (this.getPoolProperties().getRollbackOnReturn()) { boolean autocommit = con.getConnection().getAutoCommit(); if (!autocommit) con.getConnection().rollback(); } else if (this.getPoolProperties().getCommitOnReturn()) { boolean autocommit = con.getConnection().getAutoCommit(); if (!autocommit) con.getConnection().commit(); } } return true; } catch (SQLException x) { log.warn("Unable to terminate transaction, connection will be closed.", x); return false; } }

/** * send a cluster message to one member * * @param msg message to transfer * @param dest Receiver member * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage, * org.apache.catalina.tribes.Member) */ @Override public void send(ClusterMessage msg, Member dest) { try { msg.setAddress(getLocalMember()); if (dest != null) { if (!getLocalMember().equals(dest)) { channel.send(new Member[] {dest}, msg,channelSendOptions); } else log.error("Unable to send message to local member " + msg); } else { Member[] destmembers = channel.getMembers(); if (destmembers.length>0) channel.send(destmembers,msg,channelSendOptions); } } }
@SuppressWarnings("unchecked") @Override public Enumeration<String> getAttributeNames() { Set<String> names = new HashSet<String>(); names.addAll(attributes.keySet()); return new MultiEnumeration<String>(new Enumeration[] { super.getAttributeNames(), Collections.enumeration(names) }); }	@Override public boolean setInitParameter(String name, String value) { if (parameters.containsKey(name)) { return false; } parameters.put(name, value); return true; }	@Override public void removeAttribute(String name) { Object value = null; boolean found = false; if (readOnlyAttributes.containsKey(name)) return; found = attributes.containsKey(name); if (found) { value = attributes.get(name); attributes.remove(name); } else { return; } Object[] listeners = context.getApplicationEventListeners(); if ((listeners == null) || (listeners.length == 0)) return; ServletContextAttributeEvent event = new ServletContextAttributeEvent(context.getServletContext(), name, value); for (int i = 0; i < listeners.length; i++) { if (!(listeners[i] instanceof ServletContextAttributeListener)) continue; ServletContextAttributeListener listener = (ServletContextAttributeListener) listeners[i]; try { context.fireContainerEvent("beforeContextAttributeRemoved", listener); listener.attributeRemoved(event); context.fireContainerEvent("afterContextAttributeRemoved", listener); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); context.fireContainerEvent("afterContextAttributeRemoved", listener); log(sm.getString("applicationContext.attributeEvent"), t); } } }
@Override public String[] findMimeMappings() { synchronized (mimeMappings) { String[] results = new String[mimeMappings.size()]; return (mimeMappings.keySet().toArray(results)); } }	@Override public void addMimeMapping(String extension, String mimeType) { synchronized (mimeMappings) { mimeMappings.put(extension, mimeType); } fireContainerEvent("addMimeMapping", extension); }
private void status(Request request, Response response) { int statusCode = response.getStatus(); Context context = request.getContext(); if (context == null) { return; } if (!response.isError()) { return; } ErrorPage errorPage = context.findErrorPage(statusCode); if (errorPage != null) { response.setAppCommitted(false); request.setAttribute(RequestDispatcher.ERROR_STATUS_CODE, Integer.valueOf(statusCode)); String message = response.getMessage(); if (message == null) { message = ""; } request.setAttribute(RequestDispatcher.ERROR_MESSAGE, message); request.setAttribute(ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, errorPage.getLocation()); request.setAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR, DispatcherType.ERROR); Wrapper wrapper = request.getWrapper(); if (wrapper != null) { request.setAttribute(RequestDispatcher.ERROR_SERVLET_NAME, wrapper.getName()); } request.setAttribute(RequestDispatcher.ERROR_REQUEST_URI, request.getRequestURI()); if (custom(request, response, errorPage)) { try { response.flushBuffer(); } catch (ClientAbortException e) { // Ignore } catch (IOException e) { container.getLogger().warn("Exception Processing " + errorPage, e); } } } }
@Override public URL getResource(String path) throws MalformedURLException { if (path == null || !path.startsWith("/") && GET_RESOURCE_REQUIRE_SLASH) throw new MalformedURLException(sm.getString("applicationContext.requestDispatcher.iae", path)); String normPath = RequestUtil.normalize(path); if (normPath == null) return (null); DirContext resources = context.getResources(); if (resources != null) { String fullPath = context.getPath() + normPath; String hostName = context.getParent().getName(); try { resources.lookup(normPath); URI uri = new URI("jndi", getJNDIUri(hostName, fullPath), null); return new URL(null, uri.toString(), new DirContextURLStreamHandler(resources)); } catch (NamingException e) { // Ignore } catch (Exception e) { log(sm.getString("applicationContext.lookup.error", path, getContextPath()), e); } } return (null); }	public void testBug53257() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0"); tomcat.addWebapp(null, "/test", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/test/bug53257/index.jsp"); String result = res.toString(); String[] lines = result.split("\n"); for (String line : lines) { if (line.startsWith("FAIL")) { Assert.fail(line); } } }
public ObjectName createObjectName(ObjectName original) throws MalformedObjectNameException { String domain = ConnectionPool.POOL_JMX_DOMAIN; Hashtable<String, String> properties = original.getKeyPropertyList(); String origDomain = original.getDomain(); properties.put("type", "ConnectionPool"); properties.put("class", this.getClass().getName()); if (original.getKeyProperty("path") != null) { properties.put("engine", origDomain); } ObjectName name = new ObjectName(domain, properties); return name; }
protected void configureNamingRules(Digester digester) { digester.addObjectCreate(fullPrefix + "/ejb-local-ref", "org.apache.catalina.deploy.ContextLocalEjb"); digester.addSetNext(fullPrefix + "/ejb-local-ref", "addEjbLocalRef", "org.apache.catalina.deploy.ContextLocalEjb"); digester.addCallMethod(fullPrefix + "/ejb-local-ref/description", "setDescription", 0); digester.addCallMethod(fullPrefix + "/ejb-local-ref/ejb-link", "setLink", 0); digester.addCallMethod(fullPrefix + "/ejb-local-ref/ejb-ref-name", "setName", 0); digester.addCallMethod(fullPrefix + "/ejb-local-ref/ejb-ref-type", "setType", 0); digester.addCallMethod(fullPrefix + "/ejb-local-ref/local", "setLocal", 0); digester.addCallMethod(fullPrefix + "/ejb-local-ref/local-home", "setHome", 0); configureInjectionRules(digester, "web-app/ejb-local-ref/"); digester.addObjectCreate(fullPrefix + "/ejb-ref", "org.apache.catalina.deploy.ContextEjb"); digester.addSetNext(fullPrefix + "/ejb-ref", "addEjbRef", "org.apache.catalina.deploy.ContextEjb"); digester.addCallMethod(fullPrefix + "/ejb-ref/description", "setDescription", 0); digester.addCallMethod(fullPrefix + "/ejb-ref/ejb-link", "setLink", 0); digester.addCallMethod(fullPrefix + "/ejb-ref/ejb-ref-name", "setName", 0); digester.addCallMethod(fullPrefix + "/ejb-ref/ejb-ref-type", "setType", 0); digester.addCallMethod(fullPrefix + "/ejb-ref/home", "setHome", 0); digester.addCallMethod(fullPrefix + "/ejb-ref/remote", "setRemote", 0); configureInjectionRules(digester, "web-app/ejb-ref/"); digester.addObjectCreate(fullPrefix + "/env-entry", "org.apache.catalina.deploy.ContextEnvironment"); digester.addSetNext(fullPrefix + "/env-entry", "addEnvEntry", "org.apache.catalina.deploy.ContextEnvironment"); digester.addCallMethod(fullPrefix + "/env-entry/description", "setDescription", 0); digester.addCallMethod(fullPrefix + "/env-entry/env-entry-name", "setName", 0); digester.addCallMethod(fullPrefix + "/env-entry/env-entry-type", "setType", 0); digester.addCallMethod(fullPrefix + "/env-entry/env-entry-value", "setValue", 0); configureInjectionRules(digester, "web-app/env-entry/"); digester.addObjectCreate(fullPrefix + "/resource-env-ref", "org.apache.catalina.deploy.ContextResourceEnvRef"); digester.addSetNext(fullPrefix + "/resource-env-ref", "addResourceEnvRef", "org.apache.catalina.deploy.ContextResourceEnvRef"); digester.addCallMethod(fullPrefix + "/resource-env-ref/resource-env-ref-name", "setName", 0); digester.addCallMethod(fullPrefix + "/resource-env-ref/resource-env-ref-type", "setType", 0); configureInjectionRules(digester, "web-app/resource-env-ref/"); digester.addObjectCreate(fullPrefix + "/message-destination", "org.apache.catalina.deploy.MessageDestination"); digester.addSetNext(fullPrefix + "/message-destination", "addMessageDestination", "org.apache.catalina.deploy.MessageDestination"); digester.addCallMethod(fullPrefix + "/message-destination/description", "setDescription", 0); digester.addCallMethod(fullPrefix + "/message-destination/display-name", "setDisplayName", 0); digester.addCallMethod(fullPrefix + "/message-destination/icon/large-icon", "setLargeIcon", 0); digester.addCallMethod(fullPrefix + "/message-destination/icon/small-icon", "setSmallIcon", 0); digester.addCallMethod(fullPrefix + "/message-destination/message-destination-name", "setName", 0); digester.addObjectCreate(fullPrefix + "/message-destination-ref", "org.apache.catalina.deploy.MessageDestinationRef"); digester.addSetNext(fullPrefix + "/message-destination-ref", "addMessageDestinationRef", "org.apache.catalina.deploy.MessageDestinationRef"); digester.addCallMethod(fullPrefix + "/message-destination-ref/description", "setDescription", 0); digester.addCallMethod(fullPrefix + "/message-destination-ref/message-destination-link", "setLink", 0); digester.addCallMethod(fullPrefix + "/message-destination-ref/message-destination-ref-name", "setName", 0); digester.addCallMethod(fullPrefix + "/message-destination-ref/message-destination-type", "setType", 0); digester.addCallMethod(fullPrefix + "/message-destination-ref/message-destination-usage", "setUsage", 0); configureInjectionRules(digester, "web-app/message-destination-ref/"); digester.addObjectCreate(fullPrefix + "/resource-ref", "org.apache.catalina.deploy.ContextResource"); digester.addSetNext(fullPrefix + "/resource-ref", "addResourceRef", "org.apache.catalina.deploy.ContextResource"); digester.addCallMethod(fullPrefix + "/resource-ref/description", "setDescription", 0); digester.addCallMethod(fullPrefix + "/resource-ref/res-auth", "setAuth", 0); digester.addCallMethod(fullPrefix + "/resource-ref/res-ref-name", "setName", 0); digester.addCallMethod(fullPrefix + "/resource-ref/res-sharing-scope", "setScope", 0); digester.addCallMethod(fullPrefix + "/resource-ref/res-type", "setType", 0); configureInjectionRules(digester, "web-app/resource-ref/"); digester.addObjectCreate(fullPrefix + "/service-ref", "org.apache.catalina.deploy.ContextService"); digester.addSetNext(fullPrefix + "/service-ref", "addServiceRef", "org.apache.catalina.deploy.ContextService"); digester.addCallMethod(fullPrefix + "/service-ref/description", "setDescription", 0); digester.addCallMethod(fullPrefix + "/service-ref/display-name", "setDisplayname", 0); digester.addCallMethod(fullPrefix + "/service-ref/icon/large-icon", "setLargeIcon", 0); digester.addCallMethod(fullPrefix + "/service-ref/icon/small-icon", "setSmallIcon", 0); digester.addCallMethod(fullPrefix + "/service-ref/service-ref-name", "setName", 0); digester.addCallMethod(fullPrefix + "/service-ref/service-interface", "setInterface", 0); digester.addCallMethod(fullPrefix + "/service-ref/service-ref-type", "setType", 0); digester.addCallMethod(fullPrefix + "/service-ref/wsdl-file", "setWsdlfile", 0); digester.addCallMethod(fullPrefix + "/service-ref/jaxrpc-mapping-file", "setJaxrpcmappingfile", 0); digester.addRule(fullPrefix + "/service-ref/service-qname", new ServiceQnameRule()); digester.addRule(fullPrefix + "/service-ref/port-component-ref", new CallMethodMultiRule("addPortcomponent", 2, 1)); digester.addCallParam(fullPrefix + "/service-ref/port-component-ref/service-endpoint-interface", 0); digester.addRule(fullPrefix + "/service-ref/port-component-ref/port-component-link", new CallParamMultiRule(1)); digester.addObjectCreate(fullPrefix + "/service-ref/handler", "org.apache.catalina.deploy.ContextHandler"); digester.addRule(fullPrefix + "/service-ref/handler", new SetNextRule("addHandler", "org.apache.catalina.deploy.ContextHandler")); digester.addCallMethod(fullPrefix + "/service-ref/handler/handler-name", "setName", 0); digester.addCallMethod(fullPrefix + "/service-ref/handler/handler-class", "setHandlerclass", 0); digester.addCallMethod(fullPrefix + "/service-ref/handler/init-param", "setProperty", 2); digester.addCallParam(fullPrefix + "/service-ref/handler/init-param/param-name", 0); digester.addCallParam(fullPrefix + "/service-ref/handler/init-param/param-value", 1); digester.addRule(fullPrefix + "/service-ref/handler/soap-header", new SoapHeaderRule()); digester.addCallMethod(fullPrefix + "/service-ref/handler/soap-role", "addSoapRole", 0); digester.addCallMethod(fullPrefix + "/service-ref/handler/port-name", "addPortName", 0); configureInjectionRules(digester, "web-app/service-ref/"); }	@Test public void testBug52830() throws Exception { Tomcat tomcat = getTomcatInstance(); tomcat.enableNaming(); StandardContext ctx = (StandardContext) tomcat.addContext("", System.getProperty("java.io.tmpdir")); ContextEnvironment env = new ContextEnvironment(); env.setName("boolean"); env.setType(Boolean.class.getName()); env.setValue("true"); ctx.getNamingResources().addEnvironment(env); Bug52830Servlet bug52830Servlet = new Bug52830Servlet(); Tomcat.addServlet(ctx, "bug52830Servlet", bug52830Servlet); ctx.addServletMapping("/", "bug52830Servlet"); tomcat.start(); ByteChunk bc = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/", bc, null); assertEquals(200, rc); assertTrue(bc.toString().contains("truetrue")); }	@Override public void begin(String namespace, String name, Attributes attributes) throws Exception { if (isLoginConfigSet) { throw new IllegalArgumentException("<login-config> element is limited to 1 occurrence"); } isLoginConfigSet = true; }
PageContext internalGetPageContext(Servlet servlet, ServletRequest request, ServletResponse response, String errorPageURL, boolean needsSession, int bufferSize, boolean autoflush) { try { PageContext pc; if (USE_POOL) { PageContextPool pool = localPool.get(); if (pool == null) { pool = new PageContextPool(); localPool.set(pool); } pc = pool.get(); if (pc == null) { pc = new PageContextImpl(); } } else { pc = new PageContextImpl(); } pc.initialize(servlet, request, response, errorPageURL, needsSession, bufferSize, autoflush); return pc; } catch (Throwable ex) { ExceptionUtils.handleThrowable(ex); log.fatal("Exception initializing page context", ex); return null; } }	private void generatePostamble() { out.popIndent(); out.printil("} catch (java.lang.Throwable t) {"); out.pushIndent(); out.printil("if (!(t instanceof javax.servlet.jsp.SkipPageException)){"); out.pushIndent(); out.printil("out = _jspx_out;"); out.printil("if (out != null && out.getBufferSize() != 0)"); out.pushIndent(); out.printil("try { out.clearBuffer(); } catch (java.io.IOException e) {}"); out.popIndent(); out.printil("if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);"); out.printil("else log(t.getMessage(), t);"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("} finally {"); out.pushIndent(); out.printil("_jspxFactory.releasePageContext(_jspx_page_context);"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); genCommonPostamble(); }
protected void deregisterJmx() { try { if (mbeans.remove(poolName) != null) { ObjectName oname = getObjectName(getClass(), poolName); ManagementFactory.getPlatformMBeanServer().unregisterMBean(oname); } } catch (MBeanRegistrationException e) { log.debug("Jmx deregistration failed.", e); } catch (InstanceNotFoundException e) { log.debug("Jmx deregistration failed.", e); } catch (MalformedObjectNameException e) { log.warn("Jmx deregistration failed.", e); } catch (RuntimeOperationsException e) { log.warn("Jmx deregistration failed.", e); } }	public ObjectName createObjectName(ObjectName original) throws MalformedObjectNameException { String domain = "tomcat.jdbc"; Hashtable<String, String> properties = original.getKeyPropertyList(); String origDomain = original.getDomain(); properties.put("type", "ConnectionPool"); properties.put("class", this.getClass().getName()); if (original.getKeyProperty("path") != null) { properties.put("engine", origDomain); } ObjectName name = new ObjectName(domain, properties); return name; }	public void testSlowSqlJmx() throws Exception { int count = 1; this.init(); this.datasource.setMaxActive(1); this.datasource.setJdbcInterceptors(SlowQueryReportJmx.class.getName() + "(threshold=50,notifyPool=false)"); Connection con = this.datasource.getConnection(); String slowSql = "select count(1) from test where val1 like 'ewq%eq'"; for (int i = 0; i < count; i++) { Statement st = con.createStatement(); ResultSet rs = st.executeQuery(slowSql); rs.close(); st.close(); } Map<String, SlowQueryReport.QueryStats> map = SlowQueryReport.getPoolStats(datasource.getPool().getName()); assertNotNull(map); assertEquals(1, map.size()); String key = map.keySet().iterator().next(); SlowQueryReport.QueryStats stats = map.get(key); System.out.println("Stats:" + stats); ClientListener listener = new ClientListener(); ConnectionPool pool = datasource.getPool(); ManagementFactory.getPlatformMBeanServer().addNotificationListener(SlowQueryReportJmx.getObjectName(SlowQueryReportJmx.class, pool.getName()), listener, null, null); for (int i = 0; i < count; i++) { PreparedStatement st = con.prepareStatement(slowSql); ResultSet rs = st.executeQuery(); rs.close(); st.close(); } System.out.println("Stats:" + stats); for (int i = 0; i < count; i++) { CallableStatement st = con.prepareCall(slowSql); ResultSet rs = st.executeQuery(); rs.close(); st.close(); } System.out.println("Stats:" + stats); assertEquals("Expecting to have received " + (2 * count) + " notifications.", 2 * count, listener.notificationCount); con.close(); tearDown(); assertNull(SlowQueryReport.getPoolStats(pool.getName())); }
@Override protected void initInternal() throws LifecycleException { super.initInternal(); adapter = new CoyoteAdapter(this); protocolHandler.setAdapter(adapter); if (null == parseBodyMethodsSet) { setParseBodyMethods(getParseBodyMethods()); } try { protocolHandler.init(); } catch (Exception e) { throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerInitializationFailed"), e); } mapperListener.init(); }	@Override public Executor getExecutor() { return endpoint.getExecutor(); }
private Method read(ELContext ctx) { if (this.read == null) { this.read = getMethod(this.owner, descriptor.getReadMethod()); if (this.read == null) { throw new PropertyNotFoundException(message(ctx, "propertyNotReadable", new Object[] { type.getName(), descriptor.getName() })); } } return this.read; }	private Method write(ELContext ctx) { if (this.write == null) { this.write = getMethod(this.owner, descriptor.getWriteMethod()); if (this.write == null) { throw new PropertyNotFoundException(message(ctx, "propertyNotWritable", new Object[] { type.getName(), descriptor.getName() })); } } return this.write; }
@Override public ContainerListener[] findContainerListeners() { Lock read = listenersLock.readLock(); read.lock(); try { ContainerListener[] results = new ContainerListener[listeners.size()]; return listeners.toArray(results); } finally { read.unlock(); } }	public Void run() { addChildInternal(child); return null; }	@Override public void addContainerListener(ContainerListener listener) { Lock write = listenersLock.writeLock(); write.lock(); try { listeners.add(listener); } finally { write.unlock(); } }	@Override public void fireContainerEvent(String type, Object data) { Lock read = listenersLock.readLock(); read.lock(); try { if (listeners.size() < 1) return; ContainerEvent event = new ContainerEvent(this, type, data); for (ContainerListener listener : listeners) { listener.containerEvent(event); } } finally { read.unlock(); } }	@Override public void removeContainerListener(ContainerListener listener) { Lock write = listenersLock.writeLock(); write.lock(); try { listeners.remove(listener); } finally { write.unlock(); } }
@Override public SocketState event(SocketStatus status) throws IOException { RequestInfo rp = request.getRequestProcessor(); try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); error = !adapter.event(request, response, status); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("http11processor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (error) { return SocketState.CLOSED; } else if (!comet) { inputBuffer.nextRequest(); outputBuffer.nextRequest(); return SocketState.OPEN; } else { return SocketState.LONG; } }	@Override public SocketState event(SocketStatus status) throws IOException { long soTimeout = endpoint.getSoTimeout(); RequestInfo rp = request.getRequestProcessor(); final NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) socket.getSocket().getAttachment(false); try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); error = !adapter.event(request, response, status); if (!error) { if (attach != null) { attach.setComet(comet); if (comet) { Integer comettimeout = (Integer) request.getAttribute(org.apache.coyote.Constants.COMET_TIMEOUT_ATTR); if (comettimeout != null) { attach.setTimeout(comettimeout.longValue()); } } else { if (keepAlive) { attach.setTimeout(keepAliveTimeout); } else { attach.setTimeout(soTimeout); } } } } } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("http11processor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (error) { return SocketState.CLOSED; } else if (!comet) { if (keepAlive) { inputBuffer.nextRequest(); outputBuffer.nextRequest(); return SocketState.OPEN; } else { return SocketState.CLOSED; } } else { return SocketState.LONG; } }
public boolean validate(Request request, String authorization) { if (authorization == null) { return false; } if (!authorization.startsWith("Digest ")) { return false; } authorization = authorization.substring(7).trim(); String[] tokens = authorization.split(",(?=(?:[^\"]*\"[^\"]*\")+$)"); method = request.getMethod(); String opaque = null; for (int i = 0; i < tokens.length; i++) { String currentToken = tokens[i]; if (currentToken.length() == 0) { continue; } int equalSign = currentToken.indexOf('='); if (equalSign < 0) { return false; } String currentTokenName = currentToken.substring(0, equalSign).trim(); String currentTokenValue = currentToken.substring(equalSign + 1).trim(); if ("username".equals(currentTokenName)) { userName = removeQuotes(currentTokenValue); } if ("realm".equals(currentTokenName)) { realmName = removeQuotes(currentTokenValue, true); } if ("nonce".equals(currentTokenName)) { nonce = removeQuotes(currentTokenValue); } if ("nc".equals(currentTokenName)) { nc = removeQuotes(currentTokenValue); } if ("cnonce".equals(currentTokenName)) { cnonce = removeQuotes(currentTokenValue); } if ("qop".equals(currentTokenName)) { qop = removeQuotes(currentTokenValue); } if ("uri".equals(currentTokenName)) { uri = removeQuotes(currentTokenValue); } if ("response".equals(currentTokenName)) { response = removeQuotes(currentTokenValue); } if ("opaque".equals(currentTokenName)) { opaque = removeQuotes(currentTokenValue); } } if ((userName == null) || (realmName == null) || (nonce == null) || (uri == null) || (response == null)) { return false; } if (validateUri) { String uriQuery; String query = request.getQueryString(); if (query == null) { uriQuery = request.getRequestURI(); } else { uriQuery = request.getRequestURI() + "?" + query; } if (!uri.equals(uriQuery)) { return false; } } String lcRealm = getRealmName(request.getContext()); if (!lcRealm.equals(realmName)) { return false; } if (!this.opaque.equals(opaque)) { return false; } int i = nonce.indexOf(":"); if (i < 0 || (i + 1) == nonce.length()) { return false; } long nonceTime; try { nonceTime = Long.parseLong(nonce.substring(0, i)); } catch (NumberFormatException nfe) { return false; } String md5clientIpTimeKey = nonce.substring(i + 1); long currentTime = System.currentTimeMillis(); if ((currentTime - nonceTime) > nonceValidity) { nonceStale = true; return false; } String serverIpTimeKey = request.getRemoteAddr() + ":" + nonceTime + ":" + key; byte[] buffer = null; synchronized (md5Helper) { buffer = md5Helper.digest(serverIpTimeKey.getBytes(B2CConverter.ISO_8859_1)); } String md5ServerIpTimeKey = md5Encoder.encode(buffer); if (!md5ServerIpTimeKey.equals(md5clientIpTimeKey)) { return false; } if (qop != null && !QOP.equals(qop)) { return false; } if (qop == null) { if (cnonce != null || nc != null) { return false; } } else { if (cnonce == null || nc == null) { return false; } if (nc.length() != 8) { return false; } long count; try { count = Long.parseLong(nc, 16); } catch (NumberFormatException nfe) { return false; } NonceInfo info; synchronized (cnonces) { info = cnonces.get(cnonce); } if (info == null) { info = new NonceInfo(); } else { if (count <= info.getCount()) { return false; } } info.setCount(count); info.setTimestamp(currentTime); synchronized (cnonces) { cnonces.put(cnonce, info); } } return true; }
protected void processServletContainerInitializers(Set<WebXml> fragments) { for (WebXml fragment : fragments) { URL url = fragment.getURL(); Jar jar = null; InputStream is = null; ServletContainerInitializer sci = null; try { if ("jar".equals(url.getProtocol())) { jar = JarFactory.newInstance(url); is = jar.getInputStream(SCI_LOCATION); } else if ("file".equals(url.getProtocol())) { String path = url.getPath(); File file = new File(path, SCI_LOCATION); if (file.exists()) { is = new FileInputStream(file); } } if (is != null) { sci = getServletContainerInitializer(is); } } catch (IOException ioe) { log.error(sm.getString("contextConfig.servletContainerInitializerFail", url, context.getName())); ok = false; return; } finally { if (is != null) { try { is.close(); } catch (IOException e) { // Ignore } } if (jar != null) { jar.close(); } } if (sci == null) { continue; } initializerClassMap.put(sci, new HashSet<Class<?>>()); HandlesTypes ht = sci.getClass().getAnnotation(HandlesTypes.class); if (ht != null) { Class<?>[] types = ht.value(); if (types != null) { for (Class<?> type : types) { if (type.isAnnotation()) { handlesTypesAnnotations = true; } else { handlesTypesNonAnnotations = true; } Set<ServletContainerInitializer> scis = typeInitializerMap.get(type); if (scis == null) { scis = new HashSet<ServletContainerInitializer>(); typeInitializerMap.put(type, scis); } scis.add(sci); } } } } }
protected static void writeProcessorState(PrintWriter writer, ObjectName pName, MBeanServer mBeanServer, int mode) throws Exception { Integer stageValue = (Integer) mBeanServer.getAttribute(pName, "stage"); int stage = stageValue.intValue(); boolean fullStatus = true; boolean showRequest = true; String stageStr = null; switch(stage) { case (1): stageStr = "P"; fullStatus = false; break; case (2): stageStr = "P"; fullStatus = false; break; case (3): stageStr = "S"; break; case (4): stageStr = "F"; break; case (5): stageStr = "F"; break; case (7): stageStr = "R"; fullStatus = false; break; case (6): stageStr = "K"; fullStatus = true; showRequest = false; break; case (0): stageStr = "R"; fullStatus = false; break; default: stageStr = "?"; fullStatus = false; } if (mode == 0) { writer.write("<td><strong>"); writer.write(stageStr); writer.write("</strong></td>"); if (fullStatus) { writer.write("<td>"); writer.print(formatTime(mBeanServer.getAttribute(pName, "requestProcessingTime"), false)); writer.write("</td>"); writer.write("<td>"); if (showRequest) { writer.print(formatSize(mBeanServer.getAttribute(pName, "requestBytesSent"), false)); } else { writer.write("?"); } writer.write("</td>"); writer.write("<td>"); if (showRequest) { writer.print(formatSize(mBeanServer.getAttribute(pName, "requestBytesReceived"), false)); } else { writer.write("?"); } writer.write("</td>"); writer.write("<td>"); writer.print(filter(mBeanServer.getAttribute(pName, "remoteAddr"))); writer.write("</td>"); writer.write("<td nowrap>"); writer.write(filter(mBeanServer.getAttribute(pName, "virtualHost"))); writer.write("</td>"); writer.write("<td nowrap>"); if (showRequest) { writer.write(filter(mBeanServer.getAttribute(pName, "method"))); writer.write(" "); writer.write(filter(mBeanServer.getAttribute(pName, "currentUri"))); String queryString = (String) mBeanServer.getAttribute(pName, "currentQueryString"); if ((queryString != null) && (!queryString.equals(""))) { writer.write("?"); writer.print(RequestUtil.filter(queryString)); } writer.write(" "); writer.write(filter(mBeanServer.getAttribute(pName, "protocol"))); } else { writer.write("?"); } writer.write("</td>"); } else { writer.write("<td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td>"); } } else if (mode == 1) { writer.write("<worker "); writer.write(" stage=\"" + stageStr + "\""); if (fullStatus) { writer.write(" requestProcessingTime=\"" + mBeanServer.getAttribute(pName, "requestProcessingTime") + "\""); writer.write(" requestBytesSent=\""); if (showRequest) { writer.write("" + mBeanServer.getAttribute(pName, "requestBytesSent")); } else { writer.write("0"); } writer.write("\""); writer.write(" requestBytesReceived=\""); if (showRequest) { writer.write("" + mBeanServer.getAttribute(pName, "requestBytesReceived")); } else { writer.write("0"); } writer.write("\""); writer.write(" remoteAddr=\"" + filter(mBeanServer.getAttribute(pName, "remoteAddr")) + "\""); writer.write(" virtualHost=\"" + filter(mBeanServer.getAttribute(pName, "virtualHost")) + "\""); if (showRequest) { writer.write(" method=\"" + filter(mBeanServer.getAttribute(pName, "method")) + "\""); writer.write(" currentUri=\"" + filter(mBeanServer.getAttribute(pName, "currentUri")) + "\""); String queryString = (String) mBeanServer.getAttribute(pName, "currentQueryString"); if ((queryString != null) && (!queryString.equals(""))) { writer.write(" currentQueryString=\"" + RequestUtil.filter(queryString) + "\""); } else { writer.write(" currentQueryString=\"&#63;\""); } writer.write(" protocol=\"" + filter(mBeanServer.getAttribute(pName, "protocol")) + "\""); } else { writer.write(" method=\"&#63;\""); writer.write(" currentUri=\"&#63;\""); writer.write(" currentQueryString=\"&#63;\""); writer.write(" protocol=\"&#63;\""); } } else { writer.write(" requestProcessingTime=\"0\""); writer.write(" requestBytesSent=\"0\""); writer.write(" requestBytesRecieved=\"0\""); writer.write(" remoteAddr=\"&#63;\""); writer.write(" virtualHost=\"&#63;\""); writer.write(" method=\"&#63;\""); writer.write(" currentUri=\"&#63;\""); writer.write(" currentQueryString=\"&#63;\""); writer.write(" protocol=\"&#63;\""); } writer.write(" />"); } }
@Override public Void call() throws LifecycleException { child.start(); return null; }
public static PoolConfiguration parsePoolProperties(Properties properties) { PoolConfiguration poolProperties = new PoolProperties(); String value = null; value = properties.getProperty(PROP_DEFAULTAUTOCOMMIT); if (value != null) { poolProperties.setDefaultAutoCommit(Boolean.valueOf(value)); } value = properties.getProperty(PROP_DEFAULTREADONLY); if (value != null) { poolProperties.setDefaultReadOnly(Boolean.valueOf(value)); } value = properties.getProperty(PROP_DEFAULTTRANSACTIONISOLATION); if (value != null) { int level = UNKNOWN_TRANSACTIONISOLATION; if ("NONE".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_NONE; } else if ("READ_COMMITTED".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_READ_COMMITTED; } else if ("READ_UNCOMMITTED".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_READ_UNCOMMITTED; } else if ("REPEATABLE_READ".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_REPEATABLE_READ; } else if ("SERIALIZABLE".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_SERIALIZABLE; } else { try { level = Integer.parseInt(value); } catch (NumberFormatException e) { System.err.println("Could not parse defaultTransactionIsolation: " + value); System.err.println("WARNING: defaultTransactionIsolation not set"); System.err.println("using default value of database driver"); level = UNKNOWN_TRANSACTIONISOLATION; } } poolProperties.setDefaultTransactionIsolation(level); } value = properties.getProperty(PROP_DEFAULTCATALOG); if (value != null) { poolProperties.setDefaultCatalog(value); } value = properties.getProperty(PROP_DRIVERCLASSNAME); if (value != null) { poolProperties.setDriverClassName(value); } value = properties.getProperty(PROP_MAXACTIVE); if (value != null) { poolProperties.setMaxActive(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXIDLE); if (value != null) { poolProperties.setMaxIdle(Integer.parseInt(value)); } value = properties.getProperty(PROP_MINIDLE); if (value != null) { poolProperties.setMinIdle(Integer.parseInt(value)); } value = properties.getProperty(PROP_INITIALSIZE); if (value != null) { poolProperties.setInitialSize(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXWAIT); if (value != null) { poolProperties.setMaxWait(Integer.parseInt(value)); } value = properties.getProperty(PROP_TESTONBORROW); if (value != null) { poolProperties.setTestOnBorrow(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TESTONRETURN); if (value != null) { poolProperties.setTestOnReturn(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TESTONCONNECT); if (value != null) { poolProperties.setTestOnConnect(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TIMEBETWEENEVICTIONRUNSMILLIS); if (value != null) { poolProperties.setTimeBetweenEvictionRunsMillis(Integer.parseInt(value)); } value = properties.getProperty(PROP_NUMTESTSPEREVICTIONRUN); if (value != null) { poolProperties.setNumTestsPerEvictionRun(Integer.parseInt(value)); } value = properties.getProperty(PROP_MINEVICTABLEIDLETIMEMILLIS); if (value != null) { poolProperties.setMinEvictableIdleTimeMillis(Integer.parseInt(value)); } value = properties.getProperty(PROP_TESTWHILEIDLE); if (value != null) { poolProperties.setTestWhileIdle(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_PASSWORD); if (value != null) { poolProperties.setPassword(value); } value = properties.getProperty(PROP_URL); if (value != null) { poolProperties.setUrl(value); } value = properties.getProperty(PROP_USERNAME); if (value != null) { poolProperties.setUsername(value); } value = properties.getProperty(PROP_VALIDATIONQUERY); if (value != null) { poolProperties.setValidationQuery(value); } value = properties.getProperty(PROP_VALIDATOR_CLASS_NAME); if (value != null) { poolProperties.setValidatorClassName(value); } value = properties.getProperty(PROP_VALIDATIONINTERVAL); if (value != null) { poolProperties.setValidationInterval(Long.parseLong(value)); } value = properties.getProperty(PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED); if (value != null) { poolProperties.setAccessToUnderlyingConnectionAllowed(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_REMOVEABANDONED); if (value != null) { poolProperties.setRemoveAbandoned(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_REMOVEABANDONEDTIMEOUT); if (value != null) { poolProperties.setRemoveAbandonedTimeout(Integer.parseInt(value)); } value = properties.getProperty(PROP_LOGABANDONED); if (value != null) { poolProperties.setLogAbandoned(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_POOLPREPAREDSTATEMENTS); if (value != null) { log.warn(PROP_POOLPREPAREDSTATEMENTS + " is not a valid setting, it will have no effect."); } value = properties.getProperty(PROP_MAXOPENPREPAREDSTATEMENTS); if (value != null) { log.warn(PROP_MAXOPENPREPAREDSTATEMENTS + " is not a valid setting, it will have no effect."); } value = properties.getProperty(PROP_CONNECTIONPROPERTIES); if (value != null) { Properties p = getProperties(value); poolProperties.setDbProperties(p); } else { poolProperties.setDbProperties(new Properties()); } if (poolProperties.getUsername() != null) { poolProperties.getDbProperties().setProperty("user", poolProperties.getUsername()); } if (poolProperties.getPassword() != null) { poolProperties.getDbProperties().setProperty("password", poolProperties.getPassword()); } value = properties.getProperty(PROP_INITSQL); if (value != null) { poolProperties.setInitSQL(value); } value = properties.getProperty(PROP_INTERCEPTORS); if (value != null) { poolProperties.setJdbcInterceptors(value); } value = properties.getProperty(PROP_JMX_ENABLED); if (value != null) { poolProperties.setJmxEnabled(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_FAIR_QUEUE); if (value != null) { poolProperties.setFairQueue(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_USE_EQUALS); if (value != null) { poolProperties.setUseEquals(Boolean.parseBoolean(value)); } value = properties.getProperty(OBJECT_NAME); if (value != null) { poolProperties.setName(ObjectName.quote(value)); } value = properties.getProperty(PROP_ABANDONWHENPERCENTAGEFULL); if (value != null) { poolProperties.setAbandonWhenPercentageFull(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXAGE); if (value != null) { poolProperties.setMaxAge(Long.parseLong(value)); } value = properties.getProperty(PROP_USE_CON_LOCK); if (value != null) { poolProperties.setUseLock(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_DATASOURCE); if (value != null) { throw new IllegalArgumentException("Can't set dataSource property as a string, this must be a javax.sql.DataSource object."); } value = properties.getProperty(PROP_DATASOURCE_JNDI); if (value != null) { poolProperties.setDataSourceJNDI(value); } value = properties.getProperty(PROP_SUSPECT_TIMEOUT); if (value != null) { poolProperties.setSuspectTimeout(Integer.parseInt(value)); } value = properties.getProperty(PROP_ALTERNATE_USERNAME_ALLOWED); if (value != null) { poolProperties.setAlternateUsernameAllowed(Boolean.parseBoolean(value)); } return poolProperties; }
public void doTestLookup(boolean useSingletonResource) throws Exception { Tomcat tomcat = getTomcatInstance(); tomcat.enableNaming(); StandardContext ctx = (StandardContext) tomcat.addContext("", System.getProperty("java.io.tmpdir")); ContextResource cr = new ContextResource(); cr.setName("list/foo"); cr.setType("org.apache.naming.resources.TesterObject"); cr.setProperty("factory", "org.apache.naming.resources.TesterFactory"); cr.setSingleton(useSingletonResource); ctx.getNamingResources().addResource(cr); Bug49994Servlet bug49994Servlet = new Bug49994Servlet(); Tomcat.addServlet(ctx, "bug49994Servlet", bug49994Servlet); ctx.addServletMapping("/", "bug49994Servlet"); tomcat.start(); ByteChunk bc = getUrl("http://localhost:" + getPort() + "/"); String expected; if (useSingletonResource) { expected = "EQUAL"; } else { expected = "NOTEQUAL"; } assertEquals(expected, bc.toString()); }	public void setAliases(String theAliases) { aliases.clear(); if (theAliases == null || theAliases.length() == 0) return; String[] kvps = theAliases.split(","); for (String kvp : kvps) { String[] kv = kvp.split("="); if (kv.length != 2 || kv[0].length() == 0 || kv[1].length() == 0) throw new IllegalArgumentException(sm.getString("resources.invalidAliasMapping", kvp)); if (kv[0].equals("/")) { throw new IllegalArgumentException(sm.getString("resources.invalidAliasNotAllowed", kv[0])); } File aliasLoc = new File(kv[1]); if (!aliasLoc.exists()) { throw new IllegalArgumentException(sm.getString("resources.invalidAliasNotExist", kv[1])); } BaseDirContext context; if (kv[1].endsWith(".war") && !(aliasLoc.isDirectory())) { context = new WARDirContext(); } else if (aliasLoc.isDirectory()) { context = new FileDirContext(); } else { throw new IllegalArgumentException(sm.getString("resources.invalidAliasFile", kv[1])); } context.setDocBase(kv[1]); addAlias(kv[0], context); } }
protected PooledConnection borrowConnection(long now, PooledConnection con, String username, String password) throws SQLException { //we have a connection, lets set it up boolean setToNull = false; try { con.lock(); boolean usercheck = con.checkUser(username, password); if (con.isReleased()) { return null; } if (!con.isDiscarded() && !con.isInitialized()) { con.connect(); } if (usercheck) { if ((!con.isDiscarded()) && con.validate(PooledConnection.VALIDATE_BORROW)) { con.setTimestamp(now); if (getPoolProperties().isLogAbandoned()) { con.setStackTrace(getThreadDump()); } if (!busy.offer(con)) { log.debug("Connection doesn't fit into busy array, connection will not be traceable."); } return con; } } try { con.reconnect(); if (con.validate(PooledConnection.VALIDATE_INIT)) { con.setTimestamp(now); if (getPoolProperties().isLogAbandoned()) { con.setStackTrace(getThreadDump()); } if (!busy.offer(con)) { log.debug("Connection doesn't fit into busy array, connection will not be traceable."); } return con; } else { release(con); setToNull = true; throw new SQLException("Failed to validate a newly established connection."); } } catch (Exception x) { release(con); setToNull = true; if (x instanceof SQLException) { throw (SQLException) x; } else { SQLException ex = new SQLException(x.getMessage()); ex.initCause(x); throw ex; } } } finally { con.unlock(); if (setToNull) { con = null; } } }	protected void connectUsingDriver() throws SQLException { try { if (driver == null) driver = (java.sql.Driver) Class.forName(poolProperties.getDriverClassName(), true, PooledConnection.class.getClassLoader()).newInstance(); } catch (java.lang.Exception cn) { if (log.isDebugEnabled()) { log.debug("Unable to instantiate JDBC driver.", cn); } SQLException ex = new SQLException(cn.getMessage()); ex.initCause(cn); throw ex; } String driverURL = poolProperties.getUrl(); String usr = null; String pwd = null; if (getAttributes().containsKey(PROP_USER)) { usr = (String) getAttributes().get(PROP_USER); } else { usr = poolProperties.getUsername(); getAttributes().put(PROP_USER, usr); } if (getAttributes().containsKey(PROP_PASSWORD)) { pwd = (String) getAttributes().get(PROP_PASSWORD); } else { pwd = poolProperties.getPassword(); getAttributes().put(PROP_PASSWORD, pwd); } Properties properties = PoolUtilities.clone(poolProperties.getDbProperties()); if (usr != null) properties.setProperty(PROP_USER, usr); if (pwd != null) properties.setProperty(PROP_PASSWORD, pwd); try { connection = driver.connect(driverURL, properties); } catch (Exception x) { if (log.isDebugEnabled()) { log.debug("Unable to connect to database.", x); } if (parent.jmxPool != null) { parent.jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_CONNECT, ConnectionPool.getStackTrace(x)); } if (x instanceof SQLException) { throw (SQLException) x; } else { SQLException ex = new SQLException(x.getMessage()); ex.initCause(x); throw ex; } } if (connection == null) { throw new SQLException("Driver:" + driver + " returned null for URL:" + driverURL); } }
protected void addExtension(final String extension) { if (extension != null) { if (extensions == null) { extensions = new Vector<String>(); } extensions.add(extension); } }	public static void main(String[] arg) { if (arg.length == 0) { System.out.println(Localizer.getMessage("jspc.usage")); } else { JspC jspc = new JspC(); try { jspc.setArgs(arg); if (jspc.helpNeeded) { System.out.println(Localizer.getMessage("jspc.usage")); } else { jspc.execute(); } } catch (JasperException je) { System.err.println(je); if (jspc.dieLevel != NO_DIE_LEVEL) { System.exit(jspc.dieLevel); } } } }	public void execute() throws JasperException { if (log.isDebugEnabled()) { log.debug("execute() starting for " + pages.size() + " pages."); } try { if (uriRoot == null) { if (pages.size() == 0) { throw new JasperException(Localizer.getMessage("jsp.error.jspc.missingTarget")); } String firstJsp = pages.get(0); File firstJspF = new File(firstJsp); if (!firstJspF.exists()) { throw new JasperException(Localizer.getMessage("jspc.error.fileDoesNotExist", firstJsp)); } locateUriRoot(firstJspF); } if (uriRoot == null) { throw new JasperException(Localizer.getMessage("jsp.error.jspc.no_uriroot")); } File uriRootF = new File(uriRoot); if (!uriRootF.isDirectory()) { throw new JasperException(Localizer.getMessage("jsp.error.jspc.uriroot_not_dir")); } if (context == null) { initServletContext(); } if (pages.size() == 0) { scanFiles(uriRootF); } initWebXml(); Iterator<String> iter = pages.iterator(); while (iter.hasNext()) { String nextjsp = iter.next().toString(); File fjsp = new File(nextjsp); if (!fjsp.isAbsolute()) { fjsp = new File(uriRootF, nextjsp); } if (!fjsp.exists()) { if (log.isWarnEnabled()) { log.warn(Localizer.getMessage("jspc.error.fileDoesNotExist", fjsp.toString())); } continue; } String s = fjsp.getAbsolutePath(); if (s.startsWith(uriRoot)) { nextjsp = s.substring(uriRoot.length()); } if (nextjsp.startsWith("." + File.separatorChar)) { nextjsp = nextjsp.substring(2); } processFile(nextjsp); } completeWebXml(); if (addWebXmlMappings) { mergeIntoWebXml(); } } catch (IOException ioe) { throw new JasperException(ioe); } catch (JasperException je) { Throwable rootCause = je; while (rootCause instanceof JasperException && ((JasperException) rootCause).getRootCause() != null) { rootCause = ((JasperException) rootCause).getRootCause(); } if (rootCause != je) { rootCause.printStackTrace(); } throw je; } finally { if (loader != null) { LogFactory.release(loader); } } }	public void scanFiles(File base) throws JasperException { Stack<String> dirs = new Stack<String>(); dirs.push(base.toString()); if ((getExtensions() == null) || (getExtensions().size() < 2)) { addExtension("jsp"); addExtension("jspx"); } while (!dirs.isEmpty()) { String s = dirs.pop(); File f = new File(s); if (f.exists() && f.isDirectory()) { String[] files = f.list(); String ext; for (int i = 0; (files != null) && i < files.length; i++) { File f2 = new File(s, files[i]); if (f2.isDirectory()) { dirs.push(f2.getPath()); } else { String path = f2.getPath(); String uri = path.substring(uriRoot.length()); ext = files[i].substring(files[i].lastIndexOf('.') + 1); if (getExtensions().contains(ext) || jspConfig.isJspPage(uri)) { pages.add(path); } } } } } }
@Override public Session createSession(String sessionId) { if ((maxActiveSessions >= 0) && (getActiveSessions() >= maxActiveSessions)) { rejectedSessions++; throw new IllegalStateException(sm.getString("managerBase.createSession.ise")); } Session session = createEmptySession(); session.setNew(true); session.setValid(true); session.setCreationTime(System.currentTimeMillis()); session.setMaxInactiveInterval(this.maxInactiveInterval); String id = sessionId; if (id == null) { id = generateSessionId(); } session.setId(id); sessionCounter++; SessionTiming timing = new SessionTiming(session.getCreationTime(), 0); synchronized (sessionCreationTiming) { sessionCreationTiming.add(timing); sessionCreationTiming.poll(); } return (session); }
protected Map<String, String> processAnnotationWebInitParams(ElementValue ev) { Map<String, String> result = new HashMap<String, String>(); if (ev instanceof ArrayElementValue) { ElementValue[] arrayValues = ((ArrayElementValue) ev).getElementValuesArray(); for (ElementValue value : arrayValues) { if (value instanceof AnnotationElementValue) { ElementValuePair[] evps = ((AnnotationElementValue) value).getAnnotationEntry().getElementValuePairs(); String initParamName = null; String initParamValue = null; for (ElementValuePair evp : evps) { if ("name".equals(evp.getNameString())) { initParamName = evp.getValue().stringifyValue(); } else if ("value".equals(evp.getNameString())) { initParamValue = evp.getValue().stringifyValue(); } else { // Ignore } } result.put(initParamName, initParamValue); } } } return result; }
private void closeOutboundConnection(WsFrame frame) throws IOException { try { getWsOutbound().close(frame); } finally { onClose(Constants.OPCODE_CLOSE); } }	private void closeOutboundConnection(int status, ByteBuffer data) throws IOException { try { getWsOutbound().close(status, data); } finally { onClose(status); } }	@Override public final SocketState onData() throws IOException { // Must be start the start of a message (which may consist of multiple WsInputStream wsIs = new WsInputStream(processor, getWsOutbound()); try { WsFrame frame = wsIs.nextFrame(true); while (frame != null) { if (frame.getRsv() > 0) { closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR, null); return SocketState.CLOSED; } byte opCode = frame.getOpCode(); if (opCode == Constants.OPCODE_BINARY) { onBinaryData(wsIs); } else if (opCode == Constants.OPCODE_TEXT) { InputStreamReader r = new InputStreamReader(wsIs, new Utf8Decoder()); onTextData(r); } else if (opCode == Constants.OPCODE_CLOSE) { closeOutboundConnection(frame); return SocketState.CLOSED; } else if (opCode == Constants.OPCODE_PING) { getWsOutbound().pong(frame.getPayLoad()); } else if (opCode == Constants.OPCODE_PONG) { // NO-OP } else { closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR, null); return SocketState.CLOSED; } frame = wsIs.nextFrame(false); } } catch (MalformedInputException mie) { closeOutboundConnection(Constants.STATUS_BAD_DATA, null); return SocketState.CLOSED; } catch (UnmappableCharacterException uce) { closeOutboundConnection(Constants.STATUS_BAD_DATA, null); return SocketState.CLOSED; } catch (IOException ioe) { // Given something must have gone to reach this point, this closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR, null); return SocketState.CLOSED; } return SocketState.UPGRADED; }	@Test public void testDetectWrongVersion() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File(getBuildDirectory(), "webapps/examples"); tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); tomcat.start(); WebSocketClient client = new WebSocketClient(getPort()); client.writer.write("GET /examples/websocket/echoStream HTTP/1.1" + CRLF); client.writer.write("Host: foo" + CRLF); client.writer.write("Upgrade: websocket" + CRLF); client.writer.write("Connection: upgrade" + CRLF); client.writer.write("Sec-WebSocket-Version: 8" + CRLF); client.writer.write("Sec-WebSocket-Key: TODO" + CRLF); client.writer.write(CRLF); client.writer.flush(); String responseLine = client.reader.readLine(); assertTrue(responseLine.startsWith("HTTP/1.1 426")); List<String> headerlines = new ArrayList<String>(); String responseHeaderLine = client.reader.readLine(); while (!responseHeaderLine.equals("")) { headerlines.add(responseHeaderLine); responseHeaderLine = client.reader.readLine(); } assertTrue(headerlines.contains("Sec-WebSocket-Version: 13")); client.close(); }	@Test public void testKey() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File(getBuildDirectory(), "webapps/examples"); tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); tomcat.start(); WebSocketClient client = new WebSocketClient(getPort()); client.writer.write("GET /examples/websocket/echoStream HTTP/1.1" + CRLF); client.writer.write("Host: foo" + CRLF); client.writer.write("Upgrade: websocket" + CRLF); client.writer.write("Connection: upgrade" + CRLF); client.writer.write("Sec-WebSocket-Version: 13" + CRLF); client.writer.write("Sec-WebSocket-Key: TODO" + CRLF); client.writer.write(CRLF); client.writer.flush(); String responseLine = client.reader.readLine(); assertTrue(responseLine.startsWith("HTTP/1.1 101")); String accept = null; String responseHeaderLine = client.reader.readLine(); while (!responseHeaderLine.equals("")) { if (responseHeaderLine.startsWith("Sec-WebSocket-Accept: ")) { accept = responseHeaderLine.substring(responseHeaderLine.indexOf(":") + 2); break; } responseHeaderLine = client.reader.readLine(); } assertTrue(accept != null); MessageDigest sha1Helper = MessageDigest.getInstance("SHA1"); sha1Helper.reset(); sha1Helper.update("TODO".getBytes(B2CConverter.ISO_8859_1)); String source = Base64.encode(sha1Helper.digest(WS_ACCEPT)); assertEquals(source, accept); sha1Helper.reset(); sha1Helper.update("TOD".getBytes(B2CConverter.ISO_8859_1)); source = Base64.encode(sha1Helper.digest(WS_ACCEPT)); assertFalse(source.equals(accept)); client.close(); }
private void doTestBasic(String user, String pwd, String uri, boolean expectedReject1, int expectedRC1, boolean expectedReject2, int expectedRC2) throws Exception { Map<String, List<String>> reqHeaders1 = new HashMap<String, List<String>>(); Map<String, List<String>> respHeaders1 = new HashMap<String, List<String>>(); ByteChunk bc = new ByteChunk(); int rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders1, respHeaders1); if (expectedReject1) { assertEquals(expectedRC1, rc); assertTrue(bc.getLength() > 0); } else { assertEquals(200, rc); assertEquals("OK", bc.toString()); return; } String credentials = user + ":" + pwd; byte[] credentialsBytes = ByteChunk.convertToBytes(credentials); String base64auth = Base64.encode(credentialsBytes); String authLine = "Basic " + base64auth; List<String> auth = new ArrayList<String>(); auth.add(authLine); Map<String, List<String>> reqHeaders2 = new HashMap<String, List<String>>(); reqHeaders2.put(CLIENT_AUTH_HEADER, auth); Map<String, List<String>> respHeaders2 = new HashMap<String, List<String>>(); bc.recycle(); rc = getUrl(HTTP_PREFIX + getPort() + uri, bc, reqHeaders2, respHeaders2); if (expectedReject2) { assertEquals(expectedRC2, rc); assertTrue(bc.getLength() > 0); } else { assertEquals(200, rc); assertEquals("OK", bc.toString()); } }	@Test public void testAcceptProtectedBasic() throws Exception { doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED, true, 401, false, 200); }	@Test public void testAcceptPublicBasic() throws Exception { doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PUBLIC, false, 200, false, 200); }	@Test public void testBasicLoginRejectProtected() throws Exception { doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED, true, 401, false, 200); doTestNonLogin(CONTEXT_PATH_NOLOGIN + URI_PROTECTED, true, 403); }	@Test public void testBasicLoginSessionTimeout() throws Exception { doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED, true, 401, false, 200); Thread.sleep(LONG_TIMEOUT_DELAY_MSECS); doTestBasic(USER, PWD, CONTEXT_PATH_LOGIN + URI_PROTECTED, true, 401, false, 200); }
private void doForward(ServletRequest request, ServletResponse response) throws ServletException, IOException { if (response.isCommitted()) { throw new IllegalStateException(sm.getString("applicationDispatcher.forward.ise")); } try { response.resetBuffer(); } catch (IllegalStateException e) { throw e; } State state = new State(request, response, false); if (WRAP_SAME_OBJECT) { checkSameObjects(request, response); } wrapResponse(state); if ((servletPath == null) && (pathInfo == null)) { ApplicationHttpRequest wrequest = (ApplicationHttpRequest) wrapRequest(state); HttpServletRequest hrequest = state.hrequest; wrequest.setRequestURI(hrequest.getRequestURI()); wrequest.setContextPath(hrequest.getContextPath()); wrequest.setServletPath(hrequest.getServletPath()); wrequest.setPathInfo(hrequest.getPathInfo()); wrequest.setQueryString(hrequest.getQueryString()); processRequest(request, response, state); } else { ApplicationHttpRequest wrequest = (ApplicationHttpRequest) wrapRequest(state); String contextPath = context.getPath(); HttpServletRequest hrequest = state.hrequest; if (hrequest.getAttribute(RequestDispatcher.FORWARD_REQUEST_URI) == null) { wrequest.setAttribute(RequestDispatcher.FORWARD_REQUEST_URI, hrequest.getRequestURI()); wrequest.setAttribute(RequestDispatcher.FORWARD_CONTEXT_PATH, hrequest.getContextPath()); wrequest.setAttribute(RequestDispatcher.FORWARD_SERVLET_PATH, hrequest.getServletPath()); wrequest.setAttribute(RequestDispatcher.FORWARD_PATH_INFO, hrequest.getPathInfo()); wrequest.setAttribute(RequestDispatcher.FORWARD_QUERY_STRING, hrequest.getQueryString()); } wrequest.setContextPath(contextPath); wrequest.setRequestURI(requestURI); wrequest.setServletPath(servletPath); wrequest.setPathInfo(pathInfo); if (queryString != null) { wrequest.setQueryString(queryString); wrequest.setQueryParams(queryString); } processRequest(request, response, state); } if (wrapper.getLogger().isDebugEnabled()) wrapper.getLogger().debug(" Disabling the response for futher output"); if (response instanceof ResponseFacade) { ((ResponseFacade) response).finish(); } else { if (wrapper.getLogger().isDebugEnabled()) { wrapper.getLogger().debug(" The Response is vehiculed using a wrapper: " + response.getClass().getName()); } try { PrintWriter writer = response.getWriter(); writer.close(); } catch (IllegalStateException e) { try { ServletOutputStream stream = response.getOutputStream(); stream.close(); } catch (IllegalStateException f) { // Ignore } catch (IOException f) { // Ignore } } catch (IOException e) { // Ignore } } }	private void doTestBug51197(boolean threaded) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); AsyncErrorServlet asyncErrorServlet = new AsyncErrorServlet(HttpServletResponse.SC_BAD_REQUEST, threaded); Wrapper wrapper = Tomcat.addServlet(ctx, "asyncErrorServlet", asyncErrorServlet); wrapper.setAsyncSupported(true); ctx.addServletMapping("/asyncErrorServlet", "asyncErrorServlet"); TesterAccessLogValve alv = new TesterAccessLogValve(); ctx.getPipeline().addValve(alv); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/asyncErrorServlet"); ByteChunk res = new ByteChunk(); int rc = getUrl(url.toString(), res, null); assertEquals(HttpServletResponse.SC_BAD_REQUEST, rc); if (threaded) { assertEquals(0, res.getLength()); } else { assertTrue(res.getLength() > 0); } // Without this test may complete before access log has a chance to log Thread.sleep(REQUEST_TIME); alv.validateAccessLog(1, HttpServletResponse.SC_BAD_REQUEST, 0, REQUEST_TIME); }
@Override public synchronized Servlet loadServlet() throws ServletException { if (singleThreadModel) { Servlet instance; try { instance = existing.getClass().newInstance(); } catch (InstantiationException e) { throw new ServletException(e); } catch (IllegalAccessException e) { throw new ServletException(e); } instance.init(facade); return instance; } else { if (!init) { existing.init(facade); init = true; } return existing; } }	public void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException { res.getWriter().write("Hello world"); }	public static void initWebappDefaults(Context ctx) { Wrapper servlet = addServlet(ctx, "default", "org.apache.catalina.servlets.DefaultServlet"); servlet.setLoadOnStartup(1); servlet = addServlet(ctx, "jsp", "org.apache.jasper.servlet.JspServlet"); servlet.addInitParameter("fork", "false"); servlet.setLoadOnStartup(3); ctx.addServletMapping("/", "default"); ctx.addServletMapping("*.jsp", "jsp"); ctx.addServletMapping("*.jspx", "jsp"); ctx.setSessionTimeout(30); for (int i = 0; i < DEFAULT_MIME_MAPPINGS.length; ) { ctx.addMimeMapping(DEFAULT_MIME_MAPPINGS[i++], DEFAULT_MIME_MAPPINGS[i++]); } ctx.addWelcomeFile("index.html"); ctx.addWelcomeFile("index.htm"); ctx.addWelcomeFile("index.jsp"); }	@Test public void testBug50826() throws Exception { Tomcat tomcat = getTomcatInstance(); String contextPath = "/examples"; File appDir = new File(getBuildDirectory(), "webapps" + contextPath); tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); Exception e = null; try { tomcat.destroy(); } catch (Exception ex) { ex.printStackTrace(); e = ex; } assertNull(e); }
@Override public void addRuleInstances(Digester digester) { digester.addRule(fullPrefix, new SetPublicIdRule("setPublicId")); digester.addRule(fullPrefix, new IgnoreAnnotationsRule()); digester.addRule(fullPrefix, new VersionRule()); digester.addRule(fullPrefix + "/absolute-ordering", absoluteOrdering); digester.addRule(fullPrefix + "/ordering", relativeOrdering); if (fragment) { digester.addRule(fullPrefix + "/name", name); digester.addCallMethod(fullPrefix + "/ordering/after/name", "addAfterOrdering", 0); digester.addCallMethod(fullPrefix + "/ordering/after/others", "addAfterOrderingOthers"); digester.addCallMethod(fullPrefix + "/ordering/before/name", "addBeforeOrdering", 0); digester.addCallMethod(fullPrefix + "/ordering/before/others", "addBeforeOrderingOthers"); } else { digester.addCallMethod(fullPrefix + "/absolute-ordering/name", "addAbsoluteOrdering", 0); digester.addCallMethod(fullPrefix + "/absolute-ordering/others", "addAbsoluteOrderingOthers"); } digester.addCallMethod(fullPrefix + "/context-param", "addContextParam", 2); digester.addCallParam(fullPrefix + "/context-param/param-name", 0); digester.addCallParam(fullPrefix + "/context-param/param-value", 1); digester.addCallMethod(fullPrefix + "/display-name", "setDisplayName", 0); digester.addRule(fullPrefix + "/distributable", new SetDistributableRule()); configureNamingRules(digester); digester.addObjectCreate(fullPrefix + "/error-page", "org.apache.catalina.deploy.ErrorPage"); digester.addSetNext(fullPrefix + "/error-page", "addErrorPage", "org.apache.catalina.deploy.ErrorPage"); digester.addCallMethod(fullPrefix + "/error-page/error-code", "setErrorCode", 0); digester.addCallMethod(fullPrefix + "/error-page/exception-type", "setExceptionType", 0); digester.addCallMethod(fullPrefix + "/error-page/location", "setLocation", 0); digester.addObjectCreate(fullPrefix + "/filter", "org.apache.catalina.deploy.FilterDef"); digester.addSetNext(fullPrefix + "/filter", "addFilter", "org.apache.catalina.deploy.FilterDef"); digester.addCallMethod(fullPrefix + "/filter/description", "setDescription", 0); digester.addCallMethod(fullPrefix + "/filter/display-name", "setDisplayName", 0); digester.addCallMethod(fullPrefix + "/filter/filter-class", "setFilterClass", 0); digester.addCallMethod(fullPrefix + "/filter/filter-name", "setFilterName", 0); digester.addCallMethod(fullPrefix + "/filter/icon/large-icon", "setLargeIcon", 0); digester.addCallMethod(fullPrefix + "/filter/icon/small-icon", "setSmallIcon", 0); digester.addCallMethod(fullPrefix + "/filter/async-supported", "setAsyncSupported", 0); digester.addCallMethod(fullPrefix + "/filter/init-param", "addInitParameter", 2); digester.addCallParam(fullPrefix + "/filter/init-param/param-name", 0); digester.addCallParam(fullPrefix + "/filter/init-param/param-value", 1); digester.addObjectCreate(fullPrefix + "/filter-mapping", "org.apache.catalina.deploy.FilterMap"); digester.addSetNext(fullPrefix + "/filter-mapping", "addFilterMapping", "org.apache.catalina.deploy.FilterMap"); digester.addCallMethod(fullPrefix + "/filter-mapping/filter-name", "setFilterName", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/servlet-name", "addServletName", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/url-pattern", "addURLPattern", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/dispatcher", "setDispatcher", 0); digester.addCallMethod(fullPrefix + "/listener/listener-class", "addListener", 0); digester.addRule(fullPrefix + "/jsp-config", jspConfig); digester.addObjectCreate(fullPrefix + "/jsp-config/jsp-property-group", "org.apache.catalina.deploy.JspPropertyGroup"); digester.addSetNext(fullPrefix + "/jsp-config/jsp-property-group", "addJspPropertyGroup", "org.apache.catalina.deploy.JspPropertyGroup"); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/deferred-syntax-allowed-as-literal", "setDeferredSyntax", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/el-ignored", "setElIgnored", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/include-coda", "addIncludeCoda", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/include-prelude", "addIncludePrelude", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/is-xml", "setIsXml", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/page-encoding", "setPageEncoding", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/scripting-invalid", "setScriptingInvalid", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/trim-directive-whitespaces", "setTrimWhitespace", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/url-pattern", "setUrlPattern", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/default-content-type", "setDefaultContentType", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/buffer", "setBuffer", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/error-on-undeclared-namespace", "setErrorOnUndeclaredNamespace", 0); digester.addRule(fullPrefix + "/login-config", loginConfig); digester.addObjectCreate(fullPrefix + "/login-config", "org.apache.catalina.deploy.LoginConfig"); digester.addSetNext(fullPrefix + "/login-config", "setLoginConfig", "org.apache.catalina.deploy.LoginConfig"); digester.addCallMethod(fullPrefix + "/login-config/auth-method", "setAuthMethod", 0); digester.addCallMethod(fullPrefix + "/login-config/realm-name", "setRealmName", 0); digester.addCallMethod(fullPrefix + "/login-config/form-login-config/form-error-page", "setErrorPage", 0); digester.addCallMethod(fullPrefix + "/login-config/form-login-config/form-login-page", "setLoginPage", 0); digester.addCallMethod(fullPrefix + "/mime-mapping", "addMimeMapping", 2); digester.addCallParam(fullPrefix + "/mime-mapping/extension", 0); digester.addCallParam(fullPrefix + "/mime-mapping/mime-type", 1); digester.addObjectCreate(fullPrefix + "/security-constraint", "org.apache.catalina.deploy.SecurityConstraint"); digester.addSetNext(fullPrefix + "/security-constraint", "addSecurityConstraint", "org.apache.catalina.deploy.SecurityConstraint"); digester.addRule(fullPrefix + "/security-constraint/auth-constraint", new SetAuthConstraintRule()); digester.addCallMethod(fullPrefix + "/security-constraint/auth-constraint/role-name", "addAuthRole", 0); digester.addCallMethod(fullPrefix + "/security-constraint/display-name", "setDisplayName", 0); digester.addCallMethod(fullPrefix + "/security-constraint/user-data-constraint/transport-guarantee", "setUserConstraint", 0); digester.addObjectCreate(fullPrefix + "/security-constraint/web-resource-collection", "org.apache.catalina.deploy.SecurityCollection"); digester.addSetNext(fullPrefix + "/security-constraint/web-resource-collection", "addCollection", "org.apache.catalina.deploy.SecurityCollection"); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/http-method", "addMethod", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/http-method-omission", "addOmittedMethod", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/url-pattern", "addPattern", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/web-resource-name", "setName", 0); digester.addCallMethod(fullPrefix + "/security-role/role-name", "addSecurityRole", 0); digester.addRule(fullPrefix + "/servlet", new ServletDefCreateRule()); digester.addSetNext(fullPrefix + "/servlet", "addServlet", "org.apache.catalina.deploy.ServletDef"); digester.addCallMethod(fullPrefix + "/servlet/init-param", "addInitParameter", 2); digester.addCallParam(fullPrefix + "/servlet/init-param/param-name", 0); digester.addCallParam(fullPrefix + "/servlet/init-param/param-value", 1); digester.addCallMethod(fullPrefix + "/servlet/jsp-file", "setJspFile", 0); digester.addCallMethod(fullPrefix + "/servlet/load-on-startup", "setLoadOnStartup", 0); digester.addCallMethod(fullPrefix + "/servlet/run-as/role-name", "setRunAs", 0); digester.addCallMethod(fullPrefix + "/servlet/security-role-ref", "addSecurityRoleRef", 2); digester.addCallParam(fullPrefix + "/servlet/security-role-ref/role-link", 1); digester.addCallParam(fullPrefix + "/servlet/security-role-ref/role-name", 0); digester.addCallMethod(fullPrefix + "/servlet/servlet-class", "setServletClass", 0); digester.addCallMethod(fullPrefix + "/servlet/servlet-name", "setServletName", 0); digester.addObjectCreate(fullPrefix + "/servlet/multipart-config", "org.apache.catalina.deploy.MultipartDef"); digester.addSetNext(fullPrefix + "/servlet/multipart-config", "setMultipartDef", "org.apache.catalina.deploy.MultipartDef"); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/location", "setLocation", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/max-file-size", "setMaxFileSize", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/max-request-size", "setMaxRequestSize", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/file-size-threshold", "setFileSizeThreshold", 0); digester.addCallMethod(fullPrefix + "/servlet/async-supported", "setAsyncSupported", 0); digester.addCallMethod(fullPrefix + "/servlet/enabled", "setEnabled", 0); digester.addRule(fullPrefix + "/servlet-mapping", new CallMethodMultiRule("addServletMapping", 2, 0)); digester.addCallParam(fullPrefix + "/servlet-mapping/servlet-name", 1); digester.addRule(fullPrefix + "/servlet-mapping/url-pattern", new CallParamMultiRule(0)); digester.addRule(fullPrefix + "/session-config", sessionConfig); digester.addObjectCreate(fullPrefix + "/session-config", "org.apache.catalina.deploy.SessionConfig"); digester.addSetNext(fullPrefix + "/session-config", "setSessionConfig", "org.apache.catalina.deploy.SessionConfig"); digester.addCallMethod(fullPrefix + "/session-config/session-timeout", "setSessionTimeout", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/name", "setCookieName", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/domain", "setCookieDomain", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/path", "setCookiePath", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/comment", "setCookieComment", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/http-only", "setCookieHttpOnly", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/secure", "setCookieSecure", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/max-age", "setCookieMaxAge", 0); digester.addCallMethod(fullPrefix + "/session-config/tracking-mode", "addSessionTrackingMode", 0); digester.addRule(fullPrefix + "/taglib", new TaglibLocationRule(false)); digester.addCallMethod(fullPrefix + "/taglib", "addTaglib", 2); digester.addCallParam(fullPrefix + "/taglib/taglib-location", 1); digester.addCallParam(fullPrefix + "/taglib/taglib-uri", 0); digester.addRule(fullPrefix + "/jsp-config/taglib", new TaglibLocationRule(true)); digester.addCallMethod(fullPrefix + "/jsp-config/taglib", "addTaglib", 2); digester.addCallParam(fullPrefix + "/jsp-config/taglib/taglib-location", 1); digester.addCallParam(fullPrefix + "/jsp-config/taglib/taglib-uri", 0); digester.addCallMethod(fullPrefix + "/welcome-file-list/welcome-file", "addWelcomeFile", 0); digester.addCallMethod(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping", "addLocaleEncodingMapping", 2); digester.addCallParam(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping/locale", 0); digester.addCallParam(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping/encoding", 1); }	public void addSecurityRoleRef(SecurityRoleRef securityRoleRef) { securityRoleRefs.add(securityRoleRef); }
@Override protected void initInternal() throws LifecycleException { BlockingQueue<Runnable> startStopQueue = new LinkedBlockingQueue<Runnable>(); startStopExecutor = new ThreadPoolExecutor(getStartStopThreadsInternal(), getStartStopThreadsInternal(), 10, TimeUnit.SECONDS, startStopQueue); startStopExecutor.allowCoreThreadTimeOut(true); super.initInternal(); }	@Override public Void call() throws LifecycleException { child.start(); return null; }

private void prepareResponse() { boolean entityBody = true; contentDelimitation = false; OutputFilter[] outputFilters = getOutputBuffer().getFilters(); if (http09 == true) { getOutputBuffer().addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); return; } int statusCode = response.getStatus(); if ((statusCode == 204) || (statusCode == 205) || (statusCode == 304)) { getOutputBuffer().addActiveFilter(outputFilters[Constants.VOID_FILTER]); entityBody = false; contentDelimitation = true; } MessageBytes methodMB = request.method(); if (methodMB.equals("HEAD")) { getOutputBuffer().addActiveFilter(outputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } boolean sendingWithSendfile = false; if (getEndpoint().getUseSendfile()) { sendingWithSendfile = prepareSendfile(outputFilters); } boolean isCompressable = false; boolean useCompression = false; if (entityBody && (compressionLevel > 0) && !sendingWithSendfile) { isCompressable = isCompressable(); if (isCompressable) { useCompression = useCompression(); } if (useCompression) { response.setContentLength(-1); } } MimeHeaders headers = response.getMimeHeaders(); if (!entityBody) { response.setContentLength(-1); } else { String contentType = response.getContentType(); if (contentType != null) { headers.setValue("Content-Type").setString(contentType); } String contentLanguage = response.getContentLanguage(); if (contentLanguage != null) { headers.setValue("Content-Language").setString(contentLanguage); } } long contentLength = response.getContentLengthLong(); if (contentLength != -1) { headers.setValue("Content-Length").setLong(contentLength); getOutputBuffer().addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } else { if (entityBody && http11) { getOutputBuffer().addActiveFilter(outputFilters[Constants.CHUNKED_FILTER]); contentDelimitation = true; headers.addValue(Constants.TRANSFERENCODING).setString(Constants.CHUNKED); } else { getOutputBuffer().addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); } } if (useCompression) { getOutputBuffer().addActiveFilter(outputFilters[Constants.GZIP_FILTER]); headers.setValue("Content-Encoding").setString("gzip"); } if (isCompressable) { MessageBytes vary = headers.getValue("Vary"); if (vary == null) { headers.setValue("Vary").setString("Accept-Encoding"); } else if (vary.equals("*")) { // No action required } else { headers.setValue("Vary").setString(vary.getString() + ",Accept-Encoding"); } } headers.setValue("Date").setString(FastHttpDateFormat.getCurrentDate()); if ((entityBody) && (!contentDelimitation)) { // Mark as close the connection after the request, and add the keepAlive = false; } // If we know that the request is bad this early, add the keepAlive = keepAlive && !statusDropsConnection(statusCode); if (!keepAlive) { headers.addValue(Constants.CONNECTION).setString(Constants.CLOSE); } else if (!http11 && !error) { headers.addValue(Constants.CONNECTION).setString(Constants.KEEPALIVE); } getOutputBuffer().sendStatus(); if (server != null) { headers.setValue("Server").setString(server); } else if (headers.getValue("Server") == null) { getOutputBuffer().write(Constants.SERVER_BYTES); } int size = headers.size(); for (int i = 0; i < size; i++) { getOutputBuffer().sendHeader(headers.getName(i), headers.getValue(i)); } getOutputBuffer().endHeaders(); }	protected void prepareRequest() { http11 = true; http09 = false; contentDelimitation = false; expectation = false; prepareRequestInternal(); if (endpoint.isSSLEnabled()) { request.scheme().setString("https"); } MessageBytes protocolMB = request.protocol(); if (protocolMB.equals(Constants.HTTP_11)) { http11 = true; protocolMB.setString(Constants.HTTP_11); } else if (protocolMB.equals(Constants.HTTP_10)) { http11 = false; keepAlive = false; protocolMB.setString(Constants.HTTP_10); } else if (protocolMB.equals("")) { http09 = true; http11 = false; keepAlive = false; } else { http11 = false; error = true; if (getLog().isDebugEnabled()) { getLog().debug(sm.getString("http11processor.request.prepare") + " Unsupported HTTP version \"" + protocolMB + "\""); } response.setStatus(505); } MessageBytes methodMB = request.method(); if (methodMB.equals(Constants.GET)) { methodMB.setString(Constants.GET); } else if (methodMB.equals(Constants.POST)) { methodMB.setString(Constants.POST); } MimeHeaders headers = request.getMimeHeaders(); MessageBytes connectionValueMB = headers.getValue("connection"); if (connectionValueMB != null) { ByteChunk connectionValueBC = connectionValueMB.getByteChunk(); if (findBytes(connectionValueBC, Constants.CLOSE_BYTES) != -1) { keepAlive = false; } else if (findBytes(connectionValueBC, Constants.KEEPALIVE_BYTES) != -1) { keepAlive = true; } } MessageBytes expectMB = null; if (http11) { expectMB = headers.getValue("expect"); } if ((expectMB != null) && (expectMB.indexOfIgnoreCase("100-continue", 0) != -1)) { getInputBuffer().setSwallowInput(false); expectation = true; } if ((restrictedUserAgents != null) && ((http11) || (keepAlive))) { MessageBytes userAgentValueMB = headers.getValue("user-agent"); if (userAgentValueMB != null) { String userAgentValue = userAgentValueMB.toString(); if (restrictedUserAgents != null && restrictedUserAgents.matcher(userAgentValue).matches()) { http11 = false; keepAlive = false; } } } ByteChunk uriBC = request.requestURI().getByteChunk(); if (uriBC.startsWithIgnoreCase("http", 0)) { int pos = uriBC.indexOf("://", 0, 3, 4); int uriBCStart = uriBC.getStart(); int slashPos = -1; if (pos != -1) { byte[] uriB = uriBC.getBytes(); slashPos = uriBC.indexOf('/', pos + 3); if (slashPos == -1) { slashPos = uriBC.getLength(); request.requestURI().setBytes(uriB, uriBCStart + pos + 1, 1); } else { request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos); } MessageBytes hostMB = headers.setValue("host"); hostMB.setBytes(uriB, uriBCStart + pos + 3, slashPos - pos - 3); } } InputFilter[] inputFilters = getInputBuffer().getFilters(); MessageBytes transferEncodingValueMB = null; if (http11) { transferEncodingValueMB = headers.getValue("transfer-encoding"); } if (transferEncodingValueMB != null) { String transferEncodingValue = transferEncodingValueMB.toString(); int startPos = 0; int commaPos = transferEncodingValue.indexOf(','); String encodingName = null; while (commaPos != -1) { encodingName = transferEncodingValue.substring(startPos, commaPos).toLowerCase(Locale.ENGLISH).trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; response.setStatus(501); } startPos = commaPos + 1; commaPos = transferEncodingValue.indexOf(',', startPos); } encodingName = transferEncodingValue.substring(startPos).toLowerCase(Locale.ENGLISH).trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; if (getLog().isDebugEnabled()) { getLog().debug(sm.getString("http11processor.request.prepare") + " Unsupported transfer encoding \"" + encodingName + "\""); } response.setStatus(501); } } long contentLength = request.getContentLengthLong(); if (contentLength >= 0 && !contentDelimitation) { getInputBuffer().addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } MessageBytes valueMB = headers.getValue("host"); if (http11 && (valueMB == null)) { error = true; if (getLog().isDebugEnabled()) { getLog().debug(sm.getString("http11processor.request.prepare") + " host header missing"); } response.setStatus(400); } parseHost(valueMB); if (!contentDelimitation) { // If there's no content length // (broken HTTP/1.0 or HTTP/1.1), assume getInputBuffer().addActiveFilter(inputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } if (endpoint.getUseSendfile()) { request.setAttribute(org.apache.coyote.Constants.SENDFILE_SUPPORTED_ATTR, Boolean.TRUE); } if (endpoint.getUseComet()) { request.setAttribute(org.apache.coyote.Constants.COMET_SUPPORTED_ATTR, Boolean.TRUE); } if (endpoint.getUseCometTimeout()) { request.setAttribute(org.apache.coyote.Constants.COMET_TIMEOUT_SUPPORTED_ATTR, Boolean.TRUE); } if (error) { adapter.log(request, response, 0); } }	public void testPipelining() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctxt = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(ctxt, "TesterServlet", new TesterServlet()); ctxt.addServletMapping("/foo", "TesterServlet"); tomcat.start(); String requestPart1 = "GET /foo HTTP/1.1" + SimpleHttpClient.CRLF; String requestPart2 = "Host: any" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF; final Client client = new Client(tomcat.getConnector().getLocalPort()); client.setRequest(new String[] { requestPart1, requestPart2 }); client.setRequestPause(1000); client.setUseContentLength(true); client.connect(); Runnable send = new Runnable() { @Override public void run() { try { client.sendRequest(); client.sendRequest(); } catch (InterruptedException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } }; Thread t = new Thread(send); t.start(); // Sleep for 1500 ms which should mean the all of request 1 has been Thread.sleep(1500); client.readResponse(true); assertFalse(client.isResponse50x()); assertTrue(client.isResponse200()); assertEquals("OK", client.getResponseBody()); // Read the second response. No need to sleep, read will block until client.readResponse(true); assertFalse(client.isResponse50x()); assertTrue(client.isResponse200()); assertEquals("OK", client.getResponseBody()); }
protected void populateAnnotationsCache(Class<?> clazz, Map<String, String> injections) throws IllegalAccessException, InvocationTargetException, NamingException { List<AnnotationCacheEntry> annotations = null; while (clazz != null) { AnnotationCacheEntry[] annotationsArray = null; synchronized (annotationCache) { annotationsArray = annotationCache.get(clazz); } if (annotationsArray == null) { if (annotations == null) { annotations = new ArrayList<AnnotationCacheEntry>(); } else { annotations.clear(); } if (context != null) { // Initialize fields annotations for resource injection if Field[] fields = null; if (Globals.IS_SECURITY_ENABLED) { final Class<?> clazz2 = clazz; fields = AccessController.doPrivileged(new PrivilegedAction<Field[]>() { @Override public Field[] run() { return clazz2.getDeclaredFields(); } }); } else { fields = clazz.getDeclaredFields(); } for (Field field : fields) { if (injections != null && injections.containsKey(field.getName())) { annotations.add(new AnnotationCacheEntry(field.getName(), null, injections.get(field.getName()), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(Resource.class)) { Resource annotation = field.getAnnotation(Resource.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(EJB.class)) { EJB annotation = field.getAnnotation(EJB.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(WebServiceRef.class)) { WebServiceRef annotation = field.getAnnotation(WebServiceRef.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(PersistenceContext.class)) { PersistenceContext annotation = field.getAnnotation(PersistenceContext.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(PersistenceUnit.class)) { PersistenceUnit annotation = field.getAnnotation(PersistenceUnit.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } } } Method[] methods = null; if (Globals.IS_SECURITY_ENABLED) { final Class<?> clazz2 = clazz; methods = AccessController.doPrivileged(new PrivilegedAction<Method[]>() { @Override public Method[] run() { return clazz2.getDeclaredMethods(); } }); } else { methods = clazz.getDeclaredMethods(); } Method postConstruct = null; Method preDestroy = null; for (Method method : methods) { String methodName = method.getName(); if (context != null) { if (injections != null && methodName.startsWith("set") && methodName.length() > 3 && method.getParameterTypes().length == 1 && method.getReturnType().getName().equals("void")) { String fieldName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4); if (injections.containsKey(fieldName)) { annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), injections.get(method.getName()), AnnotationCacheEntryType.SETTER)); break; } } if (method.isAnnotationPresent(Resource.class)) { Resource annotation = method.getAnnotation(Resource.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(EJB.class)) { EJB annotation = method.getAnnotation(EJB.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(WebServiceRef.class)) { WebServiceRef annotation = method.getAnnotation(WebServiceRef.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(PersistenceContext.class)) { PersistenceContext annotation = method.getAnnotation(PersistenceContext.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(PersistenceUnit.class)) { PersistenceUnit annotation = method.getAnnotation(PersistenceUnit.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } } if (method.isAnnotationPresent(PostConstruct.class)) { if ((postConstruct != null) || (method.getParameterTypes().length != 0) || (Modifier.isStatic(method.getModifiers())) || (method.getExceptionTypes().length > 0) || (!method.getReturnType().getName().equals("void"))) { throw new IllegalArgumentException("Invalid PostConstruct annotation"); } postConstruct = method; } if (method.isAnnotationPresent(PreDestroy.class)) { if ((preDestroy != null || method.getParameterTypes().length != 0) || (Modifier.isStatic(method.getModifiers())) || (method.getExceptionTypes().length > 0) || (!method.getReturnType().getName().equals("void"))) { throw new IllegalArgumentException("Invalid PreDestroy annotation"); } preDestroy = method; } } if (postConstruct != null) { annotations.add(new AnnotationCacheEntry(postConstruct.getName(), postConstruct.getParameterTypes(), null, AnnotationCacheEntryType.POST_CONSTRUCT)); } if (preDestroy != null) { annotations.add(new AnnotationCacheEntry(preDestroy.getName(), preDestroy.getParameterTypes(), null, AnnotationCacheEntryType.PRE_DESTROY)); } if (annotations.isEmpty()) { annotationsArray = ANNOTATIONS_EMPTY; } else { annotationsArray = annotations.toArray(new AnnotationCacheEntry[annotations.size()]); } synchronized (annotationCache) { annotationCache.put(clazz, annotationsArray); } } clazz = clazz.getSuperclass(); } }	public static String getName(Method setter) { StringBuilder name = new StringBuilder(setter.getName()); name.delete(0, 3); name.setCharAt(0, Character.toLowerCase(name.charAt(0))); return name.toString(); }
protected void populateAnnotationsCache(Class<?> clazz, Map<String, String> injections) throws IllegalAccessException, InvocationTargetException, NamingException { List<AnnotationCacheEntry> annotations = null; while (clazz != null) { AnnotationCacheEntry[] annotationsArray = null; synchronized (annotationCache) { annotationsArray = annotationCache.get(clazz); } if (annotationsArray == null) { if (annotations == null) { annotations = new ArrayList<AnnotationCacheEntry>(); } else { annotations.clear(); } if (context != null) { // Initialize fields annotations for resource injection if Field[] fields = null; if (Globals.IS_SECURITY_ENABLED) { final Class<?> clazz2 = clazz; fields = AccessController.doPrivileged(new PrivilegedAction<Field[]>() { @Override public Field[] run() { return clazz2.getDeclaredFields(); } }); } else { fields = clazz.getDeclaredFields(); } for (Field field : fields) { if (injections != null && injections.containsKey(field.getName())) { annotations.add(new AnnotationCacheEntry(field.getName(), null, injections.get(field.getName()), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(Resource.class)) { Resource annotation = field.getAnnotation(Resource.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(EJB.class)) { EJB annotation = field.getAnnotation(EJB.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(WebServiceRef.class)) { WebServiceRef annotation = field.getAnnotation(WebServiceRef.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(PersistenceContext.class)) { PersistenceContext annotation = field.getAnnotation(PersistenceContext.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } else if (field.isAnnotationPresent(PersistenceUnit.class)) { PersistenceUnit annotation = field.getAnnotation(PersistenceUnit.class); annotations.add(new AnnotationCacheEntry(field.getName(), null, annotation.name(), AnnotationCacheEntryType.FIELD)); } } } Method[] methods = null; if (Globals.IS_SECURITY_ENABLED) { final Class<?> clazz2 = clazz; methods = AccessController.doPrivileged(new PrivilegedAction<Method[]>() { @Override public Method[] run() { return clazz2.getDeclaredMethods(); } }); } else { methods = clazz.getDeclaredMethods(); } Method postConstruct = null; Method preDestroy = null; for (Method method : methods) { String methodName = method.getName(); if (context != null) { if (injections != null && methodName.startsWith("set") && methodName.length() > 3) { String fieldName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4); if (injections.containsKey(fieldName)) { annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), injections.get(method.getName()), AnnotationCacheEntryType.SETTER)); break; } } if (method.isAnnotationPresent(Resource.class)) { Resource annotation = method.getAnnotation(Resource.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(EJB.class)) { EJB annotation = method.getAnnotation(EJB.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(WebServiceRef.class)) { WebServiceRef annotation = method.getAnnotation(WebServiceRef.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(PersistenceContext.class)) { PersistenceContext annotation = method.getAnnotation(PersistenceContext.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } else if (method.isAnnotationPresent(PersistenceUnit.class)) { PersistenceUnit annotation = method.getAnnotation(PersistenceUnit.class); annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(), annotation.name(), AnnotationCacheEntryType.SETTER)); } } if (method.isAnnotationPresent(PostConstruct.class)) { if ((postConstruct != null) || (method.getParameterTypes().length != 0) || (Modifier.isStatic(method.getModifiers())) || (method.getExceptionTypes().length > 0) || (!method.getReturnType().getName().equals("void"))) { throw new IllegalArgumentException("Invalid PostConstruct annotation"); } postConstruct = method; } if (method.isAnnotationPresent(PreDestroy.class)) { if ((preDestroy != null || method.getParameterTypes().length != 0) || (Modifier.isStatic(method.getModifiers())) || (method.getExceptionTypes().length > 0) || (!method.getReturnType().getName().equals("void"))) { throw new IllegalArgumentException("Invalid PreDestroy annotation"); } preDestroy = method; } } if (postConstruct != null) { annotations.add(new AnnotationCacheEntry(postConstruct.getName(), postConstruct.getParameterTypes(), null, AnnotationCacheEntryType.POST_CONSTRUCT)); } if (preDestroy != null) { annotations.add(new AnnotationCacheEntry(preDestroy.getName(), preDestroy.getParameterTypes(), null, AnnotationCacheEntryType.PRE_DESTROY)); } if (annotations.isEmpty()) { annotationsArray = ANNOTATIONS_EMPTY; } else { annotationsArray = annotations.toArray(new AnnotationCacheEntry[annotations.size()]); } synchronized (annotationCache) { annotationCache.put(clazz, annotationsArray); } } clazz = clazz.getSuperclass(); } }
protected Class<?> findLoadedClass0(String name) { ResourceEntry entry = resourceEntries.get(name); if (entry != null) { return entry.loadedClass; } return (null); }	protected ResourceEntry findResourceInternal(String name, String path) { if (!started) { log.info(sm.getString("webappClassLoader.stopped", name)); return null; } if ((name == null) || (path == null)) return null; ResourceEntry entry = resourceEntries.get(name); if (entry != null) return entry; int contentLength = -1; InputStream binaryStream = null; int jarFilesLength = jarFiles.length; int repositoriesLength = repositories.length; int i; Resource resource = null; boolean fileNeedConvert = false; for (i = 0; (entry == null) && (i < repositoriesLength); i++) { try { String fullPath = repositories[i] + path; Object lookupResult = resources.lookup(fullPath); if (lookupResult instanceof Resource) { resource = (Resource) lookupResult; } // Note : Not getting an exception here means the resource was ResourceAttributes attributes = (ResourceAttributes) resources.getAttributes(fullPath); contentLength = (int) attributes.getContentLength(); String canonicalPath = attributes.getCanonicalPath(); if (canonicalPath != null) { // we create the ResourceEntry based on the information returned // by the DirContext rather than just using the path to the // repository. This allows to have smart DirContext implementations entry = findResourceInternal(new File(canonicalPath), ""); } else { // probably a resource not in the filesystem (e.g. in a entry = findResourceInternal(files[i], path); } entry.lastModified = attributes.getLastModified(); if (resource != null) { try { binaryStream = resource.streamContent(); } catch (IOException e) { return null; } if (needConvert) { if (path.endsWith(".properties")) { fileNeedConvert = true; } } synchronized (allPermission) { int j; long[] result2 = new long[lastModifiedDates.length + 1]; for (j = 0; j < lastModifiedDates.length; j++) { result2[j] = lastModifiedDates[j]; } result2[lastModifiedDates.length] = entry.lastModified; lastModifiedDates = result2; String[] result = new String[paths.length + 1]; for (j = 0; j < paths.length; j++) { result[j] = paths[j]; } result[paths.length] = fullPath; paths = result; } } } catch (NamingException e) { // Ignore } } if ((entry == null) && (notFoundResources.containsKey(name))) return null; JarEntry jarEntry = null; synchronized (jarFiles) { try { if (!openJARs()) { return null; } for (i = 0; (entry == null) && (i < jarFilesLength); i++) { jarEntry = jarFiles[i].getJarEntry(path); if (jarEntry != null) { entry = new ResourceEntry(); try { entry.codeBase = getURL(jarRealFiles[i], false); String jarFakeUrl = getURI(jarRealFiles[i]).toString(); jarFakeUrl = "jar:" + jarFakeUrl + "!/" + path; entry.source = new URL(jarFakeUrl); entry.lastModified = jarRealFiles[i].lastModified(); } catch (MalformedURLException e) { return null; } contentLength = (int) jarEntry.getSize(); try { entry.manifest = jarFiles[i].getManifest(); binaryStream = jarFiles[i].getInputStream(jarEntry); } catch (IOException e) { return null; } if (antiJARLocking && !(path.endsWith(".class"))) { byte[] buf = new byte[1024]; File resourceFile = new File(loaderDir, jarEntry.getName()); if (!resourceFile.exists()) { Enumeration<JarEntry> entries = jarFiles[i].entries(); while (entries.hasMoreElements()) { JarEntry jarEntry2 = entries.nextElement(); if (!(jarEntry2.isDirectory()) && (!jarEntry2.getName().endsWith(".class"))) { resourceFile = new File(loaderDir, jarEntry2.getName()); try { if (!resourceFile.getCanonicalPath().startsWith(canonicalLoaderDir)) { throw new IllegalArgumentException(sm.getString("webappClassLoader.illegalJarPath", jarEntry2.getName())); } } catch (IOException ioe) { throw new IllegalArgumentException(sm.getString("webappClassLoader.validationErrorJarPath", jarEntry2.getName()), ioe); } File parentFile = resourceFile.getParentFile(); if (!parentFile.mkdirs() && !parentFile.exists()) { // Ignore the error (like the IOExceptions below) } FileOutputStream os = null; InputStream is = null; try { is = jarFiles[i].getInputStream(jarEntry2); os = new FileOutputStream(resourceFile); while (true) { int n = is.read(buf); if (n <= 0) { break; } os.write(buf, 0, n); } resourceFile.setLastModified(jarEntry2.getTime()); } catch (IOException e) { // Ignore } finally { try { if (is != null) { is.close(); } } catch (IOException e) { // Ignore } try { if (os != null) { os.close(); } } catch (IOException e) { // Ignore } } } } } } } } if (entry == null) { synchronized (notFoundResources) { notFoundResources.put(name, name); } return null; } if (binaryStream != null) { byte[] binaryContent = new byte[contentLength]; int pos = 0; try { while (true) { int n = binaryStream.read(binaryContent, pos, binaryContent.length - pos); if (n <= 0) break; pos += n; } } catch (IOException e) { log.error(sm.getString("webappClassLoader.readError", name), e); return null; } if (fileNeedConvert) { // Workaround for certain files on platforms that use // EBCDIC encoding, when they are read through FileInputStream. // See commit message of rev.303915 for details String str = new String(binaryContent, 0, pos); try { binaryContent = str.getBytes(CHARSET_UTF8); } catch (Exception e) { return null; } } entry.binaryContent = binaryContent; if (jarEntry != null) { entry.certificates = jarEntry.getCertificates(); } } } finally { if (binaryStream != null) { try { binaryStream.close(); } catch (IOException e) { /* Ignore */ } } } } synchronized (resourceEntries) { // Ensures that all the threads which may be in a race to load // a particular class all end up with the same ResourceEntry ResourceEntry entry2 = resourceEntries.get(name); if (entry2 == null) { resourceEntries.put(name, entry); } else { entry = entry2; } } return entry; }
private Object newInstance(Object instance, Class<?> clazz) throws IllegalAccessException, InvocationTargetException, NamingException { if (!ignoreAnnotations) { Map<String, String> injections = injectionMap.get(clazz.getName()); populateAnnotationsCache(clazz, injections); processAnnotations(instance, injections); postConstruct(instance, clazz); } return instance; }
private void closePollset(long pollset) { int rv = Poll.pollset(pollset, desc); if (rv > 0) { for (int n = 0; n < rv; n++) { if (comet) { processSocket(desc[n * 2 + 1], SocketStatus.STOP); } else { destroySocket(desc[n * 2 + 1], true); } } } }	@Override protected void longPoll(SocketWrapper<Long> socket, Processor<Long> processor) { connections.put(socket.getSocket(), processor); if (processor.isAsync()) { socket.setAsync(true); } else if (processor.isComet() && proto.endpoint.isRunning()) { ((AprEndpoint) proto.endpoint).getCometPoller().add(socket.getSocket().longValue(), false); } else { ((AprEndpoint) proto.endpoint).getPoller().add(socket.getSocket().longValue(), false); } }	protected void onClose(int status) { // NO-OP }	public void add(long socket, boolean keepAlive) { synchronized (this) { if (addCount >= addSocket.length) { if (comet) { processSocket(socket, SocketStatus.ERROR); } else { destroySocket(socket); } return; } addSocket[addCount] = socket; if (keepAlive) { addSocketTimeout[addCount] = getKeepAliveTimeout(); } else { addSocketTimeout[addCount] = getSoTimeout(); } addCount++; this.notify(); } }	@Override public void release(SocketWrapper<Long> socket, Processor<Long> processor, boolean isSocketClosing, boolean addToPoller) { processor.recycle(isSocketClosing); recycledProcessors.offer(processor); if (addToPoller) { ((AprEndpoint) proto.endpoint).getPoller().add(socket.getSocket().longValue(), true); } }	@Override public void release(SocketWrapper<Long> socket, Processor<Long> processor, boolean isSocketClosing, boolean addToPoller) { processor.recycle(isSocketClosing); recycledProcessors.offer(processor); if (addToPoller && proto.endpoint.isRunning()) { ((AprEndpoint) proto.endpoint).getPoller().add(socket.getSocket().longValue(), true); } }	protected Log getLog() { return log; }
public static Set<TimerTask> getPoolCleaners() { return Collections.<TimerTask>unmodifiableSet(cleaners); }	protected PooledConnection create(boolean incrementCounter) { if (incrementCounter) size.incrementAndGet(); PooledConnection con = new PooledConnection(getPoolProperties(), this); return con; }	protected boolean shouldClose(PooledConnection con, int action) { if (con.isDiscarded()) return true; if (isClosed()) return true; if (!con.validate(action)) return true; if (!terminateTransaction(con)) return true; if (getPoolProperties().getMaxAge() > 0) { return (System.currentTimeMillis() - con.getLastConnected()) > getPoolProperties().getMaxAge(); } else { return false; } }	protected void init(PoolConfiguration properties) throws SQLException { poolProperties = properties; if (properties.getMaxActive() < 1) { log.warn("maxActive is smaller than 1, setting maxActive to: " + PoolProperties.DEFAULT_MAX_ACTIVE); properties.setMaxActive(PoolProperties.DEFAULT_MAX_ACTIVE); } if (properties.getMaxActive() < properties.getInitialSize()) { log.warn("initialSize is larger than maxActive, setting initialSize to: " + properties.getMaxActive()); properties.setInitialSize(properties.getMaxActive()); } if (properties.getMinIdle() > properties.getMaxActive()) { log.warn("minIdle is larger than maxActive, setting minIdle to: " + properties.getMaxActive()); properties.setMinIdle(properties.getMaxActive()); } if (properties.getMaxIdle() > properties.getMaxActive()) { log.warn("maxIdle is larger than maxActive, setting maxIdle to: " + properties.getMaxActive()); properties.setMaxIdle(properties.getMaxActive()); } if (properties.getMaxIdle() < properties.getMinIdle()) { log.warn("maxIdle is smaller than minIdle, setting maxIdle to: " + properties.getMinIdle()); properties.setMaxIdle(properties.getMinIdle()); } busy = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(), false); if (properties.isFairQueue()) { idle = new FairBlockingQueue<PooledConnection>(); //idle = new MultiLockFairBlockingQueue<PooledConnection>(); } else { idle = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(), properties.isFairQueue()); } initializePoolCleaner(properties); if (this.getPoolProperties().isJmxEnabled()) createMBean(); //Parse and create an initial set of interceptors. Letting them know the pool has started. PoolProperties.InterceptorDefinition[] proxies = getPoolProperties().getJdbcInterceptorsAsArray(); for (int i = 0; i < proxies.length; i++) { try { if (log.isDebugEnabled()) { log.debug("Creating interceptor instance of class:" + proxies[i].getInterceptorClass()); } JdbcInterceptor interceptor = proxies[i].getInterceptorClass().newInstance(); interceptor.setProperties(proxies[i].getProperties()); interceptor.poolStarted(this); } catch (Exception x) { log.error("Unable to inform interceptor of pool start.", x); if (jmxPool != null) jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_INIT, getStackTrace(x)); close(true); SQLException ex = new SQLException(); ex.initCause(x); throw ex; } } PooledConnection[] initialPool = new PooledConnection[poolProperties.getInitialSize()]; try { for (int i = 0; i < initialPool.length; i++) { initialPool[i] = this.borrowConnection(0, null, null); } //for } catch (SQLException x) { if (jmxPool != null) jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_INIT, getStackTrace(x)); close(true); throw x; } finally { for (int i = 0; i < initialPool.length; i++) { if (initialPool[i] != null) { try { this.returnConnection(initialPool[i]); } catch (Exception x) { /*NOOP*/ } } //end if } //for } closed = false; }	public void checkIdle() { try { if (idle.size() == 0) return; long now = System.currentTimeMillis(); Iterator<PooledConnection> unlocked = idle.iterator(); while ((idle.size() >= getPoolProperties().getMinIdle()) && unlocked.hasNext()) { PooledConnection con = unlocked.next(); boolean setToNull = false; try { con.lock(); if (busy.contains(con)) continue; long time = con.getTimestamp(); if ((con.getReleaseTime() > 0) && ((now - time) > con.getReleaseTime()) && (getSize() > getPoolProperties().getMinIdle())) { release(con); idle.remove(con); setToNull = true; } else { //do nothing } //end if } finally { con.unlock(); if (setToNull) con = null; } } //while } catch (ConcurrentModificationException e) { log.debug("checkIdle failed.", e); } catch (Exception e) { log.warn("checkIdle failed, it will be retried.", e); } }	@Override public void setPropagateInterruptState(boolean propagateInterruptState) { getPoolProperties().setPropagateInterruptState(propagateInterruptState); }	@Override public void setPropagateInterruptState(boolean propagateInterruptState) { getPoolProperties().setPropagateInterruptState(propagateInterruptState); }
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String key; String subProtocol = null; List<String> extensions = Collections.emptyList(); if (!headerContainsToken(req, "upgrade", "websocket")) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } if (!headerContainsToken(req, "connection", "upgrade")) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } if (!headerContainsToken(req, "sec-websocket-version", "13")) { resp.setStatus(426); resp.setHeader("Sec-WebSocket-Version", "13"); return; } key = req.getHeader("Sec-WebSocket-Key"); if (key == null) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } String origin = req.getHeader("Origin"); if (!verifyOrigin(origin)) { resp.sendError(HttpServletResponse.SC_FORBIDDEN); return; } List<String> subProtocols = getTokensFromHeader(req, "Sec-WebSocket-Protocol-Client"); if (!subProtocols.isEmpty()) { subProtocol = selectSubProtocol(subProtocols); } // TODO Read client handshake - Sec-WebSocket-Extensions // TODO Extensions require the ability to specify something (API TBD) // that can be passed to the Tomcat internals and process extension // data present when the frame is fragmented. resp.setHeader("Upgrade", "websocket"); resp.setHeader("Connection", "upgrade"); resp.setHeader("Sec-WebSocket-Accept", getWebSocketAccept(key)); if (subProtocol != null) { resp.setHeader("Sec-WebSocket-Protocol", subProtocol); } if (!extensions.isEmpty()) { // TODO } StreamInbound inbound = createWebSocketInbound(subProtocol); ((RequestFacade) req).doUpgrade(inbound); }
public int getMaxThreads() { if (running && executor != null) { if (executor instanceof java.util.concurrent.ThreadPoolExecutor) { return ((java.util.concurrent.ThreadPoolExecutor) executor).getMaximumPoolSize(); } else if (executor instanceof ResizableExecutor) { return ((ResizableExecutor) executor).getMaxThreads(); } else { return -1; } } else { return maxThreads; } }	@Override public void bind() throws Exception { if (acceptorThreadCount == 0) { acceptorThreadCount = 1; } if (getMaxConnections() == 0) { setMaxConnections(getMaxThreads()); } if (serverSocketFactory == null) { if (isSSLEnabled()) { serverSocketFactory = handler.getSslImplementation().getServerSocketFactory(this); } else { serverSocketFactory = new DefaultServerSocketFactory(this); } } if (serverSocket == null) { try { if (getAddress() == null) { serverSocket = serverSocketFactory.createSocket(getPort(), getBacklog()); } else { serverSocket = serverSocketFactory.createSocket(getPort(), getBacklog(), getAddress()); } } catch (BindException orig) { String msg; if (getAddress() == null) msg = orig.getMessage() + " <null>:" + getPort(); else msg = orig.getMessage() + " " + getAddress().toString() + ":" + getPort(); BindException be = new BindException(msg); be.initCause(orig); throw be; } } }
protected void removeAttributeInternal(String name, boolean notify, boolean addDeltaRequest) { try { lock(); Object value = attributes.get(name); if (value == null) return; super.removeAttributeInternal(name, notify); if (addDeltaRequest && deltaRequest != null && !exclude(name)) { deltaRequest.removeAttribute(name); } } finally { unlock(); } }	public String getTypeDesc() { switch(msgtype) { case MSG_BACKUP: return "MSG_BACKUP"; case MSG_RETRIEVE_BACKUP: return "MSG_RETRIEVE_BACKUP"; case MSG_PROXY: return "MSG_PROXY"; case MSG_REMOVE: return "MSG_REMOVE"; case MSG_STATE: return "MSG_STATE"; case MSG_START: return "MSG_START"; case MSG_STOP: return "MSG_STOP"; case MSG_INIT: return "MSG_INIT"; case MSG_STATE_COPY: return "MSG_STATE_COPY"; case MSG_COPY: return "MSG_COPY"; default: return "UNKNOWN"; } }	@Override public String toString() { StringBuilder buf = new StringBuilder("MapEntry[key:"); buf.append(getKey()).append("; "); buf.append("value:").append(getValue()).append("; "); buf.append("primary:").append(isPrimary()).append("; "); buf.append("backup:").append(isBackup()).append("; "); buf.append("proxy:").append(isProxy()).append(";]"); return buf.toString(); }	@Override public long getVersion() { return version; }	@SuppressWarnings("unchecked") @Override public void messageReceived(Serializable msg, Member sender) { if (!(msg instanceof MapMessage)) return; MapMessage mapmsg = (MapMessage) msg; if (log.isTraceEnabled()) { log.trace("Map[" + mapname + "] received message:" + mapmsg); } try { mapmsg.deserialize(getExternalLoaders()); } catch (IOException x) { log.error("Unable to deserialize MapMessage.", x); return; } catch (ClassNotFoundException x) { log.error("Unable to deserialize MapMessage.", x); return; } if (log.isTraceEnabled()) log.trace("Map message received from:" + sender.getName() + " msg:" + mapmsg); if (mapmsg.getMsgType() == MapMessage.MSG_START) { mapMemberAdded(mapmsg.getPrimary()); } if (mapmsg.getMsgType() == MapMessage.MSG_STOP) { memberDisappeared(mapmsg.getPrimary()); } if (mapmsg.getMsgType() == MapMessage.MSG_PROXY) { MapEntry<K, V> entry = innerMap.get(mapmsg.getKey()); if (entry == null) { entry = new MapEntry<K, V>((K) mapmsg.getKey(), (V) mapmsg.getValue()); entry.setBackup(false); entry.setProxy(true); entry.setBackupNodes(mapmsg.getBackupNodes()); entry.setPrimary(mapmsg.getPrimary()); innerMap.put(entry.getKey(), entry); } else { entry.setProxy(true); entry.setBackup(false); entry.setBackupNodes(mapmsg.getBackupNodes()); entry.setPrimary(mapmsg.getPrimary()); } } if (mapmsg.getMsgType() == MapMessage.MSG_REMOVE) { innerMap.remove(mapmsg.getKey()); } if (mapmsg.getMsgType() == MapMessage.MSG_BACKUP || mapmsg.getMsgType() == MapMessage.MSG_COPY) { MapEntry<K, V> entry = innerMap.get(mapmsg.getKey()); if (entry == null) { entry = new MapEntry<K, V>((K) mapmsg.getKey(), (V) mapmsg.getValue()); entry.setBackup(mapmsg.getMsgType() == MapMessage.MSG_BACKUP); entry.setProxy(false); entry.setBackupNodes(mapmsg.getBackupNodes()); entry.setPrimary(mapmsg.getPrimary()); if (mapmsg.getValue() != null && mapmsg.getValue() instanceof ReplicatedMapEntry) { ((ReplicatedMapEntry) mapmsg.getValue()).setOwner(getMapOwner()); } } else { entry.setBackup(mapmsg.getMsgType() == MapMessage.MSG_BACKUP); entry.setProxy(false); entry.setBackupNodes(mapmsg.getBackupNodes()); entry.setPrimary(mapmsg.getPrimary()); if (entry.getValue() instanceof ReplicatedMapEntry) { ReplicatedMapEntry diff = (ReplicatedMapEntry) entry.getValue(); if (mapmsg.isDiff()) { try { diff.lock(); diff.applyDiff(mapmsg.getDiffValue(), 0, mapmsg.getDiffValue().length); } catch (Exception x) { log.error("Unable to apply diff to key:" + entry.getKey(), x); } finally { diff.unlock(); } } else { if (mapmsg.getValue() != null) entry.setValue((V) mapmsg.getValue()); ((ReplicatedMapEntry) entry.getValue()).setOwner(getMapOwner()); } //end if } else if (mapmsg.getValue() instanceof ReplicatedMapEntry) { ReplicatedMapEntry re = (ReplicatedMapEntry) mapmsg.getValue(); re.setOwner(getMapOwner()); entry.setValue((V) re); } else { if (mapmsg.getValue() != null) entry.setValue((V) mapmsg.getValue()); } //end if } innerMap.put(entry.getKey(), entry); } //end if }	public void replicate(Object key, boolean complete) { if (log.isTraceEnabled()) log.trace("Replicate invoked on key:" + key); MapEntry<K, V> entry = innerMap.get(key); if (entry == null) return; if (!entry.isSerializable()) return; if (entry.isPrimary() && entry.getBackupNodes() != null && entry.getBackupNodes().length > 0) { Object value = entry.getValue(); boolean repl = complete || ((value instanceof ReplicatedMapEntry) && ((ReplicatedMapEntry) value).isDirty()); if (!repl) { if (log.isTraceEnabled()) log.trace("Not replicating:" + key + ", no change made"); return; } boolean diff = ((value instanceof ReplicatedMapEntry) && ((ReplicatedMapEntry) value).isDiffable()); MapMessage msg = null; if (diff) { ReplicatedMapEntry rentry = (ReplicatedMapEntry) entry.getValue(); try { rentry.lock(); msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP, true, (Serializable) entry.getKey(), null, rentry.getDiff(), entry.getPrimary(), entry.getBackupNodes()); rentry.resetDiff(); } catch (IOException x) { log.error("Unable to diff object. Will replicate the entire object instead.", x); } finally { rentry.unlock(); } } if (msg == null) { msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP, false, (Serializable) entry.getKey(), (Serializable) entry.getValue(), null, entry.getPrimary(), entry.getBackupNodes()); } try { if (channel != null && entry.getBackupNodes() != null && entry.getBackupNodes().length > 0) { channel.send(entry.getBackupNodes(), msg, channelSendOptions); } } catch (ChannelException x) { log.error("Unable to replicate data.", x); } } //end if }	@Override public void setOwner(Object owner) { if (owner instanceof ClusterManager && getManager() == null) { ClusterManager cm = (ClusterManager) owner; this.setManager(cm); this.setValid(true); this.setPrimarySession(false); this.access(); this.resetDeltaRequest(); this.endAccess(); } }
private static void init() { int major = 0; int minor = 0; int patch = 0; int apver = 0; int rqver = TCN_REQUIRED_MAJOR * 1000 + TCN_REQUIRED_MINOR * 100 + TCN_REQUIRED_PATCH; int rcver = TCN_REQUIRED_MAJOR * 1000 + TCN_REQUIRED_MINOR * 100 + TCN_RECOMMENDED_PV; if (aprInitialized) { return; } aprInitialized = true; try { String methodName = "initialize"; Class<?>[] paramTypes = new Class[1]; paramTypes[0] = String.class; Object[] paramValues = new Object[1]; paramValues[0] = null; Class<?> clazz = Class.forName("org.apache.tomcat.jni.Library"); Method method = clazz.getMethod(methodName, paramTypes); method.invoke(null, paramValues); major = clazz.getField("TCN_MAJOR_VERSION").getInt(null); minor = clazz.getField("TCN_MINOR_VERSION").getInt(null); patch = clazz.getField("TCN_PATCH_VERSION").getInt(null); apver = major * 1000 + minor * 100 + patch; } catch (Throwable t) { t = ExceptionUtils.unwrapInvocationTargetException(t); ExceptionUtils.handleThrowable(t); log.info(sm.getString("aprListener.aprInit", System.getProperty("java.library.path"))); return; } if (apver < rqver) { log.error(sm.getString("aprListener.tcnInvalid", major + "." + minor + "." + patch, TCN_REQUIRED_MAJOR + "." + TCN_REQUIRED_MINOR + "." + TCN_REQUIRED_PATCH)); try { // Terminate the APR in case the version terminateAPR(); } catch (Throwable t) { t = ExceptionUtils.unwrapInvocationTargetException(t); ExceptionUtils.handleThrowable(t); } return; } if (apver < rcver) { log.info(sm.getString("aprListener.tcnVersion", major + "." + minor + "." + patch, TCN_REQUIRED_MAJOR + "." + TCN_RECOMMENDED_MINOR + "." + TCN_RECOMMENDED_PV)); } log.info(sm.getString("aprListener.tcnValid", major + "." + minor + "." + patch)); log.info(sm.getString("aprListener.flags", Boolean.valueOf(Library.APR_HAVE_IPV6), Boolean.valueOf(Library.APR_HAS_SENDFILE), Boolean.valueOf(Library.APR_HAS_SO_ACCEPTFILTER), Boolean.valueOf(Library.APR_HAS_RANDOM))); aprAvailable = true; }
protected void init(PoolConfiguration properties) throws SQLException { poolProperties = properties; if (properties.getMaxActive() < 1) { log.warn("maxActive is smaller than 1, setting maxActive to: " + PoolProperties.DEFAULT_MAX_ACTIVE); properties.setMaxActive(PoolProperties.DEFAULT_MAX_ACTIVE); } if (properties.getMaxActive() < properties.getInitialSize()) { log.warn("initialSize is larger than maxActive, setting initialSize to: " + properties.getMaxActive()); properties.setInitialSize(properties.getMaxActive()); } if (properties.getMinIdle() > properties.getMaxActive()) { log.warn("minIdle is larger than maxActive, setting minIdle to: " + properties.getMaxActive()); properties.setMinIdle(properties.getMaxActive()); } if (properties.getMaxIdle() > properties.getMaxActive()) { log.warn("maxIdle is larger than maxActive, setting maxIdle to: " + properties.getMaxActive()); properties.setMaxIdle(properties.getMaxActive()); } if (properties.getMaxIdle() < properties.getMinIdle()) { log.warn("maxIdle is smaller than minIdle, setting maxIdle to: " + properties.getMinIdle()); properties.setMaxIdle(properties.getMinIdle()); } busy = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(), false); if (properties.isFairQueue()) { idle = new FairBlockingQueue<PooledConnection>(); //idle = new MultiLockFairBlockingQueue<PooledConnection>(); } else { idle = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(), properties.isFairQueue()); } if (properties.isPoolSweeperEnabled()) { poolCleaner = new PoolCleaner(this, properties.getTimeBetweenEvictionRunsMillis()); poolCleaner.start(); } if (this.getPoolProperties().isJmxEnabled()) createMBean(); //Parse and create an initial set of interceptors. Letting them know the pool has started. PoolProperties.InterceptorDefinition[] proxies = getPoolProperties().getJdbcInterceptorsAsArray(); for (int i = 0; i < proxies.length; i++) { try { if (log.isDebugEnabled()) { log.debug("Creating interceptor instance of class:" + proxies[i].getInterceptorClass()); } JdbcInterceptor interceptor = proxies[i].getInterceptorClass().newInstance(); interceptor.setProperties(proxies[i].getProperties()); interceptor.poolStarted(this); } catch (Exception x) { log.error("Unable to inform interceptor of pool start.", x); if (jmxPool != null) jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_INIT, getStackTrace(x)); close(true); SQLException ex = new SQLException(); ex.initCause(x); throw ex; } } PooledConnection[] initialPool = new PooledConnection[poolProperties.getInitialSize()]; try { for (int i = 0; i < initialPool.length; i++) { initialPool[i] = this.borrowConnection(0, null, null); } //for } catch (SQLException x) { if (jmxPool != null) jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_INIT, getStackTrace(x)); close(true); throw x; } finally { for (int i = 0; i < initialPool.length; i++) { if (initialPool[i] != null) { try { this.returnConnection(initialPool[i]); } catch (Exception x) { /*NOOP*/ } } //end if } //for } closed = false; }	@Override public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed) { //noop }	@Override public void setDataSourceJNDI(String jndiDS) { //noop }	@Override public void setInitSQL(String initSQL) { // TODO Auto-generated method stub }	@Override public void setInitialSize(int initialSize) { // TODO Auto-generated method stub }	@Override public void setJdbcInterceptors(String jdbcInterceptors) { // TODO Auto-generated method stub }	@Override public void setJmxEnabled(boolean jmxEnabled) { // TODO Auto-generated method stub }	@Override public void setLogAbandoned(boolean logAbandoned) { // TODO Auto-generated method stub }	@Override public void setMaxActive(int maxActive) { // TODO Auto-generated method stub }	@Override public void setMaxIdle(int maxIdle) { // TODO Auto-generated method stub }	@Override public void setMaxWait(int maxWait) { // TODO Auto-generated method stub }	@Override public void setMinEvictableIdleTimeMillis(int minEvictableIdleTimeMillis) { // TODO Auto-generated method stub }	@Override public void setMinIdle(int minIdle) { // TODO Auto-generated method stub }	@Override public void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) { // TODO Auto-generated method stub }	@Override public void setPassword(String password) { // TODO Auto-generated method stub }	@Override public void setRemoveAbandoned(boolean removeAbandoned) { // TODO Auto-generated method stub }	@Override public void setRemoveAbandonedTimeout(int removeAbandonedTimeout) { // TODO Auto-generated method stub }	@Override public void setSuspectTimeout(int seconds) { //no op }	@Override public void setTestOnBorrow(boolean testOnBorrow) { // TODO Auto-generated method stub }	@Override public void setTestOnConnect(boolean testOnConnect) { // TODO Auto-generated method stub }	@Override public void setTestOnReturn(boolean testOnReturn) { // TODO Auto-generated method stub }	@Override public void setTestWhileIdle(boolean testWhileIdle) { // TODO Auto-generated method stub }	@Override public void setTimeBetweenEvictionRunsMillis(int timeBetweenEvictionRunsMillis) { // TODO Auto-generated method stub }	@Override public void setUrl(String url) { // TODO Auto-generated method stub }	@Override public void setUseEquals(boolean useEquals) { // TODO Auto-generated method stub }	@Override public void setUseLock(boolean useLock) { // TODO Auto-generated method stub }	@Override public void setUsername(String username) { // TODO Auto-generated method stub }	@Override public void setValidationInterval(long validationInterval) { // TODO Auto-generated method stub }	@Override public void setValidationQuery(String validationQuery) { // TODO Auto-generated method stub }	@Override public void setValidator(Validator validator) { //noop }
public static ExpressionFactory newInstance(Properties properties) { ExpressionFactory result = null; ClassLoader tccl = Thread.currentThread().getContextClassLoader(); String className = discoverClassName(tccl); try { Class<?> clazz = null; if (tccl == null) { clazz = Class.forName(className); } else { clazz = tccl.loadClass(className); } Constructor<?> constructor = null; if (properties != null) { try { constructor = clazz.getConstructor(Properties.class); } catch (SecurityException se) { throw new ELException(se); } catch (NoSuchMethodException nsme) { // This can be ignored // This is OK for this constructor not to exist } } if (constructor == null) { result = (ExpressionFactory) clazz.newInstance(); } else { result = (ExpressionFactory) constructor.newInstance(properties); } } catch (ClassNotFoundException e) { throw new ELException("Unable to find ExpressionFactory of type: " + className, e); } catch (InstantiationException e) { throw new ELException("Unable to create ExpressionFactory of type: " + className, e); } catch (IllegalAccessException e) { throw new ELException("Unable to create ExpressionFactory of type: " + className, e); } catch (IllegalArgumentException e) { throw new ELException("Unable to create ExpressionFactory of type: " + className, e); } catch (InvocationTargetException e) { Throwable cause = e.getCause(); if (cause instanceof ThreadDeath) { throw (ThreadDeath) cause; } if (cause instanceof VirtualMachineError) { throw (VirtualMachineError) cause; } throw new ELException("Unable to create ExpressionFactory of type: " + className, e); } return result; }

protected static void addResource(Context context, Resource annotation) { if (annotation.type().getCanonicalName().equals("java.lang.String") || annotation.type().getCanonicalName().equals("java.lang.Character") || annotation.type().getCanonicalName().equals("java.lang.Integer") || annotation.type().getCanonicalName().equals("java.lang.Boolean") || annotation.type().getCanonicalName().equals("java.lang.Double") || annotation.type().getCanonicalName().equals("java.lang.Byte") || annotation.type().getCanonicalName().equals("java.lang.Short") || annotation.type().getCanonicalName().equals("java.lang.Long") || annotation.type().getCanonicalName().equals("java.lang.Float")) { ContextEnvironment resource = new ContextEnvironment(); resource.setName(annotation.name()); resource.setType(annotation.type().getCanonicalName()); resource.setDescription(annotation.description()); resource.setValue(annotation.mappedName()); context.getNamingResources().addEnvironment(resource); } else if (annotation.type().getCanonicalName().equals("javax.xml.rpc.Service")) { ContextService service = new ContextService(); service.setName(annotation.name()); service.setWsdlfile(annotation.mappedName()); service.setType(annotation.type().getCanonicalName()); service.setDescription(annotation.description()); context.getNamingResources().addService(service); } else if (annotation.type().getCanonicalName().equals("javax.sql.DataSource") || annotation.type().getCanonicalName().equals("javax.jms.ConnectionFactory") || annotation.type().getCanonicalName().equals("javax.jms.QueueConnectionFactory") || annotation.type().getCanonicalName().equals("javax.jms.TopicConnectionFactory") || annotation.type().getCanonicalName().equals("javax.mail.Session") || annotation.type().getCanonicalName().equals("java.net.URL") || annotation.type().getCanonicalName().equals("javax.resource.cci.ConnectionFactory") || annotation.type().getCanonicalName().equals("org.omg.CORBA_2_3.ORB") || annotation.type().getCanonicalName().endsWith("ConnectionFactory")) { ContextResource resource = new ContextResource(); resource.setName(annotation.name()); resource.setType(annotation.type().getCanonicalName()); if (annotation.authenticationType() == Resource.AuthenticationType.CONTAINER) { resource.setAuth("Container"); } } }	protected static void loadApplicationFilterAnnotations(Context context) { FilterDef[] filterDefs = context.findFilterDefs(); for (int i = 0; i < filterDefs.length; i++) { loadClassAnnotation(context, (filterDefs[i]).getFilterClass()); } }	protected static void loadApplicationListenerAnnotations(Context context) { String[] applicationListeners = context.findApplicationListeners(); for (int i = 0; i < applicationListeners.length; i++) { loadClassAnnotation(context, applicationListeners[i]); } }	protected static void loadApplicationServletAnnotations(Context context) { ClassLoader classLoader = context.getLoader().getClassLoader(); Wrapper wrapper = null; Class<?> classClass = null; Container[] children = context.findChildren(); for (int i = 0; i < children.length; i++) { if (children[i] instanceof Wrapper) { wrapper = (Wrapper) children[i]; if (wrapper.getServletClass() == null) { continue; } try { classClass = classLoader.loadClass(wrapper.getServletClass()); } catch (ClassNotFoundException e) { // We do nothing } catch (NoClassDefFoundError e) { // We do nothing } if (classClass == null) { continue; } loadClassAnnotation(context, wrapper.getServletClass()); if (classClass.isAnnotationPresent(RunAs.class)) { RunAs annotation = classClass.getAnnotation(RunAs.class); wrapper.setRunAs(annotation.value()); } } } }	protected static void loadClassAnnotation(Context context, String fileString) { ClassLoader classLoader = context.getLoader().getClassLoader(); Class<?> classClass = null; try { classClass = classLoader.loadClass(fileString); } catch (ClassNotFoundException e) { // We do nothing } catch (NoClassDefFoundError e) { // We do nothing } if (classClass == null) { return; } if (classClass.isAnnotationPresent(Resource.class)) { Resource annotation = classClass.getAnnotation(Resource.class); addResource(context, annotation); } if (classClass.isAnnotationPresent(Resources.class)) { Resources annotation = classClass.getAnnotation(Resources.class); for (int i = 0; annotation.value() != null && i < annotation.value().length; i++) { addResource(context, annotation.value()[i]); } } if (classClass.isAnnotationPresent(DeclareRoles.class)) { DeclareRoles annotation = classClass.getAnnotation(DeclareRoles.class); for (int i = 0; annotation.value() != null && i < annotation.value().length; i++) { context.addSecurityRole(annotation.value()[i]); } } }
@Override protected void initInternal() throws LifecycleException { super.initInternal(); // Register global String cache // Note although the cache is global, if there are multiple Servers // present in the JVM (may happen when embedding) then the same cache onameStringCache = register(new StringCache(), "type=StringCache"); MBeanFactory factory = new MBeanFactory(); factory.setContainer(this); onameMBeanFactory = register(factory, "type=MBeanFactory"); globalNamingResources.init(); if (getCatalina() != null) { ClassLoader cl = getCatalina().getParentClassLoader(); while (cl != ClassLoader.getSystemClassLoader()) { if (cl instanceof URLClassLoader) { URL[] urls = ((URLClassLoader) cl).getURLs(); for (URL url : urls) { if (url.getProtocol().equals("file")) { try { File f = new File(url.toURI()); if (f.isFile() && f.getName().endsWith(".jar")) { ExtensionValidator.addSystemResource(f); } } catch (URISyntaxException e) { // Ignore } catch (IOException e) { // Ignore } } } } cl = cl.getParent(); } } for (int i = 0; i < services.length; i++) { services[i].init(); } }
private PooledConnection borrowConnection(int wait, String username, String password) throws SQLException { if (isClosed()) { throw new SQLException("Connection pool closed."); } //end if long now = System.currentTimeMillis(); PooledConnection con = idle.poll(); while (true) { if (con != null) { PooledConnection result = borrowConnection(now, con, username, password); if (result != null) return result; } if (size.get() < getPoolProperties().getMaxActive()) { if (size.addAndGet(1) > getPoolProperties().getMaxActive()) { size.decrementAndGet(); } else { return createConnection(now, con, username, password); } } //end if long maxWait = wait; if (wait == -1) { maxWait = (getPoolProperties().getMaxWait() <= 0) ? Long.MAX_VALUE : getPoolProperties().getMaxWait(); } long timetowait = Math.max(0, maxWait - (System.currentTimeMillis() - now)); waitcount.incrementAndGet(); try { con = idle.poll(timetowait, TimeUnit.MILLISECONDS); } catch (InterruptedException ex) { Thread.interrupted(); SQLException sx = new SQLException("Pool wait interrupted."); sx.initCause(ex); throw sx; } finally { waitcount.decrementAndGet(); } if (maxWait == 0 && con == null) { if (jmxPool != null) { jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.POOL_EMPTY, "Pool empty - no wait."); } throw new PoolExhaustedException("[" + Thread.currentThread().getName() + "] " + "NoWait: Pool empty. Unable to fetch a connection, none available[" + busy.size() + " in use]."); } if (con == null) { if ((System.currentTimeMillis() - now) >= maxWait) { if (jmxPool != null) { jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.POOL_EMPTY, "Pool empty - timeout."); } throw new PoolExhaustedException("[" + Thread.currentThread().getName() + "] " + "Timeout: Pool empty. Unable to fetch a connection in " + (maxWait / 1000) + " seconds, none available[size:" + size.get() + "; busy:" + busy.size() + "; idle:" + idle.size() + "; lastwait:" + timetowait + "]."); } else { continue; } } } //while }	protected void close(boolean force) { if (this.closed) return; this.closed = true; if (poolCleaner != null) { poolCleaner.stopRunning(); } BlockingQueue<PooledConnection> pool = (idle.size() > 0) ? idle : (force ? busy : idle); while (pool.size() > 0) { try { PooledConnection con = pool.poll(1000, TimeUnit.MILLISECONDS); while (con != null) { if (pool == idle) release(con); else abandon(con); if (pool.size() > 0) { con = pool.poll(1000, TimeUnit.MILLISECONDS); } else { break; } } //while } catch (InterruptedException ex) { Thread.interrupted(); } if (pool.size() == 0 && force && pool != busy) pool = busy; } if (this.getPoolProperties().isJmxEnabled()) this.jmxPool = null; PoolProperties.InterceptorDefinition[] proxies = getPoolProperties().getJdbcInterceptorsAsArray(); for (int i = 0; i < proxies.length; i++) { try { proxies[i].getInterceptorClass().newInstance().poolClosed(this); } catch (Exception x) { log.debug("Unable to inform interceptor of pool closure.", x); } } }	@Override public boolean getLogValidationErrors() { return getPoolProperties().getLogValidationErrors(); }	@Override public boolean getLogValidationErrors() { return this.logValidationErrors; }	@Override public boolean getLogValidationErrors() { return getPoolProperties().getLogValidationErrors(); }
@Override public void removeValve(Valve valve) { Valve current; if (first == valve) { first = first.getNext(); current = null; } else { current = first; } while (current != null) { if (current.getNext() == valve) { current.setNext(valve.getNext()); break; } current = current.getNext(); } if (first == basic) first = null; if (valve instanceof Contained) ((Contained) valve).setContainer(null); if (getState().isAvailable()) { if (valve instanceof Lifecycle) { try { ((Lifecycle) valve).stop(); } catch (LifecycleException e) { log.error("StandardPipeline.removeValve: stop: ", e); } } } try { ((Lifecycle) valve).destroy(); } catch (LifecycleException e) { log.error("StandardPipeline.removeValve: destroy: ", e); } container.fireContainerEvent(Container.REMOVE_VALVE_EVENT, valve); }

@Override public boolean getUseDisposableConnectionFacade() { return getPoolProperties().getUseDisposableConnectionFacade(); }	@Override public boolean getUseDisposableConnectionFacade() { return useDisposableConnectionFacade; }	@Override public boolean getUseDisposableConnectionFacade() { return getPoolProperties().getUseDisposableConnectionFacade(); }	public boolean validate(int validateAction, String sql) { if (this.isDiscarded()) { return false; } if (!doValidate(validateAction)) { return true; } long now = System.currentTimeMillis(); if (validateAction != VALIDATE_INIT && poolProperties.getValidationInterval() > 0 && (now - this.lastValidated) < poolProperties.getValidationInterval()) { return true; } if (poolProperties.getValidator() != null) { if (poolProperties.getValidator().validate(connection, validateAction)) { this.lastValidated = now; return true; } else { return false; } } String query = sql; if (validateAction == VALIDATE_INIT && poolProperties.getInitSQL() != null) { query = poolProperties.getInitSQL(); } if (query == null) { query = poolProperties.getValidationQuery(); } Statement stmt = null; try { stmt = connection.createStatement(); stmt.execute(query); stmt.close(); this.lastValidated = now; return true; } catch (Exception ignore) { if (log.isDebugEnabled()) log.debug("Unable to validate object:", ignore); if (stmt != null) try { stmt.close(); } catch (Exception ignore2) { /*NOOP*/ } } return false; }
private PooledConnection borrowConnection(int wait, String username, String password) throws SQLException { if (isClosed()) { throw new SQLException("Connection pool closed."); } //end if long now = System.currentTimeMillis(); PooledConnection con = idle.poll(); while (true) { if (con != null) { PooledConnection result = borrowConnection(now, con, username, password); if (result != null) return result; } if (size.get() < getPoolProperties().getMaxActive()) { if (size.addAndGet(1) > getPoolProperties().getMaxActive()) { size.decrementAndGet(); } else { return createConnection(now, con, username, password); } } //end if long maxWait = wait; if (wait == -1) { maxWait = (getPoolProperties().getMaxWait() <= 0) ? Long.MAX_VALUE : getPoolProperties().getMaxWait(); } long timetowait = Math.max(0, maxWait - (System.currentTimeMillis() - now)); waitcount.incrementAndGet(); try { con = idle.poll(timetowait, TimeUnit.MILLISECONDS); } catch (InterruptedException ex) { Thread.interrupted(); SQLException sx = new SQLException("Pool wait interrupted."); sx.initCause(ex); throw sx; } finally { waitcount.decrementAndGet(); } if (maxWait == 0 && con == null) { throw new SQLException("[" + Thread.currentThread().getName() + "] " + "NoWait: Pool empty. Unable to fetch a connection, none available[" + busy.size() + " in use]."); } if (con == null) { if ((System.currentTimeMillis() - now) >= maxWait) { throw new SQLException("[" + Thread.currentThread().getName() + "] " + "Timeout: Pool empty. Unable to fetch a connection in " + (maxWait / 1000) + " seconds, none available[size:" + size.get() + "; busy:" + busy.size() + "; idle:" + idle.size() + "; lastwait:" + timetowait + "]."); } else { continue; } } } //while }	public static MBeanNotificationInfo[] getDefaultNotificationInfo() { String[] types = new String[] { NOTIFY_INIT, NOTIFY_CONNECT, NOTIFY_ABANDON, SLOW_QUERY_NOTIFICATION, FAILED_QUERY_NOTIFICATION, SUSPECT_ABANDONED_NOTIFICATION }; String name = Notification.class.getName(); String description = "A connection pool error condition was met."; MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description); return new MBeanNotificationInfo[] { info }; }
@Override protected String reportFailedQuery(String query, Object[] args, String name, long start, Throwable t) { String sql = super.reportFailedQuery(query, args, name, start, t); if (this.maxQueries > 0) { long now = System.currentTimeMillis(); long delta = now - start; QueryStats qs = this.getQueryStats(sql); qs.failure(delta, now); } return sql; }	@Override protected String reportSlowQuery(String query, Object[] args, String name, long start, long delta) { String sql = super.reportSlowQuery(query, args, name, start, delta); if (this.maxQueries > 0) { QueryStats qs = this.getQueryStats(sql); qs.add(delta, start); } return sql; }
public boolean processSocket(NioChannel socket, SocketStatus status, boolean dispatch) { try { KeyAttachment attachment = (KeyAttachment) socket.getAttachment(false); attachment.setCometNotify(false); SocketProcessor sc = processorCache.poll(); if (sc == null) sc = new SocketProcessor(socket, status); else sc.reset(socket, status); if (dispatch && getExecutor() != null) getExecutor().execute(sc); else sc.run(); } catch (RejectedExecutionException rx) { log.warn("Socket processing request was rejected for:" + socket, rx); return false; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); // This means we got an OOM or similar creating a thread, or that log.error(sm.getString("endpoint.process.fail"), t); return false; } return true; }
protected void doUnload() throws IOException { if (log.isDebugEnabled()) log.debug(sm.getString("standardManager.unloading.debug")); if (sessions.isEmpty()) { log.debug(sm.getString("standardManager.unloading.nosessions")); return; } File file = file(); if (file == null) return; if (log.isDebugEnabled()) log.debug(sm.getString("standardManager.unloading", pathname)); FileOutputStream fos = null; ObjectOutputStream oos = null; try { fos = new FileOutputStream(file.getAbsolutePath()); oos = new ObjectOutputStream(new BufferedOutputStream(fos)); } catch (IOException e) { log.error(sm.getString("standardManager.unloading.ioe", e), e); if (fos != null) { try { fos.close(); } catch (IOException f) { // Ignore } } throw e; } ArrayList<StandardSession> list = new ArrayList<StandardSession>(); synchronized (sessions) { if (log.isDebugEnabled()) log.debug("Unloading " + sessions.size() + " sessions"); try { oos.writeObject(new Integer(sessions.size())); Iterator<Session> elements = sessions.values().iterator(); while (elements.hasNext()) { StandardSession session = (StandardSession) elements.next(); list.add(session); session.passivate(); session.writeObjectData(oos); } } catch (IOException e) { log.error(sm.getString("standardManager.unloading.ioe", e), e); try { oos.close(); } catch (IOException f) { // Ignore } throw e; } } try { oos.flush(); } finally { try { oos.close(); } catch (IOException f) { // Ignore } } if (log.isDebugEnabled()) log.debug("Expiring " + list.size() + " persisted sessions"); Iterator<StandardSession> expires = list.iterator(); while (expires.hasNext()) { StandardSession session = expires.next(); try { session.expire(false); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } finally { session.recycle(); } } if (log.isDebugEnabled()) log.debug("Unloading complete"); }
private Thread[] getThreads() { ThreadGroup tg = Thread.currentThread().getThreadGroup(); while (tg.getParent() != null) { tg = tg.getParent(); } int threadCountGuess = tg.activeCount() + 50; Thread[] threads = new Thread[threadCountGuess]; int threadCountActual = tg.enumerate(threads); while (threadCountActual == threadCountGuess) { threadCountGuess *= 2; threads = new Thread[threadCountGuess]; // Note tg.enumerate(Thread[]) silently ignores any threads that threadCountActual = tg.enumerate(threads); } return threads; }	private void checkThreadLocalsForLeaks() { Thread[] threads = getThreads(); try { // Make the fields in the Thread class that store ThreadLocals Field threadLocalsField = Thread.class.getDeclaredField("threadLocals"); threadLocalsField.setAccessible(true); Field inheritableThreadLocalsField = Thread.class.getDeclaredField("inheritableThreadLocals"); inheritableThreadLocalsField.setAccessible(true); // Make the underlying array of ThreadLoad.ThreadLocalMap.Entry objects Class<?> tlmClass = Class.forName("java.lang.ThreadLocal$ThreadLocalMap"); Field tableField = tlmClass.getDeclaredField("table"); tableField.setAccessible(true); for (int i = 0; i < threads.length; i++) { Object threadLocalMap; if (threads[i] != null) { threadLocalMap = threadLocalsField.get(threads[i]); checkThreadLocalMapForLeaks(threadLocalMap, tableField); threadLocalMap = inheritableThreadLocalsField.get(threads[i]); checkThreadLocalMapForLeaks(threadLocalMap, tableField); } } } catch (SecurityException e) { log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail", contextName), e); } catch (NoSuchFieldException e) { log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail", contextName), e); } catch (ClassNotFoundException e) { log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail", contextName), e); } catch (IllegalArgumentException e) { log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail", contextName), e); } catch (IllegalAccessException e) { log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail", contextName), e); } }	private void clearReferencesStopTimerThread(Thread thread) { try { Field newTasksMayBeScheduledField = thread.getClass().getDeclaredField("newTasksMayBeScheduled"); newTasksMayBeScheduledField.setAccessible(true); Field queueField = thread.getClass().getDeclaredField("queue"); queueField.setAccessible(true); Object queue = queueField.get(thread); Method clearMethod = queue.getClass().getDeclaredMethod("clear"); clearMethod.setAccessible(true); synchronized (queue) { newTasksMayBeScheduledField.setBoolean(thread, false); clearMethod.invoke(queue); queue.notify(); } log.error(sm.getString("webappClassLoader.warnTimerThread", contextName, thread.getName())); } catch (Exception e) { Throwable t = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(t); log.warn(sm.getString("webappClassLoader.stopTimerThreadFail", thread.getName(), contextName), t); } }	@SuppressWarnings("deprecation") private void clearReferencesThreads() { Thread[] threads = getThreads(); for (Thread thread : threads) { if (thread != null) { ClassLoader ccl = thread.getContextClassLoader(); if (ccl == this) { if (thread == Thread.currentThread()) { continue; } ThreadGroup tg = thread.getThreadGroup(); if (tg != null && JVM_THREAD_GROUP_NAMES.contains(tg.getName())) { if (clearReferencesHttpClientKeepAliveThread && thread.getName().equals("Keep-Alive-Timer")) { thread.setContextClassLoader(parent); log.debug(sm.getString("webappClassLoader.checkThreadsHttpClient")); } continue; } if (!thread.isAlive()) { continue; } if (thread.getClass().getName().equals("java.util.TimerThread") && clearReferencesStopTimerThreads) { clearReferencesStopTimerThread(thread); continue; } if (isRequestThread(thread)) { log.error(sm.getString("webappClassLoader.warnRequestThread", contextName, thread.getName())); } else { log.error(sm.getString("webappClassLoader.warnThread", contextName, thread.getName())); } if (!clearReferencesStopThreads) { continue; } try { Field targetField = thread.getClass().getDeclaredField("target"); targetField.setAccessible(true); Object target = targetField.get(thread); if (target != null && target.getClass().getCanonicalName().equals("java.util.concurrent.ThreadPoolExecutor.Worker")) { Field executorField = target.getClass().getDeclaredField("this$0"); executorField.setAccessible(true); Object executor = executorField.get(target); if (executor instanceof ThreadPoolExecutor) { ((ThreadPoolExecutor) executor).shutdownNow(); } } } catch (SecurityException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } catch (NoSuchFieldException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } catch (IllegalArgumentException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } catch (IllegalAccessException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } // This method is deprecated and for good reason. This is // very risky code but is the only option at this point. // A *very* good reason for apps to do this clean-up thread.stop(); } } } }
public void generatePostamble() { ServletWriter out = this.classBuffer.getOut(); for (int i = 0; i < fragments.size(); i++) { Fragment fragment = fragments.get(i); fragment.getGenBuffer().adjustJavaLines(out.getJavaLine() - 1); out.printMultiLn(fragment.getGenBuffer().toString()); } out.printil("public void invoke( java.io.Writer writer )"); out.pushIndent(); out.printil("throws javax.servlet.jsp.JspException"); out.popIndent(); out.printil("{"); out.pushIndent(); out.printil("javax.servlet.jsp.JspWriter out = null;"); out.printil("if( writer != null ) {"); out.pushIndent(); out.printil("out = this.jspContext.pushBody(writer);"); out.popIndent(); out.printil("} else {"); out.pushIndent(); out.printil("out = this.jspContext.getOut();"); out.popIndent(); out.printil("}"); out.printil("try {"); out.pushIndent(); out.printil("this.jspContext.getELContext().putContext(javax.servlet.jsp.JspContext.class,this.jspContext);"); out.printil("switch( this.discriminator ) {"); out.pushIndent(); for (int i = 0; i < fragments.size(); i++) { out.printil("case " + i + ":"); out.pushIndent(); out.printil("invoke" + i + "( out );"); out.printil("break;"); out.popIndent(); } out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); out.printil("catch( java.lang.Throwable e ) {"); out.pushIndent(); out.printil("if (e instanceof javax.servlet.jsp.SkipPageException)"); out.printil(" throw (javax.servlet.jsp.SkipPageException) e;"); out.printil("throw new javax.servlet.jsp.JspException( e );"); out.popIndent(); out.printil("}"); out.printil("finally {"); out.pushIndent(); out.printil("if( writer != null ) {"); out.pushIndent(); out.printil("this.jspContext.popBody();"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); out.popIndent(); }	@Override public void visit(Node.InvokeAction n) throws JasperException { n.setBeginJavaLine(out.getJavaLine()); // Copy virtual page scope of tag file to page scope of invoking out.printil("((org.apache.jasper.runtime.JspContextWrapper) this.jspContext).syncBeforeInvoke();"); String varReaderAttr = n.getTextAttribute("varReader"); String varAttr = n.getTextAttribute("var"); if (varReaderAttr != null || varAttr != null) { out.printil("_jspx_sout = new java.io.StringWriter();"); } else { out.printil("_jspx_sout = null;"); } out.printin("if ("); out.print(toGetterMethod(n.getTextAttribute("fragment"))); out.println(" != null) {"); out.pushIndent(); out.printin(toGetterMethod(n.getTextAttribute("fragment"))); out.println(".invoke(_jspx_sout);"); out.popIndent(); out.printil("}"); if (varReaderAttr != null || varAttr != null) { String scopeName = n.getTextAttribute("scope"); out.printin("_jspx_page_context.setAttribute("); if (varReaderAttr != null) { out.print(quote(varReaderAttr)); out.print(", new java.io.StringReader(_jspx_sout.toString())"); } else { out.print(quote(varAttr)); out.print(", _jspx_sout.toString()"); } if (scopeName != null) { out.print(", "); out.print(getScopeConstant(scopeName)); } out.println(");"); } out.printil("jspContext.getELContext().putContext(javax.servlet.jsp.JspContext.class,getJspContext());"); n.setEndJavaLine(out.getJavaLine()); }
protected Principal getPrincipal(X509Certificate usercert) { return (getPrincipal(usercert.getSubjectDN().getName())); }	@Override protected void initInternal() throws LifecycleException { super.initInternal(); if (container != null) { this.containerLog = container.getLogger(); } }	protected String getRealmSuffix() { return ",realmPath=" + getRealmPath(); }	public void setValidate(boolean validate) { this.validate = validate; }
protected boolean validate(String name) { if (name == null) { return false; } if (name.startsWith("java.")) { return false; } if (name.startsWith("javax.servlet.jsp.jstl")) { return true; } if (name.startsWith("javax.servlet.")) { return false; } if (name.startsWith("javax.el")) { return false; } return true; }	protected boolean validateJarFile(File jarfile) throws IOException { if (triggers == null) return (true); JarFile jarFile = new JarFile(jarfile); for (int i = 0; i < triggers.length; i++) { Class<?> clazz = null; try { if (parent != null) { clazz = parent.loadClass(triggers[i]); } else { clazz = Class.forName(triggers[i]); } } catch (Exception e) { clazz = null; } if (clazz == null) continue; String name = triggers[i].replace('.', '/') + ".class"; if (log.isDebugEnabled()) log.debug(" Checking for " + name); JarEntry jarEntry = jarFile.getJarEntry(name); if (jarEntry != null) { log.info("validateJarFile(" + jarfile + ") - jar not loaded. See Servlet Spec 2.3, " + "section 9.7.2. Offending class: " + name); jarFile.close(); return (false); } } jarFile.close(); return (true); }
protected Object lookup(Name name, boolean resolveLinks) throws NamingException { while ((!name.isEmpty()) && (name.get(0).length() == 0)) name = name.getSuffix(1); if (name.isEmpty()) { return new NamingContext(env, this.name, bindings); } NamingEntry entry = bindings.get(name.get(0)); if (entry == null) { throw new NameNotFoundException(sm.getString("namingContext.nameNotBound", name.get(0))); } if (name.size() > 1) { if (entry.type != NamingEntry.CONTEXT) { throw new NamingException(sm.getString("namingContext.contextExpected")); } return ((Context) entry.value).lookup(name.getSuffix(1)); } else { if ((resolveLinks) && (entry.type == NamingEntry.LINK_REF)) { String link = ((LinkRef) entry.value).getLinkName(); if (link.startsWith(".")) { return lookup(link.substring(1)); } else { return (new InitialContext(env)).lookup(link); } } else if (entry.type == NamingEntry.REFERENCE) { try { Object obj = NamingManager.getObjectInstance(entry.value, name, this, env); if (entry.value instanceof ResourceRef) { boolean singleton = Boolean.parseBoolean((String) ((ResourceRef) entry.value).get("singleton").getContent()); if (singleton) { entry.type = NamingEntry.ENTRY; entry.value = obj; } } return obj; } catch (NamingException e) { throw e; } catch (Exception e) { log.warn(sm.getString("namingContext.failResolvingReference"), e); throw new NamingException(e.getMessage()); } } else { return entry.value; } } }	protected void bind(Name name, Object obj, boolean rebind) throws NamingException { if (!checkWritable()) { return; } while ((!name.isEmpty()) && (name.get(0).length() == 0)) name = name.getSuffix(1); if (name.isEmpty()) throw new NamingException(sm.getString("namingContext.invalidName")); NamingEntry entry = bindings.get(name.get(0)); if (name.size() > 1) { if (entry == null) { throw new NameNotFoundException(sm.getString("namingContext.nameNotBound", name.get(0))); } if (entry.type == NamingEntry.CONTEXT) { if (rebind) { ((Context) entry.value).rebind(name.getSuffix(1), obj); } else { ((Context) entry.value).bind(name.getSuffix(1), obj); } } else { throw new NamingException(sm.getString("namingContext.contextExpected")); } } else { if ((!rebind) && (entry != null)) { throw new NameAlreadyBoundException(sm.getString("namingContext.alreadyBound", name.get(0))); } else { // Getting the type of the object and wrapping it within a new Object toBind = NamingManager.getStateToBind(obj, name, this, env); if (toBind instanceof Context) { entry = new NamingEntry(name.get(0), toBind, NamingEntry.CONTEXT); } else if (toBind instanceof LinkRef) { entry = new NamingEntry(name.get(0), toBind, NamingEntry.LINK_REF); } else if (toBind instanceof Reference) { entry = new NamingEntry(name.get(0), toBind, NamingEntry.REFERENCE); } else if (toBind instanceof Referenceable) { toBind = ((Referenceable) toBind).getReference(); entry = new NamingEntry(name.get(0), toBind, NamingEntry.REFERENCE); } else { entry = new NamingEntry(name.get(0), toBind, NamingEntry.ENTRY); } bindings.put(name.get(0), entry); } } }	@Override public void destroySubcontext(Name name) throws NamingException { if (!checkWritable()) { return; } while ((!name.isEmpty()) && (name.get(0).length() == 0)) name = name.getSuffix(1); if (name.isEmpty()) throw new NamingException(sm.getString("namingContext.invalidName")); NamingEntry entry = bindings.get(name.get(0)); if (entry == null) { throw new NameNotFoundException(sm.getString("namingContext.nameNotBound", name.get(0))); } if (name.size() > 1) { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).destroySubcontext(name.getSuffix(1)); } else { throw new NamingException(sm.getString("namingContext.contextExpected")); } } else { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).close(); bindings.remove(name.get(0)); } else { throw new NotContextException(sm.getString("namingContext.contextExpected")); } } }	@Override public NamingEnumeration<Binding> listBindings(String name) throws NamingException { return listBindings(new CompositeName(name)); }	@Override public void unbind(Name name) throws NamingException { if (!checkWritable()) { return; } while ((!name.isEmpty()) && (name.get(0).length() == 0)) name = name.getSuffix(1); if (name.isEmpty()) throw new NamingException(sm.getString("namingContext.invalidName")); NamingEntry entry = bindings.get(name.get(0)); if (entry == null) { throw new NameNotFoundException(sm.getString("namingContext.nameNotBound", name.get(0))); } if (name.size() > 1) { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).unbind(name.getSuffix(1)); } else { throw new NamingException(sm.getString("namingContext.contextExpected")); } } else { bindings.remove(name.get(0)); } }
public void execute() throws JasperException { if (log.isDebugEnabled()) { log.debug("execute() starting for " + pages.size() + " pages."); } try { if (uriRoot == null) { if (pages.size() == 0) { throw new JasperException(Localizer.getMessage("jsp.error.jspc.missingTarget")); } String firstJsp = pages.get(0); File firstJspF = new File(firstJsp); if (!firstJspF.exists()) { throw new JasperException(Localizer.getMessage("jspc.error.fileDoesNotExist", firstJsp)); } locateUriRoot(firstJspF); } if (uriRoot == null) { throw new JasperException(Localizer.getMessage("jsp.error.jspc.no_uriroot")); } if (context == null) { initServletContext(); } if (pages.size() == 0) { scanFiles(new File(uriRoot)); } File uriRootF = new File(uriRoot); if (!uriRootF.exists() || !uriRootF.isDirectory()) { throw new JasperException(Localizer.getMessage("jsp.error.jspc.uriroot_not_dir")); } initWebXml(); Iterator<String> iter = pages.iterator(); while (iter.hasNext()) { String nextjsp = iter.next().toString(); File fjsp = new File(nextjsp); if (!fjsp.isAbsolute()) { fjsp = new File(uriRootF, nextjsp); } if (!fjsp.exists()) { if (log.isWarnEnabled()) { log.warn(Localizer.getMessage("jspc.error.fileDoesNotExist", fjsp.toString())); } continue; } String s = fjsp.getAbsolutePath(); if (s.startsWith(uriRoot)) { nextjsp = s.substring(uriRoot.length()); } if (nextjsp.startsWith("." + File.separatorChar)) { nextjsp = nextjsp.substring(2); } processFile(nextjsp); } completeWebXml(); if (addWebXmlMappings) { mergeIntoWebXml(); } } catch (IOException ioe) { throw new JasperException(ioe); } catch (JasperException je) { Throwable rootCause = je; while (rootCause instanceof JasperException && ((JasperException) rootCause).getRootCause() != null) { rootCause = ((JasperException) rootCause).getRootCause(); } if (rootCause != je) { rootCause.printStackTrace(); } throw je; } finally { if (loader != null) { LogFactory.release(loader); } } }
public int write(ByteBuffer buf, NioChannel socket, long writeTimeout) throws IOException { SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); if (key == null) throw new IOException("Key no longer registered"); KeyReference reference = new KeyReference(); KeyAttachment att = (KeyAttachment) key.attachment(); int written = 0; boolean timedout = false; int keycount = 1; long time = System.currentTimeMillis(); try { while ((!timedout) && buf.hasRemaining()) { if (keycount > 0) { //only write if we were registered for a write int cnt = socket.write(buf); if (cnt == -1) throw new EOFException(); written += cnt; if (cnt > 0) { time = System.currentTimeMillis(); continue; } } try { if (att.getWriteLatch() == null || att.getWriteLatch().getCount() == 0) att.startWriteLatch(1); poller.add(att, SelectionKey.OP_WRITE, reference); att.awaitWriteLatch(writeTimeout, TimeUnit.MILLISECONDS); } catch (InterruptedException ignore) { Thread.interrupted(); } if (att.getWriteLatch() != null && att.getWriteLatch().getCount() > 0) { keycount = 0; } else { keycount = 1; att.resetWriteLatch(); } if (writeTimeout > 0 && (keycount == 0)) timedout = (System.currentTimeMillis() - time) >= writeTimeout; } if (timedout) throw new SocketTimeoutException(); } finally { poller.remove(att, SelectionKey.OP_WRITE); if (timedout && reference.key != null) { poller.cancelKey(reference.key); } reference.key = null; } return written; }
protected void open() throws SQLException { if (conn != null) { return; } if (driver == null) { try { Class<?> clazz = Class.forName(driverName); driver = (Driver) clazz.newInstance(); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); throw new SQLException(e.getMessage(), e); } } Properties props = new Properties(); props.put("autoReconnect", "true"); if (connectionName != null) { props.put("user", connectionName); } if (connectionPassword != null) { props.put("password", connectionPassword); } conn = driver.connect(connectionURL, props); conn.setAutoCommit(true); String logPattern = pattern; if (logPattern.equals("common")) { ps = conn.prepareStatement("INSERT INTO " + tableName + " (" + remoteHostField + ", " + userField + ", " + timestampField + ", " + queryField + ", " + statusField + ", " + bytesField + ") VALUES(?, ?, ?, ?, ?, ?)"); } else if (logPattern.equals("combined")) { ps = conn.prepareStatement("INSERT INTO " + tableName + " (" + remoteHostField + ", " + userField + ", " + timestampField + ", " + queryField + ", " + statusField + ", " + bytesField + ", " + virtualHostField + ", " + methodField + ", " + refererField + ", " + userAgentField + ") VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"); } }
public boolean authenticate(Request request, HttpServletResponse response) throws IOException { Principal principal = request.getUserPrincipal(); if (principal != null) { if (containerLog.isDebugEnabled()) containerLog.debug("Already authenticated as '" + principal.getName() + "'"); if (cache) { Session session = request.getSessionInternal(true); // save the inherited Principal (if necessary) in this session.setPrincipal(principal); String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (ssoId != null) { if (containerLog.isDebugEnabled()) containerLog.debug("User authenticated by existing SSO"); associate(ssoId, session); } } return true; } if (containerLog.isDebugEnabled()) containerLog.debug("User authenticated without any roles"); return true; }
static String getClassNameServices(ClassLoader tccl) { InputStream is = null; if (tccl == null) { is = ClassLoader.getSystemResourceAsStream(SERVICE_RESOURCE_NAME); } else { is = tccl.getResourceAsStream(SERVICE_RESOURCE_NAME); } if (is != null) { String line = null; BufferedReader br = null; try { br = new BufferedReader(new InputStreamReader(is, "UTF-8")); line = br.readLine(); if (line != null && line.trim().length() > 0) { return line.trim(); } } catch (UnsupportedEncodingException e) { // Should never happen with UTF-8 // If it does - ignore & return null } catch (IOException e) { throw new ELException("Failed to read " + SERVICE_RESOURCE_NAME, e); } finally { try { if (br != null) { br.close(); } } catch (IOException ioe) { /*Ignore*/ } try { is.close(); } catch (IOException ioe) { /*Ignore*/ } } } return null; }
protected void generateClass(String[] smap) throws FileNotFoundException, JasperException, Exception { long t1 = 0; if (log.isDebugEnabled()) { t1 = System.currentTimeMillis(); } final String sourceFile = ctxt.getServletJavaFileName(); final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); String packageName = ctxt.getServletPackageName(); final String targetClassName = ((packageName.length() != 0) ? (packageName + ".") : "") + ctxt.getServletClassName(); final ClassLoader classLoader = ctxt.getJspLoader(); String[] fileNames = new String[] {sourceFile}; String[] classNames = new String[] {targetClassName}; final ArrayList<JavacErrorDetail> problemList = new ArrayList<JavacErrorDetail>(); class CompilationUnit implements ICompilationUnit { private final String className; private final String sourceFile; CompilationUnit(String sourceFile, String className) { this.className = className; this.sourceFile = sourceFile; } @Override public char[] getFileName() { return sourceFile.toCharArray(); } @Override public char[] getContents() { char[] result = null; FileInputStream is = null; Reader reader = null; try { is = new FileInputStream(sourceFile); reader = new BufferedReader(new InputStreamReader(is, ctxt.getOptions().getJavaEncoding())); char[] chars = new char[8192]; StringBuilder buf = new StringBuilder(); int count; while ((count = reader.read(chars, 0, chars.length)) > 0) { buf.append(chars, 0, count); } result = new char[buf.length()]; buf.getChars(0, result.length, result, 0); } catch (IOException e) { log.error("Compilation error", e); } finally { if (reader != null) { try { reader.close(); } catch (IOException ioe) {/*Ignore*/} } if (is != null) { try { is.close(); } catch (IOException exc) {/*Ignore*/} } } return result; } @Override public char[] getMainTypeName() { int dot = className.lastIndexOf('.'); if (dot > 0) { return className.substring(dot + 1).toCharArray(); } return className.toCharArray(); } @Override public char[][] getPackageName() { StringTokenizer izer = new StringTokenizer(className, "."); char[][] result = new char[izer.countTokens()-1][]; for (int i = 0; i < result.length; i++) { String tok = izer.nextToken(); result[i] = tok.toCharArray(); } return result; } @SuppressWarnings("unused") } } } }
@Override public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.BEFORE_STOP_EVENT.equals(event.getType())) { Iterator<Request> iterator = cometRequests.iterator(); while (iterator.hasNext()) { Request request = iterator.next(); // Remove the session tracking attribute as it isn't HttpSession session = request.getSession(false); if (session != null) { session.removeAttribute(cometRequestsAttribute); } try { CometEventImpl cometEvent = request.getEvent(); cometEvent.setEventType(CometEvent.EventType.END); cometEvent.setEventSubType(CometEvent.EventSubType.WEBAPP_RELOAD); getNext().event(request, request.getResponse(), cometEvent); cometEvent.close(); } catch (Exception e) { container.getLogger().warn(sm.getString("cometConnectionManagerValve.event"), e); } } cometRequests.clear(); } }
protected void deployWAR(ContextName cn, File war) { JarFile jar = null; JarEntry entry = null; InputStream istream = null; BufferedOutputStream ostream = null; File xml; if (copyXML) { xml = new File(configBase(), cn.getBaseName() + ".xml"); } else { xml = new File(host.getAppBaseFile(), cn.getBaseName() + "/META-INF/context.xml"); } boolean xmlInWar = false; if (deployXML && !xml.exists()) { try { jar = new JarFile(war); entry = jar.getJarEntry(Constants.ApplicationContextXml); if (entry != null) { xmlInWar = true; } if ((copyXML || unpackWARs) && xmlInWar) { istream = jar.getInputStream(entry); ostream = new BufferedOutputStream(new FileOutputStream(xml), 1024); byte[] buffer = new byte[1024]; while (true) { int n = istream.read(buffer); if (n < 0) { break; } ostream.write(buffer, 0, n); } ostream.flush(); ostream.close(); ostream = null; istream.close(); istream = null; } } catch (IOException e) { /* Ignore */ } finally { if (ostream != null) { try { ostream.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } ostream = null; } if (istream != null) { try { istream.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } istream = null; } entry = null; if (jar != null) { try { jar.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } jar = null; } } } DeployedApplication deployedApp = new DeployedApplication(cn.getName()); if (log.isInfoEnabled()) log.info(sm.getString("hostConfig.deployWar", war.getAbsolutePath())); Context context = null; try { if (deployXML && xml.exists()) { synchronized (digester) { try { context = (Context) digester.parse(xml); } catch (Exception e) { log.error(sm.getString("hostConfig.deployDescriptor.error", war.getAbsolutePath())); context = new FailedContext(); } finally { digester.reset(); } } context.setConfigFile(xml.toURI().toURL()); } else if (deployXML && xmlInWar) { synchronized (digester) { try { jar = new JarFile(war); entry = jar.getJarEntry(Constants.ApplicationContextXml); istream = jar.getInputStream(entry); context = (Context) digester.parse(istream); } catch (Exception e) { log.error(sm.getString("hostConfig.deployDescriptor.error", war.getAbsolutePath())); } finally { if (context == null) { context = new FailedContext(); } context.setConfigFile(new URL("jar:" + war.toURI().toString() + "!/" + Constants.ApplicationContextXml)); if (istream != null) { try { istream.close(); } catch (IOException e) { /* Ignore */ } istream = null; } entry = null; if (jar != null) { try { jar.close(); } catch (IOException e) { /* Ignore */ } jar = null; } digester.reset(); } } } else { context = (Context) Class.forName(contextClass).newInstance(); } deployedApp.redeployResources.put(war.getAbsolutePath(), Long.valueOf(war.lastModified())); if (deployXML && xml.exists() && copyXML) { deployedApp.redeployResources.put(xml.getAbsolutePath(), Long.valueOf(xml.lastModified())); } Class<?> clazz = Class.forName(host.getConfigClass()); LifecycleListener listener = (LifecycleListener) clazz.newInstance(); context.addLifecycleListener(listener); context.setName(cn.getName()); context.setPath(cn.getPath()); context.setWebappVersion(cn.getVersion()); context.setDocBase(cn.getBaseName() + ".war"); host.addChild(context); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("hostConfig.deployWar.error", war.getAbsolutePath()), t); } finally { if (unpackWARs && context != null && context.getDocBase() != null) { File docBase = new File(host.getAppBaseFile(), cn.getBaseName()); deployedApp.redeployResources.put(docBase.getAbsolutePath(), Long.valueOf(docBase.lastModified())); addWatchedResources(deployedApp, docBase.getAbsolutePath(), context); if (deployXML && !copyXML && (xmlInWar || xml.exists())) { deployedApp.redeployResources.put(xml.getAbsolutePath(), Long.valueOf(xml.lastModified())); } } else { addWatchedResources(deployedApp, null, context); } // Add the global redeploy resources (which are never deleted) at addGlobalRedeployResources(deployedApp); } deployed.put(cn.getName(), deployedApp); }
@Override public void open() throws Exception { synchronized (groups) { synchronized (users) { users.clear(); groups.clear(); roles.clear(); File file = new File(pathname); if (!file.isAbsolute()) { file = new File(System.getProperty(Globals.CATALINA_BASE_PROP), pathname); } if (!file.exists()) { return; } FileInputStream fis = new FileInputStream(file); Digester digester = new Digester(); try { digester.setFeature("http://apache.org/xml/features/allow-java-encodings", true); } catch (Exception e) { log.warn(sm.getString("memoryUserDatabase.xmlFeatureEncoding"), e); } digester.addFactoryCreate("tomcat-users/group", new MemoryGroupCreationFactory(this), true); digester.addFactoryCreate("tomcat-users/role", new MemoryRoleCreationFactory(this), true); digester.addFactoryCreate("tomcat-users/user", new MemoryUserCreationFactory(this), true); try { digester.parse(fis); fis.close(); } catch (Exception e) { try { fis.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } throw e; } } } }
private static String getClassNameBase(String urn) { StringBuilder base = new StringBuilder("org.apache.jsp.tag.meta."); if (urn != null) { base.append(makeJavaPackage(urn)); base.append('.'); } return base.toString(); }	public static String getTagHandlerClassName(String path, String urn, ErrorDispatcher err) throws JasperException { String className = null; int begin = 0; int index; index = path.lastIndexOf(".tag"); if (index == -1) { err.jspError("jsp.error.tagfile.badSuffix", path); } // It's tempting to remove the ".tag" suffix here, but we can't. // If we remove it, the fully-qualified class name of this tag // could conflict with the package name of other tags. // For instance, the tag file // /WEB-INF/tags/foo.tag // would have fully-qualified class name // org.apache.jsp.tag.web.foo // which would conflict with the package name of the tag file index = path.indexOf(WEB_INF_TAGS); if (index != -1) { className = "org.apache.jsp.tag.web."; begin = index + WEB_INF_TAGS.length(); } else { index = path.indexOf(META_INF_TAGS); if (index != -1) { className = getClassNameBase(urn); begin = index + META_INF_TAGS.length(); } else { err.jspError("jsp.error.tagfile.illegalPath", path); } } className += makeJavaPackage(path.substring(begin)); return className; }
public void load() { long t1 = System.nanoTime(); initDirs(); initNaming(); Digester digester = createStartDigester(); InputSource inputSource = null; InputStream inputStream = null; File file = null; try { file = configFile(); inputStream = new FileInputStream(file); inputSource = new InputSource("file://" + file.getAbsolutePath()); } catch (Exception e) { if (log.isDebugEnabled()) { log.debug(sm.getString("catalina.configFail", file), e); } } if (inputStream == null) { try { inputStream = getClass().getClassLoader().getResourceAsStream(getConfigFile()); inputSource = new InputSource(getClass().getClassLoader().getResource(getConfigFile()).toString()); } catch (Exception e) { if (log.isDebugEnabled()) { log.debug(sm.getString("catalina.configFail", getConfigFile()), e); } } } if (inputStream == null) { try { inputStream = getClass().getClassLoader().getResourceAsStream("server-embed.xml"); inputSource = new InputSource(getClass().getClassLoader().getResource("server-embed.xml").toString()); } catch (Exception e) { if (log.isDebugEnabled()) { log.debug(sm.getString("catalina.configFail", "server-embed.xml"), e); } } } if (inputStream == null || inputSource == null) { if (file == null) { log.warn(sm.getString("catalina.configFail", getConfigFile() + "] or [server-embed.xml]")); } else { log.warn(sm.getString("catalina.configFail", file.getAbsolutePath())); if (file.exists() && !file.canRead()) { log.warn("Permissions incorrect, read permission is not allowed on the file."); } } return; } try { inputSource.setByteStream(inputStream); digester.push(this); digester.parse(inputSource); inputStream.close(); } catch (SAXParseException spe) { log.warn("Catalina.start using " + getConfigFile() + ": " + spe.getMessage()); return; } catch (Exception e) { log.warn("Catalina.start using " + getConfigFile() + ": ", e); return; } getServer().setCatalina(this); getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile()); getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile()); initStreams(); try { getServer().init(); } catch (LifecycleException e) { if (Boolean.getBoolean("org.apache.catalina.startup.EXIT_ON_INIT_FAILURE")) { throw new java.lang.Error(e); } else { log.error("Catalina.start", e); } } long t2 = System.nanoTime(); if (log.isInfoEnabled()) { log.info("Initialization processed in " + ((t2 - t1) / 1000000) + " ms"); } }	public void stopServer(String[] arguments) { if (arguments != null) { arguments(arguments); } Server s = getServer(); if (s == null) { Digester digester = createStopDigester(); digester.setClassLoader(Thread.currentThread().getContextClassLoader()); File file = configFile(); try { InputSource is = new InputSource("file://" + file.getAbsolutePath()); FileInputStream fis = new FileInputStream(file); is.setByteStream(fis); digester.push(this); digester.parse(is); fis.close(); } catch (Exception e) { log.error("Catalina.stop: ", e); System.exit(1); } } else { try { s.stop(); } catch (LifecycleException e) { log.error("Catalina.stop: ", e); } return; } s = getServer(); try { if (s.getPort() > 0) { Socket socket = new Socket(s.getAddress(), s.getPort()); OutputStream stream = socket.getOutputStream(); String shutdown = s.getShutdown(); for (int i = 0; i < shutdown.length(); i++) { stream.write(shutdown.charAt(i)); } stream.flush(); stream.close(); socket.close(); } else { log.error(sm.getString("catalina.stopServer")); System.exit(1); } } catch (IOException e) { log.error("Catalina.stop: ", e); System.exit(1); } }


protected void generateClass(String[] smap) throws FileNotFoundException, JasperException, Exception { long t1 = 0; if (log.isDebugEnabled()) { t1 = System.currentTimeMillis(); } final String sourceFile = ctxt.getServletJavaFileName(); final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); String packageName = ctxt.getServletPackageName(); final String targetClassName = ((packageName.length() != 0) ? (packageName + ".") : "") + ctxt.getServletClassName(); final ClassLoader classLoader = ctxt.getJspLoader(); String[] fileNames = new String[] {sourceFile}; String[] classNames = new String[] {targetClassName}; final ArrayList<JavacErrorDetail> problemList = new ArrayList<JavacErrorDetail>(); class CompilationUnit implements ICompilationUnit { String className; String sourceFile; CompilationUnit(String sourceFile, String className) { this.className = className; this.sourceFile = sourceFile; } @Override public char[] getFileName() { return sourceFile.toCharArray(); } @Override public char[] getContents() { char[] result = null; FileInputStream is = null; Reader reader = null; try { is = new FileInputStream(sourceFile); reader = new BufferedReader(new InputStreamReader(is, ctxt.getOptions().getJavaEncoding())); char[] chars = new char[8192]; StringBuilder buf = new StringBuilder(); int count; while ((count = reader.read(chars, 0, chars.length)) > 0) { buf.append(chars, 0, count); } result = new char[buf.length()]; buf.getChars(0, result.length, result, 0); } catch (IOException e) { log.error("Compilation error", e); } finally { if (reader != null) { try { reader.close(); } catch (IOException ioe) {/*Ignore*/} } if (is != null) { try { is.close(); } catch (IOException exc) {/*Ignore*/} } } return result; } @Override public char[] getMainTypeName() { int dot = className.lastIndexOf('.'); if (dot > 0) { return className.substring(dot + 1).toCharArray(); } return className.toCharArray(); } @Override public char[][] getPackageName() { StringTokenizer izer = new StringTokenizer(className, "."); char[][] result = new char[izer.countTokens()-1][]; for (int i = 0; i < result.length; i++) { String tok = izer.nextToken(); result[i] = tok.toCharArray(); } return result; } } final INameEnvironment env = new INameEnvironment() { @Override public NameEnvironmentAnswer findType(char[][] compoundTypeName) { String result = ""; String sep = ""; for (int i = 0; i < compoundTypeName.length; i++) { result += sep; result += new String(compoundTypeName[i]); sep = "."; } return findType(result); } @Override public NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) { String result = ""; String sep = ""; for (int i = 0; i < packageName.length; i++) { result += sep; result += new String(packageName[i]); sep = "."; } result += sep; result += new String(typeName); return findType(result); } } } } }
public static String dumpBeans(MBeanServer mbeanServer, Set<ObjectName> names) { StringBuilder buf = new StringBuilder(); Iterator<ObjectName> it = names.iterator(); while (it.hasNext()) { ObjectName oname = it.next(); buf.append("Name: "); buf.append(oname.toString()); buf.append(CRLF); try { MBeanInfo minfo = mbeanServer.getMBeanInfo(oname); String code = minfo.getClassName(); if ("org.apache.commons.modeler.BaseModelMBean".equals(code)) { code = (String) mbeanServer.getAttribute(oname, "modelerType"); } buf.append("modelerType: "); buf.append(code); buf.append(CRLF); MBeanAttributeInfo[] attrs = minfo.getAttributes(); Object value = null; for (int i = 0; i < attrs.length; i++) { if (!attrs[i].isReadable()) continue; String attName = attrs[i].getName(); if ("modelerType".equals(attName)) continue; if (attName.indexOf("=") >= 0 || attName.indexOf(":") >= 0 || attName.indexOf(" ") >= 0) { continue; } try { value = mbeanServer.getAttribute(oname, attName); } catch (JMRuntimeException rme) { Throwable cause = rme.getCause(); if (cause instanceof UnsupportedOperationException) { log.debug("Error getting attribute " + oname + " " + attName, rme); } else { log.error("Error getting attribute " + oname + " " + attName, rme); } continue; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error("Error getting attribute " + oname + " " + attName, t); continue; } if (value == null) continue; String valueString; try { Class<?> c = value.getClass(); if (c.isArray()) { int len = Array.getLength(value); StringBuilder sb = new StringBuilder("Array[" + c.getComponentType().getName() + "] of length " + len); if (len > 0) { sb.append(CRLF); } for (int j = 0; j < len; j++) { sb.append("\t"); Object item = Array.get(value, j); if (item == null) { sb.append("NULL VALUE"); } else { try { sb.append(escape(item.toString())); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); sb.append("NON-STRINGABLE VALUE"); } } if (j < len - 1) { sb.append(CRLF); } } valueString = sb.toString(); } else { valueString = escape(value.toString()); } buf.append(attName); buf.append(": "); buf.append(valueString); buf.append(CRLF); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } buf.append(CRLF); } return buf.toString(); }
protected void webConfig() { Set<WebXml> defaults = new HashSet<WebXml>(); defaults.add(getDefaultWebXmlFragment()); WebXml webXml = createWebXml(); InputSource contextWebXml = getContextWebXmlSource(); parseWebXml(contextWebXml, webXml, false); if (webXml.getMajorVersion() >= 3) { // Ordering is important here // Step 1. Identify all the JARs packaged with the application // If the JARs have a web-fragment.xml it will be parsed at this Map<String, WebXml> fragments = processJarsForWebFragments(); // Only need to process fragments and annotations if metadata is Set<WebXml> orderedFragments = null; if (!webXml.isMetadataComplete()) { orderedFragments = WebXml.orderWebFragments(webXml, fragments); if (ok) { processServletContainerInitializers(orderedFragments); } if (ok) { NamingEnumeration<Binding> listBindings = null; try { try { listBindings = context.getResources().listBindings("/WEB-INF/classes"); } catch (NameNotFoundException ignore) { // Safe to ignore } while (listBindings != null && listBindings.hasMoreElements()) { Binding binding = listBindings.nextElement(); if (binding.getObject() instanceof FileDirContext) { File webInfCLassDir = new File(((FileDirContext) binding.getObject()).getDocBase()); processAnnotationsFile(webInfCLassDir, webXml); } } } catch (NamingException e) { log.error(sm.getString("contextConfig.webinfClassesUrl"), e); } } if (ok) { processAnnotations(orderedFragments); } javaClassCache.clear(); if (ok) { ok = webXml.merge(orderedFragments); } // Step 7. Apply global defaults // Have to merge defaults before JSP conversion since defaults webXml.merge(defaults); if (ok) { convertJsps(webXml); } if (ok) { webXml.configureContext(context); // Step 9a. Make the merged web.xml available to other // components, specifically Jasper, to save those components // from having to re-generate it. String mergedWebXml = webXml.toXml(); context.getServletContext().setAttribute(org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML, mergedWebXml); if (context.getLogEffectiveWebXml()) { log.info("web.xml:\n" + mergedWebXml); } } } else { webXml.merge(defaults); webXml.configureContext(context); } if (ok) { // Spec does not define an order. Set<WebXml> resourceJars = new LinkedHashSet<WebXml>(); if (orderedFragments != null) { for (WebXml fragment : orderedFragments) { resourceJars.add(fragment); } } for (WebXml fragment : fragments.values()) { if (!resourceJars.contains(fragment)) { resourceJars.add(fragment); } } processResourceJARs(resourceJars); // See also StandardContext.resourcesStart() for // WEB-INF/classes/META-INF/resources configuration } if (!webXml.isMetadataComplete()) { if (ok) { for (Map.Entry<ServletContainerInitializer, Set<Class<?>>> entry : initializerClassMap.entrySet()) { if (entry.getValue().isEmpty()) { context.addServletContainerInitializer(entry.getKey(), null); } else { context.addServletContainerInitializer(entry.getKey(), entry.getValue()); } } } } } else { webXml.merge(defaults); convertJsps(webXml); webXml.configureContext(context); } }
@SuppressWarnings("unchecked") public static final Enum<?> coerceToEnum(final Object obj, @SuppressWarnings("rawtypes") Class type) { if (obj == null || "".equals(obj)) { return null; } if (type.isAssignableFrom(obj.getClass())) { return (Enum<?>) obj; } if (!(obj instanceof String)) { throw new ELException(MessageFactory.get("error.convert", obj, obj.getClass(), type)); } Enum<?> result; try { result = Enum.valueOf(type, (String) obj); } catch (IllegalArgumentException iae) { throw new ELException(MessageFactory.get("error.convert", obj, obj.getClass(), type)); } return result; }
@Override protected void initInternal() throws LifecycleException { super.initInternal(); // Register global String cache // Note although the cache is global, if there are multiple Servers // present in the JVM (may happen when embedding) then the same cache onameStringCache = register(new StringCache(), "type=StringCache"); MBeanFactory factory = new MBeanFactory(); factory.setContainer(this); onameMBeanFactory = register(factory, "type=MBeanFactory"); globalNamingResources.init(); for (int i = 0; i < services.length; i++) { services[i].init(); } }
@Override public final void action(ActionCode actionCode, Object param) { if (actionCode == ActionCode.COMMIT) { if (response.isCommitted()) return; try { prepareResponse(); } catch (IOException e) { error = true; } try { flush(false); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.CLIENT_FLUSH) { if (!response.isCommitted()) { try { prepareResponse(); } catch (IOException e) { error = true; return; } } try { flush(true); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.DISABLE_SWALLOW_INPUT) { // TODO: Do not swallow request input but error = true; } else if (actionCode == ActionCode.CLOSE) { try { finish(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE) { if (!certificates.isNull()) { ByteChunk certData = certificates.getByteChunk(); X509Certificate[] jsseCerts = null; ByteArrayInputStream bais = new ByteArrayInputStream(certData.getBytes(), certData.getStart(), certData.getLength()); try { CertificateFactory cf; if (clientCertProvider == null) { cf = CertificateFactory.getInstance("X.509"); } else { cf = CertificateFactory.getInstance("X.509", clientCertProvider); } while (bais.available() > 0) { X509Certificate cert = (X509Certificate) cf.generateCertificate(bais); if (jsseCerts == null) { jsseCerts = new X509Certificate[1]; jsseCerts[0] = cert; } else { X509Certificate[] temp = new X509Certificate[jsseCerts.length + 1]; System.arraycopy(jsseCerts, 0, temp, 0, jsseCerts.length); temp[jsseCerts.length] = cert; jsseCerts = temp; } } } catch (java.security.cert.CertificateException e) { getLog().error(sm.getString("ajpprocessor.certs.fail"), e); return; } catch (NoSuchProviderException e) { getLog().error(sm.getString("ajpprocessor.certs.fail"), e); return; } request.setAttribute(SSLSupport.CERTIFICATE_KEY, jsseCerts); } } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) { if (request.remoteHost().isNull()) { try { request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName()); } catch (IOException iex) { // Ignore } } } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) { request.localAddr().setString(request.localName().toString()); } else if (actionCode == ActionCode.REQ_SET_BODY_REPLAY) { ByteChunk bc = (ByteChunk) param; int length = bc.getLength(); bodyBytes.setBytes(bc.getBytes(), bc.getStart(), length); request.setContentLength(length); first = false; empty = false; replay = true; } else if (actionCode == ActionCode.ASYNC_START) { asyncStateMachine.asyncStart((AsyncContextCallback) param); } else if (actionCode == ActionCode.ASYNC_DISPATCHED) { asyncStateMachine.asyncDispatched(); } else if (actionCode == ActionCode.ASYNC_TIMEOUT) { AtomicBoolean result = (AtomicBoolean) param; result.set(asyncStateMachine.asyncTimeout()); } else if (actionCode == ActionCode.ASYNC_RUN) { asyncStateMachine.asyncRun((Runnable) param); } else if (actionCode == ActionCode.ASYNC_ERROR) { asyncStateMachine.asyncError(); } else if (actionCode == ActionCode.ASYNC_IS_STARTED) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted()); } else if (actionCode == ActionCode.ASYNC_IS_DISPATCHING) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching()); } else if (actionCode == ActionCode.ASYNC_IS_ASYNC) { ((AtomicBoolean) param).set(asyncStateMachine.isAsync()); } else if (actionCode == ActionCode.ASYNC_IS_TIMINGOUT) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut()); } else if (actionCode == ActionCode.UPGRADE) { // HTTP connections only. Unsupported for AJP. // NOOP } else { actionInternal(actionCode, param); } }
public static String dumpBeans(MBeanServer mbeanServer, Set<ObjectName> names) { StringBuilder buf = new StringBuilder(); Iterator<ObjectName> it = names.iterator(); while (it.hasNext()) { ObjectName oname = it.next(); buf.append("Name: "); buf.append(oname.toString()); buf.append(CRLF); try { MBeanInfo minfo = mbeanServer.getMBeanInfo(oname); String code = minfo.getClassName(); if ("org.apache.commons.modeler.BaseModelMBean".equals(code)) { code = (String) mbeanServer.getAttribute(oname, "modelerType"); } buf.append("modelerType: "); buf.append(code); buf.append(CRLF); MBeanAttributeInfo[] attrs = minfo.getAttributes(); Object value = null; for (int i = 0; i < attrs.length; i++) { if (!attrs[i].isReadable()) continue; String attName = attrs[i].getName(); if ("modelerType".equals(attName)) continue; if (attName.indexOf("=") >= 0 || attName.indexOf(":") >= 0 || attName.indexOf(" ") >= 0) { continue; } try { value = mbeanServer.getAttribute(oname, attName); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error("Error getting attribute " + oname + " " + attName, t); continue; } if (value == null) continue; String valueString; try { Class<?> c = value.getClass(); if (c.isArray()) { int len = Array.getLength(value); StringBuilder sb = new StringBuilder("Array[" + c.getComponentType().getName() + "] of length " + len); if (len > 0) { sb.append(CRLF); } for (int j = 0; j < len; j++) { sb.append("\t"); Object item = Array.get(value, j); if (item == null) { sb.append("NULL VALUE"); } else { try { sb.append(escape(item.toString())); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); sb.append("NON-STRINGABLE VALUE"); } } if (j < len - 1) { sb.append(CRLF); } } valueString = sb.toString(); } else { valueString = escape(value.toString()); } buf.append(attName); buf.append(": "); buf.append(valueString); buf.append(CRLF); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } buf.append(CRLF); } return buf.toString(); }
private static ErrorPage findErrorPage(Context context, Throwable exception) { if (exception == null) { return (null); } Class<?> clazz = exception.getClass(); String name = clazz.getName(); while (!Object.class.equals(clazz)) { ErrorPage errorPage = context.findErrorPage(name); if (errorPage != null) { return (errorPage); } clazz = clazz.getSuperclass(); if (clazz == null) { break; } name = clazz.getName(); } return (null); }
@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType("text/plain"); resp.setCharacterEncoding("ISO-8859-1"); Writer w = resp.getWriter(); String useBufferStr = req.getParameter("useBuffer"); if (useBufferStr != null) { w = new BufferedWriter(w); } long start = System.nanoTime(); for (int i = 0; i < writeCount; i++) { w.write(writeString); } if (useBufferStr != null) { w.flush(); } long lastRunNano = System.nanoTime() - start; System.out.println("Write length: " + writeString.length() + ", Buffered: " + (useBufferStr == null ? "n" : "y") + ", Time: " + lastRunNano + "ns"); }	public void reset() { if (gotEnc && conv != null) { conv.recycle(); } bb.recycle(); bytesWritten = 0; charsWritten = 0; gotEnc = false; enc = null; initial = true; }	public void resetBuffer(boolean resetWriterStreamFlags) { if (isCommitted()) { throw new IllegalStateException(sm.getString("coyoteResponse.resetBuffer.ise")); } outputBuffer.reset(); if (resetWriterStreamFlags) { usingOutputStream = false; usingWriter = false; isCharacterEncodingSet = false; } }	public void testWriteSpeed() throws Exception { Tomcat tomcat = getTomcatInstance(); Context root = tomcat.addContext("", TEMP_DIR); for (int i = 1; i <= WritingServlet.EXPECTED_CONTENT_LENGTH; i *= 10) { WritingServlet servlet = new WritingServlet(i); Tomcat.addServlet(root, "servlet" + i, servlet); root.addServletMapping("/servlet" + i, "servlet" + i); } tomcat.start(); ByteChunk bc = new ByteChunk(); for (int i = 1; i <= WritingServlet.EXPECTED_CONTENT_LENGTH; i *= 10) { int rc = getUrl("http://localhost:" + getPort() + "/servlet" + i, bc, null, null); assertEquals(HttpServletResponse.SC_OK, rc); assertEquals(WritingServlet.EXPECTED_CONTENT_LENGTH, bc.getLength()); bc.recycle(); rc = getUrl("http://localhost:" + getPort() + "/servlet" + i + "?useBuffer=y", bc, null, null); assertEquals(HttpServletResponse.SC_OK, rc); assertEquals(WritingServlet.EXPECTED_CONTENT_LENGTH, bc.getLength()); bc.recycle(); } }
@Override public void setParent(Container container) { throw new IllegalArgumentException(sm.getString("standardEngine.notParent")); }
protected void checkHandlesTypes(JavaClass javaClass) { if (typeInitializerMap.size() == 0) { return; } if ((javaClass.getAccessFlags() & org.apache.tomcat.util.bcel.Constants.ACC_ANNOTATION) > 0) { return; } String className = javaClass.getClassName(); Class<?> clazz = null; try { clazz = context.getLoader().getClassLoader().loadClass(className); } catch (NoClassDefFoundError e) { log.debug(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (ClassNotFoundException e) { log.debug(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (ClassFormatError e) { log.debug(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("contextConfig.invalidSciHandlesTypes", className), t); return; } if (clazz.isAnnotation()) { return; } boolean match = false; for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry : typeInitializerMap.entrySet()) { if (entry.getKey().isAnnotation()) { AnnotationEntry[] annotationEntries = javaClass.getAnnotationEntries(); for (AnnotationEntry annotationEntry : annotationEntries) { if (entry.getKey().getName().equals(getClassName(annotationEntry.getAnnotationType()))) { match = true; break; } } } else if (entry.getKey().isAssignableFrom(clazz)) { match = true; } if (match) { for (ServletContainerInitializer sci : entry.getValue()) { initializerClassMap.get(sci).add(clazz); } match = false; } } }	protected void processServletContainerInitializers(Set<WebXml> fragments) { for (WebXml fragment : fragments) { URL url = fragment.getURL(); Jar jar = null; InputStream is = null; ServletContainerInitializer sci = null; try { if ("jar".equals(url.getProtocol())) { jar = JarFactory.newInstance(url); is = jar.getInputStream(SCI_LOCATION); } else if ("file".equals(url.getProtocol())) { String path = url.getPath(); File file = new File(path, SCI_LOCATION); if (file.exists()) { is = new FileInputStream(file); } } if (is != null) { sci = getServletContainerInitializer(is); } } catch (IOException ioe) { log.error(sm.getString("contextConfig.servletContainerInitializerFail", url, context.getName())); ok = false; return; } finally { if (is != null) { try { is.close(); } catch (IOException e) { // Ignore } } if (jar != null) { jar.close(); } } if (sci == null) { continue; } initializerClassMap.put(sci, new HashSet<Class<?>>()); HandlesTypes ht = sci.getClass().getAnnotation(HandlesTypes.class); if (ht != null) { Class<?>[] types = ht.value(); if (types != null) { for (Class<?> type : types) { Set<ServletContainerInitializer> scis = typeInitializerMap.get(type); if (scis == null) { scis = new HashSet<ServletContainerInitializer>(); typeInitializerMap.put(type, scis); } scis.add(sci); } } } } }	protected void webConfig() { Set<WebXml> defaults = new HashSet<WebXml>(); defaults.add(getDefaultWebXmlFragment()); WebXml webXml = createWebXml(); InputSource contextWebXml = getContextWebXmlSource(); parseWebXml(contextWebXml, webXml, false); if (webXml.getMajorVersion() >= 3) { // Ordering is important here // Step 1. Identify all the JARs packaged with the application // If the JARs have a web-fragment.xml it will be parsed at this Map<String, WebXml> fragments = processJarsForWebFragments(); // Only need to process fragments and annotations if metadata is Set<WebXml> orderedFragments = null; if (!webXml.isMetadataComplete()) { orderedFragments = WebXml.orderWebFragments(webXml, fragments); if (ok) { processServletContainerInitializers(orderedFragments); } if (ok) { NamingEnumeration<Binding> listBindings = null; try { try { listBindings = context.getResources().listBindings("/WEB-INF/classes"); } catch (NameNotFoundException ignore) { // Safe to ignore } while (listBindings != null && listBindings.hasMoreElements()) { Binding binding = listBindings.nextElement(); if (binding.getObject() instanceof FileDirContext) { File webInfCLassDir = new File(((FileDirContext) binding.getObject()).getDocBase()); processAnnotationsFile(webInfCLassDir, webXml); } } } catch (NamingException e) { log.error(sm.getString("contextConfig.webinfClassesUrl"), e); } } if (ok) { processAnnotations(orderedFragments); } if (ok) { ok = webXml.merge(orderedFragments); } // Step 7. Apply global defaults // Have to merge defaults before JSP conversion since defaults webXml.merge(defaults); if (ok) { convertJsps(webXml); } if (ok) { webXml.configureContext(context); // Step 9a. Make the merged web.xml available to other // components, specifically Jasper, to save those components // from having to re-generate it. String mergedWebXml = webXml.toXml(); context.getServletContext().setAttribute(org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML, mergedWebXml); if (context.getLogEffectiveWebXml()) { log.info("web.xml:\n" + mergedWebXml); } } } else { webXml.merge(defaults); webXml.configureContext(context); } if (ok) { // Spec does not define an order. Set<WebXml> resourceJars = new LinkedHashSet<WebXml>(); if (orderedFragments != null) { for (WebXml fragment : orderedFragments) { resourceJars.add(fragment); } } for (WebXml fragment : fragments.values()) { if (!resourceJars.contains(fragment)) { resourceJars.add(fragment); } } processResourceJARs(resourceJars); // See also StandardContext.resourcesStart() for // WEB-INF/classes/META-INF/resources configuration } if (!webXml.isMetadataComplete()) { if (ok) { for (Map.Entry<ServletContainerInitializer, Set<Class<?>>> entry : initializerClassMap.entrySet()) { if (entry.getValue().isEmpty()) { context.addServletContainerInitializer(entry.getKey(), null); } else { context.addServletContainerInitializer(entry.getKey(), entry.getValue()); } } } } } else { webXml.merge(defaults); convertJsps(webXml); webXml.configureContext(context); } }	public String getClassName() { return class_name; }	public long getHostTimeStamp() { return hostTimeStamp; }	@Test public void testCheckHandleTypes() throws Exception { ContextConfig config = new ContextConfig(); StandardContext context = new StandardContext(); context.setLoader(new TesterLoader()); config.context = context; SCI sciNone = new SCI(); config.initializerClassMap.put(sciNone, new HashSet<Class<?>>()); SCI sciServlet = new SCI(); config.initializerClassMap.put(sciServlet, new HashSet<Class<?>>()); config.typeInitializerMap.put(Servlet.class, new HashSet<ServletContainerInitializer>()); config.typeInitializerMap.get(Servlet.class).add(sciServlet); SCI sciObject = new SCI(); config.initializerClassMap.put(sciObject, new HashSet<Class<?>>()); config.typeInitializerMap.put(Object.class, new HashSet<ServletContainerInitializer>()); config.typeInitializerMap.get(Object.class).add(sciObject); WebXml ignore = new WebXml(); File file = paramClassResource("org/apache/catalina/startup/ParamServlet"); config.processAnnotationsFile(file, ignore); file = paramClassResource("org/apache/catalina/startup/ParamFilter"); config.processAnnotationsFile(file, ignore); file = paramClassResource("org/apache/catalina/startup/TesterServlet"); config.processAnnotationsFile(file, ignore); file = paramClassResource("org/apache/catalina/startup/TestListener"); config.processAnnotationsFile(file, ignore); assertEquals(0, config.initializerClassMap.get(sciNone).size()); assertEquals(2, config.initializerClassMap.get(sciServlet).size()); assertEquals(4, config.initializerClassMap.get(sciObject).size()); }
public void recycle() { for (int i = 0; i <= lastActiveFilter; i++) { activeFilters[i].recycle(); } response.recycle(); pos = 0; lastActiveFilter = -1; committed = false; finished = false; }
protected void write(ByteChunk bc) { int length = bc.getLength(); System.arraycopy(bc.getBytes(), bc.getStart(), buf, pos, length); pos = pos + length; }	protected void write(CharChunk cc) { int start = cc.getStart(); int end = cc.getEnd(); char[] cbuf = cc.getBuffer(); for (int i = start; i < end; i++) { char c = cbuf[i]; if (((c <= 31) && (c != 9)) || c == 127 || c > 255) { c = ' '; } buf[pos++] = (byte) c; } }	protected void write(String s) { if (s == null) return; int len = s.length(); for (int i = 0; i < len; i++) { char c = s.charAt(i); if (((c <= 31) && (c != 9)) || c == 127 || c > 255) { c = ' '; } buf[pos++] = (byte) c; } }	protected void write(int i) { write(String.valueOf(i)); }	public void write(byte[] b) { System.arraycopy(b, 0, buf, pos, b.length); pos = pos + b.length; }
protected void webConfig() { Set<WebXml> defaults = new HashSet<WebXml>(); defaults.add(getDefaultWebXmlFragment()); WebXml webXml = createWebXml(); InputSource contextWebXml = getContextWebXmlSource(); parseWebXml(contextWebXml, webXml, false); if (webXml.getMajorVersion() >= 3) { // Ordering is important here // Step 1. Identify all the JARs packaged with the application // If the JARs have a web-fragment.xml it will be parsed at this Map<String, WebXml> fragments = processJarsForWebFragments(); // Only need to process fragments and annotations if metadata is Set<WebXml> orderedFragments = null; if (!webXml.isMetadataComplete()) { orderedFragments = WebXml.orderWebFragments(webXml, fragments); if (ok) { processServletContainerInitializers(orderedFragments); } if (ok) { try { NamingEnumeration<Binding> listBindings = context.getResources().listBindings("/WEB-INF/classes"); while (listBindings.hasMoreElements()) { Binding binding = listBindings.nextElement(); if (binding.getObject() instanceof FileDirContext) { File webInfCLassDir = new File(((FileDirContext) binding.getObject()).getDocBase()); processAnnotationsFile(webInfCLassDir, webXml); } } } catch (NamingException e) { log.error(sm.getString("contextConfig.webinfClassesUrl"), e); } } if (ok) { processAnnotations(orderedFragments); } if (ok) { ok = webXml.merge(orderedFragments); } // Step 7. Apply global defaults // Have to merge defaults before JSP conversion since defaults webXml.merge(defaults); if (ok) { convertJsps(webXml); } if (ok) { webXml.configureContext(context); // Step 9a. Make the merged web.xml available to other // components, specifically Jasper, to save those components // from having to re-generate it. String mergedWebXml = webXml.toXml(); context.getServletContext().setAttribute(org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML, mergedWebXml); if (context.getLogEffectiveWebXml()) { log.info("web.xml:\n" + mergedWebXml); } } } else { webXml.merge(defaults); webXml.configureContext(context); } if (ok) { // Spec does not define an order. Set<WebXml> resourceJars = new LinkedHashSet<WebXml>(); if (orderedFragments != null) { for (WebXml fragment : orderedFragments) { resourceJars.add(fragment); } } for (WebXml fragment : fragments.values()) { if (!resourceJars.contains(fragment)) { resourceJars.add(fragment); } } processResourceJARs(resourceJars); // See also StandardContext.resourcesStart() for // WEB-INF/classes/META-INF/resources configuration } if (!webXml.isMetadataComplete()) { if (ok) { for (Map.Entry<ServletContainerInitializer, Set<Class<?>>> entry : initializerClassMap.entrySet()) { if (entry.getValue().isEmpty()) { context.addServletContainerInitializer(entry.getKey(), null); } else { context.addServletContainerInitializer(entry.getKey(), entry.getValue()); } } } } } else { webXml.merge(defaults); convertJsps(webXml); webXml.configureContext(context); } }
@Override public void body(String namespace, String name, String text) throws Exception { taglibUriRule.setDuplicateUri(false); }
protected Charset getDigestCharset() throws UnsupportedEncodingException { if (digestEncoding == null) { return Charset.defaultCharset(); } else { return B2CConverter.getCharset(getDigestEncoding()); } }	protected String generateNonce(Request request) { long currentTime = System.currentTimeMillis(); String ipTimeKey = request.getRemoteAddr() + ":" + currentTime + ":" + getKey(); byte[] buffer; synchronized (md5Helper) { buffer = md5Helper.digest(ipTimeKey.getBytes(Charset.defaultCharset())); } return currentTime + ":" + md5Encoder.encode(buffer); }	protected boolean compareCredentials(DirContext context, User info, String credentials) throws NamingException { if (info == null || credentials == null) return (false); String password = info.getPassword(); if (password == null) return (false); if (containerLog.isTraceEnabled()) containerLog.trace(" validating credentials"); boolean validated = false; if (hasMessageDigest()) { if (password.startsWith("{MD5}") || password.startsWith("{SHA}")) { synchronized (this) { password = password.substring(5); md.reset(); md.update(credentials.getBytes(Charset.defaultCharset())); String digestedPassword = Base64.encode(md.digest()); validated = password.equals(digestedPassword); } } else if (password.startsWith("{SSHA}")) { synchronized (this) { password = password.substring(6); md.reset(); md.update(credentials.getBytes(Charset.defaultCharset())); ByteChunk pwbc = new ByteChunk(password.length()); try { pwbc.append(password.getBytes(Charset.defaultCharset()), 0, password.length()); } catch (IOException e) { containerLog.error("Could not append password bytes to chunk: ", e); } CharChunk decoded = new CharChunk(); Base64.decode(pwbc, decoded); char[] pwarray = decoded.getBuffer(); final int saltpos = 20; byte[] hash = new byte[saltpos]; for (int i = 0; i < hash.length; i++) { hash[i] = (byte) pwarray[i]; } byte[] salt = new byte[pwarray.length - saltpos]; for (int i = 0; i < salt.length; i++) salt[i] = (byte) pwarray[i + saltpos]; md.update(salt); byte[] dp = md.digest(); validated = Arrays.equals(dp, hash); } // End synchronized(this) block } else { validated = (digest(credentials).equalsIgnoreCase(password)); } } else validated = (digest(credentials).equals(password)); return (validated); }	protected synchronized void open() { File dir = new File(directory); if (!dir.isAbsolute()) { dir = new File(System.getProperty(Globals.CATALINA_BASE_PROP), directory); } if (!dir.mkdirs() && !dir.isDirectory()) { log.error(sm.getString("accessLogValve.openDirFail", dir)); } File pathname; if (rotatable) { pathname = new File(dir.getAbsoluteFile(), prefix + dateStamp + suffix); } else { pathname = new File(dir.getAbsoluteFile(), prefix + suffix); } File parent = pathname.getParentFile(); if (!parent.mkdirs() && !parent.isDirectory()) { log.error(sm.getString("accessLogValve.openDirFail", parent)); } Charset charset = null; if (encoding != null) { try { charset = B2CConverter.getCharset(encoding); } catch (UnsupportedEncodingException ex) { log.error(sm.getString("accessLogValve.unsupportedEncoding", encoding), ex); } } if (charset == null) { charset = Charset.defaultCharset(); } try { writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(pathname, true), charset), 128000), false); currentLogFile = pathname; } catch (IOException e) { writer = null; currentLogFile = null; log.error(sm.getString("accessLogValve.openFail", pathname), e); } }	protected void cacheLoad(CacheEntry entry) { String name = entry.name; boolean exists = true; if (entry.attributes == null) { try { Attributes attributes = dirContext.getAttributes(entry.name); if (!(attributes instanceof ResourceAttributes)) { entry.attributes = new ResourceAttributes(attributes); } else { entry.attributes = (ResourceAttributes) attributes; } } catch (NamingException e) { exists = false; } } if ((exists) && (entry.resource == null) && (entry.context == null)) { try { Object object = dirContext.lookup(name); if (object instanceof InputStream) { entry.resource = new Resource((InputStream) object); } else if (object instanceof DirContext) { entry.context = (DirContext) object; } else if (object instanceof Resource) { entry.resource = (Resource) object; } else { entry.resource = new Resource(new ByteArrayInputStream(object.toString().getBytes(Charset.defaultCharset()))); } } catch (NamingException e) { exists = false; } } if ((exists) && (entry.resource != null) && (entry.resource.getContent() == null) && (entry.attributes.getContentLength() >= 0) && (entry.attributes.getContentLength() < (cacheObjectMaxSize * 1024))) { int length = (int) entry.attributes.getContentLength(); // The entry size is 1 + the resource size in KB, if it will be entry.size += (entry.attributes.getContentLength() / 1024); InputStream is = null; try { is = entry.resource.streamContent(); int pos = 0; byte[] b = new byte[length]; while (pos < length) { int n = is.read(b, pos, length - pos); if (n < 0) break; pos = pos + n; } entry.resource.setContent(b); } catch (IOException e) { // Ignore } finally { try { if (is != null) is.close(); } catch (IOException e) { // Ignore } } } entry.exists = exists; entry.timestamp = System.currentTimeMillis() + cacheTTL; synchronized (cache) { if ((cache.lookup(name) == null) && cache.allocate(entry.size)) { cache.load(entry); } } }	protected void doLock(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { if (readOnly) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return; } if (isLocked(req)) { resp.sendError(WebdavStatus.SC_LOCKED); return; } LockInfo lock = new LockInfo(); // Parsing lock request String depthStr = req.getHeader("Depth"); if (depthStr == null) { lock.depth = maxDepth; } else { if (depthStr.equals("0")) { lock.depth = 0; } else { lock.depth = maxDepth; } } int lockDuration = DEFAULT_TIMEOUT; String lockDurationStr = req.getHeader("Timeout"); if (lockDurationStr == null) { lockDuration = DEFAULT_TIMEOUT; } else { int commaPos = lockDurationStr.indexOf(","); if (commaPos != -1) { lockDurationStr = lockDurationStr.substring(0, commaPos); } if (lockDurationStr.startsWith("Second-")) { lockDuration = (new Integer(lockDurationStr.substring(7))).intValue(); } else { if (lockDurationStr.equalsIgnoreCase("infinity")) { lockDuration = MAX_TIMEOUT; } else { try { lockDuration = (new Integer(lockDurationStr)).intValue(); } catch (NumberFormatException e) { lockDuration = MAX_TIMEOUT; } } } if (lockDuration == 0) { lockDuration = DEFAULT_TIMEOUT; } if (lockDuration > MAX_TIMEOUT) { lockDuration = MAX_TIMEOUT; } } lock.expiresAt = System.currentTimeMillis() + (lockDuration * 1000); int lockRequestType = LOCK_CREATION; Node lockInfoNode = null; DocumentBuilder documentBuilder = getDocumentBuilder(); try { Document document = documentBuilder.parse(new InputSource(req.getInputStream())); Element rootElement = document.getDocumentElement(); lockInfoNode = rootElement; } catch (IOException e) { lockRequestType = LOCK_REFRESH; } catch (SAXException e) { lockRequestType = LOCK_REFRESH; } if (lockInfoNode != null) { NodeList childList = lockInfoNode.getChildNodes(); StringWriter strWriter = null; DOMWriter domWriter = null; Node lockScopeNode = null; Node lockTypeNode = null; Node lockOwnerNode = null; for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: String nodeName = currentNode.getNodeName(); if (nodeName.endsWith("lockscope")) { lockScopeNode = currentNode; } if (nodeName.endsWith("locktype")) { lockTypeNode = currentNode; } if (nodeName.endsWith("owner")) { lockOwnerNode = currentNode; } break; } } if (lockScopeNode != null) { childList = lockScopeNode.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: String tempScope = currentNode.getNodeName(); if (tempScope.indexOf(':') != -1) { lock.scope = tempScope.substring(tempScope.indexOf(':') + 1); } else { lock.scope = tempScope; } break; } } if (lock.scope == null) { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } } else { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } if (lockTypeNode != null) { childList = lockTypeNode.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: String tempType = currentNode.getNodeName(); if (tempType.indexOf(':') != -1) { lock.type = tempType.substring(tempType.indexOf(':') + 1); } else { lock.type = tempType; } break; } } if (lock.type == null) { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } } else { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } if (lockOwnerNode != null) { childList = lockOwnerNode.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: lock.owner += currentNode.getNodeValue(); break; case Node.ELEMENT_NODE: strWriter = new StringWriter(); domWriter = new DOMWriter(strWriter, true); domWriter.setQualifiedNames(false); domWriter.print(currentNode); lock.owner += strWriter.toString(); break; } } if (lock.owner == null) { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } } else { lock.owner = ""; } } String path = getRelativePath(req); lock.path = path; boolean exists = true; Object object = null; try { object = resources.lookup(path); } catch (NamingException e) { exists = false; } Enumeration<LockInfo> locksList = null; if (lockRequestType == LOCK_CREATION) { String lockTokenStr = req.getServletPath() + "-" + lock.type + "-" + lock.scope + "-" + req.getUserPrincipal() + "-" + lock.depth + "-" + lock.owner + "-" + lock.tokens + "-" + lock.expiresAt + "-" + System.currentTimeMillis() + "-" + secret; String lockToken = md5Encoder.encode(md5Helper.digest(lockTokenStr.getBytes(Charset.defaultCharset()))); if ((exists) && (object instanceof DirContext) && (lock.depth == maxDepth)) { // Locking a collection (and all its member resources) // Checking if a child resource of this collection is Vector<String> lockPaths = new Vector<String>(); locksList = collectionLocks.elements(); while (locksList.hasMoreElements()) { LockInfo currentLock = locksList.nextElement(); if (currentLock.hasExpired()) { resourceLocks.remove(currentLock.path); continue; } if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) { lockPaths.addElement(currentLock.path); } } locksList = resourceLocks.elements(); while (locksList.hasMoreElements()) { LockInfo currentLock = locksList.nextElement(); if (currentLock.hasExpired()) { resourceLocks.remove(currentLock.path); continue; } if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) { lockPaths.addElement(currentLock.path); } } if (!lockPaths.isEmpty()) { // One of the child paths was locked Enumeration<String> lockPathsList = lockPaths.elements(); resp.setStatus(WebdavStatus.SC_CONFLICT); XMLWriter generatedXML = new XMLWriter(); generatedXML.writeXMLHeader(); generatedXML.writeElement("D", DEFAULT_NAMESPACE, "multistatus", XMLWriter.OPENING); while (lockPathsList.hasMoreElements()) { generatedXML.writeElement("D", "response", XMLWriter.OPENING); generatedXML.writeElement("D", "href", XMLWriter.OPENING); generatedXML.writeText(lockPathsList.nextElement()); generatedXML.writeElement("D", "href", XMLWriter.CLOSING); generatedXML.writeElement("D", "status", XMLWriter.OPENING); generatedXML.writeText("HTTP/1.1 " + WebdavStatus.SC_LOCKED + " " + WebdavStatus.getStatusText(WebdavStatus.SC_LOCKED)); generatedXML.writeElement("D", "status", XMLWriter.CLOSING); generatedXML.writeElement("D", "response", XMLWriter.CLOSING); } generatedXML.writeElement("D", "multistatus", XMLWriter.CLOSING); Writer writer = resp.getWriter(); writer.write(generatedXML.toString()); writer.close(); return; } boolean addLock = true; locksList = collectionLocks.elements(); while (locksList.hasMoreElements()) { LockInfo currentLock = locksList.nextElement(); if (currentLock.path.equals(lock.path)) { if (currentLock.isExclusive()) { resp.sendError(WebdavStatus.SC_LOCKED); return; } else { if (lock.isExclusive()) { resp.sendError(WebdavStatus.SC_LOCKED); return; } } currentLock.tokens.addElement(lockToken); lock = currentLock; addLock = false; } } if (addLock) { lock.tokens.addElement(lockToken); collectionLocks.addElement(lock); } } else { // Locking a single resource LockInfo presentLock = resourceLocks.get(lock.path); if (presentLock != null) { if ((presentLock.isExclusive()) || (lock.isExclusive())) { // If either lock is exclusive, the lock can't be resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED); return; } else { presentLock.tokens.addElement(lockToken); lock = presentLock; } } else { lock.tokens.addElement(lockToken); resourceLocks.put(lock.path, lock); exists = true; try { object = resources.lookup(path); } catch (NamingException e) { exists = false; } if (!exists) { int slash = lock.path.lastIndexOf('/'); String parentPath = lock.path.substring(0, slash); Vector<String> lockNulls = lockNullResources.get(parentPath); if (lockNulls == null) { lockNulls = new Vector<String>(); lockNullResources.put(parentPath, lockNulls); } lockNulls.addElement(lock.path); } // Add the Lock-Token header as by RFC 2518 8.10.1 resp.addHeader("Lock-Token", "<opaquelocktoken:" + lockToken + ">"); } } } if (lockRequestType == LOCK_REFRESH) { String ifHeader = req.getHeader("If"); if (ifHeader == null) ifHeader = ""; LockInfo toRenew = resourceLocks.get(path); Enumeration<String> tokenList = null; if (toRenew != null) { tokenList = toRenew.tokens.elements(); while (tokenList.hasMoreElements()) { String token = tokenList.nextElement(); if (ifHeader.indexOf(token) != -1) { toRenew.expiresAt = lock.expiresAt; lock = toRenew; } } } Enumeration<LockInfo> collectionLocksList = collectionLocks.elements(); while (collectionLocksList.hasMoreElements()) { toRenew = collectionLocksList.nextElement(); if (path.equals(toRenew.path)) { tokenList = toRenew.tokens.elements(); while (tokenList.hasMoreElements()) { String token = tokenList.nextElement(); if (ifHeader.indexOf(token) != -1) { toRenew.expiresAt = lock.expiresAt; lock = toRenew; } } } } } // Set the status, then generate the XML response containing XMLWriter generatedXML = new XMLWriter(); generatedXML.writeXMLHeader(); generatedXML.writeElement("D", DEFAULT_NAMESPACE, "prop", XMLWriter.OPENING); generatedXML.writeElement("D", "lockdiscovery", XMLWriter.OPENING); lock.toXML(generatedXML); generatedXML.writeElement("D", "lockdiscovery", XMLWriter.CLOSING); generatedXML.writeElement("D", "prop", XMLWriter.CLOSING); resp.setStatus(WebdavStatus.SC_OK); resp.setContentType("text/xml; charset=UTF-8"); Writer writer = resp.getWriter(); writer.write(generatedXML.toString()); writer.close(); }	public CacheEntry lookupCache(String name) { CacheEntry entry = cacheLookup(name); if (entry == null) { entry = new CacheEntry(); entry.name = name; try { Object object = dirContext.lookup(parseName(name)); if (object instanceof InputStream) { entry.resource = new Resource((InputStream) object); } else if (object instanceof DirContext) { entry.context = (DirContext) object; } else if (object instanceof Resource) { entry.resource = (Resource) object; } else { entry.resource = new Resource(new ByteArrayInputStream(object.toString().getBytes(Charset.defaultCharset()))); } Attributes attributes = dirContext.getAttributes(parseName(name)); if (!(attributes instanceof ResourceAttributes)) { attributes = new ResourceAttributes(attributes); } entry.attributes = (ResourceAttributes) attributes; } catch (NamingException e) { entry.exists = false; } } return entry; }	@Override public Object lookup(String name) throws NamingException { CacheEntry entry = cacheLookup(name); if (entry != null) { if (!entry.exists) { throw NOT_FOUND_EXCEPTION; } if (entry.resource != null) { return entry.resource; } else { return entry.context; } } Object object = dirContext.lookup(parseName(name)); if (object instanceof InputStream) { return new Resource((InputStream) object); } else if (object instanceof DirContext) { return object; } else if (object instanceof Resource) { return object; } else { return new Resource(new ByteArrayInputStream(object.toString().getBytes(Charset.defaultCharset()))); } }	public Principal authenticate(Realm realm) { // Second MD5 digest used to calculate the digest : String a2 = method + ":" + uri; byte[] buffer; synchronized (md5Helper) { buffer = md5Helper.digest(a2.getBytes(Charset.defaultCharset())); } String md5a2 = md5Encoder.encode(buffer); return realm.authenticate(userName, response, nonce, nc, cnonce, qop, realmName, md5a2); }	public boolean validate(Request request, String authorization, LoginConfig config) { if (authorization == null) { return false; } if (!authorization.startsWith("Digest ")) { return false; } authorization = authorization.substring(7).trim(); String[] tokens = authorization.split(",(?=(?:[^\"]*\"[^\"]*\")+$)"); method = request.getMethod(); String opaque = null; for (int i = 0; i < tokens.length; i++) { String currentToken = tokens[i]; if (currentToken.length() == 0) { continue; } int equalSign = currentToken.indexOf('='); if (equalSign < 0) { return false; } String currentTokenName = currentToken.substring(0, equalSign).trim(); String currentTokenValue = currentToken.substring(equalSign + 1).trim(); if ("username".equals(currentTokenName)) { userName = removeQuotes(currentTokenValue); } if ("realm".equals(currentTokenName)) { realmName = removeQuotes(currentTokenValue, true); } if ("nonce".equals(currentTokenName)) { nonce = removeQuotes(currentTokenValue); } if ("nc".equals(currentTokenName)) { nc = removeQuotes(currentTokenValue); } if ("cnonce".equals(currentTokenName)) { cnonce = removeQuotes(currentTokenValue); } if ("qop".equals(currentTokenName)) { qop = removeQuotes(currentTokenValue); } if ("uri".equals(currentTokenName)) { uri = removeQuotes(currentTokenValue); } if ("response".equals(currentTokenName)) { response = removeQuotes(currentTokenValue); } if ("opaque".equals(currentTokenName)) { opaque = removeQuotes(currentTokenValue); } } if ((userName == null) || (realmName == null) || (nonce == null) || (uri == null) || (response == null)) { return false; } if (validateUri) { String uriQuery; String query = request.getQueryString(); if (query == null) { uriQuery = request.getRequestURI(); } else { uriQuery = request.getRequestURI() + "?" + query; } if (!uri.equals(uriQuery)) { return false; } } String lcRealm = config.getRealmName(); if (lcRealm == null) { lcRealm = REALM_NAME; } if (!lcRealm.equals(realmName)) { return false; } if (!this.opaque.equals(opaque)) { return false; } int i = nonce.indexOf(":"); if (i < 0 || (i + 1) == nonce.length()) { return false; } long nonceTime; try { nonceTime = Long.parseLong(nonce.substring(0, i)); } catch (NumberFormatException nfe) { return false; } String md5clientIpTimeKey = nonce.substring(i + 1); long currentTime = System.currentTimeMillis(); if ((currentTime - nonceTime) > nonceValidity) { nonceStale = true; return false; } String serverIpTimeKey = request.getRemoteAddr() + ":" + nonceTime + ":" + key; byte[] buffer = null; synchronized (md5Helper) { buffer = md5Helper.digest(serverIpTimeKey.getBytes(Charset.defaultCharset())); } String md5ServerIpTimeKey = md5Encoder.encode(buffer); if (!md5ServerIpTimeKey.equals(md5clientIpTimeKey)) { return false; } if (qop != null && !QOP.equals(qop)) { return false; } if (qop == null) { if (cnonce != null || nc != null) { return false; } } else { if (cnonce == null || nc == null) { return false; } if (nc.length() != 8) { return false; } long count; try { count = Long.parseLong(nc, 16); } catch (NumberFormatException nfe) { return false; } NonceInfo info; synchronized (cnonces) { info = cnonces.get(cnonce); } if (info == null) { info = new NonceInfo(); } else { if (count <= info.getCount()) { return false; } } info.setCount(count); info.setTimestamp(currentTime); synchronized (cnonces) { cnonces.put(cnonce, info); } } return true; }	public static String URLDecode(String str, String enc, boolean isQuery) { if (str == null) return (null); // use the specified encoding to extract bytes out of the // given string so that the encoding is not lost. If an byte[] bytes = null; try { if (enc == null) { bytes = str.getBytes(Charset.defaultCharset()); } else { bytes = str.getBytes(B2CConverter.getCharset(enc)); } } catch (UnsupportedEncodingException uee) { if (log.isDebugEnabled()) { log.debug(sm.getString("requestUtil.urlDecode.uee", enc), uee); } } return URLDecode(bytes, enc, isQuery); }	public static void installSmap(String[] smap) throws IOException { if (smap == null) { return; } for (int i = 0; i < smap.length; i += 2) { File outServlet = new File(smap[i]); SDEInstaller.install(outServlet, smap[i + 1].getBytes(Charset.defaultCharset())); } }	public void execute(String command, InputStream istream, String contentType, int contentLength) throws BuildException { URLConnection conn = null; InputStreamReader reader = null; try { conn = (new URL(url + command)).openConnection(); HttpURLConnection hconn = (HttpURLConnection) conn; hconn.setAllowUserInteraction(false); hconn.setDoInput(true); hconn.setUseCaches(false); if (istream != null) { hconn.setDoOutput(true); hconn.setRequestMethod("PUT"); if (contentType != null) { hconn.setRequestProperty("Content-Type", contentType); } if (contentLength >= 0) { hconn.setRequestProperty("Content-Length", "" + contentLength); hconn.setFixedLengthStreamingMode(contentLength); } } else { hconn.setDoOutput(false); hconn.setRequestMethod("GET"); } hconn.setRequestProperty("User-Agent", "Catalina-Ant-Task/1.0"); String input = username + ":" + password; String output = Base64.encode(input.getBytes(Charset.defaultCharset())); hconn.setRequestProperty("Authorization", "Basic " + output); hconn.connect(); if (istream != null) { BufferedOutputStream ostream = new BufferedOutputStream(hconn.getOutputStream(), 1024); byte[] buffer = new byte[1024]; while (true) { int n = istream.read(buffer); if (n < 0) { break; } ostream.write(buffer, 0, n); } ostream.flush(); ostream.close(); istream.close(); } reader = new InputStreamReader(hconn.getInputStream(), CHARSET); StringBuilder buff = new StringBuilder(); String error = null; int msgPriority = Project.MSG_INFO; boolean first = true; while (true) { int ch = reader.read(); if (ch < 0) { break; } else if ((ch == '\r') || (ch == '\n')) { if (buff.length() > 0) { String line = buff.toString(); buff.setLength(0); if (first) { if (!line.startsWith("OK -")) { error = line; msgPriority = Project.MSG_ERR; } first = false; } handleOutput(line, msgPriority); } } else { buff.append((char) ch); } } if (buff.length() > 0) { handleOutput(buff.toString(), msgPriority); } if (error != null && isFailOnError()) { throw new BuildException(error); } } catch (Exception e) { if (isFailOnError()) { throw new BuildException(e); } else { handleErrorOutput(e.getMessage()); } } finally { closeRedirector(); if (reader != null) { try { reader.close(); } catch (IOException ioe) { // Ignore } reader = null; } if (istream != null) { try { istream.close(); } catch (IOException ioe) { // Ignore } } } }	@Override public void invoke(Request request, Response response) throws IOException, ServletException { String strcert0 = mygetHeader(request, "ssl_client_cert"); if (strcert0 != null && strcert0.length() > 28) { String strcert1 = strcert0.replace(' ', '\n'); String strcert2 = strcert1.substring(28, strcert1.length() - 26); String strcert3 = "-----BEGIN CERTIFICATE-----\n"; String strcert4 = strcert3.concat(strcert2); String strcerts = strcert4.concat("\n-----END CERTIFICATE-----\n"); ByteArrayInputStream bais = new ByteArrayInputStream(strcerts.getBytes(Charset.defaultCharset())); X509Certificate[] jsseCerts = null; String providerName = (String) request.getConnector().getProperty("clientCertProvider"); try { CertificateFactory cf; if (providerName == null) { cf = CertificateFactory.getInstance("X.509"); } else { cf = CertificateFactory.getInstance("X.509", providerName); } X509Certificate cert = (X509Certificate) cf.generateCertificate(bais); jsseCerts = new X509Certificate[1]; jsseCerts[0] = cert; } catch (java.security.cert.CertificateException e) { log.warn(sm.getString("sslValve.certError", strcerts), e); } catch (NoSuchProviderException e) { log.error(sm.getString("sslValve.invalidProvider", providerName), e); } request.setAttribute(Globals.CERTIFICATES_ATTR, jsseCerts); } strcert0 = mygetHeader(request, "ssl_cipher"); if (strcert0 != null) { request.setAttribute(Globals.CIPHER_SUITE_ATTR, strcert0); } strcert0 = mygetHeader(request, "ssl_session_id"); if (strcert0 != null) { request.setAttribute(Globals.SSL_SESSION_ID_ATTR, strcert0); } strcert0 = mygetHeader(request, "ssl_cipher_usekeysize"); if (strcert0 != null) { request.setAttribute(Globals.KEY_SIZE_ATTR, Integer.valueOf(strcert0)); } getNext().invoke(request, response); }	public void toBytes() { if (!byteC.isNull()) { type = T_BYTES; return; } toString(); type = T_BYTES; byte[] bb = strValue.getBytes(Charset.defaultCharset()); byteC.setBytes(bb, 0, bb.length); }
private void setClassPath() { if (!(container instanceof Context)) return; ServletContext servletContext = ((Context) container).getServletContext(); if (servletContext == null) return; StringBuilder classpath = new StringBuilder(); ClassLoader loader = getClassLoader(); int n = 0; while (loader != null) { if (!(loader instanceof URLClassLoader)) { String cp = getClasspath(loader); if (cp == null) { log.info("Unknown loader " + loader + " " + loader.getClass()); } else { if (n > 0) classpath.append(File.pathSeparator); classpath.append(cp); n++; } break; //continue; } URL[] repositories = ((URLClassLoader) loader).getURLs(); for (int i = 0; i < repositories.length; i++) { String repository = repositories[i].toString(); if (repository.startsWith("file://")) repository = repository.substring(7); } } }
public boolean isSupported(String type) { return true; }	@Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { response.setContentType("text/plain"); PrintWriter writer = response.getWriter(); if (mBeanServer == null) { writer.println("Error - No mbean server"); return; } String qry = request.getParameter("set"); if (qry != null) { String name = request.getParameter("att"); String val = request.getParameter("val"); setAttribute(writer, qry, name, val); return; } qry = request.getParameter("get"); if (qry != null) { String name = request.getParameter("att"); getAttribute(writer, qry, name); return; } qry = request.getParameter("qry"); if (qry == null) { qry = "*:*"; } listBeans(writer, qry); }	public void getAttribute(PrintWriter writer, String onameStr, String att) { try { ObjectName oname = new ObjectName(onameStr); Object value = mBeanServer.getAttribute(oname, att); writer.println("OK - Attribute get '" + onameStr + "' - " + att + "= " + MBeanDumper.escape(value.toString())); } catch (Exception ex) { writer.println("Error - " + ex.toString()); } }	public void listBeans(PrintWriter writer, String qry) { Set<ObjectName> names = null; try { names = mBeanServer.queryNames(new ObjectName(qry), null); writer.println("OK - Number of results: " + names.size()); writer.println(); } catch (Exception e) { writer.println("Error - " + e.toString()); return; } String dump = MBeanDumper.dumpBeans(mBeanServer, names); writer.print(dump); }	public void setAttribute(PrintWriter writer, String onameStr, String att, String val) { try { ObjectName oname = new ObjectName(onameStr); String type = registry.getType(oname, att); Object valueObj = registry.convertValue(type, val); mBeanServer.setAttribute(oname, new Attribute(att, valueObj)); writer.println("OK - Attribute set"); } catch (Exception ex) { writer.println("Error - " + ex.toString()); } }
private WebXml getDefaultWebXmlFragment() { Host host = (Host) context.getParent(); DefaultWebXmlCacheEntry entry = hostWebXmlCache.get(host); InputSource globalWebXml = getGlobalWebXmlSource(); InputSource hostWebXml = getHostWebXmlSource(); long globalTimeStamp = 0; long hostTimeStamp = 0; if (globalWebXml != null) { try { File f = new File(new URI(globalWebXml.getSystemId())); globalTimeStamp = f.lastModified(); } catch (URISyntaxException e) { globalTimeStamp = -1; } } if (hostWebXml != null) { try { File f = new File(new URI(hostWebXml.getSystemId())); hostTimeStamp = f.lastModified(); } catch (URISyntaxException e) { hostTimeStamp = -1; } } if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp && entry.getHostTimeStamp() == hostTimeStamp) { return entry.getWebXml(); } synchronized (host.getPipeline()) { entry = hostWebXmlCache.get(host); if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp && entry.getHostTimeStamp() == hostTimeStamp) { return entry.getWebXml(); } WebXml webXmlDefaultFragment = createWebXml(); webXmlDefaultFragment.setOverridable(true); // Set to distributable else every app will be prevented from being // distributable when the default fragment is merged with the main webXmlDefaultFragment.setDistributable(true); // When merging, the default welcome files are only used if the app has webXmlDefaultFragment.setAlwaysAddWelcomeFiles(false); if (globalWebXml == null) { log.info(sm.getString("contextConfig.defaultMissing")); } else { parseWebXml(globalWebXml, webXmlDefaultFragment, false); } // Parse host level web.xml if present webXmlDefaultFragment.setReplaceWelcomeFiles(true); parseWebXml(hostWebXml, webXmlDefaultFragment, false); if (globalTimeStamp != -1 && hostTimeStamp != -1) { entry = new DefaultWebXmlCacheEntry(webXmlDefaultFragment, globalTimeStamp, hostTimeStamp); hostWebXmlCache.put(host, entry); } return webXmlDefaultFragment; } }
private Class<?>[] getTypesFromValues(Object[] values) { if (values == null) { return null; } Class<?>[] result = new Class<?>[values.length]; for (int i = 0; i < values.length; i++) { if (values[i] == null) { result[i] = null; } else { result[i] = values[i].getClass(); } } return result; }	@Override public boolean isParametersProvided() { if (this.children.length > 2 && this.jjtGetChild(2) instanceof AstMethodParameters) { return true; } return false; }	@Test public void testBug50790b() throws Exception { ValueExpression ve = factory.createValueExpression(context, "#{beanA.name.contains(beanAA.name)}", java.lang.Boolean.class); Boolean actual = (Boolean) ve.getValue(context); assertEquals(Boolean.FALSE, actual); }
public Context addWebapp(Host host, String url, String name, String path) { silence(host, url); Context ctx = new StandardContext(); ctx.setName(name); ctx.setPath(url); ctx.setDocBase(path); if (defaultRealm == null) { initSimpleAuth(); } ctx.setRealm(defaultRealm); ctx.addLifecycleListener(new DefaultWebXmlListener()); ContextConfig ctxCfg = new ContextConfig(); ctx.addLifecycleListener(ctxCfg); ctxCfg.setDefaultWebXml(noDefaultWebXmlPath()); if (host == null) { getHost().addChild(ctx); } else { host.addChild(ctx); } return ctx; }	public Engine getEngine() { if (engine == null) { getServer(); engine = new StandardEngine(); engine.setName("Tomcat"); engine.setDefaultHost(hostname); service.setContainer(engine); } return engine; }	public Host getHost() { if (host == null) { host = new StandardHost(); host.setName(hostname); getEngine().addChild(host); } return host; }	public Realm getDefaultRealm() { if (defaultRealm == null) { initSimpleAuth(); } return defaultRealm; }	public String noDefaultWebXmlPath() { return Constants.NoDefaultWebXml; }
protected boolean validate(String name) { if (name == null) { return false; } if (name.startsWith("java.")) { return false; } if (name.startsWith("javax.servlet.jsp.jstl")) { return true; } if (name.startsWith("javax.servlet.")) { return false; } return true; }	@Override public ClassLoader run() { return clazz.getClassLoader(); }
@Override public void setImage(String image) { if (!Validation.isIdentifier(image)) { throw new ELException(MessageFactory.get("error.identifier.notjava", image)); } this.image = image; }	public void testGetValueReference() { ExpressionFactory factory = ExpressionFactory.newInstance(); ELContext context = new ELContextImpl(); TesterBeanB beanB = new TesterBeanB(); beanB.setName("Tomcat"); ValueExpression var = factory.createValueExpression(beanB, TesterBeanB.class); context.getVariableMapper().setVariable("beanB", var); ValueExpression ve = factory.createValueExpression(context, "${beanB.name}", String.class); String result = (String) ve.getValue(context); assertEquals("Tomcat", result); ValueReference vr = ve.getValueReference(context); assertNotNull(vr); assertEquals(beanB, vr.getBase()); assertEquals("name", vr.getProperty()); }
protected void doFlush(boolean realFlush) throws IOException { if (suspended) { return; } try { doFlush = true; if (initial) { coyoteResponse.sendHeaders(); initial = false; } if (bb.getLength() > 0) { bb.flushBuffer(); } } finally { doFlush = false; } if (realFlush) { coyoteResponse.action(ActionCode.CLIENT_FLUSH, coyoteResponse); if (coyoteResponse.isExceptionPresent()) { throw new ClientAbortException(coyoteResponse.getErrorException()); } } }	public void reset() { bb.recycle(); bytesWritten = 0; charsWritten = 0; gotEnc = false; enc = null; initial = true; }	@Override public void write(String s) throws IOException { if (suspended) { return; } if (s == null) { s = "null"; } conv.convert(s); conv.flushBuffer(); }	@Override public void write(String s, int off, int len) throws IOException { if (suspended) { return; } charsWritten += len; if (s == null) { s = "null"; } conv.convert(s, off, len); conv.flushBuffer(); }	@Override public void write(char[] c, int off, int len) throws IOException { if (suspended) { return; } conv.convert(c, off, len); conv.flushBuffer(); charsWritten += len; }	@Override public void write(int c) throws IOException { if (suspended) { return; } conv.convert((char) c); conv.flushBuffer(); charsWritten++; }
private void silence(String ctx) { String base = "org.apache.catalina.core.ContainerBase.[default].["; base += getHost().getName(); base += "].["; base += ctx; base += "]"; Logger.getLogger(base).setLevel(Level.WARNING); }	public Context addContext(Host host, String contextPath, String contextName, String dir) { silence(contextPath); Context ctx = new StandardContext(); ctx.setName(contextName); ctx.setPath(contextPath); ctx.setDocBase(dir); ctx.addLifecycleListener(new FixContextListener()); if (host == null) { getHost().addChild(ctx); } else { host.addChild(ctx); } return ctx; }	public Context addWebapp(Host host, String url, String name, String path) { silence(url); Context ctx = new StandardContext(); ctx.setName(name); ctx.setPath(url); ctx.setDocBase(path); if (defaultRealm == null) { initSimpleAuth(); } ctx.setRealm(defaultRealm); ctx.addLifecycleListener(new DefaultWebXmlListener()); ContextConfig ctxCfg = new ContextConfig(); ctx.addLifecycleListener(ctxCfg); ctxCfg.setDefaultWebXml(noDefaultWebXmlPath()); if (host == null) { getHost().addChild(ctx); } else { host.addChild(ctx); } return ctx; }	public void setSilent(boolean silent) { for (String s : silences) { if (silent) { Logger.getLogger(s).setLevel(Level.WARNING); } else { Logger.getLogger(s).setLevel(Level.INFO); } } }
protected void checkHandlesTypes(JavaClass javaClass) { if (typeInitializerMap.size() == 0) { return; } String className = javaClass.getClassName(); Class<?> clazz = null; try { clazz = context.getLoader().getClassLoader().loadClass(className); } catch (NoClassDefFoundError e) { log.debug(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (ClassNotFoundException e) { log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (ClassFormatError e) { log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), t); return; } if (clazz.isAnnotation()) { return; } boolean match = false; for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry : typeInitializerMap.entrySet()) { if (entry.getKey().isAnnotation()) { AnnotationEntry[] annotationEntries = javaClass.getAnnotationEntries(); for (AnnotationEntry annotationEntry : annotationEntries) { if (entry.getKey().getName().equals(getClassName(annotationEntry.getAnnotationType()))) { match = true; break; } } } else if (entry.getKey().isAssignableFrom(clazz)) { match = true; } if (match) { for (ServletContainerInitializer sci : entry.getValue()) { initializerClassMap.get(sci).add(clazz); } match = false; } } }
protected AccessLogElement[] createLogElements() { List<AccessLogElement> list = new ArrayList<AccessLogElement>(); boolean replace = false; StringBuilder buf = new StringBuilder(); for (int i = 0; i < pattern.length(); i++) { char ch = pattern.charAt(i); if (replace) { if ('{' == ch) { StringBuilder name = new StringBuilder(); int j = i + 1; for (; j < pattern.length() && '}' != pattern.charAt(j); j++) { name.append(pattern.charAt(j)); } if (j + 1 < pattern.length()) { j++; list.add(createAccessLogElement(name.toString(), pattern.charAt(j))); i = j; /* Since we walked more than one character */ } else { // D'oh - end of string - pretend we never did this list.add(createAccessLogElement(ch)); } } else { list.add(createAccessLogElement(ch)); } replace = false; } else if (ch == '%') { replace = true; list.add(new StringElement(buf.toString())); buf = new StringBuilder(); } else { buf.append(ch); } } if (buf.length() > 0) { list.add(new StringElement(buf.toString())); } return list.toArray(new AccessLogElement[0]); }
public boolean authenticate(Request request, HttpServletResponse response, LoginConfig config) throws IOException { if (containerLog.isDebugEnabled()) { containerLog.debug("User authentication is not required"); } return (true); }
private void processParameters(byte[] bytes, int start, int len, Charset charset) { if (log.isDebugEnabled()) { log.debug(sm.getString("parameters.bytes", new String(bytes, start, len, DEFAULT_CHARSET))); } int decodeFailCount = 0; int pos = start; int end = start + len; while (pos < end) { int nameStart = pos; int nameEnd = -1; int valueStart = -1; int valueEnd = -1; boolean parsingName = true; boolean decodeName = false; boolean decodeValue = false; boolean parameterComplete = false; do { switch(bytes[pos]) { case '=': if (parsingName) { nameEnd = pos; parsingName = false; valueStart = ++pos; } else { pos++; } break; case '&': if (parsingName) { nameEnd = pos; } else { valueEnd = pos; } parameterComplete = true; pos++; break; case '%': case '+': if (parsingName) { decodeName = true; } else { decodeValue = true; } pos++; break; default: pos++; break; } } while (!parameterComplete && pos < end); if (pos == end) { if (nameEnd == -1) { nameEnd = pos; } else if (valueStart > -1 && valueEnd == -1) { valueEnd = pos; } } if (log.isDebugEnabled() && valueStart == -1) { log.debug(sm.getString("parameters.noequal", Integer.valueOf(nameStart), Integer.valueOf(nameEnd), new String(bytes, nameStart, nameEnd - nameStart, DEFAULT_CHARSET))); } if (nameEnd <= nameStart) { if (log.isInfoEnabled()) { if (valueEnd >= nameStart && log.isDebugEnabled()) { String extract = new String(bytes, nameStart, valueEnd - nameStart, DEFAULT_CHARSET); log.info(sm.getString("parameters.invalidChunk", Integer.valueOf(nameStart), Integer.valueOf(valueEnd), extract)); } else { log.info(sm.getString("parameters.invalidChunk", Integer.valueOf(nameStart), Integer.valueOf(nameEnd), null)); } } parseFailed = true; continue; // invalid chunk - it's better to ignore } tmpName.setBytes(bytes, nameStart, nameEnd - nameStart); tmpValue.setBytes(bytes, valueStart, valueEnd - valueStart); if (log.isDebugEnabled()) { try { origName.append(bytes, nameStart, nameEnd - nameStart); origValue.append(bytes, valueStart, valueEnd - valueStart); } catch (IOException ioe) { log.error(sm.getString("parameters.copyFail"), ioe); } } try { String name; String value; if (decodeName) { urlDecode(tmpName); } tmpName.setCharset(charset); name = tmpName.toString(); if (decodeValue) { urlDecode(tmpValue); } tmpValue.setCharset(charset); value = tmpValue.toString(); try { addParameter(name, value); } catch (IllegalStateException ise) { // Hitting limit stops processing further params but does parseFailed = true; log.warn(ise.getMessage()); break; } } catch (IOException e) { parseFailed = true; decodeFailCount++; if (decodeFailCount == 1 || log.isDebugEnabled()) { if (log.isDebugEnabled()) { log.debug(sm.getString("parameters.decodeFail.debug", origName.toString(), origValue.toString()), e); } else if (log.isInfoEnabled()) { log.info(sm.getString("parameters.decodeFail.info", tmpName.toString(), tmpValue.toString()), e); } } } tmpName.recycle(); tmpValue.recycle(); if (log.isDebugEnabled()) { origName.recycle(); origValue.recycle(); } } if (decodeFailCount > 1 && !log.isDebugEnabled()) { log.info(sm.getString("parameters.multipleDecodingFail", Integer.valueOf(decodeFailCount))); } }


public void setEnabled(boolean enable) { enabled = enable; if (!enabled) { lock.abortRemove(); last = first = null; } }
protected void antiLocking() { if ((context instanceof StandardContext) && ((StandardContext) context).getAntiResourceLocking()) { Host host = (Host) context.getParent(); String docBase = context.getDocBase(); if (docBase == null) { return; } if (originalDocBase == null) { originalDocBase = docBase; } else { docBase = originalDocBase; } File docBaseFile = new File(docBase); if (!docBaseFile.isAbsolute()) { docBaseFile = new File(host.getAppBaseFile(), docBase); } String path = context.getPath(); if (path == null) { return; } ContextName cn = new ContextName(path, context.getWebappVersion()); docBase = cn.getBaseName(); File file = null; if (docBase.toLowerCase(Locale.ENGLISH).endsWith(".war")) { file = new File(System.getProperty("java.io.tmpdir"), deploymentCount++ + "-" + docBase + ".war"); } else { file = new File(System.getProperty("java.io.tmpdir"), deploymentCount++ + "-" + docBase); } if (log.isDebugEnabled()) { log.debug("Anti locking context[" + context.getName() + "] setting docBase to " + file); } ExpandWar.delete(file); if (ExpandWar.copy(docBaseFile, file)) { context.setDocBase(file.getAbsolutePath()); } } }
public Map<String, String> getTaglibs() { return taglibs; }
protected void listen() throws Exception { if (doListen()) { log.warn("ServerSocketChannel already started"); return; } setListen(true); if (selector != null && datagramChannel != null) { ObjectReader oreader = new ObjectReader(MAX_UDP_SIZE); datagramChannel.socket().setSendBufferSize(getUdpTxBufSize()); datagramChannel.socket().setReceiveBufferSize(getUdpRxBufSize()); datagramChannel.socket().setReuseAddress(getSoReuseAddress()); datagramChannel.socket().setSoTimeout(getTimeout()); datagramChannel.socket().setTrafficClass(getSoTrafficClass()); registerChannel(selector, datagramChannel, SelectionKey.OP_READ, oreader); } while (doListen() && selector != null) { try { events(); socketTimeouts(); int n = selector.select(getSelectorTimeout()); if (n == 0) { continue; } Iterator<SelectionKey> it = (selector != null) ? selector.selectedKeys().iterator() : null; while (it != null && it.hasNext()) { SelectionKey key = it.next(); if (key.isAcceptable()) { ServerSocketChannel server = (ServerSocketChannel) key.channel(); SocketChannel channel = server.accept(); channel.socket().setReceiveBufferSize(getRxBufSize()); channel.socket().setSendBufferSize(getTxBufSize()); channel.socket().setTcpNoDelay(getTcpNoDelay()); channel.socket().setKeepAlive(getSoKeepAlive()); channel.socket().setOOBInline(getOoBInline()); channel.socket().setReuseAddress(getSoReuseAddress()); channel.socket().setSoLinger(getSoLingerOn(), getSoLingerTime()); channel.socket().setTrafficClass(getSoTrafficClass()); channel.socket().setSoTimeout(getTimeout()); Object attach = new ObjectReader(channel); registerChannel(selector, channel, SelectionKey.OP_READ, attach); } if (key.isReadable()) { readDataFromSocket(key); } else { key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE)); } if (selector != null) it.remove(); } } catch (java.nio.channels.ClosedSelectorException cse) { // ignore is normal at shutdown or stop listen socket } catch (java.nio.channels.CancelledKeyException nx) { log.warn("Replication client disconnected, error when polling key. Ignoring client."); } catch (Throwable t) { if (t instanceof ThreadDeath) { throw (ThreadDeath) t; } if (t instanceof VirtualMachineError) { throw (VirtualMachineError) t; } log.error("Unable to process request in NioReceiver", t); } } serverChannel.close(); if (datagramChannel != null) { try { datagramChannel.close(); } catch (Exception iox) { if (log.isDebugEnabled()) log.debug("Unable to close datagram channel.", iox); } datagramChannel = null; } closeSelector(); }
private void doTestBug51557Char(char s) { Bug51557Client client = new Bug51557Client("X-Bug" + s + "51557", "invalid"); client.setPort(getPort()); client.doRequest(); assertTrue(client.isResponse200()); assertEquals("abcd", client.getResponseBody()); assertTrue(client.isResponseBodyOK()); }	private void doTest(String resourceMethod, String redirectMethod, boolean useContinue) throws Exception { FormAuthClient client = new FormAuthClient(); client.setUseContinue(useContinue); client.doResourceRequest(resourceMethod); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.setUseContinue(useContinue); client.doLoginRequest(); assertTrue(client.isResponse302()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doResourceRequest(redirectMethod); if ("POST".equals(redirectMethod)) { client.setUseContinue(useContinue); } assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); for (int i = 0; i < 5; i++) { client.setUseContinue(useContinue); client.doResourceRequest(resourceMethod); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); } }	private ObjectName createObjectName() throws MalformedObjectNameException { domain = adapter.getDomain(); if (domain == null) { return null; } StringBuilder name = new StringBuilder(getDomain()); name.append(":type=ProtocolHandler,port="); name.append(getPort()); InetAddress address = getAddress(); if (address != null) { name.append(",address="); name.append(ObjectName.quote(address.toString())); } return new ObjectName(name.toString()); }	@Test public void testBug48692() { Bug48692Client client = new Bug48692Client(); client.setPort(getPort()); client.doRequest("GET", "foo=bar", null, null, false); assertTrue("Non-200 response for GET request", client.isResponse200()); assertEquals("Incorrect response for GET request", "foo=bar", client.getResponseBody()); client.reset(); // // Make sure POST works properly // client.doRequest("POST", "foo=bar", "application/x-www-form-urlencoded", "bar=baz", true); assertTrue("Non-200 response for POST request", client.isResponse200()); assertEquals("Incorrect response for POST request", "bar=baz,foo=bar", client.getResponseBody()); client.reset(); client.doRequest("POST", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", true); assertTrue("Non-200 response for POST request", client.isResponse200()); assertEquals("Incorrect response for POST request", "bar=baz,bar=foo,foo=bar,foo=baz", client.getResponseBody()); client.reset(); client.doRequest("PUT", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", false); assertTrue("Non-200 response for PUT/noparse request", client.isResponse200()); assertEquals("Incorrect response for PUT request", "bar=foo,foo=bar", client.getResponseBody()); client.reset(); client.doRequest("PUT", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", true); assertTrue("Non-200 response for PUT request", client.isResponse200()); assertEquals("Incorrect response for PUT/parse request", "bar=baz,bar=foo,foo=bar,foo=baz", client.getResponseBody()); client.reset(); /* private Exception doRequest(String method, String queryString, String contentType, String requestBody, boolean allowBody) { */ }	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType("text/plain"); resp.setCharacterEncoding("UTF-8"); PrintWriter out = resp.getWriter(); out.println("parts=" + (null == req.getParts() ? "null" : Integer.valueOf(req.getParts().size()))); }	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { PrintWriter out = resp.getWriter(); resp.setContentType("text/plain"); resp.setCharacterEncoding("UTF-8"); StringBuilder sb = new StringBuilder(); try { Collection<Part> c = req.getParts(); if (c == null) { log.debug("Count: -1"); sb.append("Count: -1\n"); } else { log.debug("Count: " + c.size()); sb.append("Count: " + c.size() + "\n"); for (Part p : c) { log.debug("Name: " + p.getName() + ", Size: " + p.getSize()); sb.append("Name: " + p.getName() + ", Size: " + p.getSize() + "\n"); } } } catch (IllegalStateException ex) { log.debug("IllegalStateException during getParts()"); sb.append("IllegalStateException during getParts()\n"); resp.setStatus(500); } catch (Throwable ex) { log.error("Exception during getParts()", ex); sb.append(ex); resp.setStatus(500); } out.print(sb.toString()); resp.flushBuffer(); }	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType("text/plain"); resp.setCharacterEncoding("UTF-8"); resp.setStatus(status); PrintWriter out = resp.getWriter(); out.print("OK"); resp.flushBuffer(); }	public void testWithEquals() throws Exception { System.setProperty("org.apache.tomcat.util.http.ServerCookie.ALLOW_EQUALS_IN_VALUE", "true"); TestCookieEqualsClient client = new TestCookieEqualsClient(); client.doRequest(); }	public void testWithHttpSep() throws Exception { System.setProperty("org.apache.tomcat.util.http.ServerCookie.ALLOW_HTTP_SEPARATORS_IN_V0", "true"); TestCookieHttpSepClient client = new TestCookieHttpSepClient(); client.doRequest(); }	public void testWithEquals() throws Exception { System.setProperty("org.apache.tomcat.util.http.ServerCookie.ALLOW_NAME_ONLY", "true"); TestCookieNameOnlyClient client = new TestCookieNameOnlyClient(); client.doRequest(); }	public void testWithEquals() throws Exception { TestCookieEqualsClient client = new TestCookieEqualsClient(); client.doRequest(); }	private void doTestBug51557Char(char s) { Bug51557Client client = new Bug51557Client("X-Bug" + s + "51557", "invalid"); client.setPort(getPort()); client.doRequest(); assertTrue(client.isResponse200()); assertEquals("abcd", client.getResponseBody()); assertTrue(client.isResponseBodyOK()); }	protected String createObjectNameKeyProperties(String type) { Object addressObj = getProperty("address"); StringBuilder sb = new StringBuilder("type="); sb.append(type); sb.append(",port="); sb.append(getPort()); if (addressObj != null) { String address = addressObj.toString(); if (address.length() > 0) { sb.append(",address="); sb.append(ObjectName.quote(address)); } } return sb.toString(); }	protected boolean isParseBodyMethod(String method) { return parseBodyMethodsSet.contains(method); }	public void testNoTrailingHeaders() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(ctx, "servlet", new EchoHeaderServlet()); ctx.addServletMapping("/", "servlet"); tomcat.start(); String request = "POST /echo-params.jsp HTTP/1.1" + SimpleHttpClient.CRLF + "Host: any" + SimpleHttpClient.CRLF + "Transfer-encoding: chunked" + SimpleHttpClient.CRLF + "Content-Type: application/x-www-form-urlencoded" + SimpleHttpClient.CRLF + "Connection: close" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF + "3" + SimpleHttpClient.CRLF + "a=0" + SimpleHttpClient.CRLF + "4" + SimpleHttpClient.CRLF + "&b=1" + SimpleHttpClient.CRLF + "0" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF; TrailerClient client = new TrailerClient(); client.setPort(getPort()); client.setRequest(new String[] { request }); client.connect(); client.processRequest(); assertEquals("null7null", client.getResponseBody()); }	@Override protected void startInternal() throws LifecycleException { if (getPort() < 1) { throw new LifecycleException(sm.getString("coyoteConnector.invalidPort", Integer.valueOf(getPort()))); } setState(LifecycleState.STARTING); try { protocolHandler.start(); } catch (Exception e) { String errPrefix = ""; if (this.service != null) { errPrefix += "service.getName(): \"" + this.service.getName() + "\"; "; } throw new LifecycleException(errPrefix + " " + sm.getString("coyoteConnector.protocolHandlerStartFailed"), e); } mapperListener.start(); }	protected void validate(HttpServlet servlet, Integer expectedMaxAgeInSeconds, int expectedResponseStatusCode) throws Exception { Tomcat tomcat = getTomcatInstance(); Context root = tomcat.addContext("", TEMP_DIR); FilterDef filterDef = new FilterDef(); filterDef.addInitParameter("ExpiresDefault", "access plus 1 minute"); filterDef.addInitParameter("ExpiresByType text/xml;charset=utf-8", "access plus 3 minutes"); filterDef.addInitParameter("ExpiresByType text/xml", "access plus 5 minutes"); filterDef.addInitParameter("ExpiresByType text", "access plus 7 minutes"); filterDef.addInitParameter("ExpiresExcludedResponseStatusCodes", "304, 503"); filterDef.setFilterClass(ExpiresFilter.class.getName()); filterDef.setFilterName(ExpiresFilter.class.getName()); root.addFilterDef(filterDef); FilterMap filterMap = new FilterMap(); filterMap.setFilterName(ExpiresFilter.class.getName()); filterMap.addURLPattern("*"); root.addFilterMap(filterMap); Tomcat.addServlet(root, servlet.getClass().getName(), servlet); root.addServletMapping("/test", servlet.getClass().getName()); tomcat.start(); try { Calendar.getInstance(TimeZone.getTimeZone("GMT")); long timeBeforeInMillis = System.currentTimeMillis(); HttpURLConnection httpURLConnection = (HttpURLConnection) new URL("http://localhost:" + tomcat.getConnector().getPort() + "/test").openConnection(); Assert.assertEquals(expectedResponseStatusCode, httpURLConnection.getResponseCode()); StringBuilder msg = new StringBuilder(); for (Entry<String, List<String>> field : httpURLConnection.getHeaderFields().entrySet()) { for (String value : field.getValue()) { msg.append((field.getKey() == null ? "" : field.getKey() + ": ") + value + "\n"); } } System.out.println(msg); Integer actualMaxAgeInSeconds; String cacheControlHeader = httpURLConnection.getHeaderField("Cache-Control"); if (cacheControlHeader == null) { actualMaxAgeInSeconds = null; } else { actualMaxAgeInSeconds = null; StringTokenizer cacheControlTokenizer = new StringTokenizer(cacheControlHeader, ","); while (cacheControlTokenizer.hasMoreTokens() && actualMaxAgeInSeconds == null) { String cacheDirective = cacheControlTokenizer.nextToken(); StringTokenizer cacheDirectiveTokenizer = new StringTokenizer(cacheDirective, "="); if (cacheDirectiveTokenizer.countTokens() == 2) { String key = cacheDirectiveTokenizer.nextToken().trim(); String value = cacheDirectiveTokenizer.nextToken().trim(); if (key.equalsIgnoreCase("max-age")) { actualMaxAgeInSeconds = Integer.valueOf(value); } } } } if (expectedMaxAgeInSeconds == null) { Assert.assertNull("actualMaxAgeInSeconds '" + actualMaxAgeInSeconds + "' should be null", actualMaxAgeInSeconds); return; } Assert.assertNotNull(actualMaxAgeInSeconds); @SuppressWarnings("null") int deltaInSeconds = Math.abs(actualMaxAgeInSeconds.intValue() - expectedMaxAgeInSeconds.intValue()); Assert.assertTrue("actualMaxAgeInSeconds: " + actualMaxAgeInSeconds + ", expectedMaxAgeInSeconds: " + expectedMaxAgeInSeconds + ", request time: " + timeBeforeInMillis + " for content type " + httpURLConnection.getContentType(), deltaInSeconds < 3); } finally { tomcat.stop(); } }	public Exception doAbortedPOSTTest(AbortedPOSTClient client, int status, boolean swallow) { client.setPort(getPort()); Exception ex = client.doRequest(status, swallow); if (log.isDebugEnabled()) { log.debug("Response line: " + client.getResponseLine()); log.debug("Response headers: " + client.getResponseHeaders()); log.debug("Response body: " + client.getResponseBody()); if (ex != null) { log.info("Exception in client: ", ex); } } return ex; }	public Exception doAbortedUploadTest(AbortedUploadClient client, boolean limited, boolean swallow) { client.setPort(getPort()); Exception ex = client.doRequest(limited, swallow); if (log.isDebugEnabled()) { log.debug("Response line: " + client.getResponseLine()); log.debug("Response headers: " + client.getResponseHeaders()); log.debug("Response body: " + client.getResponseBody()); if (ex != null) { log.debug("Exception in client: ", ex); } } return ex; }	@Override public boolean getUsePolling() { return false; }	public boolean getSSLInsecureRenegotiation() { return SSLInsecureRenegotiation; }	public String getName() { StringBuilder name = new StringBuilder(getNamePrefix()); name.append('-'); if (getAddress() != null) { name.append(getAddress()); name.append('-'); } name.append(endpoint.getPort()); return ObjectName.quote(name.toString()); }	@Override public String toString() { StringBuilder sb = new StringBuilder("Connector["); sb.append(getProtocol()); sb.append('-'); sb.append(getPort()); sb.append(']'); return sb.toString(); }	public int getPort() { return port; }	public static int getUrl(String path, ByteChunk out, Map<String, List<String>> resHead) throws IOException { out.recycle(); return TomcatBaseTest.getUrl(path, out, resHead); }	public void testPipelining() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctxt = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(ctxt, "TesterServlet", new TesterServlet()); ctxt.addServletMapping("/foo", "TesterServlet"); tomcat.start(); String requestPart1 = "GET /foo HTTP/1.1" + SimpleHttpClient.CRLF; String requestPart2 = "Host: any" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF; final Client client = new Client(); client.setPort(getPort()); client.setRequest(new String[] { requestPart1, requestPart2 }); client.setRequestPause(1000); client.setUseContentLength(true); client.connect(); Runnable send = new Runnable() { @Override public void run() { try { client.sendRequest(); client.sendRequest(); } catch (InterruptedException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } }; Thread t = new Thread(send); t.start(); // Sleep for 1500 ms which should mean the all of request 1 has been Thread.sleep(1500); client.readResponse(true); assertFalse(client.isResponse50x()); assertTrue(client.isResponse200()); assertEquals("OK", client.getResponseBody()); // Read the second response. No need to sleep, read will block until client.readResponse(true); assertFalse(client.isResponse50x()); assertTrue(client.isResponse200()); assertEquals("OK", client.getResponseBody()); }	public void setBindOnInit(boolean b) { this.bindOnInit = b; }	public void setSSLContext(SSLContext c) { sslContext = c; }	public void setPort(int port) { this.port = port; setProperty("port", String.valueOf(port)); }	public void setPort(int port) { endpoint.setPort(port); }	public void setSoTimeout(int timeout) { setConnectionTimeout(timeout); }	@Before @Override public void setUp() throws Exception { super.setUp(); CatalinaProperties.getProperty("foo"); File appBase = new File(getTemporaryDirectory(), "webapps"); if (!appBase.exists() && !appBase.mkdir()) { fail("Unable to create appBase for test"); } tomcat = new TomcatWithFastSessionIDs(); String protocol = getProtocol(); Connector connector = new Connector(protocol); // If each test is running on same port - they connector.setPort(getNextPort()); connector.setAttribute("connectionTimeout", "3000"); tomcat.getService().addConnector(connector); tomcat.setConnector(connector); if (protocol.contains("Apr")) { StandardServer server = (StandardServer) tomcat.getServer(); AprLifecycleListener listener = new AprLifecycleListener(); listener.setSSLRandomSeed("/dev/urandom"); server.addLifecycleListener(listener); connector.setAttribute("pollerThreadCount", Integer.valueOf(1)); } File catalinaBase = getTemporaryDirectory(); tomcat.setBaseDir(catalinaBase.getAbsolutePath()); tomcat.getHost().setAppBase(appBase.getAbsolutePath()); accessLogEnabled = Boolean.parseBoolean(System.getProperty("tomcat.test.accesslog", "false")); if (accessLogEnabled) { AccessLogValve alv = new AccessLogValve(); alv.setDirectory(getBuildDirectory() + "/logs"); alv.setPattern("%h %l %u %t \"%r\" %s %b %I %D"); tomcat.getHost().getPipeline().addValve(alv); } // Cannot delete the whole tempDir, because logs are there, addDeleteOnTearDown(new File(catalinaBase, "webapps")); addDeleteOnTearDown(new File(catalinaBase, "work")); }	public void testBug37794() { Bug37794Client client = new Bug37794Client(true); client.setPort(getPort()); // Edge cases around zero client.doRequest(-1, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(0, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(1, false); assertTrue(client.isResponse400()); client.reset(); client.reset(); client.doRequest(6, false); assertTrue(client.isResponse400()); client.reset(); client.doRequest(7, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(8, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(8096, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(8096, true); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); }	@Test public void testBug37794withoutFilter() { Bug37794Client client = new Bug37794Client(false); client.setPort(getPort()); client.reset(); client.doRequest(6, false); assertTrue(client.isResponse200()); assertEquals("", client.getResponseBody()); }	public void testBug46243() throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(tomcat.getHost().getAppBaseFile(), "ROOT"); if (!docBase.mkdirs() && !docBase.isDirectory()) { fail("Unable to create docBase"); } Context root = tomcat.addContext("", "ROOT"); FilterDef filterDef = new FilterDef(); filterDef.setFilterClass(Bug46243Filter.class.getName()); filterDef.setFilterName("Bug46243"); root.addFilterDef(filterDef); FilterMap filterMap = new FilterMap(); filterMap.setFilterName("Bug46243"); filterMap.addURLPattern("*"); root.addFilterMap(filterMap); // Add a test servlet so there is something to generate a response if Tomcat.addServlet(root, "Bug46243", new HelloWorldServlet()); root.addServletMapping("/", "Bug46243"); tomcat.start(); Bug46243Client client = new Bug46243Client(); client.setPort(getPort()); client.setRequest(new String[] { REQUEST }); client.connect(); client.processRequest(); assertTrue(client.isResponse404()); }	@Test public void testBug48692() { Bug48692Client client = new Bug48692Client(); client.setPort(getPort()); client.doRequest("GET", "foo=bar", null, null, false); assertTrue("Non-200 response for GET request", client.isResponse200()); assertEquals("Incorrect response for GET request", "foo=bar", client.getResponseBody()); client.reset(); // // Make sure POST works properly // client.doRequest("POST", "foo=bar", "application/x-www-form-urlencoded", "bar=baz", true); assertTrue("Non-200 response for POST request", client.isResponse200()); assertEquals("Incorrect response for POST request", "bar=baz,foo=bar", client.getResponseBody()); client.reset(); client.doRequest("POST", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", true); assertTrue("Non-200 response for POST request", client.isResponse200()); assertEquals("Incorrect response for POST request", "bar=baz,bar=foo,foo=bar,foo=baz", client.getResponseBody()); client.reset(); client.doRequest("PUT", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", false); assertTrue("Non-200 response for PUT/noparse request", client.isResponse200()); assertEquals("Incorrect response for PUT request", "bar=foo,foo=bar", client.getResponseBody()); client.reset(); client.doRequest("PUT", "foo=bar&bar=foo", "application/x-www-form-urlencoded", "bar=baz&foo=baz", true); assertTrue("Non-200 response for PUT request", client.isResponse200()); assertEquals("Incorrect response for PUT/parse request", "bar=baz,bar=foo,foo=bar,foo=baz", client.getResponseBody()); client.reset(); }	public void testBug48839() { Bug48839Client client = new Bug48839Client(); client.setPort(getPort()); client.doRequest(); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); }	@Test public void testBug49711() { Bug49711Client client = new Bug49711Client(); client.setPort(getPort()); client.doRequest("/regular", false, false); assertEquals("Incorrect response for GET request", "parts=0", client.getResponseBody()); client.reset(); // Make sure regular multipart works properly client.doRequest("/multipart", false, true); assertEquals("Regular multipart doesn't work", "parts=1", client.getResponseBody()); client.reset(); // Make casual multipart request to "regular" servlet w/o config // We expect that no parts will be available client.doRequest("/regular", false, true); assertEquals("Incorrect response for non-configured casual multipart request", "parts=0", client.getResponseBody()); client.reset(); // Make casual multipart request to "regular" servlet w/config // We expect that the server /will/ parse the parts, even though // there is no @MultipartConfig client.doRequest("/regular", true, true); assertEquals("Incorrect response for configured casual multipart request", "parts=1", client.getResponseBody()); client.reset(); }	@Test public void testBug51557BoundaryEnd() { Bug51557Client client = new Bug51557Client("X-Bug51557=", "invalid"); client.setPort(getPort()); client.doRequest(); assertTrue(client.isResponse200()); assertEquals("abcd", client.getResponseBody()); assertTrue(client.isResponseBodyOK()); }	@Test public void testBug51557BoundaryStart() { Bug51557Client client = new Bug51557Client("=X-Bug51557", "invalid"); client.setPort(getPort()); client.doRequest(); assertTrue(client.isResponse200()); assertEquals("abcd", client.getResponseBody()); assertTrue(client.isResponseBodyOK()); }	@Test public void testBug51557Continuation() { Bug51557Client client = new Bug51557Client("X-Bug=51557NoColon", "foo" + SimpleHttpClient.CRLF + " bar"); client.setPort(getPort()); client.doRequest(); assertTrue(client.isResponse200()); assertEquals("abcd", client.getResponseBody()); assertTrue(client.isResponseBodyOK()); }	@Test public void testBug51557NoColon() { Bug51557Client client = new Bug51557Client("X-Bug51557NoColon"); client.setPort(getPort()); client.doRequest(); assertTrue(client.isResponse200()); assertEquals("abcd", client.getResponseBody()); assertTrue(client.isResponseBodyOK()); }	@Test public void testCustomErrorPage() throws Exception { File appDir = new File(getTemporaryDirectory(), "MyApp"); File webInf = new File(appDir, "WEB-INF"); addDeleteOnTearDown(appDir); if (!webInf.mkdirs() && !webInf.isDirectory()) { fail("Unable to create directory [" + webInf + "]"); } Writer w = new OutputStreamWriter(new FileOutputStream(new File(appDir, "WEB-INF/web.xml")), "UTF-8"); try { w.write("<?xml version='1.0' encoding='UTF-8'?>\n" + "<web-app xmlns='http://java.sun.com/xml/ns/j2ee' " + " xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'" + " xsi:schemaLocation='http://java.sun.com/xml/ns/j2ee " + " http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd'" + " version='2.4'>\n" + "<error-page>\n<error-code>404</error-code>\n" + "<location>/404.html</location>\n</error-page>\n" + "</web-app>\n"); w.flush(); } finally { w.close(); } w = new OutputStreamWriter(new FileOutputStream(new File(appDir, "404.html")), "ISO-8859-1"); try { w.write("It is 404.html"); w.flush(); } finally { w.close(); } Tomcat tomcat = getTomcatInstance(); String contextPath = "/MyApp"; tomcat.addWebapp(null, contextPath, appDir.getAbsolutePath()); tomcat.start(); TestCustomErrorClient client = new TestCustomErrorClient(); client.setPort(getPort()); client.reset(); client.setRequest(new String[] { "GET /MyApp/missing HTTP/1.0" + CRLF + CRLF }); client.connect(); client.processRequest(); assertTrue(client.isResponse404()); assertEquals("It is 404.html", client.getResponseBody()); SimpleDateFormat format = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US); format.setTimeZone(TimeZone.getTimeZone("GMT")); String tomorrow = format.format(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)); // https://issues.apache.org/bugzilla/show_bug.cgi?id=50413 client.reset(); client.setRequest(new String[] { "GET /MyApp/missing HTTP/1.1" + CRLF + "Host: localhost" + CRLF + "Connection: close" + CRLF + "If-Modified-Since: " + tomorrow + CRLF + CRLF }); client.connect(); client.processRequest(); assertTrue(client.isResponse404()); assertEquals("It is 404.html", client.getResponseBody()); // https://issues.apache.org/bugzilla/show_bug.cgi?id=50413#c6 client.reset(); client.setRequest(new String[] { "GET /MyApp/missing HTTP/1.1" + CRLF + "Host: localhost" + CRLF + "Connection: close" + CRLF + "Range: bytes=0-100" + CRLF + CRLF }); client.connect(); client.processRequest(); assertTrue(client.isResponse404()); assertEquals("It is 404.html", client.getResponseBody()); }	@Test public void testCustomErrorPageMissing() throws Exception { File appDir = new File(getTemporaryDirectory(), "MyApp"); File webInf = new File(appDir, "WEB-INF"); addDeleteOnTearDown(appDir); if (!webInf.mkdirs() && !webInf.isDirectory()) { fail("Unable to create directory [" + webInf + "]"); } Writer w = new OutputStreamWriter(new FileOutputStream(new File(appDir, "WEB-INF/web.xml")), "UTF-8"); try { w.write("<?xml version='1.0' encoding='UTF-8'?>\n" + "<web-app xmlns='http://java.sun.com/xml/ns/j2ee' " + " xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'" + " xsi:schemaLocation='http://java.sun.com/xml/ns/j2ee " + " http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd'" + " version='2.4'>\n" + "<error-page>\n<error-code>404</error-code>\n" + "<location>/404-absent.html</location>\n</error-page>\n" + "</web-app>\n"); w.flush(); } finally { w.close(); } Tomcat tomcat = getTomcatInstance(); String contextPath = "/MyApp"; tomcat.addWebapp(null, contextPath, appDir.getAbsolutePath()); tomcat.start(); TestCustomErrorClient client = new TestCustomErrorClient(); client.setPort(getPort()); client.reset(); client.setRequest(new String[] { "GET /MyApp/missing HTTP/1.0" + CRLF + CRLF }); client.connect(); client.processRequest(); assertTrue(client.isResponse404()); }	public void testMBeanDeregistration() throws Exception { final MBeanServer mbeanServer = Registry.getRegistry(null, null).getMBeanServer(); Set<ObjectName> onames = mbeanServer.queryNames(new ObjectName("Catalina:*"), null); assertEquals("Remaining: " + onames, 0, onames.size()); final Tomcat tomcat = getTomcatInstance(); final File contextDir = new File(getTemporaryDirectory(), "webappFoo"); addDeleteOnTearDown(contextDir); if (!contextDir.mkdirs() && !contextDir.isDirectory()) { fail("Failed to create: [" + contextDir.toString() + "]"); } tomcat.addContext(contextName, contextDir.getAbsolutePath()); tomcat.start(); onames = mbeanServer.queryNames(new ObjectName("Catalina:*"), null); assertEquals("Found: " + onames, 0, onames.size()); onames = mbeanServer.queryNames(new ObjectName("Tomcat:*"), null); ArrayList<String> found = new ArrayList<String>(onames.size()); for (ObjectName on : onames) { found.add(on.toString()); } String protocol = getTomcatInstance().getConnector().getProtocolHandlerClassName(); if (protocol.indexOf("Nio") > 0) { protocol = "nio"; } else if (protocol.indexOf("Apr") > 0) { protocol = "apr"; } else { protocol = "bio"; } ArrayList<String> expected = new ArrayList<String>(Arrays.asList(basicMBeanNames())); expected.addAll(Arrays.asList(hostMBeanNames("localhost"))); expected.addAll(Arrays.asList(contextMBeanNames("localhost", contextName))); expected.addAll(Arrays.asList(connectorMBeanNames(Integer.toString(getPort()), protocol))); expected.addAll(Arrays.asList(optionalMBeanNames("localhost"))); ArrayList<String> missing = new ArrayList<String>(expected); missing.removeAll(found); assertTrue("Missing Tomcat MBeans: " + missing, missing.isEmpty()); List<String> additional = found; additional.removeAll(expected); assertTrue("Unexpected Tomcat MBeans: " + additional, additional.isEmpty()); tomcat.stop(); onames = mbeanServer.queryNames(new ObjectName("Tomcat:*"), null); assertTrue("No Tomcat MBeans", onames.size() > 0); StandardHost host = new StandardHost(); host.setName("otherhost"); tomcat.getEngine().addChild(host); final File contextDir2 = new File(getTemporaryDirectory(), "webappFoo2"); addDeleteOnTearDown(contextDir2); if (!contextDir2.mkdirs() && !contextDir2.isDirectory()) { fail("Failed to create: [" + contextDir2.toString() + "]"); } tomcat.addContext(host, contextName + "2", contextDir2.getAbsolutePath()); tomcat.start(); tomcat.stop(); tomcat.destroy(); onames = mbeanServer.queryNames(new ObjectName("Catalina:*"), null); assertEquals("Remaining: " + onames, 0, onames.size()); onames = mbeanServer.queryNames(new ObjectName("Tomcat:*"), null); assertEquals("Remaining: " + onames, 0, onames.size()); }	@Test public void testNoTrailingHeaders() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(ctx, "servlet", new EchoHeaderServlet()); ctx.addServletMapping("/", "servlet"); tomcat.start(); String request = "POST /echo-params.jsp HTTP/1.1" + SimpleHttpClient.CRLF + "Host: any" + SimpleHttpClient.CRLF + "Transfer-encoding: chunked" + SimpleHttpClient.CRLF + "Content-Type: application/x-www-form-urlencoded" + SimpleHttpClient.CRLF + "Connection: close" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF + "3" + SimpleHttpClient.CRLF + "a=0" + SimpleHttpClient.CRLF + "4" + SimpleHttpClient.CRLF + "&b=1" + SimpleHttpClient.CRLF + "0" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF; TrailerClient client = new TrailerClient(); client.setPort(getPort()); client.setRequest(new String[] { request }); client.connect(); client.processRequest(); assertEquals("null7null", client.getResponseBody()); }	@Test public void testPipelining() throws Exception { Tomcat tomcat = getTomcatInstance(); // Must have a real docBase - just use temp Context ctxt = tomcat.addContext("", System.getProperty("java.io.tmpdir")); // Add protected servlet Tomcat.addServlet(ctxt, "TesterServlet", new TesterServlet()); ctxt.addServletMapping("/foo", "TesterServlet"); tomcat.start(); String requestPart1 = "GET /foo HTTP/1.1" + SimpleHttpClient.CRLF; String requestPart2 = "Host: any" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF; final Client client = new Client(); client.setPort(getPort()); client.setRequest(new String[] {requestPart1, requestPart2}); client.setRequestPause(1000); client.setUseContentLength(true); client.connect(); Runnable send = new Runnable() { @Override } }	@Test public void testStartStopBindOnStart() throws Exception { Tomcat tomcat = getTomcatInstance(); Connector c = tomcat.getConnector(); c.setProperty("bindOnInit", "false"); File appDir = new File(getBuildDirectory(), "webapps/examples"); tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); int port = getPort(); tomcat.start(); tomcat.getConnector().stop(); Exception e = null; ServerSocket s = null; long pool = 0; long nativeSocket = 0; boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains("Apr"); try { if (isApr) { pool = createAprPool(); assertTrue(pool != 0); nativeSocket = createAprSocket(port, pool); assertTrue(nativeSocket != 0); } else { s = new ServerSocket(port); } } catch (Exception e1) { e = e1; } finally { try { if (isApr) { destroyAprSocket(nativeSocket, pool); } else if (s != null) { s.close(); } } catch (Exception e2) { /* Ignore */ } } assertNull(e); tomcat.getConnector().start(); }	public void testStop() throws Exception { Tomcat tomcat = getTomcatInstance(); Context root = tomcat.addContext("", TEMP_DIR); Wrapper w = Tomcat.addServlet(root, "tester", new TesterServlet()); w.setAsyncSupported(true); root.addServletMapping("/", "tester"); Connector connector = tomcat.getConnector(); tomcat.start(); ByteChunk bc = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/", bc, null, null); assertEquals(200, rc); assertEquals("OK", bc.toString()); rc = -1; bc.recycle(); connector.stop(); try { rc = getUrl("http://localhost:" + getPort() + "/", bc, 1000, null, null); } catch (SocketTimeoutException ste) { // May also see this with NIO rc = 503; } assertEquals(503, rc); }	public void testTrailingHeaders() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(ctx, "servlet", new EchoHeaderServlet()); ctx.addServletMapping("/", "servlet"); tomcat.start(); String[] request = new String[] { "POST /echo-params.jsp HTTP/1.1" + SimpleHttpClient.CRLF + "Host: any" + SimpleHttpClient.CRLF + "Transfer-encoding: chunked" + SimpleHttpClient.CRLF + "Content-Type: application/x-www-form-urlencoded" + SimpleHttpClient.CRLF + "Connection: close" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF + "3" + SimpleHttpClient.CRLF + "a=0" + SimpleHttpClient.CRLF + "4" + SimpleHttpClient.CRLF + "&b=1" + SimpleHttpClient.CRLF + "0" + SimpleHttpClient.CRLF + "x-trailer: Test", "TestTest0123456789abcdefghijABCDEFGHIJopqrstuvwxyz" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF }; TrailerClient client = new TrailerClient(); client.setPort(getPort()); client.setRequest(request); client.connect(); client.processRequest(); assertEquals("null7TestTestTest0123456789abcdefghijABCDEFGHIJopqrstuvwxyz", client.getResponseBody()); }	@Test public void testTrailingHeadersSizeLimit() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(ctx, "servlet", new EchoHeaderServlet()); ctx.addServletMapping("/", "servlet"); tomcat.getConnector().setProperty("maxTrailerSize", "10"); tomcat.start(); String[] request = new String[] { "POST /echo-params.jsp HTTP/1.1" + SimpleHttpClient.CRLF + "Host: any" + SimpleHttpClient.CRLF + "Transfer-encoding: chunked" + SimpleHttpClient.CRLF + "Content-Type: application/x-www-form-urlencoded" + SimpleHttpClient.CRLF + "Connection: close" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF + "3" + SimpleHttpClient.CRLF + "a=0" + SimpleHttpClient.CRLF + "4" + SimpleHttpClient.CRLF + "&b=1" + SimpleHttpClient.CRLF + "0" + SimpleHttpClient.CRLF + "x-trailer: Test" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF }; TrailerClient client = new TrailerClient(); client.setPort(getPort()); client.setRequest(request); client.connect(); client.processRequest(); // Expected to fail because the trailers are longer assertTrue(client.isResponse500()); }	@Test public void testWithTEBuffered() throws Exception { Tomcat tomcat = getTomcatInstance(); File root = new File("test/webapp-3.0"); tomcat.addWebapp("", root.getAbsolutePath()); tomcat.start(); String request = "POST /echo-params.jsp HTTP/1.1" + SimpleHttpClient.CRLF + "Host: any" + SimpleHttpClient.CRLF + "Transfer-encoding: buffered" + SimpleHttpClient.CRLF + "Content-Length: 9" + SimpleHttpClient.CRLF + "Content-Type: application/x-www-form-urlencoded" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF + "test=data"; Client client = new Client(); client.setPort(getPort()); client.setRequest(new String[] { request }); client.connect(); client.processRequest(); assertTrue(client.isResponse501()); }	@Test public void testWithTEIdentity() throws Exception { Tomcat tomcat = getTomcatInstance(); File root = new File("test/webapp-3.0"); tomcat.addWebapp("", root.getAbsolutePath()); tomcat.start(); String request = "POST /echo-params.jsp HTTP/1.1" + SimpleHttpClient.CRLF + "Host: any" + SimpleHttpClient.CRLF + "Transfer-encoding: identity" + SimpleHttpClient.CRLF + "Content-Length: 9" + SimpleHttpClient.CRLF + "Content-Type: application/x-www-form-urlencoded" + SimpleHttpClient.CRLF + "Connection: close" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF + "test=data"; Client client = new Client(); client.setPort(getPort()); client.setRequest(new String[] { request }); client.connect(); client.processRequest(); assertTrue(client.isResponse200()); assertTrue(client.getResponseBody().contains("test - data")); }	@Test public void testWithTESavedRequest() throws Exception { Tomcat tomcat = getTomcatInstance(); File root = new File("test/webapp-3.0"); tomcat.addWebapp("", root.getAbsolutePath()); tomcat.start(); String request = "POST /echo-params.jsp HTTP/1.1" + SimpleHttpClient.CRLF + "Host: any" + SimpleHttpClient.CRLF + "Transfer-encoding: savedrequest" + SimpleHttpClient.CRLF + "Content-Length: 9" + SimpleHttpClient.CRLF + "Content-Type: application/x-www-form-urlencoded" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF + "test=data"; Client client = new Client(); client.setPort(getPort()); client.setRequest(new String[] { request }); client.connect(); client.processRequest(); assertTrue(client.isResponse501()); }	@Test public void testWithTEUnsupported() throws Exception { Tomcat tomcat = getTomcatInstance(); File root = new File("test/webapp-3.0"); tomcat.addWebapp("", root.getAbsolutePath()); tomcat.start(); String request = "POST /echo-params.jsp HTTP/1.1" + SimpleHttpClient.CRLF + "Host: any" + SimpleHttpClient.CRLF + "Transfer-encoding: unsupported" + SimpleHttpClient.CRLF + "Content-Length: 9" + SimpleHttpClient.CRLF + "Content-Type: application/x-www-form-urlencoded" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF + "test=data"; Client client = new Client(); client.setPort(getPort()); client.setRequest(new String[] { request }); client.connect(); client.processRequest(); assertTrue(client.isResponse501()); }	public void testWithTEVoid() throws Exception { Tomcat tomcat = getTomcatInstance(); File root = new File("test/webapp-3.0"); tomcat.addWebapp("", root.getAbsolutePath()); tomcat.start(); String request = "POST /echo-params.jsp HTTP/1.1" + SimpleHttpClient.CRLF + "Host: any" + SimpleHttpClient.CRLF + "Transfer-encoding: void" + SimpleHttpClient.CRLF + "Content-Length: 9" + SimpleHttpClient.CRLF + "Content-Type: application/x-www-form-urlencoded" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF + "test=data"; Client client = new Client(); client.setPort(getPort()); client.setRequest(new String[] { request }); client.connect(); client.processRequest(); assertTrue(client.isResponse501()); }	@Test public void testWithTomcatServer() throws Exception { Map<String, String> remoteIpFilterParameter = new HashMap<String, String>(); remoteIpFilterParameter.put("protocolHeader", "x-forwarded-proto"); Tomcat tomcat = getTomcatInstance(); Context root = tomcat.addContext("", TEMP_DIR); FilterDef filterDef = new FilterDef(); filterDef.getParameterMap().putAll(remoteIpFilterParameter); filterDef.setFilterClass(RemoteIpFilter.class.getName()); filterDef.setFilterName(RemoteIpFilter.class.getName()); root.addFilterDef(filterDef); FilterMap filterMap = new FilterMap(); filterMap.setFilterName(RemoteIpFilter.class.getName()); filterMap.addURLPattern("*"); root.addFilterMap(filterMap); MockHttpServlet mockServlet = new MockHttpServlet(); Tomcat.addServlet(root, mockServlet.getClass().getName(), mockServlet); root.addServletMapping("/test", mockServlet.getClass().getName()); getTomcatInstance().start(); HttpURLConnection httpURLConnection = (HttpURLConnection) new URL("http://localhost:" + tomcat.getConnector().getPort() + "/test").openConnection(); String expectedRemoteAddr = "my-remote-addr"; httpURLConnection.addRequestProperty("x-forwarded-for", expectedRemoteAddr); httpURLConnection.addRequestProperty("x-forwarded-proto", "https"); Assert.assertEquals(HttpURLConnection.HTTP_OK, httpURLConnection.getResponseCode()); HttpServletRequest request = mockServlet.getRequest(); Assert.assertNotNull(request); Assert.assertEquals(expectedRemoteAddr, request.getRemoteAddr()); Assert.assertEquals(expectedRemoteAddr, request.getRemoteHost()); Assert.assertTrue(request.isSecure()); Assert.assertEquals("https", request.getScheme()); Assert.assertEquals(443, request.getServerPort()); }
public synchronized void addHostAlias(String name, String alias) { int pos = find(hosts, name); if (pos < 0) { return; } Host realHost = hosts[pos]; Host[] newHosts = new Host[hosts.length + 1]; Host newHost = new Host(); newHost.name = alias; newHost.contextList = realHost.contextList; newHost.object = realHost; if (insertMap(hosts, newHosts, newHost)) { hosts = newHosts; } }	public void setUp() throws Exception { mapper = new Mapper(); mapper.addHost("sjbjdvwsbvhrb", new String[0], "blah1"); mapper.addHost("sjbjdvwsbvhr/", new String[0], "blah1"); mapper.addHost("wekhfewuifweuibf", new String[0], "blah2"); mapper.addHost("ylwrehirkuewh", new String[0], "blah3"); mapper.addHost("iohgeoihro", new String[0], "blah4"); mapper.addHost("fwehoihoihwfeo", new String[0], "blah5"); mapper.addHost("owefojiwefoi", new String[0], "blah6"); mapper.addHost("iowejoiejfoiew", new String[0], "blah7"); mapper.addHost("iowejoiejfoiew", new String[0], "blah17"); mapper.addHost("ohewoihfewoih", new String[0], "blah8"); mapper.addHost("fewohfoweoih", new String[0], "blah9"); mapper.addHost("ttthtiuhwoih", new String[0], "blah10"); mapper.addHost("lkwefjwojweffewoih", new String[0], "blah11"); mapper.addHost("zzzuyopjvewpovewjhfewoih", new String[0], "blah12"); mapper.addHost("xxxxgqwiwoih", new String[0], "blah13"); mapper.addHost("qwigqwiwoih", new String[0], "blah14"); mapper.setDefaultHostName("ylwrehirkuewh"); String[] welcomes = new String[2]; welcomes[0] = "boo/baba"; welcomes[1] = "bobou"; mapper.addContextVersion("iowejoiejfoiew", "blah7", "", "0", "context0", new String[0], null); mapper.addContextVersion("iowejoiejfoiew", "blah7", "/foo", "0", "context1", new String[0], null); mapper.addContextVersion("iowejoiejfoiew", "blah7", "/foo/bar", "0", "context2", welcomes, null); mapper.addContextVersion("iowejoiejfoiew", "blah7", "/foo/bar/bla", "0", "context3", new String[0], null); mapper.addWrapper("iowejoiejfoiew", "/foo/bar", "0", "/fo/*", "wrapper0", false, false); mapper.addWrapper("iowejoiejfoiew", "/foo/bar", "0", "/", "wrapper1", false, false); mapper.addWrapper("iowejoiejfoiew", "/foo/bar", "0", "/blh", "wrapper2", false, false); mapper.addWrapper("iowejoiejfoiew", "/foo/bar", "0", "*.jsp", "wrapper3", false, false); mapper.addWrapper("iowejoiejfoiew", "/foo/bar", "0", "/blah/bou/*", "wrapper4", false, false); mapper.addWrapper("iowejoiejfoiew", "/foo/bar", "0", "/blah/bobou/*", "wrapper5", false, false); mapper.addWrapper("iowejoiejfoiew", "/foo/bar", "0", "*.htm", "wrapper6", false, false); mapper.addWrapper("iowejoiejfoiew", "/foo/bar/bla", "0", "/bobou/*", "wrapper7", false, false); }	@Test public void testAddHost() throws Exception { assertEquals(15, mapper.hosts.length); assertEquals("blah7", mapper.hosts[3].object); String previous; String current = mapper.hosts[0].name; for (int i = 1; i < mapper.hosts.length; i++) { previous = current; current = mapper.hosts[i].name; assertTrue(previous.compareTo(current) < 0); } }	@Test public void testMap() throws Exception { MappingData mappingData = new MappingData(); MessageBytes host = MessageBytes.newInstance(); host.setString("iowejoiejfoiew"); MessageBytes uri = MessageBytes.newInstance(); uri.setString("/foo/bar/blah/bobou/foo"); uri.toChars(); uri.getCharChunk().setLimit(-1); mapper.map(host, uri, null, mappingData); assertEquals("blah7", mappingData.host); assertEquals("context2", mappingData.context); assertEquals("wrapper5", mappingData.wrapper); assertEquals("/foo/bar", mappingData.contextPath.toString()); assertEquals("/blah/bobou", mappingData.wrapperPath.toString()); assertEquals("/foo", mappingData.pathInfo.toString()); assertTrue(mappingData.redirectPath.isNull()); mappingData.recycle(); uri.recycle(); uri.setString("/foo/bar/bla/bobou/foo"); uri.toChars(); uri.getCharChunk().setLimit(-1); mapper.map(host, uri, null, mappingData); assertEquals("blah7", mappingData.host); assertEquals("context3", mappingData.context); assertEquals("wrapper7", mappingData.wrapper); assertEquals("/foo/bar/bla", mappingData.contextPath.toString()); assertEquals("/bobou", mappingData.wrapperPath.toString()); assertEquals("/foo", mappingData.pathInfo.toString()); assertTrue(mappingData.redirectPath.isNull()); }
public boolean getDelegate() { return (this.delegate); }
private static void initializeSSL() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException { if ("off".equalsIgnoreCase(SSLEngine)) { return; } if (sslInitialized) { return; } sslInitialized = true; String methodName = "randSet"; Class<?>[] paramTypes = new Class[1]; paramTypes[0] = String.class; Object[] paramValues = new Object[1]; paramValues[0] = SSLRandomSeed; Class<?> clazz = Class.forName("org.apache.tomcat.jni.SSL"); Method method = clazz.getMethod(methodName, paramTypes); method.invoke(null, paramValues); methodName = "initialize"; paramValues[0] = "on".equalsIgnoreCase(SSLEngine) ? null : SSLEngine; method = clazz.getMethod(methodName, paramTypes); method.invoke(null, paramValues); sslAvailable = true; }	private static void terminateAPR() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException { String methodName = "terminate"; Method method = Class.forName("org.apache.tomcat.jni.Library").getMethod(methodName, (Class[]) null); method.invoke(null, (Object[]) null); aprAvailable = false; aprInitialized = false; sslInitialized = false; sslAvailable = false; }	@Override public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) { synchronized (lock) { init(); if (aprAvailable) { try { initializeSSL(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.info(sm.getString("aprListener.sslInit")); } } } } else if (Lifecycle.AFTER_DESTROY_EVENT.equals(event.getType())) { synchronized (lock) { if (!aprAvailable) { return; } try { terminateAPR(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.info(sm.getString("aprListener.aprDestroy")); } } } }	public void setSSLEngine(String SSLEngine) { AprLifecycleListener.SSLEngine = SSLEngine; }	public void setSSLRandomSeed(String SSLRandomSeed) { AprLifecycleListener.SSLRandomSeed = SSLRandomSeed; }
@Override public URL getResource(String path) throws MalformedURLException { if (path == null || !path.startsWith("/") && GET_RESOURCE_REQUIRE_SLASH) throw new MalformedURLException(sm.getString("applicationContext.requestDispatcher.iae", path)); String normPath = RequestUtil.normalize(path); if (normPath == null) return (null); DirContext resources = context.getResources(); if (resources != null) { String fullPath = context.getPath() + normPath; String hostName = context.getParent().getName(); try { resources.lookup(path); return new URL("jndi", "", 0, getJNDIUri(hostName, fullPath), new DirContextURLStreamHandler(resources)); } catch (NamingException e) { // Ignore } catch (Exception e) { log(sm.getString("applicationContext.lookup.error", path, getContextPath()), e); } } return (null); }
public String createStandardContext(String parent, String path, String docBase, boolean xmlValidation, boolean xmlNamespaceAware, boolean tldValidation, boolean tldNamespaceAware) throws Exception { StandardContext context = new StandardContext(); path = getPathStr(path); context.setPath(path); context.setDocBase(docBase); context.setXmlValidation(xmlValidation); context.setXmlNamespaceAware(xmlNamespaceAware); context.setTldValidation(tldValidation); context.setTldNamespaceAware(tldNamespaceAware); ContextConfig contextConfig = new ContextConfig(); context.addLifecycleListener(contextConfig); ObjectName pname = new ObjectName(parent); ObjectName deployer = new ObjectName(pname.getDomain() + ":type=Deployer,host=" + pname.getKeyProperty("host")); if (mserver.isRegistered(deployer)) { String contextName = context.getName(); mserver.invoke(deployer, "addServiced", new Object[] { contextName }, new String[] { "java.lang.String" }); String configPath = (String) mserver.getAttribute(deployer, "configBaseName"); String baseName = context.getBaseName(); File configFile = new File(new File(configPath), baseName + ".xml"); context.setConfigFile(configFile.toURI().toURL()); mserver.invoke(deployer, "manageApp", new Object[] { context }, new String[] { "org.apache.catalina.Context" }); mserver.invoke(deployer, "removeServiced", new Object[] { contextName }, new String[] { "java.lang.String" }); } else { log.warn("Deployer not found for " + pname.getKeyProperty("host")); Service service = getService(pname); Engine engine = (Engine) service.getContainer(); Host host = (Host) engine.findChild(pname.getKeyProperty("host")); host.addChild(context); } return context.getObjectName().toString(); }
public static InputStream getInputStream(String fname, JarFile jarFile, JspCompilationContext ctxt, ErrorDispatcher err) throws JasperException, IOException { InputStream in = null; if (jarFile != null) { String jarEntryName = fname.substring(1, fname.length()); ZipEntry jarEntry = jarFile.getEntry(jarEntryName); if (jarEntry == null) { err.jspError("jsp.error.file.not.found", fname); } in = jarFile.getInputStream(jarEntry); } else { in = ctxt.getResourceAsStream(fname); } if (in == null) { err.jspError("jsp.error.file.not.found", fname); } return in; }	public Class<?> load() throws JasperException { try { getJspLoader(); String name = getFQCN(); servletClass = jspLoader.loadClass(name); } catch (ClassNotFoundException cex) { throw new JasperException(Localizer.getMessage("jsp.error.unable.load"), cex); } catch (Exception ex) { throw new JasperException(Localizer.getMessage("jsp.error.unable.compile"), ex); } removed = 0; return servletClass; }
private boolean isCometSupported() { String protocol = getTomcatInstance().getConnector().getProtocolHandlerClassName(); if (protocol.indexOf("Nio") == -1 && protocol.indexOf("Apr") == -1) { return false; } else { return true; } }	@Override public boolean event(org.apache.coyote.Request req, org.apache.coyote.Response res, SocketStatus status) { Request request = (Request) req.getNote(ADAPTER_NOTES); Response response = (Response) res.getNote(ADAPTER_NOTES); if (request.getWrapper() == null) { return false; } boolean error = false; boolean read = false; try { if (status == SocketStatus.OPEN) { if (response.isClosed()) { // The event has been closed asynchronously, so call end instead of request.getEvent().setEventType(CometEvent.EventType.END); request.getEvent().setEventSubType(null); } else { try { if (request.read()) { read = true; } } catch (IOException e) { error = true; } if (read) { request.getEvent().setEventType(CometEvent.EventType.READ); request.getEvent().setEventSubType(null); } else if (error) { request.getEvent().setEventType(CometEvent.EventType.ERROR); request.getEvent().setEventSubType(CometEvent.EventSubType.CLIENT_DISCONNECT); } else { request.getEvent().setEventType(CometEvent.EventType.END); request.getEvent().setEventSubType(null); } } } else if (status == SocketStatus.DISCONNECT) { request.getEvent().setEventType(CometEvent.EventType.ERROR); request.getEvent().setEventSubType(CometEvent.EventSubType.CLIENT_DISCONNECT); error = true; } else if (status == SocketStatus.ERROR) { request.getEvent().setEventType(CometEvent.EventType.ERROR); request.getEvent().setEventSubType(CometEvent.EventSubType.IOEXCEPTION); error = true; } else if (status == SocketStatus.STOP) { request.getEvent().setEventType(CometEvent.EventType.END); request.getEvent().setEventSubType(CometEvent.EventSubType.SERVER_SHUTDOWN); } else if (status == SocketStatus.TIMEOUT) { if (response.isClosed()) { // The event has been closed asynchronously, so call end instead of request.getEvent().setEventType(CometEvent.EventType.END); request.getEvent().setEventSubType(null); } else { request.getEvent().setEventType(CometEvent.EventType.ERROR); request.getEvent().setEventSubType(CometEvent.EventSubType.TIMEOUT); } } req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName()); connector.getService().getContainer().getPipeline().getFirst().event(request, response, request.getEvent()); if (!error && !response.isClosed() && (request.getAttribute(RequestDispatcher.ERROR_EXCEPTION) != null)) { // An unexpected exception occurred while processing the event, so request.getEvent().setEventType(CometEvent.EventType.ERROR); request.getEvent().setEventSubType(null); error = true; connector.getService().getContainer().getPipeline().getFirst().event(request, response, request.getEvent()); } if (response.isClosed() || !request.isComet()) { if (status == SocketStatus.OPEN && request.getEvent().getEventType() != EventType.END) { request.getEvent().setEventType(CometEvent.EventType.END); request.getEvent().setEventSubType(null); error = true; connector.getService().getContainer().getPipeline().getFirst().event(request, response, request.getEvent()); } res.action(ActionCode.COMET_END, null); } else if (!error && read && request.getAvailable()) { // If this was a read and not all bytes have been read, or if no data request.getEvent().setEventType(CometEvent.EventType.ERROR); request.getEvent().setEventSubType(CometEvent.EventSubType.IOEXCEPTION); error = true; connector.getService().getContainer().getPipeline().getFirst().event(request, response, request.getEvent()); } return (!error); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); if (!(t instanceof IOException)) { log.error(sm.getString("coyoteAdapter.service"), t); } error = true; return false; } finally { req.getRequestProcessor().setWorkerThreadName(null); if (error || response.isClosed() || !request.isComet()) { request.recycle(); request.setFilterChain(null); response.recycle(); } } }	private boolean isCometSupported() { String protocol = getTomcatInstance().getConnector().getProtocolHandlerClassName(); if (protocol.indexOf("Nio") == -1 && protocol.indexOf("Apr") == -1) { return false; } else { return true; } }	@Override public void service(org.apache.coyote.Request req, org.apache.coyote.Response res) throws Exception { Request request = (Request) req.getNote(ADAPTER_NOTES); Response response = (Response) res.getNote(ADAPTER_NOTES); if (request == null) { request = connector.createRequest(); request.setCoyoteRequest(req); response = connector.createResponse(); response.setCoyoteResponse(res); request.setResponse(response); response.setRequest(request); req.setNote(ADAPTER_NOTES, request); res.setNote(ADAPTER_NOTES, response); req.getParameters().setQueryStringEncoding(connector.getURIEncoding()); } if (connector.getXpoweredBy()) { response.addHeader("X-Powered-By", POWERED_BY); } boolean comet = false; boolean async = false; try { // Parse and set Catalina and configuration specific req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName()); boolean postParseSuccess = postParseRequest(req, request, res, response); if (postParseSuccess) { request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported()); connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); if (request.isComet()) { if (!response.isClosed() && !response.isError()) { if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) { if (event(req, res, SocketStatus.OPEN)) { comet = true; res.action(ActionCode.COMET_BEGIN, null); } } else { comet = true; res.action(ActionCode.COMET_BEGIN, null); } } else { // Clear the filter chain, as otherwise it will not be reset elsewhere request.setFilterChain(null); } } } AsyncContextImpl asyncConImpl = (AsyncContextImpl) request.getAsyncContext(); if (asyncConImpl != null) { async = true; } else if (!comet) { request.finishRequest(); response.finishResponse(); if (postParseSuccess) { // Log only if processing was invoked. ((Context) request.getMappingData().context).logAccess(request, response, System.currentTimeMillis() - req.getStartTime(), false); } req.action(ActionCode.POST_REQUEST, null); } } catch (IOException e) { // Ignore } finally { req.getRequestProcessor().setWorkerThreadName(null); if (!comet && !async) { request.recycle(); response.recycle(); } else { // Clear converters so that the minimum amount of memory request.clearEncoders(); response.clearEncoders(); } } }	@Test public void testSimpleCometClient() throws Exception { if (!isCometSupported()) { return; } Tomcat tomcat = getTomcatInstance(); Context root = tomcat.addContext("", TEMP_DIR); Tomcat.addServlet(root, "comet", new SimpleCometServlet()); root.addServletMapping("/", "comet"); tomcat.start(); final Socket socket = SocketFactory.getDefault().createSocket("localhost", getPort()); socket.setSoTimeout(60000); final OutputStream os = socket.getOutputStream(); String requestLine = "POST http://localhost:" + getPort() + "/ HTTP/1.1\r\n"; os.write(requestLine.getBytes()); os.write("transfer-encoding: chunked\r\n".getBytes()); os.write("\r\n".getBytes()); PingWriterThread writeThread = new PingWriterThread(4, os); writeThread.start(); socket.setSoTimeout(25000); InputStream is = socket.getInputStream(); ResponseReaderThread readThread = new ResponseReaderThread(is); readThread.start(); readThread.join(); os.close(); is.close(); String[] response = readThread.getResponse().split("\r\n"); assertEquals("HTTP/1.1 200 OK", response[0]); assertEquals("Server: Apache-Coyote/1.1", response[1]); assertTrue(response[2].startsWith("Set-Cookie: JSESSIONID=")); assertEquals("Content-Type: text/plain;charset=ISO-8859-1", response[3]); assertEquals("Transfer-Encoding: chunked", response[4]); assertTrue(response[5].startsWith("Date: ")); assertEquals("", response[6]); assertEquals("7", response[7]); assertEquals("BEGIN", response[8]); assertEquals("", response[9]); assertEquals("17", response[10]); assertEquals("Client: READ: 4 bytes", response[11]); assertEquals("", response[12]); assertEquals("17", response[13]); assertEquals("Client: READ: 4 bytes", response[14]); assertEquals("", response[15]); assertEquals("17", response[16]); assertEquals("Client: READ: 4 bytes", response[17]); assertEquals("", response[18]); assertEquals("17", response[19]); assertEquals("Client: READ: 4 bytes", response[20]); assertEquals("", response[21]); assertEquals("d", response[22]); assertEquals("Client: END", response[23]); assertEquals("", response[24]); assertEquals("0", response[25]); assertEquals(26, response.length); }
/** * Convert (if necessary) and return the absolute URL that represents the * resource referenced by this possibly relative URL. If this URL is * already absolute, return it unchanged. * * @param location URL to be (possibly) converted and then returned * * @exception IllegalArgumentException if a MalformedURLException is * thrown when converting the relative URL to an absolute one */ protected String toAbsolute(String location) { if (location == null) return (location); boolean leadingSlash = location.startsWith("/"); if (leadingSlash || !hasScheme(location)) { redirectURLCC.recycle(); String scheme = request.getScheme(); String name = request.getServerName(); int port = request.getServerPort(); try { redirectURLCC.append(scheme, 0, scheme.length()); redirectURLCC.append("://", 0, 3); redirectURLCC.append(name, 0, name.length()); if ((scheme.equals("http") && port != 80) || (scheme.equals("https") && port != 443)) { redirectURLCC.append(':'); String portS = port + ""; redirectURLCC.append(portS, 0, portS.length()); } if (!leadingSlash) { String relativePath = request.getDecodedRequestURI(); int pos = relativePath.lastIndexOf('/'); relativePath = relativePath.substring(0, pos); String encodedURI = null; final String frelativePath = relativePath; if (SecurityUtil.isPackageProtectionEnabled() ){ try{ encodedURI = AccessController.doPrivileged( new PrivilegedExceptionAction<String>(){ @Override } } } } } } }
@Override public void sendRedirect(String location) throws IOException { if (isCommitted()) throw new IllegalStateException(sm.getString("coyoteResponse.sendRedirect.ise")); if (included) return; resetBuffer(true); try { String absolute = toAbsolute(location); setStatus(SC_FOUND); setHeader("Location", absolute); PrintWriter writer = getWriter(); writer.print(sm.getString("coyoteResponse.sendRedirect.note", RequestUtil.filter(absolute))); flushBuffer(); } catch (IllegalArgumentException e) { setStatus(SC_NOT_FOUND); } setSuspended(true); }
@Override protected Log getLogger() { return log; }	@Override public void doFilterEvent(CometEvent event, CometFilterChain chain) throws IOException, ServletException { processCometEvent(event.getHttpServletRequest().getRemoteHost(), event, chain); }
protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException { if (Boolean.TRUE == req.getAttribute("dispatch")) { log.info("Received dispatch, completing on the worker thread."); log.info("After complete called started:"+req.isAsyncStarted()); resp.getWriter().write("Async dispatch worked:+"+System.currentTimeMillis()+"\n"); req.getAsyncContext().complete(); } else { resp.setContentType("text/plain"); final AsyncContext actx = req.startAsync(); actx.setTimeout(Long.MAX_VALUE); Runnable run = new Runnable() { @Override } } }
@Override public void event(Request request, Response response, CometEvent event) throws IOException, ServletException { Throwable throwable = null; long t1 = System.currentTimeMillis(); StandardWrapper wrapper = (StandardWrapper) getContainer(); Servlet servlet = null; Context context = (Context) wrapper.getParent(); boolean unavailable = !context.getAvailable() || wrapper.isUnavailable(); try { if (!unavailable) { servlet = wrapper.allocate(); } } catch (UnavailableException e) { // The response is already committed, so it's not possible to do anything } catch (ServletException e) { container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), StandardWrapper.getRootCause(e)); throwable = e; exception(request, response, e); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), e); throwable = e; exception(request, response, e); servlet = null; } MessageBytes requestPathMB = request.getRequestPathMB(); request.setAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR, DispatcherType.REQUEST); request.setAttribute(ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB); ApplicationFilterChain filterChain = (ApplicationFilterChain) request.getFilterChain(); try { if ((servlet != null) && (filterChain != null)) { if (context.getSwallowOutput()) { try { SystemLogHandler.startCapture(); filterChain.doFilterEvent(request.getEvent()); } finally { String log = SystemLogHandler.stopCapture(); if (log != null && log.length() > 0) { context.getLogger().info(log); } } } else { filterChain.doFilterEvent(request.getEvent()); } } } catch (ClientAbortException e) { throwable = e; exception(request, response, e); } catch (IOException e) { container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName(), context.getName()), e); throwable = e; exception(request, response, e); } catch (UnavailableException e) { container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName(), context.getName()), e); // Do not save exception in 'throwable', because we // do not want to do exception(request, response, e) processing } catch (ServletException e) { Throwable rootCause = StandardWrapper.getRootCause(e); if (!(rootCause instanceof ClientAbortException)) { container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot", wrapper.getName(), context.getName(), e.getMessage()), rootCause); } throwable = e; exception(request, response, e); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName(), context.getName()), e); throwable = e; exception(request, response, e); } if (filterChain != null) { filterChain.reuse(); } try { if (servlet != null) { wrapper.deallocate(servlet); } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString("standardWrapper.deallocateException", wrapper.getName()), e); if (throwable == null) { throwable = e; exception(request, response, e); } } try { if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) { wrapper.unload(); } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString("standardWrapper.unloadException", wrapper.getName()), e); if (throwable == null) { throwable = e; exception(request, response, e); } } long t2 = System.currentTimeMillis(); long time = t2 - t1; processingTime += time; if (time > maxTime) maxTime = time; if (time < minTime) minTime = time; }
@Override public void stopInternal() { releaseConnectionLatch(); if (!paused) { pause(); } if (running) { running = false; unlockAccept(); for (int i = 0; i < acceptors.length; i++) { long s = System.currentTimeMillis() + 30000; while (acceptors[i].isAlive()) { try { acceptors[i].interrupt(); acceptors[i].join(1000); } catch (InterruptedException e) { // Ignore } if (System.currentTimeMillis() >= s) { log.warn(sm.getString("endpoint.warn.unlockAcceptorFailed", acceptors[i].getName())); if (serverSock != 0) { Socket.shutdown(serverSock, Socket.APR_SHUTDOWN_READ); serverSock = 0; } } } } for (int i = 0; i < pollers.length; i++) { try { pollers[i].destroy(); } catch (Exception e) { // Ignore } } pollers = null; for (int i = 0; i < cometPollers.length; i++) { try { cometPollers[i].destroy(); } catch (Exception e) { // Ignore } } cometPollers = null; if (useSendfile) { for (int i = 0; i < sendfiles.length; i++) { try { sendfiles[i].destroy(); } catch (Exception e) { // Ignore } } sendfiles = null; } } shutdownExecutor(); }
protected void parseHost(MessageBytes valueMB) { if (valueMB == null || valueMB.isNull()) { request.setServerPort(request.getLocalPort()); try { request.serverName().duplicate(request.localName()); } catch (IOException e) { response.setStatus(400); adapter.log(request, response, 0); error = true; } return; } ByteChunk valueBC = valueMB.getByteChunk(); byte[] valueB = valueBC.getBytes(); int valueL = valueBC.getLength(); int valueS = valueBC.getStart(); int colonPos = -1; if (hostNameC.length < valueL) { hostNameC = new char[valueL]; } boolean ipv6 = (valueB[valueS] == '['); boolean bracketClosed = false; for (int i = 0; i < valueL; i++) { char b = (char) valueB[i + valueS]; hostNameC[i] = b; if (b == ']') { bracketClosed = true; } else if (b == ':') { if (!ipv6 || bracketClosed) { colonPos = i; break; } } } if (colonPos < 0) { if (request.scheme().equalsIgnoreCase("https")) { request.setServerPort(443); } else { request.setServerPort(80); } request.serverName().setChars(hostNameC, 0, valueL); } else { request.serverName().setChars(hostNameC, 0, colonPos); int port = 0; int mult = 1; for (int i = valueL - 1; i > colonPos; i--) { int charValue = HexUtils.getDec(valueB[i + valueS]); if (charValue == -1) { error = true; response.setStatus(400); adapter.log(request, response, 0); break; } port = port + (charValue * mult); mult = 10 * mult; } request.setServerPort(port); } }	protected void parseHost(MessageBytes valueMB) { if (valueMB == null || valueMB.isNull()) { // HTTP/1.0 // If no host header, use the port info from the endpoint // The host will be obtained lazily from the socket if required request.setServerPort(endpoint.getPort()); return; } ByteChunk valueBC = valueMB.getByteChunk(); byte[] valueB = valueBC.getBytes(); int valueL = valueBC.getLength(); int valueS = valueBC.getStart(); int colonPos = -1; if (hostNameC.length < valueL) { hostNameC = new char[valueL]; } boolean ipv6 = (valueB[valueS] == '['); boolean bracketClosed = false; for (int i = 0; i < valueL; i++) { char b = (char) valueB[i + valueS]; hostNameC[i] = b; if (b == ']') { bracketClosed = true; } else if (b == ':') { if (!ipv6 || bracketClosed) { colonPos = i; break; } } } if (colonPos < 0) { if (!endpoint.isSSLEnabled()) { request.setServerPort(80); } else { request.setServerPort(443); } request.serverName().setChars(hostNameC, 0, valueL); } else { request.serverName().setChars(hostNameC, 0, colonPos); int port = 0; int mult = 1; for (int i = valueL - 1; i > colonPos; i--) { int charValue = HexUtils.getDec(valueB[i + valueS]); if (charValue == -1 || charValue > 9) { error = true; response.setStatus(400); adapter.log(request, response, 0); break; } port = port + (charValue * mult); mult = 10 * mult; } request.setServerPort(port); } }	protected void prepareRequest() { byte methodCode = requestHeaderMessage.getByte(); if (methodCode != Constants.SC_M_JK_STORED) { String methodName = Constants.getMethodForCode(methodCode - 1); request.method().setString(methodName); } requestHeaderMessage.getBytes(request.protocol()); requestHeaderMessage.getBytes(request.requestURI()); requestHeaderMessage.getBytes(request.remoteAddr()); requestHeaderMessage.getBytes(request.remoteHost()); requestHeaderMessage.getBytes(request.localName()); request.setLocalPort(requestHeaderMessage.getInt()); boolean isSSL = requestHeaderMessage.getByte() != 0; if (isSSL) { request.scheme().setString("https"); } MimeHeaders headers = request.getMimeHeaders(); int hCount = requestHeaderMessage.getInt(); for (int i = 0; i < hCount; i++) { String hName = null; // Header names are encoded as either an integer code starting // with 0xA0, or as a normal string (in which case the first int isc = requestHeaderMessage.peekInt(); int hId = isc & 0xFF; MessageBytes vMB = null; isc &= 0xFF00; if (0xA000 == isc) { requestHeaderMessage.getInt(); hName = Constants.getHeaderForCode(hId - 1); vMB = headers.addValue(hName); } else { // reset hId -- if the header currently being read // happens to be 7 or 8 bytes long, the code below // will think it's the content-type header or the // content-length header - SC_REQ_CONTENT_TYPE=7, // SC_REQ_CONTENT_LENGTH=8 - leading to unexpected hId = -1; requestHeaderMessage.getBytes(tmpMB); ByteChunk bc = tmpMB.getByteChunk(); vMB = headers.addValue(bc.getBuffer(), bc.getStart(), bc.getLength()); } requestHeaderMessage.getBytes(vMB); if (hId == Constants.SC_REQ_CONTENT_LENGTH || (hId == -1 && tmpMB.equalsIgnoreCase("Content-Length"))) { long cl = vMB.getLong(); if (cl < Integer.MAX_VALUE) request.setContentLength((int) cl); } else if (hId == Constants.SC_REQ_CONTENT_TYPE || (hId == -1 && tmpMB.equalsIgnoreCase("Content-Type"))) { ByteChunk bchunk = vMB.getByteChunk(); request.contentType().setBytes(bchunk.getBytes(), bchunk.getOffset(), bchunk.getLength()); } } boolean secret = false; byte attributeCode; while ((attributeCode = requestHeaderMessage.getByte()) != Constants.SC_A_ARE_DONE) { switch(attributeCode) { case Constants.SC_A_REQ_ATTRIBUTE: requestHeaderMessage.getBytes(tmpMB); String n = tmpMB.toString(); requestHeaderMessage.getBytes(tmpMB); String v = tmpMB.toString(); if (n.equals(Constants.SC_A_REQ_REMOTE_PORT)) { try { request.setRemotePort(Integer.parseInt(v)); } catch (NumberFormatException nfe) { // Ignore invalid value } } else { request.setAttribute(n, v); } break; case Constants.SC_A_CONTEXT: requestHeaderMessage.getBytes(tmpMB); break; case Constants.SC_A_SERVLET_PATH: requestHeaderMessage.getBytes(tmpMB); break; case Constants.SC_A_REMOTE_USER: if (tomcatAuthentication) { requestHeaderMessage.getBytes(tmpMB); } else { requestHeaderMessage.getBytes(request.getRemoteUser()); } break; case Constants.SC_A_AUTH_TYPE: if (tomcatAuthentication) { requestHeaderMessage.getBytes(tmpMB); } else { requestHeaderMessage.getBytes(request.getAuthType()); } break; case Constants.SC_A_QUERY_STRING: requestHeaderMessage.getBytes(request.queryString()); break; case Constants.SC_A_JVM_ROUTE: requestHeaderMessage.getBytes(request.instanceId()); break; case Constants.SC_A_SSL_CERT: request.scheme().setString("https"); requestHeaderMessage.getBytes(certificates); break; case Constants.SC_A_SSL_CIPHER: request.scheme().setString("https"); requestHeaderMessage.getBytes(tmpMB); request.setAttribute(SSLSupport.CIPHER_SUITE_KEY, tmpMB.toString()); break; case Constants.SC_A_SSL_SESSION: request.scheme().setString("https"); requestHeaderMessage.getBytes(tmpMB); request.setAttribute(SSLSupport.SESSION_ID_KEY, tmpMB.toString()); break; case Constants.SC_A_SSL_KEY_SIZE: request.setAttribute(SSLSupport.KEY_SIZE_KEY, Integer.valueOf(requestHeaderMessage.getInt())); break; case Constants.SC_A_STORED_METHOD: requestHeaderMessage.getBytes(request.method()); break; case Constants.SC_A_SECRET: requestHeaderMessage.getBytes(tmpMB); if (requiredSecret != null) { secret = true; if (!tmpMB.equals(requiredSecret)) { response.setStatus(403); adapter.log(request, response, 0); error = true; } } break; default: break; } } if ((requiredSecret != null) && !secret) { response.setStatus(403); adapter.log(request, response, 0); error = true; } ByteChunk uriBC = request.requestURI().getByteChunk(); if (uriBC.startsWithIgnoreCase("http", 0)) { int pos = uriBC.indexOf("://", 0, 3, 4); int uriBCStart = uriBC.getStart(); int slashPos = -1; if (pos != -1) { byte[] uriB = uriBC.getBytes(); slashPos = uriBC.indexOf('/', pos + 3); if (slashPos == -1) { slashPos = uriBC.getLength(); request.requestURI().setBytes(uriB, uriBCStart + pos + 1, 1); } else { request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos); } MessageBytes hostMB = headers.setValue("host"); hostMB.setBytes(uriB, uriBCStart + pos + 3, slashPos - pos - 3); } } MessageBytes valueMB = request.getMimeHeaders().getValue("host"); parseHost(valueMB); }	protected void prepareRequest() { http11 = true; http09 = false; contentDelimitation = false; expectation = false; prepareRequestInternal(); if (endpoint.isSSLEnabled()) { request.scheme().setString("https"); } MessageBytes protocolMB = request.protocol(); if (protocolMB.equals(Constants.HTTP_11)) { http11 = true; protocolMB.setString(Constants.HTTP_11); } else if (protocolMB.equals(Constants.HTTP_10)) { http11 = false; keepAlive = false; protocolMB.setString(Constants.HTTP_10); } else if (protocolMB.equals("")) { http09 = true; http11 = false; keepAlive = false; } else { http11 = false; error = true; if (getLog().isDebugEnabled()) { getLog().debug(sm.getString("http11processor.request.prepare") + " Unsupported HTTP version \"" + protocolMB + "\""); } response.setStatus(505); adapter.log(request, response, 0); } MessageBytes methodMB = request.method(); if (methodMB.equals(Constants.GET)) { methodMB.setString(Constants.GET); } else if (methodMB.equals(Constants.POST)) { methodMB.setString(Constants.POST); } MimeHeaders headers = request.getMimeHeaders(); MessageBytes connectionValueMB = headers.getValue("connection"); if (connectionValueMB != null) { ByteChunk connectionValueBC = connectionValueMB.getByteChunk(); if (findBytes(connectionValueBC, Constants.CLOSE_BYTES) != -1) { keepAlive = false; } else if (findBytes(connectionValueBC, Constants.KEEPALIVE_BYTES) != -1) { keepAlive = true; } } MessageBytes expectMB = null; if (http11) expectMB = headers.getValue("expect"); if ((expectMB != null) && (expectMB.indexOfIgnoreCase("100-continue", 0) != -1)) { getInputBuffer().setSwallowInput(false); expectation = true; } if ((restrictedUserAgents != null) && ((http11) || (keepAlive))) { MessageBytes userAgentValueMB = headers.getValue("user-agent"); if (userAgentValueMB != null) { String userAgentValue = userAgentValueMB.toString(); if (restrictedUserAgents != null && restrictedUserAgents.matcher(userAgentValue).matches()) { http11 = false; keepAlive = false; } } } ByteChunk uriBC = request.requestURI().getByteChunk(); if (uriBC.startsWithIgnoreCase("http", 0)) { int pos = uriBC.indexOf("://", 0, 3, 4); int uriBCStart = uriBC.getStart(); int slashPos = -1; if (pos != -1) { byte[] uriB = uriBC.getBytes(); slashPos = uriBC.indexOf('/', pos + 3); if (slashPos == -1) { slashPos = uriBC.getLength(); request.requestURI().setBytes(uriB, uriBCStart + pos + 1, 1); } else { request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos); } MessageBytes hostMB = headers.setValue("host"); hostMB.setBytes(uriB, uriBCStart + pos + 3, slashPos - pos - 3); } } InputFilter[] inputFilters = getInputBuffer().getFilters(); MessageBytes transferEncodingValueMB = null; if (http11) transferEncodingValueMB = headers.getValue("transfer-encoding"); if (transferEncodingValueMB != null) { String transferEncodingValue = transferEncodingValueMB.toString(); int startPos = 0; int commaPos = transferEncodingValue.indexOf(','); String encodingName = null; while (commaPos != -1) { encodingName = transferEncodingValue.substring(startPos, commaPos).toLowerCase(Locale.ENGLISH).trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; response.setStatus(501); adapter.log(request, response, 0); } startPos = commaPos + 1; commaPos = transferEncodingValue.indexOf(',', startPos); } encodingName = transferEncodingValue.substring(startPos).toLowerCase(Locale.ENGLISH).trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; if (getLog().isDebugEnabled()) { getLog().debug(sm.getString("http11processor.request.prepare") + " Unsupported transfer encoding \"" + encodingName + "\""); } response.setStatus(501); adapter.log(request, response, 0); } } long contentLength = request.getContentLengthLong(); if (contentLength >= 0 && !contentDelimitation) { getInputBuffer().addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } MessageBytes valueMB = headers.getValue("host"); if (http11 && (valueMB == null)) { error = true; if (getLog().isDebugEnabled()) { getLog().debug(sm.getString("http11processor.request.prepare") + " host header missing"); } response.setStatus(400); adapter.log(request, response, 0); } parseHost(valueMB); if (!contentDelimitation) { // If there's no content length // (broken HTTP/1.0 or HTTP/1.1), assume getInputBuffer().addActiveFilter(inputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } if (endpoint.getUseSendfile()) { request.setAttribute("org.apache.tomcat.sendfile.support", Boolean.TRUE); } if (endpoint.getUseComet()) { request.setAttribute("org.apache.tomcat.comet.support", Boolean.TRUE); } if (endpoint.getUseCometTimeout()) { request.setAttribute("org.apache.tomcat.comet.timeout.support", Boolean.TRUE); } }	@Override public SocketState process(SocketWrapper<Long> socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); this.socket = socket; long socketRef = socket.getSocket().longValue(); Socket.setrbb(socketRef, inputBuffer); Socket.setsbb(socketRef, outputBuffer); boolean cping = false; error = false; boolean keptAlive = false; while (!error && !endpoint.isPaused()) { try { if (!readMessage(requestHeaderMessage, true, keptAlive)) { break; } // Check message type, process right away and break if int type = requestHeaderMessage.getByte(); if (type == Constants.JK_AJP13_CPING_REQUEST) { if (endpoint.isPaused()) { recycle(true); break; } cping = true; if (Socket.send(socketRef, pongMessageArray, 0, pongMessageArray.length) < 0) { error = true; } continue; } else if (type != Constants.JK_AJP13_FORWARD_REQUEST) { if (log.isDebugEnabled()) { log.debug("Unexpected message: " + type); } error = true; break; } keptAlive = true; request.setStartTime(System.currentTimeMillis()); } catch (IOException e) { error = true; break; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.header.error"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.request.prepare"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } } if (!cping && endpoint.isPaused()) { response.setStatus(503); adapter.log(request, response, 0); error = true; } cping = false; if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("ajpprocessor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (isAsync() && !error) { break; } if (!finished) { try { finish(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); error = true; } } if (error) { response.setStatus(500); } request.updateCounters(); rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); recycle(false); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (!error && !endpoint.isPaused()) { if (isAsync()) { return SocketState.LONG; } else { return SocketState.OPEN; } } else { return SocketState.CLOSED; } }	@Override public SocketState process(SocketWrapper<NioChannel> socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); this.socket = socket.getSocket(); long soTimeout = endpoint.getSoTimeout(); boolean cping = false; error = false; while (!error && !endpoint.isPaused()) { try { int bytesRead = readMessage(requestHeaderMessage, false); if (bytesRead == 0) { break; } if (keepAliveTimeout > 0) { socket.setTimeout(soTimeout); } // Check message type, process right away and break if int type = requestHeaderMessage.getByte(); if (type == Constants.JK_AJP13_CPING_REQUEST) { if (endpoint.isPaused()) { recycle(true); break; } cping = true; try { output(pongMessageArray, 0, pongMessageArray.length); } catch (IOException e) { error = true; } recycle(false); continue; } else if (type != Constants.JK_AJP13_FORWARD_REQUEST) { if (log.isDebugEnabled()) { log.debug("Unexpected message: " + type); } error = true; recycle(true); break; } request.setStartTime(System.currentTimeMillis()); } catch (IOException e) { error = true; break; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.header.error"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.request.prepare"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } } if (!cping && endpoint.isPaused()) { response.setStatus(503); adapter.log(request, response, 0); error = true; } cping = false; if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("ajpprocessor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (isAsync() && !error) { break; } if (!finished) { try { finish(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); error = true; } } if (error) { response.setStatus(500); } request.updateCounters(); rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); if (keepAliveTimeout > 0) { socket.setTimeout(keepAliveTimeout); } recycle(false); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (!error && !endpoint.isPaused()) { if (isAsync()) { return SocketState.LONG; } else { return SocketState.OPEN; } } else { return SocketState.CLOSED; } }	@Override public SocketState process(SocketWrapper<S> socketWrapper) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); setSocketWrapper(socketWrapper); getInputBuffer().init(socketWrapper, endpoint); getOutputBuffer().init(socketWrapper, endpoint); error = false; keepAlive = true; comet = false; openSocket = false; sendfileInProgress = false; readComplete = true; if (endpoint.getUsePolling()) { keptAlive = false; } else { keptAlive = socketWrapper.isKeptAlive(); } if (disableKeepAlive()) { socketWrapper.setKeepAliveLeft(0); } while (!error && keepAlive && !comet && !isAsync() && !endpoint.isPaused()) { try { setRequestLineReadTimeout(); if (!getInputBuffer().parseRequestLine(keptAlive)) { if (handleIncompleteRequestLineRead()) { break; } } if (endpoint.isPaused()) { response.setStatus(503); adapter.log(request, response, 0); error = true; } else { request.setStartTime(System.currentTimeMillis()); keptAlive = true; if (!getInputBuffer().parseHeaders()) { // We've read part of the request, don't recycle it openSocket = true; readComplete = false; break; } if (!disableUploadTimeout) { setSocketTimeout(connectionUploadTimeout); } } } catch (IOException e) { if (getLog().isDebugEnabled()) { getLog().debug(sm.getString("http11processor.header.parse"), e); } error = true; break; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); if (getLog().isDebugEnabled()) { getLog().debug(sm.getString("http11processor.header.parse"), t); } response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); if (getLog().isDebugEnabled()) { getLog().debug(sm.getString("http11processor.request.prepare"), t); } response.setStatus(400); adapter.log(request, response, 0); error = true; } } if (maxKeepAliveRequests == 1) { keepAlive = false; } else if (maxKeepAliveRequests > 0 && socketWrapper.decrementKeepAlive() <= 0) { keepAlive = false; } if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); if (keepAlive && !error) { error = response.getErrorException() != null || (!isAsync() && statusDropsConnection(response.getStatus())); } setCometTimeouts(socketWrapper); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getLog().error(sm.getString("http11processor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT); if (!isAsync() && !comet) { if (error) { // If we know we are closing the connection, don't drain // input. This way uploading a 100GB file doesn't tie up the getInputBuffer().setSwallowInput(false); } endRequest(); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT); if (error) { response.setStatus(500); } request.updateCounters(); if (!isAsync() && !comet || error) { getInputBuffer().nextRequest(); getOutputBuffer().nextRequest(); } if (!disableUploadTimeout) { setSocketTimeout(endpoint.getSoTimeout()); } rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); if (breakKeepAliveLoop(socketWrapper)) { break; } } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (error || endpoint.isPaused()) { return SocketState.CLOSED; } else if (isAsync() || comet) { return SocketState.LONG; } else { if (sendfileInProgress) { return SocketState.SENDFILE; } else { if (openSocket) { if (readComplete) { return SocketState.OPEN; } else { return SocketState.LONG; } } else { return SocketState.CLOSED; } } } }	@Override public SocketState process(SocketWrapper<Socket> socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); this.socket = socket; input = socket.getSocket().getInputStream(); output = socket.getSocket().getOutputStream(); int soTimeout = -1; if (keepAliveTimeout > 0) { soTimeout = socket.getSocket().getSoTimeout(); } boolean cping = false; error = false; while (!error && !endpoint.isPaused()) { try { if (keepAliveTimeout > 0) { socket.getSocket().setSoTimeout(keepAliveTimeout); } if (!readMessage(requestHeaderMessage)) { break; } if (keepAliveTimeout > 0) { socket.getSocket().setSoTimeout(soTimeout); } // Check message type, process right away and break if int type = requestHeaderMessage.getByte(); if (type == Constants.JK_AJP13_CPING_REQUEST) { if (endpoint.isPaused()) { recycle(true); break; } cping = true; try { output.write(pongMessageArray); } catch (IOException e) { error = true; } continue; } else if (type != Constants.JK_AJP13_FORWARD_REQUEST) { if (log.isDebugEnabled()) { log.debug("Unexpected message: " + type); } error = true; break; } request.setStartTime(System.currentTimeMillis()); } catch (IOException e) { error = true; break; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.header.error"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.request.prepare"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } } if (!cping && endpoint.isPaused()) { response.setStatus(503); adapter.log(request, response, 0); error = true; } cping = false; if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("ajpprocessor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (isAsync() && !error) { break; } if (!finished) { try { finish(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); error = true; } } if (error) { response.setStatus(500); } request.updateCounters(); rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); recycle(false); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (isAsync() && !error && !endpoint.isPaused()) { return SocketState.LONG; } else { input = null; output = null; return SocketState.CLOSED; } }	public void endRequest() { try { getInputBuffer().endRequest(); } catch (IOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getLog().error(sm.getString("http11processor.request.finish"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } try { getOutputBuffer().endRequest(); } catch (IOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getLog().error(sm.getString("http11processor.response.finish"), t); error = true; } }	@Override public void log(org.apache.coyote.Request req, org.apache.coyote.Response res, long time) { Request request = (Request) req.getNote(ADAPTER_NOTES); Response response = (Response) res.getNote(ADAPTER_NOTES); boolean create = false; if (request == null) { create = true; request = connector.createRequest(); request.setCoyoteRequest(req); response = connector.createResponse(); response.setCoyoteResponse(res); request.setResponse(response); response.setRequest(request); req.setNote(ADAPTER_NOTES, request); res.setNote(ADAPTER_NOTES, response); req.getParameters().setQueryStringEncoding(connector.getURIEncoding()); } try { // Log at the lowest level available. logAccess() will be boolean logged = false; if (request.mappingData != null) { if (request.mappingData.context != null) { logged = true; ((Context) request.mappingData.context).logAccess(request, response, time, true); } else if (request.mappingData.host != null) { logged = true; ((Host) request.mappingData.host).logAccess(request, response, time, true); } } if (!logged) { connector.getService().getContainer().logAccess(request, response, time, true); } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.warn(sm.getString("coyoteAdapter.accesslogFail"), t); } if (create) { request.recycle(); response.recycle(); } }
public static int postUrl(byte[] body, String path, ByteChunk out, Map<String, List<String>> reqHead, Map<String, List<String>> resHead) throws IOException { URL url = new URL(path); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setDoOutput(true); connection.setReadTimeout(1000000); if (reqHead != null) { for (Map.Entry<String, List<String>> entry : reqHead.entrySet()) { StringBuilder valueList = new StringBuilder(); for (String value : entry.getValue()) { if (valueList.length() > 0) { valueList.append(','); } valueList.append(value); } connection.setRequestProperty(entry.getKey(), valueList.toString()); } } connection.connect(); OutputStream os = null; try { os = connection.getOutputStream(); if (body != null) { os.write(body, 0, body.length); } } finally { if (os != null) { try { os.close(); } catch (IOException ioe) { // Ignore } } } int rc = connection.getResponseCode(); if (resHead != null) { Map<String, List<String>> head = connection.getHeaderFields(); resHead.putAll(head); } if (rc == HttpServletResponse.SC_OK) { InputStream is = connection.getInputStream(); BufferedInputStream bis = null; try { bis = new BufferedInputStream(is); byte[] buf = new byte[2048]; int rd = 0; while ((rd = bis.read(buf)) > 0) { out.append(buf, 0, rd); } } finally { if (bis != null) { try { bis.close(); } catch (IOException e) { // Ignore } } } } return rc; }	@Before public void setUp() throws Exception { System.setProperty("java.util.logging.manager", "org.apache.juli.ClassLoaderLogManager"); System.setProperty("java.util.logging.config.file", new File(getBuildDirectory(), "conf/logging.properties").toString()); tempDir = new File(System.getProperty("tomcat.test.temp", "output/tmp")); if (!tempDir.mkdirs() && !tempDir.isDirectory()) { fail("Unable to create temporary directory for test"); } System.setProperty("catalina.base", tempDir.getAbsolutePath()); CatalinaProperties.getProperty("foo"); File appBase = new File(tempDir, "webapps"); if (!appBase.exists() && !appBase.mkdir()) { fail("Unable to create appBase for test"); } tomcat = new Tomcat(); String protocol = getProtocol(); Connector connector = new Connector(protocol); // If each test is running on same port - they connector.setPort(getNextPort()); connector.setAttribute("connectionTimeout", "3000"); tomcat.getService().addConnector(connector); tomcat.setConnector(connector); if (protocol.contains("Apr")) { StandardServer server = (StandardServer) tomcat.getServer(); AprLifecycleListener listener = new AprLifecycleListener(); listener.setSSLRandomSeed("/dev/urandom"); server.addLifecycleListener(listener); connector.setAttribute("pollerThreadCount", Integer.valueOf(1)); } tomcat.setBaseDir(tempDir.getAbsolutePath()); tomcat.getHost().setAppBase(appBase.getAbsolutePath()); accessLogEnabled = Boolean.parseBoolean(System.getProperty("tomcat.test.accesslog", "false")); if (accessLogEnabled) { AccessLogValve alv = new AccessLogValve(); alv.setDirectory(getBuildDirectory() + "/logs"); alv.setPattern("%h %l %u %t \"%r\" %s %b %I %D"); tomcat.getHost().getPipeline().addValve(alv); } }
@Override public PrivateKey getPrivateKey(String alias) { return delegate.getPrivateKey(alias); }	@Override public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) { return delegate.chooseClientAlias(keyType, issuers, socket); }
@Override public Object invoke(ELContext context, Object base, Object method, Class<?>[] paramTypes, Object[] params) { if (context == null) { throw new NullPointerException(); } if (base == null || method == null) { return null; } ExpressionFactory factory = ExpressionFactory.newInstance(); String methodName = (String) factory.coerceToType(method, String.class); Method matchingMethod = null; Class<?> clazz = base.getClass(); if (paramTypes != null) { try { matchingMethod = getMethod(clazz, clazz.getMethod(methodName, paramTypes)); } catch (NoSuchMethodException e) { throw new MethodNotFoundException(e); } } else { int paramCount = 0; if (params != null) { paramCount = params.length; } Method[] methods = clazz.getMethods(); for (Method m : methods) { if (methodName.equals(m.getName()) && m.getParameterTypes().length == paramCount) { matchingMethod = getMethod(clazz, m); break; } if (m.isVarArgs()) { matchingMethod = getMethod(clazz, m); } } if (matchingMethod == null) { throw new MethodNotFoundException("Unable to find method [" + methodName + "] with [" + paramCount + "] parameters"); } } Class<?>[] parameterTypes = matchingMethod.getParameterTypes(); Object[] parameters = null; if (parameterTypes.length > 0) { parameters = new Object[parameterTypes.length]; @SuppressWarnings("null") int paramCount = params.length; if (matchingMethod.isVarArgs()) { int varArgIndex = parameterTypes.length - 1; for (int i = 0; (i < varArgIndex - 1); i++) { parameters[i] = factory.coerceToType(params[i], parameterTypes[i]); } Class<?> varArgClass = parameterTypes[varArgIndex].getComponentType(); for (int i = (varArgIndex); i < paramCount; i++) { Object varargs = Array.newInstance(parameterTypes[paramCount], (paramCount - varArgIndex)); Array.set(varargs, i, factory.coerceToType(params[i], varArgClass)); parameters[varArgIndex] = varargs; } } else { parameters = new Object[parameterTypes.length]; for (int i = 0; i < parameterTypes.length; i++) { parameters[i] = factory.coerceToType(params[i], parameterTypes[i]); } } } Object result = null; try { result = matchingMethod.invoke(base, parameters); } catch (IllegalArgumentException e) { throw new ELException(e); } catch (IllegalAccessException e) { throw new ELException(e); } catch (InvocationTargetException e) { throw new ELException(e.getCause()); } context.setPropertyResolved(true); return result; }
public static String expand(Host host, URL war, String pathname) throws IOException { File docBase = new File(host.getAppBaseFile(), pathname); if (docBase.exists()) { return (docBase.getAbsolutePath()); } docBase.mkdir(); String canonicalDocBasePrefix = docBase.getCanonicalPath(); if (!canonicalDocBasePrefix.endsWith(File.separator)) { canonicalDocBasePrefix += File.separator; } JarURLConnection juc = (JarURLConnection) war.openConnection(); juc.setUseCaches(false); JarFile jarFile = null; InputStream input = null; boolean success = false; try { jarFile = juc.getJarFile(); Enumeration<JarEntry> jarEntries = jarFile.entries(); while (jarEntries.hasMoreElements()) { JarEntry jarEntry = jarEntries.nextElement(); String name = jarEntry.getName(); File expandedFile = new File(docBase, name); if (!expandedFile.getCanonicalPath().startsWith(canonicalDocBasePrefix)) { throw new IllegalArgumentException(sm.getString("expandWar.illegalPath", war, name, expandedFile.getCanonicalPath(), canonicalDocBasePrefix)); } int last = name.lastIndexOf('/'); if (last >= 0) { File parent = new File(docBase, name.substring(0, last)); if (!parent.mkdirs() && !parent.isDirectory()) { throw new IOException(sm.getString("expandWar.createFailed", parent)); } } if (name.endsWith("/")) { continue; } input = jarFile.getInputStream(jarEntry); expand(input, expandedFile); long lastModified = jarEntry.getTime(); if ((lastModified != -1) && (lastModified != 0)) { expandedFile.setLastModified(lastModified); } input.close(); input = null; } success = true; } catch (IOException e) { throw e; } finally { if (!success) { // If something went wrong, delete expanded dir to keep things deleteDir(docBase); } if (input != null) { try { input.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } input = null; } if (jarFile != null) { try { jarFile.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } jarFile = null; } } return (docBase.getAbsolutePath()); }
@Override public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) { ClassLoader loader = Thread.currentThread().getContextClassLoader(); try { // Use the system classloader as the victim for all this Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); if (driverManagerProtection) { DriverManager.getDrivers(); } if (appContextProtection) { ImageIO.getCacheDirectory(); } if (awtThreadProtection) { java.awt.Toolkit.getDefaultToolkit(); } if (gcDaemonProtection) { try { Class<?> clazz = Class.forName("sun.misc.GC"); Method method = clazz.getDeclaredMethod("requestLatency", new Class[] { long.class }); method.invoke(null, Long.valueOf(3600000)); } catch (ClassNotFoundException e) { if (System.getProperty("java.vendor").startsWith("Sun")) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } else { log.debug(sm.getString("jreLeakListener.gcDaemonFail"), e); } } catch (SecurityException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (NoSuchMethodException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (IllegalArgumentException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (IllegalAccessException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (InvocationTargetException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } } if (securityPolicyProtection) { try { Class<?> policyClass = Class.forName("javax.security.auth.Policy"); Method method = policyClass.getMethod("getPolicy"); method.invoke(null); } catch (ClassNotFoundException e) { // Ignore. The class is deprecated. } catch (SecurityException e) { // Ignore. Don't need call to getPolicy() to be // successful, just need to trigger static initializer. } catch (NoSuchMethodException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (IllegalArgumentException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (IllegalAccessException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (InvocationTargetException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } } if (securityLoginConfigurationProtection) { try { Class.forName("javax.security.auth.login.Configuration", true, ClassLoader.getSystemClassLoader()); } catch (ClassNotFoundException e) { // Ignore } } if (tokenPollerProtection) { java.security.Security.getProviders(); } if (urlCacheProtection) { try { // Doesn't matter that this JAR doesn't exist - just as URL url = new URL("jar:file://dummy.jar!/"); URLConnection uConn = url.openConnection(); uConn.setDefaultUseCaches(false); } catch (MalformedURLException e) { log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"), e); } catch (IOException e) { log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"), e); } } if (xmlParsingProtection) { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); try { factory.newDocumentBuilder(); } catch (ParserConfigurationException e) { log.error(sm.getString("jreLeakListener.xmlParseFail"), e); } } if (ldapPoolProtection) { try { Class.forName("com.sun.jndi.ldap.LdapPoolManager"); } catch (ClassNotFoundException e) { if (System.getProperty("java.vendor").startsWith("Sun")) { log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"), e); } else { log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"), e); } } } } finally { Thread.currentThread().setContextClassLoader(loader); } } }	public boolean isGcDaemonProtection() { return gcDaemonProtection; }
public String getSslImplemenationName() { return sslImplemenationName; }	@Override public void init() throws Exception { // SSL implementation needs to be in place before end point is sslImplementation = SSLImplementation.getInstance(sslImplemenationName); super.init(); }	public void testCustomSslImplementation() throws Exception { TesterSupport.configureClientSsl(); Tomcat tomcat = getTomcatInstance(); Connector connector = tomcat.getConnector(); if (connector.getProtocolHandlerClassName().contains("Apr")) { return; } connector.setProperty("sslImplemenationName", "org.apache.tomcat.util.net.jsse.TesterBug50640SslImpl"); connector.setProperty(TesterBug50640SslImpl.PROPERTY_NAME, TesterBug50640SslImpl.PROPERTY_VALUE); connector.setProperty("sslProtocol", "tls"); File keystoreFile = new File("test/org/apache/tomcat/util/net/localhost.jks"); connector.setAttribute("keystoreFile", keystoreFile.getAbsolutePath()); connector.setSecure(true); connector.setProperty("SSLEnabled", "true"); File appDir = new File(getBuildDirectory(), "webapps/examples"); tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = getUrl("https://localhost:" + getPort() + "/examples/servlets/servlet/HelloWorldExample"); assertTrue(res.toString().indexOf("<h1>Hello World!</h1>") > 0); }
protected Log getLog() { return log; }
protected void finish() throws IOException { if (!response.isCommitted()) { try { prepareResponse(); } catch (IOException e) { error = true; } } if (finished) return; finished = true; if (error) { output(endAndCloseMessageArray, 0, endAndCloseMessageArray.length); } else { output(endMessageArray, 0, endMessageArray.length); } }	@Override public SocketState process(SocketWrapper<Long> socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); this.socket = socket; long socketRef = socket.getSocket().longValue(); Socket.setrbb(socketRef, inputBuffer); Socket.setsbb(socketRef, outputBuffer); error = false; boolean keptAlive = false; while (!error && !endpoint.isPaused()) { try { if (!readMessage(requestHeaderMessage, true, keptAlive)) { break; } // Check message type, process right away and break if int type = requestHeaderMessage.getByte(); if (type == Constants.JK_AJP13_CPING_REQUEST) { if (Socket.send(socketRef, pongMessageArray, 0, pongMessageArray.length) < 0) { error = true; } continue; } else if (type != Constants.JK_AJP13_FORWARD_REQUEST) { if (log.isDebugEnabled()) { log.debug("Unexpected message: " + type); } continue; } keptAlive = true; request.setStartTime(System.currentTimeMillis()); } catch (IOException e) { error = true; break; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.header.error"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.request.prepare"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } } if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("ajpprocessor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (isAsync() && !error) { break; } if (!finished) { try { finish(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); error = true; } } if (error) { response.setStatus(500); } request.updateCounters(); rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); recycle(false); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (error || endpoint.isPaused()) { return SocketState.CLOSED; } else if (isAsync()) { return SocketState.LONG; } else { return SocketState.OPEN; } }	@Override public SocketState process(SocketWrapper<NioChannel> socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); this.socket = socket.getSocket(); long soTimeout = endpoint.getSoTimeout(); error = false; while (!error && !endpoint.isPaused()) { try { int bytesRead = readMessage(requestHeaderMessage, false); if (bytesRead == 0) { break; } if (keepAliveTimeout > 0) { socket.setTimeout(soTimeout); } // Check message type, process right away and break if int type = requestHeaderMessage.getByte(); if (type == Constants.JK_AJP13_CPING_REQUEST) { try { output(pongMessageArray, 0, pongMessageArray.length); } catch (IOException e) { error = true; } recycle(false); continue; } else if (type != Constants.JK_AJP13_FORWARD_REQUEST) { if (log.isDebugEnabled()) { log.debug("Unexpected message: " + type); } recycle(true); continue; } request.setStartTime(System.currentTimeMillis()); } catch (IOException e) { error = true; break; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.header.error"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.request.prepare"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } } if (endpoint.isPaused()) { response.setStatus(503); adapter.log(request, response, 0); error = true; } if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("ajpprocessor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (isAsync() && !error) { break; } if (!finished) { try { finish(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); error = true; } } if (error) { response.setStatus(500); } request.updateCounters(); rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); if (keepAliveTimeout > 0) { socket.setTimeout(keepAliveTimeout); } recycle(false); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (!error && !endpoint.isPaused()) { if (isAsync()) { return SocketState.LONG; } else { return SocketState.OPEN; } } else { return SocketState.CLOSED; } }	@Override public SocketState process(SocketWrapper<Socket> socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); this.socket = socket; input = socket.getSocket().getInputStream(); output = socket.getSocket().getOutputStream(); int soTimeout = -1; if (keepAliveTimeout > 0) { soTimeout = socket.getSocket().getSoTimeout(); } error = false; while (!error && !endpoint.isPaused()) { try { if (keepAliveTimeout > 0) { socket.getSocket().setSoTimeout(keepAliveTimeout); } if (!readMessage(requestHeaderMessage)) { break; } if (keepAliveTimeout > 0) { socket.getSocket().setSoTimeout(soTimeout); } // Check message type, process right away and break if int type = requestHeaderMessage.getByte(); if (type == Constants.JK_AJP13_CPING_REQUEST) { try { output.write(pongMessageArray); } catch (IOException e) { error = true; } continue; } else if (type != Constants.JK_AJP13_FORWARD_REQUEST) { if (log.isDebugEnabled()) { log.debug("Unexpected message: " + type); } continue; } request.setStartTime(System.currentTimeMillis()); } catch (IOException e) { error = true; break; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.header.error"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.request.prepare"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } } if (endpoint.isPaused()) { response.setStatus(503); adapter.log(request, response, 0); error = true; } if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("ajpprocessor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (isAsync() && !error) { break; } if (!finished) { try { finish(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); error = true; } } if (error) { response.setStatus(500); } request.updateCounters(); rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); recycle(false); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (isAsync() && !error && !endpoint.isPaused()) { return SocketState.LONG; } else { input = null; output = null; return SocketState.CLOSED; } }
@Override public boolean authenticate(Request request, HttpServletResponse response, LoginConfig config) throws IOException { Session session = null; Principal principal = request.getUserPrincipal(); String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (principal != null) { if (log.isDebugEnabled()) log.debug("Already authenticated '" + principal.getName() + "'"); if (ssoId != null) associate(ssoId, request.getSessionInternal(true)); return (true); } if (ssoId != null) { if (log.isDebugEnabled()) log.debug("SSO Id " + ssoId + " set; attempting " + "reauthentication"); if (reauthenticateFromSSO(ssoId, request)) return true; } if (!cache) { session = request.getSessionInternal(true); if (log.isDebugEnabled()) log.debug("Checking for reauthenticate in session " + session); String username = (String) session.getNote(Constants.SESS_USERNAME_NOTE); String password = (String) session.getNote(Constants.SESS_PASSWORD_NOTE); if ((username != null) && (password != null)) { if (log.isDebugEnabled()) log.debug("Reauthenticating username '" + username + "'"); principal = context.getRealm().authenticate(username, password); if (principal != null) { session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal); if (!matchRequest(request)) { register(request, response, principal, Constants.FORM_METHOD, username, password); return (true); } } if (log.isDebugEnabled()) log.debug("Reauthentication failed, proceed normally"); } } if (matchRequest(request)) { session = request.getSessionInternal(true); if (log.isDebugEnabled()) log.debug("Restore request from session '" + session.getIdInternal() + "'"); principal = (Principal) session.getNote(Constants.FORM_PRINCIPAL_NOTE); register(request, response, principal, Constants.FORM_METHOD, (String) session.getNote(Constants.SESS_USERNAME_NOTE), (String) session.getNote(Constants.SESS_PASSWORD_NOTE)); if (cache) { session.removeNote(Constants.SESS_USERNAME_NOTE); session.removeNote(Constants.SESS_PASSWORD_NOTE); } if (restoreRequest(request, session)) { if (log.isDebugEnabled()) log.debug("Proceed to restored request"); return (true); } else { if (log.isDebugEnabled()) log.debug("Restore of original request failed"); response.sendError(HttpServletResponse.SC_BAD_REQUEST); return (false); } } MessageBytes uriMB = MessageBytes.newInstance(); CharChunk uriCC = uriMB.getCharChunk(); uriCC.setLimit(-1); String contextPath = request.getContextPath(); String requestURI = request.getDecodedRequestURI(); boolean loginAction = requestURI.startsWith(contextPath) && requestURI.endsWith(Constants.FORM_ACTION); if (!loginAction) { session = request.getSessionInternal(true); if (log.isDebugEnabled()) log.debug("Save request in session '" + session.getIdInternal() + "'"); try { saveRequest(request, session); } catch (IOException ioe) { log.debug("Request body too big to save during authentication"); response.sendError(HttpServletResponse.SC_FORBIDDEN, sm.getString("authenticator.requestBodyTooBig")); return (false); } forwardToLoginPage(request, response, config); return (false); } // Yes -- Acknowledge the request, validate the specified credentials request.getResponse().sendAcknowledgement(); Realm realm = context.getRealm(); if (characterEncoding != null) { request.setCharacterEncoding(characterEncoding); } String username = request.getParameter(Constants.FORM_USERNAME); String password = request.getParameter(Constants.FORM_PASSWORD); if (log.isDebugEnabled()) log.debug("Authenticating username '" + username + "'"); principal = realm.authenticate(username, password); if (principal == null) { forwardToErrorPage(request, response, config); return (false); } if (log.isDebugEnabled()) log.debug("Authentication of '" + username + "' was successful"); if (session == null) session = request.getSessionInternal(false); if (session == null) { if (containerLog.isDebugEnabled()) containerLog.debug("User took so long to log on the session expired"); if (landingPage == null) { response.sendError(HttpServletResponse.SC_REQUEST_TIMEOUT, sm.getString("authenticator.sessionExpired")); } else { // Make the authenticator think the user originally requested String uri = request.getContextPath() + landingPage; SavedRequest saved = new SavedRequest(); saved.setRequestURI(uri); request.getSessionInternal(true).setNote(Constants.FORM_REQUEST_NOTE, saved); response.sendRedirect(response.encodeRedirectURL(uri)); } return (false); } session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal); session.setNote(Constants.SESS_USERNAME_NOTE, username); session.setNote(Constants.SESS_PASSWORD_NOTE, password); // Redirect the user to the original request URI (which will cause requestURI = savedRequestURL(session); if (log.isDebugEnabled()) log.debug("Redirecting to original '" + requestURI + "'"); if (requestURI == null) if (landingPage == null) { response.sendError(HttpServletResponse.SC_BAD_REQUEST, sm.getString("authenticator.formlogin")); } else { // Make the authenticator think the user originally requested String uri = request.getContextPath() + landingPage; SavedRequest saved = new SavedRequest(); saved.setRequestURI(uri); session.setNote(Constants.FORM_REQUEST_NOTE, saved); response.sendRedirect(response.encodeRedirectURL(uri)); } else response.sendRedirect(response.encodeRedirectURL(requestURI)); return (false); }
@Override public void invoke(Request request, Response response) throws IOException, ServletException { if (log.isDebugEnabled()) log.debug("Security checking request " + request.getMethod() + " " + request.getRequestURI()); LoginConfig config = this.context.getLoginConfig(); if (cache) { Principal principal = request.getUserPrincipal(); if (principal == null) { Session session = request.getSessionInternal(false); if (session != null) { principal = session.getPrincipal(); if (principal != null) { if (log.isDebugEnabled()) log.debug("We have cached auth type " + session.getAuthType() + " for principal " + session.getPrincipal()); request.setAuthType(session.getAuthType()); request.setUserPrincipal(principal); } } } } // Special handling for form-based logins to deal with the case // where the login form (and therefore the "j_security_check" URI String contextPath = this.context.getPath(); String requestURI = request.getDecodedRequestURI(); if (requestURI.startsWith(contextPath) && requestURI.endsWith(Constants.FORM_ACTION)) { if (!authenticate(request, response, config)) { if (log.isDebugEnabled()) log.debug(" Failed authenticate() test ??" + requestURI); return; } } // The Servlet may specify security constraints through annotations. Wrapper wrapper = (Wrapper) request.getMappingData().wrapper; if (wrapper != null) { wrapper.servletSecurityAnnotationScan(); } Realm realm = this.context.getRealm(); SecurityConstraint[] constraints = realm.findSecurityConstraints(request, this.context); if (constraints == null && !context.getPreemptiveAuthentication()) { if (log.isDebugEnabled()) log.debug(" Not subject to any constraint"); getNext().invoke(request, response); return; } if (constraints != null && disableProxyCaching && !request.isSecure() && !"POST".equalsIgnoreCase(request.getMethod())) { if (securePagesWithPragma) { response.setHeader("Pragma", "No-cache"); response.setHeader("Cache-Control", "no-cache"); } else { response.setHeader("Cache-Control", "private"); } response.setHeader("Expires", DATE_ONE); } int i; if (constraints != null) { if (log.isDebugEnabled()) { log.debug(" Calling hasUserDataPermission()"); } if (!realm.hasUserDataPermission(request, response, constraints)) { if (log.isDebugEnabled()) { log.debug(" Failed hasUserDataPermission() test"); } return; } } // Since authenticate modifies the response on failure, boolean authRequired; if (constraints == null) { authRequired = false; } else { authRequired = true; for (i = 0; i < constraints.length && authRequired; i++) { if (!constraints[i].getAuthConstraint()) { authRequired = false; } else if (!constraints[i].getAllRoles()) { String[] roles = constraints[i].findAuthRoles(); if (roles == null || roles.length == 0) { authRequired = false; } } } } if (!authRequired && context.getPreemptiveAuthentication()) { authRequired = request.getCoyoteRequest().getMimeHeaders().getValue("authorization") != null; } if (!authRequired && context.getPreemptiveAuthentication()) { X509Certificate[] certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR); authRequired = certs != null && certs.length > 0; } if (authRequired) { if (log.isDebugEnabled()) { log.debug(" Calling authenticate()"); } if (!authenticate(request, response, config)) { if (log.isDebugEnabled()) { log.debug(" Failed authenticate() test"); } return; } } if (constraints != null) { if (log.isDebugEnabled()) { log.debug(" Calling accessControl()"); } if (!realm.hasResourcePermission(request, response, constraints, this.context)) { if (log.isDebugEnabled()) { log.debug(" Failed accessControl() test"); } return; } } if (log.isDebugEnabled()) { log.debug(" Successfully passed all security constraints"); } getNext().invoke(request, response); }
@Override protected synchronized void startInternal() throws LifecycleException { super.startInternal(); try { cluster.registerManager(this); CatalinaCluster catclust = cluster; LazyReplicatedMap map = new LazyReplicatedMap(this, catclust.getChannel(), DEFAULT_REPL_TIMEOUT, getMapName(), getClassLoaders()); map.setChannelSendOptions(mapSendOptions); this.sessions = map; } catch (Exception x) { log.error("Unable to start BackupManager", x); throw new LifecycleException("Failed to start BackupManager", x); } setState(LifecycleState.STARTING); }	protected void broadcast(int msgtype, boolean rpc) throws ChannelException { MapMessage msg = new MapMessage(this.mapContextName, msgtype, false, null, null, null, channel.getLocalMember(false), null); if (rpc) { Response[] resp = rpcChannel.send(channel.getMembers(), msg, RpcChannel.FIRST_REPLY, (channelSendOptions), rpcTimeout); for (int i = 0; i < resp.length; i++) { mapMemberAdded(resp[i].getSource()); messageReceived(resp[i].getMessage(), resp[i].getSource()); } } else { channel.send(channel.getMembers(), msg, channelSendOptions); } }	@Override public ClusterManager cloneFromTemplate() { BackupManager result = new BackupManager(); result.mExpireSessionsOnShutdown = mExpireSessionsOnShutdown; result.name = "Clone-from-" + name; result.cluster = cluster; result.notifyListenersOnReplication = notifyListenersOnReplication; result.mapSendOptions = mapSendOptions; result.maxActiveSessions = maxActiveSessions; return result; }	@Override public String[] getInvalidatedSessions() { return new String[0]; }
private File directory() { if (this.directory == null) { return (null); } if (this.directoryFile != null) { return (this.directoryFile); } File file = new File(this.directory); if (!file.isAbsolute()) { Container container = manager.getContainer(); if (container instanceof Context) { ServletContext servletContext = ((Context) container).getServletContext(); File work = (File) servletContext.getAttribute(ServletContext.TEMPDIR); file = new File(work, this.directory); } else { throw new IllegalArgumentException("Parent Container is not a Context"); } } if (!file.exists() || !file.isDirectory()) { file.delete(); file.mkdirs(); } this.directoryFile = file; return (file); }	private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); File foo = new File(docBase, "async"); if (!foo.exists() && !foo.mkdirs()) { fail("Unable to create async directory in docBase"); } Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); TimeoutServlet timeout = new TimeoutServlet(completeOnTimeout, dispatchUrl); Wrapper wrapper = Tomcat.addServlet(ctx, "time", timeout); wrapper.setAsyncSupported(true); ctx.addServletMapping("/async", "time"); if (dispatchUrl != null) { NonAsyncServlet nonAsync = new NonAsyncServlet(); Tomcat.addServlet(ctx, "nonasync", nonAsync); ctx.addServletMapping(dispatchUrl, "nonasync"); } ctx.addApplicationListener(TrackingRequestListener.class.getName()); TesterAccessLogValve alv = new TesterAccessLogValve(); ctx.getPipeline().addValve(alv); tomcat.start(); ByteChunk res = new ByteChunk(); try { getUrl("http://localhost:" + getPort() + "/async", res, null); } catch (IOException ioe) { // Ignore - expected for some error conditions } StringBuilder expected = new StringBuilder("requestInitialized-"); expected.append("TimeoutServletGet-onTimeout-"); if (completeOnTimeout) { if (dispatchUrl == null) { expected.append("onComplete-"); expected.append("requestDestroyed"); } else { // Error - no further output // There is no onComplete- since the complete event would be // fired during post processing but since there is an error that // never happens. } } else { if (dispatchUrl == null) { expected.append("onError-"); } else { expected.append("NonAsyncServletGet-"); } expected.append("onComplete-"); expected.append("requestDestroyed"); } assertEquals(expected.toString(), res.toString()); if (completeOnTimeout && dispatchUrl != null) { if (!isAccessLogEnabled()) { validateAccessLog(alv, 1, 500, 0, TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME); } } else { validateAccessLog(alv, 1, 200, TimeoutServlet.ASYNC_TIMEOUT, TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME); } }	private void postWorkDirectory() { String workDir = getWorkDir(); if (workDir == null || workDir.length() == 0) { String hostName = null; String engineName = null; String hostWorkDir = null; Container parentHost = getParent(); if (parentHost != null) { hostName = parentHost.getName(); if (parentHost instanceof StandardHost) { hostWorkDir = ((StandardHost) parentHost).getWorkDir(); } Container parentEngine = parentHost.getParent(); if (parentEngine != null) { engineName = parentEngine.getName(); } } if ((hostName == null) || (hostName.length() < 1)) hostName = "_"; if ((engineName == null) || (engineName.length() < 1)) engineName = "_"; String temp = getName(); if (temp.startsWith("/")) temp = temp.substring(1); temp = temp.replace('/', '_'); temp = temp.replace('\\', '_'); if (temp.length() < 1) temp = "_"; if (hostWorkDir != null) { workDir = hostWorkDir + File.separator + temp; } else { workDir = "work" + File.separator + engineName + File.separator + hostName + File.separator + temp; } setWorkDir(workDir); } File dir = new File(workDir); if (!dir.isAbsolute()) { File catalinaHome = engineBase(); String catalinaHomePath = null; try { catalinaHomePath = catalinaHome.getCanonicalPath(); dir = new File(catalinaHomePath, workDir); } catch (IOException e) { log.warn(sm.getString("standardContext.workCreateException", workDir, catalinaHomePath, getName()), e); } } if (!dir.exists() && !dir.mkdirs()) { log.warn(sm.getString("standardContext.workCreateFail", dir, getName())); } if (context == null) { getServletContext(); } context.setAttribute(ServletContext.TEMPDIR, dir); context.setAttributeReadOnly(ServletContext.TEMPDIR); }	private void setRepositories() throws IOException { if (!(container instanceof Context)) return; ServletContext servletContext = ((Context) container).getServletContext(); if (servletContext == null) return; loaderRepositories = new ArrayList<String>(); File workDir = (File) servletContext.getAttribute(ServletContext.TEMPDIR); if (workDir == null) { log.info("No work dir for " + servletContext); } if (log.isDebugEnabled() && workDir != null) log.debug(sm.getString("webappLoader.deploy", workDir.getAbsolutePath())); classLoader.setWorkDir(workDir); DirContext resources = container.getResources(); String classesPath = "/WEB-INF/classes"; DirContext classes = null; try { Object object = resources.lookup(classesPath); if (object instanceof DirContext) { classes = (DirContext) object; } } catch (NamingException e) { // Silent catch: it's valid that no /WEB-INF/classes collection // exists } if (classes != null) { File classRepository = null; String absoluteClassesPath = servletContext.getRealPath(classesPath); if (absoluteClassesPath != null) { classRepository = new File(absoluteClassesPath); } else { classRepository = new File(workDir, classesPath); if (!classRepository.isDirectory()) { if (!classRepository.mkdirs()) throw new IOException(sm.getString("webappLoader.mkdirFailure")); } if (!copyDir(classes, classRepository)) { throw new IOException(sm.getString("webappLoader.copyFailure")); } } if (log.isDebugEnabled()) log.debug(sm.getString("webappLoader.classDeploy", classesPath, classRepository.getAbsolutePath())); classLoader.addRepository(classesPath + "/", classRepository); loaderRepositories.add(classesPath + "/"); } String libPath = "/WEB-INF/lib"; classLoader.setJarPath(libPath); DirContext libDir = null; try { Object object = resources.lookup(libPath); if (object instanceof DirContext) libDir = (DirContext) object; } catch (NamingException e) { // Silent catch: it's valid that no /WEB-INF/lib collection // exists } if (libDir != null) { boolean copyJars = false; String absoluteLibPath = servletContext.getRealPath(libPath); File destDir = null; if (absoluteLibPath != null) { destDir = new File(absoluteLibPath); } else { copyJars = true; destDir = new File(workDir, libPath); if (!destDir.isDirectory()) { if (!destDir.mkdirs()) throw new IOException(sm.getString("webappLoader.mkdirFailure")); } } NamingEnumeration<NameClassPair> enumeration = null; try { enumeration = libDir.list(""); } catch (NamingException e) { IOException ioe = new IOException(sm.getString("webappLoader.namingFailure", libPath)); ioe.initCause(e); throw ioe; } while (enumeration.hasMoreElements()) { NameClassPair ncPair = enumeration.nextElement(); String filename = libPath + "/" + ncPair.getName(); if (!filename.endsWith(".jar")) continue; // Copy JAR in the work directory, always (the JAR file // would get locked otherwise, which would make it File destFile = new File(destDir, ncPair.getName()); if (log.isDebugEnabled()) log.debug(sm.getString("webappLoader.jarDeploy", filename, destFile.getAbsolutePath())); // Bug 45403 - Explicitly call lookup() on the name to check // that the resource is readable. We cannot use resources // returned by listBindings(), because that lists all of them, Object obj = null; try { obj = libDir.lookup(ncPair.getName()); } catch (NamingException e) { IOException ioe = new IOException(sm.getString("webappLoader.namingFailure", filename)); ioe.initCause(e); throw ioe; } if (!(obj instanceof Resource)) continue; Resource jarResource = (Resource) obj; if (copyJars) { if (!copy(jarResource.streamContent(), new FileOutputStream(destFile))) { throw new IOException(sm.getString("webappLoader.copyFailure")); } } try { JarFile jarFile = new JarFile(destFile); classLoader.addJar(filename, jarFile, destFile); } catch (Exception ex) { // Catch the exception if there is an empty jar file // Should ignore and continue loading other jar files // in the dir } loaderRepositories.add(filename); } } }	protected File getConfigBase(String hostName) { File configBase = new File(System.getProperty(Globals.CATALINA_BASE_PROP), "conf"); if (!configBase.exists()) { return null; } if (engine != null) { configBase = new File(configBase, engine.getName()); } if (installedHost != null) { configBase = new File(configBase, hostName); } if (!configBase.exists()) { if (!configBase.mkdirs()) { return null; } } return configBase; }	protected ResourceEntry findResourceInternal(String name, String path) { if (!started) { log.info(sm.getString("webappClassLoader.stopped", name)); return null; } if ((name == null) || (path == null)) return null; ResourceEntry entry = resourceEntries.get(name); if (entry != null) return entry; int contentLength = -1; InputStream binaryStream = null; int jarFilesLength = jarFiles.length; int repositoriesLength = repositories.length; int i; Resource resource = null; boolean fileNeedConvert = false; for (i = 0; (entry == null) && (i < repositoriesLength); i++) { try { String fullPath = repositories[i] + path; Object lookupResult = resources.lookup(fullPath); if (lookupResult instanceof Resource) { resource = (Resource) lookupResult; } // Note : Not getting an exception here means the resource was entry = findResourceInternal(files[i], path); ResourceAttributes attributes = (ResourceAttributes) resources.getAttributes(fullPath); contentLength = (int) attributes.getContentLength(); entry.lastModified = attributes.getLastModified(); if (resource != null) { try { binaryStream = resource.streamContent(); } catch (IOException e) { return null; } if (needConvert) { if (path.endsWith(".properties")) { fileNeedConvert = true; } } synchronized (allPermission) { int j; long[] result2 = new long[lastModifiedDates.length + 1]; for (j = 0; j < lastModifiedDates.length; j++) { result2[j] = lastModifiedDates[j]; } result2[lastModifiedDates.length] = entry.lastModified; lastModifiedDates = result2; String[] result = new String[paths.length + 1]; for (j = 0; j < paths.length; j++) { result[j] = paths[j]; } result[paths.length] = fullPath; paths = result; } } } catch (NamingException e) { // Ignore } } if ((entry == null) && (notFoundResources.containsKey(name))) return null; JarEntry jarEntry = null; synchronized (jarFiles) { try { if (!openJARs()) { return null; } for (i = 0; (entry == null) && (i < jarFilesLength); i++) { jarEntry = jarFiles[i].getJarEntry(path); if (jarEntry != null) { entry = new ResourceEntry(); try { entry.codeBase = getURL(jarRealFiles[i], false); String jarFakeUrl = getURI(jarRealFiles[i]).toString(); jarFakeUrl = "jar:" + jarFakeUrl + "!/" + path; entry.source = new URL(jarFakeUrl); entry.lastModified = jarRealFiles[i].lastModified(); } catch (MalformedURLException e) { return null; } contentLength = (int) jarEntry.getSize(); try { entry.manifest = jarFiles[i].getManifest(); binaryStream = jarFiles[i].getInputStream(jarEntry); } catch (IOException e) { return null; } if (antiJARLocking && !(path.endsWith(".class"))) { byte[] buf = new byte[1024]; File resourceFile = new File(loaderDir, jarEntry.getName()); if (!resourceFile.exists()) { Enumeration<JarEntry> entries = jarFiles[i].entries(); while (entries.hasMoreElements()) { JarEntry jarEntry2 = entries.nextElement(); if (!(jarEntry2.isDirectory()) && (!jarEntry2.getName().endsWith(".class"))) { resourceFile = new File(loaderDir, jarEntry2.getName()); try { if (!resourceFile.getCanonicalPath().startsWith(canonicalLoaderDir)) { throw new IllegalArgumentException(sm.getString("webappClassLoader.illegalJarPath", jarEntry2.getName())); } } catch (IOException ioe) { throw new IllegalArgumentException(sm.getString("webappClassLoader.validationErrorJarPath", jarEntry2.getName()), ioe); } resourceFile.getParentFile().mkdirs(); FileOutputStream os = null; InputStream is = null; try { is = jarFiles[i].getInputStream(jarEntry2); os = new FileOutputStream(resourceFile); while (true) { int n = is.read(buf); if (n <= 0) { break; } os.write(buf, 0, n); } resourceFile.setLastModified(jarEntry2.getTime()); } catch (IOException e) { // Ignore } finally { try { if (is != null) { is.close(); } } catch (IOException e) { // Ignore } try { if (os != null) { os.close(); } } catch (IOException e) { // Ignore } } } } } } } } if (entry == null) { synchronized (notFoundResources) { notFoundResources.put(name, name); } return null; } if (binaryStream != null) { byte[] binaryContent = new byte[contentLength]; int pos = 0; try { while (true) { int n = binaryStream.read(binaryContent, pos, binaryContent.length - pos); if (n <= 0) break; pos += n; } } catch (IOException e) { log.error(sm.getString("webappClassLoader.readError", name), e); return null; } if (fileNeedConvert) { // Workaround for certain files on platforms that use // EBCDIC encoding, when they are read through FileInputStream. // See commit message of rev.303915 for details String str = new String(binaryContent, 0, pos); try { binaryContent = str.getBytes(CHARSET_UTF8); } catch (Exception e) { return null; } } entry.binaryContent = binaryContent; if (jarEntry != null) { entry.certificates = jarEntry.getCertificates(); } } } finally { if (binaryStream != null) { try { binaryStream.close(); } catch (IOException e) { /* Ignore */ } } } } synchronized (resourceEntries) { // Ensures that all the threads which may be in a race to load // a particular class all end up with the same ResourceEntry ResourceEntry entry2 = resourceEntries.get(name); if (entry2 == null) { resourceEntries.put(name, entry); } else { entry = entry2; } } return entry; }	protected boolean makeOutputDir() { synchronized (outputDirLock) { File outDirFile = new File(outputDir); return (outDirFile.exists() || outDirFile.mkdirs()); } }	protected synchronized void open() { File dir = new File(directory); if (!dir.isAbsolute()) dir = new File(System.getProperty(Globals.CATALINA_BASE_PROP), directory); if (!dir.exists()) { if (!dir.mkdirs()) { log.error(sm.getString("accessLogValve.openDirFail", dir)); } } File pathname; if (rotatable) { pathname = new File(dir.getAbsoluteFile(), prefix + dateStamp + suffix); } else { pathname = new File(dir.getAbsoluteFile(), prefix + suffix); } File parent = pathname.getParentFile(); if (!parent.exists()) { if (!parent.mkdirs()) { log.error(sm.getString("accessLogValve.openDirFail", parent)); } } Charset charset = null; if (encoding != null) { try { charset = B2CConverter.getCharset(encoding); } catch (UnsupportedEncodingException ex) { log.error(sm.getString("accessLogValve.unsupportedEncoding", encoding), ex); } } if (charset == null) { charset = Charset.defaultCharset(); } try { writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(pathname, true), charset), 128000), false); currentLogFile = pathname; } catch (IOException e) { writer = null; currentLogFile = null; log.error(sm.getString("accessLogValve.openFail", pathname), e); } }	protected synchronized void deploy(PrintWriter writer, ContextName cn, String tag, boolean update, HttpServletRequest request, StringManager smClient) { if (debug >= 1) { log("deploy: Deploying web application '" + cn + "'"); } if (!validateContextName(cn, writer, smClient)) { return; } String name = cn.getName(); String baseName = cn.getBaseName(); String displayPath = cn.getDisplayName(); Context context = (Context) host.findChild(name); if (update) { if (context != null) { undeploy(writer, cn, smClient); } context = (Context) host.findChild(name); } if (context != null) { writer.println(smClient.getString("managerServlet.alreadyContext", displayPath)); return; } File deployedPath = deployed; if (tag != null) { deployedPath = new File(versioned, tag); if (!deployedPath.isDirectory() && !deployedPath.mkdirs()) { writer.println(smClient.getString("managerServlet.mkdirFail", deployedPath)); return; } } File localWar = new File(deployedPath, baseName + ".war"); if (debug >= 2) { log("Uploading WAR file to " + localWar); } try { if (!isServiced(name)) { addServiced(name); try { uploadWar(writer, request, localWar, smClient); if (tag != null) { deployedPath = deployed; File localWarCopy = new File(deployedPath, baseName + ".war"); copy(localWar, localWarCopy); localWar = localWarCopy; copy(localWar, new File(host.getAppBaseFile(), baseName + ".war")); } check(name); } finally { removeServiced(name); } } } catch (Exception e) { log("managerServlet.check[" + displayPath + "]", e); writer.println(smClient.getString("managerServlet.exception", e.toString())); return; } context = (Context) host.findChild(name); if (context != null && context.getConfigured()) { writer.println(smClient.getString("managerServlet.deployed", displayPath)); } else { writer.println(smClient.getString("managerServlet.deployFailed", displayPath)); } }	protected void deploy(PrintWriter writer, String config, ContextName cn, String war, boolean update, StringManager smClient) { if (config != null && config.length() == 0) { config = null; } if (war != null && war.length() == 0) { war = null; } if (debug >= 1) { if (config != null && config.length() > 0) { if (war != null) { log("install: Installing context configuration at '" + config + "' from '" + war + "'"); } else { log("install: Installing context configuration at '" + config + "'"); } } else { if (cn != null) { log("install: Installing web application '" + cn + "' from '" + war + "'"); } else { log("install: Installing web application from '" + war + "'"); } } } if (!validateContextName(cn, writer, smClient)) { return; } @SuppressWarnings("null") String name = cn.getName(); String baseName = cn.getBaseName(); String displayPath = cn.getDisplayName(); Context context = (Context) host.findChild(name); if (update) { if (context != null) { undeploy(writer, cn, smClient); } context = (Context) host.findChild(name); } if (context != null) { writer.println(smClient.getString("managerServlet.alreadyContext", displayPath)); return; } if (config != null && (config.startsWith("file:"))) { config = config.substring("file:".length()); } if (war != null && (war.startsWith("file:"))) { war = war.substring("file:".length()); } try { if (!isServiced(name)) { addServiced(name); try { if (config != null) { if (!configBase.isDirectory() && !configBase.mkdirs()) { writer.println(smClient.getString("managerServlet.mkdirFail", configBase)); return; } copy(new File(config), new File(configBase, baseName + ".xml")); } if (war != null) { if (war.endsWith(".war")) { copy(new File(war), new File(host.getAppBaseFile(), baseName + ".war")); } else { copy(new File(war), new File(host.getAppBaseFile(), baseName)); } } check(name); } finally { removeServiced(name); } } context = (Context) host.findChild(name); if (context != null && context.getConfigured() && context.getAvailable()) { writer.println(smClient.getString("managerServlet.deployed", displayPath)); } else if (context != null && !context.getAvailable()) { writer.println(smClient.getString("managerServlet.deployedButNotStarted", displayPath)); } else { writer.println(smClient.getString("managerServlet.deployFailed", displayPath)); } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log("ManagerServlet.install[" + displayPath + "]", t); writer.println(smClient.getString("managerServlet.exception", t.toString())); } }	protected void expandCGIScript() { StringBuilder srcPath = new StringBuilder(); StringBuilder destPath = new StringBuilder(); InputStream is = null; if (cgiPathPrefix == null) { srcPath.append(pathInfo); is = context.getResourceAsStream(srcPath.toString()); destPath.append(tmpDir); destPath.append(pathInfo); } else { srcPath.append(cgiPathPrefix); StringTokenizer pathWalker = new StringTokenizer(pathInfo, "/"); while (pathWalker.hasMoreElements() && (is == null)) { srcPath.append("/"); srcPath.append(pathWalker.nextElement()); is = context.getResourceAsStream(srcPath.toString()); } destPath.append(tmpDir); destPath.append("/"); destPath.append(srcPath); } if (is == null) { if (debug >= 2) { log("expandCGIScript: source '" + srcPath + "' not found"); } return; } File f = new File(destPath.toString()); if (f.exists()) { return; } String dirPath = destPath.toString().substring(0, destPath.toString().lastIndexOf("/")); File dir = new File(dirPath); if (!dir.mkdirs() && debug >= 2) { log("expandCGIScript: failed to create directories for '" + dir.getAbsolutePath() + "'"); return; } try { synchronized (expandFileLock) { if (f.exists()) { return; } if (!f.createNewFile()) { return; } FileOutputStream fos = new FileOutputStream(f); IOTools.flow(is, fos); is.close(); fos.close(); if (debug >= 2) { log("expandCGIScript: expanded '" + srcPath + "' to '" + destPath + "'"); } } } catch (IOException ioe) { if (f.exists()) { if (!f.delete() && debug >= 2) { log("expandCGIScript: failed to delete '" + f.getAbsolutePath() + "'"); } } } }	protected void openWriter() { File dir = new File(directory); if (!dir.exists() && !dir.mkdirs()) { reportError("Unable to create [" + dir + "]", null, ErrorManager.OPEN_FAILURE); writer = null; return; } writerLock.writeLock().lock(); try { File pathname = new File(dir.getAbsoluteFile(), prefix + (rotatable ? date : "") + suffix); File parent = pathname.getParentFile(); if (!parent.exists()) { if (!parent.mkdirs()) { reportError("Unable to create [" + parent + "]", null, ErrorManager.OPEN_FAILURE); writer = null; return; } } String encoding = getEncoding(); FileOutputStream fos = new FileOutputStream(pathname, true); OutputStream os = bufferSize > 0 ? new BufferedOutputStream(fos, bufferSize) : fos; writer = new PrintWriter((encoding != null) ? new OutputStreamWriter(os, encoding) : new OutputStreamWriter(os), false); writer.write(getFormatter().getHead(this)); } catch (Exception e) { reportError(null, e, ErrorManager.OPEN_FAILURE); writer = null; } finally { writerLock.writeLock().unlock(); } }	public static String expand(Host host, URL war, String pathname) throws IOException { File docBase = new File(host.getAppBaseFile(), pathname); if (docBase.exists()) { return (docBase.getAbsolutePath()); } docBase.mkdir(); String canonicalDocBasePrefix = docBase.getCanonicalPath(); if (!canonicalDocBasePrefix.endsWith(File.separator)) { canonicalDocBasePrefix += File.separator; } JarURLConnection juc = (JarURLConnection) war.openConnection(); juc.setUseCaches(false); JarFile jarFile = null; InputStream input = null; boolean success = false; try { jarFile = juc.getJarFile(); Enumeration<JarEntry> jarEntries = jarFile.entries(); while (jarEntries.hasMoreElements()) { JarEntry jarEntry = jarEntries.nextElement(); String name = jarEntry.getName(); File expandedFile = new File(docBase, name); if (!expandedFile.getCanonicalPath().startsWith(canonicalDocBasePrefix)) { throw new IllegalArgumentException(sm.getString("expandWar.illegalPath", war, name, expandedFile.getCanonicalPath(), canonicalDocBasePrefix)); } int last = name.lastIndexOf('/'); if (last >= 0) { File parent = new File(docBase, name.substring(0, last)); parent.mkdirs(); } if (name.endsWith("/")) { continue; } input = jarFile.getInputStream(jarEntry); expand(input, expandedFile); long lastModified = jarEntry.getTime(); if ((lastModified != -1) && (lastModified != 0)) { expandedFile.setLastModified(lastModified); } input.close(); input = null; } success = true; } catch (IOException e) { throw e; } finally { if (!success) { // If something went wrong, delete expanded dir to keep things deleteDir(docBase); } if (input != null) { try { input.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } input = null; } if (jarFile != null) { try { jarFile.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } jarFile = null; } } return (docBase.getAbsolutePath()); }	protected synchronized void add(PrintWriter writer, String name, String aliases, String appBase, boolean manager, boolean autoDeploy, boolean deployOnStartup, boolean deployXML, boolean unpackWARs, StringManager smClient) { if (debug >= 1) { log(sm.getString("hostManagerServlet.add", name)); } if ((name == null) || name.length() == 0) { writer.println(smClient.getString("hostManagerServlet.invalidHostName", name)); return; } if (engine.findChild(name) != null) { writer.println(smClient.getString("hostManagerServlet.alreadyHost", name)); return; } File appBaseFile = null; File file = null; if (appBase == null || appBase.length() == 0) { file = new File(name); } else { file = new File(appBase); } if (!file.isAbsolute()) file = new File(System.getProperty(Globals.CATALINA_BASE_PROP), file.getPath()); try { appBaseFile = file.getCanonicalFile(); } catch (IOException e) { appBaseFile = file; } if (!appBaseFile.exists()) { if (!appBaseFile.mkdirs()) { writer.println(smClient.getString("hostManagerServlet.appBaseCreateFail", appBaseFile.toString(), name)); return; } } File configBaseFile = getConfigBase(name); if (manager) { if (configBaseFile == null) { writer.println(smClient.getString("hostManagerServlet.configBaseCreateFail", name)); return; } InputStream is = null; OutputStream os = null; try { is = getServletContext().getResourceAsStream("/manager.xml"); os = new FileOutputStream(new File(configBaseFile, "manager.xml")); byte[] buffer = new byte[512]; int len = buffer.length; while (true) { len = is.read(buffer); if (len == -1) break; os.write(buffer, 0, len); } } catch (IOException e) { writer.println(smClient.getString("hostManagerServlet.managerXml")); return; } finally { if (is != null) { try { is.close(); } catch (IOException e) { // Ignore } } if (os != null) { try { os.close(); } catch (IOException e) { // Ignore } } } } StandardHost host = new StandardHost(); host.setAppBase(appBase); host.setName(name); host.addLifecycleListener(new HostConfig()); if ((aliases != null) && !("".equals(aliases))) { StringTokenizer tok = new StringTokenizer(aliases, ", "); while (tok.hasMoreTokens()) { host.addAlias(tok.nextToken()); } } host.setAutoDeploy(autoDeploy); host.setDeployOnStartup(deployOnStartup); host.setDeployXML(deployXML); host.setUnpackWARs(unpackWARs); try { engine.addChild(host); } catch (Exception e) { writer.println(smClient.getString("hostManagerServlet.exception", e.toString())); return; } host = (StandardHost) engine.findChild(name); if (host != null) { writer.println(smClient.getString("hostManagerServlet.add", name)); } else { writer.println(smClient.getString("hostManagerServlet.addFailed", name)); } }	@Override public void save(Session session) throws IOException { File file = file(session.getIdInternal()); if (file == null) { return; } if (manager.getContainer().getLogger().isDebugEnabled()) { manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".saving", session.getIdInternal(), file.getAbsolutePath())); } FileOutputStream fos = null; ObjectOutputStream oos = null; try { fos = new FileOutputStream(file.getAbsolutePath()); oos = new ObjectOutputStream(new BufferedOutputStream(fos)); } catch (IOException e) { if (fos != null) { try { fos.close(); } catch (IOException f) { // Ignore } } throw e; } try { ((StandardSession) session).writeObjectData(oos); } finally { oos.close(); } }	@Before public void setUp() throws Exception { System.setProperty("java.util.logging.manager", "org.apache.juli.ClassLoaderLogManager"); System.setProperty("java.util.logging.config.file", new File(getBuildDirectory(), "conf/logging.properties").toString()); tempDir = new File(System.getProperty("tomcat.test.temp", "output/tmp")); if (!tempDir.exists() && !tempDir.mkdirs()) { fail("Unable to create temporary directory for test"); } System.setProperty("catalina.base", tempDir.getAbsolutePath()); CatalinaProperties.getProperty("foo"); File appBase = new File(tempDir, "webapps"); if (!appBase.exists() && !appBase.mkdir()) { fail("Unable to create appBase for test"); } tomcat = new Tomcat(); String protocol = getProtocol(); Connector connector = new Connector(protocol); // If each test is running on same port - they connector.setPort(getNextPort()); connector.setAttribute("connectionTimeout", "3000"); tomcat.getService().addConnector(connector); tomcat.setConnector(connector); if (protocol.contains("Apr")) { StandardServer server = (StandardServer) tomcat.getServer(); AprLifecycleListener listener = new AprLifecycleListener(); listener.setSSLRandomSeed("/dev/urandom"); server.addLifecycleListener(listener); connector.setAttribute("pollerThreadCount", Integer.valueOf(1)); } tomcat.setBaseDir(tempDir.getAbsolutePath()); tomcat.getHost().setAppBase(appBase.getAbsolutePath()); accessLogEnabled = Boolean.parseBoolean(System.getProperty("tomcat.test.accesslog", "false")); if (accessLogEnabled) { AccessLogValve alv = new AccessLogValve(); alv.setDirectory(getBuildDirectory() + "/logs"); alv.setPattern("%h %l %u %t \"%r\" %s %b %I %D"); tomcat.getHost().getPipeline().addValve(alv); } }	public void start() { if (log.isDebugEnabled()) log.debug(sm.getString("hostConfig.start")); try { ObjectName hostON = host.getObjectName(); oname = new ObjectName(hostON.getDomain() + ":type=Deployer,host=" + host.getName()); Registry.getRegistry(null, null).registerComponent(this, oname, this.getClass().getName()); } catch (Exception e) { log.error(sm.getString("hostConfig.jmx.register", oname), e); } if (host.getCreateDirs()) { File[] dirs = new File[] { host.getAppBaseFile(), configBase() }; for (int i = 0; i < dirs.length; i++) { if ((!dirs[i].isDirectory()) && (!dirs[i].mkdirs())) { log.error(sm.getString("hostConfig.createDirs", dirs[i])); } } } if (!host.getAppBaseFile().isDirectory()) { log.error(sm.getString("hostConfig.appBase", host.getName(), host.getAppBaseFile().getPath())); host.setDeployOnStartup(false); host.setAutoDeploy(false); } if (host.getDeployOnStartup()) deployApps(); }	public void testBug46243() throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(tomcat.getHost().getAppBaseFile(), "ROOT"); if (!docBase.exists() && !docBase.mkdirs()) { fail("Unable to create docBase"); } Context root = tomcat.addContext("", "ROOT"); FilterDef filterDef = new FilterDef(); filterDef.setFilterClass(Bug46243Filter.class.getName()); filterDef.setFilterName("Bug46243"); root.addFilterDef(filterDef); FilterMap filterMap = new FilterMap(); filterMap.setFilterName("Bug46243"); filterMap.addURLPattern("*"); root.addFilterMap(filterMap); // Add a test servlet so there is something to generate a response if Tomcat.addServlet(root, "Bug46243", new HelloWorldServlet()); root.addServletMapping("/", "Bug46243"); tomcat.start(); Bug46243Client client = new Bug46243Client(); client.setPort(getPort()); client.setRequest(new String[] { REQUEST }); client.connect(); client.processRequest(); assertTrue(client.isResponse404()); }	@Test public void testCustomErrorPage() throws Exception { File appDir = new File(getTemporaryDirectory(), "MyApp"); File webInf = new File(appDir, "WEB-INF"); if (!webInf.mkdirs()) { fail("Unable to create directory [" + webInf + "]"); } Writer w = new OutputStreamWriter(new FileOutputStream(new File(appDir, "WEB-INF/web.xml")), "UTF-8"); try { w.write("<?xml version='1.0' encoding='UTF-8'?>\n" + "<web-app xmlns='http://java.sun.com/xml/ns/j2ee' " + " xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'" + " xsi:schemaLocation='http://java.sun.com/xml/ns/j2ee " + " http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd'" + " version='2.4'>\n" + "<error-page>\n<error-code>404</error-code>\n" + "<location>/404.html</location>\n</error-page>\n" + "</web-app>\n"); w.flush(); } finally { w.close(); } w = new OutputStreamWriter(new FileOutputStream(new File(appDir, "404.html")), "ISO-8859-1"); try { w.write("It is 404.html"); w.flush(); } finally { w.close(); } Tomcat tomcat = getTomcatInstance(); String contextPath = "/MyApp"; tomcat.addWebapp(null, contextPath, appDir.getAbsolutePath()); tomcat.start(); TestCustomErrorClient client = new TestCustomErrorClient(); client.setPort(getPort()); client.reset(); client.setRequest(new String[] { "GET /MyApp/missing HTTP/1.0" + CRLF + CRLF }); client.connect(); client.processRequest(); assertTrue(client.isResponse404()); assertEquals("It is 404.html", client.getResponseBody()); SimpleDateFormat format = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US); format.setTimeZone(TimeZone.getTimeZone("GMT")); String tomorrow = format.format(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)); // https://issues.apache.org/bugzilla/show_bug.cgi?id=50413 client.reset(); client.setRequest(new String[] { "GET /MyApp/missing HTTP/1.1" + CRLF + "Host: localhost" + CRLF + "Connection: close" + CRLF + "If-Modified-Since: " + tomorrow + CRLF + CRLF }); client.connect(); client.processRequest(); assertTrue(client.isResponse404()); assertEquals("It is 404.html", client.getResponseBody()); // https://issues.apache.org/bugzilla/show_bug.cgi?id=50413#c6 client.reset(); client.setRequest(new String[] { "GET /MyApp/missing HTTP/1.1" + CRLF + "Host: localhost" + CRLF + "Connection: close" + CRLF + "Range: bytes=0-100" + CRLF + CRLF }); client.connect(); client.processRequest(); assertTrue(client.isResponse404()); assertEquals("It is 404.html", client.getResponseBody()); }	@Test public void testCustomErrorPageMissing() throws Exception { File appDir = new File(getTemporaryDirectory(), "MyApp"); File webInf = new File(appDir, "WEB-INF"); if (!webInf.mkdirs()) { fail("Unable to create directory [" + webInf + "]"); } Writer w = new OutputStreamWriter(new FileOutputStream(new File(appDir, "WEB-INF/web.xml")), "UTF-8"); try { w.write("<?xml version='1.0' encoding='UTF-8'?>\n" + "<web-app xmlns='http://java.sun.com/xml/ns/j2ee' " + " xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'" + " xsi:schemaLocation='http://java.sun.com/xml/ns/j2ee " + " http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd'" + " version='2.4'>\n" + "<error-page>\n<error-code>404</error-code>\n" + "<location>/404-absent.html</location>\n</error-page>\n" + "</web-app>\n"); w.flush(); } finally { w.close(); } Tomcat tomcat = getTomcatInstance(); String contextPath = "/MyApp"; tomcat.addWebapp(null, contextPath, appDir.getAbsolutePath()); tomcat.start(); TestCustomErrorClient client = new TestCustomErrorClient(); client.setPort(getPort()); client.reset(); client.setRequest(new String[] { "GET /MyApp/missing HTTP/1.0" + CRLF + CRLF }); client.connect(); client.processRequest(); assertTrue(client.isResponse404()); }	@Test public void testPathParamsRedirect() throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); File foo = new File(docBase, "foo"); if (!foo.exists() && !foo.mkdirs()) { fail("Unable to create foo directory in docBase"); } Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); Tomcat.addServlet(ctx, "servlet", new PathParamServlet()); ctx.addServletMapping("/", "servlet"); tomcat.start(); testPath("/", "none"); testPath("/;jsessionid=1234", "1234"); testPath("/foo;jsessionid=1234", "1234"); testPath("/foo;jsessionid=1234;dummy", "1234"); testPath("/foo;jsessionid=1234;dummy=5678", "1234"); testPath("/foo;jsessionid=1234;=5678", "1234"); testPath("/foo;jsessionid=1234/bar", "1234"); }
public static void initWebappDefaults(Context ctx) { Wrapper servlet = addServlet(ctx, "default", "org.apache.catalina.servlets.DefaultServlet"); servlet.setLoadOnStartup(1); servlet = addServlet(ctx, "jsp", "org.apache.jasper.servlet.JspServlet"); servlet.addInitParameter("fork", "false"); servlet.setLoadOnStartup(3); ctx.addServletMapping("/", "default"); ctx.addServletMapping("*.jsp", "jsp"); ctx.addServletMapping("*.jspx", "jsp"); ctx.setManager(new StandardManager()); ctx.setSessionTimeout(30); for (int i = 0; i < DEFAULT_MIME_MAPPINGS.length; ) { ctx.addMimeMapping(DEFAULT_MIME_MAPPINGS[i++], DEFAULT_MIME_MAPPINGS[i++]); } ctx.addWelcomeFile("index.html"); ctx.addWelcomeFile("index.htm"); ctx.addWelcomeFile("index.jsp"); }	public void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException { res.getWriter().write("Hello world"); }	@Test public void testJsps() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File(getBuildDirectory(), "webapps/examples"); tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/examples/jsp/jsp2/el/basic-arithmetic.jsp"); assertTrue(res.toString().indexOf("<td>${(1==2) ? 3 : 4}</td>") > 0); }

@Override public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) { ClassLoader loader = Thread.currentThread().getContextClassLoader(); try { // Use the system classloader as the victim for all this Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); if (driverManagerProtection) { DriverManager.getDrivers(); } if (appContextProtection) { ImageIO.getCacheDirectory(); } if (gcDaemonProtection) { try { Class<?> clazz = Class.forName("sun.misc.GC"); Method method = clazz.getDeclaredMethod("requestLatency", new Class[] { long.class }); method.invoke(null, Long.valueOf(3600000)); } catch (ClassNotFoundException e) { if (System.getProperty("java.vendor").startsWith("Sun")) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } else { log.debug(sm.getString("jreLeakListener.gcDaemonFail"), e); } } catch (SecurityException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (NoSuchMethodException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (IllegalArgumentException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (IllegalAccessException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (InvocationTargetException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } } if (securityPolicyProtection) { try { Class<?> policyClass = Class.forName("javax.security.auth.Policy"); Method method = policyClass.getMethod("getPolicy"); method.invoke(null); } catch (ClassNotFoundException e) { // Ignore. The class is deprecated. } catch (SecurityException e) { // Ignore. Don't need call to getPolicy() to be // successful, just need to trigger static initializer. } catch (NoSuchMethodException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (IllegalArgumentException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (IllegalAccessException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (InvocationTargetException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } } if (securityLoginConfigurationProtection) { try { Class.forName("javax.security.auth.login.Configuration", true, ClassLoader.getSystemClassLoader()); } catch (ClassNotFoundException e) { // Ignore } } if (tokenPollerProtection) { java.security.Security.getProviders(); } if (urlCacheProtection) { try { // Doesn't matter that this JAR doesn't exist - just as URL url = new URL("jar:file://dummy.jar!/"); URLConnection uConn = url.openConnection(); uConn.setDefaultUseCaches(false); } catch (MalformedURLException e) { log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"), e); } catch (IOException e) { log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"), e); } } if (xmlParsingProtection) { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); try { factory.newDocumentBuilder(); } catch (ParserConfigurationException e) { log.error(sm.getString("jreLeakListener.xmlParseFail"), e); } } if (ldapPoolProtection) { try { Class.forName("com.sun.jndi.ldap.LdapPoolManager"); } catch (ClassNotFoundException e) { if (System.getProperty("java.vendor").startsWith("Sun")) { log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"), e); } else { log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"), e); } } } } finally { Thread.currentThread().setContextClassLoader(loader); } } }	public boolean isGcDaemonProtection() { return gcDaemonProtection; }
@Override public void run() { long maintainTime = 0; while (running) { while (paused && running) { try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } } if (!running) { break; } if (keepAliveCount < 1 && addCount < 1) { synchronized (this) { while (keepAliveCount < 1 && addCount < 1 && running) { maintainTime = 0; try { this.wait(); } catch (InterruptedException e) { // Ignore } } } } if (!running) { break; } try { if (addCount > 0) { synchronized (this) { int successCount = 0; try { for (int i = (addCount - 1); i >= 0; i--) { int rv = Poll.add(serverPollset, addS[i], Poll.APR_POLLIN); if (rv == Status.APR_SUCCESS) { successCount++; } else { if (comet) { processSocket(addS[i], SocketStatus.ERROR); } else { destroySocket(addS[i]); } } } } finally { keepAliveCount += successCount; addCount = 0; } } } maintainTime += pollTime; int rv = Poll.poll(serverPollset, pollTime, desc, true); if (rv > 0) { keepAliveCount -= rv; for (int n = 0; n < rv; n++) { if (((desc[n * 2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP) || ((desc[n * 2] & Poll.APR_POLLERR) == Poll.APR_POLLERR) || (comet && (!processSocket(desc[n * 2 + 1], SocketStatus.OPEN))) || (!comet && (!processSocket(desc[n * 2 + 1])))) { if (comet) { processSocket(desc[n * 2 + 1], SocketStatus.DISCONNECT); } else { destroySocket(desc[n * 2 + 1]); } continue; } } } else if (rv < 0) { int errn = -rv; if ((errn != Status.TIMEUP) && (errn != Status.EINTR)) { if (errn > Status.APR_OS_START_USERERR) { errn -= Status.APR_OS_START_USERERR; } log.error(sm.getString("endpoint.poll.fail", "" + errn, Error.strerror(errn))); synchronized (this) { destroy(); init(); } continue; } } if (socketProperties.getSoTimeout() > 0 && maintainTime > 1000000L && running) { rv = Poll.maintain(serverPollset, desc, true); maintainTime = 0; if (rv > 0) { keepAliveCount -= rv; for (int n = 0; n < rv; n++) { if (comet) { processSocket(desc[n], SocketStatus.TIMEOUT); } else { destroySocket(desc[n]); } } } } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("endpoint.poll.error"), t); } } synchronized (this) { this.notifyAll(); } }	@Override protected void longPoll(SocketWrapper<Long> socket, Http11AprProcessor processor) { connections.put(socket.getSocket(), processor); if (processor.isAsync()) { socket.setAsync(true); } else if (processor.comet) { ((AprEndpoint) proto.endpoint).getCometPoller().add(socket.getSocket().longValue()); } }	public void run() { while (running) { try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } long now = System.currentTimeMillis(); Iterator<SocketWrapper<Long>> sockets = waitingRequests.iterator(); while (sockets.hasNext()) { SocketWrapper<Long> socket = sockets.next(); if (socket.async) { long access = socket.getLastAccess(); if (socket.getTimeout() > 0 && (now - access) > socket.getTimeout()) { processSocketAsync(socket, SocketStatus.TIMEOUT); } } } while (paused && running) { try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } } } }	public void add(long socket) { synchronized (this) { if (addCount >= addS.length) { if (comet) { processSocket(socket, SocketStatus.ERROR); } else { destroySocket(socket); } return; } addS[addCount] = socket; addCount++; this.notify(); } }	@Override public void run() { long maintainTime = 0; while (running) { while (paused && running) { try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } } if (!running) { break; } if (keepAliveCount < 1 && addCount < 1) { synchronized (this) { while (keepAliveCount < 1 && addCount < 1 && running) { maintainTime = 0; try { this.wait(); } catch (InterruptedException e) { // Ignore } } } } if (!running) { break; } try { if (addCount > 0) { synchronized (this) { int successCount = 0; try { for (int i = (addCount - 1); i >= 0; i--) { int rv = Poll.add(serverPollset, addS[i], Poll.APR_POLLIN); if (rv == Status.APR_SUCCESS) { successCount++; } else { if (comet) { processSocket(addS[i], SocketStatus.ERROR); } else { destroySocket(addS[i]); } } } } finally { keepAliveCount += successCount; addCount = 0; } } } maintainTime += pollTime; int rv = Poll.poll(serverPollset, pollTime, desc, true); if (rv > 0) { keepAliveCount -= rv; for (int n = 0; n < rv; n++) { if (((desc[n * 2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP) || ((desc[n * 2] & Poll.APR_POLLERR) == Poll.APR_POLLERR) || (comet && (!processSocket(desc[n * 2 + 1], SocketStatus.OPEN))) || (!comet && (!processSocket(desc[n * 2 + 1])))) { if (comet) { processSocket(desc[n * 2 + 1], SocketStatus.DISCONNECT); } else { destroySocket(desc[n * 2 + 1]); } continue; } } } else if (rv < 0) { int errn = -rv; if ((errn != Status.TIMEUP) && (errn != Status.EINTR)) { if (errn > Status.APR_OS_START_USERERR) { errn -= Status.APR_OS_START_USERERR; } log.error(sm.getString("endpoint.poll.fail", "" + errn, Error.strerror(errn))); synchronized (this) { destroy(); init(); } continue; } } if (socketProperties.getSoTimeout() > 0 && maintainTime > 1000000L && running) { rv = Poll.maintain(serverPollset, desc, true); maintainTime = 0; if (rv > 0) { keepAliveCount -= rv; for (int n = 0; n < rv; n++) { if (comet) { processSocket(desc[n], SocketStatus.TIMEOUT); } else { destroySocket(desc[n]); } } } } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("endpoint.poll.error"), t); } } synchronized (this) { this.notifyAll(); } }	@Override public void release(SocketWrapper<Long> socket, AjpAprProcessor processor, boolean isSocketClosing, boolean addToPoller) { processor.recycle(isSocketClosing); recycledProcessors.offer(processor); if (addToPoller) { ((AprEndpoint) proto.endpoint).getPoller().add(socket.getSocket().longValue()); } }	@Override public void release(SocketWrapper<Long> socket, Http11AprProcessor processor, boolean isSocketClosing, boolean addToPoller) { processor.recycle(); recycledProcessors.offer(processor); if (addToPoller) { ((AprEndpoint) proto.endpoint).getPoller().add(socket.getSocket().longValue()); } }	protected Log getLog() { return log; }
@Override public void log(org.apache.coyote.Request req, org.apache.coyote.Response res, long time) { Request request = (Request) req.getNote(ADAPTER_NOTES); Response response = (Response) res.getNote(ADAPTER_NOTES); boolean create = false; if (request == null) { create = true; request = connector.createRequest(); request.setCoyoteRequest(req); response = connector.createResponse(); response.setCoyoteResponse(res); request.setResponse(response); response.setRequest(request); req.setNote(ADAPTER_NOTES, request); res.setNote(ADAPTER_NOTES, response); req.getParameters().setQueryStringEncoding(connector.getURIEncoding()); } try { // Log at the lowest level available. logAccess() will be boolean logged = false; if (request.mappingData != null) { if (request.mappingData.context != null) { logged = true; ((Context) request.mappingData.context).logAccess(request, response, time, true); } else if (request.mappingData.host != null) { logged = true; ((Context) request.mappingData.context).logAccess(request, response, time, true); } } if (!logged) { connector.getService().getContainer().logAccess(request, response, time, true); } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.warn(sm.getString("coyoteAdapter.accesslogFail"), t); } if (create) { request.recycle(); response.recycle(); } }
public void start() { if (log.isDebugEnabled()) log.debug(sm.getString("hostConfig.start")); try { ObjectName hostON = host.getObjectName(); oname = new ObjectName(hostON.getDomain() + ":type=Deployer,host=" + host.getName()); Registry.getRegistry(null, null).registerComponent(this, oname, this.getClass().getName()); } catch (Exception e) { log.error(sm.getString("hostConfig.jmx.register", oname), e); } if (host.getCreateDirs()) { File[] dirs = new File[] { appBase(), configBase() }; for (int i = 0; i < dirs.length; i++) { if ((!dirs[i].isDirectory()) && (!dirs[i].mkdirs())) { log.error(sm.getString("hostConfig.createDirs", dirs[i])); } } } if (host.getDeployOnStartup()) deployApps(); }
public static String normalize(String path, boolean replaceBackSlash) { if (path == null) return null; String normalized = path; if (replaceBackSlash && normalized.indexOf('\\') >= 0) normalized = normalized.replace('\\', '/'); if (normalized.equals("/.")) return "/"; if (!normalized.startsWith("/")) normalized = "/" + normalized; while (true) { int index = normalized.indexOf("//"); if (index < 0) break; normalized = normalized.substring(0, index) + normalized.substring(index + 1); } while (true) { int index = normalized.indexOf("/./"); if (index < 0) break; normalized = normalized.substring(0, index) + normalized.substring(index + 2); } while (true) { int index = normalized.indexOf("/../"); if (index < 0) break; if (index == 0) return (null); int index2 = normalized.lastIndexOf('/', index - 1); normalized = normalized.substring(0, index2) + normalized.substring(index + 3); } return (normalized); }	public static void parseParameters(Map<String, String[]> map, String data, String encoding) { if ((data != null) && (data.length() > 0)) { // use the specified encoding to extract bytes out of the // given string so that the encoding is not lost. If an byte[] bytes = null; try { if (encoding == null) { bytes = data.getBytes(Charset.defaultCharset()); } else { bytes = data.getBytes(B2CConverter.getCharset(encoding)); } parseParameters(map, bytes, encoding); } catch (UnsupportedEncodingException uee) { if (log.isDebugEnabled()) { log.debug(sm.getString("requestUtil.parseParameters.uee", encoding), uee); } } } }
private static JavacErrorDetail[] parseJavacMessage(String errMsg, String fname, Node.Nodes page) throws IOException, JasperException { ArrayList<JavacErrorDetail> errors = new ArrayList<JavacErrorDetail>(); StringBuilder errMsgBuf = null; int lineNum = -1; JavacErrorDetail javacError = null; BufferedReader reader = new BufferedReader(new StringReader(errMsg)); String line = null; while ((line = reader.readLine()) != null) { int beginColon = line.indexOf(':', 2); int endColon = line.indexOf(':', beginColon + 1); if ((beginColon >= 0) && (endColon >= 0)) { if (javacError != null) { errors.add(javacError); } String lineNumStr = line.substring(beginColon + 1, endColon); try { lineNum = Integer.parseInt(lineNumStr); } catch (NumberFormatException e) { lineNum = -1; } errMsgBuf = new StringBuilder(); javacError = createJavacError(fname, page, errMsgBuf, lineNum); } if (errMsgBuf != null) { errMsgBuf.append(line); errMsgBuf.append("\n"); } } if (javacError != null) { errors.add(javacError); } reader.close(); JavacErrorDetail[] errDetails = null; if (errors.size() > 0) { errDetails = new JavacErrorDetail[errors.size()]; errors.toArray(errDetails); } return errDetails; }	@Override public void javacError(JavacErrorDetail[] details) throws JasperException { if (details == null) { return; } Object[] args = null; StringBuilder buf = new StringBuilder(); for (int i = 0; i < details.length; i++) { if (details[i].getJspBeginLineNumber() >= 0) { args = new Object[] { Integer.valueOf(details[i].getJspBeginLineNumber()), details[i].getJspFileName() }; buf.append("\n\n"); buf.append(Localizer.getMessage("jsp.error.single.line.number", args)); buf.append("\n"); buf.append(details[i].getErrorMessage()); buf.append("\n"); buf.append(details[i].getJspExtract()); } else { args = new Object[] { Integer.valueOf(details[i].getJavaLineNumber()) }; buf.append("\n\n"); buf.append(Localizer.getMessage("jsp.error.java.line.number", args)); buf.append("\n"); buf.append(details[i].getErrorMessage()); } } buf.append("\n\nStacktrace:"); throw new JasperException(Localizer.getMessage("jsp.error.unable.compile") + ": " + buf); }
public Enumeration<String> list() throws IOException { if (!connected) { connect(); } if ((resource == null) && (collection == null)) { throw new FileNotFoundException(getURL() == null ? "null" : getURL().toString()); } Vector<String> result = new Vector<String>(); if (collection != null) { try { String file = getURL().getFile(); // This will be of the form /<hostname>/<contextpath>/file name // if <contextpath> is not empty otherwise this will be of the // form /<hostname>/file name int start; if (context instanceof ProxyDirContext && "".equals(((ProxyDirContext) context).getContextPath())) { start = file.indexOf('/', 1); } else start = file.indexOf('/', file.indexOf('/', 1) + 1); NamingEnumeration<NameClassPair> enumeration = context.list(file.substring(start)); while (enumeration.hasMoreElements()) { NameClassPair ncp = enumeration.nextElement(); result.addElement(URLEncoder.encode(ncp.getName(), "UTF-8")); } } catch (NamingException e) { throw new FileNotFoundException(getURL() == null ? "null" : getURL().toString()); } } return result.elements(); }
@Override public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) { ClassLoader loader = Thread.currentThread().getContextClassLoader(); try { // Use the system classloader as the victim for all this Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); if (appContextProtection) { ImageIO.getCacheDirectory(); } if (gcDaemonProtection) { try { Class<?> clazz = Class.forName("sun.misc.GC"); Method method = clazz.getDeclaredMethod("requestLatency", new Class[] { long.class }); method.invoke(null, Long.valueOf(3600000)); } catch (ClassNotFoundException e) { if (System.getProperty("java.vendor").startsWith("Sun")) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } else { log.debug(sm.getString("jreLeakListener.gcDaemonFail"), e); } } catch (SecurityException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (NoSuchMethodException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (IllegalArgumentException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (IllegalAccessException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (InvocationTargetException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } } if (securityPolicyProtection) { try { Class<?> policyClass = Class.forName("javax.security.auth.Policy"); Method method = policyClass.getMethod("getPolicy"); method.invoke(null); } catch (ClassNotFoundException e) { // Ignore. The class is deprecated. } catch (SecurityException e) { // Ignore. Don't need call to getPolicy() to be // successful, just need to trigger static initializer. } catch (NoSuchMethodException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (IllegalArgumentException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (IllegalAccessException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (InvocationTargetException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } } if (securityLoginConfigurationProtection) { try { Class.forName("javax.security.auth.login.Configuration", true, ClassLoader.getSystemClassLoader()); } catch (ClassNotFoundException e) { // Ignore } } if (tokenPollerProtection) { java.security.Security.getProviders(); } if (urlCacheProtection) { try { // Doesn't matter that this JAR doesn't exist - just as URL url = new URL("jar:file://dummy.jar!/"); URLConnection uConn = url.openConnection(); uConn.setDefaultUseCaches(false); } catch (MalformedURLException e) { log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"), e); } catch (IOException e) { log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"), e); } } if (xmlParsingProtection) { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); try { factory.newDocumentBuilder(); } catch (ParserConfigurationException e) { log.error(sm.getString("jreLeakListener.xmlParseFail"), e); } } if (ldapPoolProtection) { try { Class.forName("com.sun.jndi.ldap.LdapPoolManager"); } catch (ClassNotFoundException e) { if (System.getProperty("java.vendor").startsWith("Sun")) { log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"), e); } else { log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"), e); } } } } finally { Thread.currentThread().setContextClassLoader(loader); } } }	public void setLdapPoolProtection(boolean ldapPoolProtection) { this.ldapPoolProtection = ldapPoolProtection; }	public boolean isLdapPoolProtection() { return ldapPoolProtection; }
@Override public void release(SocketWrapper<NioChannel> socket) { Http11NioProcessor processor = connections.remove(socket); if (processor != null) { processor.recycle(); recycledProcessors.offer(processor); } }
protected void connectUsingDriver() throws SQLException { try { if (driver == null) driver = (java.sql.Driver) Class.forName(poolProperties.getDriverClassName(), true, PooledConnection.class.getClassLoader()).newInstance(); } catch (java.lang.Exception cn) { if (log.isDebugEnabled()) { log.debug("Unable to instantiate JDBC driver.", cn); } SQLException ex = new SQLException(cn.getMessage()); ex.initCause(cn); throw ex; } String driverURL = poolProperties.getUrl(); String usr = null; String pwd = null; if (getAttributes().containsKey(PROP_USER)) { usr = (String) getAttributes().get(PROP_USER); } else { usr = poolProperties.getUsername(); getAttributes().put(PROP_USER, usr); } if (getAttributes().containsKey(PROP_PASSWORD)) { pwd = (String) getAttributes().get(PROP_PASSWORD); } else { pwd = poolProperties.getPassword(); getAttributes().put(PROP_PASSWORD, pwd); } Properties properties = PoolUtilities.clone(poolProperties.getDbProperties()); if (usr != null) properties.setProperty(PROP_USER, usr); if (pwd != null) properties.setProperty(PROP_PASSWORD, pwd); try { connection = connection = driver.connect(driverURL, properties); } catch (Exception x) { if (log.isDebugEnabled()) { log.debug("Unable to connect to database.", x); } if (parent.jmxPool != null) { parent.jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_CONNECT, ConnectionPool.getStackTrace(x)); } if (x instanceof SQLException) { throw (SQLException) x; } else { SQLException ex = new SQLException(x.getMessage()); ex.initCause(x); throw ex; } } if (connection == null) { throw new SQLException("Driver:" + driver + " returned null for URL:" + driverURL); } }
@Override public final synchronized void destroy() throws LifecycleException { if (LifecycleState.DESTROYING.equals(state) || LifecycleState.DESTROYED.equals(state)) { if (log.isDebugEnabled()) { Exception e = new LifecycleException(); log.debug(sm.getString("lifecycleBase.alreadyDestroyed", toString()), e); } else if (log.isInfoEnabled()) { log.info(sm.getString("lifecycleBase.alreadyDestroyed", toString())); } return; } if (!state.equals(LifecycleState.STOPPED) && !state.equals(LifecycleState.FAILED) && !state.equals(LifecycleState.NEW) && !state.equals(LifecycleState.INITIALIZED)) { invalidTransition(Lifecycle.BEFORE_DESTROY_EVENT); } setStateInternal(LifecycleState.DESTROYING, null, false); try { destroyInternal(); } catch (LifecycleException e) { setStateInternal(LifecycleState.FAILED, null, false); throw e; } setStateInternal(LifecycleState.DESTROYED, null, false); }	@Override public final synchronized void init() throws LifecycleException { if (!state.equals(LifecycleState.NEW)) { invalidTransition(Lifecycle.BEFORE_INIT_EVENT); } setStateInternal(LifecycleState.INITIALIZING, null, false); try { initInternal(); } catch (LifecycleException e) { setStateInternal(LifecycleState.FAILED, null, false); throw e; } setStateInternal(LifecycleState.INITIALIZED, null, false); }	@Override public final synchronized void start() throws LifecycleException { if (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) || LifecycleState.STARTED.equals(state)) { if (log.isDebugEnabled()) { Exception e = new LifecycleException(); log.debug(sm.getString("lifecycleBase.alreadyStarted", toString()), e); } else if (log.isInfoEnabled()) { log.info(sm.getString("lifecycleBase.alreadyStarted", toString())); } return; } if (state.equals(LifecycleState.NEW)) { init(); } else if (!state.equals(LifecycleState.INITIALIZED) && !state.equals(LifecycleState.STOPPED)) { invalidTransition(Lifecycle.BEFORE_START_EVENT); } setStateInternal(LifecycleState.STARTING_PREP, null, false); try { startInternal(); } catch (LifecycleException e) { setStateInternal(LifecycleState.FAILED, null, false); throw e; } if (state.equals(LifecycleState.FAILED) || state.equals(LifecycleState.MUST_STOP)) { stop(); } else { if (!state.equals(LifecycleState.STARTING)) { invalidTransition(Lifecycle.AFTER_START_EVENT); } setStateInternal(LifecycleState.STARTED, null, false); } }	@Override public final synchronized void stop() throws LifecycleException { if (LifecycleState.STOPPING_PREP.equals(state) || LifecycleState.STOPPING.equals(state) || LifecycleState.STOPPED.equals(state)) { if (log.isDebugEnabled()) { Exception e = new LifecycleException(); log.debug(sm.getString("lifecycleBase.alreadyStopped", toString()), e); } else if (log.isInfoEnabled()) { log.info(sm.getString("lifecycleBase.alreadyStopped", toString())); } return; } if (state.equals(LifecycleState.NEW)) { state = LifecycleState.STOPPED; return; } if (!state.equals(LifecycleState.STARTED) && !state.equals(LifecycleState.FAILED) && !state.equals(LifecycleState.MUST_STOP)) { invalidTransition(Lifecycle.BEFORE_STOP_EVENT); } if (state.equals(LifecycleState.FAILED)) { // Don't transition to STOPPING_PREP as that would briefly mark the // component as available but do ensure the BEFORE_STOP_EVENT is fireLifecycleEvent(BEFORE_STOP_EVENT, null); } else { setStateInternal(LifecycleState.STOPPING_PREP, null, false); } try { stopInternal(); } catch (LifecycleException e) { setStateInternal(LifecycleState.FAILED, null, false); throw e; } if (state.equals(LifecycleState.MUST_DESTROY)) { setStateInternal(LifecycleState.STOPPED, null, false); destroy(); } else { if (!state.equals(LifecycleState.STOPPING)) { invalidTransition(Lifecycle.AFTER_STOP_EVENT); } setStateInternal(LifecycleState.STOPPED, null, false); } }
public void processExpires() { String[] keys = null; if (!getState().isAvailable()) { return; } try { keys = keys(); } catch (IOException e) { manager.getContainer().getLogger().error("Error getting keys", e); return; } if (manager.getContainer().getLogger().isDebugEnabled()) { manager.getContainer().getLogger().debug(getStoreName() + ": processExpires check number of " + keys.length + " sessions"); } long timeNow = System.currentTimeMillis(); for (int i = 0; i < keys.length; i++) { try { StandardSession session = (StandardSession) load(keys[i]); if (session == null) { continue; } int timeIdle = (int) ((timeNow - session.getThisAccessedTime()) / 1000L); if (timeIdle < session.getMaxInactiveInterval()) { continue; } if (manager.getContainer().getLogger().isDebugEnabled()) { manager.getContainer().getLogger().debug(getStoreName() + ": processExpires expire store session " + keys[i]); } boolean isLoaded = false; try { if (manager.findSession(keys[i]) != null) { isLoaded = true; } } catch (IOException ioe) { // Ignore - session will be expired } if (isLoaded) { session.recycle(); } else { session.expire(); } remove(keys[i]); } catch (Exception e) { manager.getContainer().getLogger().error("Session: " + keys[i] + "; ", e); try { remove(keys[i]); } catch (IOException e2) { manager.getContainer().getLogger().error("Error removing key", e2); } } } }
private AccessLogElement createAccessLogElement(String header, char pattern) { switch(pattern) { case 'i': return new HeaderElement(header); case 'c': return new CookieElement(header); case 'o': return new ResponseHeaderElement(header); case 'r': return new RequestAttributeElement(header); case 's': return new SessionAttributeElement(header); case 't': return new DateAndTimeElement(header); default: return new StringElement("???"); } }	protected AccessLogElement[] createLogElements() { List<AccessLogElement> list = new ArrayList<AccessLogElement>(); boolean replace = false; StringBuilder buf = new StringBuilder(); for (int i = 0; i < pattern.length(); i++) { char ch = pattern.charAt(i); if (replace) { if ('{' == ch) { StringBuilder name = new StringBuilder(); int j = i + 1; for (; j < pattern.length() && '}' != pattern.charAt(j); j++) { name.append(pattern.charAt(j)); } if (j + 1 < pattern.length()) { j++; list.add(createAccessLogElement(name.toString(), pattern.charAt(j))); i = j; /* Since we walked more than one character */ } else { // D'oh - end of string - pretend we never did this list.add(createAccessLogElement(ch)); } } else { list.add(createAccessLogElement(ch)); } replace = false; } else if (ch == '%') { replace = true; list.add(new StringElement(buf.toString())); buf = new StringBuilder(); } else { buf.append(ch); } } if (buf.length() > 0) { list.add(new StringElement(buf.toString())); } return list.toArray(new AccessLogElement[0]); }
protected void checkHandlesTypes(JavaClass javaClass) { if (typeInitializerMap.size() == 0) return; String className = javaClass.getClassName(); Class<?> clazz = null; try { clazz = context.getLoader().getClassLoader().loadClass(className); } catch (NoClassDefFoundError e) { log.debug(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (ClassNotFoundException e) { log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (ClassFormatError e) { log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } if (clazz.isAnnotation()) { return; } boolean match = false; for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry : typeInitializerMap.entrySet()) { if (entry.getKey().isAnnotation()) { AnnotationEntry[] annotationEntries = javaClass.getAnnotationEntries(); for (AnnotationEntry annotationEntry : annotationEntries) { if (entry.getKey().getName().equals(getClassName(annotationEntry.getAnnotationType()))) { match = true; break; } } } else if (entry.getKey().isAssignableFrom(clazz)) { match = true; } if (match) { for (ServletContainerInitializer sci : entry.getValue()) { initializerClassMap.get(sci).add(clazz); } match = false; } } }
public boolean isResponseBodyOK() { if (getResponseBody() == null) { return false; } if (!getResponseBody().contains("abcd\tefgh")) { return false; } return true; }	public HeaderParseStatus parseHeader() throws IOException { // // Check for blank line byte chr = 0; while (headerParsePos == HeaderParsePosition.HEADER_START) { if (pos >= lastValid) { if (!fill(true, false)) { headerParsePos = HeaderParsePosition.HEADER_START; return HeaderParseStatus.NEED_MORE_DATA; } } chr = buf[pos]; if ((chr == Constants.CR) || (chr == Constants.LF)) { if (chr == Constants.LF) { pos++; return HeaderParseStatus.DONE; } } else { break; } pos++; } if (headerParsePos == HeaderParsePosition.HEADER_START) { headerData.start = pos; headerParsePos = HeaderParsePosition.HEADER_NAME; } while (headerParsePos == HeaderParsePosition.HEADER_NAME) { if (pos >= lastValid) { if (!fill(true, false)) { return HeaderParseStatus.NEED_MORE_DATA; } } if (buf[pos] == Constants.COLON) { headerParsePos = HeaderParsePosition.HEADER_VALUE; headerData.headerValue = headers.addValue(buf, headerData.start, pos - headerData.start); } chr = buf[pos]; if ((chr >= Constants.A) && (chr <= Constants.Z)) { buf[pos] = (byte) (chr - Constants.LC_OFFSET); } pos++; if (headerParsePos == HeaderParsePosition.HEADER_VALUE) { headerData.start = pos; headerData.realPos = pos; } } // // Reading the header value (which can be spanned over multiple lines) boolean eol = false; while (headerParsePos == HeaderParsePosition.HEADER_VALUE || headerParsePos == HeaderParsePosition.HEADER_MULTI_LINE) { if (headerParsePos == HeaderParsePosition.HEADER_VALUE) { boolean space = true; while (space) { if (pos >= lastValid) { if (!fill(true, false)) { return HeaderParseStatus.NEED_MORE_DATA; } } if ((buf[pos] == Constants.SP) || (buf[pos] == Constants.HT)) { pos++; } else { space = false; } } headerData.lastSignificantChar = headerData.realPos; while (!eol) { if (pos >= lastValid) { if (!fill(true, false)) { return HeaderParseStatus.NEED_MORE_DATA; } } if (buf[pos] == Constants.CR) { // Skip } else if (buf[pos] == Constants.LF) { eol = true; } else if (buf[pos] == Constants.SP) { buf[headerData.realPos] = buf[pos]; headerData.realPos++; } else { buf[headerData.realPos] = buf[pos]; headerData.realPos++; headerData.lastSignificantChar = headerData.realPos; } pos++; } headerData.realPos = headerData.lastSignificantChar; // Checking the first character of the new line. If the character headerParsePos = HeaderParsePosition.HEADER_MULTI_LINE; } if (pos >= lastValid) { if (!fill(true, false)) { return HeaderParseStatus.NEED_MORE_DATA; } } chr = buf[pos]; if (headerParsePos == HeaderParsePosition.HEADER_MULTI_LINE) { if ((chr != Constants.SP) && (chr != Constants.HT)) { headerParsePos = HeaderParsePosition.HEADER_START; } else { eol = false; // Copying one extra space in the buffer (since there must buf[headerData.realPos] = chr; headerData.realPos++; headerParsePos = HeaderParsePosition.HEADER_VALUE; } } } headerData.headerValue.setBytes(buf, headerData.start, headerData.realPos - headerData.start); headerData.recycle(); return HeaderParseStatus.HAVE_MORE_HEADERS; }	@SuppressWarnings("null") public boolean parseHeader() throws IOException { // // Check for blank line byte chr = 0; while (true) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } chr = buf[pos]; if ((chr == Constants.CR) || (chr == Constants.LF)) { if (chr == Constants.LF) { pos++; return false; } } else { break; } pos++; } int start = pos; // // Reading the header name // Header name is always US-ASCII boolean colon = false; MessageBytes headerValue = null; while (!colon) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.COLON) { colon = true; headerValue = headers.addValue(buf, start, pos - start); } chr = buf[pos]; if ((chr >= Constants.A) && (chr <= Constants.Z)) { buf[pos] = (byte) (chr - Constants.LC_OFFSET); } pos++; } start = pos; int realPos = pos; // // Reading the header value (which can be spanned over multiple lines) boolean eol = false; boolean validLine = true; while (validLine) { boolean space = true; while (space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if ((buf[pos] == Constants.SP) || (buf[pos] == Constants.HT)) { pos++; } else { space = false; } } int lastSignificantChar = realPos; while (!eol) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.CR) { // Skip } else if (buf[pos] == Constants.LF) { eol = true; } else if (buf[pos] == Constants.SP) { buf[realPos] = buf[pos]; realPos++; } else { buf[realPos] = buf[pos]; realPos++; lastSignificantChar = realPos; } pos++; } realPos = lastSignificantChar; if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } chr = buf[pos]; if ((chr != Constants.SP) && (chr != Constants.HT)) { validLine = false; } else { eol = false; // Copying one extra space in the buffer (since there must buf[realPos] = chr; realPos++; } } headerValue.setBytes(buf, start, realPos - start); return true; }	@SuppressWarnings("null") public boolean parseHeader() throws IOException { // // Check for blank line byte chr = 0; while (true) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } chr = buf[pos]; if ((chr == Constants.CR) || (chr == Constants.LF)) { if (chr == Constants.LF) { pos++; return false; } } else { break; } pos++; } int start = pos; // // Reading the header name // Header name is always US-ASCII boolean colon = false; MessageBytes headerValue = null; while (!colon) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.COLON) { colon = true; headerValue = headers.addValue(buf, start, pos - start); } chr = buf[pos]; if ((chr >= Constants.A) && (chr <= Constants.Z)) { buf[pos] = (byte) (chr - Constants.LC_OFFSET); } pos++; } start = pos; int realPos = pos; // // Reading the header value (which can be spanned over multiple lines) boolean eol = false; boolean validLine = true; while (validLine) { boolean space = true; while (space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if ((buf[pos] == Constants.SP) || (buf[pos] == Constants.HT)) { pos++; } else { space = false; } } int lastSignificantChar = realPos; while (!eol) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.CR) { // Skip } else if (buf[pos] == Constants.LF) { eol = true; } else if (buf[pos] == Constants.SP) { buf[realPos] = buf[pos]; realPos++; } else { buf[realPos] = buf[pos]; realPos++; lastSignificantChar = realPos; } pos++; } realPos = lastSignificantChar; if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } chr = buf[pos]; if ((chr != Constants.SP) && (chr != Constants.HT)) { validLine = false; } else { eol = false; // Copying one extra space in the buffer (since there must buf[realPos] = chr; realPos++; } } headerValue.setBytes(buf, start, realPos - start); return true; }	@Override public int doRead(ByteChunk chunk, Request req) throws IOException { if (lastActiveFilter == -1) return inputStreamInputBuffer.doRead(chunk, req); else return activeFilters[lastActiveFilter].doRead(chunk, req); }	public void setSwallowInput(boolean swallowInput) { this.swallowInput = swallowInput; }
protected AccessLogElement getXParameterElement(PatternTokenizer tokenizer) throws IOException { if (!tokenizer.hasSubToken()) { log.error("x param in wrong format. Needs to be 'x-#(...)' read the docs!"); return null; } String token = tokenizer.getToken(); if (!tokenizer.hasParameter()) { log.error("x param in wrong format. Needs to be 'x-#(...)' read the docs!"); return null; } String parameter = tokenizer.getParameter(); if (parameter == null) { log.error("No closing ) found for in decode"); return null; } if ("A".equals(token)) { return new ServletContextElement(parameter); } else if ("C".equals(token)) { return new CookieElement(parameter); } else if ("R".equals(token)) { return new RequestAttributeElement(parameter); } else if ("S".equals(token)) { return new SessionAttributeElement(parameter); } else if ("H".equals(token)) { return getServletRequestElement(parameter); } else if ("P".equals(token)) { return new RequestParameterElement(parameter); } else if ("O".equals(token)) { return new ResponseAllHeaderElement(parameter); } log.error("x param for servlet request, couldn't decode value: " + token); return null; }
@Override public final synchronized void destroy() throws LifecycleException { if (LifecycleState.DESTROYING.equals(state) || LifecycleState.DESTROYED.equals(state)) { if (log.isDebugEnabled()) { Exception e = new LifecycleException(); log.debug(sm.getString("lifecycleBase.alreadyDestroyed", toString()), e); } else if (log.isInfoEnabled()) { log.info(sm.getString("lifecycleBase.alreadyDestroyed", toString())); } return; } if (!state.equals(LifecycleState.STOPPED) && !state.equals(LifecycleState.FAILED) && !state.equals(LifecycleState.NEW)) { invalidTransition(Lifecycle.BEFORE_DESTROY_EVENT); } setStateInternal(LifecycleState.DESTROYING, null, false); try { destroyInternal(); } catch (LifecycleException e) { setStateInternal(LifecycleState.FAILED, null, false); throw e; } setStateInternal(LifecycleState.DESTROYED, null, false); }
@Override public void reset() { if (isCommitted()) throw new IllegalStateException(); response.reset(); }	@Override public void resetBuffer() { if (isCommitted()) throw new IllegalStateException(); response.resetBuffer(); }	@Override public void sendError(int sc) throws IOException { if (isCommitted()) throw new IllegalStateException(); response.setAppCommitted(true); response.sendError(sc); }	@Override public void sendError(int sc, String msg) throws IOException { if (isCommitted()) throw new IllegalStateException(); response.setAppCommitted(true); response.sendError(sc, msg); }	@Override public void sendRedirect(String location) throws IOException { if (isCommitted()) throw new IllegalStateException(); response.setAppCommitted(true); response.sendRedirect(location); }	@Override public void setBufferSize(int size) { if (isCommitted()) throw new IllegalStateException(); response.setBufferSize(size); }

public boolean isOutDated(boolean checkClass) { if (jsw != null && (ctxt.getOptions().getModificationTestInterval() > 0)) { if (jsw.getLastModificationTest() + (ctxt.getOptions().getModificationTestInterval() * 1000) > System.currentTimeMillis()) { return false; } jsw.setLastModificationTest(System.currentTimeMillis()); } Long jspRealLastModified = ctxt.getLastModified(ctxt.getJspFile()); if (jspRealLastModified.longValue() < 0) { return true; } long targetLastModified = 0; File targetFile; if (checkClass) { targetFile = new File(ctxt.getClassFileName()); } else { targetFile = new File(ctxt.getServletJavaFileName()); } if (!targetFile.exists()) { return true; } targetLastModified = targetFile.lastModified(); if (checkClass && jsw != null) { jsw.setServletClassLastModifiedTime(targetLastModified); } if (targetLastModified != jspRealLastModified.longValue()) { if (log.isDebugEnabled()) { log.debug("Compiler: outdated: " + targetFile + " " + targetLastModified); } return true; } if (jsw == null) { return false; } Map<String, Long> depends = jsw.getDependants(); if (depends == null) { return false; } Iterator<Entry<String, Long>> it = depends.entrySet().iterator(); while (it.hasNext()) { Entry<String, Long> include = it.next(); try { URL includeUrl = ctxt.getResource(include.getKey()); if (includeUrl == null) { return true; } URLConnection iuc = includeUrl.openConnection(); long includeLastModified = 0; if (iuc instanceof JarURLConnection) { includeLastModified = ((JarURLConnection) iuc).getJarEntry().getTime(); } else { includeLastModified = iuc.getLastModified(); } iuc.getInputStream().close(); if (includeLastModified != include.getValue().longValue()) { return true; } } catch (Exception e) { if (log.isDebugEnabled()) log.debug("Problem accessing resource. Treat as outdated.", e); return true; } } return false; }
public boolean contains(T key) { return cache.containsKey(key); }	void add(T key) { cache.put(key, null); }
@Override public void addRuleInstances(Digester digester) { digester.addRule(fullPrefix, new SetPublicIdRule("setPublicId")); digester.addRule(fullPrefix, new IgnoreAnnotationsRule()); digester.addRule(fullPrefix, new VersionRule()); if (fragment) { digester.addCallMethod(fullPrefix + "/name", "setName", 0); digester.addRule(fullPrefix + "/absolute-ordering", new AbsoluteOrderingRule()); digester.addCallMethod(fullPrefix + "/ordering/after/name", "addAfterOrdering", 0); digester.addCallMethod(fullPrefix + "/ordering/after/others", "addAfterOrderingOthers"); digester.addCallMethod(fullPrefix + "/ordering/before/name", "addBeforeOrdering", 0); digester.addCallMethod(fullPrefix + "/ordering/before/others", "addBeforeOrderingOthers"); } else { digester.addRule(fullPrefix + "/ordering", new RelativeOrderingRule()); digester.addCallMethod(fullPrefix + "/absolute-ordering/name", "addAbsoluteOrdering", 0); digester.addCallMethod(fullPrefix + "/absolute-ordering/name/others", "addAbsoluteOrderingOthers"); } digester.addCallMethod(fullPrefix + "/context-param", "addContextParam", 2); digester.addCallParam(fullPrefix + "/context-param/param-name", 0); digester.addCallParam(fullPrefix + "/context-param/param-value", 1); digester.addCallMethod(fullPrefix + "/display-name", "setDisplayName", 0); digester.addRule(fullPrefix + "/distributable", new SetDistributableRule()); configureNamingRules(digester); digester.addObjectCreate(fullPrefix + "/error-page", "org.apache.catalina.deploy.ErrorPage"); digester.addSetNext(fullPrefix + "/error-page", "addErrorPage", "org.apache.catalina.deploy.ErrorPage"); digester.addCallMethod(fullPrefix + "/error-page/error-code", "setErrorCode", 0); digester.addCallMethod(fullPrefix + "/error-page/exception-type", "setExceptionType", 0); digester.addCallMethod(fullPrefix + "/error-page/location", "setLocation", 0); digester.addObjectCreate(fullPrefix + "/filter", "org.apache.catalina.deploy.FilterDef"); digester.addSetNext(fullPrefix + "/filter", "addFilter", "org.apache.catalina.deploy.FilterDef"); digester.addCallMethod(fullPrefix + "/filter/description", "setDescription", 0); digester.addCallMethod(fullPrefix + "/filter/display-name", "setDisplayName", 0); digester.addCallMethod(fullPrefix + "/filter/filter-class", "setFilterClass", 0); digester.addCallMethod(fullPrefix + "/filter/filter-name", "setFilterName", 0); digester.addCallMethod(fullPrefix + "/filter/icon/large-icon", "setLargeIcon", 0); digester.addCallMethod(fullPrefix + "/filter/icon/small-icon", "setSmallIcon", 0); digester.addCallMethod(fullPrefix + "/filter/async-supported", "setAsyncSupported", 0); digester.addCallMethod(fullPrefix + "/filter/init-param", "addInitParameter", 2); digester.addCallParam(fullPrefix + "/filter/init-param/param-name", 0); digester.addCallParam(fullPrefix + "/filter/init-param/param-value", 1); digester.addObjectCreate(fullPrefix + "/filter-mapping", "org.apache.catalina.deploy.FilterMap"); digester.addSetNext(fullPrefix + "/filter-mapping", "addFilterMapping", "org.apache.catalina.deploy.FilterMap"); digester.addCallMethod(fullPrefix + "/filter-mapping/filter-name", "setFilterName", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/servlet-name", "addServletName", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/url-pattern", "addURLPattern", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/dispatcher", "setDispatcher", 0); digester.addCallMethod(fullPrefix + "/listener/listener-class", "addListener", 0); digester.addRule(fullPrefix + "/jsp-config", jspConfig); digester.addObjectCreate(fullPrefix + "/jsp-config/jsp-property-group", "org.apache.catalina.deploy.JspPropertyGroup"); digester.addSetNext(fullPrefix + "/jsp-config/jsp-property-group", "addJspPropertyGroup", "org.apache.catalina.deploy.JspPropertyGroup"); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/deferred-syntax-allowed-as-literal", "setDeferredSyntax", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/el-ignored", "setElIgnored", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/include-coda", "addIncludeCoda", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/include-prelude", "addIncludePrelude", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/is-xml", "setIsXml", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/page-encoding", "setPageEncoding", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/scripting-invalid", "setScriptingInvalid", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/trim-directive-whitespaces", "setTrimWhitespace", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/url-pattern", "setUrlPattern", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/default-content-type", "setDefaultContentType", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/buffer", "setBuffer", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/error-on-undeclared-namespace", "setErrorOnUndeclaredNamespace", 0); digester.addRule(fullPrefix + "/login-config", loginConfig); digester.addObjectCreate(fullPrefix + "/login-config", "org.apache.catalina.deploy.LoginConfig"); digester.addSetNext(fullPrefix + "/login-config", "setLoginConfig", "org.apache.catalina.deploy.LoginConfig"); digester.addCallMethod(fullPrefix + "/login-config/auth-method", "setAuthMethod", 0); digester.addCallMethod(fullPrefix + "/login-config/realm-name", "setRealmName", 0); digester.addCallMethod(fullPrefix + "/login-config/form-login-config/form-error-page", "setErrorPage", 0); digester.addCallMethod(fullPrefix + "/login-config/form-login-config/form-login-page", "setLoginPage", 0); digester.addCallMethod(fullPrefix + "/mime-mapping", "addMimeMapping", 2); digester.addCallParam(fullPrefix + "/mime-mapping/extension", 0); digester.addCallParam(fullPrefix + "/mime-mapping/mime-type", 1); digester.addObjectCreate(fullPrefix + "/security-constraint", "org.apache.catalina.deploy.SecurityConstraint"); digester.addSetNext(fullPrefix + "/security-constraint", "addSecurityConstraint", "org.apache.catalina.deploy.SecurityConstraint"); digester.addRule(fullPrefix + "/security-constraint/auth-constraint", new SetAuthConstraintRule()); digester.addCallMethod(fullPrefix + "/security-constraint/auth-constraint/role-name", "addAuthRole", 0); digester.addCallMethod(fullPrefix + "/security-constraint/display-name", "setDisplayName", 0); digester.addCallMethod(fullPrefix + "/security-constraint/user-data-constraint/transport-guarantee", "setUserConstraint", 0); digester.addObjectCreate(fullPrefix + "/security-constraint/web-resource-collection", "org.apache.catalina.deploy.SecurityCollection"); digester.addSetNext(fullPrefix + "/security-constraint/web-resource-collection", "addCollection", "org.apache.catalina.deploy.SecurityCollection"); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/http-method", "addMethod", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/http-method-omission", "addOmittedMethod", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/url-pattern", "addPattern", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/web-resource-name", "setName", 0); digester.addCallMethod(fullPrefix + "/security-role/role-name", "addSecurityRole", 0); digester.addRule(fullPrefix + "/servlet", new ServletDefCreateRule()); digester.addSetNext(fullPrefix + "/servlet", "addServlet", "org.apache.catalina.deploy.ServletDef"); digester.addCallMethod(fullPrefix + "/servlet/init-param", "addInitParameter", 2); digester.addCallParam(fullPrefix + "/servlet/init-param/param-name", 0); digester.addCallParam(fullPrefix + "/servlet/init-param/param-value", 1); digester.addCallMethod(fullPrefix + "/servlet/jsp-file", "setJspFile", 0); digester.addCallMethod(fullPrefix + "/servlet/load-on-startup", "setLoadOnStartup", 0); digester.addCallMethod(fullPrefix + "/servlet/run-as/role-name", "setRunAs", 0); digester.addCallMethod(fullPrefix + "/servlet/security-role-ref", "addSecurityRoleRef", 2); digester.addCallParam(fullPrefix + "/servlet/security-role-ref/role-link", 1); digester.addCallParam(fullPrefix + "/servlet/security-role-ref/role-name", 0); digester.addCallMethod(fullPrefix + "/servlet/servlet-class", "setServletClass", 0); digester.addCallMethod(fullPrefix + "/servlet/servlet-name", "setServletName", 0); digester.addObjectCreate(fullPrefix + "/servlet/multipart-config", "org.apache.catalina.deploy.MultipartDef"); digester.addSetNext(fullPrefix + "/servlet/multipart-config", "setMultipartDef", "org.apache.catalina.deploy.MultipartDef"); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/location", "setLocation", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/max-file-size", "setMaxFileSize", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/max-request-size", "setMaxRequestSize", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/file-size-threshold", "setFileSizeThreshold", 0); digester.addCallMethod(fullPrefix + "/servlet/async-supported", "setAsyncSupported", 0); digester.addCallMethod(fullPrefix + "/servlet/enabled", "setEnabled", 0); digester.addRule(fullPrefix + "/servlet-mapping", new CallMethodMultiRule("addServletMapping", 2, 0)); digester.addCallParam(fullPrefix + "/servlet-mapping/servlet-name", 1); digester.addRule(fullPrefix + "/servlet-mapping/url-pattern", new CallParamMultiRule(0)); digester.addRule(fullPrefix + "/session-config", sessionConfig); digester.addObjectCreate(fullPrefix + "/session-config", "org.apache.catalina.deploy.SessionConfig"); digester.addSetNext(fullPrefix + "/session-config", "setSessionConfig", "org.apache.catalina.deploy.SessionConfig"); digester.addCallMethod(fullPrefix + "/session-config/session-timeout", "setSessionTimeout", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/name", "setCookieName", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/domain", "setCookieDomain", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/path", "setCookiePath", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/comment", "setCookieComment", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/http-only", "setCookieHttpOnly", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/secure", "setCookieSecure", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/max-age", "setCookieMaxAge", 0); digester.addCallMethod(fullPrefix + "/session-config/tracking-mode", "addSessionTrackingMode", 0); digester.addRule(fullPrefix + "/taglib", new TaglibLocationRule(false)); digester.addCallMethod(fullPrefix + "/taglib", "addTaglib", 2); digester.addCallParam(fullPrefix + "/taglib/taglib-location", 1); digester.addCallParam(fullPrefix + "/taglib/taglib-uri", 0); digester.addRule(fullPrefix + "/jsp-config/taglib", new TaglibLocationRule(true)); digester.addCallMethod(fullPrefix + "/jsp-config/taglib", "addTaglib", 2); digester.addCallParam(fullPrefix + "/jsp-config/taglib/taglib-location", 1); digester.addCallParam(fullPrefix + "/jsp-config/taglib/taglib-uri", 0); digester.addCallMethod(fullPrefix + "/welcome-file-list/welcome-file", "addWelcomeFile", 0); digester.addCallMethod(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping", "addLocaleEncodingMapping", 2); digester.addCallParam(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping/locale", 0); digester.addCallParam(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping/encoding", 1); }
@Override protected void flush(boolean explicit) throws IOException { long socketRef = socket.getSocket().longValue(); if (outputBuffer.position() > 0) { if (Socket.sendbb(socketRef, 0, outputBuffer.position()) < 0) { throw new IOException(sm.getString("ajpprocessor.failedsend")); } outputBuffer.clear(); } if (explicit && !finished) { if (Socket.send(socketRef, flushMessageArray, 0, flushMessageArray.length) < 0) { throw new IOException(sm.getString("ajpprocessor.failedflush")); } } }
@Override protected void startInternal() throws LifecycleException { setState(LifecycleState.STARTING); try { protocolHandler.start(); } catch (Exception e) { String errPrefix = ""; if (this.service != null) { errPrefix += "service.getName(): \"" + this.service.getName() + "\"; "; } throw new LifecycleException(errPrefix + " " + sm.getString("coyoteConnector.protocolHandlerStartFailed"), e); } mapperListener.start(); }
public static boolean initialize(String libraryName) throws Exception { if (_instance == null) { if (libraryName == null) _instance = new Library(); else _instance = new Library(libraryName); TCN_MAJOR_VERSION = version(0x01); TCN_MINOR_VERSION = version(0x02); TCN_PATCH_VERSION = version(0x03); TCN_IS_DEV_VERSION = version(0x04); APR_MAJOR_VERSION = version(0x11); APR_MINOR_VERSION = version(0x12); APR_PATCH_VERSION = version(0x13); APR_IS_DEV_VERSION = version(0x14); APR_SIZEOF_VOIDP = size(1); APR_PATH_MAX = size(2); APRMAXHOSTLEN = size(3); APR_MAX_IOVEC_SIZE = size(4); APR_MAX_SECS_TO_LINGER = size(5); APR_MMAP_THRESHOLD = size(6); APR_MMAP_LIMIT = size(7); APR_HAVE_IPV6 = has(0); APR_HAS_SHARED_MEMORY = has(1); APR_HAS_THREADS = has(2); APR_HAS_SENDFILE = has(3); APR_HAS_MMAP = has(4); APR_HAS_FORK = has(5); APR_HAS_RANDOM = has(6); APR_HAS_OTHER_CHILD = has(7); APR_HAS_DSO = has(8); APR_HAS_SO_ACCEPTFILTER = has(9); APR_HAS_UNICODE_FS = has(10); APR_HAS_PROC_INVOKED = has(11); APR_HAS_USER = has(12); APR_HAS_LARGE_FILES = has(13); APR_HAS_XTHREAD_FILES = has(14); APR_HAS_OS_UUID = has(15); APR_IS_BIGENDIAN = has(16); APR_FILES_AS_SOCKETS = has(17); APR_CHARSET_EBCDIC = has(18); APR_TCP_NODELAY_INHERITED = has(19); APR_O_NONBLOCK_INHERITED = has(20); if (APR_MAJOR_VERSION < 1) { throw new UnsatisfiedLinkError("Unsupported APR Version (" + aprVersionString() + ")"); } if (!APR_HAS_THREADS) { throw new UnsatisfiedLinkError("Missing APR_HAS_THREADS"); } } return initialize(); }	@Override public void bind() throws Exception { try { rootPool = Pool.create(0); } catch (UnsatisfiedLinkError e) { throw new Exception(sm.getString("endpoint.init.notavail")); } serverSockPool = Pool.create(rootPool); String addressStr = null; if (getAddress() != null) { addressStr = getAddress().getHostAddress(); } int family = Socket.APR_INET; if (Library.APR_HAVE_IPV6) { if (addressStr == null) { if (!OS.IS_BSD && !OS.IS_WIN32 && !OS.IS_WIN64) family = Socket.APR_UNSPEC; } else if (addressStr.indexOf(':') >= 0) { family = Socket.APR_UNSPEC; } } long inetAddress = Address.info(addressStr, family, getPort(), 0, rootPool); serverSock = Socket.create(Address.getInfo(inetAddress).family, Socket.SOCK_STREAM, Socket.APR_PROTO_TCP, rootPool); if (OS.IS_UNIX) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } Socket.optSet(serverSock, Socket.APR_SO_KEEPALIVE, 1); int ret = Socket.bind(serverSock, inetAddress); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.bind", "" + ret, Error.strerror(ret))); } ret = Socket.listen(serverSock, getBacklog()); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.listen", "" + ret, Error.strerror(ret))); } if (OS.IS_WIN32 || OS.IS_WIN64) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } if (useSendfile && !Library.APR_HAS_SENDFILE) { useSendfile = false; } if (acceptorThreadCount == 0) { acceptorThreadCount = 1; } if (pollerThreadCount == 0) { if ((OS.IS_WIN32 || OS.IS_WIN64) && (getMaxConnections() > 1024)) { pollerThreadCount = getMaxConnections() / 1024; setMaxConnections(getMaxConnections() - (getMaxConnections() % 1024)); } else { pollerThreadCount = 1; } } if (sendfileThreadCount == 0) { if ((OS.IS_WIN32 || OS.IS_WIN64) && (sendfileSize > 1024)) { sendfileThreadCount = sendfileSize / 1024; sendfileSize = sendfileSize - (sendfileSize % 1024); } else { // No explicit poller size limitation sendfileThreadCount = 1; } } if (deferAccept) { if (Socket.optSet(serverSock, Socket.APR_TCP_DEFER_ACCEPT, 1) == Status.APR_ENOTIMPL) { deferAccept = false; } } if (isSSLEnabled()) { if (SSLCertificateFile == null) { throw new Exception(sm.getString("endpoint.apr.noSslCertFile")); } int value = SSL.SSL_PROTOCOL_ALL; if ("SSLv2".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV2; } else if ("SSLv3".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV3; } else if ("TLSv1".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_TLSV1; } else if ("SSLv2+SSLv3".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV2 | SSL.SSL_PROTOCOL_SSLV3; } else if ("all".equalsIgnoreCase(SSLProtocol) || SSLProtocol == null || SSLProtocol.length() == 0) { // NOOP, use the default defined above } else { throw new Exception(sm.getString("endpoint.apr.invalidSslProtocol", SSLProtocol)); } sslContext = SSLContext.make(rootPool, value, SSL.SSL_MODE_SERVER); if (SSLInsecureRenegotiation) { boolean legacyRenegSupported = false; try { legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); if (legacyRenegSupported) SSLContext.setOptions(sslContext, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); } catch (UnsatisfiedLinkError e) { // Ignore } if (!legacyRenegSupported) { log.warn(sm.getString("endpoint.warn.noInsecureReneg", SSL.versionString())); } } SSLContext.setCipherSuite(sslContext, SSLCipherSuite); SSLContext.setCertificate(sslContext, SSLCertificateFile, SSLCertificateKeyFile, SSLPassword, SSL.SSL_AIDX_RSA); SSLContext.setCertificateChainFile(sslContext, SSLCertificateChainFile, false); SSLContext.setCACertificate(sslContext, SSLCACertificateFile, SSLCACertificatePath); SSLContext.setCARevocation(sslContext, SSLCARevocationFile, SSLCARevocationPath); value = SSL.SSL_CVERIFY_NONE; if ("optional".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL; } else if ("require".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_REQUIRE; } else if ("optionalNoCA".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA; } SSLContext.setVerify(sslContext, value, SSLVerifyDepth); useSendfile = false; } }
protected DateFormatCache initialValue() { return new DateFormatCache(localCacheSize, Locale.getDefault(), globalDateCache); }	protected synchronized void open() { File dir = new File(directory); if (!dir.isAbsolute()) dir = new File(System.getProperty(Globals.CATALINA_BASE_PROP), directory); if (!dir.exists()) { if (!dir.mkdirs()) { log.error(sm.getString("accessLogValve.openDirFail", dir)); } } try { String pathname; if (rotatable) { pathname = dir.getAbsolutePath() + File.separator + prefix + dateStamp + suffix; } else { pathname = dir.getAbsolutePath() + File.separator + prefix + suffix; } writer = new PrintWriter(new BufferedWriter(new FileWriter(pathname, true), 128000), false); currentLogFile = new File(pathname); } catch (IOException e) { writer = null; currentLogFile = null; } }	public void setLocale(String localeName) { this.localeName = localeName; locale = findLocale(localeName, locale); }
@Override public final void invoke(Request request, Response response) throws IOException, ServletException { MessageBytes requestPathMB = request.getRequestPathMB(); if ((requestPathMB.startsWithIgnoreCase("/META-INF/", 0)) || (requestPathMB.equalsIgnoreCase("/META-INF")) || (requestPathMB.startsWithIgnoreCase("/WEB-INF/", 0)) || (requestPathMB.equalsIgnoreCase("/WEB-INF"))) { error(response, HttpServletResponse.SC_NOT_FOUND); return; } boolean reloaded = false; while (context.getPaused()) { reloaded = true; try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } } if (reloaded && context.getLoader() != null && context.getLoader().getClassLoader() != null) { Thread.currentThread().setContextClassLoader(context.getLoader().getClassLoader()); } Wrapper wrapper = request.getWrapper(); if (wrapper == null) { error(response, HttpServletResponse.SC_NOT_FOUND); return; } else if (wrapper.isUnavailable()) { wrapper = (Wrapper) container.findChild(wrapper.getName()); if (wrapper == null) { error(response, HttpServletResponse.SC_NOT_FOUND); return; } } try { response.sendAcknowledgement(); } catch (IOException ioe) { container.getLogger().error(sm.getString("standardContextValve.acknowledgeException"), ioe); request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, ioe); error(response, HttpServletResponse.SC_INTERNAL_SERVER_ERROR); return; } // Don't fire listeners during async processing // If a request init listener throws an exception, the request is boolean asyncAtStart = request.isAsync(); if (asyncAtStart || context.fireRequestInitEvent(request)) { if (request.isAsyncSupported()) { request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported()); } wrapper.getPipeline().getFirst().invoke(request, response); if (!(request.isAsync() || (asyncAtStart && request.getAttribute(RequestDispatcher.ERROR_EXCEPTION) != null))) { context.fireRequestDestroyEvent(request); } } }
public static byte[] decompress(byte[] data) throws IOException { ByteArrayInputStream bin = new ByteArrayInputStream(data); GZIPInputStream gin = new GZIPInputStream(bin); byte[] tmp = new byte[DEFAULT_BUFFER_SIZE]; int length = gin.read(tmp); byte[] result = new byte[length]; System.arraycopy(tmp, 0, result, 0, length); return result; }
private final void setSecurityProperty(String properties, String packageList) { if (System.getSecurityManager() != null) { String definition = Security.getProperty(properties); if (definition != null && definition.length() > 0) { definition += ","; } Security.setProperty(properties, definition + packageList); } }
protected synchronized void stopInternal() throws LifecycleException { if (this.getObjectName() != null) { Notification notification = new Notification("j2ee.state.stopping", this.getObjectName(), sequenceNumber.getAndIncrement()); broadcaster.sendNotification(notification); } setState(LifecycleState.STOPPING); ClassLoader oldCCL = bindThread(); try { final Container[] children = findChildren(); // we do it in a dedicated thread for memory leak protection, in // case some webapp code registers some ThreadLocals that they // forget to cleanup // TODO Figure out why DedicatedThreadExecutor hangs randomly in the RunnableWithLifecycleException stop = new RunnableWithLifecycleException() { @Override public void run() { ClassLoader old = bindThread(); try { for (int i = 0; i < children.length; i++) { try { children[i].stop(); } catch (LifecycleException e) { le = e; return; } } filterStop(); threadStop(); if (manager != null && manager instanceof Lifecycle) { try { ((Lifecycle) manager).stop(); } catch (LifecycleException e) { le = e; return; } } listenerStop(); } finally { unbindThread(old); } } }; Thread t = new Thread(stop); t.setName("stop children - " + getObjectName().toString()); t.run(); try { t.join(); } catch (InterruptedException e) { throw new LifecycleException(e); } if (stop.getLifecycleException() != null) { throw stop.getLifecycleException(); } setCharsetMapper(null); if (log.isDebugEnabled()) log.debug("Processing standard container shutdown"); if (namingResources != null) { namingResources.stop(); } fireLifecycleEvent(Lifecycle.CONFIGURE_STOP_EVENT, null); if (pipeline instanceof Lifecycle) { ((Lifecycle) pipeline).stop(); } if (context != null) context.clearAttributes(); resourcesStop(); if ((realm != null) && (realm instanceof Lifecycle)) { ((Lifecycle) realm).stop(); } if ((cluster != null) && (cluster instanceof Lifecycle)) { ((Lifecycle) cluster).stop(); } if ((logger != null) && (logger instanceof Lifecycle)) { ((Lifecycle) logger).stop(); } if ((loader != null) && (loader instanceof Lifecycle)) { ((Lifecycle) loader).stop(); } } finally { unbindThread(oldCCL); } if (this.getObjectName() != null) { Notification notification = new Notification("j2ee.state.stopped", this.getObjectName(), sequenceNumber.getAndIncrement()); broadcaster.sendNotification(notification); } context = null; try { resetContext(); } catch (Exception ex) { log.error("Error reseting context " + this + " " + ex, ex); } instanceManager = null; if (log.isDebugEnabled()) log.debug("Stopping complete"); }
protected void start(PrintWriter writer, String name, StringManager smClient) { if (debug >= 1) { log(sm.getString("hostManagerServlet.start", name)); } if ((name == null) || name.length() == 0) { writer.println(smClient.getString("hostManagerServlet.invalidHostName", name)); return; } Container host = engine.findChild(name); if (host == null) { writer.println(smClient.getString("hostManagerServlet.noHost", name)); return; } if (host == installedHost) { writer.println(smClient.getString("hostManagerServlet.cannotStartOwnHost", name)); return; } if (host.getState().isAvailable()) { writer.println(smClient.getString("hostManagerServlet.alreadyStarted", name)); return; } try { host.start(); writer.println(smClient.getString("hostManagerServlet.started", name)); } catch (Exception e) { getServletContext().log(sm.getString("hostManagerServlet.startFailed", name), e); writer.println(smClient.getString("hostManagerServlet.startFailed", name)); writer.println(smClient.getString("hostManagerServlet.exception", e.toString())); return; } }	protected void stop(PrintWriter writer, String name, StringManager smClient) { if (debug >= 1) { log(sm.getString("hostManagerServlet.stop", name)); } if ((name == null) || name.length() == 0) { writer.println(smClient.getString("hostManagerServlet.invalidHostName", name)); return; } Container host = engine.findChild(name); if (host == null) { writer.println(smClient.getString("hostManagerServlet.noHost", name)); return; } if (host == installedHost) { writer.println(smClient.getString("hostManagerServlet.cannotStopOwnHost", name)); return; } if (!host.getState().isAvailable()) { writer.println(smClient.getString("hostManagerServlet.alreadyStopped", name)); return; } try { host.stop(); writer.println(smClient.getString("hostManagerServlet.stopped", name)); } catch (Exception e) { getServletContext().log(sm.getString("hostManagerServlet.stopFailed", name), e); writer.println(smClient.getString("hostManagerServlet.stopFailed", name)); writer.println(smClient.getString("hostManagerServlet.exception", e.toString())); return; } }
@Override public void invoke(Request request, Response response) throws IOException, ServletException { if (log.isDebugEnabled()) log.debug("Security checking request " + request.getMethod() + " " + request.getRequestURI()); LoginConfig config = this.context.getLoginConfig(); if (cache) { Principal principal = request.getUserPrincipal(); if (principal == null) { Session session = request.getSessionInternal(false); if (session != null) { principal = session.getPrincipal(); if (principal != null) { if (log.isDebugEnabled()) log.debug("We have cached auth type " + session.getAuthType() + " for principal " + session.getPrincipal()); request.setAuthType(session.getAuthType()); request.setUserPrincipal(principal); } } } } // Special handling for form-based logins to deal with the case // where the login form (and therefore the "j_security_check" URI String contextPath = this.context.getPath(); String requestURI = request.getDecodedRequestURI(); if (requestURI.startsWith(contextPath) && requestURI.endsWith(Constants.FORM_ACTION)) { if (!authenticate(request, response, config)) { if (log.isDebugEnabled()) log.debug(" Failed authenticate() test ??" + requestURI); return; } } // The Servlet may specify security constraints through annotations. Wrapper wrapper = (Wrapper) request.getMappingData().wrapper; if (wrapper != null) { wrapper.servletSecurityAnnotationScan(); } Realm realm = this.context.getRealm(); SecurityConstraint[] constraints = realm.findSecurityConstraints(request, this.context); if (constraints == null && !context.getPreemptiveAuthentication()) { if (log.isDebugEnabled()) log.debug(" Not subject to any constraint"); getNext().invoke(request, response); return; } if (constraints != null && disableProxyCaching && !request.isSecure() && !"POST".equalsIgnoreCase(request.getMethod())) { if (securePagesWithPragma) { response.setHeader("Pragma", "No-cache"); response.setHeader("Cache-Control", "no-cache"); } else { response.setHeader("Cache-Control", "private"); } response.setHeader("Expires", DATE_ONE); } int i; if (constraints != null) { if (log.isDebugEnabled()) { log.debug(" Calling hasUserDataPermission()"); } if (!realm.hasUserDataPermission(request, response, constraints)) { if (log.isDebugEnabled()) { log.debug(" Failed hasUserDataPermission() test"); } return; } } // Since authenticate modifies the response on failure, boolean authRequired; if (constraints == null) { authRequired = false; } else { authRequired = true; for (i = 0; i < constraints.length && authRequired; i++) { if (!constraints[i].getAuthConstraint()) { authRequired = false; } else if (!constraints[i].getAllRoles()) { String[] roles = constraints[i].findAuthRoles(); if (roles == null || roles.length == 0) { authRequired = false; } } } } if (!authRequired) { authRequired = request.getCoyoteRequest().getMimeHeaders().getValue("authorization") != null; } if (!authRequired) { X509Certificate[] certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR); authRequired = certs != null && certs.length > 0; } if (authRequired) { if (log.isDebugEnabled()) { log.debug(" Calling authenticate()"); } if (!authenticate(request, response, config)) { if (log.isDebugEnabled()) { log.debug(" Failed authenticate() test"); } return; } } if (constraints != null) { if (log.isDebugEnabled()) { log.debug(" Calling accessControl()"); } if (!realm.hasResourcePermission(request, response, constraints, this.context)) { if (log.isDebugEnabled()) { log.debug(" Failed accessControl() test"); } return; } } if (log.isDebugEnabled()) { log.debug(" Successfully passed all security constraints"); } getNext().invoke(request, response); }
private static final Node createNodeInternal(String expr) throws ELException { if (expr == null) { throw new ELException(MessageFactory.get("error.null")); } Node n = cache.get(expr); if (n == null) { try { n = (new ELParser(new StringReader(expr))).CompositeExpression(); int numChildren = n.jjtGetNumChildren(); if (numChildren == 1) { n = n.jjtGetChild(0); } else { Class<?> type = null; Node child = null; for (int i = 0; i < numChildren; i++) { child = n.jjtGetChild(i); if (child instanceof AstLiteralExpression) continue; if (type == null) type = child.getClass(); else { if (!type.equals(child.getClass())) { throw new ELException(MessageFactory.get("error.mixed", expr)); } } } } if (n instanceof AstDeferredExpression || n instanceof AstDynamicExpression) { n = n.jjtGetChild(0); } cache.put(expr, n); } catch (ParseException pe) { throw new ELException("Error Parsing: " + expr, pe); } } return n; }
private void notFound(HttpServletResponse response) { try { response.sendError(HttpServletResponse.SC_NOT_FOUND); } catch (IllegalStateException e) { // Ignore } catch (IOException e) { // Ignore } }	@Override public final void event(Request request, Response response, CometEvent event) throws IOException, ServletException { Wrapper wrapper = request.getWrapper(); // Normal request processing // FIXME: Firing request listeners could be an addition to the core // comet API wrapper.getPipeline().getFirst().event(request, response, event); // context.fireRequestDestroyEvent(request); //} }	@Override public final void invoke(Request request, Response response) throws IOException, ServletException { MessageBytes requestPathMB = request.getRequestPathMB(); if ((requestPathMB.startsWithIgnoreCase("/META-INF/", 0)) || (requestPathMB.equalsIgnoreCase("/META-INF")) || (requestPathMB.startsWithIgnoreCase("/WEB-INF/", 0)) || (requestPathMB.equalsIgnoreCase("/WEB-INF"))) { notFound(response); return; } boolean reloaded = false; while (context.getPaused()) { reloaded = true; try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } } if (reloaded && context.getLoader() != null && context.getLoader().getClassLoader() != null) { Thread.currentThread().setContextClassLoader(context.getLoader().getClassLoader()); } Wrapper wrapper = request.getWrapper(); if (wrapper == null) { notFound(response); return; } else if (wrapper.isUnavailable()) { wrapper = (Wrapper) container.findChild(wrapper.getName()); if (wrapper == null) { notFound(response); return; } } // Don't fire listeners during async processing // If a request init listener throws an exception, the request is boolean asyncAtStart = request.isAsync(); if (asyncAtStart || context.fireRequestInitEvent(request)) { if (request.isAsyncSupported()) { request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported()); } wrapper.getPipeline().getFirst().invoke(request, response); if (!(request.isAsync() || (asyncAtStart && request.getAttribute(RequestDispatcher.ERROR_EXCEPTION) != null))) { context.fireRequestDestroyEvent(request); } } }	@Override public final void invoke(Request request, Response response) throws IOException, ServletException { boolean unavailable = false; Throwable throwable = null; long t1 = System.currentTimeMillis(); requestCount++; StandardWrapper wrapper = (StandardWrapper) getContainer(); Servlet servlet = null; Context context = (Context) wrapper.getParent(); if (!context.getAvailable()) { response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("standardContext.isUnavailable")); unavailable = true; } if (!unavailable && wrapper.isUnavailable()) { container.getLogger().info(sm.getString("standardWrapper.isUnavailable", wrapper.getName())); long available = wrapper.getAvailable(); if ((available > 0L) && (available < Long.MAX_VALUE)) { response.setDateHeader("Retry-After", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("standardWrapper.isUnavailable", wrapper.getName())); } else if (available == Long.MAX_VALUE) { response.sendError(HttpServletResponse.SC_NOT_FOUND, sm.getString("standardWrapper.notFound", wrapper.getName())); } unavailable = true; } try { if (!unavailable) { servlet = wrapper.allocate(); } } catch (UnavailableException e) { container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), e); long available = wrapper.getAvailable(); if ((available > 0L) && (available < Long.MAX_VALUE)) { response.setDateHeader("Retry-After", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("standardWrapper.isUnavailable", wrapper.getName())); } else if (available == Long.MAX_VALUE) { response.sendError(HttpServletResponse.SC_NOT_FOUND, sm.getString("standardWrapper.notFound", wrapper.getName())); } } catch (ServletException e) { container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), StandardWrapper.getRootCause(e)); throwable = e; exception(request, response, e); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), e); throwable = e; exception(request, response, e); servlet = null; } boolean comet = false; if (servlet instanceof CometProcessor && request.getAttribute("org.apache.tomcat.comet.support") == Boolean.TRUE) { comet = true; request.setComet(true); } try { response.sendAcknowledgement(); } catch (IOException e) { container.getLogger().warn(sm.getString("standardWrapper.acknowledgeException", wrapper.getName()), e); throwable = e; exception(request, response, e); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString("standardWrapper.acknowledgeException", wrapper.getName()), e); throwable = e; exception(request, response, e); servlet = null; } MessageBytes requestPathMB = request.getRequestPathMB(); DispatcherType dispatcherType = DispatcherType.REQUEST; if (request.getDispatcherType() == DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; request.setAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR, dispatcherType); request.setAttribute(ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB); ApplicationFilterFactory factory = ApplicationFilterFactory.getInstance(); ApplicationFilterChain filterChain = factory.createFilterChain(request, wrapper, servlet); request.setComet(false); try { if ((servlet != null) && (filterChain != null)) { if (context.getSwallowOutput()) { try { SystemLogHandler.startCapture(); if (request.isAsyncDispatching()) { ((AsyncContextImpl) request.getAsyncContext()).doInternalDispatch(); } else if (comet) { filterChain.doFilterEvent(request.getEvent()); request.setComet(true); } else { filterChain.doFilter(request.getRequest(), response.getResponse()); } } finally { String log = SystemLogHandler.stopCapture(); if (log != null && log.length() > 0) { context.getLogger().info(log); } } } else { if (request.isAsyncDispatching()) { ((AsyncContextImpl) request.getAsyncContext()).doInternalDispatch(); } else if (comet) { request.setComet(true); filterChain.doFilterEvent(request.getEvent()); } else { filterChain.doFilter(request.getRequest(), response.getResponse()); } } } } catch (ClientAbortException e) { throwable = e; exception(request, response, e); } catch (IOException e) { container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName(), context.getName()), e); throwable = e; exception(request, response, e); } catch (UnavailableException e) { container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName(), context.getName()), e); // throwable = e; wrapper.unavailable(e); long available = wrapper.getAvailable(); if ((available > 0L) && (available < Long.MAX_VALUE)) { response.setDateHeader("Retry-After", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("standardWrapper.isUnavailable", wrapper.getName())); } else if (available == Long.MAX_VALUE) { response.sendError(HttpServletResponse.SC_NOT_FOUND, sm.getString("standardWrapper.notFound", wrapper.getName())); } // Do not save exception in 'throwable', because we // do not want to do exception(request, response, e) processing } catch (ServletException e) { Throwable rootCause = StandardWrapper.getRootCause(e); if (!(rootCause instanceof ClientAbortException)) { container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot", wrapper.getName(), context.getName(), e.getMessage()), rootCause); } throwable = e; exception(request, response, e); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName(), context.getName()), e); throwable = e; exception(request, response, e); } if (filterChain != null) { if (request.isComet()) { // If this is a Comet request, then the same chain will be used for the filterChain.reuse(); } else { filterChain.release(); } } try { if (servlet != null) { wrapper.deallocate(servlet); } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString("standardWrapper.deallocateException", wrapper.getName()), e); if (throwable == null) { throwable = e; exception(request, response, e); } } try { if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) { wrapper.unload(); } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString("standardWrapper.unloadException", wrapper.getName()), e); if (throwable == null) { throwable = e; exception(request, response, e); } } long t2 = System.currentTimeMillis(); long time = t2 - t1; processingTime += time; if (time > maxTime) maxTime = time; if (time < minTime) minTime = time; }
private InstanceManager getInstanceManager() { if (instanceManager == null) { if (context instanceof StandardContext) { instanceManager = ((StandardContext) context).getInstanceManager(); } else { instanceManager = new DefaultInstanceManager(null, new HashMap<String, Map<String, String>>(), context, getClass().getClassLoader()); } } return instanceManager; }	@Override public ServletRequest getRequest() { return servletRequest; }	@Override public ServletResponse getResponse() { return servletResponse; }	@Override public boolean hasOriginalRequestAndResponse() { return hasOriginalRequestAndResponse; }	@Override public long getTimeout() { return timeout; }	@Override public void addListener(AsyncListener listener) { AsyncListenerWrapper wrapper = new AsyncListenerWrapper(); wrapper.setListener(listener); listeners.add(wrapper); }	@SuppressWarnings("unchecked") @Override public <T extends AsyncListener> T createListener(Class<T> clazz) throws ServletException { T listener = null; try { listener = (T) getInstanceManager().newInstance(clazz.getName(), clazz.getClassLoader()); } catch (InstantiationException e) { ServletException se = new ServletException(e); throw se; } catch (IllegalAccessException e) { ServletException se = new ServletException(e); throw se; } catch (InvocationTargetException e) { ServletException se = new ServletException(e); throw se; } catch (NamingException e) { ServletException se = new ServletException(e); throw se; } catch (ClassNotFoundException e) { ServletException se = new ServletException(e); throw se; } return listener; }	@Override public void complete() { if (log.isDebugEnabled()) { logDebug("complete "); } request.getCoyoteRequest().action(ActionCode.COMMIT, null); request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE, null); }	@Override public void dispatch() { HttpServletRequest sr = (HttpServletRequest) getRequest(); String path = sr.getRequestURI(); String cpath = sr.getContextPath(); if (cpath.length() > 1) path = path.substring(cpath.length()); dispatch(path); }	@Override public void dispatch(ServletContext context, String path) { if (log.isDebugEnabled()) { logDebug("dispatch "); } if (request.getAttribute(ASYNC_REQUEST_URI)==null) { request.setAttribute(ASYNC_REQUEST_URI, request.getRequestURI()+"?"+request.getQueryString()); request.setAttribute(ASYNC_CONTEXT_PATH, request.getContextPath()); request.setAttribute(ASYNC_SERVLET_PATH, request.getServletPath()); request.setAttribute(ASYNC_QUERY_STRING, request.getQueryString()); } final RequestDispatcher requestDispatcher = context.getRequestDispatcher(path); final HttpServletRequest servletRequest = (HttpServletRequest)getRequest(); final HttpServletResponse servletResponse = (HttpServletResponse)getResponse(); Runnable run = new Runnable() { @Override } }	@Override public void dispatch(String path) { dispatch(request.getServletContext(), path); }	public void recycle() { if (log.isDebugEnabled()) { logDebug("recycle "); } servletRequest = null; servletResponse = null; hasOriginalRequestAndResponse = true; context = null; timeout = -1; event = null; }	@Override public void setTimeout(long timeout) { this.timeout = timeout; request.getCoyoteRequest().action(ActionCode.ASYNC_SETTIMEOUT, Long.valueOf(timeout)); }	@Override public void start(final Runnable run) { if (log.isDebugEnabled()) { logDebug("start "); } Runnable wrapper = new RunnableWrapper(run, context); this.request.getCoyoteRequest().action(ActionCode.ASYNC_RUN, wrapper); }
protected Session getSessionForNameAndId(ContextName cn, String id, StringManager smClient) throws IOException { if ((cn == null) || !(cn.getPath().startsWith("/") || cn.getPath().equals(""))) { String path = null; if (cn != null) { path = cn.getPath(); } throw new IllegalArgumentException(smClient.getString("managerServlet.invalidPath", RequestUtil.filter(path))); } Context ctxt = (Context) host.findChild(cn.getName()); if (null == ctxt) { throw new IllegalArgumentException(smClient.getString("managerServlet.noContext", RequestUtil.filter(cn.getDisplayName()))); } Session session = ctxt.getManager().findSession(id); return session; }	protected List<Session> getSessionsForName(ContextName cn, StringManager smClient) { if ((cn == null) || !(cn.getPath().startsWith("/") || cn.getPath().equals(""))) { String path = null; if (cn != null) { path = cn.getPath(); } throw new IllegalArgumentException(smClient.getString("managerServlet.invalidPath", RequestUtil.filter(path))); } Context ctxt = (Context) host.findChild(cn.getName()); if (null == ctxt) { throw new IllegalArgumentException(smClient.getString("managerServlet.noContext", RequestUtil.filter(cn.getDisplayName()))); } Manager manager = ctxt.getManager(); List<Session> sessions = new ArrayList<Session>(); sessions.addAll(Arrays.asList(manager.findSessions())); if (manager instanceof DistributedManager && showProxySessions) { Set<String> sessionIds = ((DistributedManager) manager).getSessionIdsFull(); for (Session session : sessions) { sessionIds.remove(session.getId()); } for (String sessionId : sessionIds) { sessions.add(new DummyProxySession(sessionId)); } } return sessions; }
public Context addWebapp(Host host, String url, String name, String path) { silence(url); Context ctx = new StandardContext(); ctx.setName(name); ctx.setPath(url); ctx.setDocBase(path); if (defaultRealm == null) { initSimpleAuth(); } ctx.setRealm(defaultRealm); ctx.addLifecycleListener(new DefaultWebXmlListener()); ContextConfig ctxCfg = new ContextConfig(); ctx.addLifecycleListener(ctxCfg); ctxCfg.setDefaultWebXml("org/apache/catalin/startup/NO_DEFAULT_XML"); if (host == null) { getHost().addChild(ctx); } else { host.addChild(ctx); } return ctx; }
private void configure() { Timestamp ts = new Timestamp(System.currentTimeMillis()); String tsString = ts.toString().substring(0, 19); date = tsString.substring(0, 10); String className = this.getClass().getName(); ClassLoader cl = Thread.currentThread().getContextClassLoader(); rotatable = Boolean.parseBoolean(getProperty(className + ".rotatable", "true")); if (directory == null) directory = getProperty(className + ".directory", "logs"); if (prefix == null) prefix = getProperty(className + ".prefix", "juli."); if (suffix == null) suffix = getProperty(className + ".suffix", ".log"); String sBufferSize = getProperty(className + ".bufferSize", String.valueOf(bufferSize)); try { bufferSize = Integer.parseInt(sBufferSize); } catch (NumberFormatException ignore) { //no op } String encoding = getProperty(className + ".encoding", null); if (encoding != null && encoding.length() > 0) { try { setEncoding(encoding); } catch (UnsupportedEncodingException ex) { // Ignore } } setLevel(Level.parse(getProperty(className + ".level", "" + Level.ALL))); String filterName = getProperty(className + ".filter", null); if (filterName != null) { try { setFilter((Filter) cl.loadClass(filterName).newInstance()); } catch (Exception e) { // Ignore } } String formatterName = getProperty(className + ".formatter", null); if (formatterName != null) { try { setFormatter((Formatter) cl.loadClass(formatterName).newInstance()); } catch (Exception e) { // Ignore } } else { setFormatter(new SimpleFormatter()); } setErrorManager(new ErrorManager()); }
@Override public void addRuleInstances(Digester digester) { sessionConfig = new SetSessionConfig(); jspConfig = new SetJspConfig(); loginConfig = new SetLoginConfig(); digester.addRule(fullPrefix, new SetPublicIdRule("setPublicId")); digester.addRule(fullPrefix, new IgnoreAnnotationsRule()); digester.addRule(fullPrefix, new VersionRule()); if (fragment) { digester.addCallMethod(fullPrefix + "/name", "setName", 0); digester.addRule(fullPrefix + "/absolute-ordering", new AbsoluteOrderingRule()); digester.addCallMethod(fullPrefix + "/ordering/after/name", "addAfterOrdering", 0); digester.addCallMethod(fullPrefix + "/ordering/after/others", "addAfterOrderingOthers"); digester.addCallMethod(fullPrefix + "/ordering/before/name", "addBeforeOrdering", 0); digester.addCallMethod(fullPrefix + "/ordering/before/others", "addBeforeOrderingOthers"); } else { digester.addRule(fullPrefix + "/ordering", new RelativeOrderingRule()); digester.addCallMethod(fullPrefix + "/absolute-ordering/name", "addAbsoluteOrdering", 0); digester.addCallMethod(fullPrefix + "/absolute-ordering/name/others", "addAbsoluteOrderingOthers"); } digester.addCallMethod(fullPrefix + "/context-param", "addContextParam", 2); digester.addCallParam(fullPrefix + "/context-param/param-name", 0); digester.addCallParam(fullPrefix + "/context-param/param-value", 1); digester.addCallMethod(fullPrefix + "/display-name", "setDisplayName", 0); digester.addRule(fullPrefix + "/distributable", new SetDistributableRule()); configureNamingRules(digester); digester.addObjectCreate(fullPrefix + "/error-page", "org.apache.catalina.deploy.ErrorPage"); digester.addSetNext(fullPrefix + "/error-page", "addErrorPage", "org.apache.catalina.deploy.ErrorPage"); digester.addCallMethod(fullPrefix + "/error-page/error-code", "setErrorCode", 0); digester.addCallMethod(fullPrefix + "/error-page/exception-type", "setExceptionType", 0); digester.addCallMethod(fullPrefix + "/error-page/location", "setLocation", 0); digester.addObjectCreate(fullPrefix + "/filter", "org.apache.catalina.deploy.FilterDef"); digester.addSetNext(fullPrefix + "/filter", "addFilter", "org.apache.catalina.deploy.FilterDef"); digester.addCallMethod(fullPrefix + "/filter/description", "setDescription", 0); digester.addCallMethod(fullPrefix + "/filter/display-name", "setDisplayName", 0); digester.addCallMethod(fullPrefix + "/filter/filter-class", "setFilterClass", 0); digester.addCallMethod(fullPrefix + "/filter/filter-name", "setFilterName", 0); digester.addCallMethod(fullPrefix + "/filter/icon/large-icon", "setLargeIcon", 0); digester.addCallMethod(fullPrefix + "/filter/icon/small-icon", "setSmallIcon", 0); digester.addCallMethod(fullPrefix + "/filter/async-supported", "setAsyncSupported", 0); digester.addCallMethod(fullPrefix + "/filter/init-param", "addInitParameter", 2); digester.addCallParam(fullPrefix + "/filter/init-param/param-name", 0); digester.addCallParam(fullPrefix + "/filter/init-param/param-value", 1); digester.addObjectCreate(fullPrefix + "/filter-mapping", "org.apache.catalina.deploy.FilterMap"); digester.addSetNext(fullPrefix + "/filter-mapping", "addFilterMapping", "org.apache.catalina.deploy.FilterMap"); digester.addCallMethod(fullPrefix + "/filter-mapping/filter-name", "setFilterName", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/servlet-name", "addServletName", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/url-pattern", "addURLPattern", 0); digester.addCallMethod(fullPrefix + "/filter-mapping/dispatcher", "setDispatcher", 0); digester.addCallMethod(fullPrefix + "/listener/listener-class", "addListener", 0); digester.addRule(fullPrefix + "/jsp-config", jspConfig); digester.addObjectCreate(fullPrefix + "/jsp-config/jsp-property-group", "org.apache.catalina.deploy.JspPropertyGroup"); digester.addSetNext(fullPrefix + "/jsp-config/jsp-property-group", "addJspPropertyGroup", "org.apache.catalina.deploy.JspPropertyGroup"); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/deferred-syntax-allowed-as-literal", "setDeferredSyntax", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/el-ignored", "setElIgnored", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/include-coda", "addIncludeCoda", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/include-prelude", "addIncludePrelude", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/is-xml", "setIsXml", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/page-encoding", "setPageEncoding", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/scripting-invalid", "setScriptingInvalid", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/trim-directive-whitespaces", "setTrimWhitespace", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/url-pattern", "setUrlPattern", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/default-content-type", "setDefaultContentType", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/buffer", "setBuffer", 0); digester.addCallMethod(fullPrefix + "/jsp-config/jsp-property-group/error-on-undeclared-namespace", "setErrorOnUndeclaredNamespace", 0); digester.addRule(fullPrefix + "/login-config", loginConfig); digester.addObjectCreate(fullPrefix + "/login-config", "org.apache.catalina.deploy.LoginConfig"); digester.addSetNext(fullPrefix + "/login-config", "setLoginConfig", "org.apache.catalina.deploy.LoginConfig"); digester.addCallMethod(fullPrefix + "/login-config/auth-method", "setAuthMethod", 0); digester.addCallMethod(fullPrefix + "/login-config/realm-name", "setRealmName", 0); digester.addCallMethod(fullPrefix + "/login-config/form-login-config/form-error-page", "setErrorPage", 0); digester.addCallMethod(fullPrefix + "/login-config/form-login-config/form-login-page", "setLoginPage", 0); digester.addCallMethod(fullPrefix + "/mime-mapping", "addMimeMapping", 2); digester.addCallParam(fullPrefix + "/mime-mapping/extension", 0); digester.addCallParam(fullPrefix + "/mime-mapping/mime-type", 1); digester.addObjectCreate(fullPrefix + "/security-constraint", "org.apache.catalina.deploy.SecurityConstraint"); digester.addSetNext(fullPrefix + "/security-constraint", "addSecurityConstraint", "org.apache.catalina.deploy.SecurityConstraint"); digester.addRule(fullPrefix + "/security-constraint/auth-constraint", new SetAuthConstraintRule()); digester.addCallMethod(fullPrefix + "/security-constraint/auth-constraint/role-name", "addAuthRole", 0); digester.addCallMethod(fullPrefix + "/security-constraint/display-name", "setDisplayName", 0); digester.addCallMethod(fullPrefix + "/security-constraint/user-data-constraint/transport-guarantee", "setUserConstraint", 0); digester.addObjectCreate(fullPrefix + "/security-constraint/web-resource-collection", "org.apache.catalina.deploy.SecurityCollection"); digester.addSetNext(fullPrefix + "/security-constraint/web-resource-collection", "addCollection", "org.apache.catalina.deploy.SecurityCollection"); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/http-method", "addMethod", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/http-method-omission", "addOmittedMethod", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/url-pattern", "addPattern", 0); digester.addCallMethod(fullPrefix + "/security-constraint/web-resource-collection/web-resource-name", "setName", 0); digester.addCallMethod(fullPrefix + "/security-role/role-name", "addSecurityRole", 0); digester.addRule(fullPrefix + "/servlet", new ServletDefCreateRule()); digester.addSetNext(fullPrefix + "/servlet", "addServlet", "org.apache.catalina.deploy.ServletDef"); digester.addCallMethod(fullPrefix + "/servlet/init-param", "addInitParameter", 2); digester.addCallParam(fullPrefix + "/servlet/init-param/param-name", 0); digester.addCallParam(fullPrefix + "/servlet/init-param/param-value", 1); digester.addCallMethod(fullPrefix + "/servlet/jsp-file", "setJspFile", 0); digester.addCallMethod(fullPrefix + "/servlet/load-on-startup", "setLoadOnStartup", 0); digester.addCallMethod(fullPrefix + "/servlet/run-as/role-name", "setRunAs", 0); digester.addCallMethod(fullPrefix + "/servlet/security-role-ref", "addSecurityRoleRef", 2); digester.addCallParam(fullPrefix + "/servlet/security-role-ref/role-link", 1); digester.addCallParam(fullPrefix + "/servlet/security-role-ref/role-name", 0); digester.addCallMethod(fullPrefix + "/servlet/servlet-class", "setServletClass", 0); digester.addCallMethod(fullPrefix + "/servlet/servlet-name", "setServletName", 0); digester.addObjectCreate(fullPrefix + "/servlet/multipart-config", "org.apache.catalina.deploy.MultipartDef"); digester.addSetNext(fullPrefix + "/servlet/multipart-config", "setMultipartDef", "org.apache.catalina.deploy.MultipartDef"); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/location", "setLocation", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/max-file-size", "setMaxFileSize", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/max-request-size", "setMaxRequestSize", 0); digester.addCallMethod(fullPrefix + "/servlet/multipart-config/file-size-threshold", "setFileSizeThreshold", 0); digester.addCallMethod(fullPrefix + "/servlet/async-supported", "setAsyncSupported", 0); digester.addCallMethod(fullPrefix + "/servlet/enabled", "setEnabled", 0); digester.addRule(fullPrefix + "/servlet-mapping", new CallMethodMultiRule("addServletMapping", 2, 0)); digester.addCallParam(fullPrefix + "/servlet-mapping/servlet-name", 1); digester.addRule(fullPrefix + "/servlet-mapping/url-pattern", new CallParamMultiRule(0)); digester.addRule(fullPrefix + "/session-config", sessionConfig); digester.addObjectCreate(fullPrefix + "/session-config", "org.apache.catalina.deploy.SessionConfig"); digester.addSetNext(fullPrefix + "/session-config", "setSessionConfig", "org.apache.catalina.deploy.SessionConfig"); digester.addCallMethod(fullPrefix + "/session-config/session-timeout", "setSessionTimeout", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/name", "setCookieName", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/domain", "setCookieDomain", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/path", "setCookiePath", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/comment", "setCookieComment", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/http-only", "setCookieHttpOnly", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/secure", "setCookieSecure", 0); digester.addCallMethod(fullPrefix + "/session-config/cookie-config/max-age", "setCookieMaxAge", 0); digester.addCallMethod(fullPrefix + "/session-config/tracking-mode", "addSessionTrackingMode", 0); digester.addRule(fullPrefix + "/taglib", new TaglibLocationRule(false)); digester.addCallMethod(fullPrefix + "/taglib", "addTaglib", 2); digester.addCallParam(fullPrefix + "/taglib/taglib-location", 1); digester.addCallParam(fullPrefix + "/taglib/taglib-uri", 0); digester.addRule(fullPrefix + "/jsp-config/taglib", new TaglibLocationRule(true)); digester.addCallMethod(fullPrefix + "/jsp-config/taglib", "addTaglib", 2); digester.addCallParam(fullPrefix + "/jsp-config/taglib/taglib-location", 1); digester.addCallParam(fullPrefix + "/jsp-config/taglib/taglib-uri", 0); digester.addCallMethod(fullPrefix + "/welcome-file-list/welcome-file", "addWelcomeFile", 0); digester.addCallMethod(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping", "addLocaleEncodingMapping", 2); digester.addCallParam(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping/locale", 0); digester.addCallParam(fullPrefix + "/locale-encoding-mapping-list/locale-encoding-mapping/encoding", 1); }
private void convertJsp(ServletDef servletDef, ServletDef jspServletDef) { servletDef.setServletClass(org.apache.catalina.core.Constants.JSP_SERVLET_CLASS); String jspFile = servletDef.getJspFile(); if ((jspFile != null) && !jspFile.startsWith("/")) { if (context.isServlet22()) { if (log.isDebugEnabled()) log.debug(sm.getString("contextConfig.jspFile.warning", jspFile)); jspFile = "/" + jspFile; } else { throw new IllegalArgumentException(sm.getString("contextConfig.jspFile.error", jspFile)); } } servletDef.getParameterMap().put("jspFile", jspFile); servletDef.setJspFile(null); for (Map.Entry<String, String> initParam : jspServletDef.getParameterMap().entrySet()) { servletDef.addInitParameter(initParam.getKey(), initParam.getValue()); } }	private void convertJsps(WebXml webXml) { ServletDef jspServlet = webXml.getServlets().get("jsp"); for (ServletDef servletDef : webXml.getServlets().values()) { if (servletDef.getJspFile() != null) { convertJsp(servletDef, jspServlet); } } }	private void doTestOverrideDefaultServletWithSCI(String servletName) throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("test/webapp-3.0"); StandardContext ctxt = (StandardContext) tomcat.addContext(null, "/test", appDir.getAbsolutePath()); ctxt.setDefaultWebXml(new File("conf/web.xml").getAbsolutePath()); ctxt.addLifecycleListener(new ContextConfig()); ctxt.addServletContainerInitializer(new CustomDefaultServletSCI(servletName), null); tomcat.start(); ByteChunk res = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/test", res, null); assertEquals(HttpServletResponse.SC_OK, rc); assertEquals("OK - Custom default Servlet", res.toString()); }
private AccessLogElement createAccessLogElement(String header, char pattern) { switch(pattern) { case 'i': return new HeaderElement(header); case 'c': return new CookieElement(header); case 'o': return new ResponseHeaderElement(header); case 'r': return new RequestAttributeElement(header); case 's': return new SessionAttributeElement(header); default: return new StringElement("???"); } }	protected synchronized void open() { File dir = new File(directory); if (!dir.isAbsolute()) dir = new File(System.getProperty(Globals.CATALINA_BASE_PROP), directory); if (!dir.exists()) { if (!dir.mkdirs()) { log.error(sm.getString("accessLogValve.openDirFail", dir)); } } try { String pathname; if (rotatable) { pathname = dir.getAbsolutePath() + File.separator + prefix + dateStamp + suffix; } else { pathname = dir.getAbsolutePath() + File.separator + prefix + suffix; } writer = new PrintWriter(new BufferedWriter(new FileWriter(pathname, true), 128000), false); currentLogFile = new File(pathname); } catch (IOException e) { writer = null; currentLogFile = null; } }	@Override protected synchronized void startInternal() throws LifecycleException { String format = getFileDateFormat(); if (format == null || format.length() == 0) { format = "yyyy-MM-dd"; setFileDateFormat(format); } fileDateFormatter = new SimpleDateFormat(format); fileDateFormatter.setTimeZone(timezone); dateStamp = fileDateFormatter.format(currentDateStruct.get().currentDate); open(); setState(LifecycleState.STARTING); }	protected AccessLogElement[] createLogElements() { List<AccessLogElement> list = new ArrayList<AccessLogElement>(); boolean replace = false; StringBuilder buf = new StringBuilder(); for (int i = 0; i < pattern.length(); i++) { char ch = pattern.charAt(i); if (replace) { if ('{' == ch) { StringBuilder name = new StringBuilder(); int j = i + 1; for (; j < pattern.length() && '}' != pattern.charAt(j); j++) { name.append(pattern.charAt(j)); } if (j + 1 < pattern.length()) { j++; list.add(createAccessLogElement(name.toString(), pattern.charAt(j))); i = j; /* Since we walked more than one character */ } else { // D'oh - end of string - pretend we never did this list.add(createAccessLogElement(ch)); } } else { list.add(createAccessLogElement(ch)); } replace = false; } else if (ch == '%') { replace = true; list.add(new StringElement(buf.toString())); buf = new StringBuilder(); } else { buf.append(ch); } } if (buf.length() > 0) { list.add(new StringElement(buf.toString())); } return list.toArray(new AccessLogElement[0]); }	@Override public void log(Request request, Response response, long time) { if (!getState().isAvailable() || !getEnabled() || logElements == null || condition != null && null != request.getRequest().getAttribute(condition)) { return; } Date date = getDate(); StringBuilder result = new StringBuilder(128); for (int i = 0; i < logElements.length; i++) { logElements[i].addElement(result, date, request, response, time); } log(result.toString()); }
protected void checkHandlesTypes(JavaClass javaClass) { if (typeInitializerMap.size() == 0) return; String className = javaClass.getClassName(); Class<?> clazz = null; try { clazz = context.getLoader().getClassLoader().loadClass(className); } catch (NoClassDefFoundError e) { log.debug(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (ClassNotFoundException e) { log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (ClassFormatError e) { log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } if (clazz.isAnnotation()) { return; } boolean match = false; for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry : typeInitializerMap.entrySet()) { if (entry.getKey().isAnnotation()) { AnnotationEntry[] annotationEntries = javaClass.getAnnotationEntries(); for (AnnotationEntry annotationEntry : annotationEntries) { if (entry.getKey().getName().equals(getClassName(annotationEntry.getAnnotationType()))) { match = true; break; } } } else if (entry.getKey().isAssignableFrom(clazz)) { match = true; } if (match) { for (ServletContainerInitializer sci : entry.getValue()) { initializerClassMap.get(sci).add(clazz); } } } }	public void testDuplicateFilterMapping() throws Exception { WebXml webxml = new WebXml(); ContextConfig config = new ContextConfig(); File pFile = paramClassResource("org/apache/catalina/startup/DuplicateMappingParamFilter"); assertTrue(pFile.exists()); try { config.processAnnotationsFile(pFile, webxml); fail(); } catch (IllegalArgumentException ex) { // ignore } FilterDef filterDef = webxml.getFilters().get("paramD"); assertNull(filterDef); }
public String toString() { return left + " " + right + " OR"; }
protected void list(HttpServletRequest request, HttpServletResponse response, String message, StringManager smClient) throws IOException { if (debug >= 1) log("list: Listing contexts for virtual host '" + host.getName() + "'"); PrintWriter writer = response.getWriter(); writer.print(Constants.HTML_HEADER_SECTION); Object[] args = new Object[2]; args[0] = request.getContextPath(); args[1] = smClient.getString("htmlManagerServlet.title"); writer.print(MessageFormat.format(Constants.BODY_HEADER_SECTION, args)); args = new Object[3]; args[0] = smClient.getString("htmlManagerServlet.messageLabel"); if (message == null || message.length() == 0) { args[1] = "OK"; } else { args[1] = RequestUtil.filter(message); } writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args)); args = new Object[9]; args[0] = smClient.getString("htmlManagerServlet.manager"); args[1] = response.encodeURL(request.getContextPath() + "/html/list"); args[2] = smClient.getString("htmlManagerServlet.list"); args[3] = response.encodeURL(request.getContextPath() + "/" + smClient.getString("htmlManagerServlet.helpHtmlManagerFile")); args[4] = smClient.getString("htmlManagerServlet.helpHtmlManager"); args[5] = response.encodeURL(request.getContextPath() + "/" + smClient.getString("htmlManagerServlet.helpManagerFile")); args[6] = smClient.getString("htmlManagerServlet.helpManager"); args[7] = response.encodeURL(request.getContextPath() + "/status"); args[8] = smClient.getString("statusServlet.title"); writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args)); args = new Object[7]; args[0] = smClient.getString("htmlManagerServlet.appsTitle"); args[1] = smClient.getString("htmlManagerServlet.appsPath"); args[2] = smClient.getString("htmlManagerServlet.appsVersion"); args[3] = smClient.getString("htmlManagerServlet.appsName"); args[4] = smClient.getString("htmlManagerServlet.appsAvailable"); args[5] = smClient.getString("htmlManagerServlet.appsSessions"); args[6] = smClient.getString("htmlManagerServlet.appsTasks"); writer.print(MessageFormat.format(APPS_HEADER_SECTION, args)); // Apps Row Section Container[] children = host.findChildren(); String[] contextNames = new String[children.length]; for (int i = 0; i < children.length; i++) contextNames[i] = children[i].getName(); Arrays.sort(contextNames); String appsStart = smClient.getString("htmlManagerServlet.appsStart"); String appsStop = smClient.getString("htmlManagerServlet.appsStop"); String appsReload = smClient.getString("htmlManagerServlet.appsReload"); String appsUndeploy = smClient.getString("htmlManagerServlet.appsUndeploy"); String appsExpire = smClient.getString("htmlManagerServlet.appsExpire"); String noVersion = "<i>" + smClient.getString("htmlManagerServlet.noVersion") + "</i>"; boolean isHighlighted = true; boolean isDeployed = true; String highlightColor = null; for (String contextName : contextNames) { Context ctxt = (Context) host.findChild(contextName); if (ctxt != null) { isHighlighted = !isHighlighted; if (isHighlighted) { highlightColor = "#C3F3C3"; } else { highlightColor = "#FFFFFF"; } String contextPath = ctxt.getPath(); String displayPath = contextPath; if (displayPath.equals("")) { displayPath = "/"; } StringBuilder tmp = new StringBuilder(); tmp.append("path="); tmp.append(URL_ENCODER.encode(displayPath)); if (ctxt.getWebappVersion().length() > 0) { tmp.append("&version="); tmp.append(URL_ENCODER.encode(ctxt.getWebappVersion())); } String pathVersion = tmp.toString(); try { isDeployed = isDeployed(contextName); } catch (Exception e) { isDeployed = false; } args = new Object[7]; args[0] = "<a href=\"" + URL_ENCODER.encode(displayPath) + "\">" + RequestUtil.filter(displayPath) + "</a>"; if ("".equals(ctxt.getWebappVersion())) { args[1] = noVersion; } else { args[1] = RequestUtil.filter(ctxt.getWebappVersion()); } if (ctxt.getDisplayName() == null) { args[2] = "&nbsp;"; } else { args[2] = RequestUtil.filter(ctxt.getDisplayName()); } args[3] = Boolean.valueOf(ctxt.getAvailable()); args[4] = RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/sessions?" + pathVersion)); Manager manager = ctxt.getManager(); if (manager instanceof DistributedManager && showProxySessions) { args[5] = Integer.valueOf(((DistributedManager) manager).getActiveSessionsFull()); } else if (ctxt.getManager() != null) { args[5] = Integer.valueOf(manager.getActiveSessions()); } else { args[5] = Integer.valueOf(0); } args[6] = highlightColor; writer.print(MessageFormat.format(APPS_ROW_DETAILS_SECTION, args)); args = new Object[14]; args[0] = RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/start?" + pathVersion)); args[1] = appsStart; args[2] = RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/stop?" + pathVersion)); args[3] = appsStop; args[4] = RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/reload?" + pathVersion)); args[5] = appsReload; args[6] = RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/undeploy?" + pathVersion)); args[7] = appsUndeploy; args[8] = RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/expire?" + pathVersion)); args[9] = appsExpire; args[10] = smClient.getString("htmlManagerServlet.expire.explain"); if (manager == null) { args[11] = smClient.getString("htmlManagerServlet.noManager"); } else { args[11] = Integer.valueOf(ctxt.getManager().getMaxInactiveInterval() / 60); } args[12] = smClient.getString("htmlManagerServlet.expire.unit"); args[13] = highlightColor; if (ctxt.getName().equals(this.context.getName())) { writer.print(MessageFormat.format(MANAGER_APP_ROW_BUTTON_SECTION, args)); } else if (ctxt.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STARTED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (ctxt.getAvailable() && !isDeployed) { writer.print(MessageFormat.format(STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (!ctxt.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STOPPED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else { writer.print(MessageFormat.format(STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } } } args = new Object[7]; args[0] = smClient.getString("htmlManagerServlet.deployTitle"); args[1] = smClient.getString("htmlManagerServlet.deployServer"); args[2] = response.encodeURL(request.getContextPath() + "/html/deploy"); args[3] = smClient.getString("htmlManagerServlet.deployPath"); args[4] = smClient.getString("htmlManagerServlet.deployConfig"); args[5] = smClient.getString("htmlManagerServlet.deployWar"); args[6] = smClient.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(DEPLOY_SECTION, args)); args = new Object[4]; args[0] = smClient.getString("htmlManagerServlet.deployUpload"); args[1] = response.encodeURL(request.getContextPath() + "/html/upload"); args[2] = smClient.getString("htmlManagerServlet.deployUploadFile"); args[3] = smClient.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(UPLOAD_SECTION, args)); args = new Object[5]; args[0] = smClient.getString("htmlManagerServlet.diagnosticsTitle"); args[1] = smClient.getString("htmlManagerServlet.diagnosticsLeak"); args[2] = response.encodeURL(request.getContextPath() + "/html/findleaks"); args[3] = smClient.getString("htmlManagerServlet.diagnosticsLeakWarning"); args[4] = smClient.getString("htmlManagerServlet.diagnosticsLeakButton"); writer.print(MessageFormat.format(DIAGNOSTICS_SECTION, args)); args = new Object[7]; args[0] = smClient.getString("htmlManagerServlet.serverTitle"); args[1] = smClient.getString("htmlManagerServlet.serverVersion"); args[2] = smClient.getString("htmlManagerServlet.serverJVMVersion"); args[3] = smClient.getString("htmlManagerServlet.serverJVMVendor"); args[4] = smClient.getString("htmlManagerServlet.serverOSName"); args[5] = smClient.getString("htmlManagerServlet.serverOSVersion"); args[6] = smClient.getString("htmlManagerServlet.serverOSArch"); writer.print(MessageFormat.format(Constants.SERVER_HEADER_SECTION, args)); args = new Object[6]; args[0] = ServerInfo.getServerInfo(); args[1] = System.getProperty("java.runtime.version"); args[2] = System.getProperty("java.vm.vendor"); args[3] = System.getProperty("os.name"); args[4] = System.getProperty("os.version"); args[5] = System.getProperty("os.arch"); writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args)); writer.print(Constants.HTML_TAIL_SECTION); writer.flush(); writer.close(); }	@Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { int mode = 0; if (request.getParameter("XML") != null && request.getParameter("XML").equals("true")) { mode = 1; } StatusTransformer.setContentType(response, mode); PrintWriter writer = response.getWriter(); boolean completeStatus = false; if ((request.getPathInfo() != null) && (request.getPathInfo().equals("/all"))) { completeStatus = true; } Object[] args = new Object[1]; args[0] = request.getContextPath(); StatusTransformer.writeHeader(writer, args, mode); args = new Object[2]; args[0] = request.getContextPath(); if (completeStatus) { args[1] = sm.getString("statusServlet.complete"); } else { args[1] = sm.getString("statusServlet.title"); } StatusTransformer.writeBody(writer, args, mode); args = new Object[9]; args[0] = sm.getString("htmlManagerServlet.manager"); args[1] = response.encodeURL(request.getContextPath() + "/html/list"); args[2] = sm.getString("htmlManagerServlet.list"); args[3] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpHtmlManagerFile")); args[4] = sm.getString("htmlManagerServlet.helpHtmlManager"); args[5] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpManagerFile")); args[6] = sm.getString("htmlManagerServlet.helpManager"); if (completeStatus) { args[7] = response.encodeURL(request.getContextPath() + "/status"); args[8] = sm.getString("statusServlet.title"); } else { args[7] = response.encodeURL(request.getContextPath() + "/status/all"); args[8] = sm.getString("statusServlet.complete"); } StatusTransformer.writeManager(writer, args, mode); args = new Object[7]; args[0] = sm.getString("htmlManagerServlet.serverTitle"); args[1] = sm.getString("htmlManagerServlet.serverVersion"); args[2] = sm.getString("htmlManagerServlet.serverJVMVersion"); args[3] = sm.getString("htmlManagerServlet.serverJVMVendor"); args[4] = sm.getString("htmlManagerServlet.serverOSName"); args[5] = sm.getString("htmlManagerServlet.serverOSVersion"); args[6] = sm.getString("htmlManagerServlet.serverOSArch"); StatusTransformer.writePageHeading(writer, args, mode); args = new Object[6]; args[0] = ServerInfo.getServerInfo(); args[1] = System.getProperty("java.runtime.version"); args[2] = System.getProperty("java.vm.vendor"); args[3] = System.getProperty("os.name"); args[4] = System.getProperty("os.version"); args[5] = System.getProperty("os.arch"); StatusTransformer.writeServerInfo(writer, args, mode); try { StatusTransformer.writeOSState(writer, mode); StatusTransformer.writeVMState(writer, mode); Enumeration<ObjectName> enumeration = threadPools.elements(); while (enumeration.hasMoreElements()) { ObjectName objectName = enumeration.nextElement(); String name = objectName.getKeyProperty("name"); StatusTransformer.writeConnectorState(writer, objectName, name, mBeanServer, globalRequestProcessors, requestProcessors, mode); } if ((request.getPathInfo() != null) && (request.getPathInfo().equals("/all"))) { // Note: Retrieving the full status is much slower StatusTransformer.writeDetailedState(writer, mBeanServer, mode); } } catch (Exception e) { throw new ServletException(e); } StatusTransformer.writeFooter(writer, mode); }
protected void handleSESSION_CREATED(SessionMessage msg, Member sender) { counterReceive_EVT_SESSION_CREATED++; if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.createNewSession", getName(), msg.getSessionID())); DeltaSession session = (DeltaSession) createEmptySession(); session.setManager(this); session.setValid(true); session.setPrimarySession(false); session.setCreationTime(msg.getTimestamp()); session.setMaxInactiveInterval(getMaxInactiveInterval()); session.access(); session.setId(msg.getSessionID(), notifySessionListenersOnReplication); session.resetDeltaRequest(); session.endAccess(); }	public void expire(boolean notify, boolean notifyCluster) { if (expiring) return; String expiredId = getIdInternal(); if (expiredId != null && manager != null && manager instanceof DeltaManager) { DeltaManager dmanager = (DeltaManager) manager; CatalinaCluster cluster = dmanager.getCluster(); ClusterMessage msg = dmanager.requestCompleted(expiredId, true); if (msg != null) { cluster.send(msg); } } super.expire(notify); if (notifyCluster) { if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.notifying", ((ClusterManager) manager).getName(), Boolean.valueOf(isPrimarySession()), expiredId)); if (manager instanceof DeltaManager) { ((DeltaManager) manager).sessionExpired(expiredId); } } }
protected void doLock(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { if (readOnly) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return; } if (isLocked(req)) { resp.sendError(WebdavStatus.SC_LOCKED); return; } LockInfo lock = new LockInfo(); // Parsing lock request String depthStr = req.getHeader("Depth"); if (depthStr == null) { lock.depth = maxDepth; } else { if (depthStr.equals("0")) { lock.depth = 0; } else { lock.depth = maxDepth; } } int lockDuration = DEFAULT_TIMEOUT; String lockDurationStr = req.getHeader("Timeout"); if (lockDurationStr == null) { lockDuration = DEFAULT_TIMEOUT; } else { int commaPos = lockDurationStr.indexOf(","); if (commaPos != -1) { lockDurationStr = lockDurationStr.substring(0, commaPos); } if (lockDurationStr.startsWith("Second-")) { lockDuration = (new Integer(lockDurationStr.substring(7))).intValue(); } else { if (lockDurationStr.equalsIgnoreCase("infinity")) { lockDuration = MAX_TIMEOUT; } else { try { lockDuration = (new Integer(lockDurationStr)).intValue(); } catch (NumberFormatException e) { lockDuration = MAX_TIMEOUT; } } } if (lockDuration == 0) { lockDuration = DEFAULT_TIMEOUT; } if (lockDuration > MAX_TIMEOUT) { lockDuration = MAX_TIMEOUT; } } lock.expiresAt = System.currentTimeMillis() + (lockDuration * 1000); int lockRequestType = LOCK_CREATION; Node lockInfoNode = null; DocumentBuilder documentBuilder = getDocumentBuilder(); try { Document document = documentBuilder.parse(new InputSource(req.getInputStream())); Element rootElement = document.getDocumentElement(); lockInfoNode = rootElement; } catch (IOException e) { lockRequestType = LOCK_REFRESH; } catch (SAXException e) { lockRequestType = LOCK_REFRESH; } if (lockInfoNode != null) { NodeList childList = lockInfoNode.getChildNodes(); StringWriter strWriter = null; DOMWriter domWriter = null; Node lockScopeNode = null; Node lockTypeNode = null; Node lockOwnerNode = null; for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: String nodeName = currentNode.getNodeName(); if (nodeName.endsWith("lockscope")) { lockScopeNode = currentNode; } if (nodeName.endsWith("locktype")) { lockTypeNode = currentNode; } if (nodeName.endsWith("owner")) { lockOwnerNode = currentNode; } break; } } if (lockScopeNode != null) { childList = lockScopeNode.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: String tempScope = currentNode.getNodeName(); if (tempScope.indexOf(':') != -1) { lock.scope = tempScope.substring(tempScope.indexOf(':') + 1); } else { lock.scope = tempScope; } break; } } if (lock.scope == null) { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } } else { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } if (lockTypeNode != null) { childList = lockTypeNode.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: String tempType = currentNode.getNodeName(); if (tempType.indexOf(':') != -1) { lock.type = tempType.substring(tempType.indexOf(':') + 1); } else { lock.type = tempType; } break; } } if (lock.type == null) { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } } else { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } if (lockOwnerNode != null) { childList = lockOwnerNode.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: lock.owner += currentNode.getNodeValue(); break; case Node.ELEMENT_NODE: strWriter = new StringWriter(); domWriter = new DOMWriter(strWriter, true); domWriter.setQualifiedNames(false); domWriter.print(currentNode); lock.owner += strWriter.toString(); break; } } if (lock.owner == null) { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } } else { lock.owner = ""; } } String path = getRelativePath(req); lock.path = path; boolean exists = true; Object object = null; try { object = resources.lookup(path); } catch (NamingException e) { exists = false; } Enumeration<LockInfo> locksList = null; if (lockRequestType == LOCK_CREATION) { String lockTokenStr = req.getServletPath() + "-" + lock.type + "-" + lock.scope + "-" + req.getUserPrincipal() + "-" + lock.depth + "-" + lock.owner + "-" + lock.tokens + "-" + lock.expiresAt + "-" + System.currentTimeMillis() + "-" + secret; String lockToken = md5Encoder.encode(md5Helper.digest(lockTokenStr.getBytes())); if ((exists) && (object instanceof DirContext) && (lock.depth == maxDepth)) { // Locking a collection (and all its member resources) // Checking if a child resource of this collection is Vector<String> lockPaths = new Vector<String>(); locksList = collectionLocks.elements(); while (locksList.hasMoreElements()) { LockInfo currentLock = locksList.nextElement(); if (currentLock.hasExpired()) { resourceLocks.remove(currentLock.path); continue; } if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) { lockPaths.addElement(currentLock.path); } } locksList = resourceLocks.elements(); while (locksList.hasMoreElements()) { LockInfo currentLock = locksList.nextElement(); if (currentLock.hasExpired()) { resourceLocks.remove(currentLock.path); continue; } if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) { lockPaths.addElement(currentLock.path); } } if (!lockPaths.isEmpty()) { // One of the child paths was locked Enumeration<String> lockPathsList = lockPaths.elements(); resp.setStatus(WebdavStatus.SC_CONFLICT); XMLWriter generatedXML = new XMLWriter(); generatedXML.writeXMLHeader(); generatedXML.writeElement("D", DEFAULT_NAMESPACE, "multistatus", XMLWriter.OPENING); while (lockPathsList.hasMoreElements()) { generatedXML.writeElement("D", "response", XMLWriter.OPENING); generatedXML.writeElement("D", "href", XMLWriter.OPENING); generatedXML.writeText(lockPathsList.nextElement()); generatedXML.writeElement("D", "href", XMLWriter.CLOSING); generatedXML.writeElement("D", "status", XMLWriter.OPENING); generatedXML.writeText("HTTP/1.1 " + WebdavStatus.SC_LOCKED + " " + WebdavStatus.getStatusText(WebdavStatus.SC_LOCKED)); generatedXML.writeElement("D", "status", XMLWriter.CLOSING); generatedXML.writeElement("D", "response", XMLWriter.CLOSING); } generatedXML.writeElement("D", "multistatus", XMLWriter.CLOSING); Writer writer = resp.getWriter(); writer.write(generatedXML.toString()); writer.close(); return; } boolean addLock = true; locksList = collectionLocks.elements(); while (locksList.hasMoreElements()) { LockInfo currentLock = locksList.nextElement(); if (currentLock.path.equals(lock.path)) { if (currentLock.isExclusive()) { resp.sendError(WebdavStatus.SC_LOCKED); return; } else { if (lock.isExclusive()) { resp.sendError(WebdavStatus.SC_LOCKED); return; } } currentLock.tokens.addElement(lockToken); lock = currentLock; addLock = false; } } if (addLock) { lock.tokens.addElement(lockToken); collectionLocks.addElement(lock); } } else { // Locking a single resource LockInfo presentLock = resourceLocks.get(lock.path); if (presentLock != null) { if ((presentLock.isExclusive()) || (lock.isExclusive())) { // If either lock is exclusive, the lock can't be resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED); return; } else { presentLock.tokens.addElement(lockToken); lock = presentLock; } } else { lock.tokens.addElement(lockToken); resourceLocks.put(lock.path, lock); exists = true; try { object = resources.lookup(path); } catch (NamingException e) { exists = false; } if (!exists) { int slash = lock.path.lastIndexOf('/'); String parentPath = lock.path.substring(0, slash); Vector<String> lockNulls = lockNullResources.get(parentPath); if (lockNulls == null) { lockNulls = new Vector<String>(); lockNullResources.put(parentPath, lockNulls); } lockNulls.addElement(lock.path); } // Add the Lock-Token header as by RFC 2518 8.10.1 resp.addHeader("Lock-Token", "<opaquelocktoken:" + lockToken + ">"); } } } if (lockRequestType == LOCK_REFRESH) { String ifHeader = req.getHeader("If"); if (ifHeader == null) ifHeader = ""; LockInfo toRenew = resourceLocks.get(path); Enumeration<String> tokenList = null; tokenList = toRenew.tokens.elements(); while (tokenList.hasMoreElements()) { String token = tokenList.nextElement(); if (ifHeader.indexOf(token) != -1) { toRenew.expiresAt = lock.expiresAt; lock = toRenew; } } Enumeration<LockInfo> collectionLocksList = collectionLocks.elements(); while (collectionLocksList.hasMoreElements()) { toRenew = collectionLocksList.nextElement(); if (path.equals(toRenew.path)) { tokenList = toRenew.tokens.elements(); while (tokenList.hasMoreElements()) { String token = tokenList.nextElement(); if (ifHeader.indexOf(token) != -1) { toRenew.expiresAt = lock.expiresAt; lock = toRenew; } } } } } // Set the status, then generate the XML response containing XMLWriter generatedXML = new XMLWriter(); generatedXML.writeXMLHeader(); generatedXML.writeElement("D", DEFAULT_NAMESPACE, "prop", XMLWriter.OPENING); generatedXML.writeElement("D", "lockdiscovery", XMLWriter.OPENING); lock.toXML(generatedXML); generatedXML.writeElement("D", "lockdiscovery", XMLWriter.CLOSING); generatedXML.writeElement("D", "prop", XMLWriter.CLOSING); resp.setStatus(WebdavStatus.SC_OK); resp.setContentType("text/xml; charset=UTF-8"); Writer writer = resp.getWriter(); writer.write(generatedXML.toString()); writer.close(); }
public void addAuthenticator(Authenticator authenticator, String loginMethod) { if (!(authenticator instanceof Valve)) { throw new IllegalArgumentException(sm.getString("embedded.authenticatorNotInstanceOfValve")); } if (authenticators == null) { synchronized (this) { if (authenticators == null) { authenticators = new HashMap<String, Authenticator>(); } } } authenticators.put(loginMethod, authenticator); }
protected Map<String, WebXml> processJarsForWebFragments() { JarScanner jarScanner = context.getJarScanner(); FragmentJarScannerCallback callback = new FragmentJarScannerCallback(); jarScanner.scan(context.getServletContext(), context.getLoader().getClassLoader(), callback, null); return callback.getFragments(); }
protected void doFlush(boolean realFlush) throws IOException { if (suspended) return; doFlush = true; if (initial) { coyoteResponse.sendHeaders(); initial = false; } if (bb.getLength() > 0) { bb.flushBuffer(); } doFlush = false; if (realFlush) { coyoteResponse.action(ActionCode.CLIENT_FLUSH, coyoteResponse); if (coyoteResponse.isExceptionPresent()) { throw new ClientAbortException(coyoteResponse.getErrorException()); } } }	public void recycle() { initial = true; bytesWritten = 0; charsWritten = 0; bb.recycle(); closed = false; suspended = false; if (conv != null) { conv.recycle(); } gotEnc = false; enc = null; }
public String getPath() { return (this.path); }	@Override public void execute() throws BuildException { super.execute(); if (path == null) { throw new BuildException("Must specify 'path' attribute"); } try { execute("/reload?path=" + URLEncoder.encode(this.path, getCharset())); } catch (UnsupportedEncodingException e) { throw new BuildException("Invalid 'charset' attribute: " + getCharset()); } }	@Override public void execute() throws BuildException { super.execute(); if (path == null) { throw new BuildException("Must specify 'path' attribute"); } try { execute("/sessions?path=" + URLEncoder.encode(this.path, getCharset())); } catch (UnsupportedEncodingException e) { throw new BuildException("Invalid 'charset' attribute: " + getCharset()); } }	@Override public void execute() throws BuildException { super.execute(); if (path == null) { throw new BuildException("Must specify 'path' attribute"); } try { execute("/start?path=" + URLEncoder.encode(this.path, getCharset())); } catch (UnsupportedEncodingException e) { throw new BuildException("Invalid 'charset' attribute: " + getCharset()); } }	@Override public void execute() throws BuildException { super.execute(); if (path == null) { throw new BuildException("Must specify 'path' attribute"); } try { execute("/stop?path=" + URLEncoder.encode(this.path, getCharset())); } catch (UnsupportedEncodingException e) { throw new BuildException("Invalid 'charset' attribute: " + getCharset()); } }	@Override public void execute() throws BuildException { super.execute(); if (path == null) { throw new BuildException("Must specify 'path' attribute"); } try { execute("/undeploy?path=" + URLEncoder.encode(this.path, getCharset())); } catch (UnsupportedEncodingException e) { throw new BuildException("Invalid 'charset' attribute: " + getCharset()); } }	public void setPath(String path) { this.path = path; }
private void tldScanJar(JarURLConnection jarConn) throws IOException { // JarURLConnection#getJarFile() creates temporary copies of the JAR if // the underlying resource is not a file URL. That can be slow so the URL resourceURL = jarConn.getJarFileURL(); String resourcePath = resourceURL.toString(); NonClosingJarInputStream jarInputStream = null; boolean foundTld = false; try { URLConnection resourceConn = resourceURL.openConnection(); resourceConn.setUseCaches(false); jarInputStream = new NonClosingJarInputStream(resourceConn.getInputStream()); JarEntry entry = jarInputStream.getNextJarEntry(); while (entry != null) { String name = entry.getName(); if (name.startsWith("META-INF/") && name.endsWith(".tld")) { foundTld = true; tldScanStream(resourcePath, name, jarInputStream); } entry = jarInputStream.getNextJarEntry(); } } finally { if (jarInputStream != null) { try { jarInputStream.reallyClose(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } } if (!foundTld) { log.info(Localizer.getMessage("jsp.tldCache.noTldInJar", resourcePath)); } }	private void tldScanJar(JarURLConnection jarConn) { // JarURLConnection#getJarFile() creates temporary copies of the JAR if // the underlying resource is not a file URL. That can be slow so the URL resourceURL = jarConn.getJarFileURL(); NonClosingJarInputStream jarInputStream = null; String name = null; try { URLConnection resourceConn = resourceURL.openConnection(); resourceConn.setUseCaches(false); jarInputStream = new NonClosingJarInputStream(resourceConn.getInputStream()); JarEntry entry = jarInputStream.getNextJarEntry(); while (entry != null) { name = entry.getName(); if (name.startsWith("META-INF/") && name.endsWith(".tld")) { XmlErrorHandler handler = tldScanStream(jarInputStream); handler.logFindings(log, jarConn.getURL() + name); } entry = jarInputStream.getNextJarEntry(); } } catch (IOException ioe) { log.warn(sm.getString("tldConfig.jarFail", jarConn.getURL() + name), ioe); } finally { if (jarInputStream != null) { try { jarInputStream.reallyClose(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } } }	protected void processAnnotationsJar(URL url, WebXml fragment) { JarInputStream jarInputStream = null; try { URLConnection urlConn = url.openConnection(); JarURLConnection jarConn; if (!(urlConn instanceof JarURLConnection)) { sm.getString("contextConfig.jarUrl", url); return; } jarConn = (JarURLConnection) urlConn; jarConn.setUseCaches(false); URL resourceURL = jarConn.getJarFileURL(); URLConnection resourceConn = resourceURL.openConnection(); jarInputStream = new JarInputStream(resourceConn.getInputStream()); JarEntry entry = jarInputStream.getNextJarEntry(); while (entry != null) { String entryName = entry.getName(); if (entryName.endsWith(".class")) { try { processAnnotationsStream(jarInputStream, fragment); } catch (IOException e) { log.error(sm.getString("contextConfig.inputStreamJar", entryName, url), e); } } entry = jarInputStream.getNextJarEntry(); } } catch (IOException e) { log.error(sm.getString("contextConfig.jarFile", url), e); } finally { if (jarInputStream != null) { try { jarInputStream.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } } }	protected void processResourceJARs(Set<WebXml> fragments) { for (WebXml fragment : fragments) { URL url = fragment.getURL(); JarInputStream jarInputStream = null; try { if ("jar".equals(url.getProtocol())) { JarURLConnection jarConn = (JarURLConnection) url.openConnection(); URL resourceURL = jarConn.getJarFileURL(); URLConnection resourceConn = resourceURL.openConnection(); resourceConn.setUseCaches(false); jarInputStream = new JarInputStream(resourceConn.getInputStream()); JarEntry entry = jarInputStream.getNextJarEntry(); while (entry != null) { if ("META-INF/resources/".equals(entry.getName())) { break; } entry = jarInputStream.getNextJarEntry(); } if (entry != null) { context.addResourceJarUrl(url); } } } catch (IOException ioe) { log.error(sm.getString("contextConfig.resourceJarFail", url, context.getName())); } finally { if (jarInputStream != null) { try { jarInputStream.close(); } catch (IOException e) { // Ignore } } } } }	protected void processServletContainerInitializers(Set<WebXml> fragments) { for (WebXml fragment : fragments) { URL url = fragment.getURL(); JarInputStream jarInputStream = null; InputStream is = null; ServletContainerInitializer sci = null; try { if ("jar".equals(url.getProtocol())) { JarURLConnection jarConn = (JarURLConnection) url.openConnection(); URL resourceURL = jarConn.getJarFileURL(); URLConnection resourceConn = resourceURL.openConnection(); resourceConn.setUseCaches(false); jarInputStream = new JarInputStream(resourceConn.getInputStream()); JarEntry entry = jarInputStream.getNextJarEntry(); while (entry != null) { if (SCI_LOCATION.equals(entry.getName())) { break; } entry = jarInputStream.getNextJarEntry(); } if (entry != null) { is = jarInputStream; } } else if ("file".equals(url.getProtocol())) { String path = url.getPath(); File file = new File(path, SCI_LOCATION); if (file.exists()) { is = new FileInputStream(file); } } if (is != null) { sci = getServletContainerInitializer(is); } } catch (IOException ioe) { log.error(sm.getString("contextConfig.servletContainerInitializerFail", url, context.getName())); ok = false; return; } finally { if (is != null) { try { is.close(); } catch (IOException e) { // Ignore } } if (jarInputStream != null) { try { jarInputStream.close(); } catch (IOException e) { // Ignore } } } if (sci == null) { continue; } initializerClassMap.put(sci, new HashSet<Class<?>>()); HandlesTypes ht = sci.getClass().getAnnotation(HandlesTypes.class); if (ht != null) { Class<?>[] types = ht.value(); if (types != null) { for (Class<?> type : types) { Set<ServletContainerInitializer> scis = typeInitializerMap.get(type); if (scis == null) { scis = new HashSet<ServletContainerInitializer>(); typeInitializerMap.put(type, scis); } scis.add(sci); } } } } }	protected Map<String, String> processAnnotationWebInitParams(ElementValue ev) { Map<String, String> result = new HashMap<String, String>(); if (ev instanceof ArrayElementValue) { ElementValue[] arrayValues = ((ArrayElementValue) ev).getElementValuesArray(); for (ElementValue value : arrayValues) { if (value instanceof AnnotationElementValue) { ElementValuePair[] evps = ((AnnotationElementValue) value).getAnnotationEntry().getElementValuePairs(); String initParamName = null; String initParamValue = null; for (ElementValuePair evp : evps) { if ("name".equals(evp.getNameString())) { initParamName = evp.getValue().stringifyValue(); } else if ("value".equals(evp.getNameString())) { initParamValue = evp.getValue().stringifyValue(); } else { // Ignore } } result.put(initParamName, initParamValue); } } } return result; }
protected void forwardToErrorPage(Request request, HttpServletResponse response, LoginConfig config) throws IOException { RequestDispatcher disp = context.getServletContext().getRequestDispatcher(config.getErrorPage()); try { if (context.fireRequestInitEvent(request)) { disp.forward(request.getRequest(), response); context.fireRequestDestroyEvent(request); } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); String msg = sm.getString("formAuthenticator.forwardErrorFail"); log.warn(msg, t); request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t); response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, msg); } }	protected void forwardToLoginPage(Request request, HttpServletResponse response, LoginConfig config) throws IOException { RequestDispatcher disp = context.getServletContext().getRequestDispatcher(config.getLoginPage()); try { if (context.fireRequestInitEvent(request)) { disp.forward(request.getRequest(), response); context.fireRequestDestroyEvent(request); } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); String msg = sm.getString("formAuthenticator.forwardLoginFail"); log.warn(msg, t); request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t); response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, msg); } }
protected CounterLatch initializeConnectionLatch() { if (connectionCounterLatch == null) { connectionCounterLatch = new CounterLatch(0, getMaxConnections()); } return connectionCounterLatch; }	protected long countDownConnection() { CounterLatch latch = connectionCounterLatch; if (latch != null) { long result = latch.countDown(); if (result < 0) { getLog().warn("Incorrect connection count, multiple socket.close called on the same socket."); } return result; } else return -1; }	protected void awaitConnection() throws InterruptedException { CounterLatch latch = connectionCounterLatch; if (latch != null) latch.await(); }	protected void releaseConnectionLatch() { CounterLatch latch = connectionCounterLatch; if (latch != null) latch.releaseAll(); connectionCounterLatch = null; }	public int getMaxConnections() { return this.maxConnections; }	public String adjustRelativePath(String path, String relativeTo) { String newPath = path; File f = new File(newPath); if (!f.isAbsolute()) { newPath = relativeTo + File.separator + newPath; f = new File(newPath); } if (!f.exists()) { getLog().warn("configured file:[" + newPath + "] does not exist."); } return newPath; }	protected Log getLog() { return log; }	protected Log getLog() { return log; }
protected String findleaks(StringManager smClient) { StringBuilder msg = new StringBuilder(); StringWriter stringWriter = new StringWriter(); PrintWriter printWriter = new PrintWriter(stringWriter); super.findleaks(printWriter, smClient); if (stringWriter.getBuffer().length() > 0) { msg.append(smClient.getString("htmlManagerServlet.findleaksList")); msg.append(stringWriter.toString()); } else { msg.append(smClient.getString("htmlManagerServlet.findleaksNone")); } return msg.toString(); }	protected void findleaks(PrintWriter writer, StringManager smClient) { if (!(host instanceof StandardHost)) { writer.println(smClient.getString("managerServlet.findleaksFail")); return; } String[] results = ((StandardHost) host).findReloadedContextMemoryLeaks(); for (String result : results) { if ("".equals(result)) { result = "/"; } writer.println(result); } }	@Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { StringManager smClient = getStringManager(request); String command = request.getPathInfo(); if (command == null) command = request.getServletPath(); String config = request.getParameter("config"); String path = request.getParameter("path"); ContextName cn = null; if (path != null) { cn = new ContextName(path, request.getParameter("version")); } String type = request.getParameter("type"); String war = request.getParameter("war"); String tag = request.getParameter("tag"); boolean update = false; if ((request.getParameter("update") != null) && (request.getParameter("update").equals("true"))) { update = true; } response.setContentType("text/plain; charset=" + Constants.CHARSET); PrintWriter writer = response.getWriter(); if (command == null) { writer.println(smClient.getString("managerServlet.noCommand")); } else if (command.equals("/deploy")) { if (war != null || config != null) { deploy(writer, config, cn, war, update, smClient); } else { deploy(writer, cn, tag, smClient); } } else if (command.equals("/list")) { list(writer, smClient); } else if (command.equals("/reload")) { reload(writer, cn, smClient); } else if (command.equals("/resources")) { resources(writer, type, smClient); } else if (command.equals("/save")) { save(writer, path, smClient); } else if (command.equals("/serverinfo")) { serverinfo(writer, smClient); } else if (command.equals("/sessions")) { expireSessions(writer, cn, request, smClient); } else if (command.equals("/expire")) { expireSessions(writer, cn, request, smClient); } else if (command.equals("/start")) { start(writer, cn, smClient); } else if (command.equals("/stop")) { stop(writer, cn, smClient); } else if (command.equals("/undeploy")) { undeploy(writer, cn, smClient); } else if (command.equals("/findleaks")) { findleaks(writer, smClient); } else { writer.println(smClient.getString("managerServlet.unknownCommand", command)); } writer.flush(); writer.close(); }	@Override public void init() throws ServletException { if ((wrapper == null) || (context == null)) throw new UnavailableException(sm.getString("managerServlet.noWrapper")); String value = null; try { value = getServletConfig().getInitParameter("debug"); debug = Integer.parseInt(value); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } Server server = ((Engine) host.getParent()).getService().getServer(); if (server != null) { global = server.getGlobalNamingContext(); } versioned = (File) getServletContext().getAttribute(ServletContext.TEMPDIR); // Identify the appBase of the owning Host of this Context String appBase = ((Host) context.getParent()).getAppBase(); deployed = new File(appBase); if (!deployed.isAbsolute()) { deployed = new File(System.getProperty(Globals.CATALINA_BASE_PROP), appBase); } configBase = new File(System.getProperty(Globals.CATALINA_BASE_PROP), "conf"); Container container = context; Container host = null; Container engine = null; while (container != null) { if (container instanceof Host) host = container; if (container instanceof Engine) engine = container; container = container.getParent(); } if (engine != null) { configBase = new File(configBase, engine.getName()); } if (host != null) { configBase = new File(configBase, host.getName()); } if (debug >= 1) { log("init: Associated with Deployer '" + oname + "'"); if (global != null) { log("init: Global resources are available"); } } }
@Override public void invoke(Request request, Response response) throws IOException, ServletException { if (log.isDebugEnabled()) log.debug("Security checking request " + request.getMethod() + " " + request.getRequestURI()); LoginConfig config = this.context.getLoginConfig(); if (cache) { Principal principal = request.getUserPrincipal(); if (principal == null) { Session session = request.getSessionInternal(false); if (session != null) { principal = session.getPrincipal(); if (principal != null) { if (log.isDebugEnabled()) log.debug("We have cached auth type " + session.getAuthType() + " for principal " + session.getPrincipal()); request.setAuthType(session.getAuthType()); request.setUserPrincipal(principal); } } } } // Special handling for form-based logins to deal with the case // where the login form (and therefore the "j_security_check" URI String contextPath = this.context.getPath(); String requestURI = request.getDecodedRequestURI(); if (requestURI.startsWith(contextPath) && requestURI.endsWith(Constants.FORM_ACTION)) { if (!authenticate(request, response, config)) { if (log.isDebugEnabled()) log.debug(" Failed authenticate() test ??" + requestURI); return; } } // The Servlet may specify security constraints through annotations. Wrapper wrapper = (Wrapper) request.getMappingData().wrapper; if (wrapper != null) { wrapper.servletSecurityAnnotationScan(); } Realm realm = this.context.getRealm(); SecurityConstraint[] constraints = realm.findSecurityConstraints(request, this.context); if (constraints == null && !context.getPreemptiveAuthentication()) { if (log.isDebugEnabled()) log.debug(" Not subject to any constraint"); getNext().invoke(request, response); return; } if (constraints != null && disableProxyCaching && !"POST".equalsIgnoreCase(request.getMethod())) { if (securePagesWithPragma) { // FIXME: These cause problems with downloading office docs // from IE under SSL and may not be needed for newer Mozilla response.setHeader("Pragma", "No-cache"); response.setHeader("Cache-Control", "no-cache"); } else { response.setHeader("Cache-Control", "private"); } response.setHeader("Expires", DATE_ONE); } int i; if (constraints != null) { if (log.isDebugEnabled()) { log.debug(" Calling hasUserDataPermission()"); } if (!realm.hasUserDataPermission(request, response, constraints)) { if (log.isDebugEnabled()) { log.debug(" Failed hasUserDataPermission() test"); } return; } } // Since authenticate modifies the response on failure, boolean authRequired; if (constraints == null) { authRequired = false; } else { authRequired = true; for (i = 0; i < constraints.length && authRequired; i++) { if (!constraints[i].getAuthConstraint()) { authRequired = false; } else if (!constraints[i].getAllRoles()) { String[] roles = constraints[i].findAuthRoles(); if (roles == null || roles.length == 0) { authRequired = false; } } } } if (!authRequired) { authRequired = request.getCoyoteRequest().getMimeHeaders().getValue("authorization") != null; } if (!authRequired) { X509Certificate[] certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR); authRequired = certs != null && certs.length > 0; } if (authRequired) { if (log.isDebugEnabled()) { log.debug(" Calling authenticate()"); } if (!authenticate(request, response, config)) { if (log.isDebugEnabled()) { log.debug(" Failed authenticate() test"); } return; } } if (constraints != null) { if (log.isDebugEnabled()) { log.debug(" Calling accessControl()"); } if (!realm.hasResourcePermission(request, response, constraints, this.context)) { if (log.isDebugEnabled()) { log.debug(" Failed accessControl() test"); } return; } } if (log.isDebugEnabled()) { log.debug(" Successfully passed all security constraints"); } getNext().invoke(request, response); }
public PoolConfiguration getPoolProperties() { return poolProperties; }
public void start() { if (log.isDebugEnabled()) log.debug(sm.getString("hostConfig.start")); try { ObjectName hostON = host.getObjectName(); oname = new ObjectName(hostON.getDomain() + ":type=Deployer,host=" + host.getName()); Registry.getRegistry(null, null).registerComponent(this, oname, this.getClass().getName()); } catch (Exception e) { log.error(sm.getString("hostConfig.jmx.register", oname), e); } if (host.getCreateDirs()) { File[] dirs = new File[] { appBase(), configBase() }; for (int i = 0; i < dirs.length; i++) { if ((!dirs[i].exists()) && (!dirs[i].mkdirs())) { log.error(sm.getString("hostConfig.createDirs", dirs[i])); } } } if (host.getDeployOnStartup()) deployApps(); }
private void generatePostamble() { out.popIndent(); out.printil("} catch (java.lang.Throwable t) {"); out.pushIndent(); out.printil("if (!(t instanceof javax.servlet.jsp.SkipPageException)){"); out.pushIndent(); out.printil("out = _jspx_out;"); out.printil("if (out != null && out.getBufferSize() != 0)"); out.pushIndent(); out.printil("try { out.clearBuffer(); } catch (java.io.IOException e) {}"); out.popIndent(); out.printil("if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("} finally {"); out.pushIndent(); out.printil("_jspxFactory.releasePageContext(_jspx_page_context);"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); genCommonPostamble(); }
protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException { if (Boolean.TRUE == req.getAttribute("dispatch")) { log.info("Received dispatch, completing on the worker thread."); req.getAsyncContext().complete(); log.info("After complete called started:"+req.isAsyncStarted()); resp.getWriter().write("Async dispatch worked:+"+System.currentTimeMillis()+"\n"); } else { resp.setContentType("text/plain"); final AsyncContext actx = req.startAsync(); actx.setTimeout(Long.MAX_VALUE); Runnable run = new Runnable() { @Override } } }
@Override public void setProperties(Map<String, InterceptorProperty> properties) { super.setProperties(properties); final String threshold = "threshold"; final String maxqueries = "maxQueries"; InterceptorProperty p1 = properties.get(threshold); InterceptorProperty p2 = properties.get(maxqueries); if (p1 != null) { setThreshold(Long.parseLong(p1.getValue())); } if (p2 != null) { setMaxQueries(Integer.parseInt(p2.getValue())); } }
public InterceptorDefinition[] getJdbcInterceptorsAsArray() { if (interceptors == null) { if (jdbcInterceptors == null) { interceptors = new InterceptorDefinition[0]; } else { String[] interceptorValues = jdbcInterceptors.split(";"); InterceptorDefinition[] definitions = new InterceptorDefinition[interceptorValues.length + 1]; definitions[0] = new InterceptorDefinition(TrapException.class); for (int i = 0; i < interceptorValues.length; i++) { int propIndex = interceptorValues[i].indexOf("("); int endIndex = interceptorValues[i].indexOf(")"); if (propIndex < 0 || endIndex < 0 || endIndex <= propIndex) { definitions[i + 1] = new InterceptorDefinition(interceptorValues[i].trim()); } else { String name = interceptorValues[i].substring(0, propIndex).trim(); definitions[i + 1] = new InterceptorDefinition(name); String propsAsString = interceptorValues[i].substring(propIndex + 1, interceptorValues[i].length() - 1); String[] props = propsAsString.split(","); for (int j = 0; j < props.length; j++) { int pidx = props[j].indexOf("="); String propName = props[j].substring(0, pidx).trim(); String propValue = props[j].substring(pidx + 1).trim(); definitions[i].addProperty(new InterceptorProperty(propName, propValue)); } } } interceptors = definitions; } } return interceptors; }
protected Comparator<Session> getComparator(String sortBy) { Comparator<Session> comparator = null; if ("CreationTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(session.getCreationTime()); } }; } else if ("id".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { @Override public Comparable<String> getComparableObject(Session session) { return session.getId(); } }; } else if ("LastAccessedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(session.getLastAccessedTime()); } }; } else if ("MaxInactiveInterval".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(session.getMaxInactiveInterval()); } }; } else if ("new".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Boolean>() { @Override public Comparable<Boolean> getComparableObject(Session session) { return Boolean.valueOf(session.getSession().isNew()); } }; } else if ("locale".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { @Override public Comparable<String> getComparableObject(Session session) { return JspHelper.guessDisplayLocaleFromSession(session); } }; } else if ("user".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { @Override public Comparable<String> getComparableObject(Session session) { return JspHelper.guessDisplayUserFromSession(session); } }; } else if ("UsedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getUsedTimeForSession(session)); } }; } else if ("InactiveTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getInactiveTimeForSession(session)); } }; } else if ("TTL".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getTTLForSession(session)); } }; } return comparator; }


protected void removeAttributeInternal(String name, boolean notify, boolean addDeltaRequest) { try { lock(); Object value = attributes.get(name); if (value == null) return; super.removeAttributeInternal(name, notify); if (addDeltaRequest && (deltaRequest != null)) deltaRequest.removeAttribute(name); } finally { unlock(); } }	public void setAttribute(String name, Object value, boolean notify, boolean addDeltaRequest) { if (name == null) throw new IllegalArgumentException(sm.getString("standardSession.setAttribute.namenull")); if (value == null) { removeAttribute(name); return; } try { lock(); super.setAttribute(name, value, notify); if (addDeltaRequest && (deltaRequest != null)) deltaRequest.setAttribute(name, value); } finally { unlock(); } }
public boolean authenticate(Request request, HttpServletResponse response, LoginConfig config) throws IOException { Principal principal = request.getUserPrincipal(); String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (principal != null) { if (log.isDebugEnabled()) log.debug("Already authenticated '" + principal.getName() + "'"); if (ssoId != null) associate(ssoId, request.getSessionInternal(true)); return true; } if (ssoId != null) { if (log.isDebugEnabled()) log.debug("SSO Id " + ssoId + " set; attempting " + "reauthentication"); if (reauthenticateFromSSO(ssoId, request)) return true; } MessageBytes authorization = request.getCoyoteRequest().getMimeHeaders().getValue("authorization"); if (authorization == null) { if (log.isDebugEnabled()) { log.debug(sm.getString("authenticator.noAuthHeader")); } response.setHeader("WWW-Authenticate", "Negotiate"); response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return false; } authorization.toBytes(); ByteChunk authorizationBC = authorization.getByteChunk(); if (!authorizationBC.startsWithIgnoreCase("negotiate ", 0)) { if (log.isDebugEnabled()) { log.debug(sm.getString("spnegoAuthenticator.authHeaderNotNego")); } response.setHeader("WWW-Authenticate", "Negotiate"); response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return false; } authorizationBC.setOffset(authorizationBC.getOffset() + 10); // FIXME: Add trimming ByteChunk decoded = new ByteChunk(); Base64.decode(authorizationBC, decoded); if (decoded.getLength() == 0) { if (log.isDebugEnabled()) { log.debug(sm.getString("spnegoAuthenticator.authHeaderNoToken")); } response.setHeader("WWW-Authenticate", "Negotiate"); response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return false; } LoginContext lc = null; GSSContext gssContext = null; byte[] outToken = null; try { try { lc = new LoginContext(loginConfigName); lc.login(); } catch (LoginException e) { log.error(sm.getString("spnegoAuthenticator.serviceLoginFail"), e); response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); return false; } // Assume the GSSContext is stateless GSSManager manager = GSSManager.getInstance(); gssContext = manager.createContext(manager.createCredential(null, GSSCredential.DEFAULT_LIFETIME, new Oid("1.3.6.1.5.5.2"), GSSCredential.ACCEPT_ONLY)); outToken = gssContext.acceptSecContext(decoded.getBytes(), decoded.getOffset(), decoded.getLength()); if (outToken == null) { if (log.isDebugEnabled()) { log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail")); } response.setHeader("WWW-Authenticate", "Negotiate"); response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return false; } principal = context.getRealm().authenticate(gssContext, storeDelegatedCredential); } catch (GSSException e) { if (log.isDebugEnabled()) { log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail", e)); } response.setHeader("WWW-Authenticate", "Negotiate"); response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return false; } finally { if (gssContext != null) { try { gssContext.dispose(); } catch (GSSException e) { // Ignore } } if (lc != null) { try { lc.logout(); } catch (LoginException e) { // Ignore } } } response.setHeader("WWW-Authenticate", "Negotiate " + Base64.encode(outToken)); if (principal != null) { register(request, response, principal, Constants.SPNEGO_METHOD, principal.getName(), null); return true; } response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return false; }
private void init() { // Get all the other parameters required from the standard system // properties. Only need to get the parameters that affect the creation String rmiSSLValue = System.getProperty("com.sun.management.jmxremote.ssl", "true"); rmiSSL = Boolean.parseBoolean(rmiSSLValue); String protocolsValue = System.getProperty("com.sun.management.jmxremote.ssl.enabled.protocols"); if (protocolsValue != null) { protocols = protocolsValue.split(","); } String ciphersValue = System.getProperty("com.sun.management.jmxremote.ssl.enabled.cipher.suites"); if (ciphersValue != null) { ciphers = ciphersValue.split(","); } String clientAuthValue = System.getProperty("com.sun.management.jmxremote.ssl.need.client.auth", "true"); clientAuth = Boolean.parseBoolean(clientAuthValue); String authenticateValue = System.getProperty("com.sun.management.jmxremote.authenticate", "true"); authenticate = Boolean.parseBoolean(authenticateValue); passwordFile = System.getProperty("com.sun.management.jmxremote.password.file", "jmxremote.password"); accessFile = System.getProperty("com.sun.management.jmxremote.access.file", "jmxremote.access"); }	@Override public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.START_EVENT == event.getType()) { init(); System.setProperty("java.rmi.server.randomIDs", "true"); HashMap<String, Object> env = new HashMap<String, Object>(); RMIClientSocketFactory csf = null; RMIServerSocketFactory ssf = null; if (rmiSSL) { csf = new SslRMIClientSocketFactory(); ssf = new SslRMIServerSocketFactory(ciphers, protocols, clientAuth); } if (useLocalPorts) { csf = new RmiClientLocalhostSocketFactory(csf); } if (csf != null) { env.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE, csf); } if (ssf != null) { env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, ssf); } if (authenticate) { env.put("jmx.remote.x.password.file", passwordFile); env.put("jmx.remote.x.access.file", accessFile); } csPlatform = createServer("Platform", rmiRegistryPortPlatform, rmiServerPortPlatform, env, ManagementFactory.getPlatformMBeanServer()); } else if (Lifecycle.STOP_EVENT == event.getType()) { destroyServer("Platform", csPlatform); } }
private void reAllocBuff(int len) { if (bufferSize + len <= cb.length) { bufferSize = cb.length; return; } if (len < cb.length) { len = cb.length; } bufferSize = cb.length + len; char[] tmp = new char[bufferSize]; System.arraycopy(cb, 0, tmp, 0, cb.length); cb = tmp; tmp = null; }	@Override public void clear() throws IOException { if (writer != null) { throw new IOException(); } else { nextChar = 0; if (LIMIT_BUFFER && (cb.length > Constants.DEFAULT_TAG_BUFFER_SIZE)) { bufferSize = Constants.DEFAULT_TAG_BUFFER_SIZE; cb = new char[bufferSize]; } } }
public Context addContext(Host host, String contextPath, String dir) { silence(contextPath); Context ctx = new StandardContext(); ctx.setPath(contextPath); ctx.setDocBase(dir); ctx.addLifecycleListener(new FixContextListener()); if (host == null) { getHost().addChild(ctx); } else { host.addChild(ctx); } return ctx; }	public Context addWebapp(Host host, String url, String path) { silence(url); Context ctx = new StandardContext(); ctx.setPath(url); ctx.setDocBase(path); if (defaultRealm == null) { initSimpleAuth(); } ctx.setRealm(defaultRealm); ctx.addLifecycleListener(new DefaultWebXmlListener()); ContextConfig ctxCfg = new ContextConfig(); ctx.addLifecycleListener(ctxCfg); ctxCfg.setDefaultWebXml("org/apache/catalin/startup/NO_DEFAULT_XML"); if (host == null) { getHost().addChild(ctx); } else { host.addChild(ctx); } return ctx; }
protected Log getLog() { return log; }
@Override public void bind() throws Exception { try { rootPool = Pool.create(0); } catch (UnsatisfiedLinkError e) { throw new Exception(sm.getString("endpoint.init.notavail")); } serverSockPool = Pool.create(rootPool); String addressStr = null; if (getAddress() != null) { addressStr = getAddress().getHostAddress(); } int family = Socket.APR_INET; if (Library.APR_HAVE_IPV6) { if (addressStr == null) { if (!OS.IS_BSD && !OS.IS_WIN32 && !OS.IS_WIN64) family = Socket.APR_UNSPEC; } else if (addressStr.indexOf(':') >= 0) { family = Socket.APR_UNSPEC; } } long inetAddress = Address.info(addressStr, family, getPort(), 0, rootPool); serverSock = Socket.create(Address.getInfo(inetAddress).family, Socket.SOCK_STREAM, Socket.APR_PROTO_TCP, rootPool); if (OS.IS_UNIX) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } Socket.optSet(serverSock, Socket.APR_SO_KEEPALIVE, 1); int ret = Socket.bind(serverSock, inetAddress); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.bind", "" + ret, Error.strerror(ret))); } ret = Socket.listen(serverSock, getBacklog()); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.listen", "" + ret, Error.strerror(ret))); } if (OS.IS_WIN32 || OS.IS_WIN64) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } if (useSendfile && !Library.APR_HAS_SENDFILE) { useSendfile = false; } if (acceptorThreadCount == 0) { acceptorThreadCount = 1; } if (pollerThreadCount == 0) { if ((OS.IS_WIN32 || OS.IS_WIN64) && (pollerSize > 1024)) { pollerThreadCount = pollerSize / 1024; pollerSize = pollerSize - (pollerSize % 1024); } else { pollerThreadCount = 1; } } if (sendfileThreadCount == 0) { if ((OS.IS_WIN32 || OS.IS_WIN64) && (sendfileSize > 1024)) { sendfileThreadCount = sendfileSize / 1024; sendfileSize = sendfileSize - (sendfileSize % 1024); } else { // No explicit poller size limitation sendfileThreadCount = 1; } } if (deferAccept) { if (Socket.optSet(serverSock, Socket.APR_TCP_DEFER_ACCEPT, 1) == Status.APR_ENOTIMPL) { deferAccept = false; } } if (isSSLEnabled()) { if (SSLCertificateFile == null) { throw new Exception(sm.getString("endpoint.apr.noSslCertFile")); } int value = SSL.SSL_PROTOCOL_ALL; if ("SSLv2".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV2; } else if ("SSLv3".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV3; } else if ("TLSv1".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_TLSV1; } else if ("SSLv2+SSLv3".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV2 | SSL.SSL_PROTOCOL_SSLV3; } sslContext = SSLContext.make(rootPool, value, SSL.SSL_MODE_SERVER); if (SSLInsecureRenegotiation) { boolean legacyRenegSupported = false; try { legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); if (legacyRenegSupported) SSLContext.setOptions(sslContext, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); } catch (UnsatisfiedLinkError e) { // Ignore } if (!legacyRenegSupported) { log.warn(sm.getString("endpoint.warn.noInsecureReneg", SSL.versionString())); } } SSLContext.setCipherSuite(sslContext, SSLCipherSuite); SSLContext.setCertificate(sslContext, SSLCertificateFile, SSLCertificateKeyFile, SSLPassword, SSL.SSL_AIDX_RSA); SSLContext.setCertificateChainFile(sslContext, SSLCertificateChainFile, false); SSLContext.setCACertificate(sslContext, SSLCACertificateFile, SSLCACertificatePath); SSLContext.setCARevocation(sslContext, SSLCARevocationFile, SSLCARevocationPath); value = SSL.SSL_CVERIFY_NONE; if ("optional".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL; } else if ("require".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_REQUIRE; } else if ("optionalNoCA".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA; } SSLContext.setVerify(sslContext, value, SSLVerifyDepth); useSendfile = false; } }
protected void changeSessionID(Request request, String sessionId, String newSessionID, Session catalinaSession) { fireLifecycleEvent("Before session migration", catalinaSession); catalinaSession.setId(newSessionID); if (catalinaSession instanceof DeltaSession) ((DeltaSession) catalinaSession).resetDeltaRequest(); changeRequestSessionID(request, sessionId, newSessionID); sendSessionIDClusterBackup(request, sessionId, newSessionID); fireLifecycleEvent("After session migration", catalinaSession); if (log.isDebugEnabled()) { log.debug(sm.getString("jvmRoute.changeSession", sessionId, newSessionID)); } }	protected void handleCHANGE_SESSION_ID(SessionMessage msg, Member sender) throws IOException { counterReceive_EVT_CHANGE_SESSION_ID++; DeltaSession session = (DeltaSession) findSession(msg.getSessionID()); if (session != null) { String newSessionID = deserializeSessionId(msg.getSession()); session.setPrimarySession(false); if (notifySessionListenersOnReplication) { session.setId(newSessionID); } else { session.setIdInternal(newSessionID); add(session); } } }	protected void handleSESSION_CREATED(SessionMessage msg, Member sender) { counterReceive_EVT_SESSION_CREATED++; if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.createNewSession", getName(), msg.getSessionID())); DeltaSession session = (DeltaSession) createEmptySession(); session.setManager(this); session.setValid(true); session.setPrimarySession(false); session.setCreationTime(msg.getTimestamp()); session.setMaxInactiveInterval(getMaxInactiveInterval()); session.access(); if (notifySessionListenersOnReplication) { session.setId(msg.getSessionID()); } else { session.setIdInternal(msg.getSessionID()); add(session); } session.resetDeltaRequest(); session.endAccess(); }	@Override public void changeSessionId(Session session) { session.setId(generateSessionId()); }	@Override public void setId(String id) { this.sessionId = id; }	@Override public void setId(String id) { if ((this.id != null) && (manager != null)) manager.remove(this); this.id = id; if (manager != null) manager.add(this); tellNew(); }	public void setIdInternal(String id) { this.id = id; resetDeltaRequest(); }	@Override public void setPrimarySession(boolean primarySession) { this.isPrimarySession = primarySession; }
private void doTestDispatch(int iter, boolean useThread) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); DispatchingServlet dispatch = new DispatchingServlet(false, false); Wrapper wrapper = Tomcat.addServlet(ctx, "dispatch", dispatch); wrapper.setAsyncSupported(true); ctx.addServletMapping("/stage1", "dispatch"); NonAsyncServlet nonasync = new NonAsyncServlet(); Wrapper wrapper2 = Tomcat.addServlet(ctx, "nonasync", nonasync); wrapper2.setAsyncSupported(true); ctx.addServletMapping("/stage2", "nonasync"); ctx.addApplicationListener(TrackingRequestListener.class.getName()); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/stage1?iter="); url.append(iter); if (useThread) { url.append("&useThread=y"); } ByteChunk res = getUrl(url.toString()); StringBuilder expected = new StringBuilder("requestInitialized-"); int loop = iter; while (loop > 0) { expected.append("DispatchingServletGet-"); loop--; } expected.append("NonAsyncServletGet-"); expected.append("requestDestroyed"); assertEquals(expected.toString(), res.toString()); }	private void doTestDispatchError(int iter, boolean useThread, boolean completeOnError) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); DispatchingServlet dispatch = new DispatchingServlet(true, completeOnError); Wrapper wrapper = Tomcat.addServlet(ctx, "dispatch", dispatch); wrapper.setAsyncSupported(true); ctx.addServletMapping("/stage1", "dispatch"); ErrorServlet error = new ErrorServlet(); Tomcat.addServlet(ctx, "error", error); ctx.addServletMapping("/stage2", "error"); ctx.addApplicationListener(TrackingRequestListener.class.getName()); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/stage1?iter="); url.append(iter); if (useThread) { url.append("&useThread=y"); } ByteChunk res = getUrl(url.toString()); StringBuilder expected = new StringBuilder("requestInitialized-"); int loop = iter; while (loop > 0) { expected.append("DispatchingServletGet-"); if (loop != iter) { expected.append("onStartAsync-"); } loop--; } expected.append("ErrorServletGet-onError-onComplete-requestDestroyed"); assertEquals(expected.toString(), res.toString()); }	private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); File foo = new File(docBase, "async"); if (!foo.exists() && !foo.mkdirs()) { fail("Unable to create async directory in docBase"); } Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); TimeoutServlet timeout = new TimeoutServlet(completeOnTimeout, dispatchUrl); Wrapper wrapper = Tomcat.addServlet(ctx, "time", timeout); wrapper.setAsyncSupported(true); ctx.addServletMapping("/async", "time"); if (dispatchUrl != null) { NonAsyncServlet nonAsync = new NonAsyncServlet(); Tomcat.addServlet(ctx, "nonasync", nonAsync); ctx.addServletMapping(dispatchUrl, "nonasync"); } ctx.addApplicationListener(TrackingRequestListener.class.getName()); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/async"); StringBuilder expected = new StringBuilder("requestInitialized-"); expected.append("TimeoutServletGet-onTimeout-"); if (!completeOnTimeout) { expected.append("onError-"); } if (dispatchUrl == null) { expected.append("onComplete-"); } else { expected.append("NonAsyncServletGet-"); } expected.append("requestDestroyed"); assertEquals(expected.toString(), res.toString()); }	private void doTestDispatchError(int iter, boolean useThread, boolean completeOnError) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); DispatchingServlet dispatch = new DispatchingServlet(true, completeOnError); Wrapper wrapper = Tomcat.addServlet(ctx, "dispatch", dispatch); wrapper.setAsyncSupported(true); ctx.addServletMapping("/stage1", "dispatch"); ErrorServlet error = new ErrorServlet(); Tomcat.addServlet(ctx, "error", error); ctx.addServletMapping("/stage2", "error"); ctx.addApplicationListener(TrackingRequestListener.class.getName()); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/stage1?iter="); url.append(iter); if (useThread) { url.append("&useThread=y"); } ByteChunk res = getUrl(url.toString()); StringBuilder expected = new StringBuilder("requestInitialized-"); int loop = iter; while (loop > 0) { expected.append("DispatchingServletGet-"); if (loop != iter) { expected.append("onStartAsync-"); } loop--; } expected.append("ErrorServletGet-onError-onComplete-requestDestroyed"); assertEquals(expected.toString(), res.toString()); }	@Override protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException { result = new StringBuilder(); result.append('1'); result.append(req.isAsyncStarted()); req.startAsync().setTimeout(10000); result.append('2'); result.append(req.isAsyncStarted()); req.getAsyncContext().start(new Runnable() { @Override public void run() { try { result.append('3'); result.append(req.isAsyncStarted()); Thread.sleep(1000); result.append('4'); result.append(req.isAsyncStarted()); resp.setContentType("text/plain"); resp.getWriter().print("OK"); req.getAsyncContext().complete(); result.append('5'); result.append(req.isAsyncStarted()); done = true; } catch (InterruptedException e) { result.append(e); } catch (IOException e) { result.append(e); } } }); // Pointless method call so there is somewhere to put a break point req.getMethod(); }	@Override public boolean asyncDispatch(org.apache.coyote.Request req, org.apache.coyote.Response res, SocketStatus status) throws Exception { Request request = (Request) req.getNote(ADAPTER_NOTES); Response response = (Response) res.getNote(ADAPTER_NOTES); if (request == null) { throw new IllegalStateException("Dispatch may only happen on an existing request."); } boolean comet = false; boolean success = true; AsyncContextImpl asyncConImpl = (AsyncContextImpl) request.getAsyncContext(); try { if (!request.isAsync() && !comet) { // Error or timeout - need to tell listeners the request is over // Have to test this first since state may change while in this // method and this is only required if entering this method in Context ctxt = (Context) request.getMappingData().context; if (ctxt != null) { ctxt.fireRequestDestroyEvent(request); } } if (status == SocketStatus.TIMEOUT) { success = true; if (!asyncConImpl.timeout()) { asyncConImpl.setErrorState(null); } } if (request.isAsyncDispatching()) { success = true; connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); Throwable t = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION); if (t != null) { asyncConImpl.setErrorState(t); } } if (request.isComet()) { if (!response.isClosed() && !response.isError()) { if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) { if (event(req, res, SocketStatus.OPEN)) { comet = true; res.action(ActionCode.COMET_BEGIN, null); } } else { comet = true; res.action(ActionCode.COMET_BEGIN, null); } } else { // Clear the filter chain, as otherwise it will not be reset elsewhere request.setFilterChain(null); } } if (!request.isAsync() && !comet) { request.finishRequest(); response.finishResponse(); req.action(ActionCode.POST_REQUEST, null); } } catch (IOException e) { success = false; // Ignore } catch (Throwable t) { ExceptionUtils.handleThrowable(t); success = false; log.error(sm.getString("coyoteAdapter.service"), t); } finally { req.getRequestProcessor().setWorkerThreadName(null); if (!success || (!comet && !request.isAsync())) { request.recycle(); response.recycle(); } else { // Clear converters so that the minimum amount of memory request.clearEncoders(); response.clearEncoders(); } } return success; }	public void testBug50753() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Bug50753Servlet servlet = new Bug50753Servlet(); Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet); wrapper.setAsyncSupported(true); ctx.addServletMapping("/", "servlet"); tomcat.start(); Map<String, List<String>> headers = new LinkedHashMap<String, List<String>>(); ByteChunk bc = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/", bc, headers); assertEquals(200, rc); assertEquals("OK", bc.toString()); List<String> testHeader = headers.get("A"); assertNotNull(testHeader); assertEquals(1, testHeader.size()); assertEquals("xyz", testHeader.get(0)); }	public void testAsyncStartNoComplete() throws Exception { Tomcat tomcat = getTomcatInstance(); tomcat.getConnector().setAttribute("connectionTimeout", Integer.valueOf(3000)); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); AsyncStartNoCompleteServlet servlet = new AsyncStartNoCompleteServlet(); Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet); wrapper.setAsyncSupported(true); ctx.addServletMapping("/", "servlet"); tomcat.start(); ByteChunk bc1 = getUrl("http://localhost:" + getPort() + "/?echo=run1"); assertEquals("OK-run1", bc1.toString()); ByteChunk bc2 = getUrl("http://localhost:" + getPort() + "/?echo=run2"); assertEquals("OK-run2", bc2.toString()); }	public void testAsyncStartWithComplete() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); AsyncStartWithCompleteServlet servlet = new AsyncStartWithCompleteServlet(); Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet); wrapper.setAsyncSupported(true); ctx.addServletMapping("/", "servlet"); tomcat.start(); ByteChunk bc = getUrl("http://localhost:" + getPort() + "/"); assertEquals("OK", bc.toString()); }	public void testBug49528() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Bug49528Servlet servlet = new Bug49528Servlet(); Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet); wrapper.setAsyncSupported(true); ctx.addServletMapping("/", "servlet"); tomcat.start(); ByteChunk bc = getUrl("http://localhost:" + getPort() + "/"); assertEquals("OK", bc.toString()); int counter = 0; while (!servlet.isDone() && counter < 10) { Thread.sleep(1000); counter++; } assertEquals("1false2true3true4true5false", servlet.getResult()); }	public void testBug49567() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Bug49567Servlet servlet = new Bug49567Servlet(); Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet); wrapper.setAsyncSupported(true); ctx.addServletMapping("/", "servlet"); tomcat.start(); ByteChunk bc = getUrl("http://localhost:" + getPort() + "/"); assertEquals("OK", bc.toString()); int counter = 0; while (!servlet.isDone() && counter < 10) { Thread.sleep(1000); counter++; } assertEquals("1false2true3true4true5false", servlet.getResult()); }	void testBug50352() throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); AsyncStartRunnable servlet = new AsyncStartRunnable(); Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet); wrapper.setAsyncSupported(true); ctx.addServletMapping("/", "servlet"); ErrorServlet error = new ErrorServlet(); Tomcat.addServlet(ctx, "error", error); ctx.addServletMapping("/stage2", "error"); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/"); assertEquals("Runnable-onComplete-", res.toString()); }	public void testBug50753() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Bug50753Servlet servlet = new Bug50753Servlet(); Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet); wrapper.setAsyncSupported(true); ctx.addServletMapping("/", "servlet"); tomcat.start(); Map<String, List<String>> headers = new LinkedHashMap<String, List<String>>(); ByteChunk bc = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + "/", bc, headers); assertEquals(200, rc); assertEquals("OK", bc.toString()); List<String> testHeader = headers.get("A"); assertNotNull(testHeader); assertEquals(1, testHeader.size()); assertEquals("xyz", testHeader.get(0)); }	void testListeners() throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); TrackingServlet tracking = new TrackingServlet(); Wrapper wrapper = Tomcat.addServlet(ctx, "tracking", tracking); wrapper.setAsyncSupported(true); ctx.addServletMapping("/stage1", "tracking"); TimeoutServlet timeout = new TimeoutServlet(true, null); Wrapper wrapper2 = Tomcat.addServlet(ctx, "timeout", timeout); wrapper2.setAsyncSupported(true); ctx.addServletMapping("/stage2", "timeout"); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/stage1"); ByteChunk res = getUrl(url.toString()); assertEquals("DispatchingServletGet-DispatchingServletGet-onStartAsync-" + "TimeoutServletGet-onStartAsync-onTimeout-onComplete-", res.toString()); }
private String getJarName(URL url) { String name = null; String path = url.getPath(); int end = path.indexOf(Constants.JAR_EXT); if (end != -1) { int start = path.lastIndexOf('/', end); name = path.substring(start + 1, end + 4); } return name; }	public Map<String, WebXml> getFragments() { return fragments; }
@Override public void bind() throws Exception { try { rootPool = Pool.create(0); } catch (UnsatisfiedLinkError e) { throw new Exception(sm.getString("endpoint.init.notavail")); } serverSockPool = Pool.create(rootPool); String addressStr = null; if (getAddress() != null) { addressStr = getAddress().getHostAddress(); } int family = Socket.APR_INET; if (Library.APR_HAVE_IPV6) { if (addressStr == null) { if (!OS.IS_BSD && !OS.IS_WIN32 && !OS.IS_WIN64) family = Socket.APR_UNSPEC; } else if (addressStr.indexOf(':') >= 0) { family = Socket.APR_UNSPEC; } } long inetAddress = Address.info(addressStr, family, getPort(), 0, rootPool); serverSock = Socket.create(Address.getInfo(inetAddress).family, Socket.SOCK_STREAM, Socket.APR_PROTO_TCP, rootPool); if (OS.IS_UNIX) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } Socket.optSet(serverSock, Socket.APR_SO_KEEPALIVE, 1); int ret = Socket.bind(serverSock, inetAddress); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.bind", "" + ret, Error.strerror(ret))); } ret = Socket.listen(serverSock, getBacklog()); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.listen", "" + ret, Error.strerror(ret))); } if (OS.IS_WIN32 || OS.IS_WIN64) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } if (useSendfile && !Library.APR_HAS_SENDFILE) { useSendfile = false; } if (acceptorThreadCount == 0) { acceptorThreadCount = 1; } if (pollerThreadCount == 0) { if ((OS.IS_WIN32 || OS.IS_WIN64) && (pollerSize > 1024)) { pollerThreadCount = pollerSize / 1024; pollerSize = pollerSize - (pollerSize % 1024); } else { pollerThreadCount = 1; } } if (sendfileThreadCount == 0) { if ((OS.IS_WIN32 || OS.IS_WIN64) && (sendfileSize > 1024)) { sendfileThreadCount = sendfileSize / 1024; sendfileSize = sendfileSize - (sendfileSize % 1024); } else { // No explicit poller size limitation sendfileThreadCount = 1; } } if (deferAccept) { if (Socket.optSet(serverSock, Socket.APR_TCP_DEFER_ACCEPT, 1) == Status.APR_ENOTIMPL) { deferAccept = false; } } if (isSSLEnabled()) { int value = SSL.SSL_PROTOCOL_ALL; if ("SSLv2".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV2; } else if ("SSLv3".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV3; } else if ("TLSv1".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_TLSV1; } else if ("SSLv2+SSLv3".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV2 | SSL.SSL_PROTOCOL_SSLV3; } sslContext = SSLContext.make(rootPool, value, SSL.SSL_MODE_SERVER); if (SSLInsecureRenegotiation) { boolean legacyRenegSupported = false; try { legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); if (legacyRenegSupported) SSLContext.setOptions(sslContext, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); } catch (UnsatisfiedLinkError e) { // Ignore } if (!legacyRenegSupported) { log.warn(sm.getString("endpoint.warn.noInsecureReneg", SSL.versionString())); } } SSLContext.setCipherSuite(sslContext, SSLCipherSuite); SSLContext.setCertificate(sslContext, SSLCertificateFile, SSLCertificateKeyFile, SSLPassword, SSL.SSL_AIDX_RSA); SSLContext.setCertificateChainFile(sslContext, SSLCertificateChainFile, false); SSLContext.setCACertificate(sslContext, SSLCACertificateFile, SSLCACertificatePath); SSLContext.setCARevocation(sslContext, SSLCARevocationFile, SSLCARevocationPath); value = SSL.SSL_CVERIFY_NONE; if ("optional".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL; } else if ("require".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_REQUIRE; } else if ("optionalNoCA".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA; } SSLContext.setVerify(sslContext, value, SSLVerifyDepth); useSendfile = false; } }
protected Connection open() throws SQLException { if (dbConnection != null) return (dbConnection); if (driver == null) { try { Class<?> clazz = Class.forName(driverName); driver = (Driver) clazz.newInstance(); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); throw new SQLException(e.getMessage()); } } Properties props = new Properties(); if (connectionName != null) props.put("user", connectionName); if (connectionPassword != null) props.put("password", connectionPassword); dbConnection = driver.connect(connectionURL, props); if (dbConnection == null) { throw new SQLException(sm.getString("jdbcRealm.open.invalidurl", driverName, connectionURL)); } dbConnection.setAutoCommit(false); return (dbConnection); }	protected void open() throws SQLException { if (conn != null) return; if (driver == null) { try { Class<?> clazz = Class.forName(driverName); driver = (Driver) clazz.newInstance(); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); throw new SQLException(e.getMessage()); } } Properties props = new Properties(); props.put("autoReconnect", "true"); if (connectionName != null) props.put("user", connectionName); if (connectionPassword != null) props.put("password", connectionPassword); conn = driver.connect(connectionURL, props); conn.setAutoCommit(true); String logPattern = pattern; if (logPattern.equals("common")) { ps = conn.prepareStatement("INSERT INTO " + tableName + " (" + remoteHostField + ", " + userField + ", " + timestampField + ", " + queryField + ", " + statusField + ", " + bytesField + ") VALUES(?, ?, ?, ?, ?, ?)"); } else if (logPattern.equals("combined")) { ps = conn.prepareStatement("INSERT INTO " + tableName + " (" + remoteHostField + ", " + userField + ", " + timestampField + ", " + queryField + ", " + statusField + ", " + bytesField + ", " + virtualHostField + ", " + methodField + ", " + refererField + ", " + userAgentField + ") VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"); } }	public static Hashtable<String, String[]> parsePostData(int len, ServletInputStream in) { if (len <= 0) return new Hashtable<String, String[]>(); if (in == null) { throw new IllegalArgumentException(); } byte[] postedBytes = new byte[len]; try { int offset = 0; do { int inputLen = in.read(postedBytes, offset, len - offset); if (inputLen <= 0) { String msg = lStrings.getString("err.io.short_read"); throw new IllegalArgumentException(msg); } offset += inputLen; } while ((len - offset) > 0); } catch (IOException e) { throw new IllegalArgumentException(e.getMessage()); } try { String postedBody = new String(postedBytes, 0, len, "8859_1"); return parseQueryString(postedBody); } catch (java.io.UnsupportedEncodingException e) { throw new IllegalArgumentException(e.getMessage()); } }	@Override public InputStream streamContent() throws IOException { try { if (binaryContent == null) { InputStream is = base.getInputStream(entry); inputStream = is; return is; } } catch (ZipException e) { throw new IOException(e.getMessage()); } return super.streamContent(); }	@Override public int read(final byte[] b, final int off, final int len) throws IOException { if (SecurityUtil.isPackageProtectionEnabled()) { try { Integer result = AccessController.doPrivileged(new PrivilegedExceptionAction<Integer>() { @Override public Integer run() throws IOException { Integer integer = Integer.valueOf(ib.read(b, off, len)); return integer; } }); return result.intValue(); } catch (PrivilegedActionException pae) { Exception e = pae.getException(); if (e instanceof IOException) { throw (IOException) e; } else { throw new RuntimeException(e.getMessage()); } } } else { return ib.read(b, off, len); } }	public void close() throws IOException { if (SecurityUtil.isPackageProtectionEnabled()) { try { AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() { @Override public Void run() throws IOException { ib.close(); return null; } }); } catch (PrivilegedActionException pae) { Exception e = pae.getException(); if (e instanceof IOException) { throw (IOException) e; } else { throw new RuntimeException(e.getMessage()); } } } else { ib.close(); } }	@Override public void characters(char[] ch, int start, int length) throws SAXException { try { String str = new String(ch, start, length); if (str.trim().length() > 0) { top.appendChild(doc.createTextNode(str)); } } catch (DOMException e) { throw new SAXException(e.getMessage()); } }	@Override public void endElement(String namespaceURI, String localName, String qName) throws SAXException { try { if (depth == 0) { getDigester().getXMLReader().setContentHandler(oldContentHandler); getDigester().push(root); getDigester().endElement(namespaceURI, localName, qName); } top = top.getParentNode(); depth--; } catch (DOMException e) { throw new SAXException(e.getMessage()); } }	@Override public void processingInstruction(String target, String data) throws SAXException { try { top.appendChild(doc.createProcessingInstruction(target, data)); } catch (DOMException e) { throw new SAXException(e.getMessage()); } }	@Override public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException { try { Node previousTop = top; if ((localName == null) || (localName.length() == 0)) { top = doc.createElement(qName); } else { top = doc.createElementNS(namespaceURI, localName); } for (int i = 0; i < atts.getLength(); i++) { Attr attr = null; if ((atts.getLocalName(i) == null) || (atts.getLocalName(i).length() == 0)) { attr = doc.createAttribute(atts.getQName(i)); attr.setNodeValue(atts.getValue(i)); ((Element) top).setAttributeNode(attr); } else { attr = doc.createAttributeNS(atts.getURI(i), atts.getLocalName(i)); attr.setNodeValue(atts.getValue(i)); ((Element) top).setAttributeNodeNS(attr); } } previousTop.appendChild(top); depth++; } catch (DOMException e) { throw new SAXException(e.getMessage()); } }
public SocketState process(NioChannel socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); this.socket = socket; inputBuffer.setSocket(socket); outputBuffer.setSocket(socket); inputBuffer.setSelectorPool(endpoint.getSelectorPool()); outputBuffer.setSelectorPool(endpoint.getSelectorPool()); error = false; keepAlive = true; comet = false; long soTimeout = endpoint.getSoTimeout(); int keepAliveTimeout = endpoint.getKeepAliveTimeout(); boolean keptAlive = false; boolean openSocket = false; boolean recycle = true; final KeyAttachment ka = (KeyAttachment) socket.getAttachment(false); while (!error && keepAlive && !comet && !isAsync() && !endpoint.isPaused()) { ka.setTimeout(soTimeout); try { if (!disableUploadTimeout && keptAlive && soTimeout > 0) { socket.getIOChannel().socket().setSoTimeout((int) soTimeout); } if (!inputBuffer.parseRequestLine(keptAlive)) { // Haven't finished reading the request so keep the socket openSocket = true; if (inputBuffer.getParsingRequestLinePhase() < 2) { if (keepAliveTimeout > 0) ka.setTimeout(keepAliveTimeout); } else { // Started to read request line. Need to keep processor recycle = false; } break; } keptAlive = true; if (!inputBuffer.parseHeaders()) { //we've read part of the request, don't recycle it openSocket = true; recycle = false; break; } request.setStartTime(System.currentTimeMillis()); if (!disableUploadTimeout) { socket.getIOChannel().socket().setSoTimeout(connectionUploadTimeout); } } catch (IOException e) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.header.parse"), e); } error = true; break; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.header.parse"), t); } response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare"), t); } response.setStatus(400); adapter.log(request, response, 0); error = true; } } if (maxKeepAliveRequests == 1) keepAlive = false; if (maxKeepAliveRequests > 0 && ka.decrementKeepAlive() <= 0) keepAlive = false; if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); if (keepAlive && !error) { error = response.getErrorException() != null || statusDropsConnection(response.getStatus()); } SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); if (key != null) { NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment(); if (attach != null) { attach.setComet(comet); if (comet) { Integer comettimeout = (Integer) request.getAttribute("org.apache.tomcat.comet.timeout"); if (comettimeout != null) attach.setTimeout(comettimeout.longValue()); } } } } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("http11processor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (!comet && !isAsync()) { if (error) inputBuffer.setSwallowInput(false); endRequest(); } if (error) { response.setStatus(500); } request.updateCounters(); if (!comet && !isAsync()) { inputBuffer.nextRequest(); outputBuffer.nextRequest(); } if (sendfileData != null && !error) { ka.setSendfileData(sendfileData); sendfileData.keepAlive = keepAlive; SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); openSocket = socket.getPoller().processSendfile(key, ka, true, true); break; } rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (error || endpoint.isPaused()) { recycle(); return SocketState.CLOSED; } else if (comet || isAsync()) { return SocketState.LONG; } else { if (recycle) { recycle(); } return (openSocket) ? (recycle ? SocketState.OPEN : SocketState.LONG) : SocketState.CLOSED; } }	public SocketState process(SocketWrapper<Long> socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); remoteAddr = null; remoteHost = null; localAddr = null; localName = null; remotePort = -1; localPort = -1; this.socket = socket; long socketRef = socket.getSocket().longValue(); inputBuffer.setSocket(socketRef); outputBuffer.setSocket(socketRef); error = false; comet = false; keepAlive = true; int keepAliveLeft = maxKeepAliveRequests; long soTimeout = endpoint.getSoTimeout(); boolean keptAlive = false; boolean openSocket = false; while (!error && keepAlive && !comet && !isAsync() && !endpoint.isPaused()) { try { if (!disableUploadTimeout && keptAlive && soTimeout > 0) { Socket.timeoutSet(socketRef, soTimeout * 1000); } if (!inputBuffer.parseRequestLine(keptAlive)) { // This means that no data is available right now // (long keepalive), so that the processor should be recycled openSocket = true; endpoint.getPoller().add(socketRef); break; } request.setStartTime(System.currentTimeMillis()); keptAlive = true; if (!disableUploadTimeout) { Socket.timeoutSet(socketRef, connectionUploadTimeout * 1000); } inputBuffer.parseHeaders(); } catch (IOException e) { error = true; break; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.header.parse"), t); } response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare"), t); } response.setStatus(400); adapter.log(request, response, 0); error = true; } } if (maxKeepAliveRequests > 0 && --keepAliveLeft == 0) keepAlive = false; if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); if (keepAlive && !error) { error = response.getErrorException() != null || statusDropsConnection(response.getStatus()); } } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("http11processor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (!comet && !isAsync()) { if (error) inputBuffer.setSwallowInput(false); endRequest(); } if (error) { response.setStatus(500); } request.updateCounters(); if (!comet && !isAsync()) { inputBuffer.nextRequest(); outputBuffer.nextRequest(); } if (sendfileData != null && !error) { sendfileData.socket = socketRef; sendfileData.keepAlive = keepAlive; if (!endpoint.getSendfile().add(sendfileData)) { openSocket = true; break; } } rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (error || endpoint.isPaused()) { recycle(); return SocketState.CLOSED; } else if (comet || isAsync()) { return SocketState.LONG; } else { recycle(); return (openSocket) ? SocketState.OPEN : SocketState.CLOSED; } }	public SocketState process(SocketWrapper<Socket> socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); this.socket = socket; input = socket.getSocket().getInputStream(); output = socket.getSocket().getOutputStream(); int soTimeout = -1; if (keepAliveTimeout > 0) { soTimeout = socket.getSocket().getSoTimeout(); } error = false; while (!error && !endpoint.isPaused()) { try { if (keepAliveTimeout > 0) { socket.getSocket().setSoTimeout(keepAliveTimeout); } if (!readMessage(requestHeaderMessage)) { rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); break; } if (keepAliveTimeout > 0) { socket.getSocket().setSoTimeout(soTimeout); } // Check message type, process right away and break if int type = requestHeaderMessage.getByte(); if (type == Constants.JK_AJP13_CPING_REQUEST) { try { output.write(pongMessageArray); } catch (IOException e) { error = true; } continue; } else if (type != Constants.JK_AJP13_FORWARD_REQUEST) { if (log.isDebugEnabled()) { log.debug("Unexpected message: " + type); } continue; } request.setStartTime(System.currentTimeMillis()); } catch (IOException e) { error = true; break; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.header.error"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString("ajpprocessor.request.prepare"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("ajpprocessor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (isAsync() && !error) { break; } if (!finished) { try { finish(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); error = true; } } if (error) { response.setStatus(500); } request.updateCounters(); rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); recycle(); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (isAsync() && !error && !endpoint.isPaused()) { return SocketState.LONG; } else { recycle(); input = null; output = null; return SocketState.CLOSED; } }	public static int getUrl(String path, ByteChunk out, Map<String, List<String>> reqHead, Map<String, List<String>> resHead) throws IOException { URL url = new URL(path); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setReadTimeout(1000000); if (reqHead != null) { for (Map.Entry<String, List<String>> entry : reqHead.entrySet()) { StringBuilder valueList = new StringBuilder(); for (String value : entry.getValue()) { if (valueList.length() > 0) { valueList.append(','); } valueList.append(value); } connection.setRequestProperty(entry.getKey(), valueList.toString()); } } connection.connect(); int rc = connection.getResponseCode(); if (resHead != null) { Map<String, List<String>> head = connection.getHeaderFields(); resHead.putAll(head); } if (rc == HttpServletResponse.SC_OK) { InputStream is = connection.getInputStream(); BufferedInputStream bis = null; try { bis = new BufferedInputStream(is); byte[] buf = new byte[2048]; int rd = 0; while ((rd = bis.read(buf)) > 0) { out.append(buf, 0, rd); } } finally { if (bis != null) { try { bis.close(); } catch (IOException e) { // Ignore } } } } return rc; }
@Override protected AbstractEndpoint getEndpoint() { return endpoint; }	protected AjpAprProcessor createProcessor() { AjpAprProcessor processor = new AjpAprProcessor(proto.packetSize, (AprEndpoint) proto.endpoint); processor.setAdapter(proto.adapter); processor.setTomcatAuthentication(proto.tomcatAuthentication); processor.setRequiredSecret(proto.requiredSecret); register(processor); return processor; }	protected AjpProcessor createProcessor() { AjpProcessor processor = new AjpProcessor(proto.packetSize, (JIoEndpoint) proto.endpoint); processor.setAdapter(proto.adapter); processor.setTomcatAuthentication(proto.tomcatAuthentication); processor.setRequiredSecret(proto.requiredSecret); processor.setKeepAliveTimeout(proto.getKeepAliveTimeout()); register(processor); return processor; }	protected Http11AprProcessor createProcessor() { Http11AprProcessor processor = new Http11AprProcessor(proto.getMaxHttpHeaderSize(), (AprEndpoint) proto.endpoint, proto.getMaxTrailerSize()); processor.setAdapter(proto.adapter); processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests()); processor.setConnectionUploadTimeout(proto.getConnectionUploadTimeout()); processor.setDisableUploadTimeout(proto.getDisableUploadTimeout()); processor.setCompressionMinSize(proto.getCompressionMinSize()); processor.setCompression(proto.getCompression()); processor.setNoCompressionUserAgents(proto.getNoCompressionUserAgents()); processor.setCompressableMimeTypes(proto.getCompressableMimeTypes()); processor.setRestrictedUserAgents(proto.getRestrictedUserAgents()); processor.setSocketBuffer(proto.getSocketBuffer()); processor.setMaxSavePostSize(proto.getMaxSavePostSize()); processor.setServer(proto.getServer()); register(processor); return processor; }	@Override public final void action(ActionCode actionCode, Object param) { if (actionCode == ActionCode.COMMIT) { if (response.isCommitted()) return; try { prepareResponse(); } catch (IOException e) { error = true; } try { flush(false); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.CLIENT_FLUSH) { if (!response.isCommitted()) { try { prepareResponse(); } catch (IOException e) { error = true; return; } } try { flush(true); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.DISABLE_SWALLOW_INPUT) { // TODO: Do not swallow request input but error = true; } else if (actionCode == ActionCode.CLOSE) { try { finish(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE) { if (!certificates.isNull()) { ByteChunk certData = certificates.getByteChunk(); X509Certificate[] jsseCerts = null; ByteArrayInputStream bais = new ByteArrayInputStream(certData.getBytes(), certData.getStart(), certData.getLength()); try { CertificateFactory cf = CertificateFactory.getInstance("X.509"); while (bais.available() > 0) { X509Certificate cert = (X509Certificate) cf.generateCertificate(bais); if (jsseCerts == null) { jsseCerts = new X509Certificate[1]; jsseCerts[0] = cert; } else { X509Certificate[] temp = new X509Certificate[jsseCerts.length + 1]; System.arraycopy(jsseCerts, 0, temp, 0, jsseCerts.length); temp[jsseCerts.length] = cert; jsseCerts = temp; } } } catch (java.security.cert.CertificateException e) { getLog().error(sm.getString("ajpprocessor.certs.fail"), e); return; } request.setAttribute(SSLSupport.CERTIFICATE_KEY, jsseCerts); } } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) { if (request.remoteHost().isNull()) { try { request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName()); } catch (IOException iex) { // Ignore } } } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) { request.localAddr().setString(request.localName().toString()); } else if (actionCode == ActionCode.REQ_SET_BODY_REPLAY) { ByteChunk bc = (ByteChunk) param; int length = bc.getLength(); bodyBytes.setBytes(bc.getBytes(), bc.getStart(), length); request.setContentLength(length); first = false; empty = false; replay = true; } else if (actionCode == ActionCode.ASYNC_START) { asyncStateMachine.asyncStart((AsyncContextCallback) param); } else if (actionCode == ActionCode.ASYNC_DISPATCHED) { asyncStateMachine.asyncDispatched(); } else if (actionCode == ActionCode.ASYNC_TIMEOUT) { AtomicBoolean result = (AtomicBoolean) param; result.set(asyncStateMachine.asyncTimeout()); } else if (actionCode == ActionCode.ASYNC_RUN) { asyncStateMachine.asyncRun((Runnable) param); } else if (actionCode == ActionCode.ASYNC_ERROR) { asyncStateMachine.asyncError(); } else if (actionCode == ActionCode.ASYNC_IS_STARTED) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted()); } else if (actionCode == ActionCode.ASYNC_IS_DISPATCHING) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching()); } else if (actionCode == ActionCode.ASYNC_IS_ASYNC) { ((AtomicBoolean) param).set(asyncStateMachine.isAsync()); } else if (actionCode == ActionCode.ASYNC_IS_TIMINGOUT) { ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut()); } else { actionInternal(actionCode, param); } }	@Override public void actionInternal(ActionCode actionCode, Object param) { long socketRef = socket.getSocket().longValue(); if (actionCode == ActionCode.CLOSE) { // Close // End the processing of the current request, and stop any further comet = false; try { outputBuffer.endRequest(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.REQ_HOST_ADDR_ATTRIBUTE) { if (remoteAddr == null && (socketRef != 0)) { try { long sa = Address.get(Socket.APR_REMOTE, socketRef); remoteAddr = Address.getip(sa); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.remoteAddr().setString(remoteAddr); } else if (actionCode == ActionCode.REQ_LOCAL_NAME_ATTRIBUTE) { if (localName == null && (socketRef != 0)) { try { long sa = Address.get(Socket.APR_LOCAL, socketRef); localName = Address.getnameinfo(sa, 0); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.localName().setString(localName); } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) { if (remoteHost == null && (socketRef != 0)) { try { long sa = Address.get(Socket.APR_REMOTE, socketRef); remoteHost = Address.getnameinfo(sa, 0); if (remoteHost == null) { remoteHost = Address.getip(sa); } } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.remoteHost().setString(remoteHost); } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) { if (localAddr == null && (socketRef != 0)) { try { long sa = Address.get(Socket.APR_LOCAL, socketRef); localAddr = Address.getip(sa); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.localAddr().setString(localAddr); } else if (actionCode == ActionCode.REQ_REMOTEPORT_ATTRIBUTE) { if (remotePort == -1 && (socketRef != 0)) { try { long sa = Address.get(Socket.APR_REMOTE, socketRef); Sockaddr addr = Address.getInfo(sa); remotePort = addr.port; } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.setRemotePort(remotePort); } else if (actionCode == ActionCode.REQ_LOCALPORT_ATTRIBUTE) { if (localPort == -1 && (socketRef != 0)) { try { long sa = Address.get(Socket.APR_LOCAL, socketRef); Sockaddr addr = Address.getInfo(sa); localPort = addr.port; } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.setLocalPort(localPort); } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE) { if (ssl && (socketRef != 0)) { try { Object sslO = SSLSocket.getInfoS(socketRef, SSL.SSL_INFO_CIPHER); if (sslO != null) { request.setAttribute(SSLSupport.CIPHER_SUITE_KEY, sslO); } // Get client certificate and the certificate chain if present int certLength = SSLSocket.getInfoI(socketRef, SSL.SSL_INFO_CLIENT_CERT_CHAIN); byte[] clientCert = SSLSocket.getInfoB(socketRef, SSL.SSL_INFO_CLIENT_CERT); X509Certificate[] certs = null; if (clientCert != null && certLength > -1) { certs = new X509Certificate[certLength + 1]; CertificateFactory cf = CertificateFactory.getInstance("X.509"); certs[0] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(clientCert)); for (int i = 0; i < certLength; i++) { byte[] data = SSLSocket.getInfoB(socketRef, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i); certs[i + 1] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data)); } } if (certs != null) { request.setAttribute(SSLSupport.CERTIFICATE_KEY, certs); } sslO = Integer.valueOf(SSLSocket.getInfoI(socketRef, SSL.SSL_INFO_CIPHER_USEKEYSIZE)); request.setAttribute(SSLSupport.KEY_SIZE_KEY, sslO); sslO = SSLSocket.getInfoS(socketRef, SSL.SSL_INFO_SESSION_ID); if (sslO != null) { request.setAttribute(SSLSupport.SESSION_ID_KEY, sslO); } //TODO provide a hook to enable the SSL session to be // invalidated. Set AprEndpoint.SESSION_MGR req attr } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } } else if (actionCode == ActionCode.REQ_SSL_CERTIFICATE) { if (ssl && (socketRef != 0)) { // Consume and buffer the request body, so that it does not InputFilter[] inputFilters = inputBuffer.getFilters(); ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize); inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]); try { SSLSocket.setVerify(socketRef, SSL.SSL_CVERIFY_REQUIRE, endpoint.getSSLVerifyDepth()); if (SSLSocket.renegotiate(socketRef) == 0) { // Don't look for certs unless we know renegotiation worked. // Get client certificate and the certificate chain if present int certLength = SSLSocket.getInfoI(socketRef, SSL.SSL_INFO_CLIENT_CERT_CHAIN); byte[] clientCert = SSLSocket.getInfoB(socketRef, SSL.SSL_INFO_CLIENT_CERT); X509Certificate[] certs = null; if (clientCert != null && certLength > -1) { certs = new X509Certificate[certLength + 1]; CertificateFactory cf = CertificateFactory.getInstance("X.509"); certs[0] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(clientCert)); for (int i = 0; i < certLength; i++) { byte[] data = SSLSocket.getInfoB(socketRef, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i); certs[i + 1] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data)); } } if (certs != null) { request.setAttribute(SSLSupport.CERTIFICATE_KEY, certs); } } } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } } else if (actionCode == ActionCode.AVAILABLE) { request.setAvailable(inputBuffer.available()); } else if (actionCode == ActionCode.COMET_BEGIN) { comet = true; } else if (actionCode == ActionCode.COMET_END) { comet = false; } else if (actionCode == ActionCode.COMET_CLOSE) { endpoint.processSocketAsync(this.socket, SocketStatus.OPEN); } else if (actionCode == ActionCode.COMET_SETTIMEOUT) { //no op } else if (actionCode == ActionCode.ASYNC_COMPLETE) { if (asyncStateMachine.asyncComplete()) { endpoint.processSocketAsync(this.socket, SocketStatus.OPEN); } } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) { if (param == null) return; long timeout = ((Long) param).longValue(); socket.setTimeout(timeout); } else if (actionCode == ActionCode.ASYNC_DISPATCH) { if (asyncStateMachine.asyncDispatch()) { endpoint.processSocketAsync(this.socket, SocketStatus.OPEN); } } }	@Override public void invoke(Request request, Response response) throws IOException, ServletException { String strcert0 = mygetHeader(request, "ssl_client_cert"); if (strcert0 != null && strcert0.length() > 28) { String strcert1 = strcert0.replace(' ', '\n'); String strcert2 = strcert1.substring(28, strcert1.length() - 26); String strcert3 = "-----BEGIN CERTIFICATE-----\n"; String strcert4 = strcert3.concat(strcert2); String strcerts = strcert4.concat("\n-----END CERTIFICATE-----\n"); ByteArrayInputStream bais = new ByteArrayInputStream(strcerts.getBytes()); X509Certificate[] jsseCerts = null; try { CertificateFactory cf = CertificateFactory.getInstance("X.509"); X509Certificate cert = (X509Certificate) cf.generateCertificate(bais); jsseCerts = new X509Certificate[1]; jsseCerts[0] = cert; } catch (java.security.cert.CertificateException e) { System.out.println("SSLValve failed " + strcerts); System.out.println("SSLValve failed " + e); } request.setAttribute(Globals.CERTIFICATES_ATTR, jsseCerts); } strcert0 = mygetHeader(request, "ssl_cipher"); if (strcert0 != null) { request.setAttribute(Globals.CIPHER_SUITE_ATTR, strcert0); } strcert0 = mygetHeader(request, "ssl_session_id"); if (strcert0 != null) { request.setAttribute(Globals.SSL_SESSION_ID_ATTR, strcert0); } strcert0 = mygetHeader(request, "ssl_cipher_usekeysize"); if (strcert0 != null) { request.setAttribute(Globals.KEY_SIZE_ATTR, strcert0); } getNext().invoke(request, response); }	@Override public Executor getExecutor() { return endpoint.getExecutor(); }	public void setRequiredSecret(String requiredSecret) { this.requiredSecret = requiredSecret; }
private String getCanonicalName(String className) throws JasperException { Class<?> clazz; ClassLoader tccl; if (Constants.IS_SECURITY_ENABLED) { PrivilegedAction<ClassLoader> pa = new PrivilegedGetTccl(); tccl = AccessController.doPrivileged(pa); } else { tccl = Thread.currentThread().getContextClassLoader(); } try { clazz = Class.forName(className, true, tccl); } catch (ClassNotFoundException e) { throw new JasperException(e); } return clazz.getCanonicalName(); }
/** * Stop this component and implement the requirements * of {@link org.apache.catalina.util.LifecycleBase#stopInternal()}. * * @exception LifecycleException if this component detects a fatal error * that prevents this component from being used */ @Override protected synchronized void stopInternal() throws LifecycleException { // Send j2ee.state.stopping notification if (this.getObjectName() != null) { Notification notification = new Notification("j2ee.state.stopping", this.getObjectName(), sequenceNumber.getAndIncrement()); broadcaster.sendNotification(notification); } setState(LifecycleState.STOPPING); // Currently this is effectively a NO-OP but needs to be called to // ensure the NamingResources follows the correct lifecycle if (namingResources != null) { namingResources.stop(); } // Binding thread ClassLoader oldCCL = bindThread(); try { // Stop our child containers, if any final Container[] children = findChildren(); // we do it in a dedicated thread for memory leak protection, in // case some webapp code registers some ThreadLocals that they // forget to cleanup DedicatedThreadExecutor.executeInOwnThread( new Callable<Void>() { @Override } } }	@Override protected void stopInternal() throws LifecycleException { setState(LifecycleState.STOPPING); fireLifecycleEvent(CONFIGURE_STOP_EVENT, null); }
@Override protected void startInternal() throws LifecycleException { if (log.isDebugEnabled()) log.debug(sm.getString("webappLoader.starting")); if (container.getResources() == null) { log.info("No resources for " + container); setState(LifecycleState.STARTING); return; } URLStreamHandlerFactory streamHandlerFactory = new DirContextURLStreamHandlerFactory(); if (first) { first = false; try { URL.setURLStreamHandlerFactory(streamHandlerFactory); } catch (Exception e) { log.error("Error registering jndi stream handler", e); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.info("Dual registration of jndi stream handler: " + t.getMessage()); } } try { classLoader = createClassLoader(); classLoader.setResources(container.getResources()); classLoader.setDelegate(this.delegate); classLoader.setSearchExternalFirst(searchExternalFirst); if (container instanceof StandardContext) { classLoader.setAntiJARLocking(((StandardContext) container).getAntiJARLocking()); classLoader.setClearReferencesStatic(((StandardContext) container).getClearReferencesStatic()); classLoader.setClearReferencesStopThreads(((StandardContext) container).getClearReferencesStopThreads()); classLoader.setClearReferencesStopTimerThreads(((StandardContext) container).getClearReferencesStopTimerThreads()); classLoader.setClearReferencesHttpClientKeepAliveThread(((StandardContext) container).getClearReferencesHttpClientKeepAliveThread()); } for (int i = 0; i < repositories.length; i++) { classLoader.addRepository(repositories[i]); } setRepositories(); setClassPath(); setPermissions(); ((Lifecycle) classLoader).start(); DirContextURLStreamHandler.bind(classLoader, this.container.getResources()); StandardContext ctx = (StandardContext) container; String contextName = ctx.getName(); if (!contextName.startsWith("/")) { contextName = "/" + contextName; } ObjectName cloname = new ObjectName(MBeanUtils.getDomain(ctx) + ":type=WebappClassLoader,context=" + contextName + ",host=" + ctx.getParent().getName()); Registry.getRegistry(null, null).registerComponent(classLoader, cloname, null); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error("LifecycleException ", t); throw new LifecycleException("start: ", t); } setState(LifecycleState.STARTING); }	@Override public URLStreamHandler createURLStreamHandler(String protocol) { if (protocol.equals("jndi")) { return new DirContextURLStreamHandler(); } else { return null; } }
public void register(Request request, HttpServletResponse response, Principal principal, String authType, String username, String password) { if (log.isDebugEnabled()) log.debug("Authenticated '" + principal.getName() + "' with type '" + authType + "'"); request.setAuthType(authType); request.setUserPrincipal(principal); Session session = request.getSessionInternal(false); if (session != null) { if (changeSessionIdOnAuthentication) { Manager manager = request.getContext().getManager(); manager.changeSessionId(session); request.changeSessionId(session.getId()); } } else if (alwaysUseSession) { session = request.getSessionInternal(true); } if (cache) { if (session != null) { session.setAuthType(authType); session.setPrincipal(principal); if (username != null) session.setNote(Constants.SESS_USERNAME_NOTE, username); else session.removeNote(Constants.SESS_USERNAME_NOTE); if (password != null) session.setNote(Constants.SESS_PASSWORD_NOTE, password); else session.removeNote(Constants.SESS_PASSWORD_NOTE); } } if (sso == null) return; // Only create a new SSO entry if the SSO did not already set a note // for an existing entry (as it would do with subsequent requests String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (ssoId == null) { ssoId = sessionIdGenerator.generateSessionId(); Cookie cookie = new Cookie(Constants.SINGLE_SIGN_ON_COOKIE, ssoId); cookie.setMaxAge(-1); cookie.setPath("/"); cookie.setSecure(request.isSecure()); String ssoDomain = sso.getCookieDomain(); if (ssoDomain != null) { cookie.setDomain(ssoDomain); } if (request.getServletContext().getSessionCookieConfig().isHttpOnly() || request.getContext().getUseHttpOnly()) { cookie.setHttpOnly(true); } response.addCookie(cookie); sso.register(ssoId, principal, authType, username, password); request.setNote(Constants.REQ_SSOID_NOTE, ssoId); } else { if (principal == null) { sso.deregister(ssoId); return; } else { sso.update(ssoId, principal, authType, username, password); } } if (session == null) session = request.getSessionInternal(true); sso.associate(ssoId, session); }
public Future<Connection> getConnectionAsync() throws SQLException { PooledConnection pc = this.borrowConnection(0, null, null); if (pc != null) { return new ConnectionFuture(pc); } if (idle instanceof FairBlockingQueue<?>) { Future<PooledConnection> pcf = ((FairBlockingQueue<PooledConnection>) idle).pollAsync(); return new ConnectionFuture(pcf); } else if (idle instanceof MultiLockFairBlockingQueue<?>) { Future<PooledConnection> pcf = ((MultiLockFairBlockingQueue<PooledConnection>) idle).pollAsync(); return new ConnectionFuture(pcf); } else { throw new SQLException("Connection pool is misconfigured, doesn't support async retrieval. Set the 'fair' property to 'true'"); } }
@Override public InputStream getInputStream() throws IOException { if (!connected) connect(); if (resource == null) { throw new FileNotFoundException(); } try { resource = (Resource) context.lookup(getURL().getFile()); } catch (NamingException e) { // Ignore } return (resource.streamContent()); }	@Override public Object getContent() throws IOException { if (!connected) connect(); if (resource != null) return getInputStream(); if (collection != null) return collection; if (object != null) return object; throw new FileNotFoundException(); }	public Enumeration<String> list() throws IOException { if (!connected) { connect(); } if ((resource == null) && (collection == null)) { throw new FileNotFoundException(); } Vector<String> result = new Vector<String>(); if (collection != null) { try { String file = getURL().getFile(); // This will be of the form /<hostname>/<contextpath>/file name // if <contextpath> is not empty otherwise this will be of the // form /<hostname>/file name int start; if (context instanceof ProxyDirContext && "".equals(((ProxyDirContext) context).getContextPath())) { start = file.indexOf('/', 1); } else start = file.indexOf('/', file.indexOf('/', 1) + 1); NamingEnumeration<NameClassPair> enumeration = context.list(file.substring(start)); while (enumeration.hasMoreElements()) { NameClassPair ncp = enumeration.nextElement(); result.addElement(ncp.getName()); } } catch (NamingException e) { throw new FileNotFoundException(); } } return result.elements(); }
@Override public void execute() throws BuildException { super.execute(); if (bean == null || attribute == null) { throw new BuildException("Must specify 'bean' and 'attribute' attributes"); } log("Getting attribute " + attribute + " in bean " + bean); execute("/jmxproxy/?get=" + bean + "&att=" + attribute); }	@Override public void execute() throws BuildException { super.execute(); String queryString = (query == null) ? "" : ("?qry=" + query); log("Query string is " + queryString); execute("/jmxproxy/" + queryString); }	@Override public void execute() throws BuildException { super.execute(); if (bean == null || attribute == null || value == null) { throw new BuildException("Must specify 'bean', 'attribute' and 'value' attributes"); } log("Setting attribute " + attribute + " in bean " + bean + " to " + value); execute("/jmxproxy/?set=" + bean + "&att=" + attribute + "&val=" + value); }	@Override public void execute() throws BuildException { super.execute(); if (type != null) { execute("/resources?type=" + type); } else { execute("/resources"); } }	@Override public void execute() throws BuildException { super.execute(); if (path == null) { throw new BuildException("Must specify 'path' attribute"); } execute("/undeploy?path=" + this.path); }
private static void loadProperties() { InputStream is = null; Throwable error = null; try { String configUrl = getConfigUrl(); if (configUrl != null) { is = (new URL(configUrl)).openStream(); } } catch (Throwable t) { handleThrowable(t); } if (is == null) { try { File home = new File(getCatalinaBase()); File conf = new File(home, "conf"); File propsFile = new File(conf, "catalina.properties"); is = new FileInputStream(propsFile); } catch (Throwable t) { handleThrowable(t); } } if (is == null) { try { is = CatalinaProperties.class.getResourceAsStream("/org/apache/catalina/startup/catalina.properties"); } catch (Throwable t) { handleThrowable(t); } } if (is != null) { try { properties = new Properties(); properties.load(is); is.close(); } catch (Throwable t) { handleThrowable(t); error = t; } } if ((is == null) || (error != null)) { log.warn("Failed to load catalina.properties", error); properties = new Properties(); } Enumeration<?> enumeration = properties.propertyNames(); while (enumeration.hasMoreElements()) { String name = (String) enumeration.nextElement(); String value = properties.getProperty(name); if (value != null) { System.setProperty(name, value); } } }
private synchronized void setStateInternal(LifecycleState state, Object data, boolean check) throws LifecycleException { if (log.isDebugEnabled()) { log.debug(sm.getString("lifecycleBase.setState", this, state)); } if (check) { if (state == null) { invalidTransition("null"); return; } if (!(state == LifecycleState.FAILED || (this.state == LifecycleState.STARTING_PREP && state == LifecycleState.STARTING) || (this.state == LifecycleState.STOPPING_PREP && state == LifecycleState.STOPPING))) { invalidTransition(state.name()); } } this.state = state; String lifecycleEvent = state.getLifecycleEvent(); if (lifecycleEvent != null) { fireLifecycleEvent(lifecycleEvent, data); } }	@Override public final synchronized void stop() throws LifecycleException { if (LifecycleState.STOPPING_PREP.equals(state) || LifecycleState.STOPPING.equals(state) || LifecycleState.STOPPED.equals(state)) { if (log.isDebugEnabled()) { Exception e = new LifecycleException(); log.debug(sm.getString("lifecycleBase.alreadyStopped", toString()), e); } else if (log.isInfoEnabled()) { log.info(sm.getString("lifecycleBase.alreadyStopped", toString())); } return; } if (state.equals(LifecycleState.NEW)) { state = LifecycleState.STOPPED; return; } if (!state.equals(LifecycleState.STARTED) && !state.equals(LifecycleState.FAILED) && !state.equals(LifecycleState.MUST_STOP)) { invalidTransition(Lifecycle.BEFORE_STOP_EVENT); } setStateInternal(LifecycleState.STOPPING_PREP, null, false); try { stopInternal(); } catch (LifecycleException e) { setStateInternal(LifecycleState.FAILED, null, false); throw e; } if (state.equals(LifecycleState.MUST_DESTROY)) { setStateInternal(LifecycleState.STOPPED, null, false); destroy(); } else { if (!state.equals(LifecycleState.STOPPING)) { invalidTransition(Lifecycle.AFTER_STOP_EVENT); } setStateInternal(LifecycleState.STOPPED, null, false); } }
protected SSLEngineResult handshakeUnwrap(boolean doread) throws IOException { if (netInBuffer.position() == netInBuffer.limit()) { netInBuffer.clear(); } if (doread) { int read = sc.read(netInBuffer); if (read == -1) throw new IOException("EOF encountered during handshake."); } SSLEngineResult result; boolean cont = false; do { netInBuffer.flip(); result = sslEngine.unwrap(netInBuffer, bufHandler.getReadBuffer()); netInBuffer.compact(); initHandshakeStatus = result.getHandshakeStatus(); if (result.getStatus() == SSLEngineResult.Status.OK && result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) { initHandshakeStatus = tasks(); } cont = result.getStatus() == SSLEngineResult.Status.OK && initHandshakeStatus == HandshakeStatus.NEED_UNWRAP; } while (cont); return result; }	protected SSLEngineResult handshakeWrap(boolean doWrite) throws IOException { //this should never be called with a network buffer that contains data netOutBuffer.clear(); SSLEngineResult result = sslEngine.wrap(bufHandler.getWriteBuffer(), netOutBuffer); netOutBuffer.flip(); initHandshakeStatus = result.getHandshakeStatus(); if (doWrite) flush(netOutBuffer); return result; }	@Override public ApplicationBufferHandler getBufHandler() { return bufHandler; }	public boolean isClosing() { return false; }	protected SSLEngineResult.HandshakeStatus tasks() { Runnable r = null; while ((r = sslEngine.getDelegatedTask()) != null) { r.run(); } return sslEngine.getHandshakeStatus(); }	@Override public int read(ByteBuffer dst) throws IOException { if (dst != bufHandler.getReadBuffer()) throw new IllegalArgumentException("You can only read using the application read buffer provided by the handler."); if (closing || closed) return -1; if (!initHandshakeComplete) throw new IllegalStateException("Handshake incomplete, you must complete handshake before reading data."); int netread = sc.read(netInBuffer); if (netread == -1) return -1; int read = 0; SSLEngineResult unwrap; do { netInBuffer.flip(); unwrap = sslEngine.unwrap(netInBuffer, dst); netInBuffer.compact(); if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) { read += unwrap.bytesProduced(); if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks(); if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) break; } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) { break; } else { throw new IOException("Unable to unwrap data, invalid status: " + unwrap.getStatus()); } } while ((netInBuffer.position() != 0)); return (read); }	@Override public void actionInternal(ActionCode actionCode, Object param) { if (actionCode == ActionCode.CLOSE) { // Close // End the processing of the current request, and stop any further comet = false; cometClose = true; SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); if (key != null) { NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment(); if (attach != null && attach.getComet()) { //if this is a comet connection //then execute the connection closure at the next selector loop //request.getAttributes().remove("org.apache.tomcat.comet.timeout"); //attach.setTimeout(5000); //force a cleanup in 5 seconds //attach.setError(true); //this has caused concurrency errors } } try { outputBuffer.endRequest(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.REQ_HOST_ADDR_ATTRIBUTE) { if ((remoteAddr == null) && (socket != null)) { InetAddress inetAddr = socket.getIOChannel().socket().getInetAddress(); if (inetAddr != null) { remoteAddr = inetAddr.getHostAddress(); } } request.remoteAddr().setString(remoteAddr); } else if (actionCode == ActionCode.REQ_LOCAL_NAME_ATTRIBUTE) { if ((localName == null) && (socket != null)) { InetAddress inetAddr = socket.getIOChannel().socket().getLocalAddress(); if (inetAddr != null) { localName = inetAddr.getHostName(); } } request.localName().setString(localName); } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) { if ((remoteHost == null) && (socket != null)) { InetAddress inetAddr = socket.getIOChannel().socket().getInetAddress(); if (inetAddr != null) { remoteHost = inetAddr.getHostName(); } if (remoteHost == null) { if (remoteAddr != null) { remoteHost = remoteAddr; } else { request.remoteHost().recycle(); } } } request.remoteHost().setString(remoteHost); } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) { if (localAddr == null) localAddr = socket.getIOChannel().socket().getLocalAddress().getHostAddress(); request.localAddr().setString(localAddr); } else if (actionCode == ActionCode.REQ_REMOTEPORT_ATTRIBUTE) { if ((remotePort == -1) && (socket != null)) { remotePort = socket.getIOChannel().socket().getPort(); } request.setRemotePort(remotePort); } else if (actionCode == ActionCode.REQ_LOCALPORT_ATTRIBUTE) { if ((localPort == -1) && (socket != null)) { localPort = socket.getIOChannel().socket().getLocalPort(); } request.setLocalPort(localPort); } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE) { try { if (sslSupport != null) { Object sslO = sslSupport.getCipherSuite(); if (sslO != null) request.setAttribute(SSLSupport.CIPHER_SUITE_KEY, sslO); sslO = sslSupport.getPeerCertificateChain(false); if (sslO != null) request.setAttribute(SSLSupport.CERTIFICATE_KEY, sslO); sslO = sslSupport.getKeySize(); if (sslO != null) request.setAttribute(SSLSupport.KEY_SIZE_KEY, sslO); sslO = sslSupport.getSessionId(); if (sslO != null) request.setAttribute(SSLSupport.SESSION_ID_KEY, sslO); request.setAttribute(SSLSupport.SESSION_MGR, sslSupport); } } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } else if (actionCode == ActionCode.REQ_SSL_CERTIFICATE) { if (sslSupport != null) { InputFilter[] inputFilters = inputBuffer.getFilters(); ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize); inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]); try { Object sslO = sslSupport.getPeerCertificateChain(true); if (sslO != null) { request.setAttribute(SSLSupport.CERTIFICATE_KEY, sslO); } } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } } else if (actionCode == ActionCode.AVAILABLE) { request.setAvailable(inputBuffer.available()); } else if (actionCode == ActionCode.COMET_BEGIN) { comet = true; } else if (actionCode == ActionCode.COMET_END) { comet = false; } else if (actionCode == ActionCode.COMET_CLOSE) { if (socket == null || socket.getAttachment(false) == null) return; NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) socket.getAttachment(false); attach.setCometOps(NioEndpoint.OP_CALLBACK); RequestInfo rp = request.getRequestProcessor(); if (rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE) socket.getPoller().add(socket); } else if (actionCode == ActionCode.COMET_SETTIMEOUT) { if (param == null) return; if (socket == null || socket.getAttachment(false) == null) return; NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) socket.getAttachment(false); long timeout = ((Long) param).longValue(); RequestInfo rp = request.getRequestProcessor(); if (rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE) attach.setTimeout(timeout); } else if (actionCode == ActionCode.ASYNC_COMPLETE) { if (asyncStateMachine.asyncComplete()) { endpoint.processSocket(this.socket, SocketStatus.OPEN, true); } } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) { if (param == null) return; if (socket == null || socket.getAttachment(false) == null) return; NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) socket.getAttachment(false); long timeout = ((Long) param).longValue(); attach.setTimeout(timeout); } else if (actionCode == ActionCode.ASYNC_DISPATCH) { if (asyncStateMachine.asyncDispatch()) { endpoint.processSocket(this.socket, SocketStatus.OPEN, true); } } }	@Override public void reset() throws IOException { super.reset(); netOutBuffer.position(0); netOutBuffer.limit(0); netInBuffer.position(0); netInBuffer.limit(0); initHandshakeComplete = false; closed = false; closing = false; sslEngine.beginHandshake(); initHandshakeStatus = sslEngine.getHandshakeStatus(); }
@Override protected void destroyInternal() throws LifecycleException { if ((manager != null) && (manager instanceof Lifecycle)) { ((Lifecycle) manager).destroy(); } if ((realm != null) && (realm instanceof Lifecycle)) { ((Lifecycle) realm).destroy(); } if ((cluster != null) && (cluster instanceof Lifecycle)) { ((Lifecycle) cluster).destroy(); } if ((logger != null) && (logger instanceof Lifecycle)) { ((Lifecycle) logger).destroy(); } if ((loader != null) && (loader instanceof Lifecycle)) { ((Lifecycle) loader).destroy(); } Notification notification = new Notification("j2ee.object.deleted", this.getObjectName(), sequenceNumber.getAndIncrement()); broadcaster.sendNotification(notification); if (namingResources != null) { namingResources.destroy(); } synchronized (instanceListenersLock) { instanceListeners = new String[0]; } super.destroyInternal(); }	public void testGetResource() throws Exception { Tomcat tomcat = getTomcatInstance(); String contextPath = "/examples"; File appDir = new File(getBuildDirectory(), "webapps" + contextPath); org.apache.catalina.Context ctx = tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); Tomcat.addServlet(ctx, "testGetResource", new GetResource()); ctx.addServletMapping("/testGetResource", "testGetResource"); tomcat.start(); ByteChunk res = new ByteChunk(); int rc = getUrl("http://localhost:" + getPort() + contextPath + "/testGetResource", res, null); assertEquals(HttpServletResponse.SC_OK, rc); assertTrue(res.toString().contains("<?xml version=\"1.0\" ")); }
protected List<String> getRoles(DirContext context, User user) throws NamingException { if (user == null) return (null); String dn = user.getDN(); String username = user.getUserName(); if (dn == null || username == null) return (null); if (containerLog.isTraceEnabled()) containerLog.trace(" getRoles(" + dn + ")"); List<String> list = new ArrayList<String>(); List<String> userRoles = user.getRoles(); if (userRoles != null) { list.addAll(userRoles); } if (commonRole != null) list.add(commonRole); if (containerLog.isTraceEnabled()) { containerLog.trace(" Found " + list.size() + " user internal roles"); for (int i = 0; i < list.size(); i++) containerLog.trace(" Found user internal role " + list.get(i)); } if ((roleFormat == null) || (roleName == null)) return (list); String filter = roleFormat.format(new String[] { doRFC2254Encoding(dn), username }); SearchControls controls = new SearchControls(); if (roleSubtree) controls.setSearchScope(SearchControls.SUBTREE_SCOPE); else controls.setSearchScope(SearchControls.ONELEVEL_SCOPE); controls.setReturningAttributes(new String[] { roleName }); NamingEnumeration<SearchResult> results = null; try { if (roleSearchAsUser) { userCredentialsAdd(context, dn, user.getPassword()); } results = context.search(roleBase, filter, controls); } finally { if (roleSearchAsUser) { userCredentialsRemove(context); } } if (results == null) return (list); HashMap<String, String> groupMap = new HashMap<String, String>(); try { while (results.hasMore()) { SearchResult result = results.next(); Attributes attrs = result.getAttributes(); if (attrs == null) continue; String dname = getDistinguishedName(context, roleBase, result); String name = getAttributeValue(roleName, attrs); if (name != null && dname != null) { groupMap.put(dname, name); } } } catch (PartialResultException ex) { if (!adCompat) throw ex; } Set<String> keys = groupMap.keySet(); if (containerLog.isTraceEnabled()) { containerLog.trace(" Found " + keys.size() + " direct roles"); for (String key : keys) { containerLog.trace(" Found direct role " + key + " -> " + groupMap.get(key)); } } if (getRoleNested()) { // The following efficient algorithm is known as memberOf Algorithm, as described in "Practices in // Directory Groups". It avoids group slurping and handles cyclic group memberships as well. Map<String, String> newGroups = new HashMap<String, String>(groupMap); while (!newGroups.isEmpty()) { Map<String, String> newThisRound = new HashMap<String, String>(); for (Entry<String, String> group : newGroups.entrySet()) { filter = roleFormat.format(new String[] { group.getKey(), group.getValue() }); if (containerLog.isTraceEnabled()) { containerLog.trace("Perform a nested group search with base " + roleBase + " and filter " + filter); } results = context.search(roleBase, filter, controls); try { while (results.hasMore()) { SearchResult result = results.next(); Attributes attrs = result.getAttributes(); if (attrs == null) continue; String dname = getDistinguishedName(context, roleBase, result); String name = getAttributeValue(roleName, attrs); if (name != null && dname != null && !groupMap.keySet().contains(dname)) { groupMap.put(dname, name); newThisRound.put(dname, name); if (containerLog.isTraceEnabled()) { containerLog.trace(" Found nested role " + dname + " -> " + name); } } } } catch (PartialResultException ex) { if (!adCompat) throw ex; } } newGroups = newThisRound; } } list.addAll(groupMap.values()); return list; }	public void setRoleBase(String roleBase) { this.roleBase = roleBase; }
protected List<String> getRoles(DirContext context, User user) throws NamingException { if (user == null) return (null); String dn = user.getDN(); String username = user.getUserName(); if (dn == null || username == null) return (null); if (containerLog.isTraceEnabled()) containerLog.trace(" getRoles(" + dn + ")"); List<String> list = new ArrayList<String>(); List<String> userRoles = user.getRoles(); if (userRoles != null) { list.addAll(userRoles); } if (commonRole != null) list.add(commonRole); if (containerLog.isTraceEnabled()) { containerLog.trace(" Found " + list.size() + " user internal roles"); for (int i = 0; i < list.size(); i++) containerLog.trace(" Found user internal role " + list.get(i)); } if ((roleFormat == null) || (roleName == null)) return (list); String filter = roleFormat.format(new String[] { doRFC2254Encoding(dn), username }); SearchControls controls = new SearchControls(); if (roleSubtree) controls.setSearchScope(SearchControls.SUBTREE_SCOPE); else controls.setSearchScope(SearchControls.ONELEVEL_SCOPE); controls.setReturningAttributes(new String[] { roleName }); NamingEnumeration<SearchResult> results = context.search(roleBase, filter, controls); if (results == null) return (list); HashMap<String, String> groupMap = new HashMap<String, String>(); try { while (results.hasMore()) { SearchResult result = results.next(); Attributes attrs = result.getAttributes(); if (attrs == null) continue; String dname = getDistinguishedName(context, roleBase, result); String name = getAttributeValue(roleName, attrs); if (name != null && dname != null) { groupMap.put(dname, name); } } } catch (PartialResultException ex) { if (!adCompat) throw ex; } Set<String> keys = groupMap.keySet(); if (containerLog.isTraceEnabled()) { containerLog.trace(" Found " + keys.size() + " direct roles"); for (String key : keys) { containerLog.trace(" Found direct role " + key + " -> " + groupMap.get(key)); } } if (getRoleNested()) { // The following efficient algorithm is known as memberOf Algorithm, as described in "Practices in // Directory Groups". It avoids group slurping and handles cyclic group memberships as well. Map<String, String> newGroups = new HashMap<String, String>(groupMap); while (!newGroups.isEmpty()) { Map<String, String> newThisRound = new HashMap<String, String>(); for (Entry<String, String> group : newGroups.entrySet()) { filter = roleFormat.format(new String[] { group.getKey(), group.getValue() }); if (containerLog.isTraceEnabled()) { containerLog.trace("Perform a nested group search with base " + roleBase + " and filter " + filter); } results = context.search(roleBase, filter, controls); try { while (results.hasMore()) { SearchResult result = results.next(); Attributes attrs = result.getAttributes(); if (attrs == null) continue; String dname = getDistinguishedName(context, roleBase, result); String name = getAttributeValue(roleName, attrs); if (name != null && dname != null && !groupMap.keySet().contains(dname)) { groupMap.put(dname, name); newThisRound.put(dname, name); if (containerLog.isTraceEnabled()) { containerLog.trace(" Found nested role " + dname + " -> " + name); } } } } catch (PartialResultException ex) { if (!adCompat) throw ex; } } newGroups = newThisRound; } } list.addAll(groupMap.values()); return list; }
@Override public void close() throws IOException { if (closed) return; if (suspended) return; if ((!coyoteResponse.isCommitted()) && (coyoteResponse.getContentLengthLong() == -1)) { if (!coyoteResponse.isCommitted()) { coyoteResponse.setContentLength(bb.getLength()); } } doFlush(false); closed = true; coyoteResponse.finish(); }
protected ArrayList<NamingEntry> list(File file) { ArrayList<NamingEntry> entries = new ArrayList<NamingEntry>(); if (!file.isDirectory()) return entries; String[] names = file.list(); if (names == null) { log.warn(sm.getString("fileResources.listingNull", file.getAbsolutePath())); return entries; } Arrays.sort(names); NamingEntry entry = null; for (int i = 0; i < names.length; i++) { File currentFile = new File(file, names[i]); Object object = null; if (currentFile.isDirectory()) { FileDirContext tempContext = new FileDirContext(env); tempContext.setDocBase(file.getPath()); tempContext.setAllowLinking(getAllowLinking()); object = tempContext; } else { object = new FileResource(currentFile); } entry = new NamingEntry(names[i], object, NamingEntry.ENTRY); entries.add(entry); } return entries; }	@Override public NamingEnumeration<SearchResult> search(Name name, String filterExpr, Object[] filterArgs, SearchControls cons) throws NamingException { return search(name.toString(), filterExpr, filterArgs, cons); }	@Override protected ArrayList<NamingEntry> list(File file) { ArrayList<NamingEntry> entries = super.list(file); if ("WEB-INF".equals(file.getName())) { entries.addAll(getVirtualNamingEntries()); } return entries; }	@Override public final NamingEnumeration<Binding> listBindings(String name) throws NamingException { if (!aliases.isEmpty()) { AliasResult result = findAlias(name); if (result.dirContext != null) { return result.dirContext.listBindings(result.aliasName); } } NamingEnumeration<Binding> bindings = doListBindings(name); if (bindings != null) return bindings; for (DirContext altDirContext : altDirContexts) { if (altDirContext instanceof BaseDirContext) bindings = ((BaseDirContext) altDirContext).doListBindings("/META-INF/resources" + name); else { try { bindings = altDirContext.listBindings(name); } catch (NamingException ne) { // Ignore } } if (bindings != null) return bindings; } throw new NameNotFoundException(sm.getString("resources.notFound", name)); }	@Override protected NamingEnumeration<Binding> doListBindings(String name) throws NamingException { File file = file(name); if (file == null) return null; return new NamingContextBindingsEnumeration(list(file).iterator(), this); }	@Override protected NamingEnumeration<Binding> doListBindings(String strName) throws NamingException { Name name = getEscapedJndiName(strName); if (name.isEmpty()) return new NamingContextBindingsEnumeration(list(entries).iterator(), this); Entry entry = treeLookup(name); if (entry == null) return null; return new NamingContextBindingsEnumeration(list(entry).iterator(), this); }
@Override public SocketState process(SocketWrapper<Long> socket) { AjpAprProcessor processor = recycledProcessors.poll(); try { if (processor == null) { processor = createProcessor(); } SocketState state = processor.process(socket); if (state == SocketState.LONG) { state = processor.asyncPostProcess(); } if (state == SocketState.LONG || state == SocketState.ASYNC_END) { // Need to make socket available for next processing cycle connections.put(socket, processor); socket.setAsync(true); } else { if (state == SocketState.OPEN) { connections.put(socket, processor); } recycledProcessors.offer(processor); } return state; } catch (java.net.SocketException e) { log.debug(sm.getString("ajpprotocol.proto.socketexception.debug"), e); } catch (java.io.IOException e) { log.debug(sm.getString("ajpprotocol.proto.ioexception.debug"), e); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); // any other exception or error is odd. Here we log it // with "ERROR" level, so it will show up even on log.error(sm.getString("ajpprotocol.proto.error"), e); } recycledProcessors.offer(processor); return SocketState.CLOSED; }
private void processRequest(ServletRequest request, ServletResponse response, State state) throws IOException, ServletException { DispatcherType disInt = (DispatcherType) request.getAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR); if (disInt != null) { if (disInt != DispatcherType.ERROR) { state.outerRequest.setAttribute(ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, getCombinedPath()); state.outerRequest.setAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR, DispatcherType.FORWARD); invoke(state.outerRequest, response, state); } else { invoke(state.outerRequest, response, state); } } }
@Override public Object getValue(EvaluationContext ctx) throws ELException { Object base = this.children[0].getValue(ctx); int propCount = this.jjtGetNumChildren(); int i = 1; Object suffix = null; ELResolver resolver = ctx.getELResolver(); while (base != null && i < propCount) { suffix = this.children[i].getValue(ctx); if (i + 1 < propCount && (this.children[i + 1] instanceof AstMethodParameters)) { AstMethodParameters mps = (AstMethodParameters) this.children[i + 1]; base = resolver.invoke(ctx, base, suffix, mps.getParameterTypes(ctx), mps.getParameters(ctx)); i += 2; } else { if (suffix == null) { return null; } ctx.setPropertyResolved(false); base = resolver.getValue(ctx, base, suffix); i++; } } if (!ctx.isPropertyResolved()) { throw new PropertyNotFoundException(MessageFactory.get("error.resolver.unhandled", base, suffix)); } return base; }	@Override public Object invoke(ELContext context, Object base, Object method, Class<?>[] paramTypes, Object[] params) { if (context == null) { throw new NullPointerException(); } if (base == null || method == null) { return null; } ExpressionFactory factory = ExpressionFactory.newInstance(); String methodName = (String) factory.coerceToType(method, String.class); Method matchingMethod = null; Class<?> clazz = base.getClass(); if (paramTypes != null) { try { matchingMethod = clazz.getMethod(methodName, paramTypes); } catch (NoSuchMethodException e) { throw new MethodNotFoundException(e); } } else { int paramCount = 0; if (params != null) { paramCount = params.length; } Method[] methods = clazz.getMethods(); for (Method m : methods) { if (m.getParameterTypes().length == paramCount) { matchingMethod = m; break; } if (m.isVarArgs()) { matchingMethod = m; } } if (matchingMethod == null) { throw new MethodNotFoundException("Unable to find method [" + methodName + "] with [" + paramCount + "] parameters"); } } Class<?>[] parameterTypes = matchingMethod.getParameterTypes(); Object[] parameters = null; if (parameterTypes.length > 0) { parameters = new Object[parameterTypes.length]; @SuppressWarnings("null") int paramCount = params.length; if (matchingMethod.isVarArgs()) { int varArgIndex = parameterTypes.length - 1; for (int i = 0; (i < varArgIndex - 1); i++) { parameters[i] = factory.coerceToType(params[i], parameterTypes[i]); } Class<?> varArgClass = parameterTypes[varArgIndex].getComponentType(); for (int i = (varArgIndex); i < paramCount; i++) { Object varargs = Array.newInstance(parameterTypes[paramCount], (paramCount - varArgIndex)); Array.set(varargs, i, factory.coerceToType(params[i], varArgClass)); parameters[varArgIndex] = varargs; } } else { parameters = new Object[parameterTypes.length]; for (int i = 0; i < parameterTypes.length; i++) { parameters[i] = factory.coerceToType(params[i], parameterTypes[i]); } } } Object result = null; try { result = matchingMethod.invoke(base, parameters); } catch (IllegalArgumentException e) { throw new ELException(e); } catch (IllegalAccessException e) { throw new ELException(e); } catch (InvocationTargetException e) { throw new ELException(e.getCause()); } context.setPropertyResolved(true); return result; }	public void testBug50449b() throws Exception { MethodExpression me1 = factory.createMethodExpression(context, "${beanB.sayHello('Tomcat')}", null, null); String actual = (String) me1.invoke(context, null); assertEquals("Hello Tomcat from B", actual); }
private void doTestDispatch(int iter, boolean useThread) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); DispatchingServlet dispatch = new DispatchingServlet(false, false); Wrapper wrapper = Tomcat.addServlet(ctx, "dispatch", dispatch); wrapper.setAsyncSupported(true); ctx.addServletMapping("/stage1", "dispatch"); NonAsyncServlet nonasync = new NonAsyncServlet(); Wrapper wrapper2 = Tomcat.addServlet(ctx, "nonasync", nonasync); wrapper2.setAsyncSupported(true); ctx.addServletMapping("/stage2", "nonasync"); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/stage1?iter="); url.append(iter); if (useThread) { url.append("&useThread=y"); } ByteChunk res = getUrl(url.toString()); StringBuilder expected = new StringBuilder(); int loop = iter; while (loop > 0) { expected.append("DispatchingServletGet-"); loop--; } expected.append("NonAsyncServletGet-"); assertEquals(expected.toString(), res.toString()); }	private void doTestDispatchError(int iter, boolean useThread, boolean completeOnError) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); DispatchingServlet dispatch = new DispatchingServlet(true, completeOnError); Wrapper wrapper = Tomcat.addServlet(ctx, "dispatch", dispatch); wrapper.setAsyncSupported(true); ctx.addServletMapping("/stage1", "dispatch"); ErrorServlet error = new ErrorServlet(); Tomcat.addServlet(ctx, "error", error); ctx.addServletMapping("/stage2", "error"); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/stage1?iter="); url.append(iter); if (useThread) { url.append("&useThread=y"); } ByteChunk res = getUrl(url.toString()); StringBuilder expected = new StringBuilder(); int loop = iter; while (loop > 0) { expected.append("DispatchingServletGet-"); if (loop != iter) { expected.append("onStartAsync-"); } loop--; } expected.append("ErrorServletGet-onError-onComplete-"); assertEquals(expected.toString(), res.toString()); }	private void doTestTimeout(boolean completeOnTimeout, String dispatchUrl) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); File foo = new File(docBase, "async"); if (!foo.exists() && !foo.mkdirs()) { fail("Unable to create async directory in docBase"); } Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); TimeoutServlet timeout = new TimeoutServlet(completeOnTimeout, dispatchUrl); Wrapper wrapper = Tomcat.addServlet(ctx, "time", timeout); wrapper.setAsyncSupported(true); ctx.addServletMapping("/async", "time"); if (dispatchUrl != null) { NonAsyncServlet nonAsync = new NonAsyncServlet(); Tomcat.addServlet(ctx, "nonasync", nonAsync); ctx.addServletMapping(dispatchUrl, "nonasync"); } tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/async"); StringBuilder expected = new StringBuilder(); expected.append("TimeoutServletGet-onTimeout-"); if (!completeOnTimeout) { expected.append("onError-"); } if (dispatchUrl == null) { expected.append("onComplete-"); } else { expected.append("NonAsyncServletGet-"); } assertEquals(expected.toString(), res.toString()); }	@Override public boolean asyncDispatch(org.apache.coyote.Request req, org.apache.coyote.Response res, SocketStatus status) throws Exception { Request request = (Request) req.getNote(ADAPTER_NOTES); Response response = (Response) res.getNote(ADAPTER_NOTES); if (request == null) { throw new IllegalStateException("Dispatch may only happen on an existing request."); } boolean comet = false; boolean success = true; AsyncContextImpl asyncConImpl = (AsyncContextImpl) request.getAsyncContext(); try { if (status == SocketStatus.TIMEOUT) { success = true; if (!asyncConImpl.timeout()) { asyncConImpl.setErrorState(null); } } if (request.isAsyncDispatching()) { success = true; connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); Throwable t = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION); if (t != null) { asyncConImpl.setErrorState(t); } } if (request.isComet()) { if (!response.isClosed() && !response.isError()) { if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) { if (event(req, res, SocketStatus.OPEN)) { comet = true; res.action(ActionCode.COMET_BEGIN, null); } } else { comet = true; res.action(ActionCode.COMET_BEGIN, null); } } else { // Clear the filter chain, as otherwise it will not be reset elsewhere request.setFilterChain(null); } } if (!request.isAsync() && !comet) { response.finishResponse(); req.action(ActionCode.POST_REQUEST, null); } } catch (IOException e) { success = false; // Ignore } catch (Throwable t) { ExceptionUtils.handleThrowable(t); success = false; log.error(sm.getString("coyoteAdapter.service"), t); } finally { req.getRequestProcessor().setWorkerThreadName(null); if (!success || (!comet && !request.isAsync())) { request.recycle(); response.recycle(); } else { // Clear converters so that the minimum amount of memory request.clearEncoders(); response.clearEncoders(); } } return success; }	@Override public boolean fireRequestDestroyEvent(ServletRequest request) { Object[] instances = getApplicationEventListeners(); if ((instances != null) && (instances.length > 0)) { if (!DispatcherType.ASYNC.equals(request.getDispatcherType())) { ServletRequestEvent event = new ServletRequestEvent(getServletContext(), request); for (int i = 0; i < instances.length; i++) { int j = (instances.length - 1) - i; if (instances[j] == null) continue; if (!(instances[j] instanceof ServletRequestListener)) continue; ServletRequestListener listener = (ServletRequestListener) instances[j]; try { listener.requestDestroyed(event); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getLogger().error(sm.getString("standardContext.requestListener.requestInit", instances[j].getClass().getName()), t); request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t); return false; } } } } return true; }	@Override public boolean fireRequestInitEvent(ServletRequest request) { Object[] instances = getApplicationEventListeners(); if ((instances != null) && (instances.length > 0)) { if (!DispatcherType.ASYNC.equals(request.getDispatcherType())) { ServletRequestEvent event = new ServletRequestEvent(getServletContext(), request); for (int i = 0; i < instances.length; i++) { if (instances[i] == null) continue; if (!(instances[i] instanceof ServletRequestListener)) continue; ServletRequestListener listener = (ServletRequestListener) instances[i]; try { listener.requestInitialized(event); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getLogger().error(sm.getString("standardContext.requestListener.requestInit", instances[i].getClass().getName()), t); request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t); return false; } } } } return true; }	@Override public final void invoke(Request request, Response response) throws IOException, ServletException { MessageBytes requestPathMB = request.getRequestPathMB(); if ((requestPathMB.startsWithIgnoreCase("/META-INF/", 0)) || (requestPathMB.equalsIgnoreCase("/META-INF")) || (requestPathMB.startsWithIgnoreCase("/WEB-INF/", 0)) || (requestPathMB.equalsIgnoreCase("/WEB-INF"))) { notFound(response); return; } boolean reloaded = false; while (context.getPaused()) { reloaded = true; try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } } if (reloaded && context.getLoader() != null && context.getLoader().getClassLoader() != null) { Thread.currentThread().setContextClassLoader(context.getLoader().getClassLoader()); } Wrapper wrapper = request.getWrapper(); if (wrapper == null) { notFound(response); return; } else if (wrapper.isUnavailable()) { wrapper = (Wrapper) container.findChild(wrapper.getName()); if (wrapper == null) { notFound(response); return; } } if (context.fireRequestInitEvent(request)) { if (request.isAsyncSupported()) { request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported()); } wrapper.getPipeline().getFirst().invoke(request, response); context.fireRequestDestroyEvent(request); } }	@Override public void onStartAsync(AsyncEvent event) throws IOException { ServletResponse resp = event.getAsyncContext().getResponse(); resp.getWriter().write("onStartAsync-"); resp.flushBuffer(); }
protected void printResources(PrintWriter writer, String prefix, javax.naming.Context namingContext, String type, Class<?> clazz, StringManager smClient) { try { NamingEnumeration<Binding> items = namingContext.listBindings(""); while (items.hasMore()) { Binding item = items.next(); if (item.getObject() instanceof javax.naming.Context) { printResources(writer, prefix + item.getName() + "/", (javax.naming.Context) item.getObject(), type, clazz, smClient); } else { if ((clazz != null) && (!(clazz.isInstance(item.getObject())))) { continue; } writer.print(prefix + item.getName()); writer.print(':'); writer.print(item.getClassName()); writer.println(); } } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log("ManagerServlet.resources[" + type + "]", t); writer.println(smClient.getString("managerServlet.exception", t.toString())); } }	@Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { StringManager smClient = getStringManager(request); String command = request.getPathInfo(); if (command == null) command = request.getServletPath(); String config = request.getParameter("config"); String path = request.getParameter("path"); ContextName cn = null; if (path != null) { cn = new ContextName(path, request.getParameter("version")); } String type = request.getParameter("type"); String war = request.getParameter("war"); String tag = request.getParameter("tag"); boolean update = false; if ((request.getParameter("update") != null) && (request.getParameter("update").equals("true"))) { update = true; } response.setContentType("text/plain; charset=" + Constants.CHARSET); PrintWriter writer = response.getWriter(); if (command == null) { writer.println(smClient.getString("managerServlet.noCommand")); } else if (command.equals("/deploy")) { if (war != null || config != null) { deploy(writer, config, cn, war, update, smClient); } else { deploy(writer, cn, tag, smClient); } } else if (command.equals("/list")) { list(writer, smClient); } else if (command.equals("/reload")) { reload(writer, cn, smClient); } else if (command.equals("/resources")) { resources(writer, type, smClient); } else if (command.equals("/roles")) { roles(writer, smClient); } else if (command.equals("/save")) { save(writer, path, smClient); } else if (command.equals("/serverinfo")) { serverinfo(writer, smClient); } else if (command.equals("/sessions")) { expireSessions(writer, cn, request, smClient); } else if (command.equals("/expire")) { expireSessions(writer, cn, request, smClient); } else if (command.equals("/start")) { start(writer, cn, smClient); } else if (command.equals("/stop")) { stop(writer, cn, smClient); } else if (command.equals("/undeploy")) { undeploy(writer, cn, smClient); } else if (command.equals("/findleaks")) { findleaks(writer, smClient); } else { writer.println(smClient.getString("managerServlet.unknownCommand", command)); } writer.flush(); writer.close(); }
private void mergeParameters() { ServletContext sc = getServletContext(); String[] names = findParameters(); for (int i = 0; i < names.length; i++) { sc.setInitParameter(names[i], findParameter(names[i])); } ApplicationParameter[] params = findApplicationParameters(); for (int i = 0; i < params.length; i++) { if (params[i].getOverride()) { if (sc.getInitParameter(params[i].getName()) == null) { sc.setInitParameter(params[i].getName(), params[i].getValue()); } } else { sc.setInitParameter(params[i].getName(), params[i].getValue()); } } }
public void execute(DeltaSession session, boolean notifyListeners) { if (!this.sessionId.equals(session.getId())) throw new java.lang.IllegalArgumentException("Session id mismatch, not executing the delta request"); session.access(); for (int i = 0; i < actions.size(); i++) { AttributeInfo info = actions.get(i); switch(info.getType()) { case TYPE_ATTRIBUTE: { if (info.getAction() == ACTION_SET) { if (log.isTraceEnabled()) log.trace("Session.setAttribute('" + info.getName() + "', '" + info.getValue() + "')"); session.setAttribute(info.getName(), info.getValue(), notifyListeners, false); } else { if (log.isTraceEnabled()) log.trace("Session.removeAttribute('" + info.getName() + "')"); session.removeAttribute(info.getName(), notifyListeners, false); } break; } case TYPE_ISNEW: { if (log.isTraceEnabled()) log.trace("Session.setNew('" + info.getValue() + "')"); session.setNew(((Boolean) info.getValue()).booleanValue(), false); break; } case TYPE_MAXINTERVAL: { if (log.isTraceEnabled()) log.trace("Session.setMaxInactiveInterval('" + info.getValue() + "')"); session.setMaxInactiveInterval(((Integer) info.getValue()).intValue(), false); break; } case TYPE_PRINCIPAL: { Principal p = null; if (info.getAction() == ACTION_SET) { SerializablePrincipal sp = (SerializablePrincipal) info.getValue(); p = sp.getPrincipal(); } session.setPrincipal(p, false); break; } default: throw new java.lang.IllegalArgumentException("Invalid attribute info type=" + info); } //switch } session.endAccess(); reset(); }	public void setNew(boolean n) { int action = ACTION_SET; addAction(TYPE_ISNEW, action, NAME_ISNEW, Boolean.valueOf(n)); }	public void setPrincipal(Principal principal, boolean addDeltaRequest) { try { lock(); super.setPrincipal(principal); if (addDeltaRequest && (deltaRequest != null)) deltaRequest.setPrincipal(principal); } finally { unlock(); } }
@Override public void visit(Node.TemplateText n) throws JasperException { String text = n.getText(); int textSize = text.length(); if (textSize == 0) { return; } if (textSize <= 3) { n.setBeginJavaLine(out.getJavaLine()); int lineInc = 0; for (int i = 0; i < textSize; i++) { char ch = text.charAt(i); out.printil("out.write(" + quote(ch) + ");"); if (i > 0) { n.addSmap(lineInc); } if (ch == '\n') { lineInc++; } } n.setEndJavaLine(out.getJavaLine()); return; } if (ctxt.getOptions().genStringAsCharArray()) { ServletWriter caOut; if (charArrayBuffer == null) { charArrayBuffer = new GenBuffer(); caOut = charArrayBuffer.getOut(); caOut.pushIndent(); textMap = new HashMap<String, String>(); } else { caOut = charArrayBuffer.getOut(); } String charArrayName = textMap.get(text); if (charArrayName == null) { charArrayName = "_jspx_char_array_" + charArrayCount++; textMap.put(text, charArrayName); caOut.printin("static char[] "); caOut.print(charArrayName); caOut.print(" = "); caOut.print(quote(text)); caOut.println(".toCharArray();"); } n.setBeginJavaLine(out.getJavaLine()); out.printil("out.write(" + charArrayName + ");"); n.setEndJavaLine(out.getJavaLine()); return; } n.setBeginJavaLine(out.getJavaLine()); out.printin(); StringBuilder sb = new StringBuilder("out.write(\""); int initLength = sb.length(); int count = JspUtil.CHUNKSIZE; int srcLine = 0; for (int i = 0; i < text.length(); i++) { char ch = text.charAt(i); --count; switch(ch) { case '"': sb.append('\\').append('\"'); break; case '\\': sb.append('\\').append('\\'); break; case '\r': sb.append('\\').append('r'); break; case '\n': sb.append('\\').append('n'); srcLine++; if (breakAtLF || count < 0) { sb.append("\");"); out.println(sb.toString()); if (i < text.length() - 1) { out.printin(); } sb.setLength(initLength); count = JspUtil.CHUNKSIZE; } n.addSmap(srcLine); break; case '\t': sb.append('\\').append('t'); break; default: sb.append(ch); } } if (sb.length() > initLength) { sb.append("\");"); out.println(sb.toString()); } n.setEndJavaLine(out.getJavaLine()); }
public boolean validate(int validateAction, String sql) { if (this.isDiscarded()) { return false; } if (!doValidate(validateAction)) { return true; } long now = System.currentTimeMillis(); if (validateAction != VALIDATE_INIT && poolProperties.getValidationInterval() > 0 && (now - this.lastValidated) < poolProperties.getValidationInterval()) { return true; } if (poolProperties.getValidator() != null) { return poolProperties.getValidator().validate(connection, validateAction); } String query = sql; if (validateAction == VALIDATE_INIT && poolProperties.getInitSQL() != null) { query = poolProperties.getInitSQL(); } if (query == null) { query = poolProperties.getValidationQuery(); } Statement stmt = null; try { stmt = connection.createStatement(); stmt.execute(query); stmt.close(); this.lastValidated = now; return true; } catch (Exception ignore) { if (log.isDebugEnabled()) log.debug("Unable to validate object:", ignore); if (stmt != null) try { stmt.close(); } catch (Exception ignore2) { /*NOOP*/ } } return false; }
protected User getUserByPattern(DirContext context, String username, String credentials, String[] attrIds, int curUserPattern) throws NamingException { User user = null; if (username == null || userPatternFormatArray[curUserPattern] == null) return (null); String dn = userPatternFormatArray[curUserPattern].format(new String[] { username }); try { user = getUserByPattern(context, username, attrIds, dn); } catch (NameNotFoundException e) { return (null); } catch (NamingException e) { try { context.addToEnvironment(Context.SECURITY_PRINCIPAL, dn); context.addToEnvironment(Context.SECURITY_CREDENTIALS, credentials); user = getUserByPattern(context, username, attrIds, dn); } finally { if (connectionName != null) { context.addToEnvironment(Context.SECURITY_PRINCIPAL, connectionName); } else { context.removeFromEnvironment(Context.SECURITY_PRINCIPAL); } if (connectionPassword != null) { context.addToEnvironment(Context.SECURITY_CREDENTIALS, connectionPassword); } else { context.removeFromEnvironment(Context.SECURITY_CREDENTIALS); } } } return user; }
protected void initNaming() { if (!useNaming) { log.info("Catalina naming disabled"); System.setProperty("catalina.useNaming", "false"); } else { System.setProperty("catalina.useNaming", "true"); String value = "org.apache.naming"; String oldValue = System.getProperty(javax.naming.Context.URL_PKG_PREFIXES); if (oldValue != null) { value = value + ":" + oldValue; } System.setProperty(javax.naming.Context.URL_PKG_PREFIXES, value); if (log.isDebugEnabled()) log.debug("Setting naming prefix=" + value); value = System.getProperty(javax.naming.Context.INITIAL_CONTEXT_FACTORY); if (value == null) { System.setProperty(javax.naming.Context.INITIAL_CONTEXT_FACTORY, "org.apache.naming.java.javaURLContextFactory"); } else { log.debug("INITIAL_CONTEXT_FACTORY alread set " + value); } } }
public InputSource getInputSource() { return ip; }	public void close() { if (is != null) { try { is.close(); } catch (IOException e) { log.error(Localizer.getMessage("jsp.error.stream.close.failed")); } } }
public static String URLDecode(byte[] bytes, String enc, boolean isQuery) { if (bytes == null) return null; int len = bytes.length; int ix = 0; int ox = 0; while (ix < len) { byte b = bytes[ix++]; if (b == '+' && isQuery) { b = (byte) ' '; } else if (b == '%') { if (ix + 2 >= len) { throw new IllegalArgumentException(sm.getString("requestUtil.urlDecode.missingDigit")); } b = (byte) ((convertHexDigit(bytes[ix++]) << 4) + convertHexDigit(bytes[ix++])); } bytes[ox++] = b; } if (enc != null) { try { return new String(bytes, 0, ox, enc); } catch (UnsupportedEncodingException uee) { log.debug(sm.getString("requestUtil.urlDecode.uee", enc), uee); return null; } } return new String(bytes, 0, ox); }	public void testNormalizeString() { assertEquals("/something", RequestUtil.normalize("//something")); assertEquals("/some/thing", RequestUtil.normalize("some//thing")); assertEquals("/something/", RequestUtil.normalize("something//")); assertEquals("/", RequestUtil.normalize("//")); }	public void testURLDecodeString() { Exception exception = null; try { RequestUtil.URLDecode("%5xxxxx"); } catch (Exception e) { exception = e; } assertTrue(exception instanceof IllegalArgumentException); exception = null; try { RequestUtil.URLDecode("%5"); } catch (Exception e) { exception = e; } assertTrue(exception instanceof IllegalArgumentException); }

@Override protected void stopInternal() throws LifecycleException { setState(LifecycleState.STOPPING); fireLifecycleEvent(CONFIGURE_STOP_EVENT, null); for (int i = 0; i < services.length; i++) { services[i].stop(); } if (port == -1) stopAwait(); }	public void setGlobalNamingContext(javax.naming.Context globalNamingContext) { this.globalNamingContext = globalNamingContext; }	@Override public void await() { if (port == -2) { return; } if (port == -1) { while (true) { try { Thread.sleep(10000); } catch (InterruptedException ex) { } if (stopAwait) return; } } ServerSocket serverSocket = null; try { serverSocket = new ServerSocket(port, 1, InetAddress.getByName(address)); } catch (IOException e) { log.error("StandardServer.await: create[" + address + ":" + port + "]: ", e); System.exit(1); } while (true) { Socket socket = null; InputStream stream = null; try { socket = serverSocket.accept(); socket.setSoTimeout(10 * 1000); stream = socket.getInputStream(); } catch (AccessControlException ace) { log.warn("StandardServer.accept security exception: " + ace.getMessage(), ace); continue; } catch (IOException e) { log.error("StandardServer.await: accept: ", e); System.exit(1); } StringBuilder command = new StringBuilder(); int expected = 1024; while (expected < shutdown.length()) { if (random == null) random = new Random(); expected += (random.nextInt() % 1024); } while (expected > 0) { int ch = -1; try { ch = stream.read(); } catch (IOException e) { log.warn("StandardServer.await: read: ", e); ch = -1; } if (ch < 32) break; command.append((char) ch); expected--; } try { socket.close(); } catch (IOException e) { // Ignore } boolean match = command.toString().equals(shutdown); if (match) { log.info(sm.getString("standardServer.shutdownViaPort")); break; } else log.warn("StandardServer.await: Invalid command '" + command.toString() + "' received"); } try { serverSocket.close(); } catch (IOException e) { // Ignore } }	public void stop() { try { if (useShutdownHook) { Runtime.getRuntime().removeShutdownHook(shutdownHook); // If JULI is being used, re-enable JULI's shutdown to ensure LogManager logManager = LogManager.getLogManager(); if (logManager instanceof ClassLoaderLogManager) { ((ClassLoaderLogManager) logManager).setUseShutdownHook(true); } } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); // This will fail on JDK 1.2. Ignoring, as Tomcat can run // fine without the shutdown hook. } try { getServer().stop(); } catch (LifecycleException e) { log.error("Catalina.stop", e); } }	public void stopAwait() { stopAwait = true; }	public void stopServer(String[] arguments) { if (arguments != null) { arguments(arguments); } if (getServer() == null) { Digester digester = createStopDigester(); digester.setClassLoader(Thread.currentThread().getContextClassLoader()); File file = configFile(); try { InputSource is = new InputSource("file://" + file.getAbsolutePath()); FileInputStream fis = new FileInputStream(file); is.setByteStream(fis); digester.push(this); digester.parse(is); fis.close(); } catch (Exception e) { log.error("Catalina.stop: ", e); System.exit(1); } } else { // Server object already present. Must be running as a service System.exit(0); } try { if (getServer().getPort() > 0) { Socket socket = new Socket(getServer().getAddress(), getServer().getPort()); OutputStream stream = socket.getOutputStream(); String shutdown = getServer().getShutdown(); for (int i = 0; i < shutdown.length(); i++) stream.write(shutdown.charAt(i)); stream.flush(); stream.close(); socket.close(); } else { log.error(sm.getString("catalina.stopServer")); System.exit(1); } } catch (IOException e) { log.error("Catalina.stop: ", e); System.exit(1); } }
private void expand(int newsize) { if (newsize > buf.length) { byte[] tmp = new byte[newsize]; System.arraycopy(buf, 0, tmp, 0, buf.length); buf = tmp; } }	protected boolean fill(boolean timeout, boolean block) throws IOException, EOFException { boolean read = false; if (parsingHeader) { if (lastValid == buf.length) { throw new IllegalArgumentException(sm.getString("iib.requestheadertoolarge.error")); } read = readSocket(timeout, block) > 0; } else { if (buf.length - end < 4500) { // In this case, the request header was really large, so we allocate a // brand new one; the old one will get GCed when subsequent requests buf = new byte[buf.length]; end = 0; } pos = end; lastValid = pos; read = readSocket(timeout, block) > 0; } return read; }	@Override public boolean parseHeaders() throws IOException { HeaderParseStatus status = HeaderParseStatus.HAVE_MORE_HEADERS; do { status = parseHeader(); } while (status == HeaderParseStatus.HAVE_MORE_HEADERS); if (status == HeaderParseStatus.DONE) { parsingHeader = false; end = pos; return true; } else { return false; } }	@Override public boolean parseRequestLine(boolean useAvailableDataOnly) throws IOException { if (!parsingRequestLine) return true; if (parsingRequestLinePhase == 0) { byte chr = 0; do { if (pos >= lastValid) { if (useAvailableDataOnly) { return false; } if (readSocket(true, false) == 0) return false; } chr = buf[pos++]; } while ((chr == Constants.CR) || (chr == Constants.LF)); pos--; parsingRequestLineStart = pos; parsingRequestLinePhase = 1; } if (parsingRequestLinePhase == 1) { if (pos >= lastValid) { if (useAvailableDataOnly) { return false; } if (readSocket(true, false) == 0) return false; } parsingRequestLinePhase = 2; if (log.isDebugEnabled()) { log.debug("Received [" + new String(buf, pos, lastValid - pos, "ISO-8859-1") + "]"); } } if (parsingRequestLinePhase == 2) { // // Reading the method name // Method name is always US-ASCII boolean space = false; while (!space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) { throw new IllegalArgumentException(sm.getString("iib.invalidmethod")); } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; request.method().setBytes(buf, parsingRequestLineStart, pos - parsingRequestLineStart); } pos++; } parsingRequestLinePhase = 3; } if (parsingRequestLinePhase == 3) { boolean space = true; while (space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { pos++; } else { space = false; } } parsingRequestLineStart = pos; parsingRequestLinePhase = 4; } if (parsingRequestLinePhase == 4) { int end = 0; // // Reading the URI boolean space = false; while (!space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; end = pos; } else if ((buf[pos] == Constants.CR) || (buf[pos] == Constants.LF)) { parsingRequestLineEol = true; space = true; end = pos; } else if ((buf[pos] == Constants.QUESTION) && (parsingRequestLineQPos == -1)) { parsingRequestLineQPos = pos; } pos++; } request.unparsedURI().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); if (parsingRequestLineQPos >= 0) { request.queryString().setBytes(buf, parsingRequestLineQPos + 1, end - parsingRequestLineQPos - 1); request.requestURI().setBytes(buf, parsingRequestLineStart, parsingRequestLineQPos - parsingRequestLineStart); } else { request.requestURI().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); } parsingRequestLinePhase = 5; } if (parsingRequestLinePhase == 5) { boolean space = true; while (space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { pos++; } else { space = false; } } parsingRequestLineStart = pos; parsingRequestLinePhase = 6; } if (parsingRequestLinePhase == 6) { end = 0; while (!parsingRequestLineEol) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.CR) { end = pos; } else if (buf[pos] == Constants.LF) { if (end == 0) end = pos; parsingRequestLineEol = true; } pos++; } if ((end - parsingRequestLineStart) > 0) { request.protocol().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); } else { request.protocol().setString(""); } parsingRequestLine = false; parsingRequestLinePhase = 0; parsingRequestLineEol = false; parsingRequestLineStart = 0; return true; } throw new IllegalStateException("Invalid request line parse phase:" + parsingRequestLinePhase); }	public void setSocket(NioChannel socket) { this.socket = socket; }
protected String[] getEnabledCiphers(String requestedCiphers, String[] supportedCiphers) { String[] result = null; if (ALLOW_ALL_SUPPORTED_CIPHERS.equals(requestedCiphers)) { return supportedCiphers; } if (requestedCiphers != null) { Vector<String> vec = null; String cipher = requestedCiphers; int index = requestedCiphers.indexOf(','); if (index != -1) { int fromIndex = 0; while (index != -1) { cipher = requestedCiphers.substring(fromIndex, index).trim(); if (cipher.length() > 0) { for (int i = 0; supportedCiphers != null && i < supportedCiphers.length; i++) { if (supportedCiphers[i].equals(cipher)) { if (vec == null) { vec = new Vector<String>(); } vec.addElement(cipher); break; } } } fromIndex = index + 1; index = requestedCiphers.indexOf(',', fromIndex); } cipher = requestedCiphers.substring(fromIndex); } if (cipher != null) { cipher = cipher.trim(); if (cipher.length() > 0) { for (int i = 0; supportedCiphers != null && i < supportedCiphers.length; i++) { if (supportedCiphers[i].equals(cipher)) { if (vec == null) { vec = new Vector<String>(); } vec.addElement(cipher); break; } } } } if (vec != null) { result = new String[vec.size()]; vec.copyInto(result); } } else { result = sslProxy.getDefaultCipherSuites(); } return result; }
@Override public Attributes getAttributes(Name name, String[] attrIds) throws NamingException { Entry entry = null; if (name.isEmpty()) entry = entries; else entry = treeLookup(name); if (entry == null) return null; ZipEntry zipEntry = entry.getEntry(); ResourceAttributes attrs = new ResourceAttributes(); attrs.setCreationDate(new Date(zipEntry.getTime())); attrs.setName(entry.getName()); if (!zipEntry.isDirectory()) attrs.setResourceType(""); attrs.setContentLength(zipEntry.getSize()); attrs.setLastModified(zipEntry.getTime()); return attrs; }
public static Object coerce(String s, Class<?> target) { boolean isNullOrEmpty = (s == null || s.length() == 0); if (target == Boolean.class) { if (isNullOrEmpty) { s = "false"; } return Boolean.valueOf(s); } else if (target == Byte.class) { if (isNullOrEmpty) return new Byte((byte) 0); else return new Byte(s); } else if (target == Character.class) { if (isNullOrEmpty) return new Character((char) 0); else return new Character(s.charAt(0)); } else if (target == Double.class) { if (isNullOrEmpty) return new Double(0); else return new Double(s); } else if (target == Float.class) { if (isNullOrEmpty) return new Float(0); else return new Float(s); } else if (target == Integer.class) { if (isNullOrEmpty) return new Integer(0); else return new Integer(s); } else if (target == Short.class) { if (isNullOrEmpty) return new Short((short) 0); else return new Short(s); } else if (target == Long.class) { if (isNullOrEmpty) return new Long(0); else return new Long(s); } else { return null; } }	public static Object convert(String propertyName, String s, Class<?> t, Class<?> propertyEditorClass) throws JasperException { try { if (s == null) { if (t.equals(Boolean.class) || t.equals(Boolean.TYPE)) s = "false"; else return null; } if (propertyEditorClass != null) { return getValueFromBeanInfoPropertyEditor(t, propertyName, s, propertyEditorClass); } else if (t.equals(Boolean.class) || t.equals(Boolean.TYPE)) { if (s.equalsIgnoreCase("on") || s.equalsIgnoreCase("true")) s = "true"; else s = "false"; return Boolean.valueOf(s); } else if (t.equals(Byte.class) || t.equals(Byte.TYPE)) { return new Byte(s); } else if (t.equals(Character.class) || t.equals(Character.TYPE)) { return s.length() > 0 ? new Character(s.charAt(0)) : null; } else if (t.equals(Short.class) || t.equals(Short.TYPE)) { return new Short(s); } else if (t.equals(Integer.class) || t.equals(Integer.TYPE)) { return new Integer(s); } else if (t.equals(Float.class) || t.equals(Float.TYPE)) { return new Float(s); } else if (t.equals(Long.class) || t.equals(Long.TYPE)) { return new Long(s); } else if (t.equals(Double.class) || t.equals(Double.TYPE)) { return new Double(s); } else if (t.equals(String.class)) { return s; } else if (t.equals(java.io.File.class)) { return new java.io.File(s); } else if (t.getName().equals("java.lang.Object")) { return new Object[] { s }; } else { return getValueFromPropertyEditorManager(t, propertyName, s); } } catch (Exception ex) { throw new JasperException(ex); } }	public static String toString(boolean b) { return Boolean.valueOf(b).toString(); }	public static String toString(byte b) { return new Byte(b).toString(); }	public static String toString(char c) { return new Character(c).toString(); }	public static String toString(double d) { return new Double(d).toString(); }	public static String toString(float f) { return new Float(f).toString(); }	public static String toString(int i) { return new Integer(i).toString(); }	public static String toString(long l) { return new Long(l).toString(); }	public static String toString(short s) { return new Short(s).toString(); }	public static boolean coerceToBoolean(String s) { if (s == null || s.length() == 0) return false; else return Boolean.valueOf(s).booleanValue(); }	public static byte coerceToByte(String s) { if (s == null || s.length() == 0) return (byte) 0; else return Byte.valueOf(s).byteValue(); }	public static double coerceToDouble(String s) { if (s == null || s.length() == 0) return 0; else return Double.valueOf(s).doubleValue(); }	public static float coerceToFloat(String s) { if (s == null || s.length() == 0) return 0; else return Float.valueOf(s).floatValue(); }	public static int coerceToInt(String s) { if (s == null || s.length() == 0) return 0; else return Integer.valueOf(s).intValue(); }	public static long coerceToLong(String s) { if (s == null || s.length() == 0) return 0; else return Long.valueOf(s).longValue(); }	public static short coerceToShort(String s) { if (s == null || s.length() == 0) return (short) 0; else return Short.valueOf(s).shortValue(); }	public static void createTypedArray(String propertyName, Object bean, Method method, String[] values, Class<?> t, Class<?> propertyEditorClass) throws JasperException { try { if (propertyEditorClass != null) { Object[] tmpval = new Integer[values.length]; for (int i = 0; i < values.length; i++) { tmpval[i] = getValueFromBeanInfoPropertyEditor(t, propertyName, values[i], propertyEditorClass); } method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(Integer.class)) { Integer[] tmpval = new Integer[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = new Integer(values[i]); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(Byte.class)) { Byte[] tmpval = new Byte[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = new Byte(values[i]); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(Boolean.class)) { Boolean[] tmpval = new Boolean[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = Boolean.valueOf(values[i]); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(Short.class)) { Short[] tmpval = new Short[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = new Short(values[i]); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(Long.class)) { Long[] tmpval = new Long[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = new Long(values[i]); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(Double.class)) { Double[] tmpval = new Double[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = new Double(values[i]); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(Float.class)) { Float[] tmpval = new Float[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = new Float(values[i]); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(Character.class)) { Character[] tmpval = new Character[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = new Character(values[i].charAt(0)); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(int.class)) { int[] tmpval = new int[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = Integer.parseInt(values[i]); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(byte.class)) { byte[] tmpval = new byte[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = Byte.parseByte(values[i]); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(boolean.class)) { boolean[] tmpval = new boolean[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = (Boolean.valueOf(values[i])).booleanValue(); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(short.class)) { short[] tmpval = new short[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = Short.parseShort(values[i]); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(long.class)) { long[] tmpval = new long[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = Long.parseLong(values[i]); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(double.class)) { double[] tmpval = new double[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = Double.valueOf(values[i]).doubleValue(); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(float.class)) { float[] tmpval = new float[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = Float.valueOf(values[i]).floatValue(); method.invoke(bean, new Object[] { tmpval }); } else if (t.equals(char.class)) { char[] tmpval = new char[values.length]; for (int i = 0; i < values.length; i++) tmpval[i] = values[i].charAt(0); method.invoke(bean, new Object[] { tmpval }); } else { Object[] tmpval = new Integer[values.length]; for (int i = 0; i < values.length; i++) { tmpval[i] = getValueFromPropertyEditorManager(t, propertyName, values[i]); } method.invoke(bean, new Object[] { tmpval }); } } catch (Exception ex) { throw new JasperException("error in invoking method", ex); } }	public static void handleSetProperty(Object bean, String prop, boolean value) throws JasperException { try { Method method = getWriteMethod(bean.getClass(), prop); method.invoke(bean, new Object[] { Boolean.valueOf(value) }); } catch (Exception ex) { throw new JasperException(ex); } }
private Class<?> loadTagFile(Compiler compiler, String tagFilePath, TagInfo tagInfo, PageInfo parentPageInfo) throws JasperException { JarResource tagJarResouce = null; if (tagFilePath.startsWith("/META-INF/")) { tagJarResouce = compiler.getCompilationContext().getTldLocation(tagInfo.getTagLibrary().getURI()).getJarResource(); } String wrapperUri; if (tagJarResouce == null) { wrapperUri = tagFilePath; } else { wrapperUri = tagJarResouce.getEntry(tagFilePath).toString(); } JspCompilationContext ctxt = compiler.getCompilationContext(); JspRuntimeContext rctxt = ctxt.getRuntimeContext(); JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri); synchronized (rctxt) { if (wrapper == null) { wrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), tagJarResouce); rctxt.addWrapper(wrapperUri, wrapper); wrapper.getJspEngineContext().setClassLoader(ctxt.getClassLoader()); wrapper.getJspEngineContext().setClassPath(ctxt.getClassPath()); } else { // Make sure that JspCompilationContext gets the latest TagInfo // for the tag file. TagInfo instance was created the last // time the tag file was scanned for directives, and the tag wrapper.getJspEngineContext().setTagInfo(tagInfo); } Class<?> tagClazz; int tripCount = wrapper.incTripCount(); try { if (tripCount > 0) { // When tripCount is greater than zero, a circular // dependency exists. The circularly dependent tag // file is compiled in prototype mode, to avoid infinite JspServletWrapper tempWrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), ctxt.getTagFileJarResource(tagFilePath)); tempWrapper.getJspEngineContext().setClassLoader(ctxt.getClassLoader()); tempWrapper.getJspEngineContext().setClassPath(ctxt.getClassPath()); tagClazz = tempWrapper.loadTagFilePrototype(); tempVector.add(tempWrapper.getJspEngineContext().getCompiler()); } else { tagClazz = wrapper.loadTagFile(); } } finally { wrapper.decTripCount(); } try { Object tagIns = tagClazz.newInstance(); if (tagIns instanceof JspSourceDependent) { Iterator<String> iter = ((JspSourceDependent) tagIns).getDependants().iterator(); while (iter.hasNext()) { parentPageInfo.addDependant(iter.next()); } } } catch (Exception e) { // ignore errors } return tagClazz; } }
protected File getAppBase() { if (appBase != null) { return appBase; } File file = new File(host.getAppBase()); if (!file.isAbsolute()) file = new File(System.getProperty(Globals.CATALINA_BASE_PROP), host.getAppBase()); try { appBase = file.getCanonicalFile(); } catch (IOException e) { appBase = file; } return (appBase); }	protected void remove(String path) throws Exception { // TODO Handle remove also work dir content ! Context context = (Context) host.findChild(path); if (context != null) { if (log.isDebugEnabled()) log.debug(sm.getString("farmWarDeployer.undeployLocal", path)); context.stop(); String baseName = context.getBaseName(); File war = new File(getAppBase(), baseName + ".war"); File dir = new File(getAppBase(), baseName); File xml = new File(configBase, baseName + ".xml"); if (war.exists()) { if (!war.delete()) { log.error(sm.getString("farmWarDeployer.deleteFail", war)); } } else if (dir.exists()) { undeployDir(dir); } else { if (!xml.delete()) { log.error(sm.getString("farmWarDeployer.deleteFail", xml)); } } check(path); } }	public String getContextPath() { return contextPath; }	@Override public boolean accept(ClusterMessage msg) { return (msg instanceof FileMessage) || (msg instanceof UndeployMessage); }	public boolean writeMessage(FileMessage msg) throws IllegalArgumentException, IOException { if (!openForWrite) throw new IllegalArgumentException("Can't write message, this factory is reading."); if (log.isDebugEnabled()) log.debug("Message " + msg + " data " + HexUtils.toHexString(msg.getData()) + " data length " + msg.getDataLength() + " out " + out); if (msg.getMessageNumber() <= lastMessageProcessed.get()) { log.warn("Receive Message again -- Sender ActTimeout too short [ path: " + msg.getContextPath() + " war: " + msg.getFileName() + " data: " + HexUtils.toHexString(msg.getData()) + " data length: " + msg.getDataLength() + " ]"); return false; } FileMessage previous = msgBuffer.put(Long.valueOf(msg.getMessageNumber()), msg); if (previous != null) { log.warn("Receive Message again -- Sender ActTimeout too short [ path: " + msg.getContextPath() + " war: " + msg.getFileName() + " data: " + HexUtils.toHexString(msg.getData()) + " data length: " + msg.getDataLength() + " ]"); return false; } FileMessage next = null; synchronized (this) { if (!isWriting) { next = msgBuffer.get(Long.valueOf(lastMessageProcessed.get() + 1)); if (next != null) { isWriting = true; } else { return false; } } else { return false; } } while (next != null) { out.write(next.getData(), 0, next.getDataLength()); lastMessageProcessed.incrementAndGet(); out.flush(); if (next.getMessageNumber() == next.getTotalNrOfMsgs()) { out.close(); cleanup(); return true; } synchronized (this) { next = msgBuffer.get(Long.valueOf(lastMessageProcessed.get() + 1)); if (next == null) { isWriting = false; } } } return false; }	public synchronized FileMessageFactory getFactory(FileMessage msg) throws java.io.FileNotFoundException, java.io.IOException { File tmpFile = new File(msg.getFileName()); File writeToFile = new File(getTempDir(), tmpFile.getName()); FileMessageFactory factory = fileFactories.get(msg.getFileName()); if (factory == null) { factory = FileMessageFactory.getInstance(writeToFile, true); fileFactories.put(msg.getFileName(), factory); } return factory; }	@Override public void fileModified(File newWar) { try { File deployWar = new File(getDeployDir(), newWar.getName()); copy(newWar, deployWar); String contextName = getContextName(deployWar); if (log.isInfoEnabled()) log.info(sm.getString("farmWarDeployer.modInstall", contextName, deployWar.getAbsolutePath())); try { remove(contextName, false); } catch (Exception x) { log.error(sm.getString("farmWarDeployer.modRemoveFail"), x); } install(contextName, deployWar.toURI().toURL()); } catch (Exception x) { log.error(sm.getString("farmWarDeployer.modInstallFail"), x); } }	@Override public void fileRemoved(File removeWar) { try { String contextName = getContextName(removeWar); if (log.isInfoEnabled()) log.info(sm.getString("farmWarDeployer.removeLocal", contextName)); remove(contextName, true); } catch (Exception x) { log.error(sm.getString("farmWarDeployer.removeLocalFail"), x); } }	@Override public void install(String contextPath, URL war) throws IOException { Member[] members = getCluster().getMembers(); Member localMember = getCluster().getLocalMember(); FileMessageFactory factory = FileMessageFactory.getInstance(new File(war.getFile()), false); FileMessage msg = new FileMessage(localMember, war.getFile(), contextPath); if (log.isDebugEnabled()) log.debug(sm.getString("farmWarDeployer.sendStart", contextPath, war)); msg = factory.readMessage(msg); while (msg != null) { for (int i = 0; i < members.length; i++) { if (log.isDebugEnabled()) log.debug(sm.getString("farmWarDeployer.sendFragment", contextPath, war, members[i])); getCluster().send(msg, members[i]); } msg = factory.readMessage(msg); } if (log.isDebugEnabled()) log.debug(sm.getString("farmWarDeployer.sendEnd", contextPath, war)); }	@Override public void messageReceived(ClusterMessage msg) { try { if (msg instanceof FileMessage) { FileMessage fmsg = (FileMessage) msg; if (log.isDebugEnabled()) log.debug(sm.getString("farmWarDeployer.msgRxDeploy", fmsg.getContextPath(), fmsg.getFileName())); FileMessageFactory factory = getFactory(fmsg); if (factory.writeMessage(fmsg)) { String name = factory.getFile().getName(); if (!name.endsWith(".war")) name = name + ".war"; File deployable = new File(getDeployDir(), name); try { String path = fmsg.getContextPath(); if (!isServiced(path)) { addServiced(path); try { remove(path); if (!factory.getFile().renameTo(deployable)) { log.error(sm.getString("farmWarDeployer.renameFail", factory.getFile(), deployable)); } check(path); } finally { removeServiced(path); } if (log.isDebugEnabled()) log.debug(sm.getString("farmWarDeployer.deployEnd", path)); } else log.error(sm.getString("farmWarDeployer.servicingDeploy", path, name)); } catch (Exception ex) { log.error(ex); } finally { removeFactory(fmsg); } } } else if (msg instanceof UndeployMessage) { try { UndeployMessage umsg = (UndeployMessage) msg; String path = umsg.getContextPath(); if (log.isDebugEnabled()) log.debug(sm.getString("farmWarDeployer.msgRxUndeploy", path)); if (!isServiced(path)) { addServiced(path); try { remove(path); } finally { removeServiced(path); } if (log.isDebugEnabled()) log.debug(sm.getString("farmWarDeployer.undeployEnd", path)); } else log.error(sm.getString("farmWarDeployer.servicingUneploy", path)); } catch (Exception ex) { log.error(ex); } } } catch (java.io.IOException x) { log.error(sm.getString("farmWarDeployer.msgIoe"), x); } }	@Override public void remove(String contextPath, boolean undeploy) throws IOException { if (log.isInfoEnabled()) log.info(sm.getString("farmWarDeployer.removeStart", contextPath)); Member localMember = getCluster().getLocalMember(); UndeployMessage msg = new UndeployMessage(localMember, System.currentTimeMillis(), "Undeploy:" + contextPath + ":" + System.currentTimeMillis(), contextPath, undeploy); if (log.isDebugEnabled()) log.debug(sm.getString("farmWarDeployer.removeTxMsg", contextPath)); cluster.send(msg); if (undeploy) { try { if (!isServiced(contextPath)) { addServiced(contextPath); try { remove(contextPath); } finally { removeServiced(contextPath); } } else log.error(sm.getString("farmWarDeployer.removeFailRemote", contextPath)); } catch (Exception ex) { log.error(sm.getString("farmWarDeployer.removeFailLocal", contextPath), ex); } } }	public void setFileName(String fileName) { this.fileName = fileName; }	@Override public void setUniqueId(String uniqueId) { this.uniqueId = uniqueId; }
@SuppressWarnings("deprecation") private void clearReferencesThreads() { Thread[] threads = getThreads(); for (Thread thread : threads) { if (thread != null) { ClassLoader ccl = thread.getContextClassLoader(); if (ccl == this) { if (thread == Thread.currentThread()) { continue; } if (!thread.isAlive()) { continue; } ThreadGroup tg = thread.getThreadGroup(); if (tg != null && JVM_THREAD_GROUP_NAMES.contains(tg.getName())) { continue; } if (thread.getClass().getName().equals("java.util.TimerThread") && clearReferencesStopTimerThreads) { clearReferencesStopTimerThread(thread); continue; } if (isRequestThread(thread)) { log.error(sm.getString("webappClassLoader.warnRequestThread", contextName, thread.getName())); } else { log.error(sm.getString("webappClassLoader.warnThread", contextName, thread.getName())); } if (!clearReferencesStopThreads) { continue; } try { Field targetField = thread.getClass().getDeclaredField("target"); targetField.setAccessible(true); Object target = targetField.get(thread); if (target != null && target.getClass().getCanonicalName().equals("java.util.concurrent.ThreadPoolExecutor.Worker")) { Field executorField = target.getClass().getDeclaredField("this$0"); executorField.setAccessible(true); Object executor = executorField.get(target); if (executor instanceof ThreadPoolExecutor) { ((ThreadPoolExecutor) executor).shutdownNow(); } } } catch (SecurityException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } catch (NoSuchFieldException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } catch (IllegalArgumentException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } catch (IllegalAccessException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } // This method is deprecated and for good reason. This is // very risky code but is the only option at this point. // A *very* good reason for apps to do this clean-up thread.stop(); } } } }	@Override protected void startInternal() throws LifecycleException { if (log.isDebugEnabled()) log.debug(sm.getString("webappLoader.starting")); if (container.getResources() == null) { log.info("No resources for " + container); setState(LifecycleState.STARTING); return; } URLStreamHandlerFactory streamHandlerFactory = new DirContextURLStreamHandlerFactory(); if (first) { first = false; try { URL.setURLStreamHandlerFactory(streamHandlerFactory); } catch (Exception e) { log.error("Error registering jndi stream handler", e); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.info("Dual registration of jndi stream handler: " + t.getMessage()); } } try { classLoader = createClassLoader(); classLoader.setResources(container.getResources()); classLoader.setDelegate(this.delegate); classLoader.setSearchExternalFirst(searchExternalFirst); if (container instanceof StandardContext) { classLoader.setAntiJARLocking(((StandardContext) container).getAntiJARLocking()); classLoader.setClearReferencesStatic(((StandardContext) container).getClearReferencesStatic()); classLoader.setClearReferencesStopThreads(((StandardContext) container).getClearReferencesStopThreads()); classLoader.setClearReferencesStopTimerThreads(((StandardContext) container).getClearReferencesStopTimerThreads()); } for (int i = 0; i < repositories.length; i++) { classLoader.addRepository(repositories[i]); } setRepositories(); setClassPath(); setPermissions(); ((Lifecycle) classLoader).start(); DirContextURLStreamHandler.bind(classLoader, this.container.getResources()); StandardContext ctx = (StandardContext) container; String contextName = ctx.getName(); if (!contextName.startsWith("/")) { contextName = "/" + contextName; } ObjectName cloname = new ObjectName(MBeanUtils.getDomain(ctx) + ":type=WebappClassLoader,context=" + contextName + ",host=" + ctx.getParent().getName()); Registry.getRegistry(null, null).registerComponent(classLoader, cloname, null); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error("LifecycleException ", t); throw new LifecycleException("start: ", t); } setState(LifecycleState.STARTING); }	@Override public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) { ClassLoader loader = Thread.currentThread().getContextClassLoader(); try { // Use the system classloader as the victim for all this Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); if (appContextProtection) { ImageIO.getCacheDirectory(); } if (gcDaemonProtection) { try { Class<?> clazz = Class.forName("sun.misc.GC"); Method method = clazz.getDeclaredMethod("requestLatency", new Class[] { long.class }); method.invoke(null, Long.valueOf(3600000)); } catch (ClassNotFoundException e) { if (System.getProperty("java.vendor").startsWith("Sun")) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } else { log.debug(sm.getString("jreLeakListener.gcDaemonFail"), e); } } catch (SecurityException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (NoSuchMethodException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (IllegalArgumentException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (IllegalAccessException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (InvocationTargetException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } } if (keepAliveProtection) { try { Class.forName("sun.net.www.http.HttpClient"); } catch (ClassNotFoundException e) { if (System.getProperty("java.vendor").startsWith("Sun")) { log.error(sm.getString("jreLeakListener.keepAliveFail"), e); } else { log.debug(sm.getString("jreLeakListener.keepAliveFail"), e); } } } if (securityPolicyProtection) { try { Class<?> policyClass = Class.forName("javax.security.auth.Policy"); Method method = policyClass.getMethod("getPolicy"); method.invoke(null); } catch (ClassNotFoundException e) { // Ignore. The class is deprecated. } catch (SecurityException e) { // Ignore. Don't need call to getPolicy() to be // successful, just need to trigger static initializer. } catch (NoSuchMethodException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (IllegalArgumentException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (IllegalAccessException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (InvocationTargetException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } } if (securityLoginConfigurationProtection) { try { Class.forName("javax.security.auth.login.Configuration", true, ClassLoader.getSystemClassLoader()); } catch (ClassNotFoundException e) { // Ignore } } if (tokenPollerProtection) { java.security.Security.getProviders(); } if (urlCacheProtection) { try { // Doesn't matter that this JAR doesn't exist - just as URL url = new URL("jar:file://dummy.jar!/"); URLConnection uConn = url.openConnection(); uConn.setDefaultUseCaches(false); } catch (MalformedURLException e) { log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"), e); } catch (IOException e) { log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"), e); } } if (xmlParsingProtection) { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); try { factory.newDocumentBuilder(); } catch (ParserConfigurationException e) { log.error(sm.getString("jreLeakListener.xmlParseFail"), e); } } if (ldapPoolProtection) { try { Class.forName("com.sun.jndi.ldap.LdapPoolManager"); } catch (ClassNotFoundException e) { if (System.getProperty("java.vendor").startsWith("Sun")) { log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"), e); } else { log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"), e); } } } } finally { Thread.currentThread().setContextClassLoader(loader); } } }	public void setClearReferencesLogFactoryRelease(boolean clearReferencesLogFactoryRelease) { this.clearReferencesLogFactoryRelease = clearReferencesLogFactoryRelease; }	public void setClearReferencesStopTimerThreads(boolean clearReferencesStopTimerThreads) { boolean oldClearReferencesStopTimerThreads = this.clearReferencesStopTimerThreads; this.clearReferencesStopTimerThreads = clearReferencesStopTimerThreads; support.firePropertyChange("clearReferencesStopTimerThreads", oldClearReferencesStopTimerThreads, this.clearReferencesStopTimerThreads); }	public boolean isKeepAliveProtection() { return keepAliveProtection; }
@Override public void readExternal(ObjectInput in) throws IOException { int length = in.readInt(); message = new byte[length]; in.read(message, 0, length); }
private ClassLoader bindThread() { ClassLoader oldContextClassLoader = Thread.currentThread().getContextClassLoader(); if (getResources() == null) return oldContextClassLoader; if (getLoader().getClassLoader() != null) { Thread.currentThread().setContextClassLoader(getLoader().getClassLoader()); } DirContextURLStreamHandler.bindThread(getResources()); if (isUseNaming()) { try { ContextBindings.bindThread(this, this); } catch (NamingException e) { // Silent catch, as this is a normal case during the early // startup stages } } return oldContextClassLoader; }	protected File engineBase() { String base = System.getProperty(Globals.CATALINA_BASE_PROP); if (base == null) { StandardEngine eng = (StandardEngine) this.getParent().getParent(); base = eng.getBaseDir(); } return (new File(base)); }
public void recycle() { context = null; wrapper = null; internalDispatcherType = null; requestDispatcherPath = null; comet = false; if (event != null) { event.clear(); event = null; } authType = null; inputBuffer.recycle(); usingInputStream = false; usingReader = false; userPrincipal = null; subject = null; sessionParsed = false; parametersParsed = false; parts = null; partsParseException = null; cookiesParsed = false; locales.clear(); localesParsed = false; secure = false; remoteAddr = null; remoteHost = null; remotePort = -1; localPort = -1; localAddr = null; localName = null; attributes.clear(); sslAttributesParsed = false; notes.clear(); cookies = null; if (session != null) { session.endAccess(); } session = null; requestedSessionCookie = false; requestedSessionId = null; requestedSessionURL = false; if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) { parameterMap = new ParameterMap<String, String[]>(); } else { parameterMap.setLocked(false); parameterMap.clear(); } mappingData.recycle(); if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) { if (facade != null) { facade.clear(); facade = null; } if (inputStream != null) { inputStream.clear(); inputStream = null; } if (reader != null) { reader.clear(); reader = null; } } asyncSupported = null; if (asyncContext != null) asyncContext.recycle(); asyncContext = null; pathParameters.clear(); }
/** * Executes a CGI script with the desired environment, current working * directory, and input/output streams * * <p> * This implements the following CGI specification recommedations: * <UL> * <LI> Servers SHOULD provide the "<code>query</code>" component of * the script-URI as command-line arguments to scripts if it * does not contain any unencoded "=" characters and the * command-line arguments can be generated in an unambiguous * manner. * <LI> Servers SHOULD set the AUTH_TYPE metavariable to the value * of the "<code>auth-scheme</code>" token of the * "<code>Authorization</code>" if it was supplied as part of the * request header. See <code>getCGIEnvironment</code> method. * <LI> Where applicable, servers SHOULD set the current working * directory to the directory in which the script is located * before invoking it. * <LI> Server implementations SHOULD define their behavior for the * following cases: * <ul> * <LI> <u>Allowed characters in pathInfo</u>: This implementation * does not allow ASCII NUL nor any character which cannot * be URL-encoded according to internet standards; * <LI> <u>Allowed characters in path segments</u>: This * implementation does not allow non-terminal NULL * segments in the the path -- IOExceptions may be thrown; * <LI> <u>"<code>.</code>" and "<code>..</code>" path * segments</u>: * This implementation does not allow "<code>.</code>" and * "<code>..</code>" in the the path, and such characters * will result in an IOException being thrown (this should * never happen since Tomcat normalises the requestURI * before determining the contextPath, servletPath and * pathInfo); * <LI> <u>Implementation limitations</u>: This implementation * does not impose any limitations except as documented * above. This implementation may be limited by the * servlet container used to house this implementation. * In particular, all the primary CGI variable values * are derived either directly or indirectly from the * container's implementation of the Servlet API methods. * </ul> * </UL> * </p> * * @exception IOException if problems during reading/writing occur * * @see java.lang.Runtime#exec(String command, String[] envp, * File dir) */ protected void run() throws IOException { /* * REMIND: this method feels too big; should it be re-written? */ if (!isReady()) { throw new IOException(this.getClass().getName() + ": not ready to run."); } if (debug >= 1 ) { log("runCGI(envp=[" + env + "], command=" + command + ")"); } if ((command.indexOf(File.separator + "." + File.separator) >= 0) || (command.indexOf(File.separator + "..") >= 0) || (command.indexOf(".." + File.separator) >= 0)) { throw new IOException(this.getClass().getName() + "Illegal Character in CGI command " + "path ('.' or '..') detected. Not " + "running CGI [" + command + "]."); } /* original content/structure of this section taken from * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4216884 * with major modifications by Martin Dengler */ Runtime rt = null; BufferedReader cgiHeaderReader = null; InputStream cgiOutput = null; BufferedReader commandsStdErr = null; Thread errReaderThread = null; BufferedOutputStream commandsStdIn = null; Process proc = null; int bufRead = -1; String[] cmdAndArgs = new String[params.size() + 2]; cmdAndArgs[0] = cgiExecutable; cmdAndArgs[1] = command; //create query arguments for (int i=0; i < params.size(); i++) { cmdAndArgs[i + 2] = params.get(i); } try { rt = Runtime.getRuntime(); proc = rt.exec(cmdAndArgs, hashToStringArray(env), wd); String sContentLength = env.get("CONTENT_LENGTH"); if(!"".equals(sContentLength)) { commandsStdIn = new BufferedOutputStream(proc.getOutputStream()); IOTools.flow(stdin, commandsStdIn); commandsStdIn.flush(); commandsStdIn.close(); } /* we want to wait for the process to exit, Process.waitFor() * is useless in our situation; see * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4223650 */ boolean isRunning = true; commandsStdErr = new BufferedReader (new InputStreamReader(proc.getErrorStream())); final BufferedReader stdErrRdr = commandsStdErr ; errReaderThread = new Thread() { @Override } } }	public void init(ServletConfig config) throws ServletException { super.init(config); if (getServletConfig().getInitParameter("debug") != null) debug = Integer.parseInt(getServletConfig().getInitParameter("debug")); cgiPathPrefix = getServletConfig().getInitParameter("cgiPathPrefix"); boolean passShellEnvironment = Boolean.valueOf(getServletConfig().getInitParameter("passShellEnvironment")).booleanValue(); if (passShellEnvironment) { shellEnv.putAll(System.getenv()); } if (getServletConfig().getInitParameter("executable") != null) { cgiExecutable = getServletConfig().getInitParameter("executable"); } if (getServletConfig().getInitParameter("parameterEncoding") != null) { parameterEncoding = getServletConfig().getInitParameter("parameterEncoding"); } if (getServletConfig().getInitParameter("stderrTimeout") != null) { stderrTimeout = Long.parseLong(getServletConfig().getInitParameter("stderrTimeout")); } }
protected PooledConnection createConnection(long now, PooledConnection notUsed, String username, String password) throws SQLException { PooledConnection con = create(); if (username != null) con.getAttributes().put(con.PROP_USER, username); if (password != null) con.getAttributes().put(con.PROP_PASSWORD, password); boolean error = false; try { con.lock(); con.connect(); if (con.validate(PooledConnection.VALIDATE_INIT)) { con.setTimestamp(now); if (getPoolProperties().isLogAbandoned()) { con.setStackTrace(getThreadDump()); } if (!busy.offer(con)) { log.debug("Connection doesn't fit into busy array, connection will not be traceable."); } return con; } else { //validation failed, make sure we disconnect error = true; } //end if } catch (Exception e) { error = true; if (log.isDebugEnabled()) log.debug("Unable to create a new JDBC connection.", e); if (e instanceof SQLException) { throw (SQLException) e; } else { SQLException ex = new SQLException(e.getMessage()); ex.initCause(e); throw ex; } } finally { if (error) { release(con); } con.unlock(); } return null; }	protected void release(PooledConnection con) { if (con == null) return; try { con.lock(); if (con.release()) { size.addAndGet(-1); con.setHandler(null); } } finally { con.unlock(); } if (waitcount.get() > 0) { idle.offer(new PooledConnection(poolProperties, this)); } }	public static String getStackTrace(Throwable x) { if (x == null) { return null; } else { java.io.ByteArrayOutputStream bout = new java.io.ByteArrayOutputStream(); java.io.PrintStream writer = new java.io.PrintStream(bout); x.printStackTrace(writer); String result = bout.toString(); return (x.getMessage() != null && x.getMessage().length() > 0) ? x.getMessage() + ";" + result : result; } //end if }
@Override public Collection<Object> values() { ArrayList<Object> values = new ArrayList<Object>(); Iterator<Map.Entry<?, ?>> i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry<?, ?> e = i.next(); MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry != null && entry.isActive() && entry.getValue() != null) values.add(entry.getValue()); } return Collections.unmodifiableCollection(values); }	@Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (!(obj instanceof ApplicationTaglibDescriptor)) { return false; } ApplicationTaglibDescriptor other = (ApplicationTaglibDescriptor) obj; if (location == null) { if (other.location != null) { return false; } } else if (!location.equals(other.location)) { return false; } if (uri == null) { if (other.uri != null) { return false; } } else if (!uri.equals(other.uri)) { return false; } return true; }	@Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (!(obj instanceof LoginConfig)) return false; LoginConfig other = (LoginConfig) obj; if (authMethod == null) { if (other.authMethod != null) return false; } else if (!authMethod.equals(other.authMethod)) return false; if (errorPage == null) { if (other.errorPage != null) return false; } else if (!errorPage.equals(other.errorPage)) return false; if (loginPage == null) { if (other.loginPage != null) return false; } else if (!loginPage.equals(other.loginPage)) return false; if (realmName == null) { if (other.realmName != null) return false; } else if (!realmName.equals(other.realmName)) return false; return true; }	@Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (!(obj instanceof SimpleNode)) { return false; } SimpleNode other = (SimpleNode) obj; if (!Arrays.equals(children, other.children)) { return false; } if (id != other.id) { return false; } if (image == null) { if (other.image != null) { return false; } } else if (!image.equals(other.image)) { return false; } return true; }	@Override public boolean equals(Object obj) { if ((obj != null) && (obj instanceof NamingEntry)) { return name.equals(((NamingEntry) obj).name); } else { return false; } }	@Override public boolean equals(Object obj) { if (obj == null) return (false); if (!(obj instanceof URL)) return (false); URL other = (URL) obj; if (!sameFile(other)) return (false); return (compare(ref, other.getRef())); }
public void setPassword(String password) { this.password = password; }
void setFilterDef(FilterDef filterDef) throws ClassCastException, ClassNotFoundException, IllegalAccessException, InstantiationException, ServletException, InvocationTargetException, NamingException { this.filterDef = filterDef; if (filterDef == null) { if (this.filter != null) { if (Globals.IS_SECURITY_ENABLED) { try { SecurityUtil.doAsPrivilege("destroy", filter); } catch (java.lang.Exception ex) { context.getLogger().error("ApplicationFilterConfig.doAsPrivilege", ex); } SecurityUtil.remove(filter); } else { filter.destroy(); } if (!context.getIgnoreAnnotations()) { try { ((StandardContext) context).getInstanceManager().destroyInstance(this.filter); } catch (Exception e) { context.getLogger().error("ApplicationFilterConfig.preDestroy", e); } } } this.filter = null; } else { getFilter(); } }
public void check() { if (log.isInfoEnabled()) log.info("check cluster wars at " + watchDir); File[] list = watchDir.listFiles(new WarFilter()); if (list == null) list = new File[0]; for (int i = 0; i < list.length; i++) { addWarInfo(list[i]); } for (Iterator<Map.Entry<String, WarInfo>> i = currentStatus.entrySet().iterator(); i.hasNext(); ) { Map.Entry<String, WarInfo> entry = i.next(); WarInfo info = entry.getValue(); int check = info.check(); if (check == 1) { listener.fileModified(info.getWar()); } else if (check == -1) { listener.fileRemoved(info.getWar()); currentStatus.remove(info.getWar().getAbsolutePath()); } } }
protected AccessLogElement[] createLogElements() { List<AccessLogElement> list = new ArrayList<AccessLogElement>(); boolean replace = false; StringBuilder buf = new StringBuilder(); for (int i = 0; i < pattern.length(); i++) { char ch = pattern.charAt(i); if (replace) { if ('{' == ch) { StringBuilder name = new StringBuilder(); int j = i + 1; for (; j < pattern.length() && '}' != pattern.charAt(j); j++) { name.append(pattern.charAt(j)); } if (j + 1 < pattern.length()) { j++; list.add(createAccessLogElement(name.toString(), pattern.charAt(j))); i = j; /* Since we walked more than one character */ } else { // D'oh - end of string - pretend we never did this list.add(createAccessLogElement(ch)); } } else { list.add(createAccessLogElement(ch)); } replace = false; } else if (ch == '%') { replace = true; list.add(new StringElement(buf.toString())); buf = new StringBuilder(); } else { buf.append(ch); } } if (buf.length() > 0) { list.add(new StringElement(buf.toString())); } return list.toArray(new AccessLogElement[0]); }	public void endRequest() throws IOException { if (!committed) { // Send the connector a request for commit. The connector should // then validate the headers, send them (using sendHeader) and response.action(ActionCode.COMMIT, null); } if (finished) return; if (lastActiveFilter != -1) activeFilters[lastActiveFilter].end(); finished = true; byteCount = 0; }	@Override public void invoke(Request request, Response response) throws IOException, ServletException { if (getState().isAvailable() && getEnabled()) { final String t1Name = AccessLogValve.class.getName() + ".t1"; long t1 = System.currentTimeMillis(); boolean asyncdispatch = request.isAsyncDispatching(); if (!asyncdispatch) { request.setAttribute(t1Name, Long.valueOf(t1)); } getNext().invoke(request, response); if (request.isAsyncDispatching()) { return; } else if (asyncdispatch && request.getAttribute(t1Name) != null) { t1 = ((Long) request.getAttribute(t1Name)).longValue(); } long t2 = System.currentTimeMillis(); long time = t2 - t1; log(request, response, time); } else getNext().invoke(request, response); }	@Override public void invoke(Request request, Response response) throws IOException, ServletException { getNext().invoke(request, response); log(request, response, 0); }	@Override public void log(Request request, Response response, long time) { if (logElements == null || condition != null && null != request.getRequest().getAttribute(condition)) { return; } Date date = getDate(); StringBuilder result = new StringBuilder(128); for (int i = 0; i < logElements.length; i++) { logElements[i].addElement(result, date, request, response, time); } log(result.toString()); }	@Override public void log(Request request, Response response, long time) { final String EMPTY = ""; String remoteHost; if (resolveHosts) remoteHost = request.getRemoteHost(); else remoteHost = request.getRemoteAddr(); String user = request.getRemoteUser(); String query = request.getRequestURI(); long bytes = response.getBytesWritten(true); if (bytes < 0) bytes = 0; int status = response.getStatus(); String virtualHost = EMPTY; String method = EMPTY; String referer = EMPTY; String userAgent = EMPTY; String logPattern = pattern; if (logPattern.equals("combined")) { virtualHost = request.getServerName(); method = request.getMethod(); referer = request.getHeader("referer"); userAgent = request.getHeader("user-agent"); } synchronized (this) { int numberOfTries = 2; while (numberOfTries > 0) { try { open(); ps.setString(1, remoteHost); ps.setString(2, user); ps.setTimestamp(3, new Timestamp(getCurrentTimeMillis())); ps.setString(4, query); ps.setInt(5, status); if (useLongContentLength) { ps.setLong(6, bytes); } else { if (bytes > Integer.MAX_VALUE) bytes = -1; ps.setInt(6, (int) bytes); } if (logPattern.equals("combined")) { ps.setString(7, virtualHost); ps.setString(8, method); ps.setString(9, referer); ps.setString(10, userAgent); } ps.executeUpdate(); return; } catch (SQLException e) { container.getLogger().error(sm.getString("jdbcAccessLogValve.exception"), e); if (conn != null) close(); } numberOfTries--; } } }	@Override public void log(org.apache.coyote.Request req, org.apache.coyote.Response res, long time) { Request request = (Request) req.getNote(ADAPTER_NOTES); Response response = (Response) res.getNote(ADAPTER_NOTES); if (request == null) { request = connector.createRequest(); request.setCoyoteRequest(req); response = connector.createResponse(); response.setCoyoteResponse(res); request.setResponse(response); response.setRequest(request); req.setNote(ADAPTER_NOTES, request); res.setNote(ADAPTER_NOTES, response); req.getParameters().setQueryStringEncoding(connector.getURIEncoding()); } connector.getService().getContainer().logAccess(request, response, time, true); request.recycle(); response.recycle(); }	public void nextRequest() { response.recycle(); for (int i = 0; i <= lastActiveFilter; i++) { activeFilters[i].recycle(); } pos = 0; lastActiveFilter = -1; committed = false; finished = false; }	@Override public void service(org.apache.coyote.Request req, org.apache.coyote.Response res) throws Exception { Request request = (Request) req.getNote(ADAPTER_NOTES); Response response = (Response) res.getNote(ADAPTER_NOTES); if (request == null) { request = connector.createRequest(); request.setCoyoteRequest(req); response = connector.createResponse(); response.setCoyoteResponse(res); request.setResponse(response); response.setRequest(request); req.setNote(ADAPTER_NOTES, request); res.setNote(ADAPTER_NOTES, response); req.getParameters().setQueryStringEncoding(connector.getURIEncoding()); } if (connector.getXpoweredBy()) { response.addHeader("X-Powered-By", POWERED_BY); } boolean comet = false; boolean async = false; try { // Parse and set Catalina and configuration specific req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName()); if (postParseRequest(req, request, res, response)) { request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported()); connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); if (request.isComet()) { if (!response.isClosed() && !response.isError()) { if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) { if (event(req, res, SocketStatus.OPEN)) { comet = true; res.action(ActionCode.COMET_BEGIN, null); } } else { comet = true; res.action(ActionCode.COMET_BEGIN, null); } } else { // Clear the filter chain, as otherwise it will not be reset elsewhere request.setFilterChain(null); } } } AsyncContextImpl asyncConImpl = (AsyncContextImpl) request.getAsyncContext(); if (asyncConImpl != null) { async = true; } else if (!comet) { response.finishResponse(); req.action(ActionCode.POST_REQUEST, null); } } catch (IOException e) { // Ignore } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString("coyoteAdapter.service"), t); } finally { req.getRequestProcessor().setWorkerThreadName(null); if (!comet && !async) { request.recycle(); response.recycle(); } else { // Clear converters so that the minimum amount of memory request.clearEncoders(); response.clearEncoders(); } } }	public void setUseLongContentLength(boolean useLongContentLength) { this.useLongContentLength = useLongContentLength; }
protected boolean isRequestWithoutSessionChange(String uri) { return filter.matcher(uri).matches(); }
public Group createGroup(String groupname, String description) { MemoryGroup group = new MemoryGroup(this, groupname, description); synchronized (groups) { groups.put(group.getGroupname(), group); } return (group); }	public Role createRole(String rolename, String description) { MemoryRole role = new MemoryRole(this, rolename, description); synchronized (roles) { roles.put(role.getRolename(), role); } return (role); }	public User createUser(String username, String password, String fullName) { MemoryUser user = new MemoryUser(this, username, password, fullName); synchronized (users) { users.put(user.getUsername(), user); } return (user); }	public void open() throws Exception { synchronized (groups) { synchronized (users) { users.clear(); groups.clear(); roles.clear(); File file = new File(pathname); if (!file.isAbsolute()) { file = new File(System.getProperty(Globals.CATALINA_BASE_PROP), pathname); } if (!file.exists()) { return; } FileInputStream fis = new FileInputStream(file); Digester digester = new Digester(); try { digester.setFeature("http://apache.org/xml/features/allow-java-encodings", true); } catch (Exception e) { log.warn(sm.getString("memoryUserDatabase.xmlFeatureEncoding"), e); } digester.addFactoryCreate("tomcat-users/group", new MemoryGroupCreationFactory(this)); digester.addFactoryCreate("tomcat-users/role", new MemoryRoleCreationFactory(this)); digester.addFactoryCreate("tomcat-users/user", new MemoryUserCreationFactory(this)); try { digester.parse(fis); fis.close(); } catch (Exception e) { try { fis.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } throw e; } } } }
protected void initStreams() { SystemLogHandler systemlog = new SystemLogHandler(System.out); System.setOut(systemlog); System.setErr(systemlog); }	protected void initStreams() { if (redirectStreams) { SystemLogHandler systemlog = new SystemLogHandler(System.out); System.setOut(systemlog); System.setErr(systemlog); } }
@SuppressWarnings("null") private String evaluateAttribute(TagHandlerInfo handlerInfo, Node.JspAttribute attr, Node.CustomTag n, String tagHandlerVar) throws JasperException { String attrValue = attr.getValue(); if (attrValue == null) { if (attr.isNamedAttribute()) { if (n.checkIfAttributeIsJspFragment(attr.getName())) { attrValue = generateNamedAttributeJspFragment(attr.getNamedAttributeNode(), tagHandlerVar); } else { attrValue = generateNamedAttributeValue(attr.getNamedAttributeNode()); } } else { return null; } } String localName = attr.getLocalName(); Method m = null; Class<?>[] c = null; if (attr.isDynamic()) { c = OBJECT_CLASS; } else { m = handlerInfo.getSetterMethod(localName); if (m == null) { err.jspError(n, "jsp.error.unable.to_find_method", attr.getName()); } c = m.getParameterTypes(); // XXX assert(c.length > 0) } if (attr.isExpression()) { // Do nothing } else if (attr.isNamedAttribute()) { if (!n.checkIfAttributeIsJspFragment(attr.getName()) && !attr.isDynamic()) { attrValue = convertString(c[0], attrValue, localName, handlerInfo.getPropertyEditorClass(localName), true); } } else if (attr.isELInterpreterInput()) { StringBuilder sb = new StringBuilder(64); TagAttributeInfo tai = attr.getTagAttributeInfo(); sb.append(getJspContextVar()); sb.append(".getELContext()"); String elContext = sb.toString(); if (attr.getEL() != null && attr.getEL().getMapName() != null) { sb.setLength(0); sb.append("new org.apache.jasper.el.ELContextWrapper("); sb.append(elContext); sb.append(','); sb.append(attr.getEL().getMapName()); sb.append(')'); elContext = sb.toString(); } sb.setLength(0); sb.append(n.getStart().toString()); sb.append(" '"); sb.append(attrValue); sb.append('\''); String mark = sb.toString(); sb.setLength(0); if (attr.isDeferredInput() || ((tai != null) && ValueExpression.class.getName().equals(tai.getTypeName()))) { sb.append("new org.apache.jasper.el.JspValueExpression("); sb.append(quote(mark)); sb.append(','); sb.append(getExpressionFactoryVar()); sb.append(".createValueExpression("); if (attr.getEL() != null) { sb.append(elContext); sb.append(','); } sb.append(quote(attrValue)); sb.append(','); sb.append(JspUtil.toJavaSourceTypeFromTld(attr.getExpectedTypeName())); sb.append("))"); // should the expression be evaluated before passing to boolean evaluate = false; if (tai != null && tai.canBeRequestTime()) { evaluate = true; } if (attr.isDeferredInput()) { evaluate = false; } if (attr.isDeferredInput() && tai != null && tai.canBeRequestTime()) { evaluate = !attrValue.contains("#{"); } if (evaluate) { sb.append(".getValue("); sb.append(getJspContextVar()); sb.append(".getELContext()"); sb.append(")"); } attrValue = sb.toString(); } else if (attr.isDeferredMethodInput() || ((tai != null) && MethodExpression.class.getName().equals(tai.getTypeName()))) { sb.append("new org.apache.jasper.el.JspMethodExpression("); sb.append(quote(mark)); sb.append(','); sb.append(getExpressionFactoryVar()); sb.append(".createMethodExpression("); sb.append(elContext); sb.append(','); sb.append(quote(attrValue)); sb.append(','); sb.append(JspUtil.toJavaSourceTypeFromTld(attr.getExpectedTypeName())); sb.append(','); sb.append("new Class[] {"); String[] p = attr.getParameterTypeNames(); for (int i = 0; i < p.length; i++) { sb.append(JspUtil.toJavaSourceTypeFromTld(p[i])); sb.append(','); } if (p.length > 0) { sb.setLength(sb.length() - 1); } sb.append("}))"); attrValue = sb.toString(); } else { String mapName = (attr.getEL() != null) ? attr.getEL().getMapName() : null; attrValue = JspUtil.interpreterCall(this.isTagFile, attrValue, c[0], mapName, false); } } else { attrValue = convertString(c[0], attrValue, localName, handlerInfo.getPropertyEditorClass(localName), false); } return attrValue; }	private String getScopeConstant(String scope) { String scopeName = "PageContext.PAGE_SCOPE"; if ("request".equals(scope)) { scopeName = "PageContext.REQUEST_SCOPE"; } else if ("session".equals(scope)) { scopeName = "PageContext.SESSION_SCOPE"; } else if ("application".equals(scope)) { scopeName = "PageContext.APPLICATION_SCOPE"; } return scopeName; }	static void generateLocalVariables(ServletWriter out, Node n) throws JasperException { Node.ChildInfo ci; if (n instanceof Node.CustomTag) { ci = ((Node.CustomTag) n).getChildInfo(); } else if (n instanceof Node.JspBody) { ci = ((Node.JspBody) n).getChildInfo(); } else if (n instanceof Node.NamedAttribute) { ci = ((Node.NamedAttribute) n).getChildInfo(); } else { throw new JasperException("Unexpected Node Type"); // err.getString( // "jsp.error.internal.unexpected_node_type" ) ); } if (ci.hasUseBean()) { out.printil("HttpSession session = _jspx_page_context.getSession();"); out.printil("ServletContext application = _jspx_page_context.getServletContext();"); } if (ci.hasUseBean() || ci.hasIncludeAction() || ci.hasSetProperty() || ci.hasParamAction()) { out.printil("HttpServletRequest request = (HttpServletRequest)_jspx_page_context.getRequest();"); } if (ci.hasIncludeAction()) { out.printil("HttpServletResponse response = (HttpServletResponse)_jspx_page_context.getResponse();"); } }	private void genPreambleMethods() { out.printil("public java.util.List<String> getDependants() {"); out.pushIndent(); out.printil("return _jspx_dependants;"); out.popIndent(); out.printil("}"); out.println(); generateInit(); generateDestroy(); }	private void genPreambleStaticInitializers() { out.printil("private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();"); out.println(); out.printil("private static java.util.List<String> _jspx_dependants;"); out.println(); List<String> dependants = pageInfo.getDependants(); Iterator<String> iter = dependants.iterator(); if (!dependants.isEmpty()) { out.printil("static {"); out.pushIndent(); out.printin("_jspx_dependants = new java.util.ArrayList<String>("); out.print("" + dependants.size()); out.println(");"); while (iter.hasNext()) { out.printin("_jspx_dependants.add(\""); out.print(iter.next()); out.println("\");"); } out.popIndent(); out.printil("}"); out.println(); } }	private void generateCustomEnd(Node.CustomTag n, String tagHandlerVar, String tagEvalVar, String tagPushBodyCountVar) { if (!n.hasEmptyBody()) { if (n.implementsIterationTag()) { out.printin("int evalDoAfterBody = "); out.print(tagHandlerVar); out.println(".doAfterBody();"); syncScriptingVars(n, VariableInfo.AT_BEGIN); syncScriptingVars(n, VariableInfo.NESTED); out.printil("if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN)"); out.pushIndent(); out.printil("break;"); out.popIndent(); out.popIndent(); out.printil("} while (true);"); } restoreScriptingVars(n, VariableInfo.NESTED); if (n.implementsBodyTag()) { out.printin("if ("); out.print(tagEvalVar); out.println(" != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {"); out.pushIndent(); out.printil("out = _jspx_page_context.popBody();"); if (n.implementsTryCatchFinally()) { out.printin(tagPushBodyCountVar); out.println("[0]--;"); } else if (pushBodyCountVar != null) { out.printin(pushBodyCountVar); out.println("[0]--;"); } out.popIndent(); out.printil("}"); } out.popIndent(); out.printil("}"); } out.printin("if ("); out.print(tagHandlerVar); out.println(".doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {"); out.pushIndent(); if (!n.implementsTryCatchFinally()) { if (isPoolingEnabled && !(n.implementsJspIdConsumer())) { out.printin(n.getTagHandlerPoolName()); out.print(".reuse("); out.print(tagHandlerVar); out.println(");"); } else { out.printin(tagHandlerVar); out.println(".release();"); writeDestroyInstance(tagHandlerVar); } } if (isTagFile || isFragment) { out.printil("throw new SkipPageException();"); } else { out.printil((methodNesting > 0) ? "return true;" : "return;"); } out.popIndent(); out.printil("}"); syncScriptingVars(n, VariableInfo.AT_BEGIN); if (n.implementsTryCatchFinally()) { out.popIndent(); out.printil("} catch (Throwable _jspx_exception) {"); out.pushIndent(); out.printin("while ("); out.print(tagPushBodyCountVar); out.println("[0]-- > 0)"); out.pushIndent(); out.printil("out = _jspx_page_context.popBody();"); out.popIndent(); out.printin(tagHandlerVar); out.println(".doCatch(_jspx_exception);"); out.popIndent(); out.printil("} finally {"); out.pushIndent(); out.printin(tagHandlerVar); out.println(".doFinally();"); } if (isPoolingEnabled && !(n.implementsJspIdConsumer())) { out.printin(n.getTagHandlerPoolName()); out.print(".reuse("); out.print(tagHandlerVar); out.println(");"); } else { out.printin(tagHandlerVar); out.println(".release();"); writeDestroyInstance(tagHandlerVar); } if (n.implementsTryCatchFinally()) { out.popIndent(); out.printil("}"); } // Declare and synchronize AT_END scripting variables (must do this declareScriptingVars(n, VariableInfo.AT_END); syncScriptingVars(n, VariableInfo.AT_END); restoreScriptingVars(n, VariableInfo.AT_BEGIN); }	void generateInit() { if (ctxt.isTagFile()) { out.printil("private void _jspInit(ServletConfig config) {"); } else { out.printil("public void _jspInit() {"); } out.pushIndent(); if (isPoolingEnabled) { for (int i = 0; i < tagHandlerPoolNames.size(); i++) { out.printin(tagHandlerPoolNames.elementAt(i)); out.print(" = org.apache.jasper.runtime.TagHandlerPool.getTagHandlerPool("); if (ctxt.isTagFile()) { out.print("config"); } else { out.print("getServletConfig()"); } out.println(");"); } } out.printin(VAR_EXPRESSIONFACTORY); out.print(" = _jspxFactory.getJspApplicationContext("); if (ctxt.isTagFile()) { out.print("config"); } else { out.print("getServletConfig()"); } out.println(".getServletContext()).getExpressionFactory();"); out.printin(VAR_INSTANCEMANAGER); out.print(" = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager("); if (ctxt.isTagFile()) { out.print("config"); } else { out.print("getServletConfig()"); } out.println(");"); out.popIndent(); out.printil("}"); out.println(); }	private void generatePostamble() { out.popIndent(); out.printil("} catch (Throwable t) {"); out.pushIndent(); out.printil("if (!(t instanceof SkipPageException)){"); out.pushIndent(); out.printil("out = _jspx_out;"); out.printil("if (out != null && out.getBufferSize() != 0)"); out.pushIndent(); out.printil("try { out.clearBuffer(); } catch (java.io.IOException e) {}"); out.popIndent(); out.printil("if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("} finally {"); out.pushIndent(); out.printil("_jspxFactory.releasePageContext(_jspx_page_context);"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); genCommonPostamble(); }	private void generatePreamble(Node.Nodes page) throws JasperException { String servletPackageName = ctxt.getServletPackageName(); String servletClassName = ctxt.getServletClassName(); String serviceMethodName = Constants.SERVICE_METHOD_NAME; genPreamblePackage(servletPackageName); genPreambleImports(); out.printin("public final class "); out.print(servletClassName); out.print(" extends "); out.println(pageInfo.getExtends()); out.printin(" implements org.apache.jasper.runtime.JspSourceDependent"); if (!pageInfo.isThreadSafe()) { out.println(","); out.printin(" SingleThreadModel"); } out.println(" {"); out.pushIndent(); generateDeclarations(page); genPreambleStaticInitializers(); genPreambleClassVariableDeclarations(); genPreambleMethods(); out.printin("public void "); out.print(serviceMethodName); out.println("(final HttpServletRequest request, final HttpServletResponse response)"); out.println(" throws java.io.IOException, ServletException {"); out.pushIndent(); out.println(); out.printil("final PageContext pageContext;"); if (pageInfo.isSession()) out.printil("HttpSession session = null;"); if (pageInfo.isErrorPage()) { out.printil("Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);"); out.printil("if (exception != null) {"); out.pushIndent(); out.printil("response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);"); out.popIndent(); out.printil("}"); } out.printil("final ServletContext application;"); out.printil("final ServletConfig config;"); out.printil("JspWriter out = null;"); out.printil("final Object page = this;"); out.printil("JspWriter _jspx_out = null;"); out.printil("PageContext _jspx_page_context = null;"); out.println(); declareTemporaryScriptingVars(page); out.println(); out.printil("try {"); out.pushIndent(); out.printin("response.setContentType("); out.print(quote(pageInfo.getContentType())); out.println(");"); if (ctxt.getOptions().isXpoweredBy()) { out.printil("response.addHeader(\"X-Powered-By\", \"JSP/2.1\");"); } out.printil("pageContext = _jspxFactory.getPageContext(this, request, response,"); out.printin("\t\t\t"); out.print(quote(pageInfo.getErrorPage())); out.print(", " + pageInfo.isSession()); out.print(", " + pageInfo.getBuffer()); out.print(", " + pageInfo.isAutoFlush()); out.println(");"); out.printil("_jspx_page_context = pageContext;"); out.printil("application = pageContext.getServletContext();"); out.printil("config = pageContext.getServletConfig();"); if (pageInfo.isSession()) out.printil("session = pageContext.getSession();"); out.printil("out = pageContext.getOut();"); out.printil("_jspx_out = out;"); out.println(); }	private void generateSetJspContext(TagInfo tagInfo) { boolean nestedSeen = false; boolean atBeginSeen = false; boolean atEndSeen = false; boolean aliasSeen = false; TagVariableInfo[] tagVars = tagInfo.getTagVariableInfos(); for (int i = 0; i < tagVars.length; i++) { if (tagVars[i].getNameFromAttribute() != null && tagVars[i].getNameGiven() != null) { aliasSeen = true; break; } } if (aliasSeen) { out.printil("public void setJspContext(JspContext ctx, java.util.Map aliasMap) {"); } else { out.printil("public void setJspContext(JspContext ctx) {"); } out.pushIndent(); out.printil("super.setJspContext(ctx);"); out.printil("java.util.ArrayList _jspx_nested = null;"); out.printil("java.util.ArrayList _jspx_at_begin = null;"); out.printil("java.util.ArrayList _jspx_at_end = null;"); for (int i = 0; i < tagVars.length; i++) { switch(tagVars[i].getScope()) { case VariableInfo.NESTED: if (!nestedSeen) { out.printil("_jspx_nested = new java.util.ArrayList();"); nestedSeen = true; } out.printin("_jspx_nested.add("); break; case VariableInfo.AT_BEGIN: if (!atBeginSeen) { out.printil("_jspx_at_begin = new java.util.ArrayList();"); atBeginSeen = true; } out.printin("_jspx_at_begin.add("); break; case VariableInfo.AT_END: if (!atEndSeen) { out.printil("_jspx_at_end = new java.util.ArrayList();"); atEndSeen = true; } out.printin("_jspx_at_end.add("); break; } out.print(quote(tagVars[i].getNameGiven())); out.println(");"); } if (aliasSeen) { out.printil("this.jspContext = new org.apache.jasper.runtime.JspContextWrapper(ctx, _jspx_nested, _jspx_at_begin, _jspx_at_end, aliasMap);"); } else { out.printil("this.jspContext = new org.apache.jasper.runtime.JspContextWrapper(ctx, _jspx_nested, _jspx_at_begin, _jspx_at_end, null);"); } out.popIndent(); out.printil("}"); out.println(); out.printil("public JspContext getJspContext() {"); out.pushIndent(); out.printil("return this.jspContext;"); out.popIndent(); out.printil("}"); }	private void generateTagHandlerPostamble(TagInfo tagInfo) { out.popIndent(); // Have to catch Throwable because a classic tag handler out.printil("} catch( Throwable t ) {"); out.pushIndent(); out.printil("if( t instanceof SkipPageException )"); out.printil(" throw (SkipPageException) t;"); out.printil("if( t instanceof java.io.IOException )"); out.printil(" throw (java.io.IOException) t;"); out.printil("if( t instanceof IllegalStateException )"); out.printil(" throw (IllegalStateException) t;"); out.printil("if( t instanceof JspException )"); out.printil(" throw (JspException) t;"); out.printil("throw new JspException(t);"); out.popIndent(); out.printil("} finally {"); out.pushIndent(); TagAttributeInfo[] attrInfos = tagInfo.getAttributes(); for (int i = 0; i < attrInfos.length; i++) { if (attrInfos[i].isDeferredMethod() || attrInfos[i].isDeferredValue()) { out.printin("_el_variablemapper.setVariable("); out.print(quote(attrInfos[i].getName())); out.print(",_el_ve"); out.print(i); out.println(");"); } } out.printil("jspContext.getELContext().putContext(JspContext.class,super.getJspContext());"); out.printil("((org.apache.jasper.runtime.JspContextWrapper) jspContext).syncEndTagFile();"); if (isPoolingEnabled && !tagHandlerPoolNames.isEmpty()) { out.printil("_jspDestroy();"); } out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); genCommonPostamble(); }	private void generateTagHandlerPreamble(JasperTagInfo tagInfo, Node.Nodes tag) throws JasperException { String className = tagInfo.getTagClassName(); int lastIndex = className.lastIndexOf('.'); if (lastIndex != -1) { String pkgName = className.substring(0, lastIndex); genPreamblePackage(pkgName); className = className.substring(lastIndex + 1); } genPreambleImports(); out.printin("public final class "); out.println(className); out.printil(" extends javax.servlet.jsp.tagext.SimpleTagSupport"); out.printin(" implements org.apache.jasper.runtime.JspSourceDependent"); if (tagInfo.hasDynamicAttributes()) { out.println(","); out.printin(" javax.servlet.jsp.tagext.DynamicAttributes"); } out.println(" {"); out.println(); out.pushIndent(); generateDeclarations(tag); genPreambleStaticInitializers(); out.printil("private JspContext jspContext;"); // Declare writer used for storing result of fragment/body invocation out.printil("private java.io.Writer _jspx_sout;"); genPreambleClassVariableDeclarations(); generateSetJspContext(tagInfo); generateTagHandlerAttributes(tagInfo); if (tagInfo.hasDynamicAttributes()) generateSetDynamicAttribute(); genPreambleMethods(); out.printil("public void doTag() throws JspException, java.io.IOException {"); if (ctxt.isPrototypeMode()) { out.printil("}"); out.popIndent(); out.printil("}"); return; } out.pushIndent(); out.printil("PageContext _jspx_page_context = (PageContext)jspContext;"); out.printil("HttpServletRequest request = " + "(HttpServletRequest) _jspx_page_context.getRequest();"); out.printil("HttpServletResponse response = " + "(HttpServletResponse) _jspx_page_context.getResponse();"); out.printil("HttpSession session = _jspx_page_context.getSession();"); out.printil("ServletContext application = _jspx_page_context.getServletContext();"); out.printil("ServletConfig config = _jspx_page_context.getServletConfig();"); out.printil("JspWriter out = jspContext.getOut();"); out.printil("_jspInit(config);"); out.printil("jspContext.getELContext().putContext(JspContext.class,jspContext);"); generatePageScopedVariables(tagInfo); declareTemporaryScriptingVars(tag); out.println(); out.printil("try {"); out.pushIndent(); }	public Fragment openFragment(Node parent, int methodNesting) throws JasperException { Fragment result = new Fragment(fragments.size(), parent); fragments.add(result); this.used = true; parent.setInnerClassName(className); ServletWriter out = result.getGenBuffer().getOut(); out.pushIndent(); out.pushIndent(); if (methodNesting > 0) { out.printin("public boolean invoke"); } else { out.printin("public void invoke"); } out.println(result.getId() + "( " + "JspWriter out ) "); out.pushIndent(); // Note: Throwable required because methods like _jspx_meth_* out.printil("throws Throwable"); out.popIndent(); out.printil("{"); out.pushIndent(); generateLocalVariables(out, parent); return result; }	public String generateNamedAttributeValue(Node.NamedAttribute n) throws JasperException { String varName = n.getTemporaryVariableName(); // If the only body element for this named attribute node is // template text, we need not generate an extra call to // pushBody and popBody. Maybe we can further optimize // here by getting rid of the temporary variable, but in Node.Nodes body = n.getBody(); if (body != null) { boolean templateTextOptimization = false; if (body.size() == 1) { Node bodyElement = body.getNode(0); if (bodyElement instanceof Node.TemplateText) { templateTextOptimization = true; out.printil("String " + varName + " = " + quote(((Node.TemplateText) bodyElement).getText()) + ";"); } } if (!templateTextOptimization) { out.printil("out = _jspx_page_context.pushBody();"); visitBody(n); out.printil("String " + varName + " = " + "((javax.servlet.jsp.tagext.BodyContent)" + "out).getString();"); out.printil("out = _jspx_page_context.popBody();"); } } else { out.printil("String " + varName + " = \"\";"); } return varName; }	public static String coerceToBoolean(String s, boolean isNamedAttribute) { if (isNamedAttribute) { return "(Boolean) org.apache.jasper.runtime.JspRuntimeLibrary.coerce(" + s + ", Boolean.class)"; } else { if (s == null || s.length() == 0) { return "new Boolean(false)"; } else { return "new Boolean(" + Boolean.valueOf(s).toString() + ")"; } } }	public static String coerceToByte(String s, boolean isNamedAttribute) { if (isNamedAttribute) { return "(Byte) org.apache.jasper.runtime.JspRuntimeLibrary.coerce(" + s + ", Byte.class)"; } else { if (s == null || s.length() == 0) { return "new Byte((byte) 0)"; } else { return "new Byte((byte)" + Byte.valueOf(s).toString() + ")"; } } }	public static String coerceToCharacter(String s, boolean isNamedAttribute) { if (isNamedAttribute) { return "(Character) org.apache.jasper.runtime.JspRuntimeLibrary.coerce(" + s + ", Character.class)"; } else { if (s == null || s.length() == 0) { return "new Character((char) 0)"; } else { char ch = s.charAt(0); return "new Character((char) " + (int) ch + ")"; } } }	public static String coerceToDouble(String s, boolean isNamedAttribute) { if (isNamedAttribute) { return "(Double) org.apache.jasper.runtime.JspRuntimeLibrary.coerce(" + s + ", Double.class)"; } else { if (s == null || s.length() == 0) { return "new Double(0)"; } else { return "new Double(" + Double.valueOf(s).toString() + ")"; } } }	public static String coerceToFloat(String s, boolean isNamedAttribute) { if (isNamedAttribute) { return "(Float) org.apache.jasper.runtime.JspRuntimeLibrary.coerce(" + s + ", Float.class)"; } else { if (s == null || s.length() == 0) { return "new Float(0)"; } else { return "new Float(" + Float.valueOf(s).toString() + "f)"; } } }	public static String coerceToInteger(String s, boolean isNamedAttribute) { if (isNamedAttribute) { return "(Integer) org.apache.jasper.runtime.JspRuntimeLibrary.coerce(" + s + ", Integer.class)"; } else { if (s == null || s.length() == 0) { return "new Integer(0)"; } else { return "new Integer(" + Integer.valueOf(s).toString() + ")"; } } }	public static String coerceToLong(String s, boolean isNamedAttribute) { if (isNamedAttribute) { return "(Long) org.apache.jasper.runtime.JspRuntimeLibrary.coerce(" + s + ", Long.class)"; } else { if (s == null || s.length() == 0) { return "new Long(0)"; } else { return "new Long(" + Long.valueOf(s).toString() + "l)"; } } }	public static String coerceToShort(String s, boolean isNamedAttribute) { if (isNamedAttribute) { return "(Short) org.apache.jasper.runtime.JspRuntimeLibrary.coerce(" + s + ", Short.class)"; } else { if (s == null || s.length() == 0) { return "new Short((short) 0)"; } else { return "new Short(\"" + Short.valueOf(s).toString() + "\")"; } } }	static String interpreterCall(boolean isTagFile, String expression, Class<?> expectedType, String fnmapvar, boolean XmlEscape) { String jspCtxt = null; if (isTagFile) jspCtxt = "this.getJspContext()"; else jspCtxt = "_jspx_page_context"; String targetType = expectedType.getCanonicalName(); String primitiveConverterMethod = null; if (expectedType.isPrimitive()) { if (expectedType.equals(Boolean.TYPE)) { targetType = Boolean.class.getName(); primitiveConverterMethod = "booleanValue"; } else if (expectedType.equals(Byte.TYPE)) { targetType = Byte.class.getName(); primitiveConverterMethod = "byteValue"; } else if (expectedType.equals(Character.TYPE)) { targetType = Character.class.getName(); primitiveConverterMethod = "charValue"; } else if (expectedType.equals(Short.TYPE)) { targetType = Short.class.getName(); primitiveConverterMethod = "shortValue"; } else if (expectedType.equals(Integer.TYPE)) { targetType = Integer.class.getName(); primitiveConverterMethod = "intValue"; } else if (expectedType.equals(Long.TYPE)) { targetType = Long.class.getName(); primitiveConverterMethod = "longValue"; } else if (expectedType.equals(Float.TYPE)) { targetType = Float.class.getName(); primitiveConverterMethod = "floatValue"; } else if (expectedType.equals(Double.TYPE)) { targetType = Double.class.getName(); primitiveConverterMethod = "doubleValue"; } } if (primitiveConverterMethod != null) { XmlEscape = false; } /* * Build up the base call to the interpreter. */ // XXX - We use a proprietary call to the interpreter for now // as the current standard machinery is inefficient and requires // lots of wrappers and adapters. This should all clear up once // the EL interpreter moves out of JSTL and into its own project. // In the future, this should be replaced by code that calls // ExpressionEvaluator.parseExpression() and then cache the resulting // expression objects. The interpreterCall would simply select // one of the pre-cached expressions and evaluate it. // Note that PageContextImpl implements VariableResolver and // the generated Servlet/SimpleTag implements FunctionMapper, so targetType = toJavaSourceType(targetType); StringBuilder call = new StringBuilder("(" + targetType + ") " + "org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate" + "(" + Generator.quote(expression) + ", " + targetType + ".class, " + "(PageContext)" + jspCtxt + ", " + fnmapvar + ", " + XmlEscape + ")"); if (primitiveConverterMethod != null) { call.insert(0, "("); call.append(")." + primitiveConverterMethod + "()"); } return call.toString(); }	public static String toJavaSourceTypeFromTld(String type) { if (type == null || "void".equals(type)) { return "Void.TYPE"; } return type + ".class"; }	public void generatePostamble() { ServletWriter out = this.classBuffer.getOut(); for (int i = 0; i < fragments.size(); i++) { Fragment fragment = fragments.get(i); fragment.getGenBuffer().adjustJavaLines(out.getJavaLine() - 1); out.printMultiLn(fragment.getGenBuffer().toString()); } out.printil("public void invoke( java.io.Writer writer )"); out.pushIndent(); out.printil("throws JspException"); out.popIndent(); out.printil("{"); out.pushIndent(); out.printil("JspWriter out = null;"); out.printil("if( writer != null ) {"); out.pushIndent(); out.printil("out = this.jspContext.pushBody(writer);"); out.popIndent(); out.printil("} else {"); out.pushIndent(); out.printil("out = this.jspContext.getOut();"); out.popIndent(); out.printil("}"); out.printil("try {"); out.pushIndent(); out.printil("this.jspContext.getELContext().putContext(JspContext.class,this.jspContext);"); out.printil("switch( this.discriminator ) {"); out.pushIndent(); for (int i = 0; i < fragments.size(); i++) { out.printil("case " + i + ":"); out.pushIndent(); out.printil("invoke" + i + "( out );"); out.printil("break;"); out.popIndent(); } out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); out.printil("catch( Throwable e ) {"); out.pushIndent(); out.printil("if (e instanceof SkipPageException)"); out.printil(" throw (SkipPageException) e;"); out.printil("throw new JspException( e );"); out.popIndent(); out.printil("}"); out.printil("finally {"); out.pushIndent(); out.printil("if( writer != null ) {"); out.pushIndent(); out.printil("this.jspContext.popBody();"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); out.popIndent(); }	public void generatePreamble() { ServletWriter out = this.classBuffer.getOut(); out.println(); out.pushIndent(); // Note: cannot be static, as we need to reference things like out.printil("private class " + className); out.printil(" extends " + "org.apache.jasper.runtime.JspFragmentHelper"); out.printil("{"); out.pushIndent(); out.printil("private javax.servlet.jsp.tagext.JspTag _jspx_parent;"); out.printil("private int[] _jspx_push_body_count;"); out.println(); out.printil("public " + className + "( int discriminator, JspContext jspContext, " + "javax.servlet.jsp.tagext.JspTag _jspx_parent, " + "int[] _jspx_push_body_count ) {"); out.pushIndent(); out.printil("super( discriminator, jspContext, _jspx_parent );"); out.printil("this._jspx_parent = _jspx_parent;"); out.printil("this._jspx_push_body_count = _jspx_push_body_count;"); out.popIndent(); out.printil("}"); }	public void generateSetDynamicAttribute() { out.printil("public void setDynamicAttribute(String uri, String localName, Object value) throws JspException {"); out.pushIndent(); out.printil("if (uri == null)"); out.pushIndent(); out.printil("_jspx_dynamic_attrs.put(localName, value);"); out.popIndent(); out.popIndent(); out.printil("}"); }	private void generateXmlProlog(Node.Nodes page) { String omitXmlDecl = pageInfo.getOmitXmlDecl(); if ((omitXmlDecl != null && !JspUtil.booleanValue(omitXmlDecl)) || (omitXmlDecl == null && page.getRoot().isXmlSyntax() && !pageInfo.hasJspRoot() && !ctxt.isTagFile())) { String cType = pageInfo.getContentType(); String charSet = cType.substring(cType.indexOf("charset=") + 8); out.printil("out.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"" + charSet + "\\\"?>\\n\");"); } String doctypeName = pageInfo.getDoctypeName(); if (doctypeName != null) { String doctypePublic = pageInfo.getDoctypePublic(); String doctypeSystem = pageInfo.getDoctypeSystem(); out.printin("out.write(\"<!DOCTYPE "); out.print(doctypeName); if (doctypePublic == null) { out.print(" SYSTEM \\\""); } else { out.print(" PUBLIC \\\""); out.print(doctypePublic); out.print("\\\" \\\""); } out.print(doctypeSystem); out.println("\\\">\\n\");"); } }	@Override public void visit(Node.DoBodyAction n) throws JasperException { n.setBeginJavaLine(out.getJavaLine()); // Copy virtual page scope of tag file to page scope of invoking out.printil("((org.apache.jasper.runtime.JspContextWrapper) this.jspContext).syncBeforeInvoke();"); String varReaderAttr = n.getTextAttribute("varReader"); String varAttr = n.getTextAttribute("var"); if (varReaderAttr != null || varAttr != null) { out.printil("_jspx_sout = new java.io.StringWriter();"); } else { out.printil("_jspx_sout = null;"); } out.printil("if (getJspBody() != null)"); out.pushIndent(); out.printil("getJspBody().invoke(_jspx_sout);"); out.popIndent(); if (varReaderAttr != null || varAttr != null) { String scopeName = n.getTextAttribute("scope"); out.printin("_jspx_page_context.setAttribute("); if (varReaderAttr != null) { out.print(quote(varReaderAttr)); out.print(", new java.io.StringReader(_jspx_sout.toString())"); } else { out.print(quote(varAttr)); out.print(", _jspx_sout.toString()"); } if (scopeName != null) { out.print(", "); out.print(getScopeConstant(scopeName)); } out.println(");"); } out.printil("jspContext.getELContext().putContext(JspContext.class,getJspContext());"); n.setEndJavaLine(out.getJavaLine()); }	@Override public void visit(Node.ForwardAction n) throws JasperException { Node.JspAttribute page = n.getPage(); n.setBeginJavaLine(out.getJavaLine()); out.printil("if (true) {"); out.pushIndent(); String pageParam; if (page.isNamedAttribute()) { // If the page for jsp:forward was specified via // jsp:attribute, first generate code to evaluate pageParam = generateNamedAttributeValue(page.getNamedAttributeNode()); } else { pageParam = attributeValue(page, false, String.class); } // If any of the params have their values specified by Node jspBody = findJspBody(n); if (jspBody != null) { prepareParams(jspBody); } else { prepareParams(n); } out.printin("_jspx_page_context.forward("); out.print(pageParam); printParams(n, pageParam, page.isLiteral()); out.println(");"); if (isTagFile || isFragment) { out.printil("throw new SkipPageException();"); } else { out.printil((methodNesting > 0) ? "return true;" : "return;"); } out.popIndent(); out.printil("}"); n.setEndJavaLine(out.getJavaLine()); // XXX Not sure if we can eliminate dead codes after this. }	@Override public void visit(Node.InvokeAction n) throws JasperException { n.setBeginJavaLine(out.getJavaLine()); // Copy virtual page scope of tag file to page scope of invoking out.printil("((org.apache.jasper.runtime.JspContextWrapper) this.jspContext).syncBeforeInvoke();"); String varReaderAttr = n.getTextAttribute("varReader"); String varAttr = n.getTextAttribute("var"); if (varReaderAttr != null || varAttr != null) { out.printil("_jspx_sout = new java.io.StringWriter();"); } else { out.printil("_jspx_sout = null;"); } out.printin("if ("); out.print(toGetterMethod(n.getTextAttribute("fragment"))); out.println(" != null) {"); out.pushIndent(); out.printin(toGetterMethod(n.getTextAttribute("fragment"))); out.println(".invoke(_jspx_sout);"); out.popIndent(); out.printil("}"); if (varReaderAttr != null || varAttr != null) { String scopeName = n.getTextAttribute("scope"); out.printin("_jspx_page_context.setAttribute("); if (varReaderAttr != null) { out.print(quote(varReaderAttr)); out.print(", new java.io.StringReader(_jspx_sout.toString())"); } else { out.print(quote(varAttr)); out.print(", _jspx_sout.toString()"); } if (scopeName != null) { out.print(", "); out.print(getScopeConstant(scopeName)); } out.println(");"); } out.printil("jspContext.getELContext().putContext(JspContext.class,getJspContext());"); n.setEndJavaLine(out.getJavaLine()); }	@Override public void visit(Node.JspElement n) throws JasperException { n.setBeginJavaLine(out.getJavaLine()); // Compute attribute value string for XML-style and named Hashtable<String, String> map = new Hashtable<String, String>(); Node.JspAttribute[] attrs = n.getJspAttributes(); for (int i = 0; attrs != null && i < attrs.length; i++) { String value = null; String nvp = null; if (attrs[i].isNamedAttribute()) { NamedAttribute attr = attrs[i].getNamedAttributeNode(); Node.JspAttribute omitAttr = attr.getOmit(); String omit; if (omitAttr == null) { omit = "false"; } else { omit = attributeValue(omitAttr, false, boolean.class); if ("true".equals(omit)) { continue; } } value = generateNamedAttributeValue(attrs[i].getNamedAttributeNode()); if ("false".equals(omit)) { nvp = " + \" " + attrs[i].getName() + "=\\\"\" + " + value + " + \"\\\"\""; } else { nvp = " + (Boolean.valueOf(" + omit + ")?\"\":\" " + attrs[i].getName() + "=\\\"\" + " + value + " + \"\\\"\")"; } } else { value = attributeValue(attrs[i], false, Object.class); nvp = " + \" " + attrs[i].getName() + "=\\\"\" + " + value + " + \"\\\"\""; } map.put(attrs[i].getName(), nvp); } // Write begin tag, using XML-style 'name' attribute as the String elemName = attributeValue(n.getNameAttribute(), false, String.class); out.printin("out.write(\"<\""); out.print(" + " + elemName); Enumeration<String> enumeration = map.keys(); while (enumeration.hasMoreElements()) { String attrName = enumeration.nextElement(); out.print(map.get(attrName)); } // Does the <jsp:element> have nested tags other than boolean hasBody = false; Node.Nodes subelements = n.getBody(); if (subelements != null) { for (int i = 0; i < subelements.size(); i++) { Node subelem = subelements.getNode(i); if (!(subelem instanceof Node.NamedAttribute)) { hasBody = true; break; } } } if (hasBody) { out.println(" + \">\");"); n.setEndJavaLine(out.getJavaLine()); visitBody(n); out.printin("out.write(\"</\""); out.print(" + " + elemName); out.println(" + \">\");"); } else { out.println(" + \"/>\");"); n.setEndJavaLine(out.getJavaLine()); } }	private void generateDeclarations(Node.Nodes page) throws JasperException { class DeclarationVisitor extends Node.Visitor { private boolean getServletInfoGenerated = false; /* * Generates getServletInfo() method that returns the value of the * page directive's 'info' attribute, if present. * * The Validator has already ensured that if the translation unit * contains more than one page directive with an 'info' attribute, * their values match. */ @Override public void visit(Node.PageDirective n) throws JasperException { if (getServletInfoGenerated) { return; } String info = n.getAttributeValue("info"); if (info == null) return; getServletInfoGenerated = true; out.printil("public String getServletInfo() {"); out.pushIndent(); out.printin("return "); out.print(quote(info)); out.println(";"); out.popIndent(); out.printil("}"); out.println(); } @Override } }	@Override public void visit(Node.UseBean n) throws JasperException { String name = n.getTextAttribute("id"); String scope = n.getTextAttribute("scope"); String klass = n.getTextAttribute("class"); String type = n.getTextAttribute("type"); Node.JspAttribute beanName = n.getBeanName(); boolean generateNew = false; String canonicalName = null; if (klass != null) { try { Class<?> bean = ctxt.getClassLoader().loadClass(klass); if (klass.indexOf('$') >= 0) { canonicalName = bean.getCanonicalName(); } else { canonicalName = klass; } int modifiers = bean.getModifiers(); if (!Modifier.isPublic(modifiers) || Modifier.isInterface(modifiers) || Modifier.isAbstract(modifiers)) { throw new Exception("Invalid bean class modifier"); } bean.getConstructor(new Class[] {}); // At compile time, we have determined that the bean class // exists, with a public zero constructor, new() can be generateNew = true; } catch (Exception e) { if (ctxt.getOptions().getErrorOnUseBeanInvalidClassAttribute()) { err.jspError(n, "jsp.error.invalid.bean", klass); } if (canonicalName == null) { // Doing our best here to get a canonical name canonicalName = klass.replace('$', '.'); } } if (type == null) { type = canonicalName; } } // JSP.5.1, Sematics, para 1 - lock not required for request or // page scope String scopename = "PageContext.PAGE_SCOPE"; String lock = null; if ("request".equals(scope)) { scopename = "PageContext.REQUEST_SCOPE"; } else if ("session".equals(scope)) { scopename = "PageContext.SESSION_SCOPE"; lock = "session"; } else if ("application".equals(scope)) { scopename = "PageContext.APPLICATION_SCOPE"; lock = "application"; } n.setBeginJavaLine(out.getJavaLine()); out.printin(type); out.print(' '); out.print(name); out.println(" = null;"); if (lock != null) { out.printin("synchronized ("); out.print(lock); out.println(") {"); out.pushIndent(); } out.printin(name); out.print(" = ("); out.print(type); out.print(") _jspx_page_context.getAttribute("); out.print(quote(name)); out.print(", "); out.print(scopename); out.println(");"); // Create bean out.printin("if ("); out.print(name); out.println(" == null){"); out.pushIndent(); if (klass == null && beanName == null) { out.printin("throw new java.lang.InstantiationException(\"bean "); out.print(name); out.println(" not found within scope\");"); } else { if (!generateNew) { String binaryName; if (beanName != null) { if (beanName.isNamedAttribute()) { // If the value for beanName was specified via // jsp:attribute, first generate code to evaluate binaryName = generateNamedAttributeValue(beanName.getNamedAttributeNode()); } else { binaryName = attributeValue(beanName, false, String.class); } } else { binaryName = quote(klass); } out.printil("try {"); out.pushIndent(); out.printin(name); out.print(" = ("); out.print(type); out.print(") java.beans.Beans.instantiate("); out.print("this.getClass().getClassLoader(), "); out.print(binaryName); out.println(");"); out.popIndent(); out.printil("} catch (ClassNotFoundException exc) {"); out.pushIndent(); out.printil("throw new InstantiationException(exc.getMessage());"); out.popIndent(); out.printil("} catch (Exception exc) {"); out.pushIndent(); out.printin("throw new ServletException("); out.print("\"Cannot create bean of class \" + "); out.print(binaryName); out.println(", exc);"); out.popIndent(); out.printil("}"); } else { // Implies klass is not null out.printin(name); out.print(" = new "); out.print(canonicalName); out.println("();"); } out.printin("_jspx_page_context.setAttribute("); out.print(quote(name)); out.print(", "); out.print(name); out.print(", "); out.print(scopename); out.println(");"); visitBody(n); } out.popIndent(); out.printil("}"); if (lock != null) { out.popIndent(); out.printil("}"); } n.setEndJavaLine(out.getJavaLine()); }
protected void init(PoolConfiguration properties) throws SQLException { poolProperties = properties; busy = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(), false); if (properties.isFairQueue()) { idle = new FairBlockingQueue<PooledConnection>(); //idle = new MultiLockFairBlockingQueue<PooledConnection>(); } else { idle = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(), properties.isFairQueue()); } if (properties.isPoolSweeperEnabled()) { poolCleaner = new PoolCleaner("[Pool-Cleaner]:" + properties.getName(), this, properties.getTimeBetweenEvictionRunsMillis()); poolCleaner.start(); } if (properties.getMaxActive() < properties.getInitialSize()) { log.warn("initialSize is larger than maxActive, setting initialSize to: " + properties.getMaxActive()); properties.setInitialSize(properties.getMaxActive()); } if (properties.getMinIdle() > properties.getMaxActive()) { log.warn("minIdle is larger than maxActive, setting minIdle to: " + properties.getMaxActive()); properties.setMinIdle(properties.getMaxActive()); } if (properties.getMaxIdle() > properties.getMaxActive()) { log.warn("maxIdle is larger than maxActive, setting maxIdle to: " + properties.getMaxActive()); properties.setMaxIdle(properties.getMaxActive()); } if (properties.getMaxIdle() < properties.getMinIdle()) { log.warn("maxIdle is smaller than minIdle, setting maxIdle to: " + properties.getMinIdle()); properties.setMaxIdle(properties.getMinIdle()); } if (this.getPoolProperties().isJmxEnabled()) createMBean(); //Parse and create an initial set of interceptors. Letting them know the pool has started. PoolProperties.InterceptorDefinition[] proxies = getPoolProperties().getJdbcInterceptorsAsArray(); for (int i = 0; i < proxies.length; i++) { try { if (log.isDebugEnabled()) { log.debug("Creating interceptor instance of class:" + proxies[i].getInterceptorClass()); } proxies[i].getInterceptorClass().newInstance().poolStarted(this); } catch (Exception x) { log.error("Unable to inform interceptor of pool start.", x); if (jmxPool != null) jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_INIT, getStackTrace(x)); close(true); SQLException ex = new SQLException(); ex.initCause(x); throw ex; } } PooledConnection[] initialPool = new PooledConnection[poolProperties.getInitialSize()]; try { for (int i = 0; i < initialPool.length; i++) { initialPool[i] = this.borrowConnection(0, null, null); } //for } catch (SQLException x) { if (jmxPool != null) jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_INIT, getStackTrace(x)); close(true); throw x; } finally { for (int i = 0; i < initialPool.length; i++) { if (initialPool[i] != null) { try { this.returnConnection(initialPool[i]); } catch (Exception x) { /*NOOP*/ } } //end if } //for } closed = false; }
@Override protected Object createDecorator(Object proxy, Method method, Object[] args, Object statement, Constructor<?> constructor, String sql) throws InstantiationException, IllegalAccessException, InvocationTargetException { boolean process = process(this.types, method, false); if (process) { Object result = null; CachedStatement statementProxy = new CachedStatement((Statement) statement, sql); result = constructor.newInstance(new Object[] { statementProxy }); statementProxy.setActualProxy(result); statementProxy.setConnection(proxy); statementProxy.setConstructor(constructor); return result; } else { return super.createDecorator(proxy, method, args, statement, constructor, sql); } }	public AtomicInteger getCacheSize() { return cacheSize; }	public static MBeanNotificationInfo[] getDefaultNotificationInfo() { String[] types = new String[] { NOTIFY_INIT, NOTIFY_CONNECT, NOTIFY_ABANDON, SLOW_QUERY_NOTIFICATION, FAILED_QUERY_NOTIFICATION, SUSPECT_ABANDONED_NOTIFICATION }; String name = Notification.class.getName(); String description = "A connection pool error condition was met."; MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description); return new MBeanNotificationInfo[] { info }; }	public void poolStarted(ConnectionPool pool) { cacheSizeMap.putIfAbsent(pool, new AtomicInteger(0)); super.poolStarted(pool); }	public void setProperties(Map<String, InterceptorProperty> properties) { super.setProperties(properties); InterceptorProperty p = properties.get("prepared"); if (p != null) cachePrepared = p.getValueAsBoolean(cachePrepared); p = properties.get("callable"); if (p != null) cacheCallable = p.getValueAsBoolean(cacheCallable); p = properties.get("max"); if (p != null) maxCacheSize = p.getValueAsInt(maxCacheSize); if (cachePrepared && cacheCallable) { this.types = ALL_TYPES; } else if (cachePrepared) { this.types = PREPARED_TYPE; } else if (cacheCallable) { this.types = CALLABLE_TYPE; } else { this.types = NO_TYPE; } }
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("<html>"); out.println("<body bgcolor=\"white\">"); out.println("<head>"); String title = RB.getString("cookies.title"); out.println("<title>" + title + "</title>"); out.println("</head>"); out.println("<body>"); // relative links // XXX // making these absolute till we work out the out.println("<a href=\"../cookies.html\">"); out.println("<img src=\"../images/code.gif\" height=24 " + "width=24 align=right border=0 alt=\"view code\"></a>"); out.println("<a href=\"../index.html\">"); out.println("<img src=\"../images/return.gif\" height=24 " + "width=24 align=right border=0 alt=\"return\"></a>"); out.println("<h3>" + title + "</h3>"); Cookie[] cookies = request.getCookies(); if ((cookies != null) && (cookies.length > 0)) { out.println(RB.getString("cookies.cookies") + "<br>"); for (int i = 0; i < cookies.length; i++) { Cookie cookie = cookies[i]; out.print("Cookie Name: " + HTMLFilter.filter(cookie.getName()) + "<br>"); out.println(" Cookie Value: " + HTMLFilter.filter(cookie.getValue()) + "<br><br>"); } } else { out.println(RB.getString("cookies.no-cookies")); } String cookieName = request.getParameter("cookiename"); String cookieValue = request.getParameter("cookievalue"); if (cookieName != null && cookieValue != null) { Cookie cookie = new Cookie(cookieName, cookieValue); response.addCookie(cookie); out.println("<P>"); out.println(RB.getString("cookies.set") + "<br>"); out.print(RB.getString("cookies.name") + " " + HTMLFilter.filter(cookieName) + "<br>"); out.print(RB.getString("cookies.value") + " " + HTMLFilter.filter(cookieValue)); } out.println("<P>"); out.println(RB.getString("cookies.make-cookie") + "<br>"); out.print("<form action=\""); out.println("CookieExample\" method=POST>"); out.print(RB.getString("cookies.name") + " "); out.println("<input type=text length=20 name=cookiename><br>"); out.print(RB.getString("cookies.value") + " "); out.println("<input type=text length=20 name=cookievalue><br>"); out.println("<input type=submit></form>"); out.println("</body>"); out.println("</html>"); }
protected void closeRedirector() { try { if (redirectOutput) { redirector.complete(); } } catch (IOException ioe) { log("Error closing redirector: " + ioe.getMessage(), Project.MSG_ERR); } redirectOutStream = null; redirectOutPrintStream = null; redirectErrStream = null; redirectErrPrintStream = null; }
public Context getInitialContext(Hashtable<?, ?> environment) throws NamingException { if (ContextBindings.isThreadBound() || (ContextBindings.isClassLoaderBound())) { return new SelectorContext((Hashtable<String, Object>) environment, true); } if (initialContext == null) { synchronized (getClass()) { if (initialContext == null) { initialContext = new NamingContext((Hashtable<String, Object>) environment, MAIN); } } } return initialContext; }	public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws NamingException { if ((ContextBindings.isThreadBound()) || (ContextBindings.isClassLoaderBound())) { return new SelectorContext((Hashtable<String, Object>) environment); } return null; }
protected void createMBean() { try { jmxPool = new org.apache.tomcat.jdbc.pool.jmx.ConnectionPool(this); } catch (Exception x) { log.warn("Unable to start JMX integration for connection pool. Instance[" + getName() + "] can't be monitored.", x); } }	public Connection get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { PooledConnection pc = pcFuture.get(timeout, unit); if (pc != null) { if (result != null) return result; if (configured.compareAndSet(false, true)) { try { pc = borrowConnection(System.currentTimeMillis(), pc, null, null); result = ConnectionPool.this.setupConnection(pc); } catch (SQLException x) { cause = x; } finally { latch.countDown(); } } else { //if we reach here, another thread is configuring the actual connection latch.await(timeout, unit); } if (result == null) throw new ExecutionException(cause); return result; } else { return null; } }	protected void createMBean() { try { jmxPool = new org.apache.tomcat.jdbc.pool.jmx.ConnectionPool(this); } catch (Exception x) { log.warn("Unable to start JMX integration for connection pool. Instance[" + getName() + "] can't be monitored.", x); } }	public Future<Connection> getConnectionAsync() throws SQLException { if (idle instanceof FairBlockingQueue<?>) { Future<PooledConnection> pcf = ((FairBlockingQueue<PooledConnection>) idle).pollAsync(); return new ConnectionFuture(pcf); } else if (idle instanceof MultiLockFairBlockingQueue<?>) { Future<PooledConnection> pcf = ((MultiLockFairBlockingQueue<PooledConnection>) idle).pollAsync(); return new ConnectionFuture(pcf); } else { throw new SQLException("Connection pool is misconfigured, doesn't support async retrieval. Set the 'fair' property to 'true'"); } }	public boolean cancel(boolean mayInterruptIfRunning) { if ((!cancelled.get()) && cancelled.compareAndSet(false, true)) { ConnectionPool.this.cancellator.execute(this); } return true; }	public boolean isCancelled() { return pcFuture.isCancelled() || cancelled.get(); }	public boolean isDone() { return pcFuture.isDone(); }

protected boolean cacheUnload(String name) { if (cache == null) return false; synchronized (cache) { return cache.unload(name); } }
@Override public void actionInternal(ActionCode actionCode, Object param) { long socketRef = socket.getSocket().longValue(); if (actionCode == ActionCode.CLOSE) { // Close // End the processing of the current request, and stop any further comet = false; try { outputBuffer.endRequest(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.REQ_HOST_ADDR_ATTRIBUTE) { if (remoteAddr == null && (socketRef != 0)) { try { long sa = Address.get(Socket.APR_REMOTE, socketRef); remoteAddr = Address.getip(sa); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.remoteAddr().setString(remoteAddr); } else if (actionCode == ActionCode.REQ_LOCAL_NAME_ATTRIBUTE) { if (localName == null && (socketRef != 0)) { try { long sa = Address.get(Socket.APR_LOCAL, socketRef); localName = Address.getnameinfo(sa, 0); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.localName().setString(localName); } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) { if (remoteHost == null && (socketRef != 0)) { try { long sa = Address.get(Socket.APR_REMOTE, socketRef); remoteHost = Address.getnameinfo(sa, 0); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.remoteHost().setString(remoteHost); } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) { if (localAddr == null && (socketRef != 0)) { try { long sa = Address.get(Socket.APR_LOCAL, socketRef); localAddr = Address.getip(sa); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.localAddr().setString(localAddr); } else if (actionCode == ActionCode.REQ_REMOTEPORT_ATTRIBUTE) { if (remotePort == -1 && (socketRef != 0)) { try { long sa = Address.get(Socket.APR_REMOTE, socketRef); Sockaddr addr = Address.getInfo(sa); remotePort = addr.port; } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.setRemotePort(remotePort); } else if (actionCode == ActionCode.REQ_LOCALPORT_ATTRIBUTE) { if (localPort == -1 && (socketRef != 0)) { try { long sa = Address.get(Socket.APR_LOCAL, socketRef); Sockaddr addr = Address.getInfo(sa); localPort = addr.port; } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.setLocalPort(localPort); } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE) { if (ssl && (socketRef != 0)) { try { Object sslO = SSLSocket.getInfoS(socketRef, SSL.SSL_INFO_CIPHER); if (sslO != null) { request.setAttribute(SSLSupport.CIPHER_SUITE_KEY, sslO); } // Get client certificate and the certificate chain if present int certLength = SSLSocket.getInfoI(socketRef, SSL.SSL_INFO_CLIENT_CERT_CHAIN); byte[] clientCert = SSLSocket.getInfoB(socketRef, SSL.SSL_INFO_CLIENT_CERT); X509Certificate[] certs = null; if (clientCert != null && certLength > -1) { certs = new X509Certificate[certLength + 1]; CertificateFactory cf = CertificateFactory.getInstance("X.509"); certs[0] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(clientCert)); for (int i = 0; i < certLength; i++) { byte[] data = SSLSocket.getInfoB(socketRef, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i); certs[i + 1] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data)); } } if (certs != null) { request.setAttribute(SSLSupport.CERTIFICATE_KEY, certs); } sslO = Integer.valueOf(SSLSocket.getInfoI(socketRef, SSL.SSL_INFO_CIPHER_USEKEYSIZE)); request.setAttribute(SSLSupport.KEY_SIZE_KEY, sslO); sslO = SSLSocket.getInfoS(socketRef, SSL.SSL_INFO_SESSION_ID); if (sslO != null) { request.setAttribute(SSLSupport.SESSION_ID_KEY, sslO); } //TODO provide a hook to enable the SSL session to be // invalidated. Set AprEndpoint.SESSION_MGR req attr } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } } else if (actionCode == ActionCode.REQ_SSL_CERTIFICATE) { if (ssl && (socketRef != 0)) { // Consume and buffer the request body, so that it does not InputFilter[] inputFilters = inputBuffer.getFilters(); ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize); inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]); try { SSLSocket.setVerify(socketRef, SSL.SSL_CVERIFY_REQUIRE, endpoint.getSSLVerifyDepth()); if (SSLSocket.renegotiate(socketRef) == 0) { // Don't look for certs unless we know renegotiation worked. // Get client certificate and the certificate chain if present int certLength = SSLSocket.getInfoI(socketRef, SSL.SSL_INFO_CLIENT_CERT_CHAIN); byte[] clientCert = SSLSocket.getInfoB(socketRef, SSL.SSL_INFO_CLIENT_CERT); X509Certificate[] certs = null; if (clientCert != null && certLength > -1) { certs = new X509Certificate[certLength + 1]; CertificateFactory cf = CertificateFactory.getInstance("X.509"); certs[0] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(clientCert)); for (int i = 0; i < certLength; i++) { byte[] data = SSLSocket.getInfoB(socketRef, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i); certs[i + 1] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data)); } } if (certs != null) { request.setAttribute(SSLSupport.CERTIFICATE_KEY, certs); } } } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } } else if (actionCode == ActionCode.AVAILABLE) { request.setAvailable(inputBuffer.available()); } else if (actionCode == ActionCode.COMET_BEGIN) { comet = true; } else if (actionCode == ActionCode.COMET_END) { comet = false; } else if (actionCode == ActionCode.COMET_CLOSE) { endpoint.processSocketAsync(this.socket, SocketStatus.OPEN); } else if (actionCode == ActionCode.COMET_SETTIMEOUT) { //no op } else if (actionCode == ActionCode.ASYNC_COMPLETE) { if (asyncStateMachine.asyncComplete()) { endpoint.processSocketAsync(this.socket, SocketStatus.OPEN); } } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) { if (param == null) return; long timeout = ((Long) param).longValue(); socket.setTimeout(timeout); } else if (actionCode == ActionCode.ASYNC_DISPATCH) { if (asyncStateMachine.asyncDispatch()) { endpoint.processSocketAsync(this.socket, SocketStatus.OPEN); } } }
protected void sessionExpired(String id) { counterSend_EVT_SESSION_EXPIRED++; SessionMessage msg = new SessionMessageImpl(getName(), SessionMessage.EVT_SESSION_EXPIRED, null, id, id + "-EXPIRED-MSG"); if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.expire", getName(), id)); send(msg); }	protected byte[] serializeSessionId(String sessionId) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeUTF(sessionId); oos.flush(); oos.close(); return bos.toByteArray(); }
public void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { if (matchesOne(request.getRemoteAddr(), internalProxies)) { String remoteIp = null; LinkedList<String> proxiesHeaderValue = new LinkedList<String>(); String[] remoteIpHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIpHeader)); int idx; for (idx = remoteIpHeaderValue.length - 1; idx >= 0; idx--) { String currentRemoteIp = remoteIpHeaderValue[idx]; remoteIp = currentRemoteIp; if (matchesOne(currentRemoteIp, internalProxies)) { // do nothing, internalProxies IPs are not appended to the } else if (matchesOne(currentRemoteIp, trustedProxies)) { proxiesHeaderValue.addFirst(currentRemoteIp); } else { idx--; break; } } LinkedList<String> newRemoteIpHeaderValue = new LinkedList<String>(); for (; idx >= 0; idx--) { String currentRemoteIp = remoteIpHeaderValue[idx]; newRemoteIpHeaderValue.addFirst(currentRemoteIp); } XForwardedRequest xRequest = new XForwardedRequest(request); if (remoteIp != null) { xRequest.setRemoteAddr(remoteIp); xRequest.setRemoteHost(remoteIp); if (proxiesHeaderValue.size() == 0) { xRequest.removeHeader(proxiesHeader); } else { String commaDelimitedListOfProxies = listToCommaDelimitedString(proxiesHeaderValue); xRequest.setHeader(proxiesHeader, commaDelimitedListOfProxies); } if (newRemoteIpHeaderValue.size() == 0) { xRequest.removeHeader(remoteIpHeader); } else { String commaDelimitedRemoteIpHeaderValue = listToCommaDelimitedString(newRemoteIpHeaderValue); xRequest.setHeader(remoteIpHeader, commaDelimitedRemoteIpHeaderValue); } } if (protocolHeader != null) { String protocolHeaderValue = request.getHeader(protocolHeader); if (protocolHeaderValue == null) { // don't modify the secure,scheme and serverPort attributes of the request } else if (protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) { xRequest.setSecure(true); xRequest.setScheme("https"); xRequest.setServerPort(httpsServerPort); } else { xRequest.setSecure(false); xRequest.setScheme("http"); xRequest.setServerPort(httpServerPort); } } if (log.isDebugEnabled()) { log.debug("Incoming request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "', originalRemoteHost='" + request.getRemoteHost() + "', originalSecure='" + request.isSecure() + "', originalScheme='" + request.getScheme() + "', original[" + remoteIpHeader + "]='" + request.getHeader(remoteIpHeader) + ", original[" + protocolHeader + "]='" + (protocolHeader == null ? null : request.getHeader(protocolHeader)) + "' will be seen as newRemoteAddr='" + xRequest.getRemoteAddr() + "', newRemoteHost='" + xRequest.getRemoteHost() + "', newScheme='" + xRequest.getScheme() + "', newSecure='" + xRequest.isSecure() + "', new[" + remoteIpHeader + "]='" + xRequest.getHeader(remoteIpHeader) + ", new[" + proxiesHeader + "]='" + xRequest.getHeader(proxiesHeader) + "'"); } chain.doFilter(xRequest, response); } else { if (log.isDebugEnabled()) { log.debug("Skip RemoteIpFilter for request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "'"); } chain.doFilter(request, response); } }	@Override public void invoke(Request request, Response response) throws IOException, ServletException { final String originalRemoteAddr = request.getRemoteAddr(); final String originalRemoteHost = request.getRemoteHost(); final String originalScheme = request.getScheme(); final boolean originalSecure = request.isSecure(); final int originalServerPort = request.getServerPort(); if (matchesOne(originalRemoteAddr, internalProxies)) { String remoteIp = null; LinkedList<String> proxiesHeaderValue = new LinkedList<String>(); String[] remoteIpHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIpHeader)); int idx; for (idx = remoteIpHeaderValue.length - 1; idx >= 0; idx--) { String currentRemoteIp = remoteIpHeaderValue[idx]; remoteIp = currentRemoteIp; if (matchesOne(currentRemoteIp, internalProxies)) { // do nothing, internalProxies IPs are not appended to the } else if (matchesOne(currentRemoteIp, trustedProxies)) { proxiesHeaderValue.addFirst(currentRemoteIp); } else { idx--; break; } } LinkedList<String> newRemoteIpHeaderValue = new LinkedList<String>(); for (; idx >= 0; idx--) { String currentRemoteIp = remoteIpHeaderValue[idx]; newRemoteIpHeaderValue.addFirst(currentRemoteIp); } if (remoteIp != null) { request.setRemoteAddr(remoteIp); request.setRemoteHost(remoteIp); if (proxiesHeaderValue.size() == 0) { request.getCoyoteRequest().getMimeHeaders().removeHeader(proxiesHeader); } else { String commaDelimitedListOfProxies = listToCommaDelimitedString(proxiesHeaderValue); request.getCoyoteRequest().getMimeHeaders().setValue(proxiesHeader).setString(commaDelimitedListOfProxies); } if (newRemoteIpHeaderValue.size() == 0) { request.getCoyoteRequest().getMimeHeaders().removeHeader(remoteIpHeader); } else { String commaDelimitedRemoteIpHeaderValue = listToCommaDelimitedString(newRemoteIpHeaderValue); request.getCoyoteRequest().getMimeHeaders().setValue(remoteIpHeader).setString(commaDelimitedRemoteIpHeaderValue); } } if (protocolHeader != null) { String protocolHeaderValue = request.getHeader(protocolHeader); if (protocolHeaderValue == null) { // don't modify the secure,scheme and serverPort attributes // of the request } else if (protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) { request.setSecure(true); request.getCoyoteRequest().scheme().setString("https"); request.setServerPort(httpsServerPort); } else { request.setSecure(false); request.getCoyoteRequest().scheme().setString("http"); request.setServerPort(httpServerPort); } } if (log.isDebugEnabled()) { log.debug("Incoming request " + request.getRequestURI() + " with originalRemoteAddr '" + originalRemoteAddr + "', originalRemoteHost='" + originalRemoteHost + "', originalSecure='" + originalSecure + "', originalScheme='" + originalScheme + "' will be seen as newRemoteAddr='" + request.getRemoteAddr() + "', newRemoteHost='" + request.getRemoteHost() + "', newScheme='" + request.getScheme() + "', newSecure='" + request.isSecure() + "'"); } } else { if (log.isDebugEnabled()) { log.debug("Skip RemoteIpValve for request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "'"); } } try { getNext().invoke(request, response); } finally { request.setRemoteAddr(originalRemoteAddr); request.setRemoteHost(originalRemoteHost); request.setSecure(originalSecure); request.getCoyoteRequest().scheme().setString(originalScheme); request.setServerPort(originalServerPort); } }	public void setHeader(String name, String value) { getCoyoteRequest().getMimeHeaders().setValue(name).setString(value); }	public void testInvokeAllProxiesAreInternal() throws Exception { FilterDef filterDef = new FilterDef(); filterDef.addInitParameter("internalProxies", "192\\.168\\.0\\.10, 192\\.168\\.0\\.11"); filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3"); filterDef.addInitParameter("remoteIpHeader", "x-forwarded-for"); filterDef.addInitParameter("proxiesHeader", "x-forwarded-by"); MockHttpServletRequest request = new MockHttpServletRequest(); request.setRemoteAddr("192.168.0.10"); request.setRemoteHost("remote-host-original-value"); request.setHeader("x-forwarded-for", "140.211.11.130, 192.168.0.10, 192.168.0.11"); HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request); String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for"); assertNull("all proxies are internal, x-forwarded-for must be null", actualXForwardedFor); String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by"); assertNull("all proxies are internal, x-forwarded-by must be null", actualXForwardedBy); String actualRemoteAddr = actualRequest.getRemoteAddr(); assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr); String actualRemoteHost = actualRequest.getRemoteHost(); assertEquals("remoteHost", "140.211.11.130", actualRemoteHost); }	public void testInvokeAllProxiesAreTrustedAndRemoteAddrMatchRegexp() throws Exception { FilterDef filterDef = new FilterDef(); filterDef.addInitParameter("internalProxies", "127\\.0\\.0\\.1, 192\\.168\\..*, another-internal-proxy"); filterDef.addInitParameter("trustedProxies", "proxy1, proxy2, proxy3"); filterDef.addInitParameter("remoteIpHeader", "x-forwarded-for"); filterDef.addInitParameter("proxiesHeader", "x-forwarded-by"); MockHttpServletRequest request = new MockHttpServletRequest(); request.setRemoteAddr("192.168.0.10"); request.setRemoteHost("remote-host-original-value"); request.setHeader("x-forwarded-for", "140.211.11.130, proxy1, proxy2"); HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request); String actualXForwardedFor = actualRequest.getHeader("x-forwarded-for"); assertNull("all proxies are trusted, x-forwarded-for must be null", actualXForwardedFor); String actualXForwardedBy = actualRequest.getHeader("x-forwarded-by"); assertEquals("all proxies are trusted, they must appear in x-forwarded-by", "proxy1, proxy2", actualXForwardedBy); String actualRemoteAddr = actualRequest.getRemoteAddr(); assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr); String actualRemoteHost = actualRequest.getRemoteHost(); assertEquals("remoteHost", "140.211.11.130", actualRemoteHost); }	public void testInvokeAllProxiesAreTrustedAndRemoteAddrMatchRegexp() throws Exception { RemoteIpValve remoteIpValve = new RemoteIpValve(); remoteIpValve.setInternalProxies("127\\.0\\.0\\.1, 192\\.168\\..*, another-internal-proxy"); remoteIpValve.setTrustedProxies("proxy1, proxy2, proxy3"); remoteIpValve.setRemoteIpHeader("x-forwarded-for"); remoteIpValve.setProxiesHeader("x-forwarded-by"); RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve(); remoteIpValve.setNext(remoteAddrAndHostTrackerValve); Request request = new Request(); request.setCoyoteRequest(new org.apache.coyote.Request()); request.setRemoteAddr("192.168.0.10"); request.setRemoteHost("remote-host-original-value"); request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-for").setString("140.211.11.130, proxy1, proxy2"); remoteIpValve.invoke(request, null); String actualXForwardedFor = request.getHeader("x-forwarded-for"); assertNull("all proxies are trusted, x-forwarded-for must be null", actualXForwardedFor); String actualXForwardedBy = request.getHeader("x-forwarded-by"); assertEquals("all proxies are trusted, they must appear in x-forwarded-by", "proxy1, proxy2", actualXForwardedBy); String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr(); assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr); String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost(); assertEquals("remoteHost", "140.211.11.130", actualRemoteHost); String actualPostInvokeRemoteAddr = request.getRemoteAddr(); assertEquals("postInvoke remoteAddr", "192.168.0.10", actualPostInvokeRemoteAddr); String actualPostInvokeRemoteHost = request.getRemoteHost(); assertEquals("postInvoke remoteAddr", "remote-host-original-value", actualPostInvokeRemoteHost); }
protected Log getLog() { return log; }
protected User getUserBySearch(DirContext context, String username, String[] attrIds) throws NamingException { if (username == null || userSearchFormat == null) return (null); String filter = userSearchFormat.format(new String[] { username }); SearchControls constraints = new SearchControls(); if (userSubtree) { constraints.setSearchScope(SearchControls.SUBTREE_SCOPE); } else { constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE); } if (attrIds == null) attrIds = new String[0]; constraints.setReturningAttributes(attrIds); NamingEnumeration<SearchResult> results = context.search(userBase, filter, constraints); try { if (results == null || !results.hasMore()) { return (null); } } catch (PartialResultException ex) { if (!adCompat) throw ex; else return (null); } SearchResult result = results.next(); try { if (results.hasMore()) { if (containerLog.isInfoEnabled()) containerLog.info("username " + username + " has multiple entries"); return (null); } } catch (PartialResultException ex) { if (!adCompat) throw ex; } String dn = getDistinguishedName(context, userBase, result); if (containerLog.isTraceEnabled()) containerLog.trace(" entry found for " + username + " with dn " + dn); Attributes attrs = result.getAttributes(); if (attrs == null) return null; String password = null; if (userPassword != null) password = getAttributeValue(userPassword, attrs); ArrayList<String> roles = null; if (userRoleName != null) roles = addAttributeValues(userRoleName, attrs, roles); return new User(username, dn, password, roles); }	public void setConnectionTimeout(String timeout) { this.connectionTimeout = timeout; }
public static final Number add(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return Long.valueOf(0); } final ELArithmetic delegate; if (BIGDECIMAL.matches(obj0, obj1)) delegate = BIGDECIMAL; }	static final Number mod(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return Long.valueOf(0); } final ELArithmetic delegate; if (BIGDECIMAL.matches(obj0, obj1)) delegate = BIGDECIMAL; }	static final Number multiply(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return Long.valueOf(0); } final ELArithmetic delegate; if (BIGDECIMAL.matches(obj0, obj1)) delegate = BIGDECIMAL; }	static final Number subtract(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return Long.valueOf(0); } final ELArithmetic delegate; if (BIGDECIMAL.matches(obj0, obj1)) delegate = BIGDECIMAL; }
private PooledConnection borrowConnection(int wait) throws SQLException { if (isClosed()) { throw new SQLException("Connection pool closed."); } //end if long now = System.currentTimeMillis(); PooledConnection con = idle.poll(); while (true) { if (con != null) { PooledConnection result = borrowConnection(now, con); if (result != null) return result; } if (size.get() < getPoolProperties().getMaxActive()) { if (size.addAndGet(1) > getPoolProperties().getMaxActive()) { size.decrementAndGet(); } else { return createConnection(now, con); } } //end if long maxWait = wait; if (wait == -1) { maxWait = (getPoolProperties().getMaxWait() <= 0) ? Long.MAX_VALUE : getPoolProperties().getMaxWait(); } long timetowait = Math.max(0, maxWait - (System.currentTimeMillis() - now)); waitcount.incrementAndGet(); try { con = idle.poll(timetowait, TimeUnit.MILLISECONDS); } catch (InterruptedException ex) { Thread.interrupted(); SQLException sx = new SQLException("Pool wait interrupted."); sx.initCause(ex); throw sx; } finally { waitcount.decrementAndGet(); } if (maxWait == 0 && con == null) { throw new SQLException("[" + Thread.currentThread().getName() + "] " + "NoWait: Pool empty. Unable to fetch a connection, none available[" + busy.size() + " in use]."); } if (con == null) { if ((System.currentTimeMillis() - now) >= maxWait) { throw new SQLException("[" + Thread.currentThread().getName() + "] " + "Timeout: Pool empty. Unable to fetch a connection in " + (maxWait / 1000) + " seconds, none available[" + busy.size() + " in use]."); } else { continue; } } } //while }	protected PooledConnection borrowConnection(long now, PooledConnection con) throws SQLException { //we have a connection, lets set it up boolean setToNull = false; try { con.lock(); if (con.isReleased()) { return null; } if (!con.isDiscarded() && !con.isInitialized()) { con.connect(); } if ((!con.isDiscarded()) && con.validate(PooledConnection.VALIDATE_BORROW)) { con.setTimestamp(now); if (getPoolProperties().isLogAbandoned()) { con.setStackTrace(getThreadDump()); } if (!busy.offer(con)) { log.debug("Connection doesn't fit into busy array, connection will not be traceable."); } return con; } try { con.reconnect(); if (con.validate(PooledConnection.VALIDATE_INIT)) { con.setTimestamp(now); if (getPoolProperties().isLogAbandoned()) { con.setStackTrace(getThreadDump()); } if (!busy.offer(con)) { log.debug("Connection doesn't fit into busy array, connection will not be traceable."); } return con; } else { release(con); setToNull = true; throw new SQLException("Failed to validate a newly established connection."); } } catch (Exception x) { release(con); setToNull = true; if (x instanceof SQLException) { throw (SQLException) x; } else { SQLException ex = new SQLException(x.getMessage()); ex.initCause(x); throw ex; } } } finally { con.unlock(); if (setToNull) { con = null; } } }	protected PooledConnection createConnection(long now, PooledConnection notUsed) throws SQLException { PooledConnection con = create(); boolean error = false; try { con.lock(); con.connect(); if (con.validate(PooledConnection.VALIDATE_INIT)) { con.setTimestamp(now); if (getPoolProperties().isLogAbandoned()) { con.setStackTrace(getThreadDump()); } if (!busy.offer(con)) { log.debug("Connection doesn't fit into busy array, connection will not be traceable."); } return con; } else { //validation failed, make sure we disconnect error = true; } //end if } catch (Exception e) { error = true; if (log.isDebugEnabled()) log.debug("Unable to create a new JDBC connection.", e); if (e instanceof SQLException) { throw (SQLException) e; } else { SQLException ex = new SQLException(e.getMessage()); ex.initCause(e); throw ex; } } finally { if (error) { release(con); } con.unlock(); } return null; }	protected void connectUsingDataSource() throws SQLException { if (poolProperties.getDataSource() instanceof javax.sql.XADataSource) { javax.sql.XADataSource xds = (javax.sql.XADataSource) poolProperties.getDataSource(); if (poolProperties.getUsername() != null && poolProperties.getPassword() != null) { xaConnection = xds.getXAConnection(poolProperties.getUsername(), poolProperties.getPassword()); connection = xaConnection.getConnection(); } else { xaConnection = xds.getXAConnection(); connection = xaConnection.getConnection(); } } else if (poolProperties.getDataSource() instanceof javax.sql.DataSource) { javax.sql.DataSource ds = (javax.sql.DataSource) poolProperties.getDataSource(); if (poolProperties.getUsername() != null && poolProperties.getPassword() != null) { connection = ds.getConnection(poolProperties.getUsername(), poolProperties.getPassword()); } else { connection = ds.getConnection(); } } else if (poolProperties.getDataSource() instanceof javax.sql.ConnectionPoolDataSource) { javax.sql.ConnectionPoolDataSource ds = (javax.sql.ConnectionPoolDataSource) poolProperties.getDataSource(); if (poolProperties.getUsername() != null && poolProperties.getPassword() != null) { connection = ds.getPooledConnection(poolProperties.getUsername(), poolProperties.getPassword()).getConnection(); } else { connection = ds.getPooledConnection().getConnection(); } } else { throw new SQLException("DataSource is of unknown class:" + (poolProperties.getDataSource() != null ? poolProperties.getDataSource().getClass() : "null")); } }	protected void connectUsingDriver() throws SQLException { java.sql.Driver driver = null; try { driver = (java.sql.Driver) Class.forName(poolProperties.getDriverClassName(), true, PooledConnection.class.getClassLoader()).newInstance(); } catch (java.lang.Exception cn) { if (log.isDebugEnabled()) { log.debug("Unable to instantiate JDBC driver.", cn); } SQLException ex = new SQLException(cn.getMessage()); ex.initCause(cn); throw ex; } String driverURL = poolProperties.getUrl(); String usr = poolProperties.getUsername(); String pwd = poolProperties.getPassword(); if (usr != null) { poolProperties.getDbProperties().setProperty("user", usr); } if (pwd != null) { poolProperties.getDbProperties().setProperty("password", pwd); } try { connection = driver.connect(driverURL, poolProperties.getDbProperties()); } catch (Exception x) { if (log.isDebugEnabled()) { log.debug("Unable to connect to database.", x); } if (parent.jmxPool != null) { parent.jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_CONNECT, ConnectionPool.getStackTrace(x)); } if (x instanceof SQLException) { throw (SQLException) x; } else { SQLException ex = new SQLException(x.getMessage()); ex.initCause(x); throw ex; } } if (connection == null) { throw new SQLException("Driver:" + driver + " returned null for URL:" + driverURL); } }	protected void init(PoolConfiguration properties) throws SQLException { poolProperties = properties; busy = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(), false); if (properties.isFairQueue()) { idle = new FairBlockingQueue<PooledConnection>(); //idle = new MultiLockFairBlockingQueue<PooledConnection>(); } else { idle = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(), properties.isFairQueue()); } if (properties.isPoolSweeperEnabled()) { poolCleaner = new PoolCleaner("[Pool-Cleaner]:" + properties.getName(), this, properties.getTimeBetweenEvictionRunsMillis()); poolCleaner.start(); } if (properties.getMaxActive() < properties.getInitialSize()) { log.warn("initialSize is larger than maxActive, setting initialSize to: " + properties.getMaxActive()); properties.setInitialSize(properties.getMaxActive()); } if (properties.getMinIdle() > properties.getMaxActive()) { log.warn("minIdle is larger than maxActive, setting minIdle to: " + properties.getMaxActive()); properties.setMinIdle(properties.getMaxActive()); } if (properties.getMaxIdle() > properties.getMaxActive()) { log.warn("maxIdle is larger than maxActive, setting maxIdle to: " + properties.getMaxActive()); properties.setMaxIdle(properties.getMaxActive()); } if (properties.getMaxIdle() < properties.getMinIdle()) { log.warn("maxIdle is smaller than minIdle, setting maxIdle to: " + properties.getMinIdle()); properties.setMaxIdle(properties.getMinIdle()); } if (this.getPoolProperties().isJmxEnabled()) createMBean(); //Parse and create an initial set of interceptors. Letting them know the pool has started. PoolProperties.InterceptorDefinition[] proxies = getPoolProperties().getJdbcInterceptorsAsArray(); for (int i = 0; i < proxies.length; i++) { try { if (log.isDebugEnabled()) { log.debug("Creating interceptor instance of class:" + proxies[i].getInterceptorClass()); } proxies[i].getInterceptorClass().newInstance().poolStarted(this); } catch (Exception x) { log.error("Unable to inform interceptor of pool start.", x); if (jmxPool != null) jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_INIT, getStackTrace(x)); close(true); SQLException ex = new SQLException(); ex.initCause(x); throw ex; } } PooledConnection[] initialPool = new PooledConnection[poolProperties.getInitialSize()]; try { for (int i = 0; i < initialPool.length; i++) { initialPool[i] = this.borrowConnection(0); } //for } catch (SQLException x) { if (jmxPool != null) jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_INIT, getStackTrace(x)); close(true); throw x; } finally { for (int i = 0; i < initialPool.length; i++) { if (initialPool[i] != null) { try { this.returnConnection(initialPool[i]); } catch (Exception x) { /*NOOP*/ } } //end if } //for } closed = false; }	protected void release(PooledConnection con) { if (con == null) return; try { con.lock(); if (con.release()) { size.addAndGet(-1); con.setHandler(null); } } finally { con.unlock(); } if (waitcount.get() > 0) { idle.offer(new PooledConnection(poolProperties, this)); } }	public Connection connect(String url, Properties info) throws SQLException { connectCount.addAndGet(1); return new org.apache.tomcat.jdbc.test.driver.Connection(); }	public Connection get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { PooledConnection pc = pcFuture.get(timeout, unit); if (pc != null) { if (result != null) return result; if (configured.compareAndSet(false, true)) { try { pc = borrowConnection(System.currentTimeMillis(), pc); result = ConnectionPool.this.setupConnection(pc); } catch (SQLException x) { cause = x; } finally { latch.countDown(); } } else { //if we reach here, another thread is configuring the actual connection latch.await(timeout, unit); } if (result == null) throw new ExecutionException(cause); return result; } else { return null; } }	public Connection getConnection() throws SQLException { PooledConnection con = borrowConnection(-1); return setupConnection(con); }	public Connection getConnection(String username, String password) throws SQLException { return getConnection(); }	public String getDataSourceJNDI() { return getPoolProperties().getDataSourceJNDI(); }	public String getDataSourceJNDI() { return getPoolProperties().getDataSourceJNDI(); }	public static PoolConfiguration parsePoolProperties(Properties properties) throws IOException { PoolConfiguration poolProperties = new PoolProperties(); String value = null; value = properties.getProperty(PROP_DEFAULTAUTOCOMMIT); if (value != null) { poolProperties.setDefaultAutoCommit(Boolean.valueOf(value)); } value = properties.getProperty(PROP_DEFAULTREADONLY); if (value != null) { poolProperties.setDefaultReadOnly(Boolean.valueOf(value)); } value = properties.getProperty(PROP_DEFAULTTRANSACTIONISOLATION); if (value != null) { int level = UNKNOWN_TRANSACTIONISOLATION; if ("NONE".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_NONE; } else if ("READ_COMMITTED".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_READ_COMMITTED; } else if ("READ_UNCOMMITTED".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_READ_UNCOMMITTED; } else if ("REPEATABLE_READ".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_REPEATABLE_READ; } else if ("SERIALIZABLE".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_SERIALIZABLE; } else { try { level = Integer.parseInt(value); } catch (NumberFormatException e) { System.err.println("Could not parse defaultTransactionIsolation: " + value); System.err.println("WARNING: defaultTransactionIsolation not set"); System.err.println("using default value of database driver"); level = UNKNOWN_TRANSACTIONISOLATION; } } poolProperties.setDefaultTransactionIsolation(level); } value = properties.getProperty(PROP_DEFAULTCATALOG); if (value != null) { poolProperties.setDefaultCatalog(value); } value = properties.getProperty(PROP_DRIVERCLASSNAME); if (value != null) { poolProperties.setDriverClassName(value); } value = properties.getProperty(PROP_MAXACTIVE); if (value != null) { poolProperties.setMaxActive(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXIDLE); if (value != null) { poolProperties.setMaxIdle(Integer.parseInt(value)); } value = properties.getProperty(PROP_MINIDLE); if (value != null) { poolProperties.setMinIdle(Integer.parseInt(value)); } value = properties.getProperty(PROP_INITIALSIZE); if (value != null) { poolProperties.setInitialSize(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXWAIT); if (value != null) { poolProperties.setMaxWait(Integer.parseInt(value)); } value = properties.getProperty(PROP_TESTONBORROW); if (value != null) { poolProperties.setTestOnBorrow(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TESTONRETURN); if (value != null) { poolProperties.setTestOnReturn(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TESTONCONNECT); if (value != null) { poolProperties.setTestOnConnect(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TIMEBETWEENEVICTIONRUNSMILLIS); if (value != null) { poolProperties.setTimeBetweenEvictionRunsMillis(Integer.parseInt(value)); } value = properties.getProperty(PROP_NUMTESTSPEREVICTIONRUN); if (value != null) { poolProperties.setNumTestsPerEvictionRun(Integer.parseInt(value)); } value = properties.getProperty(PROP_MINEVICTABLEIDLETIMEMILLIS); if (value != null) { poolProperties.setMinEvictableIdleTimeMillis(Integer.parseInt(value)); } value = properties.getProperty(PROP_TESTWHILEIDLE); if (value != null) { poolProperties.setTestWhileIdle(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_PASSWORD); if (value != null) { poolProperties.setPassword(value); } value = properties.getProperty(PROP_URL); if (value != null) { poolProperties.setUrl(value); } value = properties.getProperty(PROP_USERNAME); if (value != null) { poolProperties.setUsername(value); } value = properties.getProperty(PROP_VALIDATIONQUERY); if (value != null) { poolProperties.setValidationQuery(value); } value = properties.getProperty(PROP_VALIDATOR_CLASS_NAME); if (value != null) { poolProperties.setValidatorClassName(value); } value = properties.getProperty(PROP_VALIDATIONINTERVAL); if (value != null) { poolProperties.setValidationInterval(Long.parseLong(value)); } value = properties.getProperty(PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED); if (value != null) { poolProperties.setAccessToUnderlyingConnectionAllowed(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_REMOVEABANDONED); if (value != null) { poolProperties.setRemoveAbandoned(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_REMOVEABANDONEDTIMEOUT); if (value != null) { poolProperties.setRemoveAbandonedTimeout(Integer.parseInt(value)); } value = properties.getProperty(PROP_LOGABANDONED); if (value != null) { poolProperties.setLogAbandoned(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_POOLPREPAREDSTATEMENTS); if (value != null) { log.warn(PROP_POOLPREPAREDSTATEMENTS + " is not a valid setting, it will have no effect."); } value = properties.getProperty(PROP_MAXOPENPREPAREDSTATEMENTS); if (value != null) { log.warn(PROP_MAXOPENPREPAREDSTATEMENTS + " is not a valid setting, it will have no effect."); } value = properties.getProperty(PROP_CONNECTIONPROPERTIES); if (value != null) { Properties p = getProperties(value); poolProperties.setDbProperties(p); } else { poolProperties.setDbProperties(new Properties()); } if (poolProperties.getUsername() != null) { poolProperties.getDbProperties().setProperty("user", poolProperties.getUsername()); } if (poolProperties.getPassword() != null) { poolProperties.getDbProperties().setProperty("password", poolProperties.getPassword()); } value = properties.getProperty(PROP_INITSQL); if (value != null) { poolProperties.setInitSQL(value); } value = properties.getProperty(PROP_INTERCEPTORS); if (value != null) { poolProperties.setJdbcInterceptors(value); } value = properties.getProperty(PROP_JMX_ENABLED); if (value != null) { poolProperties.setJmxEnabled(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_FAIR_QUEUE); if (value != null) { poolProperties.setFairQueue(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_USE_EQUALS); if (value != null) { poolProperties.setUseEquals(Boolean.parseBoolean(value)); } value = properties.getProperty(OBJECT_NAME); if (value != null) { poolProperties.setName(ObjectName.quote(value)); } value = properties.getProperty(PROP_ABANDONWHENPERCENTAGEFULL); if (value != null) { poolProperties.setAbandonWhenPercentageFull(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXAGE); if (value != null) { poolProperties.setMaxAge(Long.parseLong(value)); } value = properties.getProperty(PROP_USE_CON_LOCK); if (value != null) { poolProperties.setUseLock(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_DATASOURCE); if (value != null) { throw new IllegalArgumentException("Can't set dataSource property as a string, this must be a javax.sql.DataSource object."); } value = properties.getProperty(PROP_DATASOURCE_JNDI); if (value != null) { poolProperties.setDataSourceJNDI(value); } value = properties.getProperty(PROP_SUSPECT_TIMEOUT); if (value != null) { poolProperties.setSuspectTimeout(Integer.parseInt(value)); } return poolProperties; }	public static Properties getProperties(String propText, Properties props) { if (props == null) props = new Properties(); if (propText != null) { try { props.load(new ByteArrayInputStream(propText.replace(';', '\n').getBytes())); } catch (IOException x) { throw new RuntimeException(x); } } return props; }
@Override public String getManagerName(String name, Manager manager) { String clusterName = name; if (clusterName == null) clusterName = manager.getContainer().getName(); if (getContainer() instanceof Engine) { Container context = manager.getContainer(); if (context != null && context instanceof Context) { Container host = ((Context) context).getParent(); if (host != null && host instanceof Host && clusterName != null && !(clusterName.indexOf("#") >= 0)) clusterName = host.getName() + "#" + clusterName; } } return clusterName; }
private void generatePreamble(Node.Nodes page) throws JasperException { String servletPackageName = ctxt.getServletPackageName(); String servletClassName = ctxt.getServletClassName(); String serviceMethodName = Constants.SERVICE_METHOD_NAME; genPreamblePackage(servletPackageName); genPreambleImports(); out.printin("public final class "); out.print(servletClassName); out.print(" extends "); out.println(pageInfo.getExtends()); out.printin(" implements org.apache.jasper.runtime.JspSourceDependent"); if (!pageInfo.isThreadSafe()) { out.println(","); out.printin(" SingleThreadModel"); } out.println(" {"); out.pushIndent(); generateDeclarations(page); genPreambleStaticInitializers(); genPreambleClassVariableDeclarations(); // Constructor // generateConstructor(className); genPreambleMethods(); out.printin("public void "); out.print(serviceMethodName); out.println("(HttpServletRequest request, HttpServletResponse response)"); out.println(" throws java.io.IOException, ServletException {"); out.pushIndent(); out.println(); out.printil("PageContext pageContext = null;"); if (pageInfo.isSession()) out.printil("HttpSession session = null;"); if (pageInfo.isErrorPage()) { out.printil("Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);"); out.printil("if (exception != null) {"); out.pushIndent(); out.printil("response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);"); out.popIndent(); out.printil("}"); } out.printil("ServletContext application = null;"); out.printil("ServletConfig config = null;"); out.printil("JspWriter out = null;"); out.printil("Object page = this;"); out.printil("JspWriter _jspx_out = null;"); out.printil("PageContext _jspx_page_context = null;"); out.println(); declareTemporaryScriptingVars(page); out.println(); out.printil("try {"); out.pushIndent(); out.printin("response.setContentType("); out.print(quote(pageInfo.getContentType())); out.println(");"); if (ctxt.getOptions().isXpoweredBy()) { out.printil("response.addHeader(\"X-Powered-By\", \"JSP/2.1\");"); } out.printil("pageContext = _jspxFactory.getPageContext(this, request, response,"); out.printin("\t\t\t"); out.print(quote(pageInfo.getErrorPage())); out.print(", " + pageInfo.isSession()); out.print(", " + pageInfo.getBuffer()); out.print(", " + pageInfo.isAutoFlush()); out.println(");"); out.printil("_jspx_page_context = pageContext;"); out.printil("application = pageContext.getServletContext();"); out.printil("config = pageContext.getServletConfig();"); if (pageInfo.isSession()) out.printil("session = pageContext.getSession();"); out.printil("out = pageContext.getOut();"); out.printil("_jspx_out = out;"); out.println(); }
public SAXException createSAXException(String message, Exception e) { if ((e != null) && (e instanceof InvocationTargetException)) { Throwable t = ((InvocationTargetException) e).getTargetException(); if ((t != null) && (t instanceof Exception)) { e = (Exception) t; } } if (locator != null) { String error = "Error at (" + locator.getLineNumber() + ", " + locator.getColumnNumber() + ": " + message; if (e != null) { return new SAXParseException(error, locator, e); } else { return new SAXParseException(error, locator); } } log.error("No Locator!"); if (e != null) { return new SAXException(message, e); } else { return new SAXException(message); } }	@Override public void begin(String namespace, String name, Attributes attributes) throws Exception { String realClassName = className; if (attributeName != null) { String value = attributes.getValue(attributeName); if (value != null) { realClassName = value; } } if (digester.log.isDebugEnabled()) { digester.log.debug("[ObjectCreateRule]{" + digester.match + "}New " + realClassName); } Class<?> clazz = digester.getClassLoader().loadClass(realClassName); Object instance = clazz.newInstance(); digester.push(instance); }	public void load() { long t1 = System.nanoTime(); initDirs(); initNaming(); Digester digester = createStartDigester(); InputSource inputSource = null; InputStream inputStream = null; File file = null; try { file = configFile(); inputStream = new FileInputStream(file); inputSource = new InputSource("file://" + file.getAbsolutePath()); } catch (Exception e) { // Ignore } if (inputStream == null) { try { inputStream = getClass().getClassLoader().getResourceAsStream(getConfigFile()); inputSource = new InputSource(getClass().getClassLoader().getResource(getConfigFile()).toString()); } catch (Exception e) { // Ignore } } if (inputStream == null) { try { inputStream = getClass().getClassLoader().getResourceAsStream("server-embed.xml"); inputSource = new InputSource(getClass().getClassLoader().getResource("server-embed.xml").toString()); } catch (Exception e) { // Ignore } } if ((inputStream == null) && (file != null)) { log.warn("Can't load server.xml from " + file.getAbsolutePath()); if (file.exists() && !file.canRead()) { log.warn("Permissions incorrect, read permission is not allowed on the file."); } return; } try { inputSource.setByteStream(inputStream); digester.push(this); digester.parse(inputSource); inputStream.close(); } catch (Exception e) { log.warn("Catalina.start using " + getConfigFile() + ": ", e); return; } getServer().setCatalina(this); initStreams(); try { getServer().init(); } catch (LifecycleException e) { if (Boolean.getBoolean("org.apache.catalina.startup.EXIT_ON_INIT_FAILURE")) throw new java.lang.Error(e); else log.error("Catalina.start", e); } long t2 = System.nanoTime(); if (log.isInfoEnabled()) log.info("Initialization processed in " + ((t2 - t1) / 1000000) + " ms"); }
public void register(Request request, HttpServletResponse response, Principal principal, String authType, String username, String password) { if (log.isDebugEnabled()) log.debug("Authenticated '" + principal.getName() + "' with type '" + authType + "'"); request.setAuthType(authType); request.setUserPrincipal(principal); Session session = request.getSessionInternal(false); if (session != null && changeSessionIdOnAuthentication) { Manager manager = request.getContext().getManager(); manager.changeSessionId(session); request.changeSessionId(session.getId()); } if (cache) { if (session != null) { session.setAuthType(authType); session.setPrincipal(principal); if (username != null) session.setNote(Constants.SESS_USERNAME_NOTE, username); else session.removeNote(Constants.SESS_USERNAME_NOTE); if (password != null) session.setNote(Constants.SESS_PASSWORD_NOTE, password); else session.removeNote(Constants.SESS_PASSWORD_NOTE); } } if (sso == null) return; // Only create a new SSO entry if the SSO did not already set a note // for an existing entry (as it would do with subsequent requests String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (ssoId == null) { ssoId = sessionIdGenerator.generateSessionId(); Cookie cookie = new Cookie(Constants.SINGLE_SIGN_ON_COOKIE, ssoId); cookie.setMaxAge(-1); cookie.setPath("/"); cookie.setSecure(request.isSecure()); String ssoDomain = sso.getCookieDomain(); if (ssoDomain != null) { cookie.setDomain(ssoDomain); } if (request.getServletContext().getSessionCookieConfig().isHttpOnly() || request.getContext().getUseHttpOnly()) { cookie.setHttpOnly(true); } response.addCookie(cookie); sso.register(ssoId, principal, authType, username, password); request.setNote(Constants.REQ_SSOID_NOTE, ssoId); } else { if (principal == null) { sso.deregister(ssoId); return; } else { sso.update(ssoId, principal, authType, username, password); } } if (session == null) session = request.getSessionInternal(true); sso.associate(ssoId, session); }
public boolean writeMessage(FileMessage msg) throws IllegalArgumentException, IOException { if (!openForWrite) throw new IllegalArgumentException("Can't write message, this factory is reading."); if (log.isDebugEnabled()) log.debug("Message " + msg + " data " + msg.getData() + " data length " + msg.getDataLength() + " out " + out); if (msg.getMessageNumber() <= lastMessageProcessed.get()) { log.warn("Receive Message again -- Sender ActTimeout too short [ path: " + msg.getContextPath() + " war: " + msg.getFileName() + " data: " + msg.getData() + " data length: " + msg.getDataLength() + " ]"); return false; } FileMessage previous = msgBuffer.put(Long.valueOf(msg.getMessageNumber()), msg); if (previous != null) { log.warn("Receive Message again -- Sender ActTimeout too short [ path: " + msg.getContextPath() + " war: " + msg.getFileName() + " data: " + msg.getData() + " data length: " + msg.getDataLength() + " ]"); return false; } FileMessage next = null; synchronized (this) { if (!isWriting) { next = msgBuffer.get(Long.valueOf(lastMessageProcessed.get() + 1)); if (next != null) { isWriting = true; } else { return false; } } else { return false; } } while (next != null) { out.write(next.getData(), 0, next.getDataLength()); lastMessageProcessed.incrementAndGet(); out.flush(); if (next.getMessageNumber() == next.getTotalNrOfMsgs()) { out.close(); cleanup(); return true; } synchronized (this) { next = msgBuffer.get(Long.valueOf(lastMessageProcessed.get() + 1)); if (next == null) { isWriting = false; } } } return false; }	public static byte getHex(int index) { return HEX[index]; }	public void dump(String msg) { if (log.isDebugEnabled()) { log.debug(msg + ": " + buf + " " + pos + "/" + (len + 4)); } int max = pos; if (len + 4 > pos) max = len + 4; if (max > 1000) max = 1000; if (log.isDebugEnabled()) { for (int j = 0; j < max; j += 16) { log.debug(hexLine(buf, j, len)); } } }
private static SAXParser getSAXParser(boolean validating, JspDocumentParser jspDocParser) throws Exception { SAXParserFactory factory = SAXParserFactory.newInstance(); factory.setNamespaceAware(true); factory.setFeature("http://xml.org/sax/features/namespace-prefixes", true); factory.setValidating(validating); //factory.setFeature( // "http://xml.org/sax/features/validation", // validating); SAXParser saxParser = factory.newSAXParser(); XMLReader xmlReader = saxParser.getXMLReader(); xmlReader.setProperty(LEXICAL_HANDLER_PROPERTY, jspDocParser); xmlReader.setErrorHandler(jspDocParser); return saxParser; }	@Override public void setRootCause(Throwable e) { /*NOOP*/ }	@Override public void startDTD(String name, String publicId, String systemId) throws SAXException { if (!isValidating) { fatalError(ENABLE_DTD_VALIDATION_EXCEPTION); } inDTD = true; }
@Override public long getCreationTime() { return 0; }	@Override public long getCreationTime() { if (!isValidInternal()) throw new IllegalStateException(sm.getString("standardSession.getCreationTime.ise")); return (this.creationTime); }	@Override public void remove(Session session, boolean update) { if (update) { long timeNow = System.currentTimeMillis(); int timeAlive = (int) ((timeNow - session.getCreationTime()) / 1000); updateSessionMaxAliveTime(timeAlive); expiredSessions.incrementAndGet(); SessionTiming timing = new SessionTiming(timeNow, timeAlive); synchronized (sessionExpirationTiming) { sessionExpirationTiming.add(timing); sessionExpirationTiming.poll(); } } if (session.getIdInternal() != null) { sessions.remove(session.getIdInternal()); } }
@Override public Class<?> getType(ELContext context, Object base, Object property) throws NullPointerException, PropertyNotFoundException, ELException { context.setPropertyResolved(false); int sz = this.size; Class<?> type; for (int i = 0; i < sz; i++) { type = this.resolvers[i].getType(context, base, property); if (context.isPropertyResolved()) { return type; } } return null; }
@Override protected void initInternal() throws LifecycleException { super.initInternal(); adapter = new CoyoteAdapter(this); protocolHandler.setAdapter(adapter); protocolHandler.setDomain(getDomain()); try { protocolHandler.init(); } catch (Exception e) { throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerInitializationFailed", e)); } onameProtocolHandler = register(protocolHandler, createObjectNameKeyProperties("ProtocolHandler")); mapperListener.init(); }	protected void parseParameters() { parametersParsed = true; Parameters parameters = coyoteRequest.getParameters(); // getCharacterEncoding() may have been overridden to search for String enc = getCharacterEncoding(); boolean useBodyEncodingForURI = connector.getUseBodyEncodingForURI(); if (enc != null) { parameters.setEncoding(enc); if (useBodyEncodingForURI) { parameters.setQueryStringEncoding(enc); } } else { parameters.setEncoding(org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING); if (useBodyEncodingForURI) { parameters.setQueryStringEncoding(org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING); } } parameters.handleQueryParameters(); if (usingInputStream || usingReader) return; if (!getMethod().equalsIgnoreCase("POST")) return; String contentType = getContentType(); if (contentType == null) contentType = ""; int semicolon = contentType.indexOf(';'); if (semicolon >= 0) { contentType = contentType.substring(0, semicolon).trim(); } else { contentType = contentType.trim(); } if ("multipart/form-data".equals(contentType)) { parseParts(); return; } if (!("application/x-www-form-urlencoded".equals(contentType))) return; int len = getContentLength(); if (len > 0) { int maxPostSize = connector.getMaxPostSize(); if ((maxPostSize > 0) && (len > maxPostSize)) { if (context.getLogger().isDebugEnabled()) { context.getLogger().debug(sm.getString("coyoteRequest.postTooLarge")); } return; } byte[] formData = null; if (len < CACHED_POST_LEN) { if (postData == null) postData = new byte[CACHED_POST_LEN]; formData = postData; } else { formData = new byte[len]; } try { if (readPostBody(formData, len) != len) { return; } } catch (IOException e) { if (context.getLogger().isDebugEnabled()) { context.getLogger().debug(sm.getString("coyoteRequest.parseParameters"), e); } return; } parameters.processParameters(formData, 0, len); } else if ("chunked".equalsIgnoreCase(coyoteRequest.getHeader("transfer-encoding"))) { byte[] formData = null; try { formData = readChunkedPostBody(); } catch (IOException e) { if (context.getLogger().isDebugEnabled()) { context.getLogger().debug(sm.getString("coyoteRequest.parseParameters"), e); } return; } if (formData != null) { parameters.processParameters(formData, 0, formData.length); } } }	public void setMaxSavePostSize(int maxSavePostSize) { this.maxSavePostSize = maxSavePostSize; setProperty("maxSavePostSize", String.valueOf(maxSavePostSize)); }	public void testBug49424WithChunking() throws Exception { Tomcat tomcat = getTomcatInstance(); Context root = tomcat.addContext("", System.getProperty("java.io.tmpdir")); Tomcat.addServlet(root, "Bug37794", new Bug37794Servlet()); root.addServletMapping("/", "Bug37794"); tomcat.start(); HttpURLConnection conn = getConnection(); conn.setChunkedStreamingMode(8 * 1024); InputStream is = conn.getInputStream(); assertNotNull(is); }
@Override protected void stopInternal() throws LifecycleException { if (log.isDebugEnabled()) log.debug("Stopping embedded server"); fireLifecycleEvent(STOP_EVENT, null); setState(LifecycleState.STARTING); for (int i = 0; i < connectors.length; i++) { ((Lifecycle) connectors[i]).stop(); } for (int i = 0; i < engines.length; i++) { engines[i].stop(); } }
private static SAXParser getSAXParser(boolean validating, JspDocumentParser jspDocParser) throws Exception { SAXParserFactory factory = SAXParserFactory.newInstance(); factory.setNamespaceAware(true); factory.setFeature("http://xml.org/sax/features/namespace-prefixes", true); factory.setValidating(validating); //factory.setFeature( // "http://xml.org/sax/features/validation", // validating); SAXParser saxParser = factory.newSAXParser(); XMLReader xmlReader = saxParser.getXMLReader(); xmlReader.setProperty(LEXICAL_HANDLER_PROPERTY, jspDocParser); xmlReader.setErrorHandler(jspDocParser); return saxParser; }	@Override public String toString() { StringBuilder buf = new StringBuilder("MapEntry[key:"); buf.append(getKey()).append("; "); buf.append("value:").append(getValue()).append("; "); buf.append("primary:").append(isPrimary()).append("; "); buf.append("backup:").append(isBackup()).append("; "); buf.append("proxy:").append(isProxy()).append(";]"); return buf.toString(); }	public static ExecutorService newThreadPool(int minThreads, int maxThreads, long maxIdleTime, TimeUnit unit, ThreadFactory threadFactory) { TaskQueue taskqueue = new TaskQueue(); ThreadPoolExecutor service = new ThreadPoolExecutor(minThreads, maxThreads, maxIdleTime, unit, taskqueue, threadFactory); taskqueue.setParent(service); return service; }	public static SimpleTableDemo createAndShowGUI(LazyReplicatedMap map, String title) { JFrame.setDefaultLookAndFeelDecorated(true); JFrame frame = new JFrame("SimpleTableDemo - " + title); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); SimpleTableDemo newContentPane = new SimpleTableDemo(map); newContentPane.setOpaque(true); frame.setContentPane(newContentPane); frame.setSize(450, 250); newContentPane.setSize(450, 300); frame.pack(); frame.setVisible(true); return newContentPane; }	@Override public void run() { System.out.println("Shutting down..."); SystemExit exit = new SystemExit(5000); exit.setDaemon(true); exit.start(); try { channel.stop(Channel.DEFAULT); } catch (Exception x) { x.printStackTrace(); } System.out.println("Channel stopped."); }
@SuppressWarnings("deprecation") private void clearReferencesThreads() { Thread[] threads = getThreads(); for (Thread thread : threads) { if (thread != null) { ClassLoader ccl = thread.getContextClassLoader(); if (ccl != null && ccl == this) { if (thread == Thread.currentThread()) { continue; } if (!thread.isAlive()) { continue; } ThreadGroup tg = thread.getThreadGroup(); if (tg != null && JVM_THREAD_GROUP_NAMES.contains(tg.getName())) { continue; } if (thread.getClass().getName().equals("java.util.TimerThread") && clearReferencesStopTimerThreads) { clearReferencesStopTimerThread(thread); continue; } if (isRequestThread(thread)) { log.error(sm.getString("webappClassLoader.warnRequestThread", contextName, thread.getName())); } else { log.error(sm.getString("webappClassLoader.warnThread", contextName, thread.getName())); } if (!clearReferencesStopThreads) { continue; } try { Field targetField = thread.getClass().getDeclaredField("target"); targetField.setAccessible(true); Object target = targetField.get(thread); if (target != null && target.getClass().getCanonicalName().equals("java.util.concurrent.ThreadPoolExecutor.Worker")) { Field executorField = target.getClass().getDeclaredField("this$0"); executorField.setAccessible(true); Object executor = executorField.get(target); if (executor instanceof ThreadPoolExecutor) { ((ThreadPoolExecutor) executor).shutdownNow(); } } } catch (SecurityException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } catch (NoSuchFieldException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } catch (IllegalArgumentException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } catch (IllegalAccessException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } // This method is deprecated and for good reason. This is // very risky code but is the only option at this point. // A *very* good reason for apps to do this clean-up thread.stop(); } } } }	private Thread[] getThreads() { ThreadGroup tg = Thread.currentThread().getThreadGroup(); while (tg.getParent() != null) { tg = tg.getParent(); } int threadCountGuess = tg.activeCount() + 50; Thread[] threads = new Thread[threadCountGuess]; int threadCountActual = tg.enumerate(threads); while (threadCountActual == threadCountGuess) { threadCountGuess *= 2; threads = new Thread[threadCountGuess]; // Note tg.enumerate(Thread[]) silently ignores any threads that threadCountActual = tg.enumerate(threads); } return threads; }
public int getPacketSize() { return packetSize; }	public void setSoLinger(int soLinger) { endpoint.setSoLinger(soLinger); }
protected void timeout(int keyCount, boolean hasEvents) { long now = System.currentTimeMillis(); if (((keyCount > 0 || hasEvents) || (now < nextExpiration)) && (!close)) { return; } long prevExp = nextExpiration; nextExpiration = now + socketProperties.getTimeoutInterval(); Set<SelectionKey> keys = selector.keys(); int keycount = 0; for (Iterator<SelectionKey> iter = keys.iterator(); iter.hasNext(); ) { SelectionKey key = iter.next(); keycount++; try { KeyAttachment ka = (KeyAttachment) key.attachment(); if (ka == null) { cancelledKey(key, SocketStatus.ERROR, false); } else if (ka.getError()) { cancelledKey(key, SocketStatus.ERROR, true); } else if (ka.getComet() && ka.getCometNotify()) { ka.setCometNotify(false); reg(key, ka, 0); if (!processSocket(ka.getChannel(), SocketStatus.OPEN, true)) processSocket(ka.getChannel(), SocketStatus.DISCONNECT, true); } else if ((ka.interestOps() & SelectionKey.OP_READ) == SelectionKey.OP_READ || (ka.interestOps() & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) { long delta = now - ka.getLastAccess(); long timeout = (ka.getTimeout() == -1) ? ((long) socketProperties.getSoTimeout()) : (ka.getTimeout()); boolean isTimedout = delta > timeout; if (close) { key.interestOps(0); ka.interestOps(0); processKey(key, ka); } else if (isTimedout) { key.interestOps(0); ka.interestOps(0); cancelledKey(key, SocketStatus.TIMEOUT, true); } else { long nextTime = now + (timeout - delta); nextExpiration = (nextTime < nextExpiration) ? nextTime : nextExpiration; } } else if (ka.isAsync()) { long delta = now - ka.getLastAccess(); long timeout = (ka.getTimeout() == -1) ? ((long) socketProperties.getSoTimeout()) : (ka.getTimeout()); boolean isTimedout = delta > timeout; if (isTimedout) { processSocket(ka.getChannel(), SocketStatus.TIMEOUT, true); } } //end if } catch (CancelledKeyException ckx) { cancelledKey(key, SocketStatus.ERROR, false); } } if (log.isTraceEnabled()) log.trace("timeout completed: keys processed=" + keycount + "; now=" + now + "; nextExpiration=" + prevExp + "; " + "keyCount=" + keyCount + "; hasEvents=" + hasEvents + "; eval=" + ((now < prevExp) && (keyCount > 0 || hasEvents) && (!close))); }	@Override public SocketState event(NioChannel socket, SocketStatus status) { Http11NioProcessor processor = connections.get(socket); NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment) socket.getAttachment(false); att.setAsync(false); SocketState state = SocketState.CLOSED; if (processor != null) { if (log.isDebugEnabled()) log.debug("Http11NioProcessor.error=" + processor.error); try { if (processor.comet) { state = processor.event(status); } else { state = processor.asyncDispatch(status); } } catch (java.net.SocketException e) { Http11NioProtocol.log.debug(sm.getString("http11protocol.proto.socketexception.debug"), e); } catch (java.io.IOException e) { Http11NioProtocol.log.debug(sm.getString("http11protocol.proto.ioexception.debug"), e); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); // any other exception or error is odd. Here we log it // with "ERROR" level, so it will show up even on Http11NioProtocol.log.error(sm.getString("http11protocol.proto.error"), e); } finally { if (processor.isAsync()) { state = processor.asyncPostProcess(); } if (state != SocketState.LONG && state != SocketState.ASYNC_END) { release(socket); if (state == SocketState.OPEN) { socket.getPoller().add(socket); } } else if (state == SocketState.ASYNC_END) { // No further work required } else if (state == SocketState.LONG) { att.setAsync(true); } else { if (log.isDebugEnabled()) log.debug("Keeping processor[" + processor); socket.getPoller().add(socket, att.getCometOps()); } } } return state; }
public static String formatSize(Object obj, boolean mb) { long bytes = -1L; if (obj instanceof Long) { bytes = ((Long) obj).longValue(); } else if (obj instanceof Integer) { bytes = ((Integer) obj).intValue(); } if (mb) { long mbytes = bytes / (1024 * 1024); long rest = ((bytes - (mbytes * (1024 * 1024))) * 100) / (1024 * 1024); return (mbytes + "." + ((rest < 10) ? "0" : "") + rest + " MB"); } else { return ((bytes / 1024) + " KB"); } }	public static String secondsToTimeString(long in_seconds) { StringBuilder buff = new StringBuilder(9); long rest = in_seconds; long hour = rest / 3600; rest = rest % 3600; long minute = rest / 60; rest = rest % 60; long second = rest; if (hour < 10) { buff.append('0'); } buff.append(hour); buff.append(':'); if (minute < 10) { buff.append('0'); } buff.append(minute); buff.append(':'); if (second < 10) { buff.append('0'); } buff.append(second); return buff.toString(); }
private void doTestTimeout(boolean completeOnTimeout) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); File foo = new File(docBase, "async"); if (!foo.exists() && !foo.mkdirs()) { fail("Unable to create async directory in docBase"); } Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); TimeoutServlet timeout = new TimeoutServlet(completeOnTimeout); Wrapper wrapper = Tomcat.addServlet(ctx, "time", timeout); wrapper.setAsyncSupported(true); ctx.addServletMapping("/async", "time"); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/async"); StringBuilder expected = new StringBuilder(); expected.append("TimeoutServletGet-onTimeout-"); if (!completeOnTimeout) { expected.append("onError-"); } expected.append("onComplete-"); assertEquals(expected.toString(), res.toString()); }	private void doTestDispatchError(int iter, boolean useThread, boolean completeOnError) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); DispatchingServlet dispatch = new DispatchingServlet(true, completeOnError); Wrapper wrapper = Tomcat.addServlet(ctx, "dispatch", dispatch); wrapper.setAsyncSupported(true); ctx.addServletMapping("/stage1", "dispatch"); ErrorServlet error = new ErrorServlet(); Tomcat.addServlet(ctx, "error", error); ctx.addServletMapping("/stage2", "error"); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/stage1?iter="); url.append(iter); if (useThread) { url.append("&useThread=y"); } ByteChunk res = getUrl(url.toString()); StringBuilder expected = new StringBuilder(); int loop = iter; while (loop > 0) { expected.append("DispatchingServletGet-"); if (loop != iter) { expected.append("onStartAsync-"); } loop--; } expected.append("ErrorServletGet-onError-onComplete-"); assertEquals(expected.toString(), res.toString()); }	private void doTestTimeout(boolean completeOnTimeout) throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); File foo = new File(docBase, "async"); if (!foo.exists() && !foo.mkdirs()) { fail("Unable to create async directory in docBase"); } Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); TimeoutServlet timeout = new TimeoutServlet(completeOnTimeout); Wrapper wrapper = Tomcat.addServlet(ctx, "time", timeout); wrapper.setAsyncSupported(true); ctx.addServletMapping("/async", "time"); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/async"); StringBuilder expected = new StringBuilder(); expected.append("TimeoutServletGet-onTimeout-"); if (!completeOnTimeout) { expected.append("onError-"); } expected.append("onComplete-"); assertEquals(expected.toString(), res.toString()); }	public void run() { if (first) { ctxt.dispatch("/stage1"); } else { ctxt.dispatch("/stage2"); } }	public synchronized boolean asyncDispatch() { boolean doDispatch = false; if (state == AsyncState.STARTING) { state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.STARTED) { state = AsyncState.DISPATCHING; doDispatch = true; } else { throw new IllegalStateException(sm.getString("asyncStateMachine.invalidAsyncState", "dispatchAsync()", state)); } return doDispatch; }	@Override public void onTimeout(AsyncEvent event) throws IOException { ServletResponse resp = event.getAsyncContext().getResponse(); resp.getWriter().write("onTimeout-"); resp.flushBuffer(); if (completeOnTimeout) { event.getAsyncContext().complete(); } }	public void testListeners() throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); TrackingServlet tracking = new TrackingServlet(); Wrapper wrapper = Tomcat.addServlet(ctx, "tracking", tracking); wrapper.setAsyncSupported(true); ctx.addServletMapping("/stage1", "tracking"); TimeoutServlet timeout = new TimeoutServlet(true); Wrapper wrapper2 = Tomcat.addServlet(ctx, "timeout", timeout); wrapper2.setAsyncSupported(true); ctx.addServletMapping("/stage2", "timeout"); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/stage1"); ByteChunk res = getUrl(url.toString()); assertEquals("DispatchingServletGet-DispatchingServletGet-onStartAsync-" + "TimeoutServletGet-onStartAsync-onTimeout-onComplete-", res.toString()); }	void testListeners() throws Exception { Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty("java.io.tmpdir")); Context ctx = tomcat.addContext("", docBase.getAbsolutePath()); TrackingServlet tracking = new TrackingServlet(); Wrapper wrapper = Tomcat.addServlet(ctx, "tracking", tracking); wrapper.setAsyncSupported(true); ctx.addServletMapping("/stage1", "tracking"); TimeoutServlet timeout = new TimeoutServlet(true); Wrapper wrapper2 = Tomcat.addServlet(ctx, "timeout", timeout); wrapper2.setAsyncSupported(true); ctx.addServletMapping("/stage2", "timeout"); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append("http://localhost:"); url.append(getPort()); url.append("/stage1"); ByteChunk res = getUrl(url.toString()); assertEquals("DispatchingServletGet-DispatchingServletGet-onStartAsync-" + "TimeoutServletGet-onStartAsync-onTimeout-onComplete-", res.toString()); }	void testTimeoutListenerComplete() throws Exception { doTestTimeout(true); }	public void testTimeoutListenerNoComplete() throws Exception { doTestTimeout(false); }
private String getWebModuleKeyProperties() { StringBuilder keyProperties = new StringBuilder(",WebModule="); String hostName = getParent().getParent().getName(); if (hostName == null) { keyProperties.append("DEFAULT"); } else { keyProperties.append(hostName); } String contextName = ((Context) getParent()).getName(); if (!contextName.startsWith("/")) { keyProperties.append('/'); } keyProperties.append(contextName); StandardContext ctx = null; if (parent instanceof StandardContext) { ctx = (StandardContext) getParent(); } keyProperties.append(",J2EEApplication="); if (ctx == null) { keyProperties.append("none"); } else { keyProperties.append(ctx.getJ2EEApplication()); } keyProperties.append(",J2EEServer="); if (ctx == null) { keyProperties.append("none"); } else { keyProperties.append(ctx.getJ2EEServer()); } return keyProperties.toString(); }

public ValueExpression setVariable(String variable, ValueExpression expression) { if (vars == null) vars = new HashMap<String, ValueExpression>(); return vars.put(variable, expression); }	@Override public Class<?> getType(ELContext context, Object base, Object property) throws NullPointerException, PropertyNotFoundException, ELException { if (context == null) { throw new NullPointerException(); } if (base == null) { context.setPropertyResolved(true); if (property != null) { try { Object obj = this.variableResolver.resolveVariable(property.toString()); return (obj != null) ? obj.getClass() : null; } catch (javax.servlet.jsp.el.ELException e) { throw new ELException(e.getMessage(), e.getCause()); } } } if (!context.isPropertyResolved()) { return getDefaultResolver().getType(context, base, property); } return null; }	@Override public ValueExpression setVariable(String variable, ValueExpression expression) { if (vars == null) vars = new HashMap<String, ValueExpression>(); return vars.put(variable, expression); }	@Override public Class<?> getCommonPropertyType(ELContext context, Object base) { if (base == null) { return String.class; } return getDefaultResolver().getCommonPropertyType(context, base); }	@Override public void setValue(ELContext context, Object base, Object property, Object value) throws NullPointerException, PropertyNotFoundException, PropertyNotWritableException, ELException { if (context == null) { throw new NullPointerException(); } if (base == null) { context.setPropertyResolved(true); throw new PropertyNotWritableException("Legacy VariableResolver wrapped, not writable"); } if (!context.isPropertyResolved()) { getDefaultResolver().setValue(context, base, property, value); } }
protected List<Session> getSessionsForPath(String path, StringManager smClient) { if ((path == null) || (!path.startsWith("/") && path.equals(""))) { throw new IllegalArgumentException(smClient.getString("managerServlet.invalidPath", RequestUtil.filter(path))); } String searchPath = path; if (path.equals("/")) searchPath = ""; Context ctxt = (Context) host.findChild(searchPath); if (null == ctxt) { throw new IllegalArgumentException(smClient.getString("managerServlet.noContext", RequestUtil.filter(path))); } Manager manager = ctxt.getManager(); List<Session> sessions = new ArrayList<Session>(); sessions.addAll(Arrays.asList(manager.findSessions())); if (manager instanceof BackupManager && showProxySessions) { Set<String> sessionIds = ((BackupManager) manager).getSessionIdsFull(); for (Session session : sessions) { sessionIds.remove(session.getId()); } for (String sessionId : sessionIds) { sessions.add(new DummyProxySession(sessionId)); } } return sessions; }	@Override public ClusterManager cloneFromTemplate() { BackupManager result = new BackupManager(); result.mExpireSessionsOnShutdown = mExpireSessionsOnShutdown; result.name = "Clone-from-" + name; result.cluster = cluster; result.notifyListenersOnReplication = notifyListenersOnReplication; result.mapSendOptions = mapSendOptions; result.maxActiveSessions = maxActiveSessions; return result; }	public int getActiveSessionsFull() { LazyReplicatedMap map = (LazyReplicatedMap) sessions; return map.sizeFull(); }	public void list(HttpServletRequest request, HttpServletResponse response, String message, StringManager smClient) throws IOException { if (debug >= 1) log("list: Listing contexts for virtual host '" + host.getName() + "'"); PrintWriter writer = response.getWriter(); writer.print(Constants.HTML_HEADER_SECTION); Object[] args = new Object[2]; args[0] = request.getContextPath(); args[1] = smClient.getString("htmlManagerServlet.title"); writer.print(MessageFormat.format(Constants.BODY_HEADER_SECTION, args)); args = new Object[3]; args[0] = smClient.getString("htmlManagerServlet.messageLabel"); if (message == null || message.length() == 0) { args[1] = "OK"; } else { args[1] = RequestUtil.filter(message); } writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args)); args = new Object[9]; args[0] = smClient.getString("htmlManagerServlet.manager"); args[1] = response.encodeURL(request.getContextPath() + "/html/list"); args[2] = smClient.getString("htmlManagerServlet.list"); args[3] = response.encodeURL(request.getContextPath() + "/" + smClient.getString("htmlManagerServlet.helpHtmlManagerFile")); args[4] = smClient.getString("htmlManagerServlet.helpHtmlManager"); args[5] = response.encodeURL(request.getContextPath() + "/" + smClient.getString("htmlManagerServlet.helpManagerFile")); args[6] = smClient.getString("htmlManagerServlet.helpManager"); args[7] = response.encodeURL(request.getContextPath() + "/status"); args[8] = smClient.getString("statusServlet.title"); writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args)); args = new Object[6]; args[0] = smClient.getString("htmlManagerServlet.appsTitle"); args[1] = smClient.getString("htmlManagerServlet.appsPath"); args[2] = smClient.getString("htmlManagerServlet.appsName"); args[3] = smClient.getString("htmlManagerServlet.appsAvailable"); args[4] = smClient.getString("htmlManagerServlet.appsSessions"); args[5] = smClient.getString("htmlManagerServlet.appsTasks"); writer.print(MessageFormat.format(APPS_HEADER_SECTION, args)); // Apps Row Section Container[] children = host.findChildren(); String[] contextPaths = new String[children.length]; for (int i = 0; i < children.length; i++) contextPaths[i] = children[i].getName(); TreeMap<String, String> sortedContextPathsMap = new TreeMap<String, String>(); for (int i = 0; i < contextPaths.length; i++) { String displayPath = contextPaths[i]; sortedContextPathsMap.put(displayPath, contextPaths[i]); } String appsStart = smClient.getString("htmlManagerServlet.appsStart"); String appsStop = smClient.getString("htmlManagerServlet.appsStop"); String appsReload = smClient.getString("htmlManagerServlet.appsReload"); String appsUndeploy = smClient.getString("htmlManagerServlet.appsUndeploy"); String appsExpire = smClient.getString("htmlManagerServlet.appsExpire"); Iterator<Map.Entry<String, String>> iterator = sortedContextPathsMap.entrySet().iterator(); boolean isHighlighted = true; boolean isDeployed = true; String highlightColor = null; while (iterator.hasNext()) { isHighlighted = !isHighlighted; if (isHighlighted) { highlightColor = "#C3F3C3"; } else { highlightColor = "#FFFFFF"; } Map.Entry<String, String> entry = iterator.next(); String displayPath = entry.getKey(); String contextPath = entry.getValue(); Context ctxt = (Context) host.findChild(contextPath); if (displayPath.equals("")) { displayPath = "/"; } if (ctxt != null) { try { isDeployed = isDeployed(contextPath); } catch (Exception e) { isDeployed = false; } args = new Object[7]; args[0] = URL_ENCODER.encode(displayPath); args[1] = displayPath; args[2] = ctxt.getDisplayName(); if (args[2] == null) { args[2] = "&nbsp;"; } args[3] = new Boolean(ctxt.getAvailable()); args[4] = response.encodeURL(request.getContextPath() + "/html/sessions?path=" + URL_ENCODER.encode(displayPath)); Manager manager = ctxt.getManager(); if (manager instanceof BackupManager && showProxySessions) { args[5] = new Integer(((BackupManager) manager).getActiveSessionsFull()); } else if (ctxt.getManager() != null) { args[5] = new Integer(manager.getActiveSessions()); } else { args[5] = new Integer(0); } args[6] = highlightColor; writer.print(MessageFormat.format(APPS_ROW_DETAILS_SECTION, args)); args = new Object[14]; args[0] = response.encodeURL(request.getContextPath() + "/html/start?path=" + URL_ENCODER.encode(displayPath)); args[1] = appsStart; args[2] = response.encodeURL(request.getContextPath() + "/html/stop?path=" + URL_ENCODER.encode(displayPath)); args[3] = appsStop; args[4] = response.encodeURL(request.getContextPath() + "/html/reload?path=" + URL_ENCODER.encode(displayPath)); args[5] = appsReload; args[6] = response.encodeURL(request.getContextPath() + "/html/undeploy?path=" + URL_ENCODER.encode(displayPath)); args[7] = appsUndeploy; args[8] = response.encodeURL(request.getContextPath() + "/html/expire?path=" + URL_ENCODER.encode(displayPath)); args[9] = appsExpire; args[10] = smClient.getString("htmlManagerServlet.expire.explain"); if (manager == null) { args[11] = smClient.getString("htmlManagerServlet.noManager"); } else { args[11] = new Integer(ctxt.getManager().getMaxInactiveInterval() / 60); } args[12] = smClient.getString("htmlManagerServlet.expire.unit"); args[13] = highlightColor; if (ctxt.getName().equals(this.context.getName())) { writer.print(MessageFormat.format(MANAGER_APP_ROW_BUTTON_SECTION, args)); } else if (ctxt.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STARTED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (ctxt.getAvailable() && !isDeployed) { writer.print(MessageFormat.format(STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (!ctxt.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STOPPED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else { writer.print(MessageFormat.format(STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } } } args = new Object[7]; args[0] = smClient.getString("htmlManagerServlet.deployTitle"); args[1] = smClient.getString("htmlManagerServlet.deployServer"); args[2] = response.encodeURL(request.getContextPath() + "/html/deploy"); args[3] = smClient.getString("htmlManagerServlet.deployPath"); args[4] = smClient.getString("htmlManagerServlet.deployConfig"); args[5] = smClient.getString("htmlManagerServlet.deployWar"); args[6] = smClient.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(DEPLOY_SECTION, args)); args = new Object[4]; args[0] = smClient.getString("htmlManagerServlet.deployUpload"); args[1] = response.encodeURL(request.getContextPath() + "/html/upload"); args[2] = smClient.getString("htmlManagerServlet.deployUploadFile"); args[3] = smClient.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(UPLOAD_SECTION, args)); args = new Object[5]; args[0] = smClient.getString("htmlManagerServlet.diagnosticsTitle"); args[1] = smClient.getString("htmlManagerServlet.diagnosticsLeak"); args[2] = response.encodeURL(request.getContextPath() + "/html/findleaks"); args[3] = smClient.getString("htmlManagerServlet.diagnosticsLeakWarning"); args[4] = smClient.getString("htmlManagerServlet.diagnosticsLeakButton"); writer.print(MessageFormat.format(DIAGNOSTICS_SECTION, args)); args = new Object[7]; args[0] = smClient.getString("htmlManagerServlet.serverTitle"); args[1] = smClient.getString("htmlManagerServlet.serverVersion"); args[2] = smClient.getString("htmlManagerServlet.serverJVMVersion"); args[3] = smClient.getString("htmlManagerServlet.serverJVMVendor"); args[4] = smClient.getString("htmlManagerServlet.serverOSName"); args[5] = smClient.getString("htmlManagerServlet.serverOSVersion"); args[6] = smClient.getString("htmlManagerServlet.serverOSArch"); writer.print(MessageFormat.format(Constants.SERVER_HEADER_SECTION, args)); args = new Object[6]; args[0] = ServerInfo.getServerInfo(); args[1] = System.getProperty("java.runtime.version"); args[2] = System.getProperty("java.vm.vendor"); args[3] = System.getProperty("os.name"); args[4] = System.getProperty("os.version"); args[5] = System.getProperty("os.arch"); writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args)); writer.print(Constants.HTML_TAIL_SECTION); writer.flush(); writer.close(); }
protected Object lookup(Name name, boolean resolveLinks) throws NamingException { while ((!name.isEmpty()) && (name.get(0).length() == 0)) name = name.getSuffix(1); if (name.isEmpty()) { return new NamingContext(env, this.name, bindings); } NamingEntry entry = bindings.get(name.get(0)); if (entry == null) { throw new NameNotFoundException(sm.getString("namingContext.nameNotBound", name.get(0))); } if (name.size() > 1) { if (entry.type != NamingEntry.CONTEXT) { throw new NamingException(sm.getString("namingContext.contextExpected")); } return ((Context) entry.value).lookup(name.getSuffix(1)); } else { if ((resolveLinks) && (entry.type == NamingEntry.LINK_REF)) { String link = ((LinkRef) entry.value).getLinkName(); if (link.startsWith(".")) { return lookup(link.substring(1)); } else { return (new InitialContext(env)).lookup(link); } } else if (entry.type == NamingEntry.REFERENCE) { try { Object obj = NamingManager.getObjectInstance(entry.value, name, this, env); boolean singleton = Boolean.parseBoolean((String) ((ResourceRef) entry.value).get("singleton").getContent()); if (singleton) { entry.type = NamingEntry.ENTRY; entry.value = obj; } return obj; } catch (NamingException e) { throw e; } catch (Exception e) { log.warn(sm.getString("namingContext.failResolvingReference"), e); throw new NamingException(e.getMessage()); } } else { return entry.value; } } }
@Override public synchronized void run() { if (socket == null) return; try { drainSocket(); } catch (Exception x) { log.error("Unable to service bio socket"); } finally { try { socket.close(); } catch (Exception e) { /* Ignore */ } try { reader.close(); } catch (Exception e) { /* Ignore */ } reader = null; socket = null; } if (getTaskPool() != null) getTaskPool().returnWorker(this); }	public synchronized void serviceSocket(Socket socket, ObjectReader reader) { this.socket = socket; this.reader = reader; this.notify(); }	public void listen() throws Exception { if (doListen()) { log.warn("ServerSocket already started"); return; } setListen(true); while (doListen()) { Socket socket = null; if (getTaskPool().available() < 1) { if (log.isWarnEnabled()) log.warn("All BIO server replication threads are busy, unable to handle more requests until a thread is freed up."); } BioReplicationTask task = (BioReplicationTask) getTaskPool().getRxTask(); if (task == null) continue; try { socket = serverSocket.accept(); } catch (Exception x) { if (doListen()) throw x; } if (!doListen()) { task.setDoRun(false); task.serviceSocket(null, null); getExecutor().execute(task); break; } if (socket == null) continue; socket.setReceiveBufferSize(getRxBufSize()); socket.setSendBufferSize(getTxBufSize()); socket.setTcpNoDelay(getTcpNoDelay()); socket.setKeepAlive(getSoKeepAlive()); socket.setOOBInline(getOoBInline()); socket.setReuseAddress(getSoReuseAddress()); socket.setSoLinger(getSoLingerOn(), getSoLingerTime()); socket.setTrafficClass(getSoTrafficClass()); socket.setSoTimeout(getTimeout()); ObjectReader reader = new ObjectReader(socket); task.serviceSocket(socket, reader); } //while }
@Override public void addMapping(String mapping) { synchronized (mappings) { mappings.add(mapping); } fireContainerEvent(ADD_MAPPING_EVENT, mapping); }	@Override public void addWelcomeFile(String name) { synchronized (welcomeFilesLock) { if (replaceWelcomeFiles) { fireContainerEvent(CLEAR_WELCOME_FILES_EVENT, null); welcomeFiles = new String[0]; setReplaceWelcomeFiles(false); } String[] results = new String[welcomeFiles.length + 1]; for (int i = 0; i < welcomeFiles.length; i++) results[i] = welcomeFiles[i]; results[welcomeFiles.length] = name; welcomeFiles = results; } postWelcomeFiles(); fireContainerEvent(ADD_WELCOME_FILE_EVENT, name); }	@Override public void removeMapping(String mapping) { synchronized (mappings) { mappings.remove(mapping); } fireContainerEvent(REMOVE_MAPPING_EVENT, mapping); }	@Override public void removeWelcomeFile(String name) { synchronized (welcomeFilesLock) { int n = -1; for (int i = 0; i < welcomeFiles.length; i++) { if (welcomeFiles[i].equals(name)) { n = i; break; } } if (n < 0) return; int j = 0; String[] results = new String[welcomeFiles.length - 1]; for (int i = 0; i < welcomeFiles.length; i++) { if (i != n) results[j++] = welcomeFiles[i]; } welcomeFiles = results; } postWelcomeFiles(); fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name); }
@Override public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) { if (appContextProtection) { ImageIO.getCacheDirectory(); } if (gcDaemonProtection) { try { Class<?> clazz = Class.forName("sun.misc.GC"); Method method = clazz.getDeclaredMethod("requestLatency", new Class[] { long.class }); method.invoke(null, Long.valueOf(3600000)); } catch (ClassNotFoundException e) { if (System.getProperty("java.vendor").startsWith("Sun")) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } else { log.debug(sm.getString("jreLeakListener.gcDaemonFail"), e); } } catch (SecurityException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (NoSuchMethodException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (IllegalArgumentException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (IllegalAccessException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } catch (InvocationTargetException e) { log.error(sm.getString("jreLeakListener.gcDaemonFail"), e); } } if (keepAliveProtection) { try { Class.forName("sun.net.www.http.HttpClient"); } catch (ClassNotFoundException e) { if (System.getProperty("java.vendor").startsWith("Sun")) { log.error(sm.getString("jreLeakListener.keepAliveFail"), e); } else { log.debug(sm.getString("jreLeakListener.keepAliveFail"), e); } } } if (securityPolicyProtection) { try { Class<?> policyClass = Class.forName("javax.security.auth.Policy"); Method method = policyClass.getMethod("getPolicy"); method.invoke(null); } catch (ClassNotFoundException e) { // Ignore. The class is deprecated. } catch (SecurityException e) { // Ignore. Don't need call to getPolicy() to be successful, // just need to trigger static initializer. } catch (NoSuchMethodException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (IllegalArgumentException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (IllegalAccessException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } catch (InvocationTargetException e) { log.warn(sm.getString("jreLeakListener.authPolicyFail"), e); } } if (tokenPollerProtection) { java.security.Security.getProviders(); } if (urlCacheProtection) { try { // Doesn't matter that this JAR doesn't exist - just as long as URL url = new URL("jar:file://dummy.jar!/"); URLConnection uConn = url.openConnection(); uConn.setDefaultUseCaches(false); } catch (MalformedURLException e) { log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"), e); } catch (IOException e) { log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"), e); } } if (xmlParsingProtection) { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); try { factory.newDocumentBuilder(); } catch (ParserConfigurationException e) { log.error(sm.getString("jreLeakListener.xmlParseFail"), e); } } } }
@Override public void messageReceived(Serializable msg, Member sender) { RpcMessage rmsg = (RpcMessage) msg; RpcCollectorKey key = new RpcCollectorKey(rmsg.uuid); if (rmsg.reply) { RpcCollector collector = responseMap.get(key); if (collector == null) { callback.leftOver(rmsg.message, sender); } else { synchronized (collector) { if (responseMap.containsKey(key)) { if ((rmsg instanceof RpcMessage.NoRpcChannelReply)) collector.destcnt--; else collector.addResponse(rmsg.message, sender); if (collector.isComplete()) collector.notifyAll(); } else { if (!(rmsg instanceof RpcMessage.NoRpcChannelReply)) callback.leftOver(rmsg.message, sender); } } //synchronized } //end if } else { Serializable reply = callback.replyRequest(rmsg.message, sender); rmsg.reply = true; rmsg.message = reply; try { channel.send(new Member[] { sender }, rmsg, 0); } catch (Exception x) { log.error("Unable to send back reply in RpcChannel.", x); } } //end if }	public void setRpcId(byte[] rpcId) { this.rpcId = rpcId; }
public void processExpires() { String[] keys = null; if (!getState().isAvailable()) { return; } try { keys = keys(); } catch (IOException e) { manager.getContainer().getLogger().error("Error getting keys", e); return; } if (manager.getContainer().getLogger().isDebugEnabled()) { manager.getContainer().getLogger().debug(getStoreName() + ": processExpires check number of " + keys.length + " sessions"); } long timeNow = System.currentTimeMillis(); for (int i = 0; i < keys.length; i++) { try { StandardSession session = (StandardSession) load(keys[i]); if (session == null) { continue; } int timeIdle = (int) ((timeNow - session.getThisAccessedTime()) / 1000L); if (timeIdle < session.getMaxInactiveInterval()) { continue; } if (manager.getContainer().getLogger().isDebugEnabled()) { manager.getContainer().getLogger().debug(getStoreName() + ": processExpires expire store session " + keys[i]); } if (((PersistentManagerBase) manager).isLoaded(keys[i])) { session.recycle(); } else { session.expire(); } remove(keys[i]); } catch (Exception e) { manager.getContainer().getLogger().error("Session: " + keys[i] + "; ", e); try { remove(keys[i]); } catch (IOException e2) { manager.getContainer().getLogger().error("Error removing key", e2); } } } }
@Override public final synchronized void destroy() throws LifecycleException { if (LifecycleState.DESTROYED.equals(state)) { if (log.isDebugEnabled()) { Exception e = new LifecycleException(); log.debug(sm.getString("lifecycleBase.alreadyDestroyed", toString()), e); } else if (log.isInfoEnabled()) { log.info(sm.getString("lifecycleBase.alreadyDestroyed", toString())); } return; } if (!state.equals(LifecycleState.STOPPED) && !state.equals(LifecycleState.FAILED) && !state.equals(LifecycleState.NEW)) { invalidTransition(Lifecycle.DESTROY_EVENT); } destroyInternal(); setState(LifecycleState.DESTROYED); }	@Override public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) { synchronized (lock) { init(); if (aprAvailable) { try { initializeSSL(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.info(sm.getString("aprListener.sslInit")); } } } } else if (Lifecycle.DESTROY_EVENT.equals(event.getType())) { synchronized (lock) { if (!aprAvailable) { return; } try { terminateAPR(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.info(sm.getString("aprListener.aprDestroy")); } } } }	@Override public void lifecycleEvent(LifecycleEvent event) { try { context = (Context) event.getLifecycle(); } catch (ClassCastException e) { log.error(sm.getString("contextConfig.cce", event.getLifecycle()), e); return; } if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) { configureStart(); } else if (event.getType().equals(Lifecycle.BEFORE_START_EVENT)) { beforeStart(); } else if (event.getType().equals(Lifecycle.AFTER_START_EVENT)) { if (originalDocBase != null) { String docBase = context.getDocBase(); context.setDocBase(originalDocBase); originalDocBase = docBase; } } else if (event.getType().equals(Lifecycle.CONFIGURE_STOP_EVENT)) { if (originalDocBase != null) { String docBase = context.getDocBase(); context.setDocBase(originalDocBase); originalDocBase = docBase; } configureStop(); } else if (event.getType().equals(Lifecycle.AFTER_INIT_EVENT)) { init(); } else if (event.getType().equals(Lifecycle.DESTROY_EVENT)) { destroy(); } }	@Override public void removeChild(Container child) { if (child == null) { return; } synchronized (children) { if (children.get(child.getName()) == null) return; children.remove(child.getName()); } try { if (child.getState().isAvailable()) { child.stop(); } } catch (LifecycleException e) { log.error("ContainerBase.removeChild: stop: ", e); } fireContainerEvent(REMOVE_CHILD_EVENT, child); child.setParent(null); try { child.destroy(); } catch (LifecycleException e) { log.error("ContainerBase.removeChild: destroy: ", e); } }
protected void registerClusterValve() throws Exception { if (container != null) { for (Iterator<Valve> iter = valves.iterator(); iter.hasNext(); ) { ClusterValve valve = (ClusterValve) iter.next(); if (log.isDebugEnabled()) log.debug("Invoking addValve on " + getContainer() + " with class=" + valve.getClass().getName()); if (valve != null) { IntrospectionUtils.callMethodN(getContainer(), "addValve", new Object[] { valve }, new Class[] { org.apache.catalina.Valve.class }); } valve.setCluster(this); } } }	public Map<String, ClusterManager> getManagers() { return managers; }	protected void unregisterClusterValve() throws Exception { for (Iterator<Valve> iter = valves.iterator(); iter.hasNext(); ) { ClusterValve valve = (ClusterValve) iter.next(); if (log.isDebugEnabled()) log.debug("Invoking removeValve on " + getContainer() + " with class=" + valve.getClass().getName()); if (valve != null) { IntrospectionUtils.callMethodN(getContainer(), "removeValve", new Object[] { valve }, new Class[] { org.apache.catalina.Valve.class }); } valve.setCluster(this); } }	public Log getLogger() { return log; }	public Manager getManager(String name) { return managers.get(name); }	public Iterator<String> getPropertyNames() { return properties.keySet().iterator(); }	public String getClusterName() { if (clusterName == null && container != null) return container.getName(); return clusterName; }	@Deprecated public String getManagerClassName() { return managerTemplate.getClass().getName(); }	public String getManagerName(String name, Manager manager) { String clusterName = name; if (clusterName == null) clusterName = manager.getContainer().getName(); if (getContainer() instanceof Engine) { Container context = manager.getContainer(); if (context != null && context instanceof Context) { Container host = ((Context) context).getParent(); if (host != null && host instanceof Host && clusterName != null && !(clusterName.indexOf("#") >= 0)) clusterName = host.getName() + "#" + clusterName; } } return clusterName; }	@Override public String toString() { StringBuilder sb = new StringBuilder(this.getClass().getName()); sb.append('['); if (container == null) { sb.append("Container is null"); } else { sb.append(container.getName()); } sb.append(']'); return sb.toString(); }	public boolean accept(Serializable msg, Member sender) { return (msg instanceof ClusterMessage); }	public Member[] getMembers() { return channel.getMembers(); }	public boolean setProperty(String name, Object value) { if (log.isTraceEnabled()) log.trace(sm.getString("SimpleTcpCluster.setProperty", name, value, properties.get(name))); properties.put(name, value); //using a dynamic way of setting properties is nice, but a security risk //if exposed through JMX. This way you can sit and try to guess property names, log.warn("Dynamic setProperty(" + name + ",value) has been disabled, please use explicit properties for the element you are trying to identify"); return false; }	public boolean setProperty(String name, String value) { return setProperty(name, (Object) value); }	public int getChannelSendOptions() { return channelSendOptions; }	public synchronized Manager createManager(String name) { if (log.isDebugEnabled()) log.debug("Creating ClusterManager for context " + name + " using class " + getManagerClassName()); Manager manager = null; try { manager = managerTemplate.cloneFromTemplate(); ((ClusterManager) manager).setName(name); } catch (Exception x) { log.error("Unable to clone cluster manager, defaulting to org.apache.catalina.ha.session.DeltaManager", x); manager = new org.apache.catalina.ha.session.DeltaManager(); } finally { if (manager != null && (manager instanceof ClusterManager)) ((ClusterManager) manager).setCluster(this); } return manager; }	public void addClusterListener(ClusterListener listener) { if (listener != null && !clusterListeners.contains(listener)) { clusterListeners.add(listener); listener.setCluster(this); } }	public ClusterListener[] findClusterListeners() { if (clusterListeners.size() > 0) { ClusterListener[] listener = new ClusterListener[clusterListeners.size()]; clusterListeners.toArray(listener); return listener; } else return new ClusterListener[0]; }	public void backgroundProcess() { if (clusterDeployer != null) clusterDeployer.backgroundProcess(); if (isHeartbeatBackgroundEnabled() && channel != null) channel.heartbeat(); }	void memberAdded(Member member) { try { hasMembers = channel.hasMembers(); if (log.isInfoEnabled()) log.info("Replication member added:" + member); fireLifecycleEvent(BEFORE_MEMBERREGISTER_EVENT, member); fireLifecycleEvent(AFTER_MEMBERREGISTER_EVENT, member); } catch (Exception x) { log.error("Unable to connect to replication system.", x); } }	public void memberDisappeared(Member member) { try { hasMembers = channel.hasMembers(); if (log.isInfoEnabled()) log.info("Received member disappeared:" + member); fireLifecycleEvent(BEFORE_MEMBERUNREGISTER_EVENT, member); fireLifecycleEvent(AFTER_MEMBERUNREGISTER_EVENT, member); } catch (Exception x) { log.error("Unable remove cluster node from replication system.", x); } }	public void messageReceived(ClusterMessage message) { if (log.isDebugEnabled() && message != null) log.debug("Assuming clocks are synched: Replication for " + message.getUniqueId() + " took=" + (System.currentTimeMillis() - (message).getTimestamp()) + " ms."); boolean accepted = false; if (message != null) { for (Iterator<ClusterListener> iter = clusterListeners.iterator(); iter.hasNext(); ) { ClusterListener listener = iter.next(); if (listener.accept(message)) { accepted = true; listener.messageReceived(message); } } } if (!accepted && log.isDebugEnabled()) { if (notifyLifecycleListenerOnFailure) { Member dest = message.getAddress(); fireLifecycleEvent(RECEIVE_MESSAGE_FAILURE_EVENT, new SendMessageData(message, dest, null)); } log.debug("Message " + message.toString() + " from type " + message.getClass().getName() + " transfered but no listener registered"); } return; }	public org.apache.catalina.ha.ClusterDeployer getClusterDeployer() { return clusterDeployer; }	@Override public void removeManager(Manager manager) { if (manager != null && manager instanceof ClusterManager) { ClusterManager cmgr = (ClusterManager) manager; fireLifecycleEvent(BEFORE_MANAGERUNREGISTER_EVENT, manager); managers.remove(getManagerName(cmgr.getName(), manager)); cmgr.setCluster(null); fireLifecycleEvent(AFTER_MANAGERUNREGISTER_EVENT, manager); } }	public void send(ClusterMessage msg) { send(msg, null); }	public void setChannelSendOptions(int channelSendOptions) { this.channelSendOptions = channelSendOptions; }	public void setClusterDeployer(org.apache.catalina.ha.ClusterDeployer clusterDeployer) { this.clusterDeployer = clusterDeployer; }	public void setClusterName(String clusterName) { this.clusterName = clusterName; }	public void setContainer(Container container) { Container oldContainer = this.container; this.container = container; support.firePropertyChange("container", oldContainer, this.container); }	public void setHeartbeatBackgroundEnabled(boolean heartbeatBackgroundEnabled) { this.heartbeatBackgroundEnabled = heartbeatBackgroundEnabled; }	@Deprecated public void setManagerClassName(String managerClassName) { log.warn("setManagerClassName is deprecated, use nested <Manager> element inside the <Cluster> element instead, this request will be ignored."); }	public void setProtocol(String protocol) { }
private void configure() { Timestamp ts = new Timestamp(System.currentTimeMillis()); String tsString = ts.toString().substring(0, 19); date = tsString.substring(0, 10); String className = this.getClass().getName(); ClassLoader cl = Thread.currentThread().getContextClassLoader(); if (directory == null) directory = getProperty(className + ".directory", "logs"); if (prefix == null) prefix = getProperty(className + ".prefix", "juli."); if (suffix == null) suffix = getProperty(className + ".suffix", ".log"); String sBufferSize = getProperty(className + ".bufferSize", String.valueOf(bufferSize)); try { bufferSize = Integer.parseInt(sBufferSize); } catch (NumberFormatException ignore) { //no op } String encoding = getProperty(className + ".encoding", null); if (encoding != null && encoding.length() > 0) { try { setEncoding(encoding); } catch (UnsupportedEncodingException ex) { // Ignore } } setLevel(Level.parse(getProperty(className + ".level", "" + Level.ALL))); String filterName = getProperty(className + ".filter", null); if (filterName != null) { try { setFilter((Filter) cl.loadClass(filterName).newInstance()); } catch (Exception e) { // Ignore } } String formatterName = getProperty(className + ".formatter", null); if (formatterName != null) { try { setFormatter((Formatter) cl.loadClass(formatterName).newInstance()); } catch (Exception e) { // Ignore } } else { setFormatter(new SimpleFormatter()); } setErrorManager(new ErrorManager()); }	protected void openWriter() { File dir = new File(directory); dir.mkdirs(); writerLock.writeLock().lock(); try { String pathname = dir.getAbsolutePath() + File.separator + prefix + date + suffix; String encoding = getEncoding(); FileOutputStream fos = new FileOutputStream(pathname, true); OutputStream os = bufferSize > 0 ? new BufferedOutputStream(fos, bufferSize) : fos; writer = new PrintWriter((encoding != null) ? new OutputStreamWriter(os, encoding) : new OutputStreamWriter(os), false); writer.write(getFormatter().getHead(this)); } catch (Exception e) { reportError(null, e, ErrorManager.OPEN_FAILURE); writer = null; } finally { writerLock.writeLock().unlock(); } }	@Override public void publish(LogRecord record) { if (!isLoggable(record)) { return; } Timestamp ts = new Timestamp(System.currentTimeMillis()); String tsString = ts.toString().substring(0, 19); String tsDate = tsString.substring(0, 10); writerLock.readLock().lock(); if (!date.equals(tsDate)) { writerLock.readLock().unlock(); writerLock.writeLock().lock(); try { if (!date.equals(tsDate)) { closeWriter(); date = tsDate; openWriter(); } // Down grade to read-lock. This ensures the writer remains valid writerLock.readLock().lock(); } finally { writerLock.writeLock().unlock(); } } try { String result = null; try { result = getFormatter().format(record); } catch (Exception e) { reportError(null, e, ErrorManager.FORMAT_FAILURE); return; } try { if (writer != null) { writer.write(result); if (bufferSize < 0) { writer.flush(); } } else { reportError("FileHandler is closed or not yet initialized, unable to log [" + result + "]", null, ErrorManager.WRITE_FAILURE); } } catch (Exception e) { reportError(null, e, ErrorManager.WRITE_FAILURE); return; } } finally { writerLock.readLock().unlock(); } }
private void findDefaultHost() { Engine engine = (Engine) connector.getService().getContainer(); String defaultHost = engine.getDefaultHost(); boolean found = false; if (defaultHost != null && defaultHost.length() > 0) { Container[] containers = engine.findChildren(); for (Container container : containers) { Host host = (Host) container; if (defaultHost.equalsIgnoreCase(host.getName())) { found = true; break; } String[] aliases = host.findAliases(); for (String alias : aliases) { if (defaultHost.equalsIgnoreCase(alias)) { found = true; break; } } } } if (found) { mapper.setDefaultHostName(defaultHost); } else { log.warn(sm.getString("mapperListener.unknownDefaultHost", defaultHost)); } }	private void registerContext(Context context) { String contextName = context.getName(); if ("/".equals(contextName)) { contextName = ""; } Container host = context.getParent(); javax.naming.Context resources = context.getResources(); String[] welcomeFiles = context.findWelcomeFiles(); mapper.addContext(host.getName(), host, contextName, context, welcomeFiles, resources); context.addContainerListener(this); for (Container container : context.findChildren()) { registerWrapper((Wrapper) container); } if (log.isDebugEnabled()) { log.debug(sm.getString("mapperListener.registerContext", contextName)); } }	private void registerHost(Host host) { String[] aliases = host.findAliases(); mapper.addHost(host.getName(), aliases, host); host.addContainerListener(this); for (Container container : host.findChildren()) { registerContext((Context) container); } if (log.isDebugEnabled()) { log.debug(sm.getString("mapperListener.registerHost", host.getName(), domain)); } }	private void registerWrapper(Wrapper wrapper) { String wrapperName = wrapper.getName(); String contextName = wrapper.getParent().getName(); if ("/".equals(contextName)) { contextName = ""; } String hostName = wrapper.getParent().getParent().getName(); String[] mappings = wrapper.findMappings(); for (String mapping : mappings) { boolean jspWildCard = (wrapperName.equals("jsp") && mapping.endsWith("/*")); mapper.addWrapper(hostName, contextName, mapping, wrapper, jspWildCard); } wrapper.addContainerListener(this); if (log.isDebugEnabled()) { log.debug(sm.getString("mapperListener.registerWrapper", wrapperName, contextName)); } }	private void unregisterContext(Context context) { if (context.getPaused()) { return; } String contextName = context.getName(); if ("/".equals(contextName)) { contextName = ""; } String hostName = context.getParent().getName(); if (log.isDebugEnabled()) log.debug(sm.getString("mapperListener.unregisterContext", contextName)); mapper.removeContext(hostName, contextName); }	private void unregisterHost(Host host) { String hostname = host.getName(); mapper.removeHost(hostname); if (log.isDebugEnabled()) log.debug(sm.getString("mapperListener.unregisterHost", hostname, domain)); }	private void unregisterWrapper(Wrapper wrapper) { String contextName = wrapper.getParent().getName(); if ("/".equals(contextName)) { contextName = ""; } String hostName = wrapper.getParent().getParent().getName(); String[] mappings = wrapper.findMappings(); for (String mapping : mappings) { mapper.removeWrapper(hostName, contextName, mapping); } }	public void containerEvent(ContainerEvent event) { if (event.getType() == Container.ADD_CHILD_EVENT) { Container child = (Container) event.getData(); child.addLifecycleListener(this); child.addContainerListener(this); if (child instanceof Host) { registerHost((Host) child); } else if (child instanceof Context) { registerContext((Context) child); } else if (child instanceof Wrapper) { registerWrapper((Wrapper) child); } } else if (event.getType() == Container.REMOVE_CHILD_EVENT) { Container child = (Container) event.getData(); removeListeners(child); if (child instanceof Host) { unregisterHost((Host) child); } else if (child instanceof Context) { unregisterContext((Context) child); } else if (child instanceof Wrapper) { unregisterWrapper((Wrapper) child); } } else if (event.getType() == Host.ADD_ALIAS_EVENT) { mapper.addHostAlias(((Host) event.getSource()).getName(), event.getData().toString()); } else if (event.getType() == Host.REMOVE_ALIAS_EVENT) { mapper.removeHostAlias(event.getData().toString()); } else if (event.getType() == Wrapper.ADD_MAPPING_EVENT) { Wrapper wrapper = (Wrapper) event.getSource(); String contextName = wrapper.getParent().getName(); if ("/".equals(contextName)) { contextName = ""; } String hostName = wrapper.getParent().getParent().getName(); String mapping = (String) event.getData(); boolean jspWildCard = ("jsp".equals(wrapper.getName()) && mapping.endsWith("/*")); mapper.addWrapper(hostName, contextName, mapping, wrapper, jspWildCard); } else if (event.getType() == Wrapper.REMOVE_MAPPING_EVENT) { Wrapper wrapper = (Wrapper) event.getSource(); String contextName = wrapper.getParent().getName(); if ("/".equals(contextName)) { contextName = ""; } String hostName = wrapper.getParent().getParent().getName(); String mapping = (String) event.getData(); mapper.removeWrapper(hostName, contextName, mapping); } else if (event.getType() == Context.ADD_WELCOME_FILE_EVENT) { Context context = (Context) event.getSource(); String hostName = context.getParent().getName(); String contextName = context.getName(); if ("/".equals(contextName)) { contextName = ""; } String welcomeFile = (String) event.getData(); mapper.addWelcomeFile(hostName, contextName, welcomeFile); } else if (event.getType() == Context.REMOVE_WELCOME_FILE_EVENT) { Context context = (Context) event.getSource(); String hostName = context.getParent().getName(); String contextName = context.getName(); if ("/".equals(contextName)) { contextName = ""; } String welcomeFile = (String) event.getData(); mapper.removeWelcomeFile(hostName, contextName, welcomeFile); } else if (event.getType() == Context.CLEAR_WELCOME_FILES_EVENT) { Context context = (Context) event.getSource(); String hostName = context.getParent().getName(); String contextName = context.getName(); if ("/".equals(contextName)) { contextName = ""; } mapper.clearWelcomeFiles(hostName, contextName); } }	public void destroy() { // NO-OP? }	public void init() { // Find any components that have already been initialized since the // MBean listener won't be notified as those components will have findDefaultHost(); Engine engine = (Engine) connector.getService().getContainer(); engine.addContainerListener(this); Container[] conHosts = engine.findChildren(); for (Container conHost : conHosts) { Host host = (Host) conHost; if (!LifecycleState.NEW.equals(host.getState())) { host.addLifecycleListener(this); registerHost(host); } } }	@Override public void lifecycleEvent(LifecycleEvent event) { if (event.getType() == Lifecycle.AFTER_START_EVENT) { Object obj = event.getSource(); if (obj instanceof Wrapper) { registerWrapper((Wrapper) obj); } else if (obj instanceof Context) { registerContext((Context) obj); } else if (obj instanceof Host) { registerHost((Host) obj); } } else if (event.getType() == Lifecycle.BEFORE_STOP_EVENT) { Object obj = event.getSource(); if (obj instanceof Wrapper) { unregisterWrapper((Wrapper) obj); } else if (obj instanceof Context) { unregisterContext((Context) obj); } else if (obj instanceof Host) { unregisterHost((Host) obj); } } }	public void removeLifeCycleListeners(String type) throws MBeanException { ContainerBase container = null; try { container = (ContainerBase) getManagedResource(); } catch (InstanceNotFoundException e) { throw new MBeanException(e); } catch (RuntimeOperationsException e) { throw new MBeanException(e); } catch (InvalidTargetObjectTypeException e) { throw new MBeanException(e); } LifecycleListener[] listeners = container.findLifecycleListeners(); for (LifecycleListener listener : listeners) { if (listener.getClass().equals(type)) { container.removeLifecycleListener(listener); } } }
protected Map<String, String> processAnnotationWebInitParams(ElementValue ev) { Map<String, String> result = new HashMap<String, String>(); if (ev instanceof ArrayElementValue) { ElementValue[] arrayValues = ((ArrayElementValue) ev).getElementValuesArray(); for (ElementValue value : arrayValues) { if (value instanceof AnnotationElementValue) { ElementValuePair[] evps = ((AnnotationElementValue) value).getAnnotationEntry().getElementValuePairs(); String initParamName = null; String initParamValue = null; for (ElementValuePair evp : evps) { if ("name".equals(evp.getNameString())) { initParamName = evp.getValue().stringifyValue(); } else if ("value".equals(evp.getNameString())) { initParamValue = evp.getValue().stringifyValue(); } else { // Ignore } } result.put(initParamName, initParamValue); } } } return result; }	protected void processAnnotationWebServlet(String className, AnnotationEntry ae, WebXml fragment) { String servletName = null; ElementValuePair[] evps = ae.getElementValuePairs(); for (ElementValuePair evp : evps) { String name = evp.getNameString(); if ("name".equals(name)) { servletName = evp.getValue().stringifyValue(); break; } } if (servletName == null) { servletName = className; } ServletDef servletDef = fragment.getServlets().get(servletName); boolean isWebXMLservletDef = servletDef != null; if (!isWebXMLservletDef) { servletDef = new ServletDef(); servletDef.setServletName(servletName); servletDef.setServletClass(className); } boolean urlPatternsSet = false; String[] urlPatterns = null; for (ElementValuePair evp : evps) { String name = evp.getNameString(); if ("value".equals(name) || "urlPatterns".equals(name)) { if (urlPatternsSet) { throw new IllegalArgumentException(sm.getString("contextConfig.urlPatternValue", className)); } urlPatternsSet = true; urlPatterns = processAnnotationsStringArray(evp.getValue()); } else if ("description".equals(name)) { if (servletDef.getDescription() == null) { servletDef.setDescription(evp.getValue().stringifyValue()); } } else if ("displayName".equals(name)) { if (servletDef.getDisplayName() == null) { servletDef.setDisplayName(evp.getValue().stringifyValue()); } } else if ("largeIcon".equals(name)) { if (servletDef.getLargeIcon() == null) { servletDef.setLargeIcon(evp.getValue().stringifyValue()); } } else if ("smallIcon".equals(name)) { if (servletDef.getSmallIcon() == null) { servletDef.setSmallIcon(evp.getValue().stringifyValue()); } } else if ("asyncSupported".equals(name)) { if (servletDef.getAsyncSupported() == null) { servletDef.setAsyncSupported(evp.getValue().stringifyValue()); } } else if ("loadOnStartup".equals(name)) { if (servletDef.getLoadOnStartup() == null) { servletDef.setLoadOnStartup(evp.getValue().stringifyValue()); } } else if ("initParams".equals(name)) { Map<String, String> initParams = processAnnotationWebInitParams(evp.getValue()); if (isWebXMLservletDef) { Map<String, String> webXMLInitParams = servletDef.getParameterMap(); for (Map.Entry<String, String> entry : initParams.entrySet()) { if (webXMLInitParams.get(entry.getKey()) == null) { servletDef.addInitParameter(entry.getKey(), entry.getValue()); } } } else { for (Map.Entry<String, String> entry : initParams.entrySet()) { servletDef.addInitParameter(entry.getKey(), entry.getValue()); } } } } if (!isWebXMLservletDef && urlPatterns != null) { fragment.addServlet(servletDef); } if (urlPatternsSet) { if (!fragment.getServletMappings().containsValue(servletName)) { for (String urlPattern : urlPatterns) { fragment.addServletMapping(urlPattern, servletName); } } } }
/** * Perform work as a particular </code>Subject</code>. Here the work * will be granted to a <code>null</code> subject. * * @param methodName the method to apply the security restriction * @param targetObject the <code>Servlet</code> on which the method will * be called. * @param targetArguments <code>Object</code> array contains the * runtime parameters instance. * @param principal the <code>Principal</code> to which the security * privilege applies */ private static void execute(final Method method, final Object targetObject, final Object[] targetArguments, Principal principal) throws java.lang.Exception{ try{ Subject subject = null; PrivilegedExceptionAction<Void> pea = new PrivilegedExceptionAction<Void>(){ } } }	public static void doAsPrivilege(final String methodName, final Filter targetObject, final Class<?>[] targetType, final Object[] targetArguments, Principal principal) throws java.lang.Exception { Method method = null; Method[] methodsCache = null; if (objectCache.containsKey(targetObject)) { methodsCache = objectCache.get(targetObject); method = findMethod(methodsCache, methodName); if (method == null) { method = createMethodAndCacheIt(methodsCache, methodName, targetObject, targetType); } } else { method = createMethodAndCacheIt(methodsCache, methodName, targetObject, targetType); } execute(method, targetObject, targetArguments, principal); }
public void removeHost(String name) throws Exception { ObjectName oname = new ObjectName(name); String hostName = oname.getKeyProperty("host"); Service service = getService(oname); Engine engine = (Engine) service.getContainer(); Host host = (Host) engine.findChild(hostName); if (host != null) { if (host instanceof StandardHost) ((StandardHost) host).destroy(); else engine.removeChild(host); } }
@Override public Object getValue(EvaluationContext ctx) throws ELException { StringBuilder sb = new StringBuilder(16); Object obj = null; if (this.children != null) { for (int i = 0; i < this.children.length; i++) { obj = this.children[i].getValue(ctx); if (obj != null) { sb.append(obj); } } } return sb.toString(); }	public void testBug49345() { ExpressionFactory factory = ExpressionFactory.newInstance(); ELContext context = new ELContextImpl(); TesterBeanA beanA = new TesterBeanA(); TesterBeanB beanB = new TesterBeanB(); beanB.setName("Tomcat"); beanA.setBean(beanB); ValueExpression var = factory.createValueExpression(beanA, TesterBeanA.class); context.getVariableMapper().setVariable("beanA", var); ValueExpression ve = factory.createValueExpression(context, "${beanA.bean.name}", String.class); String result = (String) ve.getValue(context); assertEquals("Tomcat", result); ValueReference vr = ve.getValueReference(context); assertNotNull(vr); assertEquals(beanB, vr.getBase()); assertEquals("name", vr.getProperty()); }
private String extractFilename(String cd) { String fileName = null; if (cd != null) { String cdl = cd.toLowerCase(Locale.ENGLISH); if (cdl.startsWith("form-data") || cdl.startsWith("attachment")) { ParameterParser parser = new ParameterParser(); parser.setLowerCaseNames(true); Map<String, String> params = parser.parse(cd, ';'); if (params.containsKey("filename")) { fileName = params.get("filename"); if (fileName != null) { fileName = fileName.trim(); } else { // Even if there is no value, the parameter is present, // so we return an empty file name rather than no file fileName = ""; } } } } return fileName; }	protected Session getSessionForPathAndId(String path, String id) throws IOException { if ((path == null) || (!path.startsWith("/") && path.equals(""))) { throw new IllegalArgumentException(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); } String searchPath = path; if (path.equals("/")) searchPath = ""; Context ctxt = (Context) host.findChild(searchPath); if (null == ctxt) { throw new IllegalArgumentException(sm.getString("managerServlet.noContext", RequestUtil.filter(path))); } Session session = ctxt.getManager().findSession(id); return session; }	protected String deployInternal(String config, String path, String war) { StringWriter stringWriter = new StringWriter(); PrintWriter printWriter = new PrintWriter(stringWriter); super.deploy(printWriter, config, path, war, false); return stringWriter.toString(); }	protected String expireSessions(String path, HttpServletRequest req) { int idle = -1; String idleParam = req.getParameter("idle"); if (idleParam != null) { try { idle = Integer.parseInt(idleParam); } catch (NumberFormatException e) { log("Could not parse idle parameter to an int: " + idleParam); } } return sessions(path, idle); }	protected String findleaks() { StringBuilder msg = new StringBuilder(); StringWriter stringWriter = new StringWriter(); PrintWriter printWriter = new PrintWriter(stringWriter); super.findleaks(printWriter); if (stringWriter.getBuffer().length() > 0) { msg.append(sm.getString("htmlManagerServlet.findleaksList")); msg.append(stringWriter.toString()); } else { msg.append(sm.getString("htmlManagerServlet.findleaksNone")); } return msg.toString(); }	protected String generateNonce() { byte[] random = new byte[16]; StringBuilder buffer = new StringBuilder(); randomSource.nextBytes(random); for (int j = 0; j < random.length; j++) { byte b1 = (byte) ((random[j] & 0xf0) >> 4); byte b2 = (byte) (random[j] & 0x0f); if (b1 < 10) buffer.append((char) ('0' + b1)); else buffer.append((char) ('A' + (b1 - 10))); if (b2 < 10) buffer.append((char) ('0' + b2)); else buffer.append((char) ('A' + (b2 - 10))); } return buffer.toString(); }	protected String reload(String path) { StringWriter stringWriter = new StringWriter(); PrintWriter printWriter = new PrintWriter(stringWriter); super.reload(printWriter, path); return stringWriter.toString(); }	protected String stop(String path) { StringWriter stringWriter = new StringWriter(); PrintWriter printWriter = new PrintWriter(stringWriter); super.stop(printWriter, path); return stringWriter.toString(); }	protected String undeploy(String path) { StringWriter stringWriter = new StringWriter(); PrintWriter printWriter = new PrintWriter(stringWriter); super.undeploy(printWriter, path); return stringWriter.toString(); }	protected String upload(HttpServletRequest request) throws IOException, ServletException { String message = ""; Part warPart = null; String filename = null; String basename = null; Collection<Part> parts = request.getParts(); Iterator<Part> iter = parts.iterator(); try { while (iter.hasNext()) { Part part = iter.next(); if (part.getName().equals("deployWar") && warPart == null) { warPart = part; } else { part.delete(); } } while (true) { if (warPart == null) { message = sm.getString("htmlManagerServlet.deployUploadNoFile"); break; } filename = extractFilename(warPart.getHeader("Content-Disposition")); if (!filename.toLowerCase(Locale.ENGLISH).endsWith(".war")) { message = sm.getString("htmlManagerServlet.deployUploadNotWar", filename); break; } if (filename.lastIndexOf('\\') >= 0) { filename = filename.substring(filename.lastIndexOf('\\') + 1); } if (filename.lastIndexOf('/') >= 0) { filename = filename.substring(filename.lastIndexOf('/') + 1); } // Identify the appBase of the owning Host of this Context basename = filename.substring(0, filename.toLowerCase(Locale.ENGLISH).indexOf(".war")); File file = new File(getAppBase(), filename); if (file.exists()) { message = sm.getString("htmlManagerServlet.deployUploadWarExists", filename); break; } String path = null; if (basename.equals("ROOT")) { path = ""; } else { path = "/" + basename.replace('#', '/'); } if ((host.findChild(path) != null) && !isDeployed(path)) { message = sm.getString("htmlManagerServlet.deployUploadInServerXml", filename); break; } if (!isServiced(path)) { addServiced(path); try { warPart.write(file.getAbsolutePath()); check(path); } finally { removeServiced(path); } } break; } } catch (Exception e) { message = sm.getString("htmlManagerServlet.deployUploadFail", e.getMessage()); log(message, e); } finally { if (warPart != null) { warPart.delete(); } warPart = null; } return message; }	protected synchronized void deploy(PrintWriter writer, String path, String tag, boolean update, HttpServletRequest request) { if (debug >= 1) { log("deploy: Deploying web application at '" + path + "'"); } if ((path == null) || path.length() == 0 || !path.startsWith("/")) { writer.println(sm.getString("managerServlet.invalidPath", path)); return; } String displayPath = path; if (path.equals("/")) path = ""; String basename = getDocBase(path); Context context = (Context) host.findChild(path); if (update) { if (context != null) { undeploy(writer, displayPath); } context = (Context) host.findChild(path); } if (context != null) { writer.println(sm.getString("managerServlet.alreadyContext", displayPath)); return; } File deployedPath = deployed; if (tag != null) { deployedPath = new File(versioned, tag); deployedPath.mkdirs(); } File localWar = new File(deployedPath, basename + ".war"); if (debug >= 2) { log("Uploading WAR file to " + localWar); } try { if (!isServiced(path)) { addServiced(path); try { uploadWar(request, localWar); if (tag != null) { deployedPath = deployed; File localWarCopy = new File(deployedPath, basename + ".war"); copy(localWar, localWarCopy); localWar = localWarCopy; copy(localWar, new File(getAppBase(), basename + ".war")); } check(path); } finally { removeServiced(path); } } } catch (Exception e) { log("managerServlet.check[" + displayPath + "]", e); writer.println(sm.getString("managerServlet.exception", e.toString())); return; } context = (Context) host.findChild(path); if (context != null && context.getConfigured()) { writer.println(sm.getString("managerServlet.deployed", displayPath)); } else { writer.println(sm.getString("managerServlet.deployFailed", displayPath)); } }	protected void deploy(PrintWriter writer, String config, String path, String war, boolean update) { if (config != null && config.length() == 0) { config = null; } if (war != null && war.length() == 0) { war = null; } if (debug >= 1) { if (config != null && config.length() > 0) { if (war != null) { log("install: Installing context configuration at '" + config + "' from '" + war + "'"); } else { log("install: Installing context configuration at '" + config + "'"); } } else { if (path != null && path.length() > 0) { log("install: Installing web application at '" + path + "' from '" + war + "'"); } else { log("install: Installing web application from '" + war + "'"); } } } if (path == null || path.length() == 0 || !path.startsWith("/")) { writer.println(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); return; } String displayPath = path; if ("/".equals(path)) { path = ""; } Context context = (Context) host.findChild(path); if (update) { if (context != null) { undeploy(writer, displayPath); } context = (Context) host.findChild(path); } if (context != null) { writer.println(sm.getString("managerServlet.alreadyContext", displayPath)); return; } if (config != null && (config.startsWith("file:"))) { config = config.substring("file:".length()); } if (war != null && (war.startsWith("file:"))) { war = war.substring("file:".length()); } try { if (!isServiced(path)) { addServiced(path); try { if (config != null) { configBase.mkdirs(); copy(new File(config), new File(configBase, getConfigFile(path) + ".xml")); } if (war != null) { if (war.endsWith(".war")) { copy(new File(war), new File(getAppBase(), getDocBase(path) + ".war")); } else { copy(new File(war), new File(getAppBase(), getDocBase(path))); } } check(path); } finally { removeServiced(path); } } context = (Context) host.findChild(path); if (context != null && context.getConfigured() && context.getAvailable()) { writer.println(sm.getString("managerServlet.deployed", displayPath)); } else if (context != null && !context.getAvailable()) { writer.println(sm.getString("managerServlet.deployedButNotStarted", displayPath)); } else { writer.println(sm.getString("managerServlet.deployFailed", displayPath)); } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log("ManagerServlet.install[" + displayPath + "]", t); writer.println(sm.getString("managerServlet.exception", t.toString())); } }	protected void deploy(PrintWriter writer, String path, String tag) { if ((path == null) || path.length() == 0 || !path.startsWith("/")) { writer.println(sm.getString("managerServlet.invalidPath", path)); return; } String displayPath = path; if (path.equals("/")) path = ""; File deployedPath = versioned; if (tag != null) { deployedPath = new File(deployedPath, tag); } File localWar = new File(deployedPath, getDocBase(path) + ".war"); Context context = (Context) host.findChild(path); if (context != null) { undeploy(writer, displayPath); } try { if (!isServiced(path)) { addServiced(path); try { copy(localWar, new File(getAppBase(), getDocBase(path) + ".war")); check(path); } finally { removeServiced(path); } } } catch (Exception e) { log("managerServlet.check[" + displayPath + "]", e); writer.println(sm.getString("managerServlet.exception", e.toString())); return; } context = (Context) host.findChild(path); if (context != null && context.getConfigured()) { writer.println(sm.getString("managerServlet.deployed", displayPath)); } else { writer.println(sm.getString("managerServlet.deployFailed", displayPath)); } }	protected void displaySessionDetailPage(HttpServletRequest req, HttpServletResponse resp, String path, String sessionId) throws ServletException, IOException { Session session = getSessionForPathAndId(path, sessionId); //strong>NOTE</strong> - This header will be overridden // automatically if a <code>RequestDispatcher.forward()</code> call is // ultimately invoked. resp.setHeader("Pragma", "No-cache"); resp.setHeader("Cache-Control", "no-cache,no-store,max-age=0"); resp.setDateHeader("Expires", 0); req.setAttribute("currentSession", session); getServletContext().getRequestDispatcher(resp.encodeURL(sessionDetailJspPath)).include(req, resp); }	protected void displaySessionsListPage(String path, HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { List<Session> sessions = getSessionsForPath(path); String sortBy = req.getParameter("sort"); String orderBy = null; if (null != sortBy && !"".equals(sortBy.trim())) { Comparator<Session> comparator = getComparator(sortBy); if (comparator != null) { orderBy = req.getParameter("order"); if ("DESC".equalsIgnoreCase(orderBy)) { comparator = new ReverseComparator(comparator); // orderBy = "ASC"; } else { //orderBy = "DESC"; } try { Collections.sort(sessions, comparator); } catch (IllegalStateException ise) { req.setAttribute(APPLICATION_ERROR, "Can't sort session list: one session is invalidated"); } } else { log("WARNING: unknown sort order: " + sortBy); } } req.setAttribute("sort", sortBy); req.setAttribute("order", orderBy); req.setAttribute("activeSessions", sessions); //strong>NOTE</strong> - This header will be overridden // automatically if a <code>RequestDispatcher.forward()</code> call is // ultimately invoked. resp.setHeader("Pragma", "No-cache"); resp.setHeader("Cache-Control", "no-cache,no-store,max-age=0"); resp.setDateHeader("Expires", 0); getServletContext().getRequestDispatcher(sessionsListJspPath).include(req, resp); }	protected List<Session> getSessionsForPath(String path) { if ((path == null) || (!path.startsWith("/") && path.equals(""))) { throw new IllegalArgumentException(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); } String searchPath = path; if (path.equals("/")) searchPath = ""; Context ctxt = (Context) host.findChild(searchPath); if (null == ctxt) { throw new IllegalArgumentException(sm.getString("managerServlet.noContext", RequestUtil.filter(path))); } Manager manager = ctxt.getManager(); List<Session> sessions = new ArrayList<Session>(); sessions.addAll(Arrays.asList(manager.findSessions())); if (manager instanceof BackupManager && showProxySessions) { Set<String> sessionIds = ((BackupManager) manager).getSessionIdsFull(); for (Session session : sessions) { sessionIds.remove(session.getId()); } for (String sessionId : sessionIds) { sessions.add(new DummyProxySession(sessionId)); } } return sessions; }	protected void expireSessions(PrintWriter writer, String path, HttpServletRequest req) { int idle = -1; String idleParam = req.getParameter("idle"); if (idleParam != null) { try { idle = Integer.parseInt(idleParam); } catch (NumberFormatException e) { log("Could not parse idle parameter to an int: " + idleParam); } } sessions(writer, path, idle); }	protected void findleaks(PrintWriter writer) { if (!(host instanceof StandardHost)) { writer.println(sm.getString("managerServlet.findleaksFail")); return; } String[] results = ((StandardHost) host).findReloadedContextMemoryLeaks(); for (String result : results) { if ("".equals(result)) { result = "/"; } writer.println(result); } }	protected void list(PrintWriter writer) { if (debug >= 1) log("list: Listing contexts for virtual host '" + host.getName() + "'"); writer.println(sm.getString("managerServlet.listed", host.getName())); Container[] contexts = host.findChildren(); for (int i = 0; i < contexts.length; i++) { Context context = (Context) contexts[i]; if (context != null) { String displayPath = context.getPath(); if (displayPath.equals("")) displayPath = "/"; if (context.getAvailable()) { writer.println(sm.getString("managerServlet.listitem", displayPath, "running", "" + context.getManager().findSessions().length, context.getDocBase())); } else { writer.println(sm.getString("managerServlet.listitem", displayPath, "stopped", "0", context.getDocBase())); } } } }	protected void printResources(PrintWriter writer, String prefix, javax.naming.Context namingContext, String type, Class<?> clazz) { try { NamingEnumeration<Binding> items = namingContext.listBindings(""); while (items.hasMore()) { Binding item = items.next(); if (item.getObject() instanceof javax.naming.Context) { printResources(writer, prefix + item.getName() + "/", (javax.naming.Context) item.getObject(), type, clazz); } else { if ((clazz != null) && (!(clazz.isInstance(item.getObject())))) { continue; } writer.print(prefix + item.getName()); writer.print(':'); writer.print(item.getClassName()); writer.println(); } } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log("ManagerServlet.resources[" + type + "]", t); writer.println(sm.getString("managerServlet.exception", t.toString())); } }	protected void reload(PrintWriter writer, String path) { if (debug >= 1) log("restart: Reloading web application at '" + path + "'"); if ((path == null) || (!path.startsWith("/") && path.equals(""))) { writer.println(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); return; } String displayPath = path; if (path.equals("/")) path = ""; try { Context context = (Context) host.findChild(path); if (context == null) { writer.println(sm.getString("managerServlet.noContext", RequestUtil.filter(displayPath))); return; } if (context.getPath().equals(this.context.getPath())) { writer.println(sm.getString("managerServlet.noSelf")); return; } context.reload(); writer.println(sm.getString("managerServlet.reloaded", displayPath)); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log("ManagerServlet.reload[" + displayPath + "]", t); writer.println(sm.getString("managerServlet.exception", t.toString())); } }	protected void resources(PrintWriter writer, String type) { if (debug >= 1) { if (type != null) { log("resources: Listing resources of type " + type); } else { log("resources: Listing resources of all types"); } } if (global == null) { writer.println(sm.getString("managerServlet.noGlobal")); return; } if (type != null) { writer.println(sm.getString("managerServlet.resourcesType", type)); } else { writer.println(sm.getString("managerServlet.resourcesAll")); } Class<?> clazz = null; try { if (type != null) { clazz = Class.forName(type); } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log("ManagerServlet.resources[" + type + "]", t); writer.println(sm.getString("managerServlet.exception", t.toString())); return; } printResources(writer, "", global, type, clazz); }	protected void roles(PrintWriter writer) { if (debug >= 1) { log("roles: List security roles from user database"); } UserDatabase database = null; try { InitialContext ic = new InitialContext(); database = (UserDatabase) ic.lookup("java:comp/env/users"); } catch (NamingException e) { writer.println(sm.getString("managerServlet.userDatabaseError")); log("java:comp/env/users", e); return; } if (database == null) { writer.println(sm.getString("managerServlet.userDatabaseMissing")); return; } writer.println(sm.getString("managerServlet.rolesList")); Iterator<Role> roles = database.getRoles(); if (roles != null) { while (roles.hasNext()) { Role role = roles.next(); writer.print(role.getRolename()); writer.print(':'); if (role.getDescription() != null) { writer.print(role.getDescription()); } writer.println(); } } }	protected void serverinfo(PrintWriter writer) { if (debug >= 1) log("serverinfo"); try { StringBuilder props = new StringBuilder(); props.append("OK - Server info"); props.append("\nTomcat Version: "); props.append(ServerInfo.getServerInfo()); props.append("\nOS Name: "); props.append(System.getProperty("os.name")); props.append("\nOS Version: "); props.append(System.getProperty("os.version")); props.append("\nOS Architecture: "); props.append(System.getProperty("os.arch")); props.append("\nJVM Version: "); props.append(System.getProperty("java.runtime.version")); props.append("\nJVM Vendor: "); props.append(System.getProperty("java.vm.vendor")); writer.println(props.toString()); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getServletContext().log("ManagerServlet.serverinfo", t); writer.println(sm.getString("managerServlet.exception", t.toString())); } }	void sessions(PrintWriter writer, String path) { sessions(writer, path, -1); }	/** * Session information for the web application at the specified context path. * Displays a profile of session thisAccessedTime listing number * of sessions for each 10 minute interval up to 10 hours. * * @param writer Writer to render to * @param path Context path of the application to list session information for * @param idle Expire all sessions with idle time &gt; idle for this context */ protected void sessions(PrintWriter writer, String path, int idle) { if (debug >= 1) { log("sessions: Session information for web application at '" + path + "'"); if (idle >= 0) log("sessions: Session expiration for " + idle + " minutes '" + path + "'"); } if ((path == null) || (!path.startsWith("/") && path.equals(""))) { writer.println(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); return; } String displayPath = path; if( path.equals("/") ) path = ""; try { Context context = (Context) host.findChild(path); if (context == null) { writer.println(sm.getString("managerServlet.noContext", RequestUtil.filter(displayPath))); return; } Manager manager = context.getManager() ; if(manager == null) { writer.println(sm.getString("managerServlet.noManager", RequestUtil.filter(displayPath))); return; } int maxCount = 60; int maxInactiveInterval = manager.getMaxInactiveInterval()/60; int histoInterval = maxInactiveInterval / maxCount; if ( histoInterval * maxCount < maxInactiveInterval ) histoInterval++; if (0==histoInterval) histoInterval=1; maxCount = maxInactiveInterval / histoInterval; if ( histoInterval * maxCount < maxInactiveInterval ) maxCount++; writer.println(sm.getString("managerServlet.sessions", displayPath)); writer.println(sm.getString("managerServlet.sessiondefaultmax", "" + maxInactiveInterval)); Session [] sessions = manager.findSessions(); int [] timeout = new int[maxCount]; int notimeout = 0; int expired = 0; long now = System.currentTimeMillis(); for (int i = 0; i < sessions.length; i++) { int time = (int)((now-sessions[i].getThisAccessedTimeInternal())/1000); if (idle >= 0 && time >= idle*60) { sessions[i].expire(); expired++; } time=time/60/histoInterval; if (time < 0) notimeout++; } } }	protected void start(PrintWriter writer, String path) { if (debug >= 1) log("start: Starting web application at '" + path + "'"); if ((path == null) || (!path.startsWith("/") && path.equals(""))) { writer.println(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); return; } String displayPath = path; if (path.equals("/")) path = ""; try { Context context = (Context) host.findChild(path); if (context == null) { writer.println(sm.getString("managerServlet.noContext", RequestUtil.filter(displayPath))); return; } context.start(); if (context.getAvailable()) writer.println(sm.getString("managerServlet.started", displayPath)); else writer.println(sm.getString("managerServlet.startFailed", displayPath)); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getServletContext().log(sm.getString("managerServlet.startFailed", displayPath), t); writer.println(sm.getString("managerServlet.startFailed", displayPath)); writer.println(sm.getString("managerServlet.exception", t.toString())); } }	protected void stop(PrintWriter writer, String path) { if (debug >= 1) log("stop: Stopping web application at '" + path + "'"); if ((path == null) || (!path.startsWith("/") && path.equals(""))) { writer.println(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); return; } String displayPath = path; if (path.equals("/")) path = ""; try { Context context = (Context) host.findChild(path); if (context == null) { writer.println(sm.getString("managerServlet.noContext", RequestUtil.filter(displayPath))); return; } if (context.getPath().equals(this.context.getPath())) { writer.println(sm.getString("managerServlet.noSelf")); return; } context.stop(); writer.println(sm.getString("managerServlet.stopped", displayPath)); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log("ManagerServlet.stop[" + displayPath + "]", t); writer.println(sm.getString("managerServlet.exception", t.toString())); } }	protected void undeploy(PrintWriter writer, String path) { if (debug >= 1) log("undeploy: Undeploying web application at '" + path + "'"); if ((path == null) || (!path.startsWith("/") && path.equals(""))) { writer.println(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); return; } String displayPath = path; if (path.equals("/")) path = ""; try { Context context = (Context) host.findChild(path); if (context == null) { writer.println(sm.getString("managerServlet.noContext", RequestUtil.filter(displayPath))); return; } if (!isDeployed(path)) { writer.println(sm.getString("managerServlet.notDeployed", RequestUtil.filter(displayPath))); return; } if (!isServiced(path)) { addServiced(path); try { context.stop(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } try { if (path.lastIndexOf('/') > 0) { path = "/" + path.substring(1).replace('/', '#'); } File war = new File(getAppBase(), getDocBase(path) + ".war"); File dir = new File(getAppBase(), getDocBase(path)); File xml = new File(configBase, getConfigFile(path) + ".xml"); if (war.exists()) { war.delete(); } else if (dir.exists()) { undeployDir(dir); } else { xml.delete(); } check(path.replace('#', '/')); } finally { removeServiced(path.replace('#', '/')); } } writer.println(sm.getString("managerServlet.undeployed", displayPath)); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log("ManagerServlet.undeploy[" + displayPath + "]", t); writer.println(sm.getString("managerServlet.exception", t.toString())); } }	protected void uploadWar(HttpServletRequest request, File war) throws IOException { war.delete(); ServletInputStream istream = null; BufferedOutputStream ostream = null; try { istream = request.getInputStream(); ostream = new BufferedOutputStream(new FileOutputStream(war), 1024); byte[] buffer = new byte[1024]; while (true) { int n = istream.read(buffer); if (n < 0) { break; } ostream.write(buffer, 0, n); } ostream.flush(); ostream.close(); ostream = null; istream.close(); istream = null; } catch (IOException e) { war.delete(); throw e; } finally { if (ostream != null) { try { ostream.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } ostream = null; } if (istream != null) { try { istream.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } istream = null; } } }	public String getString(String key) { if (key == null) { String msg = "key may not have a null value"; throw new IllegalArgumentException(msg); } String str = null; try { if (bundle != null) { str = bundle.getString(key); } } catch (MissingResourceException mre) { //bad: shouldn't mask an exception the following way: // str = "[cannot find message associated with key '" + key + "' due to " + mre + "]"; // because it hides the fact that the String was missing // from the calling code. //good: could just throw the exception (or wrap it in another) // but that would probably cause much havoc on existing // code. //better: consistent with container pattern to // simply return null. Calling code can then do str = null; } return str; }	public String getString(final String key, final Object... args) { String value = getString(key); if (value == null) { value = key; } MessageFormat mf = new MessageFormat(value); mf.setLocale(locale); return mf.format(args, new StringBuffer(), null).toString(); }	public String sessions(String path) { return sessions(path, -1); }	public String sessions(String path, int idle) { StringWriter stringWriter = new StringWriter(); PrintWriter printWriter = new PrintWriter(stringWriter); super.sessions(printWriter, path, idle); return stringWriter.toString(); }	public String start(String path) { StringWriter stringWriter = new StringWriter(); PrintWriter printWriter = new PrintWriter(stringWriter); super.start(printWriter, path); return stringWriter.toString(); }	public boolean removeSessionAttribute(String path, String sessionId, String attributeName) throws IOException { HttpSession session = getSessionForPathAndId(path, sessionId).getSession(); if (null == session) { if (debug >= 1) { log("WARNING: can't remove attribute '" + attributeName + "' for null session " + sessionId); } return false; } boolean wasPresent = (null != session.getAttribute(attributeName)); try { session.removeAttribute(attributeName); } catch (IllegalStateException ise) { if (debug >= 1) { log("Can't remote attribute '" + attributeName + "' for invalidated session id " + sessionId); } } return wasPresent; }	public int invalidateSessions(String path, String[] sessionIds) throws IOException { if (null == sessionIds) { return 0; } int nbAffectedSessions = 0; for (int i = 0; i < sessionIds.length; ++i) { String sessionId = sessionIds[i]; HttpSession session = getSessionForPathAndId(path, sessionId).getSession(); if (null == session) { if (debug >= 1) { log("WARNING: can't invalidate null session " + sessionId); } continue; } try { session.invalidate(); ++nbAffectedSessions; if (debug >= 1) { log("Invalidating session id " + sessionId); } } catch (IllegalStateException ise) { if (debug >= 1) { log("Can't invalidate already invalidated session id " + sessionId); } } } return nbAffectedSessions; }	public static final synchronized StringManager getManager(String packageName) { StringManager mgr = managers.get(packageName); if (mgr == null) { mgr = new StringManager(packageName); managers.put(packageName, mgr); } return mgr; }	public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { // Identify the request parameters that we need // By obtaining the command from the pathInfo, per-command security can String command = request.getPathInfo(); String path = request.getParameter("path"); response.setContentType("text/html; charset=" + Constants.CHARSET); String message = ""; if (command == null || command.equals("/")) { // No command == list } else if (command.equals("/list")) { // List always displayed - nothing to do here } else if (command.equals("/sessions")) { try { doSessions(path, request, response); return; } catch (Exception e) { log("HTMLManagerServlet.sessions[" + path + "]", e); message = sm.getString("managerServlet.exception", e.toString()); } } else if (command.equals("/upload") || command.equals("/deploy") || command.equals("/reload") || command.equals("/undeploy") || command.equals("/expire") || command.equals("/start") || command.equals("/stop")) { message = sm.getString("managerServlet.postCommand", command); } else { message = sm.getString("managerServlet.unknownCommand", command); } list(request, response, message); }	@Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { String command = request.getPathInfo(); if (command == null) command = request.getServletPath(); String config = request.getParameter("config"); String path = request.getParameter("path"); String type = request.getParameter("type"); String war = request.getParameter("war"); String tag = request.getParameter("tag"); boolean update = false; if ((request.getParameter("update") != null) && (request.getParameter("update").equals("true"))) { update = true; } response.setContentType("text/plain; charset=" + Constants.CHARSET); PrintWriter writer = response.getWriter(); if (command == null) { writer.println(sm.getString("managerServlet.noCommand")); } else if (command.equals("/deploy")) { if (war != null || config != null) { deploy(writer, config, path, war, update); } else { deploy(writer, path, tag); } } else if (command.equals("/list")) { list(writer); } else if (command.equals("/reload")) { reload(writer, path); } else if (command.equals("/resources")) { resources(writer, type); } else if (command.equals("/roles")) { roles(writer); } else if (command.equals("/save")) { save(writer, path); } else if (command.equals("/serverinfo")) { serverinfo(writer); } else if (command.equals("/sessions")) { expireSessions(writer, path, request); } else if (command.equals("/expire")) { expireSessions(writer, path, request); } else if (command.equals("/start")) { start(writer, path); } else if (command.equals("/stop")) { stop(writer, path); } else if (command.equals("/undeploy")) { undeploy(writer, path); } else if (command.equals("/findleaks")) { findleaks(writer); } else { writer.println(sm.getString("managerServlet.unknownCommand", command)); } writer.flush(); writer.close(); }	@Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { // Identify the request parameters that we need // By obtaining the command from the pathInfo, per-command security can String command = request.getPathInfo(); String path = request.getParameter("path"); String deployPath = request.getParameter("deployPath"); String deployConfig = request.getParameter("deployConfig"); String deployWar = request.getParameter("deployWar"); response.setContentType("text/html; charset=" + Constants.CHARSET); String message = ""; if (command == null || command.length() == 0) { // No command == list // List always displayed -> do nothing } else if (command.equals("/upload")) { message = upload(request); } else if (command.equals("/deploy")) { message = deployInternal(deployConfig, deployPath, deployWar); } else if (command.equals("/reload")) { message = reload(path); } else if (command.equals("/undeploy")) { message = undeploy(path); } else if (command.equals("/expire")) { message = expireSessions(path, request); } else if (command.equals("/start")) { message = start(path); } else if (command.equals("/stop")) { message = stop(path); } else if (command.equals("/findleaks")) { message = findleaks(); } else { doGet(request, response); return; } list(request, response, message); }	@Override public void doPut(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { String command = request.getPathInfo(); if (command == null) command = request.getServletPath(); String path = request.getParameter("path"); String tag = request.getParameter("tag"); boolean update = false; if ((request.getParameter("update") != null) && (request.getParameter("update").equals("true"))) { update = true; } response.setContentType("text/plain;charset=" + Constants.CHARSET); PrintWriter writer = response.getWriter(); if (command == null) { writer.println(sm.getString("managerServlet.noCommand")); } else if (command.equals("/deploy")) { deploy(writer, path, tag, update, request); } else { writer.println(sm.getString("managerServlet.unknownCommand", command)); } writer.flush(); writer.close(); }	@Override public void init() throws ServletException { super.init(); String value = null; value = getServletConfig().getInitParameter("showProxySessions"); showProxySessions = Boolean.parseBoolean(value); }	@Override public void init() throws ServletException { if ((wrapper == null) || (context == null)) throw new UnavailableException(sm.getString("managerServlet.noWrapper")); String value = null; try { value = getServletConfig().getInitParameter("debug"); debug = Integer.parseInt(value); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } Server server = ((Engine) host.getParent()).getService().getServer(); if ((server != null) && (server instanceof StandardServer)) { global = ((StandardServer) server).getGlobalNamingContext(); } versioned = (File) getServletContext().getAttribute(ServletContext.TEMPDIR); // Identify the appBase of the owning Host of this Context String appBase = ((Host) context.getParent()).getAppBase(); deployed = new File(appBase); if (!deployed.isAbsolute()) { deployed = new File(System.getProperty(Globals.CATALINA_BASE_PROP), appBase); } configBase = new File(System.getProperty(Globals.CATALINA_BASE_PROP), "conf"); Container container = context; Container host = null; Container engine = null; while (container != null) { if (container instanceof Host) host = container; if (container instanceof Engine) engine = container; container = container.getParent(); } if (engine != null) { configBase = new File(configBase, engine.getName()); } if (host != null) { configBase = new File(configBase, host.getName()); } if (debug >= 1) { log("init: Associated with Deployer '" + oname + "'"); if (global != null) { log("init: Global resources are available"); } } }	public void list(HttpServletRequest request, HttpServletResponse response, String message) throws IOException { if (debug >= 1) log("list: Listing contexts for virtual host '" + host.getName() + "'"); PrintWriter writer = response.getWriter(); writer.print(Constants.HTML_HEADER_SECTION); Object[] args = new Object[2]; args[0] = request.getContextPath(); args[1] = sm.getString("htmlManagerServlet.title"); writer.print(MessageFormat.format(Constants.BODY_HEADER_SECTION, args)); args = new Object[3]; args[0] = sm.getString("htmlManagerServlet.messageLabel"); if (message == null || message.length() == 0) { args[1] = "OK"; } else { args[1] = RequestUtil.filter(message); } writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args)); args = new Object[9]; args[0] = sm.getString("htmlManagerServlet.manager"); args[1] = response.encodeURL(request.getContextPath() + "/html/list"); args[2] = sm.getString("htmlManagerServlet.list"); args[3] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpHtmlManagerFile")); args[4] = sm.getString("htmlManagerServlet.helpHtmlManager"); args[5] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpManagerFile")); args[6] = sm.getString("htmlManagerServlet.helpManager"); args[7] = response.encodeURL(request.getContextPath() + "/status"); args[8] = sm.getString("statusServlet.title"); writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args)); args = new Object[6]; args[0] = sm.getString("htmlManagerServlet.appsTitle"); args[1] = sm.getString("htmlManagerServlet.appsPath"); args[2] = sm.getString("htmlManagerServlet.appsName"); args[3] = sm.getString("htmlManagerServlet.appsAvailable"); args[4] = sm.getString("htmlManagerServlet.appsSessions"); args[5] = sm.getString("htmlManagerServlet.appsTasks"); writer.print(MessageFormat.format(APPS_HEADER_SECTION, args)); // Apps Row Section Container[] children = host.findChildren(); String[] contextPaths = new String[children.length]; for (int i = 0; i < children.length; i++) contextPaths[i] = children[i].getName(); TreeMap<String, String> sortedContextPathsMap = new TreeMap<String, String>(); for (int i = 0; i < contextPaths.length; i++) { String displayPath = contextPaths[i]; sortedContextPathsMap.put(displayPath, contextPaths[i]); } String appsStart = sm.getString("htmlManagerServlet.appsStart"); String appsStop = sm.getString("htmlManagerServlet.appsStop"); String appsReload = sm.getString("htmlManagerServlet.appsReload"); String appsUndeploy = sm.getString("htmlManagerServlet.appsUndeploy"); String appsExpire = sm.getString("htmlManagerServlet.appsExpire"); Iterator<Map.Entry<String, String>> iterator = sortedContextPathsMap.entrySet().iterator(); boolean isHighlighted = true; boolean isDeployed = true; String highlightColor = null; while (iterator.hasNext()) { isHighlighted = !isHighlighted; if (isHighlighted) { highlightColor = "#C3F3C3"; } else { highlightColor = "#FFFFFF"; } Map.Entry<String, String> entry = iterator.next(); String displayPath = entry.getKey(); String contextPath = entry.getValue(); Context ctxt = (Context) host.findChild(contextPath); if (displayPath.equals("")) { displayPath = "/"; } if (ctxt != null) { try { isDeployed = isDeployed(contextPath); } catch (Exception e) { isDeployed = false; } args = new Object[7]; args[0] = URL_ENCODER.encode(displayPath); args[1] = displayPath; args[2] = ctxt.getDisplayName(); if (args[2] == null) { args[2] = "&nbsp;"; } args[3] = new Boolean(ctxt.getAvailable()); args[4] = response.encodeURL(request.getContextPath() + "/html/sessions?path=" + URL_ENCODER.encode(displayPath)); Manager manager = ctxt.getManager(); if (manager instanceof BackupManager && showProxySessions) { args[5] = new Integer(((BackupManager) manager).getActiveSessionsFull()); } else if (ctxt.getManager() != null) { args[5] = new Integer(manager.getActiveSessions()); } else { args[5] = new Integer(0); } args[6] = highlightColor; writer.print(MessageFormat.format(APPS_ROW_DETAILS_SECTION, args)); args = new Object[14]; args[0] = response.encodeURL(request.getContextPath() + "/html/start?path=" + URL_ENCODER.encode(displayPath)); args[1] = appsStart; args[2] = response.encodeURL(request.getContextPath() + "/html/stop?path=" + URL_ENCODER.encode(displayPath)); args[3] = appsStop; args[4] = response.encodeURL(request.getContextPath() + "/html/reload?path=" + URL_ENCODER.encode(displayPath)); args[5] = appsReload; args[6] = response.encodeURL(request.getContextPath() + "/html/undeploy?path=" + URL_ENCODER.encode(displayPath)); args[7] = appsUndeploy; args[8] = response.encodeURL(request.getContextPath() + "/html/expire?path=" + URL_ENCODER.encode(displayPath)); args[9] = appsExpire; args[10] = sm.getString("htmlManagerServlet.expire.explain"); if (manager == null) { args[11] = sm.getString("htmlManagerServlet.noManager"); } else { args[11] = new Integer(ctxt.getManager().getMaxInactiveInterval() / 60); } args[12] = sm.getString("htmlManagerServlet.expire.unit"); args[13] = highlightColor; if (ctxt.getPath().equals(this.context.getPath())) { writer.print(MessageFormat.format(MANAGER_APP_ROW_BUTTON_SECTION, args)); } else if (ctxt.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STARTED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (ctxt.getAvailable() && !isDeployed) { writer.print(MessageFormat.format(STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (!ctxt.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STOPPED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else { writer.print(MessageFormat.format(STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } } } args = new Object[7]; args[0] = sm.getString("htmlManagerServlet.deployTitle"); args[1] = sm.getString("htmlManagerServlet.deployServer"); args[2] = response.encodeURL(request.getContextPath() + "/html/deploy"); args[3] = sm.getString("htmlManagerServlet.deployPath"); args[4] = sm.getString("htmlManagerServlet.deployConfig"); args[5] = sm.getString("htmlManagerServlet.deployWar"); args[6] = sm.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(DEPLOY_SECTION, args)); args = new Object[4]; args[0] = sm.getString("htmlManagerServlet.deployUpload"); args[1] = response.encodeURL(request.getContextPath() + "/html/upload"); args[2] = sm.getString("htmlManagerServlet.deployUploadFile"); args[3] = sm.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(UPLOAD_SECTION, args)); args = new Object[5]; args[0] = sm.getString("htmlManagerServlet.diagnosticsTitle"); args[1] = sm.getString("htmlManagerServlet.diagnosticsLeak"); args[2] = response.encodeURL(request.getContextPath() + "/html/findleaks"); args[3] = sm.getString("htmlManagerServlet.diagnosticsLeakWarning"); args[4] = sm.getString("htmlManagerServlet.diagnosticsLeakButton"); writer.print(MessageFormat.format(DIAGNOSTICS_SECTION, args)); args = new Object[7]; args[0] = sm.getString("htmlManagerServlet.serverTitle"); args[1] = sm.getString("htmlManagerServlet.serverVersion"); args[2] = sm.getString("htmlManagerServlet.serverJVMVersion"); args[3] = sm.getString("htmlManagerServlet.serverJVMVendor"); args[4] = sm.getString("htmlManagerServlet.serverOSName"); args[5] = sm.getString("htmlManagerServlet.serverOSVersion"); args[6] = sm.getString("htmlManagerServlet.serverOSArch"); writer.print(MessageFormat.format(Constants.SERVER_HEADER_SECTION, args)); args = new Object[6]; args[0] = ServerInfo.getServerInfo(); args[1] = System.getProperty("java.runtime.version"); args[2] = System.getProperty("java.vm.vendor"); args[3] = System.getProperty("os.name"); args[4] = System.getProperty("os.version"); args[5] = System.getProperty("os.arch"); writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args)); writer.print(Constants.HTML_TAIL_SECTION); writer.flush(); writer.close(); }
protected void checkHandlesTypes(JavaClass javaClass) { if (typeInitializerMap.size() == 0) return; String className = javaClass.getClassName(); Class<?> clazz = null; try { clazz = context.getLoader().getClassLoader().loadClass(className); } catch (NoClassDefFoundError e) { log.debug(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (ClassNotFoundException e) { log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } if (clazz.isAnnotation()) { return; } boolean match = false; for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry : typeInitializerMap.entrySet()) { if (entry.getKey().isAnnotation()) { AnnotationEntry[] annotationEntries = javaClass.getAnnotationEntries(); for (AnnotationEntry annotationEntry : annotationEntries) { if (entry.getKey().getName().equals(getClassName(annotationEntry.getAnnotationType()))) { match = true; break; } } } else if (entry.getKey().isAssignableFrom(clazz)) { match = true; } if (match) { for (ServletContainerInitializer sci : entry.getValue()) { initializerClassMap.get(sci).add(clazz); } } } }
private Class<?> loadTagFile(Compiler compiler, String tagFilePath, TagInfo tagInfo, PageInfo parentPageInfo) throws JasperException { JarResource tagJarResouce = null; if (tagFilePath.startsWith("/META-INF/")) { tagJarResouce = compiler.getCompilationContext().getTldLocation(tagInfo.getTagLibrary().getURI()).getJarResource(); } String wrapperUri; if (tagJarResouce == null) { wrapperUri = tagFilePath; } else { wrapperUri = tagJarResouce.getEntry(tagFilePath).toString(); } JspCompilationContext ctxt = compiler.getCompilationContext(); JspRuntimeContext rctxt = ctxt.getRuntimeContext(); JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri); synchronized (rctxt) { if (wrapper == null) { wrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), tagJarResouce); rctxt.addWrapper(wrapperUri, wrapper); wrapper.getJspEngineContext().setClassLoader(ctxt.getClassLoader()); wrapper.getJspEngineContext().setClassPath(ctxt.getClassPath()); } else { // Make sure that JspCompilationContext gets the latest TagInfo // for the tag file. TagInfo instance was created the last // time the tag file was scanned for directives, and the tag wrapper.getJspEngineContext().setTagInfo(tagInfo); } Class<?> tagClazz; int tripCount = wrapper.incTripCount(); try { if (tripCount > 0) { // When tripCount is greater than zero, a circular // dependency exists. The circularly dependent tag // file is compiled in prototype mode, to avoid infinite JspServletWrapper tempWrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), ctxt.getTagFileJarResource(tagFilePath)); tagClazz = tempWrapper.loadTagFilePrototype(); tempVector.add(tempWrapper.getJspEngineContext().getCompiler()); } else { tagClazz = wrapper.loadTagFile(); } } finally { wrapper.decTripCount(); } try { Object tagIns = tagClazz.newInstance(); if (tagIns instanceof JspSourceDependent) { Iterator<String> iter = ((JspSourceDependent) tagIns).getDependants().iterator(); while (iter.hasNext()) { parentPageInfo.addDependant(iter.next()); } } } catch (Exception e) { // ignore errors } return tagClazz; } }
protected void webConfig() { WebXml webXml = createWebXml(); InputSource globalWebXml = getGlobalWebXmlSource(); if (globalWebXml == null) { log.info(sm.getString("contextConfig.defaultMissing")); } else { parseWebXml(globalWebXml, webXml, false); } // Parse host level web.xml if present webXml.setReplaceWelcomeFiles(true); InputSource hostWebXml = getHostWebXmlSource(); parseWebXml(hostWebXml, webXml, false); webXml.setReplaceWelcomeFiles(true); InputSource contextWebXml = getContextWebXmlSource(); parseWebXml(contextWebXml, webXml, false); double webXmlVersion = 0; if (webXml.getVersion() != null) { webXmlVersion = Double.parseDouble(webXml.getVersion()); } if (webXmlVersion >= 3) { // Ordering is important here // Step 1. Identify all the JARs packaged with the application // If the JARs have a web-fragment.xml it will be parsed at this Map<String, WebXml> fragments = processJarsForWebFragments(); // Only need to process fragments and annotations if metadata is Set<WebXml> orderedFragments = null; if (!webXml.isMetadataComplete()) { orderedFragments = WebXml.orderWebFragments(webXml, fragments); ok = processServletContainerInitializers(orderedFragments); if (ok) { URL webinfClasses; try { webinfClasses = context.getServletContext().getResource("/WEB-INF/classes"); processAnnotationsUrl(webinfClasses, webXml); } catch (MalformedURLException e) { log.error(sm.getString("contextConfig.webinfClassesUrl"), e); } } if (ok) { processAnnotations(orderedFragments); } if (ok) { ok = webXml.merge(orderedFragments); } if (!false) { convertJsps(webXml); } if (ok) { webXml.configureContext(context); // Step 7a. Make the merged web.xml available to other // components, specifically Jasper, to save those components // from having to re-generate it. String mergedWebXml = webXml.toXml(); context.getServletContext().setAttribute(org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML, mergedWebXml); if (context.getLogEffectiveWebXml()) { log.info("web.xml:\n" + mergedWebXml); } } } else { ok = true; } if (ok) { // Spec does not define an order. Set<WebXml> resourceJars = new LinkedHashSet<WebXml>(); if (orderedFragments != null) { for (WebXml fragment : orderedFragments) { resourceJars.add(fragment); } } for (WebXml fragment : fragments.values()) { if (!resourceJars.contains(fragment)) { resourceJars.add(fragment); } } processResourceJARs(resourceJars); } if (!webXml.isMetadataComplete()) { if (ok) { for (Map.Entry<ServletContainerInitializer, Set<Class<?>>> entry : initializerClassMap.entrySet()) { if (entry.getValue().isEmpty()) { context.addServletContainerInitializer(entry.getKey(), null); } else { context.addServletContainerInitializer(entry.getKey(), entry.getValue()); } } } } } else { convertJsps(webXml); webXml.configureContext(context); } }
public void setNamingResources(NamingResources namingResources) { NamingResources oldNamingResources = this.namingResources; this.namingResources = namingResources; namingResources.setContainer(this); support.firePropertyChange("namingResources", oldNamingResources, this.namingResources); unregister(onameNamingResources); onameNamingResources = register(namingResources, "type=NamingResources," + getObjectKeyPropertiesNameOnly()); }
protected void webConfig() { WebXml webXml = createWebXml(); InputSource globalWebXml = getGlobalWebXmlSource(); if (globalWebXml == null) { log.info(sm.getString("contextConfig.defaultMissing")); } else { parseWebXml(globalWebXml, webXml, false); } // Parse host level web.xml if present webXml.setReplaceWelcomeFiles(true); InputSource hostWebXml = getHostWebXmlSource(); parseWebXml(hostWebXml, webXml, false); webXml.setReplaceWelcomeFiles(true); InputSource contextWebXml = getContextWebXmlSource(); parseWebXml(contextWebXml, webXml, false); double webXmlVersion = 0; if (webXml.getVersion() != null) { webXmlVersion = Double.parseDouble(webXml.getVersion()); } if (webXmlVersion >= 3 && !webXml.isMetadataComplete()) { // Ordering is important here // Step 1. Identify all the JARs packaged with the application // If the JARs have a web-fragment.xml it will be parsed at this Map<String, WebXml> fragments = processJarsForWebFragments(); Set<WebXml> orderedFragments = WebXml.orderWebFragments(webXml, fragments); ok = processServletContainerInitializers(orderedFragments); if (ok) { URL webinfClasses; try { webinfClasses = context.getServletContext().getResource("/WEB-INF/classes"); processAnnotationsUrl(webinfClasses, webXml); } catch (MalformedURLException e) { log.error(sm.getString("contextConfig.webinfClassesUrl"), e); } } if (ok) { processAnnotations(orderedFragments); } if (ok) { ok = webXml.merge(orderedFragments); } if (!false) { convertJsps(webXml); } if (ok) { webXml.configureContext(context); // Step 7a. Make the merged web.xml available to other // components, specifically Jasper, to save those components // from having to re-generate it. String mergedWebXml = webXml.toXml(); context.getServletContext().setAttribute(org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML, mergedWebXml); if (context.getLogEffectiveWebXml()) { log.info("web.xml:\n" + mergedWebXml); } } if (ok) { // Spec does not define an order. Set<WebXml> resourceJars = new LinkedHashSet<WebXml>(); for (WebXml fragment : orderedFragments) { resourceJars.add(fragment); } for (WebXml fragment : fragments.values()) { if (!resourceJars.contains(fragment)) { resourceJars.add(fragment); } } processResourceJARs(resourceJars); } if (ok) { for (Map.Entry<ServletContainerInitializer, Set<Class<?>>> entry : initializerClassMap.entrySet()) { if (entry.getValue().isEmpty()) { context.addServletContainerInitializer(entry.getKey(), null); } else { context.addServletContainerInitializer(entry.getKey(), entry.getValue()); } } } } else { convertJsps(webXml); webXml.configureContext(context); } }
public JspWriter getEnclosingWriter() { return enclosingWriter; }	public java.util.Enumeration<String> getAttributes() { return attributes.keys(); }	public String getFunctionSignature() { return functionSignature; }	public String getMessage() { return message; }	@Override public String toString() { StringBuilder b = new StringBuilder(64); b.append("name = " + name + " "); b.append("type = " + type + " "); b.append("reqTime = " + reqTime + " "); b.append("required = " + required + " "); b.append("fragment = " + fragment + " "); b.append("deferredValue = " + deferredValue + " "); b.append("expectedTypeName = " + expectedTypeName + " "); b.append("deferredMethod = " + deferredMethod + " "); b.append("methodSignature = " + methodSignature); return b.toString(); }	public TagInfo getTagInfo() { return tagInfo; }	public final TagInfo getTagInfo() { return tagInfo; }	public int getScope() { return scope; }	public int getScope() { return scope; }
public boolean authenticate(Request request, HttpServletResponse response, LoginConfig config) throws IOException { Principal principal = request.getUserPrincipal(); String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (principal != null) { if (log.isDebugEnabled()) log.debug("Already authenticated '" + principal.getName() + "'"); if (ssoId != null) associate(ssoId, request.getSessionInternal(true)); return (true); } if (ssoId != null) { if (log.isDebugEnabled()) log.debug("SSO Id " + ssoId + " set; attempting " + "reauthentication"); if (reauthenticateFromSSO(ssoId, request)) return true; } String username = null; String password = null; MessageBytes authorization = request.getCoyoteRequest().getMimeHeaders().getValue("authorization"); if (authorization != null) { authorization.toBytes(); ByteChunk authorizationBC = authorization.getByteChunk(); if (authorizationBC.startsWithIgnoreCase("basic ", 0)) { authorizationBC.setOffset(authorizationBC.getOffset() + 6); // FIXME: Add trimming CharChunk authorizationCC = authorization.getCharChunk(); Base64.decode(authorizationBC, authorizationCC); int colon = authorizationCC.indexOf(':'); if (colon < 0) { username = authorizationCC.toString(); } else { char[] buf = authorizationCC.getBuffer(); username = new String(buf, 0, colon); password = new String(buf, colon + 1, authorizationCC.getEnd() - colon - 1); } authorizationBC.setOffset(authorizationBC.getOffset() - 6); } principal = context.getRealm().authenticate(username, password); if (principal != null) { register(request, response, principal, Constants.BASIC_METHOD, username, password); return (true); } } StringBuilder value = new StringBuilder(16); value.append("Basic realm=\""); if (config.getRealmName() == null) { value.append(REALM_NAME); } else { value.append(config.getRealmName()); } value.append('\"'); response.setHeader(AUTH_HEADER_NAME, value.toString()); response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return (false); }	@Override public boolean authenticate(Request request, HttpServletResponse response, LoginConfig config) throws IOException { Principal principal = request.getUserPrincipal(); if (principal != null) { if (log.isDebugEnabled()) log.debug("Already authenticated '" + principal.getName() + "'"); // Associate the session with any existing SSO session in order String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (ssoId != null) associate(ssoId, request.getSessionInternal(true)); return (true); } // NOTE: We don't try to reauthenticate using any existing SSO session, // because that will only work if the original authentication was // BASIC or FORM, which are less secure than the DIGEST auth-type // specified for this webapp // // Uncomment below to allow previous FORM or BASIC authentications // to authenticate users for this webapp // TODO make this a configurable attribute (in SingleSignOn??) /* // Is there an SSO session against which we can try to reauthenticate? if (ssoId != null) { if (log.isDebugEnabled()) log.debug("SSO Id " + ssoId + " set; attempting " + "reauthentication"); // Try to reauthenticate using data cached by SSO. If this fails, // either the original SSO logon was of DIGEST or SSL (which // we can't reauthenticate ourselves because there is no // cached username and password), or the realm denied // the user's reauthentication for some reason. // In either case we have to prompt the user for a logon if (reauthenticateFromSSO(ssoId, request)) return true; } */ String authorization = request.getHeader("authorization"); if (authorization != null) { principal = findPrincipal(request, authorization, context.getRealm()); if (principal != null) { String username = parseUsername(authorization); register(request, response, principal, Constants.DIGEST_METHOD, username, null); return (true); } } // Send an "unauthorized" response and an appropriate challenge // Next, generate a nOnce token (that is a token which is supposed String nOnce = generateNOnce(request); setAuthenticateHeader(request, response, config, nOnce); response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return (false); }	@Override public boolean authenticate(Request request, HttpServletResponse response, LoginConfig config) throws IOException { Session session = null; Principal principal = request.getUserPrincipal(); String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (principal != null) { if (log.isDebugEnabled()) log.debug("Already authenticated '" + principal.getName() + "'"); if (ssoId != null) associate(ssoId, request.getSessionInternal(true)); return (true); } if (ssoId != null) { if (log.isDebugEnabled()) log.debug("SSO Id " + ssoId + " set; attempting " + "reauthentication"); if (reauthenticateFromSSO(ssoId, request)) return true; } if (!cache) { session = request.getSessionInternal(true); if (log.isDebugEnabled()) log.debug("Checking for reauthenticate in session " + session); String username = (String) session.getNote(Constants.SESS_USERNAME_NOTE); String password = (String) session.getNote(Constants.SESS_PASSWORD_NOTE); if ((username != null) && (password != null)) { if (log.isDebugEnabled()) log.debug("Reauthenticating username '" + username + "'"); principal = context.getRealm().authenticate(username, password); if (principal != null) { session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal); if (!matchRequest(request)) { register(request, response, principal, Constants.FORM_METHOD, username, password); return (true); } } if (log.isDebugEnabled()) log.debug("Reauthentication failed, proceed normally"); } } if (matchRequest(request)) { session = request.getSessionInternal(true); if (log.isDebugEnabled()) log.debug("Restore request from session '" + session.getIdInternal() + "'"); principal = (Principal) session.getNote(Constants.FORM_PRINCIPAL_NOTE); register(request, response, principal, Constants.FORM_METHOD, (String) session.getNote(Constants.SESS_USERNAME_NOTE), (String) session.getNote(Constants.SESS_PASSWORD_NOTE)); if (cache) { session.removeNote(Constants.SESS_USERNAME_NOTE); session.removeNote(Constants.SESS_PASSWORD_NOTE); } if (restoreRequest(request, session)) { if (log.isDebugEnabled()) log.debug("Proceed to restored request"); return (true); } else { if (log.isDebugEnabled()) log.debug("Restore of original request failed"); response.sendError(HttpServletResponse.SC_BAD_REQUEST); return (false); } } MessageBytes uriMB = MessageBytes.newInstance(); CharChunk uriCC = uriMB.getCharChunk(); uriCC.setLimit(-1); String contextPath = request.getContextPath(); String requestURI = request.getDecodedRequestURI(); boolean loginAction = requestURI.startsWith(contextPath) && requestURI.endsWith(Constants.FORM_ACTION); if (!loginAction) { session = request.getSessionInternal(true); if (log.isDebugEnabled()) log.debug("Save request in session '" + session.getIdInternal() + "'"); try { saveRequest(request, session); } catch (IOException ioe) { log.debug("Request body too big to save during authentication"); response.sendError(HttpServletResponse.SC_FORBIDDEN, sm.getString("authenticator.requestBodyTooBig")); return (false); } forwardToLoginPage(request, response, config); return (false); } // Yes -- Acknowledge the request, validate the specified credentials request.getResponse().sendAcknowledgement(); Realm realm = context.getRealm(); if (characterEncoding != null) { request.setCharacterEncoding(characterEncoding); } String username = request.getParameter(Constants.FORM_USERNAME); String password = request.getParameter(Constants.FORM_PASSWORD); if (log.isDebugEnabled()) log.debug("Authenticating username '" + username + "'"); principal = realm.authenticate(username, password); if (principal == null) { forwardToErrorPage(request, response, config); return (false); } if (log.isDebugEnabled()) log.debug("Authentication of '" + username + "' was successful"); if (session == null) session = request.getSessionInternal(false); if (session == null) { if (containerLog.isDebugEnabled()) containerLog.debug("User took so long to log on the session expired"); response.sendError(HttpServletResponse.SC_REQUEST_TIMEOUT, sm.getString("authenticator.sessionExpired")); return (false); } session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal); session.setNote(Constants.SESS_USERNAME_NOTE, username); session.setNote(Constants.SESS_PASSWORD_NOTE, password); // Redirect the user to the original request URI (which will cause requestURI = savedRequestURL(session); if (log.isDebugEnabled()) log.debug("Redirecting to original '" + requestURI + "'"); if (requestURI == null) response.sendError(HttpServletResponse.SC_BAD_REQUEST, sm.getString("authenticator.formlogin")); else response.sendRedirect(response.encodeRedirectURL(requestURI)); return (false); }	@Override public boolean authenticate(Request request, HttpServletResponse response, LoginConfig config) throws IOException { if (containerLog.isDebugEnabled()) containerLog.debug("User authentication is not required"); return (true); }	@Override public boolean authenticate(Request request, HttpServletResponse response, LoginConfig config) throws IOException { Principal principal = request.getUserPrincipal(); if (principal != null) { if (containerLog.isDebugEnabled()) containerLog.debug("Already authenticated '" + principal.getName() + "'"); // Associate the session with any existing SSO session in order String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (ssoId != null) associate(ssoId, request.getSessionInternal(true)); return (true); } if (containerLog.isDebugEnabled()) containerLog.debug(" Looking up certificates"); X509Certificate[] certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR); if ((certs == null) || (certs.length < 1)) { request.getCoyoteRequest().action(ActionCode.REQ_SSL_CERTIFICATE, null); certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR); } if ((certs == null) || (certs.length < 1)) { if (containerLog.isDebugEnabled()) containerLog.debug(" No certificates included with this request"); response.sendError(HttpServletResponse.SC_UNAUTHORIZED, sm.getString("authenticator.certificates")); return (false); } principal = context.getRealm().authenticate(certs); if (principal == null) { if (containerLog.isDebugEnabled()) containerLog.debug(" Realm.authenticate() returned false"); response.sendError(HttpServletResponse.SC_UNAUTHORIZED, sm.getString("authenticator.unauthorized")); return (false); } register(request, response, principal, Constants.CERT_METHOD, null, null); return (true); }	public boolean hasResourcePermission(Request request, Response response, SecurityConstraint[] constraints, Context context) throws IOException { if (constraints == null || constraints.length == 0) return (true); // Specifically allow access to the form login and form error pages LoginConfig config = context.getLoginConfig(); if ((config != null) && (Constants.FORM_METHOD.equals(config.getAuthMethod()))) { String requestURI = request.getRequestPathMB().toString(); String loginPage = config.getLoginPage(); if (loginPage.equals(requestURI)) { if (log.isDebugEnabled()) log.debug(" Allow access to login page " + loginPage); return (true); } String errorPage = config.getErrorPage(); if (errorPage.equals(requestURI)) { if (log.isDebugEnabled()) log.debug(" Allow access to error page " + errorPage); return (true); } if (requestURI.endsWith(Constants.FORM_ACTION)) { if (log.isDebugEnabled()) log.debug(" Allow access to username/password submission"); return (true); } } Principal principal = request.getPrincipal(); boolean status = false; boolean denyfromall = false; for (int i = 0; i < constraints.length; i++) { SecurityConstraint constraint = constraints[i]; String[] roles; if (constraint.getAllRoles()) { roles = request.getContext().findSecurityRoles(); } else { roles = constraint.findAuthRoles(); } if (roles == null) roles = new String[0]; if (log.isDebugEnabled()) log.debug(" Checking roles " + principal); if (roles.length == 0 && !constraint.getAllRoles()) { if (constraint.getAuthConstraint()) { if (log.isDebugEnabled()) log.debug("No roles "); status = false; denyfromall = true; break; } if (log.isDebugEnabled()) log.debug("Passing all access"); status = true; } else if (principal == null) { if (log.isDebugEnabled()) log.debug(" No user authenticated, cannot grant access"); } else { for (int j = 0; j < roles.length; j++) { if (hasRole(principal, roles[j])) { status = true; if (log.isDebugEnabled()) log.debug("Role found: " + roles[j]); } } } } }	@Override public boolean hasRole(Principal principal, String role) { if (principal instanceof GenericPrincipal) { GenericPrincipal gp = (GenericPrincipal) principal; if (gp.getUserPrincipal() instanceof User) { principal = gp.getUserPrincipal(); } } if (!(principal instanceof User)) { return super.hasRole(principal, role); } if ("*".equals(role)) { return true; } else if (role == null) { return false; } User user = (User) principal; Role dbrole = database.findRole(role); if (dbrole == null) { return false; } if (user.isInRole(dbrole)) { return true; } Iterator<Group> groups = user.getGroups(); while (groups.hasNext()) { Group group = groups.next(); if (group.isInRole(dbrole)) { return true; } } return false; }	@Override public boolean isUserInRole(String role) { if (userPrincipal == null) return false; if (context == null) return false; Realm realm = context.getRealm(); if (realm == null) return false; if (wrapper != null) { String realRole = wrapper.findSecurityReference(role); if ((realRole != null) && realm.hasRole(userPrincipal, realRole)) return true; } return (realm.hasRole(userPrincipal, role)); }	@Override public void login(String username, String password) throws ServletException { if (getAuthType() != null || getRemoteUser() != null || getUserPrincipal() != null) { throw new ServletException(sm.getString("coyoteRequest.alreadyAuthenticated")); } LoginConfig config = context.getLoginConfig(); if (config == null) { throw new ServletException(sm.getString("coyoteRequest.noLoginConfig")); } String authMethod = config.getAuthMethod(); if (BASIC_AUTH.equals(authMethod) || FORM_AUTH.equals(authMethod) || DIGEST_AUTH.equals(authMethod)) { Realm realm = context.getRealm(); Principal principal = realm.authenticate(username, password); if (principal == null) { throw new ServletException(sm.getString("coyoteRequest.authFail", username)); } // Assume if we have a non-null LoginConfig then we must have an context.getAuthenticator().register(this, getResponse(), principal, authMethod, username, password); } else { throw new ServletException("coyoteRequest.noPasswordLogin"); } }	@Override public Collection<Part> getParts() throws IOException, IllegalStateException, ServletException { parseParts(); if (partsParseException != null) { if (partsParseException instanceof IOException) { throw (IOException) partsParseException; } else if (partsParseException instanceof IllegalStateException) { throw (IllegalStateException) partsParseException; } else if (partsParseException instanceof ServletException) { throw (ServletException) partsParseException; } } return parts; }	public void register(Request request, HttpServletResponse response, Principal principal, String authType, String username, String password) { if (log.isDebugEnabled()) log.debug("Authenticated '" + principal.getName() + "' with type '" + authType + "'"); request.setAuthType(authType); request.setUserPrincipal(principal); Session session = request.getSessionInternal(false); if (session != null && changeSessionIdOnAuthentication) { Manager manager = request.getContext().getManager(); manager.changeSessionId(session); request.changeSessionId(session.getId()); } if (cache) { if (session != null) { session.setAuthType(authType); session.setPrincipal(principal); if (username != null) session.setNote(Constants.SESS_USERNAME_NOTE, username); else session.removeNote(Constants.SESS_USERNAME_NOTE); if (password != null) session.setNote(Constants.SESS_PASSWORD_NOTE, password); else session.removeNote(Constants.SESS_PASSWORD_NOTE); } } if (sso == null) return; // Only create a new SSO entry if the SSO did not already set a note // for an existing entry (as it would do with subsequent requests String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (ssoId == null) { ssoId = generateSessionId(); Cookie cookie = new Cookie(Constants.SINGLE_SIGN_ON_COOKIE, ssoId); cookie.setMaxAge(-1); cookie.setPath("/"); cookie.setSecure(request.isSecure()); String ssoDomain = sso.getCookieDomain(); if (ssoDomain != null) { cookie.setDomain(ssoDomain); } if (request.getServletContext().getSessionCookieConfig().isHttpOnly() || request.getContext().getUseHttpOnly()) { cookie.setHttpOnly(true); } response.addCookie(cookie); sso.register(ssoId, principal, authType, username, password); request.setNote(Constants.REQ_SSOID_NOTE, ssoId); } else { if (principal == null) { sso.deregister(ssoId); return; } else { sso.update(ssoId, principal, authType, username, password); } } if (session == null) session = request.getSessionInternal(true); sso.associate(ssoId, session); }	public void setResourceName(String resourceName) { this.resourceName = resourceName; }
private void addInjectionTarget(Injectable resource, Map<String, Map<String, String>> injectionMap) { List<InjectionTarget> injectionTargets = resource.getInjectionTargets(); if (injectionTargets != null && injectionTargets.size() > 0) { String jndiName = resource.getName(); for (InjectionTarget injectionTarget : injectionTargets) { String clazz = injectionTarget.getTargetClass(); Map<String, String> injections = injectionMap.get(clazz); if (injections == null) { injections = new HashMap<String, String>(); injectionMap.put(clazz, injections); } injections.put(injectionTarget.getTargetName(), jndiName); } } }	private Map<String, Map<String, String>> buildInjectionMap(NamingResources namingResources) { Map<String, Map<String, String>> injectionMap = new HashMap<String, Map<String, String>>(); for (Injectable resource : namingResources.findLocalEjbs()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findEjbs()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findEnvironments()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findMessageDestinationRefs()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findResourceEnvRefs()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findResources()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findServices()) { addInjectionTarget(resource, injectionMap); } return injectionMap; }	protected void setNewServletContextListenerAllowed(boolean allowed) { this.newServletContextListenerAllowed = allowed; }	public Enumeration<String> getInitParameterNames() { mergeParameters(); return (new Enumerator<String>(parameters.keySet())); }	@Override public boolean setInitParameter(String name, String value) { mergeParameters(); if (parameters.containsKey(name)) { return false; } parameters.put(name, value); return true; }
public Servlet getServlet() throws ServletException { if (reload) { synchronized (this) { if (reload) { destroy(); Servlet servlet = null; try { InstanceManager instanceManager = InstanceManagerFactory.getInstanceManager(config); servlet = (Servlet) instanceManager.newInstance(ctxt.getFQCN(), ctxt.getJspLoader()); } catch (IllegalAccessException e) { throw new JasperException(e); } catch (InstantiationException e) { throw new JasperException(e); } catch (Exception e) { throw new JasperException(e); } servlet.init(config); if (!firstTime) { ctxt.getRuntimeContext().incrementJspReloadCount(); } theServlet = servlet; reload = false; } } } return theServlet; }	public java.util.List<String> getDependants() { try { Object target; if (isTagFile) { if (reload) { tagHandlerClass = ctxt.load(); reload = false; } target = tagHandlerClass.newInstance(); } else { target = getServlet(); } if (target != null && target instanceof JspSourceDependent) { return ((JspSourceDependent) target).getDependants(); } } catch (Throwable ex) { ExceptionUtils.handleThrowable(ex); } return null; }
public static final String formatDate(long value, DateFormat threadLocalformat) { Long longValue = new Long(value); String cachedDate = formatCache.get(longValue); if (cachedDate != null) return cachedDate; String newDate = null; Date dateValue = new Date(value); if (threadLocalformat != null) { newDate = threadLocalformat.format(dateValue); updateFormatCache(longValue, newDate); } else { synchronized (formatCache) { synchronized (format) { newDate = format.format(dateValue); } updateFormatCache(longValue, newDate); } } return newDate; }
protected AjpAprProcessor createProcessor() { AjpAprProcessor processor = new AjpAprProcessor(proto.packetSize, proto.endpoint); processor.setAdapter(proto.adapter); processor.setTomcatAuthentication(proto.tomcatAuthentication); processor.setRequiredSecret(proto.requiredSecret); register(processor); return processor; }	protected AjpProcessor createProcessor() { AjpProcessor processor = new AjpProcessor(proto.packetSize, proto.endpoint); processor.setAdapter(proto.adapter); processor.setTomcatAuthentication(proto.tomcatAuthentication); processor.setRequiredSecret(proto.requiredSecret); processor.setKeepAliveTimeout(proto.keepAliveTimeout); register(processor); return processor; }	protected void unregister(AjpAprProcessor processor) { if (proto.getDomain() != null) { synchronized (this) { try { RequestInfo rp = processor.getRequest().getRequestProcessor(); rp.setGlobalProcessor(null); ObjectName rpName = rp.getRpName(); if (log.isDebugEnabled()) { log.debug("Unregister " + rpName); } Registry.getRegistry(null, null).unregisterComponent(rpName); rp.setRpName(null); } catch (Exception e) { log.warn("Error unregistering request", e); } } } }	protected void unregister(AjpProcessor processor) { if (proto.getDomain() != null) { synchronized (this) { try { RequestInfo rp = processor.getRequest().getRequestProcessor(); rp.setGlobalProcessor(null); ObjectName rpName = rp.getRpName(); if (log.isDebugEnabled()) { log.debug("Unregister " + rpName); } Registry.getRegistry(null, null).unregisterComponent(rpName); rp.setRpName(null); } catch (Exception e) { log.warn("Error unregistering request", e); } } } }	@Override public SocketState asyncDispatch(SocketWrapper<Long> socket, SocketStatus status) { AjpAprProcessor result = connections.get(socket); SocketState state = SocketState.CLOSED; if (result != null) { try { state = result.asyncDispatch(socket, status); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); // any other exception or error is odd. Here we log it // with "ERROR" level, so it will show up even on AjpAprProtocol.log.error(sm.getString("ajpprotocol.proto.error"), e); } finally { if (state == SocketState.LONG && result.isAsync()) { state = result.asyncPostProcess(); } if (state != SocketState.LONG && state != SocketState.ASYNC_END) { connections.remove(socket); recycledProcessors.offer(result); if (state == SocketState.OPEN) { proto.endpoint.getPoller().add(socket.getSocket().longValue()); } } } } return state; }	@Override public void init() throws Exception { endpoint.setName(getName()); endpoint.setHandler(cHandler); endpoint.setUseSendfile(false); try { endpoint.init(); } catch (Exception ex) { log.error(sm.getString("ajpprotocol.endpoint.initerror"), ex); throw ex; } if (log.isInfoEnabled()) { log.info(sm.getString("ajpprotocol.init", getName())); } }	@Override public void init() throws Exception { endpoint.setName(getName()); endpoint.setHandler(cHandler); try { endpoint.init(); } catch (Exception ex) { log.error(sm.getString("ajpprotocol.endpoint.initerror"), ex); throw ex; } if (log.isInfoEnabled()) { log.info(sm.getString("ajpprotocol.init", getName())); } }	@Override public void start() throws Exception { if (this.domain != null) { try { tpOname = new ObjectName(domain + ":" + "type=ThreadPool,name=" + getName()); Registry.getRegistry(null, null).registerComponent(endpoint, tpOname, null); } catch (Exception e) { log.error("Can't register threadpool"); } rgOname = new ObjectName(domain + ":type=GlobalRequestProcessor,name=" + getName()); Registry.getRegistry(null, null).registerComponent(cHandler.global, rgOname, null); } try { endpoint.start(); } catch (Exception ex) { log.error(sm.getString("ajpprotocol.endpoint.starterror"), ex); throw ex; } if (log.isInfoEnabled()) log.info(sm.getString("ajpprotocol.start", getName())); }	@Override public void start() throws Exception { if (this.domain != null) { try { tpOname = new ObjectName(domain + ":" + "type=ThreadPool,name=" + getName()); Registry.getRegistry(null, null).registerComponent(endpoint, tpOname, null); } catch (Exception e) { log.error("Can't register threadpool"); } rgOname = new ObjectName(domain + ":type=GlobalRequestProcessor,name=" + getName()); Registry.getRegistry(null, null).registerComponent(cHandler.global, rgOname, null); } try { endpoint.start(); } catch (Exception ex) { log.error(sm.getString("ajpprotocol.endpoint.starterror"), ex); throw ex; } if (log.isInfoEnabled()) log.info(sm.getString("ajpprotocol.start", getName())); }
protected static void lookupFieldResource(Context context, Object instance, Field field, String name, Class<?> clazz) throws NamingException, IllegalAccessException { Object lookedupResource; boolean accessibility; if ((name != null) && (name.length() > 0)) { lookedupResource = context.lookup(name); } else { lookedupResource = context.lookup(clazz.getName() + "/" + field.getName()); } accessibility = field.isAccessible(); field.setAccessible(true); field.set(instance, lookedupResource); field.setAccessible(accessibility); }	protected static void lookupMethodResource(Context context, Object instance, Method method, String name, Class<?> clazz) throws NamingException, IllegalAccessException, InvocationTargetException { if (!method.getName().startsWith("set") || method.getName().length() < 4 || method.getParameterTypes().length != 1 || !method.getReturnType().getName().equals("void")) { throw new IllegalArgumentException("Invalid method resource injection annotation"); } Object lookedupResource; boolean accessibility; if ((name != null) && (name.length() > 0)) { lookedupResource = context.lookup(name); } else { lookedupResource = context.lookup(clazz.getName() + "/" + getName(method)); } accessibility = method.isAccessible(); method.setAccessible(true); method.invoke(instance, lookedupResource); method.setAccessible(accessibility); }	public static String getName(Method setter) { StringBuilder name = new StringBuilder(setter.getName()); name.delete(0, 3); name.setCharAt(0, Character.toLowerCase(name.charAt(0))); return name.toString(); }
public boolean listenerStart() { if (log.isDebugEnabled()) log.debug("Configuring application event listeners"); String[] listeners = findApplicationListeners(); Object[] results = new Object[listeners.length]; boolean ok = true; for (int i = 0; i < results.length; i++) { if (getLogger().isDebugEnabled()) getLogger().debug(" Configuring event listener class '" + listeners[i] + "'"); try { results[i] = instanceManager.newInstance(listeners[i]); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getLogger().error(sm.getString("standardContext.applicationListener", listeners[i]), t); ok = false; } } if (!ok) { getLogger().error(sm.getString("standardContext.applicationSkipped")); return (false); } ArrayList<Object> eventListeners = new ArrayList<Object>(); ArrayList<Object> lifecycleListeners = new ArrayList<Object>(); for (int i = 0; i < results.length; i++) { if ((results[i] instanceof ServletContextAttributeListener) || (results[i] instanceof ServletRequestAttributeListener) || (results[i] instanceof ServletRequestListener) || (results[i] instanceof HttpSessionAttributeListener)) { eventListeners.add(results[i]); } if ((results[i] instanceof ServletContextListener) || (results[i] instanceof HttpSessionListener)) { lifecycleListeners.add(results[i]); } } setApplicationEventListeners(eventListeners.toArray()); setApplicationLifecycleListeners(lifecycleListeners.toArray()); if (getLogger().isDebugEnabled()) getLogger().debug("Sending application start events"); getServletContext(); context.setNewServletContextListenerAllowed(false); Object[] instances = getApplicationLifecycleListeners(); if (instances == null) return (ok); ServletContextEvent event = new ServletContextEvent(getServletContext()); for (int i = 0; i < instances.length; i++) { if (instances[i] == null) continue; if (!(instances[i] instanceof ServletContextListener)) continue; ServletContextListener listener = (ServletContextListener) instances[i]; try { fireContainerEvent("beforeContextInitialized", listener); listener.contextInitialized(event); fireContainerEvent("afterContextInitialized", listener); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); fireContainerEvent("afterContextInitialized", listener); getLogger().error(sm.getString("standardContext.listenerStart", instances[i].getClass().getName()), t); ok = false; } } return (ok); }
private void logDebug(String method) { String rHashCode; String crHashCode; String rpHashCode; String stage; StringBuilder uri = new StringBuilder(); if (request == null) { rHashCode = "null"; crHashCode = "null"; rpHashCode = "null"; stage = "-"; uri.append("N/A"); } else { rHashCode = Integer.toHexString(request.hashCode()); org.apache.coyote.Request coyoteRequest = request.getCoyoteRequest(); if (coyoteRequest == null) { crHashCode = "null"; rpHashCode = "null"; stage = "-"; } else { crHashCode = Integer.toHexString(coyoteRequest.hashCode()); RequestInfo rp = coyoteRequest.getRequestProcessor(); if (rp == null) { rpHashCode = "null"; stage = "-"; } else { rpHashCode = Integer.toHexString(rp.hashCode()); stage = Integer.toString(rp.getStage()); } } uri.append(request.getRequestURI()); if (request.getQueryString() != null) { uri.append('?'); uri.append(request.getQueryString()); } } String threadName = Thread.currentThread().getName(); int len = threadName.length(); if (len > 20) { threadName = threadName.substring(len - 20, len); } String msg = String.format("Req: %1$8s CReq: %2$8s RP: %3$8s Stage: %4$s " + "Thread: %5$20s State: %6$20s Method: %7$11s URI: %8$s", rHashCode, crHashCode, rpHashCode, stage, Thread.currentThread().getName(), "N/A", method, uri); if (log.isTraceEnabled()) { log.trace(msg, new DebugException()); } else { log.debug(msg); } }	@Override public <T extends AsyncListener> T createListener(Class<T> clazz) throws ServletException { T listener = null; try { listener = clazz.newInstance(); } catch (InstantiationException e) { ServletException se = new ServletException(e); throw se; } catch (IllegalAccessException e) { ServletException se = new ServletException(e); throw se; } return listener; }

@Override public String toString() { StringBuilder sb = new StringBuilder("StandardServer["); sb.append(getPort()); sb.append("]"); return (sb.toString()); }	public synchronized void storeConfig() throws Exception { ObjectName sname = null; try { sname = new ObjectName("Catalina:type=StoreConfig"); if (mserver.isRegistered(sname)) { mserver.invoke(sname, "storeConfig", null, null); } else log.error("StoreConfig mbean not registered" + sname); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(t); } }
@Override public void startQueue() { if (run) return; executor = new ThreadPoolExecutor(maxSpareThreads, maxThreads, keepAliveTime, TimeUnit.MILLISECONDS, runnablequeue); run = true; }
@Override public String toString() { return super.toString() + "[intOps=" + this.interestOps + "]"; }	protected Log getLog() { return log; }
private JMXConnectorServer createServer(String serverName, int theRmiRegistryPort, int theRmiServerPort, HashMap<String, Object> theEnv, MBeanServer theMBeanServer) { try { LocateRegistry.createRegistry(theRmiRegistryPort); } catch (RemoteException e) { log.error(sm.getString("jmxRemoteLifecycleListener.createRegistryFailed", serverName, Integer.toString(theRmiRegistryPort)), e); return null; } StringBuilder url = new StringBuilder(); url.append("service:jmx:rmi://localhost:"); url.append(theRmiServerPort); url.append("/jndi/rmi://localhost:"); url.append(theRmiRegistryPort); url.append("/jmxrmi"); JMXServiceURL serviceUrl; try { serviceUrl = new JMXServiceURL(url.toString()); } catch (MalformedURLException e) { log.error(sm.getString("jmxRemoteLifecycleListener.invalidURL", serverName, url.toString()), e); return null; } JMXConnectorServer cs = null; try { cs = JMXConnectorServerFactory.newJMXConnectorServer(serviceUrl, theEnv, theMBeanServer); cs.start(); log.info(sm.getString("jmxRemoteLifecycleListener.start", Integer.valueOf(theRmiRegistryPort), Integer.valueOf(theRmiServerPort), serverName)); } catch (IOException e) { log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed", serverName), e); } return cs; }

public boolean getUseIPVHosts() { return useIPVHosts; }
@Override protected void afterExecute(Runnable r, Throwable t) { activeCount.decrementAndGet(); }	@Override protected void beforeExecute(Thread t, Runnable r) { activeCount.incrementAndGet(); }	@Override public boolean offer(Runnable o) { if (parent == null) return super.offer(o); if (parent.getPoolSize() == parent.getMaximumPoolSize()) return super.offer(o); if (parent.getActiveCount() < (parent.getPoolSize())) return super.offer(o); if (parent.getPoolSize() < parent.getMaximumPoolSize()) return false; return super.offer(o); }	public void execute(Runnable command, long timeout, TimeUnit unit) { try { super.execute(command); } catch (RejectedExecutionException rx) { if (super.getQueue() instanceof TaskQueue) { final TaskQueue queue = (TaskQueue) super.getQueue(); try { if (!queue.force(command, timeout, unit)) { throw new RejectedExecutionException("Queue capacity is full."); } } catch (InterruptedException x) { Thread.interrupted(); throw new RejectedExecutionException(x); } } else { throw rx; } } }
private void initClassLoaders() { try { commonLoader = createClassLoader("common", null); if (commonLoader == null) { commonLoader = this.getClass().getClassLoader(); } catalinaLoader = createClassLoader("server", commonLoader); sharedLoader = createClassLoader("shared", commonLoader); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error("Class loader creation threw exception", t); System.exit(1); } }	public static String getCatalinaBase() { return System.getProperty(Globals.CATALINA_BASE_PROP, getCatalinaHome()); }	public static void main(String[] args) { if (daemon == null) { Bootstrap bootstrap = new Bootstrap(); try { bootstrap.init(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); t.printStackTrace(); return; } daemon = bootstrap; } try { String command = "start"; if (args.length > 0) { command = args[args.length - 1]; } if (command.equals("startd")) { args[args.length - 1] = "start"; daemon.load(args); daemon.start(); } else if (command.equals("stopd")) { args[args.length - 1] = "stop"; daemon.stop(); } else if (command.equals("start")) { daemon.setAwait(true); daemon.load(args); daemon.start(); } else if (command.equals("stop")) { daemon.stopServer(args); } else { log.warn("Bootstrap: command \"" + command + "\" does not exist."); } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); t.printStackTrace(); } }
private Node.Nodes doParse(String inFileName, Node parent, JarResource jarResource) throws FileNotFoundException, JasperException, IOException { Node.Nodes parsedPage = null; isEncodingSpecifiedInProlog = false; isBomPresent = false; isDefaultPageEncoding = false; JarFile jarFile = (jarResource == null) ? null : jarResource.getJarFile(); String absFileName = resolveFileName(inFileName); String jspConfigPageEnc = getJspConfigPageEncoding(absFileName); // Figure out what type of JSP document and encoding type we are determineSyntaxAndEncoding(absFileName, jarFile, jspConfigPageEnc); if (parent != null) { if (jarFile == null) { compiler.getPageInfo().addDependant(absFileName); } else { compiler.getPageInfo().addDependant(jarResource.getEntry(absFileName.substring(1)).toString()); } } if ((isXml && isEncodingSpecifiedInProlog) || isBomPresent) { if (jspConfigPageEnc != null && !jspConfigPageEnc.equals(sourceEnc) && (!jspConfigPageEnc.startsWith("UTF-16") || !sourceEnc.startsWith("UTF-16"))) { err.jspError("jsp.error.prolog_config_encoding_mismatch", sourceEnc, jspConfigPageEnc); } } if (isXml) { // JSP document (XML syntax) // InputStream for jspx page is created and properly closed in parsedPage = JspDocumentParser.parse(this, absFileName, jarFile, parent, isTagFile, directiveOnly, sourceEnc, jspConfigPageEnc, isEncodingSpecifiedInProlog, isBomPresent); } else { InputStreamReader inStreamReader = null; try { inStreamReader = JspUtil.getReader(absFileName, sourceEnc, jarFile, ctxt, err, skip); JspReader jspReader = new JspReader(ctxt, absFileName, sourceEnc, inStreamReader, err); parsedPage = Parser.parse(this, jspReader, parent, isTagFile, directiveOnly, jarResource, sourceEnc, jspConfigPageEnc, isDefaultPageEncoding, isBomPresent); } finally { if (inStreamReader != null) { try { inStreamReader.close(); } catch (Exception any) { } } } } if (jarFile != null) { try { jarFile.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } baseDirStack.pop(); return parsedPage; }	void postCheck() throws JasperException { Iterator<String> iter = nameFromTable.keySet().iterator(); while (iter.hasNext()) { String nameFrom = iter.next(); NameEntry nameEntry = nameTable.get(nameFrom); NameEntry nameFromEntry = nameFromTable.get(nameFrom); Node nameFromNode = nameFromEntry.getNode(); if (nameEntry == null) { err.jspError(nameFromNode, "jsp.error.tagfile.nameFrom.noAttribute", nameFrom); } else { Node node = nameEntry.getNode(); TagAttributeInfo tagAttr = nameEntry.getTagAttributeInfo(); if (!"java.lang.String".equals(tagAttr.getTypeName()) || !tagAttr.isRequired() || tagAttr.canBeRequestTime()) { err.jspError(nameFromNode, "jsp.error.tagfile.nameFrom.badAttribute", nameFrom, Integer.toString(node.getStart().getLineNumber())); } } } }
public void stopServer(String[] arguments) { if (arguments != null) { arguments(arguments); } if (getServer() == null) { Digester digester = createStopDigester(); digester.setClassLoader(Thread.currentThread().getContextClassLoader()); File file = configFile(); try { InputSource is = new InputSource("file://" + file.getAbsolutePath()); FileInputStream fis = new FileInputStream(file); is.setByteStream(fis); digester.push(this); digester.parse(is); fis.close(); } catch (Exception e) { log.error("Catalina.stop: ", e); System.exit(1); } } try { if (getServer().getPort() > 0) { Socket socket = new Socket(getServer().getAddress(), getServer().getPort()); OutputStream stream = socket.getOutputStream(); String shutdown = getServer().getShutdown(); for (int i = 0; i < shutdown.length(); i++) stream.write(shutdown.charAt(i)); stream.flush(); stream.close(); socket.close(); } else { log.error(sm.getString("catalina.stopServer")); System.exit(1); } } catch (IOException e) { log.error("Catalina.stop: ", e); System.exit(1); } }
private InputStream getResourceAsStream(String uri) throws FileNotFoundException { if (uri.startsWith("file:")) { return new FileInputStream(new File(uri.substring(5))); } else { try { String real = ctxt.getRealPath(uri); if (real == null) { return ctxt.getResourceAsStream(uri); } else { return new FileInputStream(real); } } catch (FileNotFoundException ex) { return ctxt.getResourceAsStream(uri); } } }	private TagLibraryInfo getTaglibInfo(String prefix, String uri) throws JasperException { TagLibraryInfo result = null; if (uri.startsWith(URN_JSPTAGDIR)) { String tagdir = uri.substring(URN_JSPTAGDIR.length()); result = new ImplicitTagLibraryInfo(ctxt, parserController, pageInfo, prefix, tagdir, err); } else { boolean isPlainUri = false; if (uri.startsWith(URN_JSPTLD)) { uri = uri.substring(URN_JSPTLD.length()); } else { isPlainUri = true; } TldLocation location = ctxt.getTldLocation(uri); if (location != null || !isPlainUri) { if (ctxt.getOptions().isCaching()) { result = ctxt.getOptions().getCache().get(uri); } if (result == null) { result = new TagLibraryInfoImpl(ctxt, parserController, pageInfo, prefix, uri, location, err); if (ctxt.getOptions().isCaching()) { ctxt.getOptions().getCache().put(uri, result); } } } } return result; }	private void parseTaglibDirective(Node parent) throws JasperException { Attributes attrs = parseAttributes(); String uri = attrs.getValue("uri"); String prefix = attrs.getValue("prefix"); if (prefix != null) { Mark prevMark = pageInfo.getNonCustomTagPrefix(prefix); if (prevMark != null) { err.jspError(reader.mark(), "jsp.error.prefix.use_before_dcl", prefix, prevMark.getFile(), "" + prevMark.getLineNumber()); } if (uri != null) { String uriPrev = pageInfo.getURI(prefix); if (uriPrev != null && !uriPrev.equals(uri)) { err.jspError(reader.mark(), "jsp.error.prefix.refined", prefix, uri, uriPrev); } if (pageInfo.getTaglib(uri) == null) { TagLibraryInfoImpl impl = null; if (ctxt.getOptions().isCaching()) { impl = (TagLibraryInfoImpl) ctxt.getOptions().getCache().get(uri); } if (impl == null) { TldLocation location = ctxt.getTldLocation(uri); impl = new TagLibraryInfoImpl(ctxt, parserController, pageInfo, prefix, uri, location, err); if (ctxt.getOptions().isCaching()) { ctxt.getOptions().getCache().put(uri, impl); } } else { for (TagFileInfo info : impl.getTagFiles()) { ctxt.setTagFileJarResource(info.getPath(), ctxt.getTagFileJarResource()); } } pageInfo.addTaglib(uri, impl); } pageInfo.addPrefixMapping(prefix, uri); } else { String tagdir = attrs.getValue("tagdir"); if (tagdir != null) { String urnTagdir = URN_JSPTAGDIR + tagdir; if (pageInfo.getTaglib(urnTagdir) == null) { pageInfo.addTaglib(urnTagdir, new ImplicitTagLibraryInfo(ctxt, parserController, pageInfo, prefix, tagdir, err)); } pageInfo.addPrefixMapping(prefix, urnTagdir); } } } new Node.TaglibDirective(attrs, start, parent); }	@Override public TagLibraryInfo[] getTagLibraryInfos() { Collection<TagLibraryInfo> coll = pi.getTaglibs(); return coll.toArray(new TagLibraryInfo[0]); }	@Override public void visit(Node.GetProperty n) throws JasperException { String name = n.getTextAttribute("name"); String property = n.getTextAttribute("property"); n.setBeginJavaLine(out.getJavaLine()); if (beanInfo.checkVariable(name)) { Class<?> bean = beanInfo.getBeanType(name); String beanName = bean.getCanonicalName(); java.lang.reflect.Method meth = JspRuntimeLibrary.getReadMethod(bean, property); String methodName = meth.getName(); out.printil("out.write(org.apache.jasper.runtime.JspRuntimeLibrary.toString(" + "(((" + beanName + ")_jspx_page_context.findAttribute(" + "\"" + name + "\"))." + methodName + "())));"); } else if (!STRICT_GET_PROPERTY || varInfoNames.contains(name)) { // The object is a custom action with an associated // VariableInfo entry for this name. out.printil("out.write(org.apache.jasper.runtime.JspRuntimeLibrary.toString" + "(org.apache.jasper.runtime.JspRuntimeLibrary.handleGetProperty" + "(_jspx_page_context.findAttribute(\"" + name + "\"), \"" + property + "\")));"); } else { StringBuilder msg = new StringBuilder("jsp:getProperty for bean with name '"); msg.append(name); msg.append("'. Name was not previously introduced as per JSP.5.3"); throw new JasperException(msg.toString()); } n.setEndJavaLine(out.getJavaLine()); }
private void prepareResponse() { boolean entityBody = true; contentDelimitation = false; OutputFilter[] outputFilters = getOutputBuffer().getFilters(); if (http09 == true) { getOutputBuffer().addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); return; } int statusCode = response.getStatus(); if ((statusCode == 204) || (statusCode == 205) || (statusCode == 304)) { getOutputBuffer().addActiveFilter(outputFilters[Constants.VOID_FILTER]); entityBody = false; contentDelimitation = true; } MessageBytes methodMB = request.method(); if (methodMB.equals("HEAD")) { getOutputBuffer().addActiveFilter(outputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } boolean sendingWithSendfile = false; if (getEndpoint().getUseSendfile()) { sendingWithSendfile = prepareSendfile(outputFilters); } boolean useCompression = false; if (entityBody && (compressionLevel > 0) && !sendingWithSendfile) { useCompression = isCompressable(); if (useCompression) { response.setContentLength(-1); } } MimeHeaders headers = response.getMimeHeaders(); if (!entityBody) { response.setContentLength(-1); } else { String contentType = response.getContentType(); if (contentType != null) { headers.setValue("Content-Type").setString(contentType); } String contentLanguage = response.getContentLanguage(); if (contentLanguage != null) { headers.setValue("Content-Language").setString(contentLanguage); } } long contentLength = response.getContentLengthLong(); if (contentLength != -1) { headers.setValue("Content-Length").setLong(contentLength); getOutputBuffer().addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } else { if (entityBody && http11) { getOutputBuffer().addActiveFilter(outputFilters[Constants.CHUNKED_FILTER]); contentDelimitation = true; headers.addValue(Constants.TRANSFERENCODING).setString(Constants.CHUNKED); } else { getOutputBuffer().addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); } } if (useCompression) { getOutputBuffer().addActiveFilter(outputFilters[Constants.GZIP_FILTER]); headers.setValue("Content-Encoding").setString("gzip"); MessageBytes vary = headers.getValue("Vary"); if (vary == null) { headers.setValue("Vary").setString("Accept-Encoding"); } else if (vary.equals("*")) { // No action required } else { headers.setValue("Vary").setString(vary.getString() + ",Accept-Encoding"); } } headers.setValue("Date").setString(FastHttpDateFormat.getCurrentDate()); if ((entityBody) && (!contentDelimitation)) { // Mark as close the connection after the request, and add the keepAlive = false; } // If we know that the request is bad this early, add the keepAlive = keepAlive && !statusDropsConnection(statusCode); if (!keepAlive) { headers.addValue(Constants.CONNECTION).setString(Constants.CLOSE); } else if (!http11 && !error) { headers.addValue(Constants.CONNECTION).setString(Constants.KEEPALIVE); } getOutputBuffer().sendStatus(); if (server != null) { headers.setValue("Server").setString(server); } else if (headers.getValue("Server") == null) { getOutputBuffer().write(Constants.SERVER_BYTES); } int size = headers.size(); for (int i = 0; i < size; i++) { getOutputBuffer().sendHeader(headers.getName(i), headers.getValue(i)); } getOutputBuffer().endHeaders(); }	protected boolean isCompressable() { // Nope Compression could works in HTTP 1.0 also // cf: mod_deflate // Compression only since HTTP 1.1 // if (! http11) // return false; MessageBytes acceptEncodingMB = request.getMimeHeaders().getValue("accept-encoding"); if ((acceptEncodingMB == null) || (acceptEncodingMB.indexOf("gzip") == -1)) return false; MessageBytes contentEncodingMB = response.getMimeHeaders().getValue("Content-Encoding"); if ((contentEncodingMB != null) && (contentEncodingMB.indexOf("gzip") != -1)) return false; if (compressionLevel == 2) return true; if (noCompressionUserAgents != null) { MessageBytes userAgentValueMB = request.getMimeHeaders().getValue("user-agent"); if (userAgentValueMB != null) { String userAgentValue = userAgentValueMB.toString(); for (int i = 0; i < noCompressionUserAgents.length; i++) if (noCompressionUserAgents[i].matcher(userAgentValue).matches()) return false; } } long contentLength = response.getContentLengthLong(); if ((contentLength == -1) || (contentLength > compressionMinSize)) { if (compressableMimeTypes != null) { return (startsWithStringArray(compressableMimeTypes, response.getContentType())); } } return false; }	public Adapter getAdapter() { return adapter; }
private final void clearReferencesJdbc() { InputStream is = getResourceAsStream("org/apache/catalina/loader/JdbcLeakPrevention.class"); // We know roughly how big the class will be (~ 1K) so allow 2k as a byte[] classBytes = new byte[2048]; int offset = 0; try { int read = is.read(classBytes, offset, classBytes.length - offset); while (read > -1) { offset += read; if (offset == classBytes.length) { byte[] tmp = new byte[classBytes.length * 2]; System.arraycopy(classBytes, 0, tmp, 0, classBytes.length); classBytes = tmp; } read = is.read(classBytes, offset, classBytes.length - offset); } Class<?> lpClass = defineClass("org.apache.catalina.loader.JdbcLeakPrevention", classBytes, 0, offset); Object obj = lpClass.newInstance(); @SuppressWarnings("unchecked") List<String> driverNames = (List<String>) obj.getClass().getMethod("clearJdbcDriverRegistrations").invoke(obj); for (String name : driverNames) { log.error(sm.getString("webappClassLoader.clearJbdc", contextName, name)); } } catch (Exception e) { log.warn(sm.getString("webappClassLoader.jdbcRemoveFailed", contextName), e); } finally { if (is != null) { try { is.close(); } catch (IOException ioe) { log.warn(sm.getString("webappClassLoader.jdbcRemoveStreamError", contextName), ioe); } } } }
protected void prepareRequest() { byte methodCode = requestHeaderMessage.getByte(); if (methodCode != Constants.SC_M_JK_STORED) { String methodName = Constants.methodTransArray[methodCode - 1]; request.method().setString(methodName); } requestHeaderMessage.getBytes(request.protocol()); requestHeaderMessage.getBytes(request.requestURI()); requestHeaderMessage.getBytes(request.remoteAddr()); requestHeaderMessage.getBytes(request.remoteHost()); requestHeaderMessage.getBytes(request.localName()); request.setLocalPort(requestHeaderMessage.getInt()); boolean isSSL = requestHeaderMessage.getByte() != 0; if (isSSL) { request.scheme().setString("https"); } MimeHeaders headers = request.getMimeHeaders(); int hCount = requestHeaderMessage.getInt(); for (int i = 0; i < hCount; i++) { String hName = null; // Header names are encoded as either an integer code starting // with 0xA0, or as a normal string (in which case the first int isc = requestHeaderMessage.peekInt(); int hId = isc & 0xFF; MessageBytes vMB = null; isc &= 0xFF00; if (0xA000 == isc) { requestHeaderMessage.getInt(); hName = Constants.headerTransArray[hId - 1]; vMB = headers.addValue(hName); } else { // reset hId -- if the header currently being read // happens to be 7 or 8 bytes long, the code below // will think it's the content-type header or the // content-length header - SC_REQ_CONTENT_TYPE=7, // SC_REQ_CONTENT_LENGTH=8 - leading to unexpected hId = -1; requestHeaderMessage.getBytes(tmpMB); ByteChunk bc = tmpMB.getByteChunk(); vMB = headers.addValue(bc.getBuffer(), bc.getStart(), bc.getLength()); } requestHeaderMessage.getBytes(vMB); if (hId == Constants.SC_REQ_CONTENT_LENGTH || (hId == -1 && tmpMB.equalsIgnoreCase("Content-Length"))) { long cl = vMB.getLong(); if (cl < Integer.MAX_VALUE) request.setContentLength((int) cl); } else if (hId == Constants.SC_REQ_CONTENT_TYPE || (hId == -1 && tmpMB.equalsIgnoreCase("Content-Type"))) { ByteChunk bchunk = vMB.getByteChunk(); request.contentType().setBytes(bchunk.getBytes(), bchunk.getOffset(), bchunk.getLength()); } } boolean secret = false; byte attributeCode; while ((attributeCode = requestHeaderMessage.getByte()) != Constants.SC_A_ARE_DONE) { switch(attributeCode) { case Constants.SC_A_REQ_ATTRIBUTE: requestHeaderMessage.getBytes(tmpMB); String n = tmpMB.toString(); requestHeaderMessage.getBytes(tmpMB); String v = tmpMB.toString(); if (n.equals(Constants.SC_A_REQ_REMOTE_PORT)) { try { request.setRemotePort(Integer.parseInt(v)); } catch (NumberFormatException nfe) { } } else { request.setAttribute(n, v); } break; case Constants.SC_A_CONTEXT: requestHeaderMessage.getBytes(tmpMB); break; case Constants.SC_A_SERVLET_PATH: requestHeaderMessage.getBytes(tmpMB); break; case Constants.SC_A_REMOTE_USER: if (tomcatAuthentication) { requestHeaderMessage.getBytes(tmpMB); } else { requestHeaderMessage.getBytes(request.getRemoteUser()); } break; case Constants.SC_A_AUTH_TYPE: if (tomcatAuthentication) { requestHeaderMessage.getBytes(tmpMB); } else { requestHeaderMessage.getBytes(request.getAuthType()); } break; case Constants.SC_A_QUERY_STRING: requestHeaderMessage.getBytes(request.queryString()); break; case Constants.SC_A_JVM_ROUTE: requestHeaderMessage.getBytes(request.instanceId()); break; case Constants.SC_A_SSL_CERT: request.scheme().setString("https"); requestHeaderMessage.getBytes(certificates); break; case Constants.SC_A_SSL_CIPHER: request.scheme().setString("https"); requestHeaderMessage.getBytes(tmpMB); request.setAttribute(AbstractEndpoint.CIPHER_SUITE_KEY, tmpMB.toString()); break; case Constants.SC_A_SSL_SESSION: request.scheme().setString("https"); requestHeaderMessage.getBytes(tmpMB); request.setAttribute(AbstractEndpoint.SESSION_ID_KEY, tmpMB.toString()); break; case Constants.SC_A_SSL_KEY_SIZE: request.setAttribute(AbstractEndpoint.KEY_SIZE_KEY, new Integer(requestHeaderMessage.getInt())); break; case Constants.SC_A_STORED_METHOD: requestHeaderMessage.getBytes(request.method()); break; case Constants.SC_A_SECRET: requestHeaderMessage.getBytes(tmpMB); if (requiredSecret != null) { secret = true; if (!tmpMB.equals(requiredSecret)) { response.setStatus(403); adapter.log(request, response, 0); error = true; } } break; default: break; } } if ((requiredSecret != null) && !secret) { response.setStatus(403); adapter.log(request, response, 0); error = true; } ByteChunk uriBC = request.requestURI().getByteChunk(); if (uriBC.startsWithIgnoreCase("http", 0)) { int pos = uriBC.indexOf("://", 0, 3, 4); int uriBCStart = uriBC.getStart(); int slashPos = -1; if (pos != -1) { byte[] uriB = uriBC.getBytes(); slashPos = uriBC.indexOf('/', pos + 3); if (slashPos == -1) { slashPos = uriBC.getLength(); request.requestURI().setBytes(uriB, uriBCStart + pos + 1, 1); } else { request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos); } MessageBytes hostMB = headers.setValue("host"); hostMB.setBytes(uriB, uriBCStart + pos + 3, slashPos - pos - 3); } } MessageBytes valueMB = request.getMimeHeaders().getValue("host"); parseHost(valueMB); }	protected void prepareRequest() { byte methodCode = requestHeaderMessage.getByte(); if (methodCode != Constants.SC_M_JK_STORED) { String methodName = Constants.methodTransArray[methodCode - 1]; request.method().setString(methodName); } requestHeaderMessage.getBytes(request.protocol()); requestHeaderMessage.getBytes(request.requestURI()); requestHeaderMessage.getBytes(request.remoteAddr()); requestHeaderMessage.getBytes(request.remoteHost()); requestHeaderMessage.getBytes(request.localName()); request.setLocalPort(requestHeaderMessage.getInt()); boolean isSSL = requestHeaderMessage.getByte() != 0; if (isSSL) { request.scheme().setString("https"); } MimeHeaders headers = request.getMimeHeaders(); int hCount = requestHeaderMessage.getInt(); for (int i = 0; i < hCount; i++) { String hName = null; // Header names are encoded as either an integer code starting // with 0xA0, or as a normal string (in which case the first int isc = requestHeaderMessage.peekInt(); int hId = isc & 0xFF; MessageBytes vMB = null; isc &= 0xFF00; if (0xA000 == isc) { requestHeaderMessage.getInt(); hName = Constants.headerTransArray[hId - 1]; vMB = headers.addValue(hName); } else { // reset hId -- if the header currently being read // happens to be 7 or 8 bytes long, the code below // will think it's the content-type header or the // content-length header - SC_REQ_CONTENT_TYPE=7, // SC_REQ_CONTENT_LENGTH=8 - leading to unexpected hId = -1; requestHeaderMessage.getBytes(tmpMB); ByteChunk bc = tmpMB.getByteChunk(); vMB = headers.addValue(bc.getBuffer(), bc.getStart(), bc.getLength()); } requestHeaderMessage.getBytes(vMB); if (hId == Constants.SC_REQ_CONTENT_LENGTH || (hId == -1 && tmpMB.equalsIgnoreCase("Content-Length"))) { long cl = vMB.getLong(); if (cl < Integer.MAX_VALUE) request.setContentLength((int) cl); } else if (hId == Constants.SC_REQ_CONTENT_TYPE || (hId == -1 && tmpMB.equalsIgnoreCase("Content-Type"))) { ByteChunk bchunk = vMB.getByteChunk(); request.contentType().setBytes(bchunk.getBytes(), bchunk.getOffset(), bchunk.getLength()); } } boolean secret = false; byte attributeCode; while ((attributeCode = requestHeaderMessage.getByte()) != Constants.SC_A_ARE_DONE) { switch(attributeCode) { case Constants.SC_A_REQ_ATTRIBUTE: requestHeaderMessage.getBytes(tmpMB); String n = tmpMB.toString(); requestHeaderMessage.getBytes(tmpMB); String v = tmpMB.toString(); if (n.equals(Constants.SC_A_REQ_REMOTE_PORT)) { try { request.setRemotePort(Integer.parseInt(v)); } catch (NumberFormatException nfe) { } } else { request.setAttribute(n, v); } break; case Constants.SC_A_CONTEXT: requestHeaderMessage.getBytes(tmpMB); break; case Constants.SC_A_SERVLET_PATH: requestHeaderMessage.getBytes(tmpMB); break; case Constants.SC_A_REMOTE_USER: if (tomcatAuthentication) { requestHeaderMessage.getBytes(tmpMB); } else { requestHeaderMessage.getBytes(request.getRemoteUser()); } break; case Constants.SC_A_AUTH_TYPE: if (tomcatAuthentication) { requestHeaderMessage.getBytes(tmpMB); } else { requestHeaderMessage.getBytes(request.getAuthType()); } break; case Constants.SC_A_QUERY_STRING: requestHeaderMessage.getBytes(request.queryString()); break; case Constants.SC_A_JVM_ROUTE: requestHeaderMessage.getBytes(request.instanceId()); break; case Constants.SC_A_SSL_CERT: request.scheme().setString("https"); requestHeaderMessage.getBytes(certificates); break; case Constants.SC_A_SSL_CIPHER: request.scheme().setString("https"); requestHeaderMessage.getBytes(tmpMB); request.setAttribute(AbstractEndpoint.CIPHER_SUITE_KEY, tmpMB.toString()); break; case Constants.SC_A_SSL_SESSION: request.scheme().setString("https"); requestHeaderMessage.getBytes(tmpMB); request.setAttribute(AbstractEndpoint.SESSION_ID_KEY, tmpMB.toString()); break; case Constants.SC_A_SSL_KEY_SIZE: request.setAttribute(AbstractEndpoint.KEY_SIZE_KEY, new Integer(requestHeaderMessage.getInt())); break; case Constants.SC_A_STORED_METHOD: requestHeaderMessage.getBytes(request.method()); break; case Constants.SC_A_SECRET: requestHeaderMessage.getBytes(tmpMB); if (requiredSecret != null) { secret = true; if (!tmpMB.equals(requiredSecret)) { response.setStatus(403); adapter.log(request, response, 0); error = true; } } break; default: break; } } if ((requiredSecret != null) && !secret) { response.setStatus(403); adapter.log(request, response, 0); error = true; } ByteChunk uriBC = request.requestURI().getByteChunk(); if (uriBC.startsWithIgnoreCase("http", 0)) { int pos = uriBC.indexOf("://", 0, 3, 4); int uriBCStart = uriBC.getStart(); int slashPos = -1; if (pos != -1) { byte[] uriB = uriBC.getBytes(); slashPos = uriBC.indexOf('/', pos + 3); if (slashPos == -1) { slashPos = uriBC.getLength(); request.requestURI().setBytes(uriB, uriBCStart + pos + 1, 1); } else { request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos); } MessageBytes hostMB = headers.setValue("host"); hostMB.setBytes(uriB, uriBCStart + pos + 3, slashPos - pos - 3); } } MessageBytes valueMB = request.getMimeHeaders().getValue("host"); parseHost(valueMB); }
protected boolean filter(String name) { if (name == null) return false; String packageName = null; int pos = name.lastIndexOf('.'); if (pos != -1) packageName = name.substring(0, pos); else return false; for (int i = 0; i < packageTriggers.length; i++) { if (packageName.startsWith(packageTriggers[i])) return true; } return false; }	protected boolean validate(String name) { if (name == null) return false; if (name.startsWith("java.")) return false; if (name.startsWith("javax.servlet.")) return false; return true; }
@Override public Object get(Object key) { MapEntry entry = (MapEntry) super.get(key); if (log.isTraceEnabled()) log.trace("Requesting id:" + key + " entry:" + entry); if (entry == null) return null; if (!entry.isPrimary()) { try { Member[] backup = null; MapMessage msg = null; if (!entry.isBackup()) { msg = new MapMessage(getMapContextName(), MapMessage.MSG_RETRIEVE_BACKUP, false, (Serializable) key, null, null, null, null); Response[] resp = getRpcChannel().send(entry.getBackupNodes(), msg, RpcChannel.FIRST_REPLY, Channel.SEND_OPTIONS_DEFAULT, getRpcTimeout()); if (resp == null || resp.length == 0) { log.warn("Unable to retrieve remote object for key:" + key); return null; } msg = (MapMessage) resp[0].getMessage(); msg.deserialize(getExternalLoaders()); backup = entry.getBackupNodes(); if (entry.getValue() instanceof ReplicatedMapEntry) { ReplicatedMapEntry val = (ReplicatedMapEntry) entry.getValue(); val.setOwner(getMapOwner()); } if (msg.getValue() != null) entry.setValue(msg.getValue()); } if (entry.isBackup()) { backup = publishEntryInfo(key, entry.getValue()); } else if (entry.isProxy()) { msg = new MapMessage(getMapContextName(), MapMessage.MSG_PROXY, false, (Serializable) key, null, null, channel.getLocalMember(false), backup); Member[] dest = getMapMembersExcl(backup); if (dest != null && dest.length > 0) { getChannel().send(dest, msg, getChannelSendOptions()); } } entry.setPrimary(channel.getLocalMember(false)); entry.setBackupNodes(backup); entry.setBackup(false); entry.setProxy(false); } catch (Exception x) { log.error("Unable to replicate out data for a LazyReplicatedMap.get operation", x); return null; } } if (log.isTraceEnabled()) log.trace("Requesting id:" + key + " result:" + entry.getValue()); if (entry.getValue() != null && entry.getValue() instanceof ReplicatedMapEntry) { ReplicatedMapEntry val = (ReplicatedMapEntry) entry.getValue(); val.setOwner(getMapOwner()); } return entry.getValue(); }	public void objectMadePrimay(Object key, Object value) { if (value != null && value instanceof DeltaSession) { DeltaSession session = (DeltaSession) value; synchronized (session) { session.access(); session.endAccess(); } } }
@Override protected void destroyInternal() throws LifecycleException { for (int i = 0; i < services.length; i++) { services[i].destroy(); } unregister(onameMBeanFactory); unregister(onameStringCache); unregister(onameNamingResoucres); super.destroyInternal(); }	@Override protected void destroyInternal() throws LifecycleException { synchronized (connectors) { for (Connector connector : connectors) { try { connector.destroy(); } catch (Exception e) { log.error(sm.getString("standardService.connector.destroyfailed", connector), e); } } } for (Executor executor : findExecutors()) { executor.destroy(); } if (container != null) { container.destroy(); } super.destroyInternal(); }	public void setGlobalNamingContext(javax.naming.Context globalNamingContext) { this.globalNamingContext = globalNamingContext; }	public void load() { long t1 = System.nanoTime(); initDirs(); initNaming(); Digester digester = createStartDigester(); InputSource inputSource = null; InputStream inputStream = null; File file = null; try { file = configFile(); inputStream = new FileInputStream(file); inputSource = new InputSource("file://" + file.getAbsolutePath()); } catch (Exception e) { // Ignore } if (inputStream == null) { try { inputStream = getClass().getClassLoader().getResourceAsStream(getConfigFile()); inputSource = new InputSource(getClass().getClassLoader().getResource(getConfigFile()).toString()); } catch (Exception e) { // Ignore } } if (inputStream == null) { try { inputStream = getClass().getClassLoader().getResourceAsStream("server-embed.xml"); inputSource = new InputSource(getClass().getClassLoader().getResource("server-embed.xml").toString()); } catch (Exception e) { // Ignore } } if ((inputStream == null) && (file != null)) { log.warn("Can't load server.xml from " + file.getAbsolutePath()); if (file.exists() && !file.canRead()) { log.warn("Permissions incorrect, read permission is not allowed on the file."); } return; } try { inputSource.setByteStream(inputStream); digester.push(this); digester.parse(inputSource); inputStream.close(); } catch (Exception e) { log.warn("Catalina.start using " + getConfigFile() + ": ", e); return; } initStreams(); try { getServer().init(); } catch (LifecycleException e) { if (Boolean.getBoolean("org.apache.catalina.startup.EXIT_ON_INIT_FAILURE")) throw new java.lang.Error(e); else log.error("Catalina.start", e); } long t2 = System.nanoTime(); if (log.isInfoEnabled()) log.info("Initialization processed in " + ((t2 - t1) / 1000000) + " ms"); }	@Override public void logAccess(Request request, Response response, long time, boolean useDefault) { boolean logged = false; if (accessLog != null) { accessLog.log(request, response, time); logged = true; } if (!logged && useDefault) { Host host = null; if (defaultAccessLog == null) { // If we reached this point, this Engine can't have an AccessLog host = (Host) findChild(getDefaultHost()); defaultAccessLog = host.getAccessLog(); if (defaultAccessLog == null) { Context context = (Context) host.findChild(""); if (context != null) { defaultAccessLog = context.getAccessLog(); } if (defaultAccessLog == null) { defaultAccessLog = new NoopAccessLog(); } } } defaultAccessLog.log(request, response, time); } }	public void setParentClassLoader(ClassLoader parentClassLoader) { this.parentClassLoader = parentClassLoader; }	public void setShutdown(String shutdown) { this.shutdown = shutdown; }
protected static void lookupMethodResource(Context context, Object instance, Method method, String name, Class<?> clazz) throws NamingException, IllegalAccessException, InvocationTargetException { if (!method.getName().startsWith("set") || method.getParameterTypes().length != 1 || !method.getReturnType().getName().equals("void")) { throw new IllegalArgumentException("Invalid method resource injection annotation"); } Object lookedupResource; boolean accessibility; if ((name != null) && (name.length() > 0)) { lookedupResource = context.lookup(name); } else { lookedupResource = context.lookup(clazz.getName() + "/" + method.getName().substring(3)); } accessibility = method.isAccessible(); method.setAccessible(true); method.invoke(instance, lookedupResource); method.setAccessible(accessibility); }
private void disconnect(boolean finalize) { if (isDiscarded()) { return; } setDiscarded(true); if (connection != null) { try { parent.disconnectEvent(this, finalize); connection.close(); } catch (Exception ignore) { if (log.isDebugEnabled()) { log.debug("Unable to close underlying SQL connection", ignore); } } } connection = null; xaConnection = null; lastConnected = -1; if (finalize) parent.finalize(this); }
@Override protected String getName() { // This method should never be called UnsupportedOperationException uoe = new UnsupportedOperationException(sm.getString("combinedRealm.getName")); log.error(sm.getString("combinedRealm.unexpectedMethod"), uoe); throw uoe; }
protected boolean processSocket(Socket socket) { try { SocketWrapper<Socket> wrapper = new SocketWrapper<Socket>(socket); wrapper.setKeepAliveLeft(getMaxKeepAliveRequests()); getExecutor().execute(new SocketProcessor(wrapper)); } catch (RejectedExecutionException x) { log.warn("Socket processing request was rejected for:" + socket, x); return false; } catch (Throwable t) { // This means we got an OOM or similar creating a thread, or that log.error(sm.getString("endpoint.process.fail"), t); return false; } return true; }	protected boolean processSocketWithOptions(long socket) { try { getExecutor().execute(new SocketWithOptionsProcessor(socket)); } catch (RejectedExecutionException x) { log.warn("Socket processing request was rejected for:" + socket, x); return false; } catch (Throwable t) { // This means we got an OOM or similar creating a thread, or that log.error(sm.getString("endpoint.process.fail"), t); return false; } return true; }	@Override protected void stopInternal() throws LifecycleException { setState(LifecycleState.STOPPING); mapperListener.destroy(); }	@Override protected void stopInternal() throws LifecycleException { synchronized (connectors) { for (Connector connector : connectors) { try { connector.pause(); } catch (Exception e) { log.error(sm.getString("standardService.connector.pauseFailed", connector), e); } } } try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } if (log.isInfoEnabled()) log.info(sm.getString("standardService.stop.name", this.name)); setState(LifecycleState.STOPPING); if (container != null) { synchronized (container) { container.stop(); } } synchronized (connectors) { for (Connector connector : connectors) { if (LifecycleState.INITIALIZED.equals(connector.getState())) { continue; } try { connector.stop(); } catch (Exception e) { log.error(sm.getString("standardService.connector.stopFailed", connector), e); } } } synchronized (executors) { for (Executor executor : executors) { executor.stop(); } } }	protected void unlockAccept() { java.net.Socket s = null; InetSocketAddress saddr = null; try { if (address == null) { saddr = new InetSocketAddress("localhost", getPort()); } else { saddr = new InetSocketAddress(address, getPort()); } s = new java.net.Socket(); s.setSoTimeout(getSocketProperties().getSoTimeout()); s.setSoLinger(getSocketProperties().getSoLingerOn(), getSocketProperties().getSoLingerTime()); if (log.isDebugEnabled()) { log.debug("About to unlock socket for:" + saddr); } s.connect(saddr, getSocketProperties().getUnlockTimeout()); if (log.isDebugEnabled()) { log.debug("Socket unlock completed for:" + saddr); } } catch (Exception e) { if (log.isDebugEnabled()) { log.debug(sm.getString("endpoint.debug.unlock", "" + getPort()), e); } } finally { if (s != null) { try { s.close(); } catch (Exception e) { // Ignore } } } }	@Override protected void unlockAccept() { java.net.Socket s = null; InetSocketAddress saddr = null; try { if (getAddress() == null) { saddr = new InetSocketAddress("localhost", getPort()); } else { saddr = new InetSocketAddress(getAddress(), getPort()); } s = new java.net.Socket(); s.setSoTimeout(getSocketProperties().getSoTimeout()); s.setSoLinger(getSocketProperties().getSoLingerOn(), getSocketProperties().getSoLingerTime()); if (log.isDebugEnabled()) { log.debug("About to unlock socket for:" + saddr); } s.connect(saddr, getSocketProperties().getUnlockTimeout()); if (deferAccept) { OutputStreamWriter sw; sw = new OutputStreamWriter(s.getOutputStream(), "ISO-8859-1"); sw.write("OPTIONS * HTTP/1.0\r\n" + "User-Agent: Tomcat wakeup connection\r\n\r\n"); sw.flush(); } if (log.isDebugEnabled()) { log.debug("Socket unlock completed for:" + saddr); } } catch (Exception e) { if (log.isDebugEnabled()) { log.debug(sm.getString("endpoint.debug.unlock", "" + getPort()), e); } } finally { if (s != null) { try { s.close(); } catch (Exception e) { // Ignore } } } }	public Executor getExecutor(String name) { synchronized (executors) { for (Executor executor : executors) { if (name.equals(executor.getName())) return executor; } } return null; }	public SocketState process(NioChannel socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); this.socket = socket; inputBuffer.setSocket(socket); outputBuffer.setSocket(socket); inputBuffer.setSelectorPool(endpoint.getSelectorPool()); outputBuffer.setSelectorPool(endpoint.getSelectorPool()); error = false; keepAlive = true; comet = false; async = false; long soTimeout = endpoint.getSoTimeout(); int keepAliveTimeout = endpoint.getKeepAliveTimeout(); boolean keptAlive = false; boolean openSocket = false; boolean recycle = true; final KeyAttachment ka = (KeyAttachment) socket.getAttachment(false); while (!error && keepAlive && !comet && !async) { ka.setTimeout(soTimeout); try { if (!disableUploadTimeout && keptAlive && soTimeout > 0) { socket.getIOChannel().socket().setSoTimeout((int) soTimeout); } if (!inputBuffer.parseRequestLine(keptAlive)) { // Haven't finished reading the request so keep the socket openSocket = true; if (inputBuffer.getParsingRequestLinePhase() < 2) { if (keepAliveTimeout > 0) ka.setTimeout(keepAliveTimeout); } else { // Started to read request line. Need to keep processor recycle = false; } break; } keptAlive = true; if (!inputBuffer.parseHeaders()) { //we've read part of the request, don't recycle it openSocket = true; recycle = false; break; } request.setStartTime(System.currentTimeMillis()); if (!disableUploadTimeout) { socket.getIOChannel().socket().setSoTimeout(timeout); } } catch (IOException e) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.header.parse"), e); } error = true; break; } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.header.parse"), t); } response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare"), t); } response.setStatus(400); adapter.log(request, response, 0); error = true; } } if (maxKeepAliveRequests == 1) keepAlive = false; if (maxKeepAliveRequests > 0 && ka.decrementKeepAlive() <= 0) keepAlive = false; if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); if (keepAlive && !error) { error = response.getErrorException() != null || statusDropsConnection(response.getStatus()); } SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); if (key != null) { NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment(); if (attach != null) { attach.setComet(comet); if (comet) { Integer comettimeout = (Integer) request.getAttribute("org.apache.tomcat.comet.timeout"); if (comettimeout != null) attach.setTimeout(comettimeout.longValue()); } } } } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("http11processor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (!comet && !async) { if (error) inputBuffer.setSwallowInput(false); endRequest(); } if (error) { response.setStatus(500); } request.updateCounters(); if (!comet && !async) { inputBuffer.nextRequest(); outputBuffer.nextRequest(); } if (sendfileData != null && !error) { ka.setSendfileData(sendfileData); sendfileData.keepAlive = keepAlive; SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); openSocket = socket.getPoller().processSendfile(key, ka, true, true); break; } rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (comet || async) { if (error) { recycle(); return SocketState.CLOSED; } else { return SocketState.LONG; } } else { if (recycle) { recycle(); } return (openSocket) ? (recycle ? SocketState.OPEN : SocketState.LONG) : SocketState.CLOSED; } }	public SocketState process(SocketWrapper<Socket> socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); this.socket = socket; input = socket.getSocket().getInputStream(); output = socket.getSocket().getOutputStream(); int soTimeout = -1; if (keepAliveTimeout > 0) { soTimeout = socket.getSocket().getSoTimeout(); } error = false; while (started && !error) { try { if (keepAliveTimeout > 0) { socket.getSocket().setSoTimeout(keepAliveTimeout); } if (!readMessage(requestHeaderMessage)) { rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); break; } if (keepAliveTimeout > 0) { socket.getSocket().setSoTimeout(soTimeout); } // Check message type, process right away and break if int type = requestHeaderMessage.getByte(); if (type == Constants.JK_AJP13_CPING_REQUEST) { try { output.write(pongMessageArray); } catch (IOException e) { error = true; } continue; } else if (type != Constants.JK_AJP13_FORWARD_REQUEST) { if (log.isDebugEnabled()) { log.debug("Unexpected message: " + type); } continue; } request.setStartTime(System.currentTimeMillis()); } catch (IOException e) { error = true; break; } catch (Throwable t) { log.debug(sm.getString("ajpprocessor.header.error"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { log.debug(sm.getString("ajpprocessor.request.prepare"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("ajpprocessor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (async && !error) { break; } if (!finished) { try { finish(); } catch (Throwable t) { error = true; } } if (error) { response.setStatus(500); } request.updateCounters(); rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); recycle(); } if (async && !error) { rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); return SocketState.LONG; } else { rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); recycle(); input = null; output = null; return SocketState.CLOSED; } }	/** * Process pipelined HTTP requests on the specified socket. * * @param socketWrapper Socket from which the HTTP requests will be read * and the HTTP responses will be written. * * @throws IOException error during an I/O operation */ public SocketState process(SocketWrapper<Socket> socketWrapper) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); // Set the remote address remoteAddr = null; remoteHost = null; localAddr = null; localName = null; remotePort = -1; localPort = -1; // Setting up the I/O this.socket = socketWrapper; inputBuffer.setInputStream(socket.getSocket().getInputStream()); outputBuffer.setOutputStream(socket.getSocket().getOutputStream()); // Error flag error = false; keepAlive = true; int keepAliveLeft = maxKeepAliveRequests>0?socketWrapper.decrementKeepAlive():-1; int soTimeout = endpoint.getSoTimeout(); try { socket.getSocket().setSoTimeout(soTimeout); } catch (Throwable t) { log.debug(sm.getString("http11processor.socket.timeout"), t); error = true; } boolean keptAlive = socketWrapper.isKeptAlive(); while (started && !error && keepAlive) { // Parsing the request header try { //TODO - calculate timeout based on length in queue (System.currentTimeMills() - wrapper.getLastAccess() is the time in queue) if (keptAlive) { if (keepAliveTimeout > 0) { socket.getSocket().setSoTimeout(keepAliveTimeout); } } } } }	public SocketState process(long socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); remoteAddr = null; remoteHost = null; localAddr = null; localName = null; remotePort = -1; localPort = -1; this.socket = socket; inputBuffer.setSocket(socket); outputBuffer.setSocket(socket); error = false; comet = false; async = false; keepAlive = true; int keepAliveLeft = maxKeepAliveRequests; long soTimeout = endpoint.getSoTimeout(); boolean keptAlive = false; boolean openSocket = false; while (!error && keepAlive && !comet && !async) { try { if (!disableUploadTimeout && keptAlive && soTimeout > 0) { Socket.timeoutSet(socket, soTimeout * 1000); } if (!inputBuffer.parseRequestLine(keptAlive)) { // This means that no data is available right now // (long keepalive), so that the processor should be recycled openSocket = true; endpoint.getPoller().add(socket); break; } request.setStartTime(System.currentTimeMillis()); keptAlive = true; if (!disableUploadTimeout) { Socket.timeoutSet(socket, timeout * 1000); } inputBuffer.parseHeaders(); } catch (IOException e) { error = true; break; } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.header.parse"), t); } response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare"), t); } response.setStatus(400); adapter.log(request, response, 0); error = true; } } if (maxKeepAliveRequests > 0 && --keepAliveLeft == 0) keepAlive = false; if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); if (keepAlive && !error) { error = response.getErrorException() != null || statusDropsConnection(response.getStatus()); } } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("http11processor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (!comet && !async) { if (error) inputBuffer.setSwallowInput(false); endRequest(); } if (error) { response.setStatus(500); } request.updateCounters(); if (!comet && !async) { inputBuffer.nextRequest(); outputBuffer.nextRequest(); } if (sendfileData != null && !error) { sendfileData.socket = socket; sendfileData.keepAlive = keepAlive; if (!endpoint.getSendfile().add(sendfileData)) { openSocket = true; break; } } rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (comet || async) { if (error) { inputBuffer.nextRequest(); outputBuffer.nextRequest(); recycle(); return SocketState.CLOSED; } else { return SocketState.LONG; } } else { recycle(); return (openSocket) ? SocketState.OPEN : SocketState.CLOSED; } }	public boolean process(long socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); this.socket = socket; Socket.setrbb(this.socket, inputBuffer); Socket.setsbb(this.socket, outputBuffer); error = false; async = false; boolean openSocket = true; boolean keptAlive = false; while (started && !error) { try { if (!readMessage(requestHeaderMessage, true, keptAlive)) { // This means that no data is available right now // (long keepalive), so that the processor should be recycled rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); break; } // Check message type, process right away and break if int type = requestHeaderMessage.getByte(); if (type == Constants.JK_AJP13_CPING_REQUEST) { if (Socket.sendb(socket, pongMessageBuffer, 0, pongMessageBuffer.position()) < 0) { error = true; } continue; } else if (type != Constants.JK_AJP13_FORWARD_REQUEST) { if (log.isDebugEnabled()) { log.debug("Unexpected message: " + type); } continue; } keptAlive = true; request.setStartTime(System.currentTimeMillis()); } catch (IOException e) { error = true; break; } catch (Throwable t) { log.debug(sm.getString("ajpprocessor.header.error"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { log.debug(sm.getString("ajpprocessor.request.prepare"), t); response.setStatus(400); adapter.log(request, response, 0); error = true; } if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("ajpprocessor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } } if (async && !error) { break; } if (!finished) { try { finish(); } catch (Throwable t) { error = true; } } if (error) { response.setStatus(500); } request.updateCounters(); rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); recycle(); } if (!error) { endpoint.getPoller().add(socket); } else { openSocket = false; } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (!async || error) recycle(); return openSocket; }	public int getKeepAliveCount() { if (pollers == null) { return 0; } else { int sum = 0; for (int i = 0; i < pollers.length; i++) { sum += pollers[i].getKeyCount(); } return sum; } }	public Executor[] findExecutors() { synchronized (executors) { Executor[] arr = new Executor[executors.size()]; executors.toArray(arr); return arr; } }	public void destroy() throws Exception { if (log.isInfoEnabled()) log.info(sm.getString("ajpprotocol.stop", getName())); endpoint.destroy(); if (tpOname != null) Registry.getRegistry(null, null).unregisterComponent(tpOname); if (rgOname != null) Registry.getRegistry(null, null).unregisterComponent(rgOname); }	public void destroy() throws Exception { if (log.isInfoEnabled()) log.info(sm.getString("ajpprotocol.stop", getName())); endpoint.destroy(); if (tpOname != null) Registry.getRegistry(null, null).unregisterComponent(tpOname); if (rgOname != null) Registry.getRegistry(null, null).unregisterComponent(rgOname); }	public boolean getSecure() { return secure; }	public void resume() throws Exception { try { endpoint.resume(); } catch (Exception ex) { log.error(sm.getString("ajpprotocol.endpoint.resumeerror"), ex); throw ex; } if (log.isInfoEnabled()) log.info(sm.getString("ajpprotocol.resume", getName())); }	public void resume() throws Exception { try { endpoint.resume(); } catch (Exception ex) { log.error(sm.getString("ajpprotocol.endpoint.resumeerror"), ex); throw ex; } if (log.isInfoEnabled()) log.info(sm.getString("ajpprotocol.resume", getName())); }	@Override public void resume() throws Exception { try { endpoint.resume(); } catch (Exception ex) { getLog().error(sm.getString("http11protocol.endpoint.resumeerror"), ex); throw ex; } if (getLog().isInfoEnabled()) getLog().info(sm.getString("http11protocol.resume", getName())); }	@Override public void start() throws Exception { if (!initialized) { init(); } if (!running) { running = true; paused = false; if (getExecutor() == null) { createExecutor(); } for (int i = 0; i < acceptorThreadCount; i++) { Thread acceptorThread = new Thread(new Acceptor(), getName() + "-Acceptor-" + i); acceptorThread.setPriority(threadPriority); acceptorThread.setDaemon(getDaemon()); acceptorThread.start(); } Thread timeoutThread = new Thread(new AsyncTimeout(), getName() + "-AsyncTimeout"); timeoutThread.setPriority(threadPriority); timeoutThread.setDaemon(true); timeoutThread.start(); } }	@Override public void start() throws Exception { if (!initialized) { init(); } if (!running) { running = true; paused = false; if (getExecutor() == null) { createExecutor(); } pollers = new Poller[getPollerThreadCount()]; for (int i = 0; i < pollers.length; i++) { pollers[i] = new Poller(); Thread pollerThread = new Thread(pollers[i], getName() + "-ClientPoller-" + i); pollerThread.setPriority(threadPriority); pollerThread.setDaemon(true); pollerThread.start(); } for (int i = 0; i < acceptorThreadCount; i++) { Thread acceptorThread = new Thread(new Acceptor(), getName() + "-Acceptor-" + i); acceptorThread.setPriority(threadPriority); acceptorThread.setDaemon(getDaemon()); acceptorThread.start(); } } }	public void stop() { if (running) { running = false; unlockAccept(); for (int i = 0; i < acceptors.length; i++) { int c = 0; while (acceptors[i].isAlive()) { try { acceptors[i].interrupt(); acceptors[i].join(1000); } catch (InterruptedException e) { // Ignore } if (c++ > 60) { if (serverSock != 0) { Socket.shutdown(serverSock, Socket.APR_SHUTDOWN_READ); serverSock = 0; } } } } for (int i = 0; i < pollers.length; i++) { try { pollers[i].destroy(); } catch (Exception e) { // Ignore } } pollers = null; for (int i = 0; i < cometPollers.length; i++) { try { cometPollers[i].destroy(); } catch (Exception e) { // Ignore } } cometPollers = null; if (useSendfile) { for (int i = 0; i < sendfiles.length; i++) { try { sendfiles[i].destroy(); } catch (Exception e) { // Ignore } } sendfiles = null; } } shutdownExecutor(); }	public void stop() { if (running) { running = false; unlockAccept(); } shutdownExecutor(); }	public void stop() { if (running) { running = false; unlockAccept(); for (int i = 0; pollers != null && i < pollers.length; i++) { if (pollers[i] == null) continue; pollers[i].destroy(); pollers[i] = null; } try { stopLatch.await(selectorTimeout + 100, TimeUnit.MILLISECONDS); } catch (InterruptedException ignore) { } } eventCache.clear(); keyCache.clear(); nioChannels.clear(); processorCache.clear(); shutdownExecutor(); }
private static int unwrap(ThreadLocal tl) { return ((Integer) tl.get()).intValue(); }	private static void wrap(ThreadLocal tl, int value) { tl.set(new Integer(value)); }	public AnnotationEntry[] getAnnotationEntries() { if (annotationsOutOfDate) { Attribute[] attrs = getAttributes(); List accumulatedAnnotations = new ArrayList(); for (int i = 0; i < attrs.length; i++) { Attribute attribute = attrs[i]; if (attribute instanceof Annotations) { Annotations runtimeAnnotations = (Annotations) attribute; for (int j = 0; j < runtimeAnnotations.getAnnotationEntries().length; j++) accumulatedAnnotations.add(runtimeAnnotations.getAnnotationEntries()[j]); } } annotations = (AnnotationEntry[]) accumulatedAnnotations.toArray(new AnnotationEntry[accumulatedAnnotations.size()]); annotationsOutOfDate = false; } return annotations; }	public ElementValuePair[] getElementValuePairs() { return (ElementValuePair[]) element_value_pairs.toArray(new ElementValuePair[element_value_pairs.size()]); }	@Override public boolean equals(Object obj) { return _cmp.equals(this, obj); }	public static AnnotationEntry read(DataInputStream file, ConstantPool constant_pool) throws IOException { final AnnotationEntry annotationEntry = new AnnotationEntry(file.readUnsignedShort(), constant_pool); final int num_element_value_pairs = (file.readUnsignedShort()); annotationEntry.element_value_pairs = new ArrayList(); for (int i = 0; i < num_element_value_pairs; i++) { annotationEntry.element_value_pairs.add(new ElementValuePair(file.readUnsignedShort(), ElementValue.readElementValue(file, constant_pool), constant_pool)); } return annotationEntry; }	public static final Attribute readAttribute(DataInputStream file, ConstantPool constant_pool) throws IOException, ClassFormatException { ConstantUtf8 c; String name; int name_index; int length; byte tag = Constants.ATTR_UNKNOWN; name_index = file.readUnsignedShort(); c = (ConstantUtf8) constant_pool.getConstant(name_index, Constants.CONSTANT_Utf8); name = c.getBytes(); length = file.readInt(); for (byte i = 0; i < Constants.KNOWN_ATTRIBUTES; i++) { if (name.equals(Constants.ATTRIBUTE_NAMES[i])) { tag = i; break; } } switch(tag) { case Constants.ATTR_UNKNOWN: AttributeReader r = (AttributeReader) readers.get(name); if (r != null) { return r.createAttribute(name_index, length, file, constant_pool); } return new Unknown(name_index, length, file, constant_pool); case Constants.ATTR_CONSTANT_VALUE: return new ConstantValue(name_index, length, file, constant_pool); case Constants.ATTR_SOURCE_FILE: return new SourceFile(name_index, length, file, constant_pool); case Constants.ATTR_CODE: return new Code(name_index, length, file, constant_pool); case Constants.ATTR_EXCEPTIONS: return new ExceptionTable(name_index, length, file, constant_pool); case Constants.ATTR_LINE_NUMBER_TABLE: return new LineNumberTable(name_index, length, file, constant_pool); case Constants.ATTR_LOCAL_VARIABLE_TABLE: return new LocalVariableTable(name_index, length, file, constant_pool); case Constants.ATTR_INNER_CLASSES: return new InnerClasses(name_index, length, file, constant_pool); case Constants.ATTR_SYNTHETIC: return new Synthetic(name_index, length, file, constant_pool); case Constants.ATTR_DEPRECATED: return new Deprecated(name_index, length, file, constant_pool); case Constants.ATTR_PMG: return new PMGClass(name_index, length, file, constant_pool); case Constants.ATTR_SIGNATURE: return new Signature(name_index, length, file, constant_pool); case Constants.ATTR_STACK_MAP: return new StackMap(name_index, length, file, constant_pool); case Constants.ATTR_RUNTIME_VISIBLE_ANNOTATIONS: return new RuntimeVisibleAnnotations(name_index, length, file, constant_pool); case Constants.ATTR_RUNTIMEIN_VISIBLE_ANNOTATIONS: return new RuntimeInvisibleAnnotations(name_index, length, file, constant_pool); case Constants.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS: return new RuntimeVisibleParameterAnnotations(name_index, length, file, constant_pool); case Constants.ATTR_RUNTIMEIN_VISIBLE_PARAMETER_ANNOTATIONS: return new RuntimeInvisibleParameterAnnotations(name_index, length, file, constant_pool); case Constants.ATTR_ANNOTATION_DEFAULT: return new AnnotationDefault(name_index, length, file, constant_pool); case Constants.ATTR_LOCAL_VARIABLE_TYPE_TABLE: return new LocalVariableTypeTable(name_index, length, file, constant_pool); case Constants.ATTR_ENCLOSING_METHOD: return new EnclosingMethod(name_index, length, file, constant_pool); case Constants.ATTR_STACK_MAP_TABLE: return new StackMapTable(name_index, length, file, constant_pool); default: throw new IllegalStateException("Unrecognized attribute type tag parsed: " + tag); } }	public void dump(DataOutputStream dos) throws IOException { dos.writeShort(type_index); dos.writeShort(element_value_pairs.size()); for (int i = 0; i < element_value_pairs.size(); i++) { ElementValuePair envp = (ElementValuePair) element_value_pairs.get(i); envp.dump(dos); } }	public void dump(DataOutputStream file) throws IOException { file.writeShort(name_index); file.writeInt(length); }
public ClassLoader run() { return clazz.getClassLoader(); }
private KeyStore getStore(String type, String provider, String path, String pass) throws IOException { KeyStore ks = null; InputStream istream = null; try { if (provider == null) { ks = KeyStore.getInstance(type); } else { ks = KeyStore.getInstance(type, provider); } if (!("PKCS11".equalsIgnoreCase(type) || "".equalsIgnoreCase(path))) { File keyStoreFile = new File(path); if (!keyStoreFile.isAbsolute()) { keyStoreFile = new File(System.getProperty("catalina.base"), path); } istream = new FileInputStream(keyStoreFile); } char[] storePass = null; if (pass != null && !"".equals(pass)) { storePass = pass.toCharArray(); } ks.load(istream, storePass); } catch (FileNotFoundException fnfe) { log.error(sm.getString("jsse.keystore_load_failed", type, path, fnfe.getMessage()), fnfe); throw fnfe; } catch (IOException ioe) { throw ioe; } catch (Exception ex) { String msg = sm.getString("jsse.keystore_load_failed", type, path, ex.getMessage()); log.error(msg, ex); throw new IOException(msg); } finally { if (istream != null) { try { istream.close(); } catch (IOException ioe) { // Do nothing } } } return ks; }	private static String getCatalinaBase() { return System.getProperty("catalina.base", getCatalinaHome()); }	private static String getCatalinaHome() { return System.getProperty("catalina.home", System.getProperty("user.dir")); }	private static void loadProperties() { InputStream is = null; Throwable error = null; try { String configUrl = getConfigUrl(); if (configUrl != null) { is = (new URL(configUrl)).openStream(); } } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } if (is == null) { try { File home = new File(getCatalinaBase()); File conf = new File(home, "conf"); File properties = new File(conf, "catalina.properties"); is = new FileInputStream(properties); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } if (is == null) { try { is = CatalinaProperties.class.getResourceAsStream("/org/apache/catalina/startup/catalina.properties"); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } if (is != null) { try { properties = new Properties(); properties.load(is); is.close(); } catch (Throwable t) { error = t; } } if ((is == null) || (error != null)) { log.warn("Failed to load catalina.properties", error); properties = new Properties(); } Enumeration<?> enumeration = properties.propertyNames(); while (enumeration.hasMoreElements()) { String name = (String) enumeration.nextElement(); String value = properties.getProperty(name); if (value != null) { System.setProperty(name, value); } } }	private void setCatalinaBase() { if (System.getProperty("catalina.base") != null) return; if (System.getProperty("catalina.home") != null) System.setProperty("catalina.base", System.getProperty("catalina.home")); else System.setProperty("catalina.base", System.getProperty("user.dir")); }	private void setCatalinaHome() { if (System.getProperty("catalina.home") != null) return; File bootstrapJar = new File(System.getProperty("user.dir"), "bootstrap.jar"); if (bootstrapJar.exists()) { try { System.setProperty("catalina.home", (new File(System.getProperty("user.dir"), "..")).getCanonicalPath()); } catch (Exception e) { System.setProperty("catalina.home", System.getProperty("user.dir")); } } else { System.setProperty("catalina.home", System.getProperty("user.dir")); } }	protected Collection<? extends CRL> getCRLs(String crlf) throws IOException, CRLException, CertificateException { File crlFile = new File(crlf); if (!crlFile.isAbsolute()) { crlFile = new File(System.getProperty("catalina.base"), crlf); } Collection<? extends CRL> crls = null; InputStream is = null; try { CertificateFactory cf = CertificateFactory.getInstance("X.509"); is = new FileInputStream(crlFile); crls = cf.generateCRLs(is); } catch (IOException iex) { throw iex; } catch (CRLException crle) { throw crle; } catch (CertificateException ce) { throw ce; } finally { if (is != null) { try { is.close(); } catch (Exception ex) { // Ignore } } } return crls; }	protected File configFile() { File file = new File(configFile); if (!file.isAbsolute()) file = new File(System.getProperty("catalina.base"), configFile); return (file); }	protected File engineBase() { String base = System.getProperty("catalina.base"); if (base == null) { StandardEngine eng = (StandardEngine) this.getParent().getParent(); base = eng.getBaseDir(); } return (new File(base)); }	protected File getAppBase() { if (appBase != null) { return appBase; } File file = new File(host.getAppBase()); if (!file.isAbsolute()) file = new File(System.getProperty("catalina.base"), host.getAppBase()); try { appBase = file.getCanonicalFile(); } catch (IOException e) { appBase = file; } return (appBase); }	protected File getAppBase() { if (appBase != null) { return appBase; } File file = new File(host.getAppBase()); if (!file.isAbsolute()) file = new File(System.getProperty("catalina.base"), host.getAppBase()); try { appBase = file.getCanonicalFile(); } catch (IOException e) { appBase = file; } return (appBase); }	protected File getConfigBase(String hostName) { File configBase = new File(System.getProperty("catalina.base"), "conf"); if (!configBase.exists()) { return null; } if (engine != null) { configBase = new File(configBase, engine.getName()); } if (installedHost != null) { configBase = new File(configBase, hostName); } if (!configBase.exists()) { if (!configBase.mkdirs()) { return null; } } return configBase; }	protected File returnCanonicalPath(String path) { File file = new File(path); File base = new File(System.getProperty("catalina.base")); if (!file.isAbsolute()) file = new File(base, path); try { return file.getCanonicalFile(); } catch (IOException e) { return file; } }	protected Project getProject() { if (project != null) return project; project = new Project(); logger = new JasperAntLogger(); logger.setOutputPrintStream(System.out); logger.setErrorPrintStream(System.err); logger.setMessageOutputLevel(Project.MSG_INFO); project.addBuildListener(logger); if (System.getProperty("catalina.home") != null) { project.setBasedir(System.getProperty("catalina.home")); } if (options.getCompiler() != null) { if (log.isDebugEnabled()) log.debug("Compiler " + options.getCompiler()); project.setProperty("build.compiler", options.getCompiler()); } project.init(); return project; }	protected synchronized void open() { File dir = new File(directory); if (!dir.isAbsolute()) dir = new File(System.getProperty("catalina.base"), directory); dir.mkdirs(); try { String pathname; if (rotatable) { pathname = dir.getAbsolutePath() + File.separator + prefix + dateStamp + suffix; } else { pathname = dir.getAbsolutePath() + File.separator + prefix + suffix; } writer = new PrintWriter(new BufferedWriter(new FileWriter(pathname, true), 128000), false); currentLogFile = new File(pathname); } catch (IOException e) { writer = null; currentLogFile = null; } }	void initBaseDir() { if (basedir == null) { basedir = System.getProperty("catalina.base"); } if (basedir == null) { basedir = System.getProperty("catalina.home"); } if (basedir == null) { basedir = System.getProperty("user.dir") + "/tomcat." + port; File home = new File(basedir); home.mkdir(); if (!home.isAbsolute()) { try { basedir = home.getCanonicalPath(); } catch (IOException e) { basedir = home.getAbsolutePath(); } } } System.setProperty("catalina.home", basedir); System.setProperty("catalina.base", basedir); }	protected void initDirs() { String catalinaHome = System.getProperty("catalina.home"); if (catalinaHome == null) { String j2eeHome = System.getProperty("com.sun.enterprise.home"); if (j2eeHome != null) { catalinaHome = System.getProperty("com.sun.enterprise.home"); } else if (System.getProperty("catalina.base") != null) { catalinaHome = System.getProperty("catalina.base"); } else { catalinaHome = IntrospectionUtils.guessInstall("catalina.home", "catalina.base", "catalina.jar"); if (catalinaHome == null) { catalinaHome = IntrospectionUtils.guessInstall("tomcat.install", "catalina.home", "tomcat.jar"); } } } if (catalinaHome == null) { catalinaHome = System.getProperty("user.dir"); } if (catalinaHome != null) { File home = new File(catalinaHome); if (!home.isAbsolute()) { try { catalinaHome = home.getCanonicalPath(); } catch (IOException e) { catalinaHome = home.getAbsolutePath(); } } System.setProperty("catalina.home", catalinaHome); } if (System.getProperty("catalina.base") == null) { System.setProperty("catalina.base", catalinaHome); } else { String catalinaBase = System.getProperty("catalina.base"); File base = new File(catalinaBase); if (!base.isAbsolute()) { try { catalinaBase = base.getCanonicalPath(); } catch (IOException e) { catalinaBase = base.getAbsolutePath(); } } System.setProperty("catalina.base", catalinaBase); } String temp = System.getProperty("java.io.tmpdir"); if (temp == null || (!(new File(temp)).exists()) || (!(new File(temp)).isDirectory())) { log.error(sm.getString("embedded.notmp", temp)); } }	protected void initDirs() { String catalinaHome = System.getProperty("catalina.home"); if (catalinaHome == null) { String j2eeHome = System.getProperty("com.sun.enterprise.home"); if (j2eeHome != null) { catalinaHome = System.getProperty("com.sun.enterprise.home"); } else if (System.getProperty("catalina.base") != null) { catalinaHome = System.getProperty("catalina.base"); } else { catalinaHome = IntrospectionUtils.guessInstall("catalina.home", "catalina.base", "catalina.jar"); if (catalinaHome == null) { catalinaHome = IntrospectionUtils.guessInstall("tomcat.install", "catalina.home", "tomcat.jar"); } } } if (catalinaHome == null) { catalinaHome = System.getProperty("user.dir"); } if (catalinaHome != null) { File home = new File(catalinaHome); if (!home.isAbsolute()) { try { catalinaHome = home.getCanonicalPath(); } catch (IOException e) { catalinaHome = home.getAbsolutePath(); } } System.setProperty("catalina.home", catalinaHome); } if (System.getProperty("catalina.base") == null) { System.setProperty("catalina.base", catalinaHome); } else { String catalinaBase = System.getProperty("catalina.base"); File base = new File(catalinaBase); if (!base.isAbsolute()) { try { catalinaBase = base.getCanonicalPath(); } catch (IOException e) { catalinaBase = base.getAbsolutePath(); } } System.setProperty("catalina.base", catalinaBase); } String temp = System.getProperty("java.io.tmpdir"); if (temp == null || (!(new File(temp)).exists()) || (!(new File(temp)).isDirectory())) { log.error(sm.getString("embedded.notmp", temp)); } }	@Override protected void initInternal() throws LifecycleException { super.initInternal(); adapter = new CoyoteAdapter(this); protocolHandler.setAdapter(adapter); IntrospectionUtils.setProperty(protocolHandler, "jkHome", System.getProperty("catalina.base")); try { protocolHandler.init(); } catch (Exception e) { throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerInitializationFailed", e)); } onameProtocolHandler = register(protocolHandler, createObjectNameKeyProperties("ProtocolHandler")); mapperListener.setDomain(getDomain()); onameMapper = register(mapperListener, createObjectNameKeyProperties("Mapper")); }	protected void load() { File file = new File(pathname); if (!file.isAbsolute()) file = new File(System.getProperty("catalina.base"), pathname); if (!file.exists() || !file.canRead()) { log.warn("Cannot load configuration file " + file.getAbsolutePath()); return; } Digester digester = new Digester(); digester.setValidating(false); digester.addRuleSet(new MemoryRuleSet()); try { digester.push(this); digester.parse(file); } catch (Exception e) { log.warn("Error processing configuration file " + file.getAbsolutePath(), e); return; } finally { digester.reset(); } }	@Override protected void startInternal() throws LifecycleException { File file = new File(pathname); if (!file.isAbsolute()) file = new File(System.getProperty("catalina.base"), pathname); if (!file.exists() || !file.canRead()) throw new LifecycleException(sm.getString("memoryRealm.loadExist", file.getAbsolutePath())); if (log.isDebugEnabled()) log.debug(sm.getString("memoryRealm.loadPath", file.getAbsolutePath())); Digester digester = getDigester(); try { synchronized (digester) { digester.push(this); digester.parse(file); } } catch (Exception e) { throw new LifecycleException(sm.getString("memoryRealm.readXml"), e); } finally { digester.reset(); } super.startInternal(); }	public File getConfigBase() { File configBase = new File(System.getProperty("catalina.base"), "conf"); if (!configBase.exists()) { return null; } Container container = this; Container host = null; Container engine = null; while (container != null) { if (container instanceof Host) host = container; if (container instanceof Engine) engine = container; container = container.getParent(); } if (engine != null) { configBase = new File(configBase, engine.getName()); } if (host != null) { configBase = new File(configBase, host.getName()); } if (saveConfig) { configBase.mkdirs(); } return configBase; }	public String getCatalinaBase() { return System.getProperty("catalina.base"); }	public String getCatalinaHome() { return System.getProperty("catalina.home"); }	public boolean isAwait() { return await; }	public boolean isWriteable() { File file = new File(pathname); if (!file.isAbsolute()) { file = new File(System.getProperty("catalina.base"), pathname); } File dir = file.getParentFile(); return dir.exists() && dir.isDirectory() && dir.canWrite(); }	public static String expand(Host host, URL war, String pathname) throws IOException { File appBase = new File(host.getAppBase()); if (!appBase.isAbsolute()) { appBase = new File(System.getProperty("catalina.base"), host.getAppBase()); } if (!appBase.exists() || !appBase.isDirectory()) { throw new IOException(sm.getString("hostConfig.appBase", appBase.getAbsolutePath())); } File docBase = new File(appBase, pathname); if (docBase.exists()) { return (docBase.getAbsolutePath()); } docBase.mkdir(); String canonicalDocBasePrefix = docBase.getCanonicalPath(); if (!canonicalDocBasePrefix.endsWith(File.separator)) { canonicalDocBasePrefix += File.separator; } JarURLConnection juc = (JarURLConnection) war.openConnection(); juc.setUseCaches(false); JarFile jarFile = null; InputStream input = null; boolean success = false; try { jarFile = juc.getJarFile(); Enumeration<JarEntry> jarEntries = jarFile.entries(); while (jarEntries.hasMoreElements()) { JarEntry jarEntry = jarEntries.nextElement(); String name = jarEntry.getName(); File expandedFile = new File(docBase, name); if (!expandedFile.getCanonicalPath().startsWith(canonicalDocBasePrefix)) { throw new IllegalArgumentException(sm.getString("expandWar.illegalPath", war, name)); } int last = name.lastIndexOf('/'); if (last >= 0) { File parent = new File(docBase, name.substring(0, last)); parent.mkdirs(); } if (name.endsWith("/")) { continue; } input = jarFile.getInputStream(jarEntry); expand(input, expandedFile); long lastModified = jarEntry.getTime(); if ((lastModified != -1) && (lastModified != 0)) { expandedFile.setLastModified(lastModified); } input.close(); input = null; } success = true; } catch (IOException e) { throw e; } finally { if (!success) { // If something went wrong, delete expanded dir to keep things deleteDir(docBase); } if (input != null) { try { input.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } input = null; } if (jarFile != null) { try { jarFile.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } jarFile = null; } } return (docBase.getAbsolutePath()); }	public static String getCatalinaBase() { return System.getProperty("catalina.base", getCatalinaHome()); }	public static String getCatalinaHome() { return System.getProperty("catalina.home", System.getProperty("user.dir")); }	public static void main(String[] args) { if (catalinaHome == null) { log.error("Must set 'catalina.home' system property"); System.exit(1); } int index = 0; while (true) { if (index == args.length) { usage(); System.exit(1); } if ("-ant".equals(args[index])) ant = true; } }	public static void validate(Host host, URL war, String pathname) throws IOException { File appBase = new File(host.getAppBase()); if (!appBase.isAbsolute()) { appBase = new File(System.getProperty("catalina.base"), host.getAppBase()); } File docBase = new File(appBase, pathname); String canonicalDocBasePrefix = docBase.getCanonicalPath(); if (!canonicalDocBasePrefix.endsWith(File.separator)) { canonicalDocBasePrefix += File.separator; } JarURLConnection juc = (JarURLConnection) war.openConnection(); juc.setUseCaches(false); JarFile jarFile = null; try { jarFile = juc.getJarFile(); Enumeration<JarEntry> jarEntries = jarFile.entries(); while (jarEntries.hasMoreElements()) { JarEntry jarEntry = jarEntries.nextElement(); String name = jarEntry.getName(); File expandedFile = new File(docBase, name); if (!expandedFile.getCanonicalPath().startsWith(canonicalDocBasePrefix)) { throw new IllegalArgumentException(sm.getString("expandWar.illegalPath", war, name)); } } } catch (IOException e) { throw e; } finally { if (jarFile != null) { try { jarFile.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } jarFile = null; } } }	@Override public void init() throws ServletException { if ((wrapper == null) || (context == null)) throw new UnavailableException(sm.getString("managerServlet.noWrapper")); String value = null; try { value = getServletConfig().getInitParameter("debug"); debug = Integer.parseInt(value); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } Server server = ((Engine) host.getParent()).getService().getServer(); if ((server != null) && (server instanceof StandardServer)) { global = ((StandardServer) server).getGlobalNamingContext(); } versioned = (File) getServletContext().getAttribute(ServletContext.TEMPDIR); // Identify the appBase of the owning Host of this Context String appBase = ((Host) context.getParent()).getAppBase(); deployed = new File(appBase); if (!deployed.isAbsolute()) { deployed = new File(System.getProperty("catalina.base"), appBase); } configBase = new File(System.getProperty("catalina.base"), "conf"); Container container = context; Container host = null; Container engine = null; while (container != null) { if (container instanceof Host) host = container; if (container instanceof Engine) engine = container; container = container.getParent(); } if (engine != null) { configBase = new File(configBase, engine.getName()); } if (host != null) { configBase = new File(configBase, host.getName()); } if (debug >= 1) { log("init: Associated with Deployer '" + oname + "'"); if (global != null) { log("init: Global resources are available"); } } }	protected synchronized void add(PrintWriter writer, String name, String aliases, String appBase, boolean manager, boolean autoDeploy, boolean deployOnStartup, boolean deployXML, boolean unpackWARs) { if (debug >= 1) { log(sm.getString("hostManagerServlet.add", name)); } if ((name == null) || name.length() == 0) { writer.println(sm.getString("hostManagerServlet.invalidHostName", name)); return; } if (engine.findChild(name) != null) { writer.println(sm.getString("hostManagerServlet.alreadyHost", name)); return; } File appBaseFile = null; File file = null; if (appBase == null || appBase.length() == 0) { file = new File(name); } else { file = new File(appBase); } if (!file.isAbsolute()) file = new File(System.getProperty("catalina.base"), file.getPath()); try { appBaseFile = file.getCanonicalFile(); } catch (IOException e) { appBaseFile = file; } if (!appBaseFile.exists()) { if (!appBaseFile.mkdirs()) { writer.println(sm.getString("hostManagerServlet.appBaseCreateFail", appBaseFile.toString(), name)); return; } } File configBaseFile = getConfigBase(name); if (manager) { if (configBaseFile == null) { writer.println(sm.getString("hostManagerServlet.configBaseCreateFail", name)); return; } InputStream is = null; OutputStream os = null; try { is = getServletContext().getResourceAsStream("/manager.xml"); os = new FileOutputStream(new File(configBaseFile, "manager.xml")); byte[] buffer = new byte[512]; int len = buffer.length; while (true) { len = is.read(buffer); if (len == -1) break; os.write(buffer, 0, len); } } catch (IOException e) { writer.println(sm.getString("hostManagerServlet.managerXml")); return; } finally { if (is != null) { try { is.close(); } catch (IOException e) { // Ignore } } if (os != null) { try { os.close(); } catch (IOException e) { // Ignore } } } } StandardHost host = new StandardHost(); host.setAppBase(appBase); host.setName(name); host.addLifecycleListener(new HostConfig()); if ((aliases != null) && !("".equals(aliases))) { StringTokenizer tok = new StringTokenizer(aliases, ", "); while (tok.hasMoreTokens()) { host.addAlias(tok.nextToken()); } } host.setAutoDeploy(autoDeploy); host.setDeployOnStartup(deployOnStartup); host.setDeployXML(deployXML); host.setUnpackWARs(unpackWARs); try { engine.addChild(host); } catch (Exception e) { writer.println(sm.getString("hostManagerServlet.exception", e.toString())); return; } host = (StandardHost) engine.findChild(name); if (host != null) { writer.println(sm.getString("hostManagerServlet.add", name)); } else { writer.println(sm.getString("hostManagerServlet.addFailed", name)); } }	public void open() throws Exception { synchronized (groups) { synchronized (users) { users.clear(); groups.clear(); roles.clear(); File file = new File(pathname); if (!file.isAbsolute()) { file = new File(System.getProperty("catalina.base"), pathname); } if (!file.exists()) { return; } FileInputStream fis = new FileInputStream(file); Digester digester = new Digester(); try { digester.setFeature("http://apache.org/xml/features/allow-java-encodings", true); } catch (Exception e) { log.warn(sm.getString("memoryUserDatabase.xmlFeatureEncoding"), e); } digester.addFactoryCreate("tomcat-users/group", new MemoryGroupCreationFactory(this)); digester.addFactoryCreate("tomcat-users/role", new MemoryRoleCreationFactory(this)); digester.addFactoryCreate("tomcat-users/user", new MemoryUserCreationFactory(this)); try { digester.parse(fis); fis.close(); } catch (Exception e) { try { fis.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } throw e; } } } }	public void save() throws Exception { if (getReadonly()) { log.error(sm.getString("memoryUserDatabase.readOnly")); return; } if (!isWriteable()) { log.warn(sm.getString("memoryUserDatabase.notPersistable")); return; } File fileNew = new File(pathnameNew); if (!fileNew.isAbsolute()) { fileNew = new File(System.getProperty("catalina.base"), pathnameNew); } PrintWriter writer = null; try { FileOutputStream fos = new FileOutputStream(fileNew); OutputStreamWriter osw = new OutputStreamWriter(fos, "UTF8"); writer = new PrintWriter(osw); writer.println("<?xml version='1.0' encoding='utf-8'?>"); writer.println("<tomcat-users>"); Iterator<?> values = null; values = getRoles(); while (values.hasNext()) { writer.print(" "); writer.println(values.next()); } values = getGroups(); while (values.hasNext()) { writer.print(" "); writer.println(values.next()); } values = getUsers(); while (values.hasNext()) { writer.print(" "); writer.println(values.next()); } writer.println("</tomcat-users>"); if (writer.checkError()) { writer.close(); fileNew.delete(); throw new IOException(sm.getString("memoryUserDatabase.writeException", fileNew.getAbsolutePath())); } writer.close(); } catch (IOException e) { if (writer != null) { writer.close(); } fileNew.delete(); throw e; } File fileOld = new File(pathnameOld); if (!fileOld.isAbsolute()) { fileOld = new File(System.getProperty("catalina.base"), pathnameOld); } fileOld.delete(); File fileOrig = new File(pathname); if (!fileOrig.isAbsolute()) { fileOrig = new File(System.getProperty("catalina.base"), pathname); } if (fileOrig.exists()) { fileOld.delete(); if (!fileOrig.renameTo(fileOld)) { throw new IOException(sm.getString("memoryUserDatabase.renameOld", fileOld.getAbsolutePath())); } } if (!fileNew.renameTo(fileOrig)) { if (fileOld.exists()) { fileOld.renameTo(fileOrig); } throw new IOException(sm.getString("memoryUserDatabase.renameNew", fileOrig.getAbsolutePath())); } fileOld.delete(); }	public void setCatalinaBase(String s) { System.setProperty("catalina.base", s); }	public void setCatalinaHome(String s) { System.setProperty("catalina.home", s); }	public void setCatalinaHome(String s) { System.setProperty("catalina.home", s); }	public String getCiphers() { return ciphers; }	public String getTruststorePass() { return truststorePass; }	public void start() throws Exception { if (started) return; Container hcontainer = getCluster().getContainer(); if (!(hcontainer instanceof Host)) { log.error("FarmWarDeployer can only work as host cluster subelement!"); return; } host = (Host) hcontainer; Container econtainer = host.getParent(); if (!(econtainer instanceof Engine)) { log.error("FarmWarDeployer can only work if parent of " + host.getName() + " is an engine!"); return; } Engine engine = (Engine) econtainer; String hostname = null; hostname = host.getName(); try { oname = new ObjectName(engine.getName() + ":type=Deployer,host=" + hostname); } catch (Exception e) { log.error("Can't construct MBean object name" + e); return; } if (watchEnabled) { watcher = new WarWatcher(this, new File(getWatchDir())); if (log.isInfoEnabled()) { log.info("Cluster deployment is watching " + getWatchDir() + " for changes."); } } configBase = new File(System.getProperty("catalina.base"), "conf"); if (engine != null) { configBase = new File(configBase, engine.getName()); } if (host != null) { configBase = new File(configBase, hostname); } mBeanServer = Registry.getRegistry(null, null).getMBeanServer(); started = true; count = 0; getCluster().addClusterListener(this); if (log.isInfoEnabled()) log.info("Cluster FarmWarDeployer started."); }
public void register(Request request, HttpServletResponse response, Principal principal, String authType, String username, String password) { if (log.isDebugEnabled()) log.debug("Authenticated '" + principal.getName() + "' with type '" + authType + "'"); request.setAuthType(authType); request.setUserPrincipal(principal); Session session = request.getSessionInternal(false); if (session != null && changeSessionIdOnAuthentication) { Manager manager = request.getContext().getManager(); manager.changeSessionId(session); request.changeSessionId(session.getId()); } if (cache) { if (session != null) { session.setAuthType(authType); session.setPrincipal(principal); if (username != null) session.setNote(Constants.SESS_USERNAME_NOTE, username); else session.removeNote(Constants.SESS_USERNAME_NOTE); if (password != null) session.setNote(Constants.SESS_PASSWORD_NOTE, password); else session.removeNote(Constants.SESS_PASSWORD_NOTE); } } if (sso == null) return; // Only create a new SSO entry if the SSO did not already set a note // for an existing entry (as it would do with subsequent requests String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (ssoId == null) { ssoId = generateSessionId(); Cookie cookie = new Cookie(Constants.SINGLE_SIGN_ON_COOKIE, ssoId); cookie.setMaxAge(-1); cookie.setPath("/"); cookie.setSecure(request.isSecure()); String ssoDomain = sso.getCookieDomain(); if (ssoDomain != null) { cookie.setDomain(ssoDomain); } response.addCookie(cookie); sso.register(ssoId, principal, authType, username, password); request.setNote(Constants.REQ_SSOID_NOTE, ssoId); } else { if (principal == null) { sso.deregister(ssoId); return; } else { sso.update(ssoId, principal, authType, username, password); } } if (session == null) session = request.getSessionInternal(true); sso.associate(ssoId, session); }
public int doWrite(ByteChunk chunk, Response res) throws IOException { if (compressionStream == null) { compressionStream = new GZIPOutputStream(fakeOutputStream); } compressionStream.write(chunk.getBytes(), chunk.getStart(), chunk.getLength()); return chunk.getLength(); }	public long end() throws IOException { if (compressionStream == null) { compressionStream = new GZIPOutputStream(fakeOutputStream); } compressionStream.finish(); compressionStream.close(); return ((OutputFilter) buffer).end(); }	public void flush() throws IOException { if (!committed) { // Send the connector a request for commit. The connector should // then validate the headers, send them (using sendHeader) and response.action(ActionCode.ACTION_COMMIT, null); } }
@Override protected synchronized void startInternal() throws LifecycleException { // Look up the SingleSignOn implementation in our request processing Container parent = context.getParent(); while ((sso == null) && (parent != null)) { if (!(parent instanceof Pipeline)) { parent = parent.getParent(); continue; } Valve[] valves = ((Pipeline) parent).getValves(); for (int i = 0; i < valves.length; i++) { if (valves[i] instanceof SingleSignOn) { sso = (SingleSignOn) valves[i]; break; } } if (sso == null) parent = parent.getParent(); } if (log.isDebugEnabled()) { if (sso != null) log.debug("Found SingleSignOn Valve at " + sso); else log.debug("No SingleSignOn Valve is present"); } super.startInternal(); }
protected void webConfig() { WebXml webXml = createWebXml(); InputSource globalWebXml = getGlobalWebXmlSource(); if (globalWebXml == null) { log.info(sm.getString("contextConfig.defaultMissing")); } else { parseWebXml(globalWebXml, webXml, false); } // Parse host level web.xml if present webXml.setReplaceWelcomeFiles(true); InputSource hostWebXml = getHostWebXmlSource(); parseWebXml(hostWebXml, webXml, false); webXml.setReplaceWelcomeFiles(true); InputSource contextWebXml = getContextWebXmlSource(); parseWebXml(contextWebXml, webXml, false); double webXmlVersion = 0; if (webXml.getVersion() != null) { webXmlVersion = Double.parseDouble(webXml.getVersion()); } if (webXmlVersion >= 3 && !webXml.isMetadataComplete()) { // Ordering is important here // Step 1. Identify all the JARs packaged with the application // If the JARs have a web-fragment.xml it will be parsed at this Map<String, WebXml> fragments = processJarsForWebFragments(); Set<WebXml> orderedFragments = WebXml.orderWebFragments(webXml, fragments); ok = processServletContainerInitializers(orderedFragments); if (ok) { URL webinfClasses; try { webinfClasses = context.getServletContext().getResource("/WEB-INF/classes"); processAnnotationsUrl(webinfClasses, webXml); } catch (MalformedURLException e) { log.error(sm.getString("contextConfig.webinfClassesUrl"), e); } } if (ok) { processAnnotations(orderedFragments); } if (ok) { ok = webXml.merge(orderedFragments); } if (ok) { webXml.configureContext(context); // Step 7a. Make the merged web.xml available to other // components, specifically Jasper, to save those components // from having to re-generate it. String mergedWebXml = webXml.toXml(); context.getServletContext().setAttribute(org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML, mergedWebXml); if (context.getLogEffectiveWebXml()) { log.info("web.xml:\n" + mergedWebXml); } } if (ok) { processResourceJARs(orderedFragments); } if (ok) { for (Map.Entry<ServletContainerInitializer, Set<Class<?>>> entry : initializerClassMap.entrySet()) { if (entry.getValue().isEmpty()) { context.addServletContainerInitializer(entry.getKey(), null); } else { context.addServletContainerInitializer(entry.getKey(), entry.getValue()); } } } } else { webXml.configureContext(context); } }
protected String[] generateJava() throws Exception { String[] smapStr = null; long t1, t2, t3, t4; t1 = t2 = t3 = t4 = 0; if (log.isDebugEnabled()) { t1 = System.currentTimeMillis(); } pageInfo = new PageInfo(new BeanRepository(ctxt.getClassLoader(), errDispatcher), ctxt.getJspFile()); JspConfig jspConfig = options.getJspConfig(); JspConfig.JspProperty jspProperty = jspConfig.findJspProperty(ctxt.getJspFile()); if (jspProperty.isELIgnored() != null) { pageInfo.setELIgnored(JspUtil.booleanValue(jspProperty.isELIgnored())); } if (jspProperty.isScriptingInvalid() != null) { pageInfo.setScriptingInvalid(JspUtil.booleanValue(jspProperty.isScriptingInvalid())); } if (jspProperty.getIncludePrelude() != null) { pageInfo.setIncludePrelude(jspProperty.getIncludePrelude()); } if (jspProperty.getIncludeCoda() != null) { pageInfo.setIncludeCoda(jspProperty.getIncludeCoda()); } if (jspProperty.isDeferedSyntaxAllowedAsLiteral() != null) { pageInfo.setDeferredSyntaxAllowedAsLiteral(JspUtil.booleanValue(jspProperty.isDeferedSyntaxAllowedAsLiteral())); } if (jspProperty.isTrimDirectiveWhitespaces() != null) { pageInfo.setTrimDirectiveWhitespaces(JspUtil.booleanValue(jspProperty.isTrimDirectiveWhitespaces())); } if (jspProperty.getDefaultContentType() != null) { pageInfo.setContentType(jspProperty.getDefaultContentType()); } if (jspProperty.getBuffer() != null) { pageInfo.setBufferValue(jspProperty.getBuffer(), null, errDispatcher); } if (jspProperty.isErrorOnUndeclaredNamespace() != null) { pageInfo.setErrorOnUndeclaredNamespace(JspUtil.booleanValue(jspProperty.isErrorOnUndeclaredNamespace())); } if (ctxt.isTagFile()) { try { double libraryVersion = Double.parseDouble(ctxt.getTagInfo().getTagLibrary().getRequiredVersion()); if (libraryVersion < 2.0) { pageInfo.setIsELIgnored("true", null, errDispatcher, true); } if (libraryVersion < 2.1) { pageInfo.setDeferredSyntaxAllowedAsLiteral("true", null, errDispatcher, true); } } catch (NumberFormatException ex) { errDispatcher.jspError(ex); } } ctxt.checkOutputDir(); String javaFileName = ctxt.getServletJavaFileName(); ServletWriter writer = null; try { /* * The setting of isELIgnored changes the behaviour of the parser * in subtle ways. To add to the 'fun', isELIgnored can be set in * any file that forms part of the translation unit so setting it * in a file included towards the end of the translation unit can * change how the parser should have behaved when parsing content * up to the point where isELIgnored was set. Arghh! * Previous attempts to hack around this have only provided partial * solutions. We now use two passes to parse the translation unit. * The first just parses the directives and the second parses the * whole translation unit once we know how isELIgnored has been set. * TODO There are some possible optimisations of this process. */ ParserController parserCtl = new ParserController(ctxt, this); Node.Nodes directives = parserCtl.parseDirectives(ctxt.getJspFile()); Validator.validateDirectives(this, directives); pageNodes = parserCtl.parse(ctxt.getJspFile()); if (ctxt.isPrototypeMode()) { writer = setupContextWriter(javaFileName); Generator.generate(writer, this, pageNodes); writer.close(); writer = null; return null; } // Validate and process attributes - don't re-validate the Validator.validateExDirectives(this, pageNodes); if (log.isDebugEnabled()) { t2 = System.currentTimeMillis(); } Collector.collect(this, pageNodes); // Compile (if necessary) and load the tag files referenced in tfp = new TagFileProcessor(); tfp.loadTagFiles(this, pageNodes); if (log.isDebugEnabled()) { t3 = System.currentTimeMillis(); } ScriptingVariabler.set(pageNodes, errDispatcher); TagPluginManager tagPluginManager = options.getTagPluginManager(); tagPluginManager.apply(pageNodes, errDispatcher, pageInfo); TextOptimizer.concatenate(this, pageNodes); ELFunctionMapper.map(pageNodes); writer = setupContextWriter(javaFileName); Generator.generate(writer, this, pageNodes); writer.close(); writer = null; // The writer is only used during the compile, dereference // it in the JspCompilationContext when done to allow it ctxt.setWriter(null); if (log.isDebugEnabled()) { t4 = System.currentTimeMillis(); log.debug("Generated " + javaFileName + " total=" + (t4 - t1) + " generate=" + (t4 - t3) + " validate=" + (t2 - t1)); } } catch (Exception e) { if (writer != null) { try { writer.close(); writer = null; } catch (Exception e1) { // do nothing } } new File(javaFileName).delete(); throw e; } finally { if (writer != null) { try { writer.close(); } catch (Exception e2) { // do nothing } } } if (!options.isSmapSuppressed()) { smapStr = SmapUtil.generateSmap(ctxt, pageNodes); } // If any proto type .java and .class files was generated, // the prototype .java may have been replaced by the current // compilation (if the tag file is self referencing), but the // .class file need to be removed, to make sure that javac would tfp.removeProtoTypeFiles(ctxt.getClassFileName()); return smapStr; }
protected boolean validate(String name) { if (name == null) return false; if (name.startsWith("java.")) return false; return true; }
private Class<?> getType() { return type; }	@Override public Expression parseExpression(String expression, @SuppressWarnings("unchecked") Class expectedType, FunctionMapper fMapper) throws ELException { try { ELContextImpl ctx = new ELContextImpl(ELResolverImpl.getDefaultResolver()); if (fMapper != null) { ctx.setFunctionMapper(new FunctionMapperImpl(fMapper)); } ValueExpression ve = this.factory.createValueExpression(ctx, expression, expectedType); return new ExpressionImpl(ve); } catch (javax.el.ELException e) { throw new ELParseException(e.getMessage()); } }	@Override public MethodInfo getMethodInfo(EvaluationContext ctx, @SuppressWarnings("unchecked") Class[] paramTypes) throws ELException { Target t = getTarget(ctx); Method m = ReflectionUtil.getMethod(t.base, t.property, paramTypes); return new MethodInfo(m.getName(), m.getReturnType(), m.getParameterTypes()); }	@Override public Object evaluate(String expression, @SuppressWarnings("unchecked") Class expectedType, VariableResolver vResolver, FunctionMapper fMapper) throws ELException { return this.parseExpression(expression, expectedType, fMapper).evaluate(vResolver); }	@Override public Object getContent() throws IOException { if (!connected) connect(); if (resource != null) return getInputStream(); if (collection != null) return collection; if (object != null) return object; throw new FileNotFoundException(); }	@Override public Object getValue(ELContext context, Object base, Object property) throws NullPointerException, PropertyNotFoundException, ELException { if (context == null) { throw new NullPointerException(); } if (base == null && property != null) { int idx = Arrays.binarySearch(SCOPE_NAMES, property.toString()); if (idx >= 0) { PageContext page = (PageContext) context.getContext(JspContext.class); context.setPropertyResolved(true); switch(idx) { case APPLICATIONSCOPE: return ScopeManager.get(page).getApplicationScope(); case COOKIE: return ScopeManager.get(page).getCookie(); case HEADER: return ScopeManager.get(page).getHeader(); case HEADERVALUES: return ScopeManager.get(page).getHeaderValues(); case INITPARAM: return ScopeManager.get(page).getInitParam(); case PAGECONTEXT: return ScopeManager.get(page).getPageContext(); case PAGESCOPE: return ScopeManager.get(page).getPageScope(); case PARAM: return ScopeManager.get(page).getParam(); case PARAM_VALUES: return ScopeManager.get(page).getParamValues(); case REQUEST_SCOPE: return ScopeManager.get(page).getRequestScope(); case SESSION_SCOPE: return ScopeManager.get(page).getSessionScope(); } } } return null; }	private Class<?>[] getTypesFromValues(Object[] values) { if (values == null) { return null; } Class<?>[] result = new Class<?>[values.length]; for (int i = 0; i < values.length; i++) { if (values[i] == null) { result[i] = null; } else { result[i] = values[i].getClass(); } } return result; }	@Override public VariableMapper getVariableMapper() { return this.varMapper; }	@Override public VariableMapper getVariableMapper() { return this.target.getVariableMapper(); }	@Override public boolean isPropertyResolved() { return this.elContext.isPropertyResolved(); }	@Override public boolean isPropertyResolved() { return this.target.isPropertyResolved(); }	@Override public Class<?> getCommonPropertyType(ELContext context, Object base) { if (base instanceof ResourceBundle) { return String.class; } return null; }	public boolean isWrapperFor(ServletRequest wrapped) { if (request == wrapped) { return true; } if (request instanceof ServletRequestWrapper) { return ((ServletRequestWrapper) request).isWrapperFor(wrapped); } return false; }	public boolean isWrapperFor(ServletResponse wrapped) { if (response == wrapped) { return true; } if (response instanceof ServletResponseWrapper) { return ((ServletResponseWrapper) response).isWrapperFor(wrapped); } return false; }	public static final Tag findAncestorWithClass(Tag from, @SuppressWarnings("unchecked") Class klass) { boolean isInterface = false; if (from == null || klass == null || (!Tag.class.isAssignableFrom(klass) && !(isInterface = klass.isInterface()))) { return null; } for (; ; ) { Tag tag = from.getParent(); if (tag == null) { return null; } if ((isInterface && klass.isInstance(tag)) || ((Class<?>) klass).isAssignableFrom(tag.getClass())) { return tag; } from = tag; } }
public Member getNextBackupNode() { Member[] members = getMapMembers(); int node = getNextBackupIndex(); if (members.length == 0 || node == -1) return null; if (node >= members.length) node = 0; return members[node]; }	@Override public String toString() { StringBuilder buf = new StringBuilder("MapEntry[key:"); buf.append(getKey()).append("; "); buf.append("value:").append(getValue()).append("; "); buf.append("primary:").append(isPrimary()).append("; "); buf.append("backup:").append(isBackup()).append("; "); buf.append("proxy:").append(isProxy()).append(";]"); return buf.toString(); }	public Object getValue() { return value; }	public Object setValue(Object value) { Object old = this.value; this.value = value; return old; }	public Serializable replyRequest(Serializable msg, final Member sender) { if (!(msg instanceof MapMessage)) return null; MapMessage mapmsg = (MapMessage) msg; if (mapmsg.getMsgType() == MapMessage.MSG_INIT) { mapmsg.setPrimary(channel.getLocalMember(false)); return mapmsg; } if (mapmsg.getMsgType() == MapMessage.MSG_START) { mapmsg.setPrimary(channel.getLocalMember(false)); mapMemberAdded(sender); return mapmsg; } if (mapmsg.getMsgType() == MapMessage.MSG_RETRIEVE_BACKUP) { MapEntry entry = (MapEntry) super.get(mapmsg.getKey()); if (entry == null || (!entry.isSerializable())) return null; mapmsg.setValue((Serializable) entry.getValue()); return mapmsg; } if (mapmsg.getMsgType() == MapMessage.MSG_STATE || mapmsg.getMsgType() == MapMessage.MSG_STATE_COPY) { synchronized (stateMutex) { ArrayList<MapMessage> list = new ArrayList<MapMessage>(); Iterator<Map.Entry<?, ?>> i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry<?, ?> e = i.next(); MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry != null && entry.isSerializable()) { boolean copy = (mapmsg.getMsgType() == MapMessage.MSG_STATE_COPY); MapMessage me = new MapMessage(mapContextName, copy ? MapMessage.MSG_COPY : MapMessage.MSG_PROXY, false, (Serializable) entry.getKey(), copy ? (Serializable) entry.getValue() : null, null, entry.getPrimary(), entry.getBackupNodes()); list.add(me); } } mapmsg.setValue(list); return mapmsg; } //synchronized } return null; }	public Member[] excludeFromSet(Member[] mbrs, Member[] set) { ArrayList<Member> result = new ArrayList<Member>(); for (int i = 0; i < set.length; i++) { boolean include = true; for (int j = 0; j < mbrs.length; j++) if (mbrs[j].equals(set[i])) include = false; if (include) result.add(set[i]); } return result.toArray(new Member[result.size()]); }	@Override public Collection<Object> values() { ArrayList<Object> values = new ArrayList<Object>(); Iterator<Map.Entry<?, ?>> i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry<?, ?> e = i.next(); MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry != null && entry.isActive() && entry.getValue() != null) values.add(entry.getValue()); } return Collections.unmodifiableCollection(values); }	public void leftOver(Serializable msg, Member sender) { if (!(msg instanceof MapMessage)) return; MapMessage mapmsg = (MapMessage) msg; try { mapmsg.deserialize(getExternalLoaders()); if (mapmsg.getMsgType() == MapMessage.MSG_START) { mapMemberAdded(mapmsg.getPrimary()); } else if (mapmsg.getMsgType() == MapMessage.MSG_INIT) { memberAlive(mapmsg.getPrimary()); } } catch (IOException x) { log.error("Unable to deserialize MapMessage.", x); } catch (ClassNotFoundException x) { log.error("Unable to deserialize MapMessage.", x); } }	public void listBeans(PrintWriter writer, String qry) { Set<ObjectName> names = null; try { names = mBeanServer.queryNames(new ObjectName(qry), null); writer.println("OK - Number of results: " + names.size()); writer.println(); } catch (Exception e) { writer.println("Error - " + e.toString()); return; } Iterator<ObjectName> it = names.iterator(); while (it.hasNext()) { ObjectName oname = it.next(); writer.println("Name: " + oname.toString()); try { MBeanInfo minfo = mBeanServer.getMBeanInfo(oname); String code = minfo.getClassName(); if ("org.apache.commons.modeler.BaseModelMBean".equals(code)) { code = (String) mBeanServer.getAttribute(oname, "modelerType"); } writer.println("modelerType: " + code); MBeanAttributeInfo[] attrs = minfo.getAttributes(); Object value = null; for (int i = 0; i < attrs.length; i++) { if (!attrs[i].isReadable()) continue; if (!isSupported(attrs[i].getType())) continue; String attName = attrs[i].getName(); if ("modelerType".equals(attName)) continue; if (attName.indexOf("=") >= 0 || attName.indexOf(":") >= 0 || attName.indexOf(" ") >= 0) { continue; } try { value = mBeanServer.getAttribute(oname, attName); } catch (Throwable t) { log("Error getting attribute " + oname + " " + attName + " " + t.toString()); continue; } if (value == null) continue; String valueString; try { Class c = value.getClass(); if (c.isArray()) { int len = Array.getLength(value); StringBuilder sb = new StringBuilder("Array[" + c.getComponentType().getName() + "] of length " + len); if (len > 0) { sb.append("\r\n"); } for (int j = 0; j < len; j++) { sb.append("\t"); Object item = Array.get(value, j); if (item == null) { sb.append("NULL VALUE"); } else { try { sb.append(escape(item.toString())); } catch (Throwable t) { sb.append("NON-STRINGABLE VALUE"); } } if (j < len - 1) { sb.append("\r\n"); } } valueString = sb.toString(); } else { valueString = escape(value.toString()); } writer.println(attName + ": " + valueString); } catch (Throwable t) { // Ignore } } } catch (Exception e) { // Ignore } writer.println(); } }	public void memberAdded(Member member) { //do nothing }	public void messageReceived(Serializable msg, Member sender) { if (!(msg instanceof MapMessage)) return; MapMessage mapmsg = (MapMessage) msg; if (log.isTraceEnabled()) { log.trace("Map[" + mapname + "] received message:" + mapmsg); } try { mapmsg.deserialize(getExternalLoaders()); } catch (IOException x) { log.error("Unable to deserialize MapMessage.", x); return; } catch (ClassNotFoundException x) { log.error("Unable to deserialize MapMessage.", x); return; } if (log.isTraceEnabled()) log.trace("Map message received from:" + sender.getName() + " msg:" + mapmsg); if (mapmsg.getMsgType() == MapMessage.MSG_START) { mapMemberAdded(mapmsg.getPrimary()); } if (mapmsg.getMsgType() == MapMessage.MSG_STOP) { memberDisappeared(mapmsg.getPrimary()); } if (mapmsg.getMsgType() == MapMessage.MSG_PROXY) { MapEntry entry = (MapEntry) super.get(mapmsg.getKey()); if (entry == null) { entry = new MapEntry(mapmsg.getKey(), mapmsg.getValue()); entry.setBackup(false); entry.setProxy(true); entry.setBackupNodes(mapmsg.getBackupNodes()); entry.setPrimary(mapmsg.getPrimary()); super.put(entry.getKey(), entry); } else { entry.setProxy(true); entry.setBackup(false); entry.setBackupNodes(mapmsg.getBackupNodes()); entry.setPrimary(mapmsg.getPrimary()); } } if (mapmsg.getMsgType() == MapMessage.MSG_REMOVE) { super.remove(mapmsg.getKey()); } if (mapmsg.getMsgType() == MapMessage.MSG_BACKUP || mapmsg.getMsgType() == MapMessage.MSG_COPY) { MapEntry entry = (MapEntry) super.get(mapmsg.getKey()); if (entry == null) { entry = new MapEntry(mapmsg.getKey(), mapmsg.getValue()); entry.setBackup(mapmsg.getMsgType() == MapMessage.MSG_BACKUP); entry.setProxy(false); entry.setBackupNodes(mapmsg.getBackupNodes()); entry.setPrimary(mapmsg.getPrimary()); if (mapmsg.getValue() != null && mapmsg.getValue() instanceof ReplicatedMapEntry) { ((ReplicatedMapEntry) mapmsg.getValue()).setOwner(getMapOwner()); } } else { entry.setBackup(mapmsg.getMsgType() == MapMessage.MSG_BACKUP); entry.setProxy(false); entry.setBackupNodes(mapmsg.getBackupNodes()); entry.setPrimary(mapmsg.getPrimary()); if (entry.getValue() instanceof ReplicatedMapEntry) { ReplicatedMapEntry diff = (ReplicatedMapEntry) entry.getValue(); if (mapmsg.isDiff()) { try { diff.lock(); diff.applyDiff(mapmsg.getDiffValue(), 0, mapmsg.getDiffValue().length); } catch (Exception x) { log.error("Unable to apply diff to key:" + entry.getKey(), x); } finally { diff.unlock(); } } else { if (mapmsg.getValue() != null) entry.setValue(mapmsg.getValue()); ((ReplicatedMapEntry) entry.getValue()).setOwner(getMapOwner()); } //end if } else if (mapmsg.getValue() instanceof ReplicatedMapEntry) { ReplicatedMapEntry re = (ReplicatedMapEntry) mapmsg.getValue(); re.setOwner(getMapOwner()); entry.setValue(re); } else { if (mapmsg.getValue() != null) entry.setValue(mapmsg.getValue()); } //end if } super.put(entry.getKey(), entry); } //end if }	public void transferState() { try { Member[] members = getMapMembers(); Member backup = members.length > 0 ? (Member) members[0] : null; if (backup != null) { MapMessage msg = new MapMessage(mapContextName, getStateMessageType(), false, null, null, null, null, null); Response[] resp = rpcChannel.send(new Member[] { backup }, msg, RpcChannel.FIRST_REPLY, channelSendOptions, rpcTimeout); if (resp.length > 0) { synchronized (stateMutex) { msg = (MapMessage) resp[0].getMessage(); msg.deserialize(getExternalLoaders()); ArrayList<?> list = (ArrayList<?>) msg.getValue(); for (int i = 0; i < list.size(); i++) { messageReceived((Serializable) list.get(i), resp[0].getSource()); } //for } } else { log.warn("Transfer state, 0 replies, probably a timeout."); } } } catch (ChannelException x) { log.error("Unable to transfer LazyReplicatedMap state.", x); } catch (IOException x) { log.error("Unable to transfer LazyReplicatedMap state.", x); } catch (ClassNotFoundException x) { log.error("Unable to transfer LazyReplicatedMap state.", x); } stateTransferred = true; }
protected void processAnnotations(Set<WebXml> fragments) { for (WebXml fragment : fragments) { if (!fragment.isMetadataComplete()) { WebXml annotations = new WebXml(); URL url = fragment.getURL(); processAnnotationsUrl(url, annotations); Set<WebXml> set = new HashSet<WebXml>(); set.add(annotations); fragment.merge(set); } } }
public void testInvokeWithVarArgsAAABBB() throws Exception { MethodExpression me9 = factory.createMethodExpression(context, "${beanC.sayHello(beanAAA,beanBBB,beanBBB)}", null, null); Object r9 = me9.invoke(context, null); assertEquals("ABB[]: Hello AAA from BBB, BBB", r9.toString()); }
public Session createSession(String sessionId) { if ((maxActiveSessions >= 0) && (sessions.size() >= maxActiveSessions)) { rejectedSessions++; throw new IllegalStateException(sm.getString("managerBase.createSession.ise")); } Session session = createEmptySession(); session.setNew(true); session.setValid(true); session.setCreationTime(System.currentTimeMillis()); session.setMaxInactiveInterval(this.maxInactiveInterval); String id = sessionId; if (id == null) { id = generateSessionId(); } session.setId(id); sessionCounter++; return (session); }	@Override public boolean containsValue(Object value) { if (value == null) { return super.containsValue(value); } else { Iterator<Map.Entry<?, ?>> i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry<?, ?> e = i.next(); MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry != null && entry.isPrimary() && value.equals(entry.getValue())) return true; } return false; } //end if }	@Override public Collection<Object> values() { ArrayList<Object> values = new ArrayList<Object>(); Iterator<Map.Entry<?, ?>> i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry<?, ?> e = i.next(); MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry != null && entry.isPrimary() && entry.getValue() != null) values.add(entry.getValue()); } return Collections.unmodifiableCollection(values); }	public boolean isPrimary() { return ((!proxy) && (!backup)); }	@Override public int size() { //todo, implement a counter variable instead int counter = 0; Iterator<Map.Entry<?, ?>> it = super.entrySet().iterator(); while (it != null && it.hasNext()) { Map.Entry<?, ?> e = it.next(); if (e != null) { MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry != null && entry.isPrimary() && entry.getValue() != null) counter++; } } return counter; }	@Override public Set<Object> keySet() { //todo implement LinkedHashSet<Object> set = new LinkedHashSet<Object>(super.size()); Iterator<Map.Entry<?, ?>> i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry<?, ?> e = i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry) super.get(key); if (entry != null && entry.isPrimary()) set.add(key); } return Collections.unmodifiableSet(set); }	public void add(Session session) { sessions.put(session.getIdInternal(), session); int size = sessions.size(); if (size > maxActive) { synchronized (maxActiveUpdateLock) { if (size > maxActive) { maxActive = size; } } } }
public Object getAttribute(String name) { if (name.equals(Globals.DISPATCHER_TYPE_ATTR)) { return (internalDispatcherType == null) ? DispatcherType.REQUEST : internalDispatcherType; } else if (name.equals(Globals.DISPATCHER_REQUEST_PATH_ATTR)) { return (requestDispatcherPath == null) ? getRequestPathMB().toString() : requestDispatcherPath.toString(); } if (name.equals(Globals.ASYNC_SUPPORTED_ATTR)) { return asyncSupported; } Object attr = attributes.get(name); if (attr != null) return (attr); attr = coyoteRequest.getAttribute(name); if (attr != null) return attr; if (isSSLAttribute(name)) { coyoteRequest.action(ActionCode.ACTION_REQ_SSL_ATTRIBUTE, coyoteRequest); attr = coyoteRequest.getAttribute(Globals.CERTIFICATES_ATTR); if (attr != null) { attributes.put(Globals.CERTIFICATES_ATTR, attr); } attr = coyoteRequest.getAttribute(Globals.CIPHER_SUITE_ATTR); if (attr != null) { attributes.put(Globals.CIPHER_SUITE_ATTR, attr); } attr = coyoteRequest.getAttribute(Globals.KEY_SIZE_ATTR); if (attr != null) { attributes.put(Globals.KEY_SIZE_ATTR, attr); } attr = coyoteRequest.getAttribute(Globals.SSL_SESSION_ID_ATTR); if (attr != null) { attributes.put(Globals.SSL_SESSION_ID_ATTR, attr); } attr = coyoteRequest.getAttribute(Globals.SSL_SESSION_MGR_ATTR); if (attr != null) { attributes.put(Globals.SSL_SESSION_MGR_ATTR, attr); } attr = attributes.get(name); } return attr; }	public void recycle() { context = null; wrapper = null; internalDispatcherType = null; requestDispatcherPath = null; comet = false; if (event != null) { event.clear(); event = null; } authType = null; inputBuffer.recycle(); usingInputStream = false; usingReader = false; userPrincipal = null; subject = null; sessionParsed = false; parametersParsed = false; parts = null; partsParseException = null; cookiesParsed = false; locales.clear(); localesParsed = false; secure = false; remoteAddr = null; remoteHost = null; remotePort = -1; localPort = -1; localAddr = null; localName = null; attributes.clear(); notes.clear(); cookies = null; if (session != null) { session.endAccess(); } session = null; requestedSessionCookie = false; requestedSessionId = null; requestedSessionURL = false; if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) { parameterMap = new ParameterMap<String, String[]>(); } else { parameterMap.setLocked(false); parameterMap.clear(); } mappingData.recycle(); if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) { if (facade != null) { facade.clear(); facade = null; } if (inputStream != null) { inputStream.clear(); inputStream = null; } if (reader != null) { reader.clear(); reader = null; } } asyncSupported = null; if (asyncContext != null) asyncContext.recycle(); asyncContext = null; pathParameters.clear(); }	public org.apache.coyote.Request getCoyoteRequest() { return (this.coyoteRequest); }	public Enumeration<String> getAttributeNames() { if (isSecure()) { getAttribute(Globals.CERTIFICATES_ATTR); } return new Enumerator<String>(attributes.keySet(), true); }
SocketState asyncDispatch(SocketStatus status) throws IOException { RequestInfo rp = request.getRequestProcessor(); try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); error = !adapter.asyncDispatch(request, response, status); } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("http11processor.request.process"), t); response.setStatus(500); adapter.log(request, response, 0); error = true; } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (error) { recycle(); return SocketState.CLOSED; } else if (async) { return SocketState.LONG; } else { if (!keepAlive) { recycle(); return SocketState.CLOSED; } else { return SocketState.OPEN; } } }	public boolean asyncDispatch(org.apache.coyote.Request req, org.apache.coyote.Response res, SocketStatus status) throws Exception { Request request = (Request) req.getNote(ADAPTER_NOTES); Response response = (Response) res.getNote(ADAPTER_NOTES); if (request == null) { throw new IllegalStateException("Dispatch may only happen on an existing request."); } boolean comet = false; boolean async = false; boolean success = true; try { if (status == SocketStatus.TIMEOUT) { AsyncContextImpl asyncConImpl = (AsyncContextImpl) request.getAsyncContext(); //TODO SERVLET3 - async asyncConImpl.setTimeoutState(); } if (status == SocketStatus.ERROR || status == SocketStatus.STOP || status == SocketStatus.DISCONNECT) { AsyncContextImpl asyncConImpl = (AsyncContextImpl) request.getAsyncContext(); //TODO SERVLET3 - async asyncConImpl.setErrorState(new IOException("Socket error.")); } while (success) { AsyncContextImpl impl = (AsyncContextImpl) request.getAsyncContext(); if (impl.getState() == AsyncContextImpl.AsyncState.DISPATCHED) { try { impl.complete(); connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); } finally { success = false; } } else if (impl.getState() == AsyncContextImpl.AsyncState.STARTED) { res.action(ActionCode.ACTION_ASYNC_START, request.getAsyncContext()); async = true; break; } else if (impl.getState() == AsyncContextImpl.AsyncState.NOT_STARTED) { async = false; break; } else if (impl.getState() == AsyncContextImpl.AsyncState.ERROR_DISPATCHING) { async = false; success = false; connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); } else { try { connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); } catch (RuntimeException x) { impl.setErrorState(x); } } } if (request.isComet()) { if (!response.isClosed() && !response.isError()) { if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) { if (event(req, res, SocketStatus.OPEN)) { comet = true; res.action(ActionCode.ACTION_COMET_BEGIN, null); } } else { comet = true; res.action(ActionCode.ACTION_COMET_BEGIN, null); } } else { // Clear the filter chain, as otherwise it will not be reset elsewhere request.setFilterChain(null); } } if (!async && !comet) { response.finishResponse(); req.action(ActionCode.ACTION_POST_REQUEST, null); } } catch (IOException e) { success = false; // Ignore } catch (Throwable t) { success = false; log.error(sm.getString("coyoteAdapter.service"), t); } finally { req.getRequestProcessor().setWorkerThreadName(null); if (!success || (!comet && !async)) { request.recycle(); response.recycle(); } else { // Clear converters so that the minimum amount of memory request.clearEncoders(); response.clearEncoders(); } } return success; }	public boolean isAsyncDispatching() { if (asyncContext == null) { return false; } return (asyncContext.getState() == AsyncContextImpl.AsyncState.DISPATCHING || asyncContext.getState() == AsyncContextImpl.AsyncState.DISPATCHING_RUNNABLE || asyncContext.getState() == AsyncContextImpl.AsyncState.TIMING_OUT || asyncContext.getState() == AsyncContextImpl.AsyncState.STARTED || asyncContext.getState() == AsyncContextImpl.AsyncState.ERROR_DISPATCHING || asyncContext.getState() == AsyncContextImpl.AsyncState.COMPLETING); }	public boolean isStarted() { return (state.get() == AsyncState.STARTED || state.get() == AsyncState.DISPATCHING || state.get() == AsyncState.DISPATCHING_RUNNABLE); }	@Override public void complete() { if (log.isDebugEnabled()) { log.debug("AsyncContext Complete Called[" + state.get() + "; " + request.getRequestURI() + "?" + request.getQueryString() + "]", new DebugException()); } if (state.get() == AsyncState.COMPLETING) { //do nothing } else if (state.compareAndSet(AsyncState.DISPATCHED, AsyncState.COMPLETING) || state.compareAndSet(AsyncState.STARTED, AsyncState.COMPLETING)) { AtomicBoolean dispatched = new AtomicBoolean(false); request.getCoyoteRequest().action(ActionCode.ACTION_ASYNC_COMPLETE, dispatched); if (!dispatched.get()) doInternalComplete(false); } else if (state.compareAndSet(AsyncState.DISPATCHING_RUNNABLE, AsyncState.COMPLETING_RUNNABLE)) { // do nothing } else { throw new IllegalStateException("Complete not allowed. Invalid state:" + state.get()); } }	public void doInternalDispatch() throws ServletException, IOException { if (this.state.compareAndSet(AsyncState.TIMING_OUT, AsyncState.COMPLETING)) { log.debug("TIMING OUT!"); boolean listenerInvoked = false; for (AsyncListenerWrapper listener : listeners) { listener.fireOnTimeout(event); listenerInvoked = true; } if (!listenerInvoked) { ((HttpServletResponse) servletResponse).setStatus(500); } doInternalComplete(true); } else if (this.state.compareAndSet(AsyncState.ERROR_DISPATCHING, AsyncState.COMPLETING)) { log.debug("ON ERROR!"); boolean listenerInvoked = false; for (AsyncListenerWrapper listener : listeners) { try { listener.fireOnError(event); } catch (IllegalStateException x) { log.debug("Listener invoked invalid state.", x); } catch (Exception x) { log.debug("Exception during onError.", x); } listenerInvoked = true; } if (!listenerInvoked) { ((HttpServletResponse) servletResponse).setStatus(500); } doInternalComplete(true); } else if (this.state.compareAndSet(AsyncState.DISPATCHING, AsyncState.DISPATCHED)) { if (this.dispatch != null) { try { dispatch.run(); } catch (RuntimeException x) { doInternalComplete(true); if (x.getCause() instanceof ServletException) throw (ServletException) x.getCause(); if (x.getCause() instanceof IOException) throw (IOException) x.getCause(); else throw new ServletException(x); } finally { dispatch = null; } } } else if (this.state.get() == AsyncState.DISPATCHING_RUNNABLE) { if (this.dispatch != null) { try { dispatch.run(); } catch (RuntimeException x) { doInternalComplete(true); if (x.getCause() instanceof ServletException) throw (ServletException) x.getCause(); if (x.getCause() instanceof IOException) throw (IOException) x.getCause(); else throw new ServletException(x); } finally { dispatch = null; } if (this.state.compareAndSet(AsyncState.COMPLETING_RUNNABLE, AsyncState.COMPLETING)) { doInternalComplete(false); } else if (this.state.get() == AsyncState.DISPATCHING_RUNNABLE) { doInternalComplete(true); throw new IllegalStateException("Failed to call dispatch() or complete() after start()"); } } } else if (this.state.get() == AsyncState.COMPLETING) { doInternalComplete(false); } else { throw new IllegalStateException("Dispatch illegal. Invalid state: " + state.get()); } }	protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException { result.append('1'); result.append(req.isAsyncStarted()); req.startAsync(); result.append('2'); result.append(req.isAsyncStarted()); req.getAsyncContext().start(new Runnable() { @Override public void run() { try { result.append('3'); result.append(req.isAsyncStarted()); Thread.sleep(1000); result.append('4'); result.append(req.isAsyncStarted()); req.getAsyncContext().complete(); result.append('5'); result.append(req.isAsyncStarted()); } catch (InterruptedException e) { e.printStackTrace(); } } }); // Pointless method call so there is somewhere to put a break point req.getMethod(); }	@Override public void start(final Runnable run) { if (log.isDebugEnabled()) { log.debug("AsyncContext Start Called["+state.get()+"; "+request.getRequestURI()+"?"+request.getQueryString()+"]", new DebugException()); } if (state.compareAndSet(AsyncState.STARTED, AsyncState.DISPATCHING_RUNNABLE) || state.compareAndSet(AsyncState.DISPATCHED, AsyncState.DISPATCHING_RUNNABLE)) { // TODO SERVLET3 - async final ServletContext sctx = getServletRequest().getServletContext(); Runnable r = new Runnable() { } } }	public void testBug49528() throws Exception { Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext("/", System.getProperty("java.io.tmpdir")); Bug49528Servlet servlet = new Bug49528Servlet(); Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet); wrapper.setAsyncSupported(true); ctx.addServletMapping("/", "servlet"); tomcat.start(); getUrl("http://localhost:" + getPort() + "/"); assertEquals("1false2true3true4true5false", servlet.getResult()); }
public void testConfiguration() throws Exception { Tomcat tomcat = getTomcatInstance(); Context root = tomcat.addContext("", TEMP_DIR); FilterDef filterDef = new FilterDef(); filterDef.addInitParameter("ExpiresDefault", "access plus 1 month"); filterDef.addInitParameter("ExpiresByType text/html", "access plus 1 month 15 days 2 hours"); filterDef.addInitParameter("ExpiresByType image/gif", "modification plus 5 hours 3 minutes"); filterDef.addInitParameter("ExpiresByType image/jpg", "A10000"); filterDef.addInitParameter("ExpiresByType video/mpeg", "M20000"); filterDef.addInitParameter("ExpiresActive", "Off"); filterDef.addInitParameter("ExpiresExcludedResponseStatusCodes", "304, 503"); ExpiresFilter expiresFilter = new ExpiresFilter(); filterDef.setFilter(expiresFilter); filterDef.setFilterClass(ExpiresFilter.class.getName()); filterDef.setFilterName(ExpiresFilter.class.getName()); root.addFilterDef(filterDef); FilterMap filterMap = new FilterMap(); filterMap.setFilterName(ExpiresFilter.class.getName()); filterMap.addURLPattern("*"); tomcat.start(); try { { int[] excludedResponseStatusCodes = expiresFilter.getExcludedResponseStatusCodesAsInts(); Assert.assertEquals(2, excludedResponseStatusCodes.length); Assert.assertEquals(304, excludedResponseStatusCodes[0]); Assert.assertEquals(503, excludedResponseStatusCodes[1]); } { ExpiresConfiguration expiresConfiguration = expiresFilter.getDefaultExpiresConfiguration(); Assert.assertEquals(StartingPoint.ACCESS_TIME, expiresConfiguration.getStartingPoint()); Assert.assertEquals(1, expiresConfiguration.getDurations().size()); Assert.assertEquals(DurationUnit.MONTH, expiresConfiguration.getDurations().get(0).getUnit()); Assert.assertEquals(1, expiresConfiguration.getDurations().get(0).getAmount()); } { ExpiresConfiguration expiresConfiguration = expiresFilter.getExpiresConfigurationByContentType().get("text/html"); Assert.assertEquals(StartingPoint.ACCESS_TIME, expiresConfiguration.getStartingPoint()); Assert.assertEquals(3, expiresConfiguration.getDurations().size()); Duration oneMonth = expiresConfiguration.getDurations().get(0); Assert.assertEquals(DurationUnit.MONTH, oneMonth.getUnit()); Assert.assertEquals(1, oneMonth.getAmount()); Duration fifteenDays = expiresConfiguration.getDurations().get(1); Assert.assertEquals(DurationUnit.DAY, fifteenDays.getUnit()); Assert.assertEquals(15, fifteenDays.getAmount()); Duration twoHours = expiresConfiguration.getDurations().get(2); Assert.assertEquals(DurationUnit.HOUR, twoHours.getUnit()); Assert.assertEquals(2, twoHours.getAmount()); } { ExpiresConfiguration expiresConfiguration = expiresFilter.getExpiresConfigurationByContentType().get("image/gif"); Assert.assertEquals(StartingPoint.LAST_MODIFICATION_TIME, expiresConfiguration.getStartingPoint()); Assert.assertEquals(2, expiresConfiguration.getDurations().size()); Duration fiveHours = expiresConfiguration.getDurations().get(0); Assert.assertEquals(DurationUnit.HOUR, fiveHours.getUnit()); Assert.assertEquals(5, fiveHours.getAmount()); Duration threeMinutes = expiresConfiguration.getDurations().get(1); Assert.assertEquals(DurationUnit.MINUTE, threeMinutes.getUnit()); Assert.assertEquals(3, threeMinutes.getAmount()); } { ExpiresConfiguration expiresConfiguration = expiresFilter.getExpiresConfigurationByContentType().get("image/jpg"); Assert.assertEquals(StartingPoint.ACCESS_TIME, expiresConfiguration.getStartingPoint()); Assert.assertEquals(1, expiresConfiguration.getDurations().size()); Duration tenThousandSeconds = expiresConfiguration.getDurations().get(0); Assert.assertEquals(DurationUnit.SECOND, tenThousandSeconds.getUnit()); Assert.assertEquals(10000, tenThousandSeconds.getAmount()); } { ExpiresConfiguration expiresConfiguration = expiresFilter.getExpiresConfigurationByContentType().get("video/mpeg"); Assert.assertEquals(StartingPoint.LAST_MODIFICATION_TIME, expiresConfiguration.getStartingPoint()); Assert.assertEquals(1, expiresConfiguration.getDurations().size()); Duration twentyThousandSeconds = expiresConfiguration.getDurations().get(0); Assert.assertEquals(DurationUnit.SECOND, twentyThousandSeconds.getUnit()); Assert.assertEquals(20000, twentyThousandSeconds.getAmount()); } } finally { tomcat.stop(); } }

@Override protected synchronized void startInternal() throws LifecycleException { try { if (log.isInfoEnabled()) log.info("Starting clustering manager...:" + getName()); if (cluster == null) { log.error("Starting... no cluster associated with this context:" + getName()); setState(LifecycleState.FAILED); return; } cluster.registerManager(this); if (cluster.getMembers().length > 0) { Member mbr = cluster.getMembers()[0]; SessionMessage msg = new SessionMessageImpl(this.getName(), SessionMessage.EVT_GET_ALL_SESSIONS, null, "GET-ALL", "GET-ALL-" + this.getName()); cluster.send(msg, mbr); if (log.isWarnEnabled()) log.warn("Manager[" + getName() + "], requesting session state from " + mbr + ". This operation will timeout if no session state has been received within " + "60 seconds"); long reqStart = System.currentTimeMillis(); long reqNow = 0; boolean isTimeout = false; do { try { Thread.sleep(100); } catch (Exception sleep) { } reqNow = System.currentTimeMillis(); isTimeout = ((reqNow - reqStart) > (1000 * 60)); } while ((!isStateTransferred()) && (!isTimeout)); if (isTimeout || (!isStateTransferred())) { log.error("Manager[" + getName() + "], No session state received, timing out."); } else { if (log.isInfoEnabled()) log.info("Manager[" + getName() + "], session state received in " + (reqNow - reqStart) + " ms."); } } else { if (log.isInfoEnabled()) log.info("Manager[" + getName() + "], skipping state transfer. No members active in cluster group."); } super.startInternal(); } catch (Exception x) { log.error("Unable to start SimpleTcpReplicationManager", x); setState(LifecycleState.FAILED); } }
public void start() throws LifecycleException { started = true; String encoding = null; try { encoding = System.getProperty("file.encoding"); } catch (Exception e) { return; } if (encoding.indexOf("EBCDIC") != -1) { needConvert = true; } }
protected void addBuiltinCommands() { addCommand("config", new SSIConfig()); addCommand("echo", new SSIEcho()); addCommand("exec", new SSIExec()); addCommand("include", new SSIInclude()); addCommand("flastmod", new SSIFlastmod()); addCommand("fsize", new SSIFsize()); addCommand("printenv", new SSIPrintenv()); addCommand("set", new SSISet()); SSIConditional ssiConditional = new SSIConditional(); addCommand("if", ssiConditional); addCommand("elif", ssiConditional); addCommand("endif", ssiConditional); addCommand("else", ssiConditional); }	protected void processSSI(HttpServletRequest req, HttpServletResponse res, URL resource) throws IOException { SSIExternalResolver ssiExternalResolver = new SSIServletExternalResolver(getServletContext(), req, res, isVirtualWebappRelative, debug, inputEncoding); SSIProcessor ssiProcessor = new SSIProcessor(ssiExternalResolver, debug); PrintWriter printWriter = null; StringWriter stringWriter = null; if (buffered) { stringWriter = new StringWriter(); printWriter = new PrintWriter(stringWriter); } else { printWriter = res.getWriter(); } URLConnection resourceInfo = resource.openConnection(); InputStream resourceInputStream = resourceInfo.getInputStream(); String encoding = resourceInfo.getContentEncoding(); if (encoding == null) { encoding = inputEncoding; } InputStreamReader isr; if (encoding == null) { isr = new InputStreamReader(resourceInputStream); } else { isr = new InputStreamReader(resourceInputStream, encoding); } BufferedReader bufferedReader = new BufferedReader(isr); long lastModified = ssiProcessor.process(bufferedReader, resourceInfo.getLastModified(), printWriter); if (lastModified > 0) { res.setDateHeader("last-modified", lastModified); } if (buffered) { printWriter.flush(); String text = stringWriter.toString(); res.getWriter().write(text); } bufferedReader.close(); }	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; req.setAttribute(Globals.SSI_FLAG_ATTR, "true"); ByteArrayServletOutputStream basos = new ByteArrayServletOutputStream(); ResponseIncludeWrapper responseIncludeWrapper = new ResponseIncludeWrapper(config.getServletContext(), req, res, basos); chain.doFilter(req, responseIncludeWrapper); responseIncludeWrapper.flushOutputStreamOrWriter(); byte[] bytes = basos.toByteArray(); String contentType = responseIncludeWrapper.getContentType(); if (contentTypeRegEx.matcher(contentType).matches()) { String encoding = res.getCharacterEncoding(); SSIExternalResolver ssiExternalResolver = new SSIServletExternalResolver(config.getServletContext(), req, res, isVirtualWebappRelative, debug, encoding); SSIProcessor ssiProcessor = new SSIProcessor(ssiExternalResolver, debug); Reader reader = new InputStreamReader(new ByteArrayInputStream(bytes), encoding); ByteArrayOutputStream ssiout = new ByteArrayOutputStream(); PrintWriter writer = new PrintWriter(new OutputStreamWriter(ssiout, encoding)); long lastModified = ssiProcessor.process(reader, responseIncludeWrapper.getLastModified(), writer); writer.flush(); bytes = ssiout.toByteArray(); if (expires != null) { res.setDateHeader("expires", (new java.util.Date()).getTime() + expires.longValue() * 1000); } if (lastModified > 0) { res.setDateHeader("last-modified", lastModified); } res.setContentLength(bytes.length); Matcher shtmlMatcher = shtmlRegEx.matcher(responseIncludeWrapper.getContentType()); if (shtmlMatcher.matches()) { // Convert shtml mime type to ordinary html mime type but preserve String enc = shtmlMatcher.group(1); res.setContentType("text/html" + ((enc != null) ? enc : "")); } } OutputStream out = null; try { out = res.getOutputStream(); } catch (IllegalStateException e) { // Ignore, will try to use a writer } if (out == null) { res.getWriter().write(new String(bytes)); } else { out.write(bytes); } }	public void init() throws ServletException { if (getServletConfig().getInitParameter("debug") != null) debug = Integer.parseInt(getServletConfig().getInitParameter("debug")); isVirtualWebappRelative = Boolean.parseBoolean(getServletConfig().getInitParameter("isVirtualWebappRelative")); if (getServletConfig().getInitParameter("expires") != null) expires = Long.valueOf(getServletConfig().getInitParameter("expires")); buffered = Boolean.parseBoolean(getServletConfig().getInitParameter("buffered")); inputEncoding = getServletConfig().getInitParameter("inputEncoding"); if (getServletConfig().getInitParameter("outputEncoding") != null) outputEncoding = getServletConfig().getInitParameter("outputEncoding"); if (debug > 0) log("SSIServlet.init() SSI invoker started with 'debug'=" + debug); }	public void init(FilterConfig config) throws ServletException { this.config = config; if (config.getInitParameter("debug") != null) { debug = Integer.parseInt(config.getInitParameter("debug")); } if (config.getInitParameter("contentType") != null) { contentTypeRegEx = Pattern.compile(config.getInitParameter("contentType")); } else { contentTypeRegEx = shtmlRegEx; } isVirtualWebappRelative = Boolean.parseBoolean(config.getInitParameter("isVirtualWebappRelative")); if (config.getInitParameter("expires") != null) expires = Long.valueOf(config.getInitParameter("expires")); if (debug > 0) config.getServletContext().log("SSIFilter.init() SSI invoker started with 'debug'=" + debug); }
public String getString(final String key, final Object... args) { String value = getString(key); if (value == null) { value = key; } MessageFormat mf = new MessageFormat(value); mf.setLocale(locale); return mf.format(args, new StringBuffer(), null).toString(); }
public void setContentType(String ct) { if (ct != null && ct.startsWith("text/") && ct.indexOf("charset=") < 0) { // Use getCharacterEncoding() in case the charset has already super.setContentType(ct + ";charset=" + getCharacterEncoding()); } else { super.setContentType(ct); } }	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (response instanceof HttpServletResponse) { ResponseWrapper wrapped = new ResponseWrapper((HttpServletResponse) response); chain.doFilter(request, wrapped); } else { chain.doFilter(request, response); } }	public void init(FilterConfig filterConfig) throws ServletException { // NOOP }	public void init(FilterConfig filterConfig) throws ServletException { // NOOP }
public void writeToGZip(byte[] b, int off, int len) throws IOException { if (debug > 1) { System.out.println("writeToGZip, len = " + len); } if (debug > 2) { System.out.print("writeToGZip("); System.out.write(b, off, len); System.out.println(")"); } if (gzipstream == null) { if (debug > 1) { System.out.println("new GZIPOutputStream"); } if (response.isCommitted()) { if (debug > 1) System.out.print("Response already committed. Using original output stream"); gzipstream = output; } else { response.addHeader("Content-Encoding", "gzip"); gzipstream = new GZIPOutputStream(output); } } gzipstream.write(b, off, len); }
@Override protected void destroyInternal() throws LifecycleException { unregister(onameMapper); unregister(onameProtocolHandler); if (getService() != null) { getService().removeConnector(this); } super.destroyInternal(); }	@Override protected void initInternal() throws LifecycleException { super.initInternal(); adapter = new CoyoteAdapter(this); protocolHandler.setAdapter(adapter); IntrospectionUtils.setProperty(protocolHandler, "jkHome", System.getProperty("catalina.base")); onameProtocolHandler = register(protocolHandler, createObjectNameKeyProperties("ProtocolHandler")); mapperListener.setDomain(getDomain()); onameMapper = register(mapperListener, createObjectNameKeyProperties("Mapper")); }	@Override protected void startInternal() throws LifecycleException { setState(LifecycleState.STARTING); try { protocolHandler.init(); } catch (Exception e) { throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerInitializationFailed", e)); } try { protocolHandler.start(); } catch (Exception e) { String errPrefix = ""; if (this.service != null) { errPrefix += "service.getName(): \"" + this.service.getName() + "\"; "; } throw new LifecycleException(errPrefix + " " + sm.getString("coyoteConnector.protocolHandlerStartFailed", e)); } mapperListener.init(); }	@Override protected void stopInternal() throws LifecycleException { setState(LifecycleState.STOPPING); try { protocolHandler.destroy(); } catch (Exception e) { throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerDestroyFailed", e)); } mapperListener.destroy(); }
protected void contextConfig() { if (defaultContextXml == null && context instanceof StandardContext) { defaultContextXml = ((StandardContext) context).getDefaultContextXml(); } if (defaultContextXml == null) getDefaultContextXml(); if (!context.getOverride()) { File defaultContextFile = new File(getBaseDir(), defaultContextXml); if (defaultContextFile.exists()) { try { URL defaultContextUrl = defaultContextFile.toURI().toURL(); processContextConfig(defaultContextUrl); } catch (MalformedURLException e) { log.error(sm.getString("contextConfig.badUrl", defaultContextFile), e); } } File hostContextFile = new File(getConfigBase(), getHostConfigPath(Constants.HostContextXml)); if (hostContextFile.exists()) { try { URL hostContextUrl = hostContextFile.toURI().toURL(); processContextConfig(hostContextUrl); } catch (MalformedURLException e) { log.error(sm.getString("contextConfig.badUrl", hostContextFile), e); } } } if (context.getConfigFile() != null) processContextConfig(context.getConfigFile()); }
public void setContentLength(int length) { if (isCommitted()) return; if (included) return; if (usingWriter) return; coyoteResponse.setContentLength(length); }	public void setContentType(String type) { if (isCommitted()) return; if (included) return; if (usingWriter) { if (type != null) { int index = type.indexOf(";"); if (index != -1) { type = type.substring(0, index); } } } coyoteResponse.setContentType(type); if (type != null) { int index = type.indexOf(";"); if (index != -1) { int len = type.length(); index++; while (index < len && Character.isSpace(type.charAt(index))) { index++; } if (index + 7 < len && type.charAt(index) == 'c' && type.charAt(index + 1) == 'h' && type.charAt(index + 2) == 'a' && type.charAt(index + 3) == 'r' && type.charAt(index + 4) == 's' && type.charAt(index + 5) == 'e' && type.charAt(index + 6) == 't' && type.charAt(index + 7) == '=') { isCharacterEncodingSet = true; } } } }
public void removeChild(Container child) { if (child == null) { return; } synchronized (children) { if (children.get(child.getName()) == null) return; children.remove(child.getName()); } if (getState().isAvailable()) { try { if (child.getState().isAvailable()) { child.stop(); } } catch (LifecycleException e) { log.error("ContainerBase.removeChild: stop: ", e); } } fireContainerEvent(REMOVE_CHILD_EVENT, child); // child.setParent(null); }
private void registerContext(Context context) { String contextName = context.getName(); if ("/".equals(contextName)) { contextName = ""; } String hostName = context.getParent().getName(); javax.naming.Context resources = context.getResources(); String[] welcomeFiles = context.findWelcomeFiles(); mapper.addContext(hostName, contextName, context, welcomeFiles, resources); context.addContainerListener(this); for (Container container : context.findChildren()) { registerWrapper((Wrapper) container); } if (log.isDebugEnabled()) { log.debug(sm.getString("mapperListener.registerContext", contextName)); } }	private void registerHost(Host host) { String[] aliases = host.findAliases(); mapper.addHost(host.getName(), aliases, host.getObjectName()); host.addContainerListener(this); for (Container container : host.findChildren()) { registerContext((Context) container); } if (log.isDebugEnabled()) { log.debug(sm.getString("mapperListener.registerHost", host.getName(), domain)); } }	protected boolean postParseRequest(org.apache.coyote.Request req, Request request, org.apache.coyote.Response res, Response response) throws Exception { if (!req.scheme().isNull()) { request.setSecure(req.scheme().equals("https")); } else { // use connector scheme and secure configuration, (defaults to req.scheme().setString(connector.getScheme()); request.setSecure(connector.getSecure()); } // FIXME: the code below doesnt belongs to here, // this is only have sense // in Http11, not in ajp13.. // At this point the Host header has been processed. String proxyName = connector.getProxyName(); int proxyPort = connector.getProxyPort(); if (proxyPort != 0) { req.setServerPort(proxyPort); } if (proxyName != null) { req.serverName().setString(proxyName); } MessageBytes decodedURI = req.decodedURI(); decodedURI.duplicate(req.requestURI()); // Parse the path parameters. This will: // - strip out the path parameters parsePathParameters(req, request); try { req.getURLDecoder().convert(decodedURI, false); } catch (IOException ioe) { res.setStatus(400); res.setMessage("Invalid URI: " + ioe.getMessage()); connector.getService().getContainer().logAccess(request, response, 0, true); return false; } if (!normalize(req.decodedURI())) { res.setStatus(400); res.setMessage("Invalid URI"); connector.getService().getContainer().logAccess(request, response, 0, true); return false; } convertURI(decodedURI, request); if (!checkNormalize(req.decodedURI())) { res.setStatus(400); res.setMessage("Invalid URI character encoding"); connector.getService().getContainer().logAccess(request, response, 0, true); return false; } String principal = req.getRemoteUser().toString(); if (principal != null) { request.setUserPrincipal(new CoyotePrincipal(principal)); } String authtype = req.getAuthType().toString(); if (authtype != null) { request.setAuthType(authtype); } MessageBytes serverName; if (connector.getUseIPVHosts()) { serverName = req.localName(); if (serverName.isNull()) { res.action(ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE, null); } } else { serverName = req.serverName(); } if (request.isAsyncStarted()) { //TODO SERVLET3 - async request.getMappingData().recycle(); } connector.getMapper().map(serverName, decodedURI, request.getMappingData()); request.setContext((Context) request.getMappingData().context); request.setWrapper((Wrapper) request.getMappingData().wrapper); if (!connector.getAllowTrace() && req.method().equalsIgnoreCase("TRACE")) { Wrapper wrapper = request.getWrapper(); String header = null; if (wrapper != null) { String[] methods = wrapper.getServletMethods(); if (methods != null) { for (int i = 0; i < methods.length; i++) { if ("TRACE".equals(methods[i])) { continue; } if (header == null) { header = methods[i]; } else { header += ", " + methods[i]; } } } } res.setStatus(405); res.addHeader("Allow", header); res.setMessage("TRACE method is not allowed"); request.getContext().logAccess(request, response, 0, true); return false; } if (request.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.URL)) { String sessionID = request.getPathParameter(ApplicationSessionCookieConfig.getSessionUriParamName(request.getContext())); if (sessionID != null) { request.setRequestedSessionId(sessionID); request.setRequestedSessionURL(true); } } MessageBytes redirectPathMB = request.getMappingData().redirectPath; if (!redirectPathMB.isNull()) { String redirectPath = urlEncoder.encode(redirectPathMB.toString()); String query = request.getQueryString(); if (request.isRequestedSessionIdFromURL()) { // This is not optimal, but as this is not very common, it redirectPath = redirectPath + ";" + ApplicationSessionCookieConfig.getSessionUriParamName(request.getContext()) + "=" + request.getRequestedSessionId(); } if (query != null) { // This is not optimal, but as this is not very common, it redirectPath = redirectPath + "?" + query; } response.sendRedirect(redirectPath); request.getContext().logAccess(request, response, 0, true); return false; } parseSessionCookiesId(req, request); parseSessionSslId(request); return true; }	public Host getHost() { if (getContext() == null) return null; return (Host) getContext().getParent(); //return ((Host) mappingData.host); }	public void addContext(String hostName, String path, Object context, String[] welcomeResources, javax.naming.Context resources) { Host[] hosts = this.hosts; int pos = find(hosts, hostName); if (pos < 0) { addHost(hostName, new String[0], ""); hosts = this.hosts; pos = find(hosts, hostName); } if (pos < 0) { log.error("No host found: " + hostName); } Host host = hosts[pos]; if (host.name.equals(hostName)) { int slashCount = slashCount(path); synchronized (host) { Context[] contexts = host.contextList.contexts; if (slashCount > host.contextList.nesting) { host.contextList.nesting = slashCount; } Context[] newContexts = new Context[contexts.length + 1]; Context newContext = new Context(); newContext.name = path; newContext.object = context; newContext.welcomeResources = welcomeResources; newContext.resources = resources; if (insertMap(contexts, newContexts, newContext)) { host.contextList.contexts = newContexts; } } } }
public static Cookie createSessionCookie(Context context, String sessionId, boolean secure) { SessionCookieConfig scc = context.getServletContext().getSessionCookieConfig(); // NOTE: The priority order for session cookie configuration is: // 1. Context level configuration // 2. Values from SessionCookieConfig Cookie cookie = new Cookie(getSessionCookieName(context), sessionId); cookie.setMaxAge(scc.getMaxAge()); cookie.setComment(scc.getComment()); if (context.getSessionCookieDomain() == null) { if (scc.getDomain() != null) { cookie.setDomain(scc.getDomain()); } } else { cookie.setDomain(context.getSessionCookieDomain()); } if (scc.isSecure() || secure) { cookie.setSecure(true); } if (scc.isHttpOnly() || context.getUseHttpOnly()) { cookie.setHttpOnly(true); } String contextPath = context.getSessionCookiePath(); if (contextPath == null || contextPath.length() == 0) { contextPath = scc.getPath(); } if (contextPath == null || contextPath.length() == 0) { contextPath = context.getEncodedPath(); } cookie.setPath(contextPath); return cookie; }
@Override protected String getObjectNameKeyProperties() { StringBuilder keyProperties = new StringBuilder("j2eeType=WebModule,name="); String hostName = getParent().getName(); if (hostName == null) { keyProperties.append("DEFAULT"); } else { keyProperties.append(hostName); } String pathName = getName(); if ("".equals(pathName)) { keyProperties.append('/'); } else { keyProperties.append(pathName); } keyProperties.append(",J2EEApplication="); keyProperties.append(getJ2EEApplication()); keyProperties.append(",J2EEServer="); keyProperties.append(getJ2EEServer()); return keyProperties.toString(); }	public void setNamingResources(NamingResources namingResources) { NamingResources oldNamingResources = this.namingResources; this.namingResources = namingResources; namingResources.setContainer(this); support.firePropertyChange("namingResources", oldNamingResources, this.namingResources); unregister(onameNamingResoucres); onameNamingResoucres = register(namingResources, "type=NamingResources," + getObjectNameKeyProperties()); }
private String addNonce(String url) { if ((url == null) || (nonce == null)) return (url); String path = url; String query = ""; String anchor = ""; int question = url.indexOf('?'); if (question >= 0) { path = url.substring(0, question); query = url.substring(question); } int pound = path.indexOf('#'); if (pound >= 0) { anchor = path.substring(pound); path = path.substring(0, pound); } StringBuilder sb = new StringBuilder(path); sb.append(anchor); if (query.length() > 0) { sb.append(query); sb.append('&'); } else { sb.append('?'); } sb.append(Constants.CSRF_NONCE_REQUEST_PARAM); sb.append('='); sb.append(nonce); return (sb.toString()); }	protected Session getSessionForPathAndId(String path, String id) throws IOException { if ((path == null) || (!path.startsWith("/") && path.equals(""))) { throw new IllegalArgumentException(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); } String searchPath = path; if (path.equals("/")) searchPath = ""; Context context = (Context) host.findChild(searchPath); if (null == context) { throw new IllegalArgumentException(sm.getString("managerServlet.noContext", RequestUtil.filter(path))); } Session session = context.getManager().findSession(id); return session; }	protected void displaySessionDetailPage(HttpServletRequest req, HttpServletResponse resp, String path, String sessionId) throws ServletException, IOException { Session session = getSessionForPathAndId(path, sessionId); //strong>NOTE</strong> - This header will be overridden // automatically if a <code>RequestDispatcher.forward()</code> call is // ultimately invoked. resp.setHeader("Pragma", "No-cache"); resp.setHeader("Cache-Control", "no-cache,no-store,max-age=0"); resp.setDateHeader("Expires", 0); req.setAttribute("currentSession", session); getServletContext().getRequestDispatcher(sessionDetailJspPath).include(req, resp); }	protected Session[] getSessionsForPath(String path) { if ((path == null) || (!path.startsWith("/") && path.equals(""))) { throw new IllegalArgumentException(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); } String searchPath = path; if (path.equals("/")) searchPath = ""; Context context = (Context) host.findChild(searchPath); if (null == context) { throw new IllegalArgumentException(sm.getString("managerServlet.noContext", RequestUtil.filter(path))); } Session[] sessions = context.getManager().findSessions(); return sessions; }	protected Comparator<Session> getComparator(String sortBy) { Comparator<Session> comparator = null; if ("CreationTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(session.getCreationTime()); } }; } else if ("id".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { @Override public Comparable<String> getComparableObject(Session session) { return session.getId(); } }; } else if ("LastAccessedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(session.getLastAccessedTime()); } }; } else if ("MaxInactiveInterval".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(session.getMaxInactiveInterval()); } }; } else if ("new".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Boolean>() { @Override public Comparable<Boolean> getComparableObject(Session session) { return Boolean.valueOf(session.getSession().isNew()); } }; } else if ("locale".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { @Override public Comparable<String> getComparableObject(Session session) { return JspHelper.guessDisplayLocaleFromSession(session); } }; } else if ("user".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { @Override public Comparable<String> getComparableObject(Session session) { return JspHelper.guessDisplayUserFromSession(session); } }; } else if ("UsedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getUsedTimeForSession(session)); } }; } else if ("InactiveTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getInactiveTimeForSession(session)); } }; } else if ("TTL".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getTTLForSession(session)); } }; } return comparator; }	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { ServletResponse wResponse = null; if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; boolean skipNonceCheck = false; if (Constants.METHOD_GET.equals(req.getMethod())) { String path = req.getServletPath(); if (req.getPathInfo() != null) { path = path + req.getPathInfo(); } if (entryPoints.contains(path)) { skipNonceCheck = true; } } if (!skipNonceCheck) { String previousNonce = req.getParameter(Constants.CSRF_NONCE_REQUEST_PARAM); String expectedNonce = (String) req.getSession(true).getAttribute(Constants.CSRF_NONCE_SESSION_ATTR_NAME); if (expectedNonce != null && !expectedNonce.equals(previousNonce)) { res.sendError(HttpServletResponse.SC_FORBIDDEN); return; } } String newNonce = generateNonce(); req.getSession(true).setAttribute(Constants.CSRF_NONCE_SESSION_ATTR_NAME, newNonce); wResponse = new CsrfResponseWrapper(res, newNonce); } else { wResponse = response; } chain.doFilter(request, wResponse); }	@Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { // Identify the request parameters that we need // By obtaining the command from the pathInfo, per-command security can String command = request.getPathInfo(); String path = request.getParameter("path"); String deployPath = request.getParameter("deployPath"); String deployConfig = request.getParameter("deployConfig"); String deployWar = request.getParameter("deployWar"); String requestNonce = request.getParameter(NONCE_REQUEST); response.setContentType("text/html; charset=" + Constants.CHARSET); String message = ""; // Check nonce HttpSession session = request.getSession(); String sessionNonce = (String) session.getAttribute(NONCE_SESSION); if (sessionNonce == null) { message = sm.getString("htmlManagerServlet.noNonce", command); command = null; } else { if (!sessionNonce.equals(requestNonce)) { message = sm.getString("htmlManagerServlet.nonceMismatch", command); command = null; } } if (command == null || command.length() == 0) { // No command == list // List always displayed -> do nothing } else if (command.equals("/upload")) { message = upload(request); } else if (command.equals("/deploy")) { message = deployInternal(deployConfig, deployPath, deployWar); } else if (command.equals("/reload")) { message = reload(path); } else if (command.equals("/undeploy")) { message = undeploy(path); } else if (command.equals("/expire")) { message = expireSessions(path, request); } else if (command.equals("/start")) { message = start(path); } else if (command.equals("/stop")) { message = stop(path); } else if (command.equals("/findleaks")) { message = findleaks(); } else { doGet(request, response); return; } list(request, response, message); }	public void list(HttpServletRequest request, HttpServletResponse response, String message) throws IOException { if (debug >= 1) log("list: Listing contexts for virtual host '" + host.getName() + "'"); String newNonce = generateNonce(); request.getSession().setAttribute(NONCE_SESSION, newNonce); PrintWriter writer = response.getWriter(); writer.print(Constants.HTML_HEADER_SECTION); Object[] args = new Object[2]; args[0] = request.getContextPath(); args[1] = sm.getString("htmlManagerServlet.title"); writer.print(MessageFormat.format(Constants.BODY_HEADER_SECTION, args)); args = new Object[3]; args[0] = sm.getString("htmlManagerServlet.messageLabel"); if (message == null || message.length() == 0) { args[1] = "OK"; } else { args[1] = RequestUtil.filter(message); } writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args)); args = new Object[9]; args[0] = sm.getString("htmlManagerServlet.manager"); args[1] = response.encodeURL(request.getContextPath() + "/html/list"); args[2] = sm.getString("htmlManagerServlet.list"); args[3] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpHtmlManagerFile")); args[4] = sm.getString("htmlManagerServlet.helpHtmlManager"); args[5] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpManagerFile")); args[6] = sm.getString("htmlManagerServlet.helpManager"); args[7] = response.encodeURL(request.getContextPath() + "/status"); args[8] = sm.getString("statusServlet.title"); writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args)); args = new Object[6]; args[0] = sm.getString("htmlManagerServlet.appsTitle"); args[1] = sm.getString("htmlManagerServlet.appsPath"); args[2] = sm.getString("htmlManagerServlet.appsName"); args[3] = sm.getString("htmlManagerServlet.appsAvailable"); args[4] = sm.getString("htmlManagerServlet.appsSessions"); args[5] = sm.getString("htmlManagerServlet.appsTasks"); writer.print(MessageFormat.format(APPS_HEADER_SECTION, args)); // Apps Row Section Container[] children = host.findChildren(); String[] contextPaths = new String[children.length]; for (int i = 0; i < children.length; i++) contextPaths[i] = children[i].getName(); TreeMap<String, String> sortedContextPathsMap = new TreeMap<String, String>(); for (int i = 0; i < contextPaths.length; i++) { String displayPath = contextPaths[i]; sortedContextPathsMap.put(displayPath, contextPaths[i]); } String appsStart = sm.getString("htmlManagerServlet.appsStart"); String appsStop = sm.getString("htmlManagerServlet.appsStop"); String appsReload = sm.getString("htmlManagerServlet.appsReload"); String appsUndeploy = sm.getString("htmlManagerServlet.appsUndeploy"); String appsExpire = sm.getString("htmlManagerServlet.appsExpire"); Iterator<Map.Entry<String, String>> iterator = sortedContextPathsMap.entrySet().iterator(); boolean isHighlighted = true; boolean isDeployed = true; String highlightColor = null; while (iterator.hasNext()) { isHighlighted = !isHighlighted; if (isHighlighted) { highlightColor = "#C3F3C3"; } else { highlightColor = "#FFFFFF"; } Map.Entry<String, String> entry = iterator.next(); String displayPath = entry.getKey(); String contextPath = entry.getValue(); Context context = (Context) host.findChild(contextPath); if (displayPath.equals("")) { displayPath = "/"; } if (context != null) { try { isDeployed = isDeployed(contextPath); } catch (Exception e) { isDeployed = false; } args = new Object[7]; args[0] = URL_ENCODER.encode(displayPath); args[1] = displayPath; args[2] = context.getDisplayName(); if (args[2] == null) { args[2] = "&nbsp;"; } args[3] = new Boolean(context.getAvailable()); args[4] = response.encodeURL(request.getContextPath() + "/html/sessions?path=" + URL_ENCODER.encode(displayPath)); if (context.getManager() != null) { args[5] = new Integer(context.getManager().getActiveSessions()); } else { args[5] = new Integer(0); } args[6] = highlightColor; writer.print(MessageFormat.format(APPS_ROW_DETAILS_SECTION, args)); args = new Object[15]; args[0] = response.encodeURL(request.getContextPath() + "/html/start?path=" + URL_ENCODER.encode(displayPath)); args[1] = appsStart; args[2] = response.encodeURL(request.getContextPath() + "/html/stop?path=" + URL_ENCODER.encode(displayPath)); args[3] = appsStop; args[4] = response.encodeURL(request.getContextPath() + "/html/reload?path=" + URL_ENCODER.encode(displayPath)); args[5] = appsReload; args[6] = response.encodeURL(request.getContextPath() + "/html/undeploy?path=" + URL_ENCODER.encode(displayPath)); args[7] = appsUndeploy; args[8] = response.encodeURL(request.getContextPath() + "/html/expire?path=" + URL_ENCODER.encode(displayPath)); args[9] = appsExpire; args[10] = sm.getString("htmlManagerServlet.expire.explain"); Manager manager = context.getManager(); if (manager == null) { args[11] = sm.getString("htmlManagerServlet.noManager"); } else { args[11] = new Integer(context.getManager().getMaxInactiveInterval() / 60); } args[12] = sm.getString("htmlManagerServlet.expire.unit"); args[13] = highlightColor; args[14] = newNonce; if (context.getPath().equals(this.context.getPath())) { writer.print(MessageFormat.format(MANAGER_APP_ROW_BUTTON_SECTION, args)); } else if (context.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STARTED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (context.getAvailable() && !isDeployed) { writer.print(MessageFormat.format(STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (!context.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STOPPED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else { writer.print(MessageFormat.format(STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } } } args = new Object[8]; args[0] = sm.getString("htmlManagerServlet.deployTitle"); args[1] = sm.getString("htmlManagerServlet.deployServer"); args[2] = response.encodeURL(request.getContextPath() + "/html/deploy"); args[3] = sm.getString("htmlManagerServlet.deployPath"); args[4] = sm.getString("htmlManagerServlet.deployConfig"); args[5] = sm.getString("htmlManagerServlet.deployWar"); args[6] = sm.getString("htmlManagerServlet.deployButton"); args[7] = newNonce; writer.print(MessageFormat.format(DEPLOY_SECTION, args)); args = new Object[5]; args[0] = sm.getString("htmlManagerServlet.deployUpload"); args[1] = response.encodeURL(request.getContextPath() + "/html/upload"); args[2] = sm.getString("htmlManagerServlet.deployUploadFile"); args[3] = sm.getString("htmlManagerServlet.deployButton"); args[4] = newNonce; writer.print(MessageFormat.format(UPLOAD_SECTION, args)); args = new Object[6]; args[0] = sm.getString("htmlManagerServlet.diagnosticsTitle"); args[1] = sm.getString("htmlManagerServlet.diagnosticsLeak"); args[2] = response.encodeURL(request.getContextPath() + "/html/findleaks"); args[3] = newNonce; args[4] = sm.getString("htmlManagerServlet.diagnosticsLeakWarning"); args[5] = sm.getString("htmlManagerServlet.diagnosticsLeakButton"); writer.print(MessageFormat.format(DIAGNOSTICS_SECTION, args)); args = new Object[7]; args[0] = sm.getString("htmlManagerServlet.serverTitle"); args[1] = sm.getString("htmlManagerServlet.serverVersion"); args[2] = sm.getString("htmlManagerServlet.serverJVMVersion"); args[3] = sm.getString("htmlManagerServlet.serverJVMVendor"); args[4] = sm.getString("htmlManagerServlet.serverOSName"); args[5] = sm.getString("htmlManagerServlet.serverOSVersion"); args[6] = sm.getString("htmlManagerServlet.serverOSArch"); writer.print(MessageFormat.format(Constants.SERVER_HEADER_SECTION, args)); args = new Object[6]; args[0] = ServerInfo.getServerInfo(); args[1] = System.getProperty("java.runtime.version"); args[2] = System.getProperty("java.vm.vendor"); args[3] = System.getProperty("os.name"); args[4] = System.getProperty("os.version"); args[5] = System.getProperty("os.arch"); writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args)); writer.print(Constants.HTML_TAIL_SECTION); writer.flush(); writer.close(); }
protected static boolean matchesOne(String str, Pattern... patterns) { for (Pattern pattern : patterns) { if (pattern.matcher(str).matches()) { return true; } } return false; }	public String getProxiesHeader() { return proxiesHeader; }	public void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { if (matchesOne(request.getRemoteAddr(), internalProxies)) { String remoteIp = null; LinkedList<String> proxiesHeaderValue = new LinkedList<String>(); String[] remoteIPHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIPHeader)); int idx; for (idx = remoteIPHeaderValue.length - 1; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; remoteIp = currentRemoteIp; if (matchesOne(currentRemoteIp, internalProxies)) { // do nothing, internalProxies IPs are not appended to the } else if (matchesOne(currentRemoteIp, trustedProxies)) { proxiesHeaderValue.addFirst(currentRemoteIp); } else { idx--; break; } } LinkedList<String> newRemoteIpHeaderValue = new LinkedList<String>(); for (; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; newRemoteIpHeaderValue.addFirst(currentRemoteIp); } XForwardedRequest xRequest = new XForwardedRequest(request); if (remoteIp != null) { xRequest.setRemoteAddr(remoteIp); xRequest.setRemoteHost(remoteIp); if (proxiesHeaderValue.size() == 0) { xRequest.removeHeader(proxiesHeader); } else { String commaDelimitedListOfProxies = listToCommaDelimitedString(proxiesHeaderValue); xRequest.setHeader(proxiesHeader, commaDelimitedListOfProxies); } if (newRemoteIpHeaderValue.size() == 0) { xRequest.removeHeader(remoteIPHeader); } else { String commaDelimitedRemoteIpHeaderValue = listToCommaDelimitedString(newRemoteIpHeaderValue); xRequest.setHeader(remoteIPHeader, commaDelimitedRemoteIpHeaderValue); } } if (protocolHeader != null) { String protocolHeaderValue = request.getHeader(protocolHeader); if (protocolHeaderValue == null) { // don't modify the secure,scheme and serverPort attributes of the request } else if (protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) { xRequest.setSecure(true); xRequest.setScheme("https"); xRequest.setServerPort(httpsServerPort); } else { xRequest.setSecure(false); xRequest.setScheme("http"); xRequest.setServerPort(httpServerPort); } } if (log.isDebugEnabled()) { log.debug("Incoming request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "', originalRemoteHost='" + request.getRemoteHost() + "', originalSecure='" + request.isSecure() + "', originalScheme='" + request.getScheme() + "', original[" + remoteIPHeader + "]='" + request.getHeader(remoteIPHeader) + ", original[" + protocolHeader + "]='" + (protocolHeader == null ? null : request.getHeader(protocolHeader)) + "' will be seen as newRemoteAddr='" + xRequest.getRemoteAddr() + "', newRemoteHost='" + xRequest.getRemoteHost() + "', newScheme='" + xRequest.getScheme() + "', newSecure='" + xRequest.isSecure() + "', new[" + remoteIPHeader + "]='" + xRequest.getHeader(remoteIPHeader) + ", new[" + proxiesHeader + "]='" + xRequest.getHeader(proxiesHeader) + "'"); } chain.doFilter(xRequest, response); } else { if (log.isDebugEnabled()) { log.debug("Skip RemoteIpFilter for request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "'"); } chain.doFilter(request, response); } }	public void init(FilterConfig filterConfig) throws ServletException { if (filterConfig.getInitParameter(INTERNAL_PROXIES_PARAMETER) != null) { setInternalProxies(filterConfig.getInitParameter(INTERNAL_PROXIES_PARAMETER)); } if (filterConfig.getInitParameter(PROTOCOL_HEADER_PARAMETER) != null) { setProtocolHeader(filterConfig.getInitParameter(PROTOCOL_HEADER_PARAMETER)); } if (filterConfig.getInitParameter(PROTOCOL_HEADER_HTTPS_VALUE_PARAMETER) != null) { setProtocolHeaderHttpsValue(filterConfig.getInitParameter(PROTOCOL_HEADER_HTTPS_VALUE_PARAMETER)); } if (filterConfig.getInitParameter(PROXIES_HEADER_PARAMETER) != null) { setProxiesHeader(filterConfig.getInitParameter(PROXIES_HEADER_PARAMETER)); } if (filterConfig.getInitParameter(REMOTE_IP_HEADER_PARAMETER) != null) { setRemoteIPHeader(filterConfig.getInitParameter(REMOTE_IP_HEADER_PARAMETER)); } if (filterConfig.getInitParameter(TRUSTED_PROXIES_PARAMETER) != null) { setTrustedProxies(filterConfig.getInitParameter(TRUSTED_PROXIES_PARAMETER)); } if (filterConfig.getInitParameter(HTTP_SERVER_PORT_PARAMETER) != null) { try { setHttpServerPort(Integer.parseInt(filterConfig.getInitParameter(HTTP_SERVER_PORT_PARAMETER))); } catch (NumberFormatException e) { throw new NumberFormatException("Illegal " + HTTP_SERVER_PORT_PARAMETER + " : " + e.getMessage()); } } if (filterConfig.getInitParameter(HTTPS_SERVER_PORT_PARAMETER) != null) { try { setHttpsServerPort(Integer.parseInt(filterConfig.getInitParameter(HTTPS_SERVER_PORT_PARAMETER))); } catch (NumberFormatException e) { throw new NumberFormatException("Illegal " + HTTPS_SERVER_PORT_PARAMETER + " : " + e.getMessage()); } } }	@Override public void invoke(Request request, Response response) throws IOException, ServletException { final String originalRemoteAddr = request.getRemoteAddr(); final String originalRemoteHost = request.getRemoteHost(); final String originalScheme = request.getScheme(); final boolean originalSecure = request.isSecure(); final int originalServerPort = request.getServerPort(); if (matchesOne(originalRemoteAddr, internalProxies)) { String remoteIp = null; LinkedList<String> proxiesHeaderValue = new LinkedList<String>(); String[] remoteIPHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIpHeader)); int idx; for (idx = remoteIPHeaderValue.length - 1; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; remoteIp = currentRemoteIp; if (matchesOne(currentRemoteIp, internalProxies)) { // do nothing, internalProxies IPs are not appended to the } else if (matchesOne(currentRemoteIp, trustedProxies)) { proxiesHeaderValue.addFirst(currentRemoteIp); } else { idx--; break; } } LinkedList<String> newRemoteIpHeaderValue = new LinkedList<String>(); for (; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; newRemoteIpHeaderValue.addFirst(currentRemoteIp); } if (remoteIp != null) { request.setRemoteAddr(remoteIp); request.setRemoteHost(remoteIp); if (proxiesHeaderValue.size() == 0) { request.getCoyoteRequest().getMimeHeaders().removeHeader(proxiesHeader); } else { String commaDelimitedListOfProxies = listToCommaDelimitedString(proxiesHeaderValue); request.getCoyoteRequest().getMimeHeaders().setValue(proxiesHeader).setString(commaDelimitedListOfProxies); } if (newRemoteIpHeaderValue.size() == 0) { request.getCoyoteRequest().getMimeHeaders().removeHeader(remoteIpHeader); } else { String commaDelimitedRemoteIpHeaderValue = listToCommaDelimitedString(newRemoteIpHeaderValue); request.getCoyoteRequest().getMimeHeaders().setValue(remoteIpHeader).setString(commaDelimitedRemoteIpHeaderValue); } } if (protocolHeader != null) { String protocolHeaderValue = request.getHeader(protocolHeader); if (protocolHeaderValue == null) { // don't modify the secure,scheme and serverPort attributes // of the request } else if (protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) { request.setSecure(true); request.getCoyoteRequest().scheme().setString("https"); request.setServerPort(httpsServerPort); } else { request.setSecure(false); request.getCoyoteRequest().scheme().setString("http"); request.setServerPort(httpServerPort); } } if (log.isDebugEnabled()) { log.debug("Incoming request " + request.getRequestURI() + " with originalRemoteAddr '" + originalRemoteAddr + "', originalRemoteHost='" + originalRemoteHost + "', originalSecure='" + originalSecure + "', originalScheme='" + originalScheme + "' will be seen as newRemoteAddr='" + request.getRemoteAddr() + "', newRemoteHost='" + request.getRemoteHost() + "', newScheme='" + request.getScheme() + "', newSecure='" + request.isSecure() + "'"); } } else { if (log.isDebugEnabled()) { log.debug("Skip RemoteIpValve for request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "'"); } } try { getNext().invoke(request, response); } finally { request.setRemoteAddr(originalRemoteAddr); request.setRemoteHost(originalRemoteHost); request.setSecure(originalSecure); request.getCoyoteRequest().scheme().setString(originalScheme); request.setServerPort(originalServerPort); } }	public void setProxiesHeader(String proxiesHeader) { this.proxiesHeader = proxiesHeader; }	public void setRemoteIPHeader(String remoteIPHeader) { this.remoteIPHeader = remoteIPHeader; }	protected static String[] commaDelimitedListToStringArray(String commaDelimitedStrings) { return (commaDelimitedStrings == null || commaDelimitedStrings.length() == 0) ? new String[0] : commaSeparatedValuesPattern.split(commaDelimitedStrings); }
protected DeltaSession getNewDeltaSession() { return new DeltaSession(this); }	protected void handleGET_ALL_SESSIONS(SessionMessage msg, Member sender) throws IOException { counterReceive_EVT_GET_ALL_SESSIONS++; if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.unloadingBegin", getName())); // Write the number of active sessions, followed by the details Session[] currentSessions = findSessions(); long findSessionTimestamp = System.currentTimeMillis(); if (isSendAllSessions()) { sendSessions(sender, currentSessions, findSessionTimestamp); } else { for (int i = 0; i < currentSessions.length; i += getSendAllSessionsSize()) { int len = i + getSendAllSessionsSize() > currentSessions.length ? currentSessions.length - i : getSendAllSessionsSize(); Session[] sendSessions = new Session[len]; System.arraycopy(currentSessions, i, sendSessions, 0, len); sendSessions(sender, sendSessions, findSessionTimestamp); if (getSendAllSessionsWaitTime() > 0) { try { Thread.sleep(getSendAllSessionsWaitTime()); } catch (Exception sleep) { } } //end if } //for } SessionMessage newmsg = new SessionMessageImpl(name, SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE, null, "SESSION-STATE-TRANSFERED", "SESSION-STATE-TRANSFERED" + getName()); newmsg.setTimestamp(findSessionTimestamp); if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.allSessionTransfered", getName())); counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE++; cluster.send(newmsg, sender); }	protected void messageReceived(SessionMessage msg, Member sender) { if (doDomainReplication() && !checkSenderDomain(msg, sender)) { return; } ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); try { ClassLoader[] loaders = getClassLoaders(); if (loaders != null && loaders.length > 0) Thread.currentThread().setContextClassLoader(loaders[0]); if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.eventType", getName(), msg.getEventTypeString(), sender)); switch(msg.getEventType()) { case SessionMessage.EVT_GET_ALL_SESSIONS: { handleGET_ALL_SESSIONS(msg, sender); break; } case SessionMessage.EVT_ALL_SESSION_DATA: { handleALL_SESSION_DATA(msg, sender); break; } case SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE: { handleALL_SESSION_TRANSFERCOMPLETE(msg, sender); break; } case SessionMessage.EVT_SESSION_CREATED: { handleSESSION_CREATED(msg, sender); break; } case SessionMessage.EVT_SESSION_EXPIRED: { handleSESSION_EXPIRED(msg, sender); break; } case SessionMessage.EVT_SESSION_ACCESSED: { handleSESSION_ACCESSED(msg, sender); break; } case SessionMessage.EVT_SESSION_DELTA: { handleSESSION_DELTA(msg, sender); break; } default: { break; } } //switch } catch (Exception x) { log.error(sm.getString("deltaManager.receiveMessage.error", getName()), x); } finally { Thread.currentThread().setContextClassLoader(contextLoader); } }	public String getEventTypeString() { switch(mEvtType) { case EVT_SESSION_CREATED: return "SESSION-MODIFIED"; case EVT_SESSION_EXPIRED: return "SESSION-EXPIRED"; case EVT_SESSION_ACCESSED: return "SESSION-ACCESSED"; case EVT_GET_ALL_SESSIONS: return "SESSION-GET-ALL"; case EVT_SESSION_DELTA: return "SESSION-DELTA"; case EVT_ALL_SESSION_DATA: return "ALL-SESSION-DATA"; case EVT_ALL_SESSION_TRANSFERCOMPLETE: return "SESSION-STATE-TRANSFERED"; default: return "UNKNOWN-EVENT-TYPE"; } }	public int getCounterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE() { return counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE; }	public int getCounterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE() { return counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE; }	public synchronized void resetStatistics() { processingTime = 0; expiredSessions = 0; rejectedSessions = 0; sessionReplaceCounter = 0; counterNoStateTransfered = 0; setMaxActive(getActiveSessions()); sessionCounter = getActiveSessions(); counterReceive_EVT_ALL_SESSION_DATA = 0; counterReceive_EVT_GET_ALL_SESSIONS = 0; counterReceive_EVT_SESSION_ACCESSED = 0; counterReceive_EVT_SESSION_CREATED = 0; counterReceive_EVT_SESSION_DELTA = 0; counterReceive_EVT_SESSION_EXPIRED = 0; counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0; counterSend_EVT_ALL_SESSION_DATA = 0; counterSend_EVT_GET_ALL_SESSIONS = 0; counterSend_EVT_SESSION_ACCESSED = 0; counterSend_EVT_SESSION_CREATED = 0; counterSend_EVT_SESSION_DELTA = 0; counterSend_EVT_SESSION_EXPIRED = 0; counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0; }	public void messageDataReceived(ClusterMessage cmsg) { if (cmsg != null && cmsg instanceof SessionMessage) { SessionMessage msg = (SessionMessage) cmsg; switch(msg.getEventType()) { case SessionMessage.EVT_GET_ALL_SESSIONS: case SessionMessage.EVT_SESSION_CREATED: case SessionMessage.EVT_SESSION_EXPIRED: case SessionMessage.EVT_SESSION_ACCESSED: case SessionMessage.EVT_SESSION_DELTA: { synchronized (receivedMessageQueue) { if (receiverQueue) { receivedMessageQueue.add(msg); return; } } break; } default: { break; } } messageReceived(msg, msg.getAddress() != null ? (Member) msg.getAddress() : null); } }

@SuppressWarnings("deprecation") private void clearReferencesThreads() { Thread[] threads = getThreads(); for (Thread thread : threads) { if (thread != null) { ClassLoader ccl = thread.getContextClassLoader(); if (ccl != null && ccl == this) { if (thread == Thread.currentThread()) { continue; } if (!thread.isAlive()) { continue; } ThreadGroup tg = thread.getThreadGroup(); if (tg != null && JVM_THREAD_GROUP_NAMES.contains(tg.getName())) { continue; } if (thread.getClass().getName().equals("java.util.TimerThread")) { clearReferencesStopTimerThread(thread); continue; } log.error(sm.getString("webappClassLoader.warnThread", contextName, thread.getName())); if (!clearReferencesStopThreads) { continue; } try { Field targetField = thread.getClass().getDeclaredField("target"); targetField.setAccessible(true); Object target = targetField.get(thread); if (target != null && target.getClass().getCanonicalName().equals("java.util.concurrent.ThreadPoolExecutor.Worker")) { Field executorField = target.getClass().getDeclaredField("this$0"); executorField.setAccessible(true); Object executor = executorField.get(target); if (executor instanceof ThreadPoolExecutor) { ((ThreadPoolExecutor) executor).shutdownNow(); } } } catch (SecurityException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } catch (NoSuchFieldException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } catch (IllegalArgumentException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } catch (IllegalAccessException e) { log.warn(sm.getString("webappClassLoader.stopThreadFail", thread.getName(), contextName), e); } // This method is deprecated and for good reason. This is // very risky code but is the only option at this point. // A *very* good reason for apps to do this clean-up thread.stop(); } } } }	@Override protected void startInternal() throws LifecycleException { if (log.isDebugEnabled()) log.debug(sm.getString("webappLoader.starting")); if (container.getResources() == null) { log.info("No resources for " + container); setState(LifecycleState.STARTING); return; } URLStreamHandlerFactory streamHandlerFactory = new DirContextURLStreamHandlerFactory(); if (first) { first = false; try { URL.setURLStreamHandlerFactory(streamHandlerFactory); } catch (Exception e) { log.error("Error registering jndi stream handler", e); } catch (Throwable t) { log.info("Dual registration of jndi stream handler: " + t.getMessage()); } } try { classLoader = createClassLoader(); classLoader.setResources(container.getResources()); classLoader.setDelegate(this.delegate); classLoader.setSearchExternalFirst(searchExternalFirst); if (container instanceof StandardContext) { classLoader.setAntiJARLocking(((StandardContext) container).getAntiJARLocking()); classLoader.setClearReferencesStatic(((StandardContext) container).getClearReferencesStatic()); classLoader.setClearReferencesStopThreads(((StandardContext) container).getClearReferencesStopThreads()); classLoader.setClearReferencesThreadLocals(((StandardContext) container).getClearReferencesThreadLocals()); } for (int i = 0; i < repositories.length; i++) { classLoader.addRepository(repositories[i]); } setRepositories(); setClassPath(); setPermissions(); ((Lifecycle) classLoader).start(); DirContextURLStreamHandler.bind(classLoader, this.container.getResources()); StandardContext ctx = (StandardContext) container; String path = ctx.getPath(); if (path.equals("")) { path = "/"; } ObjectName cloname = new ObjectName(MBeanUtils.getDomain(ctx) + ":type=WebappClassLoader,path=" + path + ",host=" + ctx.getParent().getName()); Registry.getRegistry(null, null).registerComponent(classLoader, cloname, null); } catch (Throwable t) { log.error("LifecycleException ", t); throw new LifecycleException("start: ", t); } setState(LifecycleState.STARTING); }	public boolean getClearReferencesLogFactoryRelease() { return (this.clearReferencesLogFactoryRelease); }	public void setClearReferencesStopThreads(boolean clearReferencesStopThreads) { boolean oldClearReferencesStopThreads = this.clearReferencesStopThreads; this.clearReferencesStopThreads = clearReferencesStopThreads; support.firePropertyChange("clearReferencesStopThreads", oldClearReferencesStopThreads, this.clearReferencesStopThreads); }	public void setClearReferencesStopThreads(boolean clearReferencesStopThreads) { this.clearReferencesStopThreads = clearReferencesStopThreads; }	public void setClearReferencesThreadLocals(boolean clearReferencesThreadLocals) { this.clearReferencesThreadLocals = clearReferencesThreadLocals; }
@Override protected synchronized void stopInternal() throws LifecycleException { if (log.isDebugEnabled()) log.debug("Stopping"); setState(LifecycleState.STOPPING); if (sessions instanceof LazyReplicatedMap) { LazyReplicatedMap map = (LazyReplicatedMap) sessions; map.breakdown(); } cluster.removeManager(this); this.random = null; setState(LifecycleState.MUST_DESTROY); }	@Override protected synchronized void stopInternal() throws LifecycleException { if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.stopped", getName())); setState(LifecycleState.STOPPING); if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.expireSessions", getName())); Session[] sessions = findSessions(); for (int i = 0; i < sessions.length; i++) { DeltaSession session = (DeltaSession) sessions[i]; if (!session.isValid()) continue; try { session.expire(true, isExpireSessionsOnShutdown()); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } this.random = null; getCluster().removeManager(this); replicationValve = null; setState(LifecycleState.MUST_DESTROY); }	@Override protected synchronized void stopInternal() throws LifecycleException { if (log.isDebugEnabled()) log.debug("Stopping"); setState(LifecycleState.STOPPING); if (getStore() != null && saveOnRestart) { unload(); } else { Session[] sessions = findSessions(); for (int i = 0; i < sessions.length; i++) { StandardSession session = (StandardSession) sessions[i]; if (!session.isValid()) continue; session.expire(); } } if (getStore() != null && getStore() instanceof Lifecycle) ((Lifecycle) getStore()).stop(); this.random = null; setState(LifecycleState.MUST_DESTROY); }
private void unregisterContext(Context context) { if (context.getPaused()) { return; } removeListeners(context); String contextName = context.getName(); if ("/".equals(contextName)) { contextName = ""; } String hostName = context.getParent().getName(); if (log.isDebugEnabled()) log.debug(sm.getString("mapperListener.unregisterContext", contextName)); mapper.removeContext(hostName, contextName); }	private void unregisterHost(Host host) { removeListeners(host); String hostname = host.getName(); mapper.removeHost(hostname); if (log.isDebugEnabled()) log.debug(sm.getString("mapperListener.unregisterHost", hostname, domain)); }	private void unregisterWrapper(Wrapper wrapper) { removeListeners(wrapper); String contextName = wrapper.getParent().getName(); if ("/".equals(contextName)) { contextName = ""; } String hostName = wrapper.getParent().getParent().getName(); String[] mappings = wrapper.findMappings(); for (String mapping : mappings) { mapper.removeWrapper(hostName, contextName, mapping); } }	public void containerEvent(ContainerEvent event) { if (event.getType() == Container.ADD_CHILD_EVENT) { Container child = (Container) event.getData(); child.addLifecycleListener(this); if (child instanceof Host) { registerHost((Host) child); } else if (child instanceof Context) { registerContext((Context) child); } else if (child instanceof Wrapper) { registerWrapper((Wrapper) child); } } else if (event.getType() == Container.REMOVE_CHILD_EVENT) { Container child = (Container) event.getData(); child.removeLifecycleListener(this); if (child instanceof Host) { unregisterHost((Host) child); } else if (child instanceof Context) { unregisterContext((Context) child); } else if (child instanceof Wrapper) { unregisterWrapper((Wrapper) child); } } else if (event.getType() == Host.ADD_ALIAS_EVENT) { mapper.addHostAlias(((Host) event.getSource()).getName(), event.getData().toString()); } else if (event.getType() == Host.REMOVE_ALIAS_EVENT) { mapper.removeHostAlias(event.getData().toString()); } else if (event.getType() == Wrapper.ADD_MAPPING_EVENT) { Wrapper wrapper = (Wrapper) event.getSource(); String contextName = wrapper.getParent().getName(); if ("/".equals(contextName)) { contextName = ""; } String hostName = wrapper.getParent().getParent().getName(); String mapping = (String) event.getData(); boolean jspWildCard = ("jsp".equals(wrapper.getName()) && mapping.endsWith("/*")); mapper.addWrapper(hostName, contextName, mapping, wrapper, jspWildCard); } else if (event.getType() == Wrapper.REMOVE_MAPPING_EVENT) { Wrapper wrapper = (Wrapper) event.getSource(); String contextName = wrapper.getParent().getName(); if ("/".equals(contextName)) { contextName = ""; } String hostName = wrapper.getParent().getParent().getName(); String mapping = (String) event.getData(); mapper.removeWrapper(hostName, contextName, mapping); } else if (event.getType() == Context.ADD_WELCOME_FILE_EVENT) { Context context = (Context) event.getSource(); String hostName = context.getParent().getName(); String contextName = context.getName(); if ("/".equals(contextName)) { contextName = ""; } String welcomeFile = (String) event.getData(); mapper.addWelcomeFile(hostName, contextName, welcomeFile); } else if (event.getType() == Context.REMOVE_WELCOME_FILE_EVENT) { Context context = (Context) event.getSource(); String hostName = context.getParent().getName(); String contextName = context.getName(); if ("/".equals(contextName)) { contextName = ""; } String welcomeFile = (String) event.getData(); mapper.removeWelcomeFile(hostName, contextName, welcomeFile); } else if (event.getType() == Context.CLEAR_WELCOME_FILES_EVENT) { Context context = (Context) event.getSource(); String hostName = context.getParent().getName(); String contextName = context.getName(); if ("/".equals(contextName)) { contextName = ""; } mapper.clearWelcomeFiles(hostName, contextName); } }
boolean doIsEncodeable(Request hreq, Session session, String location) { URL url = null; try { url = new URL(location); } catch (MalformedURLException e) { return (false); } if (!hreq.getScheme().equalsIgnoreCase(url.getProtocol())) return (false); if (!hreq.getServerName().equalsIgnoreCase(url.getHost())) return (false); int serverPort = hreq.getServerPort(); if (serverPort == -1) { if ("https".equals(hreq.getScheme())) serverPort = 443; else serverPort = 80; } int urlPort = url.getPort(); if (urlPort == -1) { if ("https".equals(url.getProtocol())) urlPort = 443; else urlPort = 80; } if (serverPort != urlPort) return (false); String contextPath = getContext().getPath(); if (contextPath != null) { String file = url.getFile(); if ((file == null) || !file.startsWith(contextPath)) return (false); String tok = ";" + Globals.SESSION_PARAMETER_NAME + "=" + session.getIdInternal(); if (file.indexOf(tok, contextPath.length()) >= 0) return (false); } return (true); }	protected String toEncoded(String url, String sessionId) { if ((url == null) || (sessionId == null)) return (url); String path = url; String query = ""; String anchor = ""; int question = url.indexOf('?'); if (question >= 0) { path = url.substring(0, question); query = url.substring(question); } int pound = path.indexOf('#'); if (pound >= 0) { anchor = path.substring(pound); path = path.substring(0, pound); } StringBuilder sb = new StringBuilder(path); if (sb.length() > 0) { sb.append(";"); sb.append(Globals.SESSION_PARAMETER_NAME); sb.append("="); sb.append(sessionId); } sb.append(anchor); sb.append(query); return (sb.toString()); }	protected boolean postParseRequest(org.apache.coyote.Request req, Request request, org.apache.coyote.Response res, Response response) throws Exception { if (!req.scheme().isNull()) { request.setSecure(req.scheme().equals("https")); } else { // use connector scheme and secure configuration, (defaults to req.scheme().setString(connector.getScheme()); request.setSecure(connector.getSecure()); } // FIXME: the code below doesnt belongs to here, // this is only have sense // in Http11, not in ajp13.. // At this point the Host header has been processed. String proxyName = connector.getProxyName(); int proxyPort = connector.getProxyPort(); if (proxyPort != 0) { req.setServerPort(proxyPort); } if (proxyName != null) { req.serverName().setString(proxyName); } parseSessionId(req, request); MessageBytes decodedURI = req.decodedURI(); decodedURI.duplicate(req.requestURI()); if (decodedURI.getType() == MessageBytes.T_BYTES) { ByteChunk uriBB = decodedURI.getByteChunk(); int semicolon = uriBB.indexOf(';', 0); if (semicolon > 0) { decodedURI.setBytes(uriBB.getBuffer(), uriBB.getStart(), semicolon); } try { req.getURLDecoder().convert(decodedURI, false); } catch (IOException ioe) { res.setStatus(400); res.setMessage("Invalid URI: " + ioe.getMessage()); return false; } if (!normalize(req.decodedURI())) { res.setStatus(400); res.setMessage("Invalid URI"); return false; } convertURI(decodedURI, request); if (!checkNormalize(req.decodedURI())) { res.setStatus(400); res.setMessage("Invalid URI character encoding"); return false; } } else { // The URL is chars or String, and has been sent using an in-memory // protocol handler, we have to assume the URL has been properly decodedURI.toChars(); CharChunk uriCC = decodedURI.getCharChunk(); int semicolon = uriCC.indexOf(';'); if (semicolon > 0) { decodedURI.setChars(uriCC.getBuffer(), uriCC.getStart(), semicolon); } } String principal = req.getRemoteUser().toString(); if (principal != null) { request.setUserPrincipal(new CoyotePrincipal(principal)); } String authtype = req.getAuthType().toString(); if (authtype != null) { request.setAuthType(authtype); } MessageBytes serverName; if (connector.getUseIPVHosts()) { serverName = req.localName(); if (serverName.isNull()) { res.action(ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE, null); } } else { serverName = req.serverName(); } if (request.isAsyncStarted()) { //TODO SERVLET3 - async request.getMappingData().recycle(); } connector.getMapper().map(serverName, decodedURI, request.getMappingData()); request.setContext((Context) request.getMappingData().context); request.setWrapper((Wrapper) request.getMappingData().wrapper); if (!connector.getAllowTrace() && req.method().equalsIgnoreCase("TRACE")) { Wrapper wrapper = request.getWrapper(); String header = null; if (wrapper != null) { String[] methods = wrapper.getServletMethods(); if (methods != null) { for (int i = 0; i < methods.length; i++) { if ("TRACE".equals(methods[i])) { continue; } if (header == null) { header = methods[i]; } else { header += ", " + methods[i]; } } } } res.setStatus(405); res.addHeader("Allow", header); res.setMessage("TRACE method is not allowed"); return false; } MessageBytes redirectPathMB = request.getMappingData().redirectPath; if (!redirectPathMB.isNull()) { String redirectPath = urlEncoder.encode(redirectPathMB.toString()); String query = request.getQueryString(); if (request.isRequestedSessionIdFromURL()) { // This is not optimal, but as this is not very common, it redirectPath = redirectPath + ";" + Globals.SESSION_PARAMETER_NAME + "=" + request.getRequestedSessionId(); } if (query != null) { // This is not optimal, but as this is not very common, it redirectPath = redirectPath + "?" + query; } response.sendRedirect(redirectPath); return false; } if (!request.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.URL)) { request.setRequestedSessionId(null); request.setRequestedSessionURL(false); } parseSessionCookiesId(req, request); parseSessionSslId(request); return true; }	protected void parseSessionSslId(Request request) { if (request.getRequestedSessionId() == null && SSL_ONLY.equals(request.getServletContext().getEffectiveSessionTrackingModes()) && request.connector.secure) { // TODO Is there a better way to map SSL sessions to our sesison ID? // TODO The request.getAttribute() will cause a number of other SSL request.setRequestedSessionId(request.getAttribute(SSLSupport.SESSION_ID_KEY).toString()); request.setRequestedSessionSSL(true); } }	public Principal authenticate(String username, String clientDigest, String nOnce, String nc, String cnonce, String qop, String realm, String md5a2) { String md5a1 = getDigest(username, realm); if (md5a1 == null) return null; String serverDigestValue = md5a1 + ":" + nOnce + ":" + nc + ":" + cnonce + ":" + qop + ":" + md5a2; byte[] valueBytes = null; if (getDigestEncoding() == null) { valueBytes = serverDigestValue.getBytes(); } else { try { valueBytes = serverDigestValue.getBytes(getDigestEncoding()); } catch (UnsupportedEncodingException uee) { log.error("Illegal digestEncoding: " + getDigestEncoding(), uee); throw new IllegalArgumentException(uee.getMessage()); } } String serverDigest = null; synchronized (md5Helper) { serverDigest = md5Encoder.encode(md5Helper.digest(valueBytes)); } if (log.isDebugEnabled()) { log.debug("Digest : " + clientDigest + " Username:" + username + " ClientSigest:" + clientDigest + " nOnce:" + nOnce + " nc:" + nc + " cnonce:" + cnonce + " qop:" + qop + " realm:" + realm + "md5a2:" + md5a2 + " Server digest:" + serverDigest); } if (serverDigest.equals(clientDigest)) return getPrincipal(username); else return null; }	public boolean hasResourcePermission(Request request, Response response, SecurityConstraint[] constraints, Context context) throws IOException { if (constraints == null || constraints.length == 0) return (true); // Specifically allow access to the form login and form error pages LoginConfig config = context.getLoginConfig(); if ((config != null) && (Constants.FORM_METHOD.equals(config.getAuthMethod()))) { String requestURI = request.getRequestPathMB().toString(); String loginPage = config.getLoginPage(); if (loginPage.equals(requestURI)) { if (log.isDebugEnabled()) log.debug(" Allow access to login page " + loginPage); return (true); } String errorPage = config.getErrorPage(); if (errorPage.equals(requestURI)) { if (log.isDebugEnabled()) log.debug(" Allow access to error page " + errorPage); return (true); } if (requestURI.endsWith(Constants.FORM_ACTION)) { if (log.isDebugEnabled()) log.debug(" Allow access to username/password submission"); return (true); } } Principal principal = request.getPrincipal(); boolean status = false; boolean denyfromall = false; for (int i = 0; i < constraints.length; i++) { SecurityConstraint constraint = constraints[i]; String[] roles; if (constraint.getAllRoles()) { roles = request.getContext().findSecurityRoles(); } else { roles = constraint.findAuthRoles(); } if (roles == null) roles = new String[0]; if (log.isDebugEnabled()) log.debug(" Checking roles " + principal); if (roles.length == 0 && !constraint.getAllRoles()) { if (constraint.getAuthConstraint()) { if (log.isDebugEnabled()) log.debug("No roles "); status = false; denyfromall = true; break; } else { if (log.isDebugEnabled()) log.debug("Passing all access"); status = true; } } else if (principal == null) { if (log.isDebugEnabled()) log.debug(" No user authenticated, cannot grant access"); } else { for (int j = 0; j < roles.length; j++) { if (hasRole(principal, roles[j])) { status = true; if (log.isDebugEnabled()) log.debug("Role found: " + roles[j]); } } } } }	public boolean hasUserDataPermission(Request request, Response response, SecurityConstraint[] constraints) throws IOException { if (constraints == null || constraints.length == 0) { if (log.isDebugEnabled()) log.debug(" No applicable security constraint defined"); return (true); } for (int i = 0; i < constraints.length; i++) { SecurityConstraint constraint = constraints[i]; String userConstraint = constraint.getUserConstraint(); if (userConstraint == null) { if (log.isDebugEnabled()) log.debug(" No applicable user data constraint defined"); return (true); } if (userConstraint.equals(Constants.NONE_TRANSPORT)) { if (log.isDebugEnabled()) log.debug(" User data constraint has no restrictions"); return (true); } } if (request.getRequest().isSecure()) { if (log.isDebugEnabled()) log.debug(" User data constraint already satisfied"); return (true); } int redirectPort = request.getConnector().getRedirectPort(); if (redirectPort <= 0) { if (log.isDebugEnabled()) log.debug(" SSL redirect is disabled"); response.sendError(HttpServletResponse.SC_FORBIDDEN, request.getRequestURI()); return (false); } StringBuilder file = new StringBuilder(); String protocol = "https"; String host = request.getServerName(); file.append(protocol).append("://").append(host); if (redirectPort != 443) { file.append(":").append(redirectPort); } file.append(request.getRequestURI()); String requestedSessionId = request.getRequestedSessionId(); if ((requestedSessionId != null) && request.isRequestedSessionIdFromURL()) { file.append(";"); file.append(Globals.SESSION_PARAMETER_NAME); file.append("="); file.append(requestedSessionId); } String queryString = request.getQueryString(); if (queryString != null) { file.append('?'); file.append(queryString); } if (log.isDebugEnabled()) log.debug(" Redirecting to " + file.toString()); response.sendRedirect(file.toString()); return (false); }	public static Cookie createSessionCookie(Context context, String sessionId, boolean secure) { SessionCookieConfig scc = context.getServletContext().getSessionCookieConfig(); // NOTE: The priority order for session cookie configuration is: // 1. Context level configuration // 2. Values from SessionCookieConfig Cookie cookie = new Cookie(getSessionCookieName(context), sessionId); cookie.setMaxAge(scc.getMaxAge()); cookie.setComment(scc.getComment()); if (context.getSessionCookieDomain() == null) { if (scc.getDomain() != null) { cookie.setDomain(scc.getDomain()); } } else { cookie.setDomain(context.getSessionCookieDomain()); } if (scc.isSecure() || secure) { cookie.setSecure(true); } if (scc.isHttpOnly() || context.getUseHttpOnly()) { cookie.setHttpOnly(true); } String contextPath = context.getSessionCookiePath(); if (contextPath == null || contextPath.length() == 0) { contextPath = scc.getPath(); } if (contextPath == null || contextPath.length() == 0) { contextPath = context.getEncodedPath(); } cookie.setPath(contextPath); return cookie; }	public static String getSessionCookieName(Context context) { if (context != null) { String cookieName = context.getSessionCookieName(); if (cookieName != null && cookieName.length() > 0) { return cookieName; } SessionCookieConfig scc = context.getServletContext().getSessionCookieConfig(); cookieName = scc.getName(); if (cookieName != null && cookieName.length() > 0) { return cookieName; } } return Globals.SESSION_COOKIE_NAME; }	public void recycle() { context = null; wrapper = null; internalDispatcherType = null; requestDispatcherPath = null; comet = false; if (event != null) { event.clear(); event = null; } authType = null; inputBuffer.recycle(); usingInputStream = false; usingReader = false; userPrincipal = null; subject = null; sessionParsed = false; parametersParsed = false; parts = null; partsParseException = null; cookiesParsed = false; locales.clear(); localesParsed = false; secure = false; remoteAddr = null; remoteHost = null; remotePort = -1; localPort = -1; localAddr = null; localName = null; attributes.clear(); notes.clear(); cookies = null; if (session != null) { session.endAccess(); } session = null; requestedSessionCookie = false; requestedSessionId = null; requestedSessionURL = false; if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) { parameterMap = new ParameterMap<String, String[]>(); } else { parameterMap.setLocked(false); parameterMap.clear(); } mappingData.recycle(); if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) { if (facade != null) { facade.clear(); facade = null; } if (inputStream != null) { inputStream.clear(); inputStream = null; } if (reader != null) { reader.clear(); reader = null; } } asyncSupported = null; if (asyncContext != null) asyncContext.recycle(); asyncContext = null; }	public org.apache.coyote.Request getCoyoteRequest() { return (this.coyoteRequest); }
protected boolean processServletContainerInitializers(Set<WebXml> fragments) { for (WebXml fragment : fragments) { URL jarUrl = fragment.getURL(); JarFile jarFile = null; InputStream is = null; ServletContainerInitializer sci = null; try { JarURLConnection conn = (JarURLConnection) jarUrl.openConnection(); jarFile = conn.getJarFile(); ZipEntry entry = jarFile.getEntry("META-INF/services/javax.servlet.ServletContainerInitializer"); if (entry != null) { is = jarFile.getInputStream(entry); sci = getServletContainerInitializer(is); } } catch (IOException ioe) { log.error(sm.getString("contextConfig.servletContainerInitializerFail", jarUrl, context.getPath())); return false; } finally { if (is != null) { try { is.close(); } catch (IOException e) { // Ignore } } if (jarFile != null) { try { jarFile.close(); } catch (IOException e) { // Ignore } } } if (sci == null) { continue; } initializerClassMap.put(sci, new HashSet<Class<?>>()); HandlesTypes ht = sci.getClass().getAnnotation(HandlesTypes.class); if (ht != null) { Class<?>[] types = ht.value(); if (types != null) { for (Class<?> type : types) { Set<ServletContainerInitializer> scis = typeInitializerMap.get(type); if (scis == null) { scis = new HashSet<ServletContainerInitializer>(); typeInitializerMap.put(type, scis); } scis.add(sci); } } } } return true; }	protected void processResourceJARs(Set<WebXml> fragments) { for (WebXml fragment : fragments) { URL jarUrl = fragment.getURL(); JarFile jarFile = null; try { JarURLConnection conn = (JarURLConnection) jarUrl.openConnection(); jarFile = conn.getJarFile(); ZipEntry entry = jarFile.getEntry("META-INF/resources/"); if (entry != null) { context.addResourceJarUrl(jarUrl); } } catch (IOException ioe) { log.error(sm.getString("contextConfig.resourceJarFail", jarUrl, context.getPath())); } finally { if (jarFile != null) { try { jarFile.close(); } catch (IOException e) { // Ignore } } } } }
public void setDomain(String pattern) { domain = pattern.toLowerCase(); }
protected void connectUsingDriver() throws SQLException { java.sql.Driver driver = null; try { driver = (java.sql.Driver) Class.forName(poolProperties.getDriverClassName(), true, PooledConnection.class.getClassLoader()).newInstance(); } catch (java.lang.Exception cn) { if (log.isDebugEnabled()) { log.debug("Unable to instantiate JDBC driver.", cn); } SQLException ex = new SQLException(cn.getMessage()); ex.initCause(cn); throw ex; } String driverURL = poolProperties.getUrl(); String usr = poolProperties.getUsername(); String pwd = poolProperties.getPassword(); poolProperties.getDbProperties().setProperty("user", usr); poolProperties.getDbProperties().setProperty("password", pwd); try { connection = driver.connect(driverURL, poolProperties.getDbProperties()); } catch (Exception x) { if (log.isDebugEnabled()) { log.debug("Unable to connect to database.", x); } if (parent.jmxPool != null) { parent.jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_CONNECT, ConnectionPool.getStackTrace(x)); } if (x instanceof SQLException) { throw (SQLException) x; } else { SQLException ex = new SQLException(x.getMessage()); ex.initCause(x); throw ex; } } if (connection == null) { throw new SQLException("Driver:" + driver + " returned null for URL:" + driverURL); } }
private String extractFilename(String cd) { String fileName = null; if (cd != null) { String cdl = cd.toLowerCase(); if (cdl.startsWith("form-data") || cdl.startsWith("attachment")) { ParameterParser parser = new ParameterParser(); parser.setLowerCaseNames(true); Map<String, String> params = parser.parse(cd, ';'); if (params.containsKey("filename")) { fileName = params.get("filename"); if (fileName != null) { fileName = fileName.trim(); } else { // Even if there is no value, the parameter is present, // so we return an empty file name rather than no file fileName = ""; } } } } return fileName; }	private String getFieldName(String pContentDisposition) { String fieldName = null; if (pContentDisposition != null && pContentDisposition.toLowerCase().startsWith(FORM_DATA)) { ParameterParser parser = new ParameterParser(); parser.setLowerCaseNames(true); Map<String, String> params = parser.parse(pContentDisposition, ';'); fieldName = params.get("name"); if (fieldName != null) { fieldName = fieldName.trim(); } } return fieldName; }	private String getFileName(String pContentDisposition) { String fileName = null; if (pContentDisposition != null) { String cdl = pContentDisposition.toLowerCase(); if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) { ParameterParser parser = new ParameterParser(); parser.setLowerCaseNames(true); Map<String, String> params = parser.parse(pContentDisposition, ';'); if (params.containsKey("filename")) { fileName = params.get("filename"); if (fileName != null) { fileName = fileName.trim(); } else { // Even if there is no value, the parameter is present, // so we return an empty file name rather than no file fileName = ""; } } } } return fileName; }	private boolean copyResource(HttpServletRequest req, HttpServletResponse resp) throws IOException { String destinationPath = req.getHeader("Destination"); if (destinationPath == null) { resp.sendError(WebdavStatus.SC_BAD_REQUEST); return false; } destinationPath = RequestUtil.URLDecode(destinationPath, "UTF8"); int protocolIndex = destinationPath.indexOf("://"); if (protocolIndex >= 0) { // if the Destination URL contains the protocol, we can safely int firstSeparator = destinationPath.indexOf("/", protocolIndex + 4); if (firstSeparator < 0) { destinationPath = "/"; } else { destinationPath = destinationPath.substring(firstSeparator); } } else { String hostName = req.getServerName(); if ((hostName != null) && (destinationPath.startsWith(hostName))) { destinationPath = destinationPath.substring(hostName.length()); } int portIndex = destinationPath.indexOf(":"); if (portIndex >= 0) { destinationPath = destinationPath.substring(portIndex); } if (destinationPath.startsWith(":")) { int firstSeparator = destinationPath.indexOf("/"); if (firstSeparator < 0) { destinationPath = "/"; } else { destinationPath = destinationPath.substring(firstSeparator); } } } destinationPath = RequestUtil.normalize(destinationPath); String contextPath = req.getContextPath(); if ((contextPath != null) && (destinationPath.startsWith(contextPath))) { destinationPath = destinationPath.substring(contextPath.length()); } String pathInfo = req.getPathInfo(); if (pathInfo != null) { String servletPath = req.getServletPath(); if ((servletPath != null) && (destinationPath.startsWith(servletPath))) { destinationPath = destinationPath.substring(servletPath.length()); } } if (debug > 0) log("Dest path :" + destinationPath); if ((destinationPath.toUpperCase().startsWith("/WEB-INF")) || (destinationPath.toUpperCase().startsWith("/META-INF"))) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return false; } String path = getRelativePath(req); if ((path.toUpperCase().startsWith("/WEB-INF")) || (path.toUpperCase().startsWith("/META-INF"))) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return false; } if (destinationPath.equals(path)) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return false; } boolean overwrite = true; String overwriteHeader = req.getHeader("Overwrite"); if (overwriteHeader != null) { if (overwriteHeader.equalsIgnoreCase("T")) { overwrite = true; } else { overwrite = false; } } boolean exists = true; try { resources.lookup(destinationPath); } catch (NamingException e) { exists = false; } if (overwrite) { if (exists) { if (!deleteResource(destinationPath, req, resp, true)) { return false; } } else { resp.setStatus(WebdavStatus.SC_CREATED); } } else { if (exists) { resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED); return false; } } Hashtable<String, Integer> errorList = new Hashtable<String, Integer>(); boolean result = copyResource(resources, errorList, path, destinationPath); if ((!result) || (!errorList.isEmpty())) { if (errorList.size() == 1) { resp.sendError(errorList.elements().nextElement().intValue()); } else { sendReport(req, resp, errorList); } return false; } if (exists) { resp.setStatus(WebdavStatus.SC_NO_CONTENT); } else { resp.setStatus(WebdavStatus.SC_CREATED); } // Removing any lock-null resource which would be present at lockNullResources.remove(destinationPath); return true; }	private boolean deleteResource(String path, HttpServletRequest req, HttpServletResponse resp, boolean setStatus) throws IOException { if ((path.toUpperCase().startsWith("/WEB-INF")) || (path.toUpperCase().startsWith("/META-INF"))) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return false; } String ifHeader = req.getHeader("If"); if (ifHeader == null) ifHeader = ""; String lockTokenHeader = req.getHeader("Lock-Token"); if (lockTokenHeader == null) lockTokenHeader = ""; if (isLocked(path, ifHeader + lockTokenHeader)) { resp.sendError(WebdavStatus.SC_LOCKED); return false; } boolean exists = true; Object object = null; try { object = resources.lookup(path); } catch (NamingException e) { exists = false; } if (!exists) { resp.sendError(WebdavStatus.SC_NOT_FOUND); return false; } boolean collection = (object instanceof DirContext); if (!collection) { try { resources.unbind(path); } catch (NamingException e) { resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR); return false; } } else { Hashtable<String, Integer> errorList = new Hashtable<String, Integer>(); deleteCollection(req, resources, path, errorList); try { resources.unbind(path); } catch (NamingException e) { errorList.put(path, new Integer(WebdavStatus.SC_INTERNAL_SERVER_ERROR)); } if (!errorList.isEmpty()) { sendReport(req, resp, errorList); return false; } } if (setStatus) { resp.setStatus(WebdavStatus.SC_NO_CONTENT); } return true; }	boolean findNextItem() throws IOException { if (eof) { return false; } if (currentItem != null) { currentItem.close(); currentItem = null; } for (; ; ) { boolean nextPart; if (skipPreamble) { nextPart = multi.skipPreamble(); } else { nextPart = multi.readBoundary(); } if (!nextPart) { if (currentFieldName == null) { eof = true; return false; } multi.setBoundary(boundary); currentFieldName = null; continue; } FileItemHeaders headers = getParsedHeaders(multi.readHeaders()); if (currentFieldName == null) { String fieldName = getFieldName(headers); if (fieldName != null) { String subContentType = headers.getHeader(CONTENT_TYPE); if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) { currentFieldName = fieldName; byte[] subBoundary = getBoundary(subContentType); multi.setBoundary(subBoundary); skipPreamble = true; continue; } String fileName = getFileName(headers); currentItem = new FileItemStreamImpl(fileName, fieldName, headers.getHeader(CONTENT_TYPE), fileName == null, getContentLength(headers)); currentItem.setHeaders(headers); notifier.noteItem(); itemValid = true; return true; } } else { String fileName = getFileName(headers); if (fileName != null) { currentItem = new FileItemStreamImpl(fileName, currentFieldName, headers.getHeader(CONTENT_TYPE), false, getContentLength(headers)); currentItem.setHeaders(headers); notifier.noteItem(); itemValid = true; return true; } } multi.discardBodyData(); } }	private static void addFolderList(String property) { String extensionsDir = System.getProperty(property); if (extensionsDir != null) { StringTokenizer extensionsTok = new StringTokenizer(extensionsDir, File.pathSeparator); while (extensionsTok.hasMoreTokens()) { File targetDir = new File(extensionsTok.nextToken()); if (!targetDir.isDirectory()) { continue; } File[] files = targetDir.listFiles(); for (int i = 0; i < files.length; i++) { if (files[i].getName().toLowerCase().endsWith(".jar") && files[i].isFile()) { try { addSystemResource(files[i]); } catch (IOException e) { log.error(sm.getString("extensionValidator.failload", files[i]), e); } } } } } }	private static void processAcceptLanguage(String acceptLanguage, Hashtable<String, Vector<String>> languages, Vector<Double> q) { StringTokenizer languageTokenizer = new StringTokenizer(acceptLanguage, ","); while (languageTokenizer.hasMoreTokens()) { String language = languageTokenizer.nextToken().trim(); int qValueIndex = language.indexOf(';'); int qIndex = language.indexOf('q'); int equalIndex = language.indexOf('='); Double qValue = new Double(1); if (qValueIndex > -1 && qValueIndex < qIndex && qIndex < equalIndex) { String qValueStr = language.substring(qValueIndex + 1); language = language.substring(0, qValueIndex); qValueStr = qValueStr.trim().toLowerCase(); qValueIndex = qValueStr.indexOf('='); qValue = new Double(0); if (qValueStr.startsWith("q") && qValueIndex > -1) { qValueStr = qValueStr.substring(qValueIndex + 1); try { qValue = new Double(qValueStr.trim()); } catch (NumberFormatException nfe) { } } } if (!language.equals("*")) { String key = qValue.toString(); Vector<String> v; if (languages.containsKey(key)) { v = languages.get(key); } else { v = new Vector<String>(); q.addElement(qValue); } v.addElement(language); languages.put(key, v); } } }	private void deleteCollection(HttpServletRequest req, DirContext dirContext, String path, Hashtable<String, Integer> errorList) { if (debug > 1) log("Delete:" + path); if ((path.toUpperCase().startsWith("/WEB-INF")) || (path.toUpperCase().startsWith("/META-INF"))) { errorList.put(path, new Integer(WebdavStatus.SC_FORBIDDEN)); return; } String ifHeader = req.getHeader("If"); if (ifHeader == null) ifHeader = ""; String lockTokenHeader = req.getHeader("Lock-Token"); if (lockTokenHeader == null) lockTokenHeader = ""; Enumeration<NameClassPair> enumeration = null; try { enumeration = dirContext.list(path); } catch (NamingException e) { errorList.put(path, new Integer(WebdavStatus.SC_INTERNAL_SERVER_ERROR)); return; } while (enumeration.hasMoreElements()) { NameClassPair ncPair = enumeration.nextElement(); String childName = path; if (!childName.equals("/")) childName += "/"; childName += ncPair.getName(); if (isLocked(childName, ifHeader + lockTokenHeader)) { errorList.put(childName, new Integer(WebdavStatus.SC_LOCKED)); } else { try { Object object = dirContext.lookup(childName); if (object instanceof DirContext) { deleteCollection(req, dirContext, childName, errorList); } try { dirContext.unbind(childName); } catch (NamingException e) { if (!(object instanceof DirContext)) { // If it's not a collection, then it's an unknown errorList.put(childName, new Integer(WebdavStatus.SC_INTERNAL_SERVER_ERROR)); } } } catch (NamingException e) { errorList.put(childName, new Integer(WebdavStatus.SC_INTERNAL_SERVER_ERROR)); } } } }	private boolean generateLockDiscovery(String path, XMLWriter generatedXML) { LockInfo resourceLock = resourceLocks.get(path); Enumeration<LockInfo> collectionLocksList = collectionLocks.elements(); boolean wroteStart = false; if (resourceLock != null) { wroteStart = true; generatedXML.writeElement(null, "lockdiscovery", XMLWriter.OPENING); resourceLock.toXML(generatedXML); } while (collectionLocksList.hasMoreElements()) { LockInfo currentLock = collectionLocksList.nextElement(); if (path.startsWith(currentLock.path)) { if (!wroteStart) { wroteStart = true; generatedXML.writeElement(null, "lockdiscovery", XMLWriter.OPENING); } currentLock.toXML(generatedXML); } } if (wroteStart) { generatedXML.writeElement(null, "lockdiscovery", XMLWriter.CLOSING); } else { return false; } return true; }	private void parseProperties(HttpServletRequest req, XMLWriter generatedXML, String path, int type, Vector<String> propertiesVector) { if (path.toUpperCase().startsWith("/WEB-INF") || path.toUpperCase().startsWith("/META-INF")) return; CacheEntry cacheEntry = resources.lookupCache(path); if (!cacheEntry.exists) { return; } generatedXML.writeElement(null, "response", XMLWriter.OPENING); String status = new String("HTTP/1.1 " + WebdavStatus.SC_OK + " " + WebdavStatus.getStatusText(WebdavStatus.SC_OK)); generatedXML.writeElement(null, "href", XMLWriter.OPENING); String href = req.getContextPath() + req.getServletPath(); if ((href.endsWith("/")) && (path.startsWith("/"))) href += path.substring(1); else href += path; if ((cacheEntry.context != null) && (!href.endsWith("/"))) href += "/"; generatedXML.writeText(rewriteUrl(href)); generatedXML.writeElement(null, "href", XMLWriter.CLOSING); String resourceName = path; int lastSlash = path.lastIndexOf('/'); if (lastSlash != -1) resourceName = resourceName.substring(lastSlash + 1); switch(type) { case FIND_ALL_PROP: generatedXML.writeElement(null, "propstat", XMLWriter.OPENING); generatedXML.writeElement(null, "prop", XMLWriter.OPENING); generatedXML.writeProperty(null, "creationdate", getISOCreationDate(cacheEntry.attributes.getCreation())); generatedXML.writeElement(null, "displayname", XMLWriter.OPENING); generatedXML.writeData(resourceName); generatedXML.writeElement(null, "displayname", XMLWriter.CLOSING); if (cacheEntry.resource != null) { generatedXML.writeProperty(null, "getlastmodified", FastHttpDateFormat.formatDate(cacheEntry.attributes.getLastModified(), null)); generatedXML.writeProperty(null, "getcontentlength", String.valueOf(cacheEntry.attributes.getContentLength())); String contentType = getServletContext().getMimeType(cacheEntry.name); if (contentType != null) { generatedXML.writeProperty(null, "getcontenttype", contentType); } generatedXML.writeProperty(null, "getetag", cacheEntry.attributes.getETag()); generatedXML.writeElement(null, "resourcetype", XMLWriter.NO_CONTENT); } else { generatedXML.writeElement(null, "resourcetype", XMLWriter.OPENING); generatedXML.writeElement(null, "collection", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "resourcetype", XMLWriter.CLOSING); } generatedXML.writeProperty(null, "source", ""); String supportedLocks = "<lockentry>" + "<lockscope><exclusive/></lockscope>" + "<locktype><write/></locktype>" + "</lockentry>" + "<lockentry>" + "<lockscope><shared/></lockscope>" + "<locktype><write/></locktype>" + "</lockentry>"; generatedXML.writeElement(null, "supportedlock", XMLWriter.OPENING); generatedXML.writeText(supportedLocks); generatedXML.writeElement(null, "supportedlock", XMLWriter.CLOSING); generateLockDiscovery(path, generatedXML); generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText(status); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "propstat", XMLWriter.CLOSING); break; case FIND_PROPERTY_NAMES: generatedXML.writeElement(null, "propstat", XMLWriter.OPENING); generatedXML.writeElement(null, "prop", XMLWriter.OPENING); generatedXML.writeElement(null, "creationdate", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "displayname", XMLWriter.NO_CONTENT); if (cacheEntry.resource != null) { generatedXML.writeElement(null, "getcontentlanguage", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "getcontentlength", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "getcontenttype", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "getetag", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "getlastmodified", XMLWriter.NO_CONTENT); } generatedXML.writeElement(null, "resourcetype", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "source", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "lockdiscovery", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText(status); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "propstat", XMLWriter.CLOSING); break; case FIND_BY_PROPERTY: Vector<String> propertiesNotFound = new Vector<String>(); generatedXML.writeElement(null, "propstat", XMLWriter.OPENING); generatedXML.writeElement(null, "prop", XMLWriter.OPENING); Enumeration<String> properties = propertiesVector.elements(); while (properties.hasMoreElements()) { String property = properties.nextElement(); if (property.equals("creationdate")) { generatedXML.writeProperty(null, "creationdate", getISOCreationDate(cacheEntry.attributes.getCreation())); } else if (property.equals("displayname")) { generatedXML.writeElement(null, "displayname", XMLWriter.OPENING); generatedXML.writeData(resourceName); generatedXML.writeElement(null, "displayname", XMLWriter.CLOSING); } else if (property.equals("getcontentlanguage")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeElement(null, "getcontentlanguage", XMLWriter.NO_CONTENT); } } else if (property.equals("getcontentlength")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeProperty(null, "getcontentlength", (String.valueOf(cacheEntry.attributes.getContentLength()))); } } else if (property.equals("getcontenttype")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeProperty(null, "getcontenttype", getServletContext().getMimeType(cacheEntry.name)); } } else if (property.equals("getetag")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeProperty(null, "getetag", cacheEntry.attributes.getETag()); } } else if (property.equals("getlastmodified")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeProperty(null, "getlastmodified", FastHttpDateFormat.formatDate(cacheEntry.attributes.getLastModified(), null)); } } else if (property.equals("resourcetype")) { if (cacheEntry.context != null) { generatedXML.writeElement(null, "resourcetype", XMLWriter.OPENING); generatedXML.writeElement(null, "collection", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "resourcetype", XMLWriter.CLOSING); } else { generatedXML.writeElement(null, "resourcetype", XMLWriter.NO_CONTENT); } } else if (property.equals("source")) { generatedXML.writeProperty(null, "source", ""); } else if (property.equals("supportedlock")) { supportedLocks = "<lockentry>" + "<lockscope><exclusive/></lockscope>" + "<locktype><write/></locktype>" + "</lockentry>" + "<lockentry>" + "<lockscope><shared/></lockscope>" + "<locktype><write/></locktype>" + "</lockentry>"; generatedXML.writeElement(null, "supportedlock", XMLWriter.OPENING); generatedXML.writeText(supportedLocks); generatedXML.writeElement(null, "supportedlock", XMLWriter.CLOSING); } else if (property.equals("lockdiscovery")) { if (!generateLockDiscovery(path, generatedXML)) propertiesNotFound.addElement(property); } else { propertiesNotFound.addElement(property); } } generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText(status); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "propstat", XMLWriter.CLOSING); Enumeration<String> propertiesNotFoundList = propertiesNotFound.elements(); if (propertiesNotFoundList.hasMoreElements()) { status = new String("HTTP/1.1 " + WebdavStatus.SC_NOT_FOUND + " " + WebdavStatus.getStatusText(WebdavStatus.SC_NOT_FOUND)); generatedXML.writeElement(null, "propstat", XMLWriter.OPENING); generatedXML.writeElement(null, "prop", XMLWriter.OPENING); while (propertiesNotFoundList.hasMoreElements()) { generatedXML.writeElement(null, propertiesNotFoundList.nextElement(), XMLWriter.NO_CONTENT); } generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText(status); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "propstat", XMLWriter.CLOSING); } break; } generatedXML.writeElement(null, "response", XMLWriter.CLOSING); }	protected String getCGIVariable(String name) { String retVal = null; String[] nameParts = name.toUpperCase().split("_"); int requiredParts = 2; if (nameParts.length == 1) { if (nameParts[0].equals("PATH")) { requiredParts = 1; } } }	protected String upload(HttpServletRequest request) throws IOException, ServletException { String message = ""; Part warPart = null; String filename = null; String basename = null; Collection<Part> parts = request.getParts(); Iterator<Part> iter = parts.iterator(); try { while (iter.hasNext()) { Part part = iter.next(); if (part.getName().equals("deployWar") && warPart == null) { warPart = part; } else { part.delete(); } } while (true) { if (warPart == null) { message = sm.getString("htmlManagerServlet.deployUploadNoFile"); break; } filename = extractFilename(warPart.getHeader("Content-Disposition")); if (!filename.toLowerCase().endsWith(".war")) { message = sm.getString("htmlManagerServlet.deployUploadNotWar", filename); break; } if (filename.lastIndexOf('\\') >= 0) { filename = filename.substring(filename.lastIndexOf('\\') + 1); } if (filename.lastIndexOf('/') >= 0) { filename = filename.substring(filename.lastIndexOf('/') + 1); } // Identify the appBase of the owning Host of this Context basename = filename.substring(0, filename.toLowerCase().indexOf(".war")); File file = new File(getAppBase(), filename); if (file.exists()) { message = sm.getString("htmlManagerServlet.deployUploadWarExists", filename); break; } String path = null; if (basename.equals("ROOT")) { path = ""; } else { path = "/" + basename.replace('#', '/'); } if ((host.findChild(path) != null) && !isDeployed(path)) { message = sm.getString("htmlManagerServlet.deployUploadInServerXml", filename); break; } if (!isServiced(path)) { addServiced(path); try { warPart.write(file.getAbsolutePath()); check(path); } finally { removeServiced(path); } } break; } } catch (Exception e) { message = sm.getString("htmlManagerServlet.deployUploadFail", e.getMessage()); log(message, e); } finally { if (warPart != null) { warPart.delete(); } warPart = null; } return message; }	protected boolean setCGIEnvironment(HttpServletRequest req) throws IOException { Hashtable<String, String> envp = new Hashtable<String, String>(); envp.putAll(shellEnv); String sPathInfoOrig = null; String sPathInfoCGI = null; String sPathTranslatedCGI = null; String sCGIFullPath = null; String sCGIScriptName = null; String sCGIFullName = null; String sCGIName = null; String[] sCGINames; sPathInfoOrig = this.pathInfo; sPathInfoOrig = sPathInfoOrig == null ? "" : sPathInfoOrig; if (webAppRootDir == null) { webAppRootDir = tmpDir.toString(); expandCGIScript(); } sCGINames = findCGI(sPathInfoOrig, webAppRootDir, contextPath, servletPath, cgiPathPrefix); sCGIFullPath = sCGINames[0]; sCGIScriptName = sCGINames[1]; sCGIFullName = sCGINames[2]; sCGIName = sCGINames[3]; if (sCGIFullPath == null || sCGIScriptName == null || sCGIFullName == null || sCGIName == null) { return false; } envp.put("SERVER_SOFTWARE", "TOMCAT"); envp.put("SERVER_NAME", nullsToBlanks(req.getServerName())); envp.put("GATEWAY_INTERFACE", "CGI/1.1"); envp.put("SERVER_PROTOCOL", nullsToBlanks(req.getProtocol())); int port = req.getServerPort(); Integer iPort = (port == 0 ? Integer.valueOf(-1) : Integer.valueOf(port)); envp.put("SERVER_PORT", iPort.toString()); envp.put("REQUEST_METHOD", nullsToBlanks(req.getMethod())); envp.put("REQUEST_URI", nullsToBlanks(req.getRequestURI())); if (pathInfo == null || (pathInfo.substring(sCGIFullName.length()).length() <= 0)) { sPathInfoCGI = ""; } else { sPathInfoCGI = pathInfo.substring(sCGIFullName.length()); } envp.put("PATH_INFO", sPathInfoCGI); if (sPathInfoCGI != null && !("".equals(sPathInfoCGI))) { sPathTranslatedCGI = context.getRealPath(sPathInfoCGI); } if (sPathTranslatedCGI == null || "".equals(sPathTranslatedCGI)) { //NOOP } else { envp.put("PATH_TRANSLATED", nullsToBlanks(sPathTranslatedCGI)); } envp.put("SCRIPT_NAME", nullsToBlanks(sCGIScriptName)); envp.put("QUERY_STRING", nullsToBlanks(req.getQueryString())); envp.put("REMOTE_HOST", nullsToBlanks(req.getRemoteHost())); envp.put("REMOTE_ADDR", nullsToBlanks(req.getRemoteAddr())); envp.put("AUTH_TYPE", nullsToBlanks(req.getAuthType())); envp.put("REMOTE_USER", nullsToBlanks(req.getRemoteUser())); envp.put("REMOTE_IDENT", ""); envp.put("CONTENT_TYPE", nullsToBlanks(req.getContentType())); int contentLength = req.getContentLength(); String sContentLength = (contentLength <= 0 ? "" : (Integer.valueOf(contentLength)).toString()); envp.put("CONTENT_LENGTH", sContentLength); Enumeration<String> headers = req.getHeaderNames(); String header = null; while (headers.hasMoreElements()) { header = null; header = headers.nextElement().toUpperCase(); if ("AUTHORIZATION".equalsIgnoreCase(header) || "PROXY_AUTHORIZATION".equalsIgnoreCase(header)) { //NOOP per CGI specification section 11.2 } else { envp.put("HTTP_" + header.replace('-', '_'), req.getHeader(header)); } } File fCGIFullPath = new File(sCGIFullPath); command = fCGIFullPath.getCanonicalPath(); envp.put("X_TOMCAT_SCRIPT_PATH", command); envp.put("SCRIPT_FILENAME", command); this.env = envp; return true; }	protected void antiLocking() { if ((context instanceof StandardContext) && ((StandardContext) context).getAntiResourceLocking()) { Host host = (Host) context.getParent(); String appBase = host.getAppBase(); String docBase = context.getDocBase(); if (docBase == null) return; if (originalDocBase == null) { originalDocBase = docBase; } else { docBase = originalDocBase; } File docBaseFile = new File(docBase); if (!docBaseFile.isAbsolute()) { File file = new File(appBase); if (!file.isAbsolute()) { file = new File(System.getProperty("catalina.base"), appBase); } docBaseFile = new File(file, docBase); } String path = context.getPath(); if (path == null) { return; } if (path.equals("")) { docBase = "ROOT"; } else { if (path.startsWith("/")) { docBase = path.substring(1); } else { docBase = path; } } File file = null; if (docBase.toLowerCase().endsWith(".war")) { file = new File(System.getProperty("java.io.tmpdir"), deploymentCount++ + "-" + docBase + ".war"); } else { file = new File(System.getProperty("java.io.tmpdir"), deploymentCount++ + "-" + docBase); } if (log.isDebugEnabled()) log.debug("Anti locking context[" + context.getPath() + "] setting docBase to " + file); ExpandWar.delete(file); if (ExpandWar.copy(docBaseFile, file)) { context.setDocBase(file.getAbsolutePath()); } } }	protected void deployDescriptor(String contextPath, File contextXml, String file) { if (deploymentExists(contextPath)) { return; } DeployedApplication deployedApp = new DeployedApplication(contextPath); if (log.isInfoEnabled()) { log.info(sm.getString("hostConfig.deployDescriptor", file, configBase.getPath())); } Context context = null; try { synchronized (digester) { try { context = (Context) digester.parse(contextXml); if (context == null) { log.error(sm.getString("hostConfig.deployDescriptor.error", file)); return; } } finally { digester.reset(); } } Class<?> clazz = Class.forName(host.getConfigClass()); LifecycleListener listener = (LifecycleListener) clazz.newInstance(); context.addLifecycleListener(listener); context.setConfigFile(contextXml.toURI().toURL()); context.setPath(contextPath); boolean isExternalWar = false; boolean isExternal = false; if (context.getDocBase() != null) { File docBase = new File(context.getDocBase()); if (!docBase.isAbsolute()) { docBase = new File(appBase(), context.getDocBase()); } if (!docBase.getCanonicalPath().startsWith(appBase().getAbsolutePath() + File.separator)) { isExternal = true; deployedApp.redeployResources.put(contextXml.getAbsolutePath(), new Long(contextXml.lastModified())); deployedApp.redeployResources.put(docBase.getAbsolutePath(), new Long(docBase.lastModified())); if (docBase.getAbsolutePath().toLowerCase().endsWith(".war")) { isExternalWar = true; } } else { log.warn(sm.getString("hostConfig.deployDescriptor.localDocBaseSpecified", docBase)); context.setDocBase(null); } } host.addChild(context); String name = null; String path = context.getPath(); if (path.equals("")) { name = "ROOT"; } else { if (path.startsWith("/")) { name = path.substring(1); } else { name = path; } } File expandedDocBase = new File(appBase(), name); if (context.getDocBase() != null) { expandedDocBase = new File(context.getDocBase()); if (!expandedDocBase.isAbsolute()) { expandedDocBase = new File(appBase(), context.getDocBase()); } } if (isExternalWar && unpackWARs) { deployedApp.redeployResources.put(expandedDocBase.getAbsolutePath(), new Long(expandedDocBase.lastModified())); deployedApp.redeployResources.put(contextXml.getAbsolutePath(), new Long(contextXml.lastModified())); addWatchedResources(deployedApp, expandedDocBase.getAbsolutePath(), context); } else { if (!isExternal) { File warDocBase = new File(expandedDocBase.getAbsolutePath() + ".war"); if (warDocBase.exists()) { deployedApp.redeployResources.put(warDocBase.getAbsolutePath(), new Long(warDocBase.lastModified())); } } if (expandedDocBase.exists()) { deployedApp.redeployResources.put(expandedDocBase.getAbsolutePath(), new Long(expandedDocBase.lastModified())); addWatchedResources(deployedApp, expandedDocBase.getAbsolutePath(), context); } else { addWatchedResources(deployedApp, null, context); } if (!isExternal) { deployedApp.redeployResources.put(contextXml.getAbsolutePath(), new Long(contextXml.lastModified())); } } } catch (Throwable t) { log.error(sm.getString("hostConfig.deployDescriptor.error", file), t); } if (context != null && host.findChild(context.getName()) != null) { deployed.put(contextPath, deployedApp); } }	protected void deployDescriptors(File configBase, String[] files) { if (files == null) return; for (int i = 0; i < files.length; i++) { File contextXml = new File(configBase, files[i]); if (files[i].toLowerCase().endsWith(".xml")) { String nameTmp = files[i].substring(0, files[i].length() - 4); String contextPath = "/" + nameTmp.replace('#', '/'); if (nameTmp.equals("ROOT")) { contextPath = ""; } if (isServiced(contextPath)) continue; String file = files[i]; deployDescriptor(contextPath, contextXml, file); } } }	protected void deployWARs(File appBase, String[] files) { if (files == null) return; for (int i = 0; i < files.length; i++) { if (files[i].equalsIgnoreCase("META-INF")) continue; if (files[i].equalsIgnoreCase("WEB-INF")) continue; File dir = new File(appBase, files[i]); if (files[i].toLowerCase().endsWith(".war") && dir.isFile() && !invalidWars.contains(files[i])) { String contextPath = "/" + files[i].replace('#', '/'); int period = contextPath.lastIndexOf("."); contextPath = contextPath.substring(0, period); if (!validateContextPath(appBase, contextPath)) { log.error(sm.getString("hostConfig.illegalWarName", files[i])); invalidWars.add(files[i]); continue; } if (contextPath.equals("/ROOT")) contextPath = ""; if (isServiced(contextPath)) continue; String file = files[i]; deployWAR(contextPath, dir, file); } } }	protected void doMkcol(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { if (readOnly) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return; } if (isLocked(req)) { resp.sendError(WebdavStatus.SC_LOCKED); return; } String path = getRelativePath(req); if ((path.toUpperCase().startsWith("/WEB-INF")) || (path.toUpperCase().startsWith("/META-INF"))) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return; } boolean exists = true; try { resources.lookup(path); } catch (NamingException e) { exists = false; } if (exists) { StringBuilder methodsAllowed = determineMethodsAllowed(resources, req); resp.addHeader("Allow", methodsAllowed.toString()); resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED); return; } if (req.getContentLength() > 0) { DocumentBuilder documentBuilder = getDocumentBuilder(); try { documentBuilder.parse(new InputSource(req.getInputStream())); resp.sendError(WebdavStatus.SC_NOT_IMPLEMENTED); return; } catch (SAXException saxe) { resp.sendError(WebdavStatus.SC_UNSUPPORTED_MEDIA_TYPE); return; } } boolean result = true; try { resources.createSubcontext(path); } catch (NamingException e) { result = false; } if (!result) { resp.sendError(WebdavStatus.SC_CONFLICT, WebdavStatus.getStatusText(WebdavStatus.SC_CONFLICT)); } else { resp.setStatus(WebdavStatus.SC_CREATED); lockNullResources.remove(path); } }	protected void doPropfind(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { if (!listings) { StringBuilder methodsAllowed = determineMethodsAllowed(resources, req); resp.addHeader("Allow", methodsAllowed.toString()); resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED); return; } String path = getRelativePath(req); if (path.endsWith("/")) path = path.substring(0, path.length() - 1); if ((path.toUpperCase().startsWith("/WEB-INF")) || (path.toUpperCase().startsWith("/META-INF"))) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return; } Vector<String> properties = null; int depth = maxDepth; int type = FIND_ALL_PROP; String depthStr = req.getHeader("Depth"); if (depthStr == null) { depth = maxDepth; } else { if (depthStr.equals("0")) { depth = 0; } else if (depthStr.equals("1")) { depth = 1; } else if (depthStr.equals("infinity")) { depth = maxDepth; } } Node propNode = null; if (req.getContentLength() > 0) { DocumentBuilder documentBuilder = getDocumentBuilder(); try { Document document = documentBuilder.parse(new InputSource(req.getInputStream())); Element rootElement = document.getDocumentElement(); NodeList childList = rootElement.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: if (currentNode.getNodeName().endsWith("prop")) { type = FIND_BY_PROPERTY; propNode = currentNode; } if (currentNode.getNodeName().endsWith("propname")) { type = FIND_PROPERTY_NAMES; } if (currentNode.getNodeName().endsWith("allprop")) { type = FIND_ALL_PROP; } break; } } } catch (SAXException e) { resp.sendError(WebdavStatus.SC_BAD_REQUEST); } catch (IOException e) { resp.sendError(WebdavStatus.SC_BAD_REQUEST); } } if (type == FIND_BY_PROPERTY) { properties = new Vector<String>(); @SuppressWarnings("null") NodeList childList = propNode.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: String nodeName = currentNode.getNodeName(); String propertyName = null; if (nodeName.indexOf(':') != -1) { propertyName = nodeName.substring(nodeName.indexOf(':') + 1); } else { propertyName = nodeName; } properties.addElement(propertyName); break; } } } boolean exists = true; Object object = null; try { object = resources.lookup(path); } catch (NamingException e) { exists = false; int slash = path.lastIndexOf('/'); if (slash != -1) { String parentPath = path.substring(0, slash); Vector<String> currentLockNullResources = lockNullResources.get(parentPath); if (currentLockNullResources != null) { Enumeration<String> lockNullResourcesList = currentLockNullResources.elements(); while (lockNullResourcesList.hasMoreElements()) { String lockNullPath = lockNullResourcesList.nextElement(); if (lockNullPath.equals(path)) { resp.setStatus(WebdavStatus.SC_MULTI_STATUS); resp.setContentType("text/xml; charset=UTF-8"); XMLWriter generatedXML = new XMLWriter(resp.getWriter()); generatedXML.writeXMLHeader(); generatedXML.writeElement(null, "multistatus" + generateNamespaceDeclarations(), XMLWriter.OPENING); parseLockNullProperties(req, generatedXML, lockNullPath, type, properties); generatedXML.writeElement(null, "multistatus", XMLWriter.CLOSING); generatedXML.sendData(); return; } } } } } if (!exists) { resp.sendError(HttpServletResponse.SC_NOT_FOUND, path); return; } resp.setStatus(WebdavStatus.SC_MULTI_STATUS); resp.setContentType("text/xml; charset=UTF-8"); XMLWriter generatedXML = new XMLWriter(resp.getWriter()); generatedXML.writeXMLHeader(); generatedXML.writeElement(null, "multistatus" + generateNamespaceDeclarations(), XMLWriter.OPENING); if (depth == 0) { parseProperties(req, generatedXML, path, type, properties); } else { Stack<String> stack = new Stack<String>(); stack.push(path); Stack<String> stackBelow = new Stack<String>(); while ((!stack.isEmpty()) && (depth >= 0)) { String currentPath = stack.pop(); parseProperties(req, generatedXML, currentPath, type, properties); try { object = resources.lookup(currentPath); } catch (NamingException e) { continue; } if ((object instanceof DirContext) && (depth > 0)) { try { NamingEnumeration<NameClassPair> enumeration = resources.list(currentPath); while (enumeration.hasMoreElements()) { NameClassPair ncPair = enumeration.nextElement(); String newPath = currentPath; if (!(newPath.endsWith("/"))) newPath += "/"; newPath += ncPair.getName(); stackBelow.push(newPath); } } catch (NamingException e) { resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, path); return; } // Displaying the lock-null resources present in that String lockPath = currentPath; if (lockPath.endsWith("/")) lockPath = lockPath.substring(0, lockPath.length() - 1); Vector<String> currentLockNullResources = lockNullResources.get(lockPath); if (currentLockNullResources != null) { Enumeration<String> lockNullResourcesList = currentLockNullResources.elements(); while (lockNullResourcesList.hasMoreElements()) { String lockNullPath = lockNullResourcesList.nextElement(); parseLockNullProperties(req, generatedXML, lockNullPath, type, properties); } } } if (stack.isEmpty()) { depth--; stack = stackBelow; stackBelow = new Stack<String>(); } generatedXML.sendData(); } } generatedXML.writeElement(null, "multistatus", XMLWriter.CLOSING); generatedXML.sendData(); }	protected void fixDocBase() throws IOException { Host host = (Host) context.getParent(); String appBase = host.getAppBase(); boolean unpackWARs = true; if (host instanceof StandardHost) { unpackWARs = ((StandardHost) host).isUnpackWARs() && ((StandardContext) context).getUnpackWAR(); } File canonicalAppBase = new File(appBase); if (canonicalAppBase.isAbsolute()) { canonicalAppBase = canonicalAppBase.getCanonicalFile(); } else { canonicalAppBase = new File(System.getProperty("catalina.base"), appBase).getCanonicalFile(); } String docBase = context.getDocBase(); if (docBase == null) { String path = context.getPath(); if (path == null) { return; } if (path.equals("")) { docBase = "ROOT"; } else { if (path.startsWith("/")) { docBase = path.substring(1).replace('/', '#'); } else { docBase = path.replace('/', '#'); } } } File file = new File(docBase); if (!file.isAbsolute()) { docBase = (new File(canonicalAppBase, docBase)).getPath(); } else { docBase = file.getCanonicalPath(); } file = new File(docBase); String origDocBase = docBase; String pathName = context.getPath(); if (pathName.equals("")) { pathName = "ROOT"; } else { pathName = pathName.substring(1).replace('/', '#'); } if (docBase.toLowerCase().endsWith(".war") && !file.isDirectory() && unpackWARs) { URL war = new URL("jar:" + (new File(docBase)).toURI().toURL() + "!/"); docBase = ExpandWar.expand(host, war, pathName); file = new File(docBase); docBase = file.getCanonicalPath(); if (context instanceof StandardContext) { ((StandardContext) context).setOriginalDocBase(origDocBase); } } else if (docBase.toLowerCase().endsWith(".war") && !file.isDirectory() && !unpackWARs) { URL war = new URL("jar:" + (new File(docBase)).toURI().toURL() + "!/"); ExpandWar.validate(host, war, pathName); } else { File docDir = new File(docBase); if (!docDir.exists()) { File warFile = new File(docBase + ".war"); if (warFile.exists()) { URL war = new URL("jar:" + warFile.toURI().toURL() + "!/"); if (unpackWARs) { docBase = ExpandWar.expand(host, war, pathName); file = new File(docBase); docBase = file.getCanonicalPath(); } else { docBase = warFile.getCanonicalPath(); ExpandWar.validate(host, war, pathName); } } if (context instanceof StandardContext) { ((StandardContext) context).setOriginalDocBase(origDocBase); } } } if (docBase.startsWith(canonicalAppBase.getPath() + File.separatorChar)) { docBase = docBase.substring(canonicalAppBase.getPath().length()); docBase = docBase.replace(File.separatorChar, '/'); if (docBase.startsWith("/")) { docBase = docBase.substring(1); } } else { docBase = docBase.replace(File.separatorChar, '/'); } context.setDocBase(docBase); }	protected void requestHandler(HttpServletRequest req, HttpServletResponse res) throws IOException { ServletContext servletContext = getServletContext(); String path = SSIServletRequestUtil.getRelativePath(req); if (debug > 0) log("SSIServlet.requestHandler()\n" + "Serving " + (buffered ? "buffered " : "unbuffered ") + "resource '" + path + "'"); if (path == null || path.toUpperCase().startsWith("/WEB-INF") || path.toUpperCase().startsWith("/META-INF")) { res.sendError(HttpServletResponse.SC_NOT_FOUND, path); log("Can't serve file: " + path); return; } URL resource = servletContext.getResource(path); if (resource == null) { res.sendError(HttpServletResponse.SC_NOT_FOUND, path); log("Can't find file: " + path); return; } String resourceMimeType = servletContext.getMimeType(path); if (resourceMimeType == null) { resourceMimeType = "text/html"; } res.setContentType(resourceMimeType + ";charset=" + outputEncoding); if (expires != null) { res.setDateHeader("Expires", (new java.util.Date()).getTime() + expires.longValue() * 1000); } req.setAttribute(Globals.SSI_FLAG_ATTR, "true"); processSSI(req, res, resource); }	public String getFilename() { String fileName = null; String cd = getHeader("Content-Disposition"); if (cd != null) { String cdl = cd.toLowerCase(); if (cdl.startsWith("form-data") || cdl.startsWith("attachment")) { ParameterParser paramParser = new ParameterParser(); paramParser.setLowerCaseNames(true); Map<String, String> params = paramParser.parse(cd, ';'); if (params.containsKey("filename")) { fileName = params.get("filename"); if (fileName != null) { fileName = fileName.trim(); } else { // Even if there is no value, the parameter is present, // so we return an empty file name rather than no file fileName = ""; } } } } return fileName; }	public Iterator<String> getHeaders(String name) { String nameLower = name.toLowerCase(); List<String> headerValueList = headerNameToValueListMap.get(nameLower); if (null == headerValueList) { return Collections.<String>emptyList().iterator(); } return headerValueList.iterator(); }	public String getVariableValue(String variableName, String encoding) { String lowerCaseVariableName = variableName.toLowerCase(); String variableValue = null; if (!isNameReserved(lowerCaseVariableName)) { //Try getting it externally first, if it fails, try getting the // 'built-in' variableValue = ssiExternalResolver.getVariableValue(variableName); if (variableValue == null) { variableName = variableName.toUpperCase(); variableValue = ssiExternalResolver.getVariableValue(className + "." + variableName); } if (variableValue != null) { variableValue = encode(variableValue, encoding); } } return variableValue; }	@Override public int doEndTag() throws JspException { if ((jspFile.indexOf("..") >= 0) || (jspFile.toUpperCase().indexOf("/WEB-INF/") != 0) || (jspFile.toUpperCase().indexOf("/META-INF/") != 0)) throw new JspTagException("Invalid JSP file " + jspFile); InputStream in = pageContext.getServletContext().getResourceAsStream(jspFile); if (in == null) throw new JspTagException("Unable to find JSP file: " + jspFile); JspWriter out = pageContext.getOut(); try { out.println("<body>"); out.println("<pre>"); for (int ch = in.read(); ch != -1; ch = in.read()) if (ch == '<') out.print("&lt;"); else out.print((char) ch); out.println("</pre>"); out.println("</body>"); } catch (IOException ex) { throw new JspTagException("IOException: " + ex.toString()); } return super.doEndTag(); }	public int indexOfIgnoreCase(String s, int starting) { toString(); String upper = strValue.toUpperCase(); String sU = s.toUpperCase(); return upper.indexOf(sU, starting); }	protected String[] parseParamValues(StringBuilder cmd, int start, int count) { int valIndex = 0; boolean inside = false; String[] vals = new String[count]; StringBuilder sb = new StringBuilder(); char endQuote = 0; for (int bIdx = start; bIdx < cmd.length(); bIdx++) { if (!inside) { while (bIdx < cmd.length() && !isQuote(cmd.charAt(bIdx))) bIdx++; if (bIdx >= cmd.length()) break; inside = !inside; endQuote = cmd.charAt(bIdx); } else { boolean escaped = false; for (; bIdx < cmd.length(); bIdx++) { char c = cmd.charAt(bIdx); if (c == '\\' && !escaped) { escaped = true; continue; } if (c == endQuote && !escaped) break; if (c == '$' && escaped) sb.append('\\'); escaped = false; sb.append(c); } if (bIdx == cmd.length()) return null; vals[valIndex++] = sb.toString(); sb.delete(0, sb.length()); inside = !inside; } } return vals; }	public static ClassLoader createClassLoader(File[] unpacked, File[] packed, ClassLoader parent) throws Exception { if (log.isDebugEnabled()) log.debug("Creating new class loader"); Set<URL> set = new LinkedHashSet<URL>(); if (unpacked != null) { for (int i = 0; i < unpacked.length; i++) { File file = unpacked[i]; if (!file.exists() || !file.canRead()) continue; file = new File(file.getCanonicalPath() + File.separator); URL url = file.toURI().toURL(); if (log.isDebugEnabled()) log.debug(" Including directory " + url); set.add(url); } } if (packed != null) { for (int i = 0; i < packed.length; i++) { File directory = packed[i]; if (!directory.isDirectory() || !directory.exists() || !directory.canRead()) continue; String[] filenames = directory.list(); for (int j = 0; j < filenames.length; j++) { String filename = filenames[j].toLowerCase(); if (!filename.endsWith(".jar")) continue; File file = new File(directory, filenames[j]); if (log.isDebugEnabled()) log.debug(" Including jar file " + file.getAbsolutePath()); URL url = file.toURI().toURL(); set.add(url); } } } URL[] array = set.toArray(new URL[set.size()]); StandardClassLoader classLoader = null; if (parent == null) classLoader = new StandardClassLoader(array); else classLoader = new StandardClassLoader(array, parent); return (classLoader); }	public static ClassLoader createClassLoader(String[] locations, Integer[] types, ClassLoader parent) throws Exception { if (log.isDebugEnabled()) log.debug("Creating new class loader"); Set<URL> set = new LinkedHashSet<URL>(); if (locations != null && types != null && locations.length == types.length) { for (int i = 0; i < locations.length; i++) { String location = locations[i]; if (types[i] == IS_URL) { URL url = new URL(location); if (log.isDebugEnabled()) log.debug(" Including URL " + url); set.add(url); } else if (types[i] == IS_DIR) { File directory = new File(location); directory = new File(directory.getCanonicalPath()); if (!directory.exists() || !directory.isDirectory() || !directory.canRead()) continue; URL url = directory.toURI().toURL(); if (log.isDebugEnabled()) log.debug(" Including directory " + url); set.add(url); } else if (types[i] == IS_JAR) { File file = new File(location); file = new File(file.getCanonicalPath()); if (!file.exists() || !file.canRead()) continue; URL url = file.toURI().toURL(); if (log.isDebugEnabled()) log.debug(" Including jar file " + url); set.add(url); } else if (types[i] == IS_GLOB) { File directory = new File(location); if (!directory.exists() || !directory.isDirectory() || !directory.canRead()) continue; if (log.isDebugEnabled()) log.debug(" Including directory glob " + directory.getAbsolutePath()); String[] filenames = directory.list(); for (int j = 0; j < filenames.length; j++) { String filename = filenames[j].toLowerCase(); if (!filename.endsWith(".jar")) continue; File file = new File(directory, filenames[j]); file = new File(file.getCanonicalPath()); if (!file.exists() || !file.canRead()) continue; if (log.isDebugEnabled()) log.debug(" Including glob jar file " + file.getAbsolutePath()); URL url = file.toURI().toURL(); set.add(url); } } } } URL[] array = set.toArray(new URL[set.size()]); if (log.isDebugEnabled()) for (int i = 0; i < array.length; i++) { log.debug(" location " + i + " is " + array[i]); } StandardClassLoader classLoader = null; if (parent == null) classLoader = new StandardClassLoader(array); else classLoader = new StandardClassLoader(array, parent); return (classLoader); }	public static Locale guessLocaleFromSession(final HttpSession in_session) { if (null == in_session) { return null; } try { Locale locale = null; for (int i = 0; i < LOCALE_TEST_ATTRIBUTES.length; ++i) { Object obj = in_session.getAttribute(LOCALE_TEST_ATTRIBUTES[i]); if (null != obj && obj instanceof Locale) { locale = (Locale) obj; break; } obj = in_session.getAttribute(LOCALE_TEST_ATTRIBUTES[i].toLowerCase()); if (null != obj && obj instanceof Locale) { locale = (Locale) obj; break; } obj = in_session.getAttribute(LOCALE_TEST_ATTRIBUTES[i].toUpperCase()); if (null != obj && obj instanceof Locale) { locale = (Locale) obj; break; } } if (null != locale) { return locale; } // Tapestry 3.0: Engine stored in session under "org.apache.tapestry.engine:" + config.getServletName() { final List<Object> tapestryArray = new ArrayList<Object>(); for (Enumeration<String> enumeration = in_session.getAttributeNames(); enumeration.hasMoreElements(); ) { String name = enumeration.nextElement(); if (name.indexOf("tapestry") > -1 && name.indexOf("engine") > -1 && null != in_session.getAttribute(name)) { tapestryArray.add(in_session.getAttribute(name)); } } if (tapestryArray.size() == 1) { Object probableEngine = tapestryArray.get(0); if (null != probableEngine) { try { Method readMethod = probableEngine.getClass().getMethod("getLocale", (Class<?>[]) null); if (null != readMethod) { Object possibleLocale = readMethod.invoke(probableEngine, (Object[]) null); if (null != possibleLocale && possibleLocale instanceof Locale) { locale = (Locale) possibleLocale; } } } catch (Exception e) { // stay silent } } } } if (null != locale) { return locale; } // Last guess: iterate over all attributes, to find a Locale { final List<Object> localeArray = new ArrayList<Object>(); for (Enumeration<String> enumeration = in_session.getAttributeNames(); enumeration.hasMoreElements(); ) { String name = enumeration.nextElement(); Object obj = in_session.getAttribute(name); if (null != obj && obj instanceof Locale) { localeArray.add(obj); } } if (localeArray.size() == 1) { locale = (Locale) localeArray.get(0); } } return locale; } catch (IllegalStateException ise) { return null; } }	public static Object guessUserFromSession(final Session in_session) { if (null == in_session) { return null; } if (in_session.getPrincipal() != null) { return in_session.getPrincipal().getName(); } HttpSession httpSession = in_session.getSession(); try { Object user = null; for (int i = 0; i < USER_TEST_ATTRIBUTES.length; ++i) { Object obj = httpSession.getAttribute(USER_TEST_ATTRIBUTES[i]); if (null != obj) { user = obj; break; } obj = httpSession.getAttribute(USER_TEST_ATTRIBUTES[i].toLowerCase()); if (null != obj) { user = obj; break; } obj = httpSession.getAttribute(USER_TEST_ATTRIBUTES[i].toUpperCase()); if (null != obj) { user = obj; break; } } if (null != user) { return user; } // Last guess: iterate over all attributes, to find a java.security.Principal or javax.security.auth.Subject { final List<Object> principalArray = new ArrayList<Object>(); for (Enumeration<String> enumeration = httpSession.getAttributeNames(); enumeration.hasMoreElements(); ) { String name = enumeration.nextElement(); Object obj = httpSession.getAttribute(name); if (null != obj && (obj instanceof Principal || obj instanceof Subject)) { principalArray.add(obj); } } if (principalArray.size() == 1) { user = principalArray.get(0); } } if (null != user) { return user; } return user; } catch (IllegalStateException ise) { return null; } }	public static String caps(String text) { return text.toUpperCase(); }	public static String convert(String mimeCharsetName) { return s_enchash.get(mimeCharsetName.toUpperCase()); }	public static String reverse(String encoding) { return s_revhash.get(encoding.toUpperCase()); }	public static final boolean isMultipartContent(RequestContext ctx) { String contentType = ctx.getContentType(); if (contentType == null) { return false; } if (contentType.toLowerCase().startsWith(MULTIPART)) { return true; } return false; }	public static final boolean isMultipartContent(HttpServletRequest request) { if (!"post".equals(request.getMethod().toLowerCase())) { return false; } String contentType = request.getContentType(); if (contentType == null) { return false; } if (contentType.toLowerCase().startsWith(MULTIPART)) { return true; } return false; }	public static synchronized boolean validateApplication(DirContext dirContext, Context context) throws IOException { String appName = context.getPath(); ArrayList<ManifestResource> appManifestResources = new ArrayList<ManifestResource>(); if (dirContext == null) return false; InputStream inputStream = null; try { NamingEnumeration<Binding> wne = dirContext.listBindings("/META-INF/"); Binding binding = wne.nextElement(); if (binding.getName().toUpperCase().equals("MANIFEST.MF")) { Resource resource = (Resource) dirContext.lookup("/META-INF/" + binding.getName()); inputStream = resource.streamContent(); Manifest manifest = new Manifest(inputStream); inputStream.close(); inputStream = null; ManifestResource mre = new ManifestResource(sm.getString("extensionValidator.web-application-manifest"), manifest, ManifestResource.WAR); appManifestResources.add(mre); } } catch (NamingException nex) { // Application does not contain a MANIFEST.MF file } catch (NoSuchElementException nse) { // Application does not contain a MANIFEST.MF file } finally { if (inputStream != null) { try { inputStream.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } } NamingEnumeration<Binding> ne = null; try { ne = dirContext.listBindings("WEB-INF/lib/"); while ((ne != null) && ne.hasMoreElements()) { Binding binding = ne.nextElement(); if (!binding.getName().toLowerCase().endsWith(".jar")) { continue; } Object obj = dirContext.lookup("/WEB-INF/lib/" + binding.getName()); if (!(obj instanceof Resource)) { continue; } Resource resource = (Resource) obj; inputStream = resource.streamContent(); Manifest jmanifest = getManifest(inputStream); if (jmanifest != null) { ManifestResource mre = new ManifestResource(binding.getName(), jmanifest, ManifestResource.APPLICATION); appManifestResources.add(mre); } } } catch (NamingException nex) { // Jump out of the check for this application because it // has no resources } finally { if (inputStream != null) { try { inputStream.close(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); } } } return validateManifestResources(appName, appManifestResources); }	public void addAlias(String alias) { alias = alias.toLowerCase(); synchronized (aliasesLock) { for (int i = 0; i < aliases.length; i++) { if (aliases[i].equals(alias)) return; } String[] newAliases = new String[aliases.length + 1]; for (int i = 0; i < aliases.length; i++) newAliases[i] = aliases[i]; newAliases[aliases.length] = alias; aliases = newAliases; } fireContainerEvent(ADD_ALIAS_EVENT, alias); }	@Override public void addDateHeader(String name, long value) { super.addDateHeader(name, value); String lname = name.toLowerCase(); if (lname.equals(LAST_MODIFIED)) { lastModified = value; } }	@Override public void addHeader(String name, String value) { super.addHeader(name, value); String lname = name.toLowerCase(); if (lname.equals(LAST_MODIFIED)) { try { synchronized (RFC1123_FORMAT) { lastModified = RFC1123_FORMAT.parse(value).getTime(); } } catch (Throwable ignore) { ExceptionUtils.handleThrowable(ignore); } } else if (lname.equals(CONTENT_TYPE)) { contentType = value; } }	public void removeAlias(String alias) { alias = alias.toLowerCase(); synchronized (aliasesLock) { int n = -1; for (int i = 0; i < aliases.length; i++) { if (aliases[i].equals(alias)) { n = i; break; } } if (n < 0) return; int j = 0; String[] results = new String[aliases.length - 1]; for (int i = 0; i < aliases.length; i++) { if (i != n) results[j++] = aliases[i]; } aliases = results; } fireContainerEvent(REMOVE_ALIAS_EVENT, alias); }	@Override public void setDateHeader(String name, long value) { super.setDateHeader(name, value); String lname = name.toLowerCase(); if (lname.equals(LAST_MODIFIED)) { lastModified = value; } }	public void setDefaultHost(String host) { String oldDefaultHost = this.defaultHost; if (host == null) { this.defaultHost = null; } else { this.defaultHost = host.toLowerCase(); } support.firePropertyChange("defaultHost", oldDefaultHost, this.defaultHost); }	public void setDispatcher(String dispatcherString) { String dispatcher = dispatcherString.toUpperCase(); if (dispatcher.equals(DispatcherType.FORWARD.name())) { dispatcherMapping |= FORWARD; } else if (dispatcher.equals(DispatcherType.INCLUDE.name())) { dispatcherMapping |= INCLUDE; } else if (dispatcher.equals(DispatcherType.REQUEST.name())) { dispatcherMapping |= REQUEST; } else if (dispatcher.equals(DispatcherType.ERROR.name())) { dispatcherMapping |= ERROR; } else if (dispatcher.equals(DispatcherType.ASYNC.name())) { dispatcherMapping |= ASYNC; } }	@Override public void setHeader(String name, String value) { super.setHeader(name, value); String lname = name.toLowerCase(); if (lname.equals(LAST_MODIFIED)) { try { synchronized (RFC1123_FORMAT) { lastModified = RFC1123_FORMAT.parse(value).getTime(); } } catch (Throwable ignore) { ExceptionUtils.handleThrowable(ignore); } } }	public void setHeaders(FileItemHeaders pHeaders) { headers = pHeaders; }	public void setImpact(String impact) { if (impact == null) this.impact = null; else this.impact = impact.toUpperCase(); }	public Map<String, String> parse(final char[] inputChars, int offset, int length, char separator) { if (inputChars == null) { return new HashMap<String, String>(); } HashMap<String, String> params = new HashMap<String, String>(); this.chars = inputChars; this.pos = offset; this.len = length; String paramName = null; String paramValue = null; while (hasChar()) { paramName = parseToken(new char[] { '=', separator }); paramValue = null; if (hasChar() && (chars[pos] == '=')) { pos++; paramValue = parseQuotedToken(new char[] { separator }); } if (hasChar() && (chars[pos] == separator)) { pos++; } if ((paramName != null) && (paramName.length() > 0)) { if (this.lowerCaseNames) { paramName = paramName.toLowerCase(); } params.put(paramName, paramValue); } } return params; }	@Override public void setName(String name) { if (name == null) throw new IllegalArgumentException(sm.getString("standardHost.nullName")); name = name.toLowerCase(); String oldName = this.name; this.name = name; support.firePropertyChange("name", oldName, this.name); }	protected TrustManager[] getTrustManagers(String keystoreType, String keystoreProvider, String algorithm) throws Exception { String crlf = (String) attributes.get(AbstractEndpoint.SSL_ATTR_CRL_FILE); TrustManager[] tms = null; KeyStore trustStore = getTrustStore(keystoreType, keystoreProvider); if (trustStore != null) { if (crlf == null) { TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm); tmf.init(trustStore); tms = tmf.getTrustManagers(); } else { TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm); CertPathParameters params = getParameters(algorithm, crlf, trustStore); ManagerFactoryParameters mfp = new CertPathTrustManagerParameters(params); tmf.init(mfp); tms = tmf.getTrustManagers(); } } return tms; }
protected void prepareRequest() { http11 = true; http09 = false; contentDelimitation = false; expectation = false; sendfileData = null; if (ssl) { request.scheme().setString("https"); } MessageBytes protocolMB = request.protocol(); if (protocolMB.equals(Constants.HTTP_11)) { http11 = true; protocolMB.setString(Constants.HTTP_11); } else if (protocolMB.equals(Constants.HTTP_10)) { http11 = false; keepAlive = false; protocolMB.setString(Constants.HTTP_10); } else if (protocolMB.equals("")) { http09 = true; http11 = false; keepAlive = false; } else { http11 = false; error = true; response.setStatus(505); } MessageBytes methodMB = request.method(); if (methodMB.equals(Constants.GET)) { methodMB.setString(Constants.GET); } else if (methodMB.equals(Constants.POST)) { methodMB.setString(Constants.POST); } MimeHeaders headers = request.getMimeHeaders(); MessageBytes connectionValueMB = headers.getValue("connection"); if (connectionValueMB != null) { ByteChunk connectionValueBC = connectionValueMB.getByteChunk(); if (findBytes(connectionValueBC, Constants.CLOSE_BYTES) != -1) { keepAlive = false; } else if (findBytes(connectionValueBC, Constants.KEEPALIVE_BYTES) != -1) { keepAlive = true; } } MessageBytes expectMB = null; if (http11) expectMB = headers.getValue("expect"); if ((expectMB != null) && (expectMB.indexOfIgnoreCase("100-continue", 0) != -1)) { inputBuffer.setSwallowInput(false); expectation = true; } if ((restrictedUserAgents != null) && ((http11) || (keepAlive))) { MessageBytes userAgentValueMB = headers.getValue("user-agent"); if (userAgentValueMB != null) { String userAgentValue = userAgentValueMB.toString(); for (int i = 0; i < restrictedUserAgents.length; i++) { if (restrictedUserAgents[i].matcher(userAgentValue).matches()) { http11 = false; keepAlive = false; break; } } } } ByteChunk uriBC = request.requestURI().getByteChunk(); if (uriBC.startsWithIgnoreCase("http", 0)) { int pos = uriBC.indexOf("://", 0, 3, 4); int uriBCStart = uriBC.getStart(); int slashPos = -1; if (pos != -1) { byte[] uriB = uriBC.getBytes(); slashPos = uriBC.indexOf('/', pos + 3); if (slashPos == -1) { slashPos = uriBC.getLength(); request.requestURI().setBytes(uriB, uriBCStart + pos + 1, 1); } else { request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos); } MessageBytes hostMB = headers.setValue("host"); hostMB.setBytes(uriB, uriBCStart + pos + 3, slashPos - pos - 3); } } InputFilter[] inputFilters = inputBuffer.getFilters(); MessageBytes transferEncodingValueMB = null; if (http11) transferEncodingValueMB = headers.getValue("transfer-encoding"); if (transferEncodingValueMB != null) { String transferEncodingValue = transferEncodingValueMB.toString(); int startPos = 0; int commaPos = transferEncodingValue.indexOf(','); String encodingName = null; while (commaPos != -1) { encodingName = transferEncodingValue.substring(startPos, commaPos).toLowerCase().trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; response.setStatus(501); } startPos = commaPos + 1; commaPos = transferEncodingValue.indexOf(',', startPos); } encodingName = transferEncodingValue.substring(startPos).toLowerCase().trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; response.setStatus(501); } } long contentLength = request.getContentLengthLong(); if (contentLength >= 0 && !contentDelimitation) { inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } MessageBytes valueMB = headers.getValue("host"); if (http11 && (valueMB == null)) { error = true; response.setStatus(400); } parseHost(valueMB); if (!contentDelimitation) { // If there's no content length // (broken HTTP/1.0 or HTTP/1.1), assume inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } if (endpoint.getUseSendfile()) { request.setAttribute("org.apache.tomcat.sendfile.support", Boolean.TRUE); } request.setAttribute("org.apache.tomcat.comet.support", Boolean.TRUE); }	protected void prepareRequest() { http11 = true; http09 = false; contentDelimitation = false; expectation = false; sendfileData = null; if (ssl) { request.scheme().setString("https"); } MessageBytes protocolMB = request.protocol(); if (protocolMB.equals(Constants.HTTP_11)) { http11 = true; protocolMB.setString(Constants.HTTP_11); } else if (protocolMB.equals(Constants.HTTP_10)) { http11 = false; keepAlive = false; protocolMB.setString(Constants.HTTP_10); } else if (protocolMB.equals("")) { http09 = true; http11 = false; keepAlive = false; } else { http11 = false; error = true; response.setStatus(505); } MessageBytes methodMB = request.method(); if (methodMB.equals(Constants.GET)) { methodMB.setString(Constants.GET); } else if (methodMB.equals(Constants.POST)) { methodMB.setString(Constants.POST); } MimeHeaders headers = request.getMimeHeaders(); MessageBytes connectionValueMB = headers.getValue("connection"); if (connectionValueMB != null) { ByteChunk connectionValueBC = connectionValueMB.getByteChunk(); if (findBytes(connectionValueBC, Constants.CLOSE_BYTES) != -1) { keepAlive = false; } else if (findBytes(connectionValueBC, Constants.KEEPALIVE_BYTES) != -1) { keepAlive = true; } } MessageBytes expectMB = null; if (http11) expectMB = headers.getValue("expect"); if ((expectMB != null) && (expectMB.indexOfIgnoreCase("100-continue", 0) != -1)) { inputBuffer.setSwallowInput(false); expectation = true; } if ((restrictedUserAgents != null) && ((http11) || (keepAlive))) { MessageBytes userAgentValueMB = headers.getValue("user-agent"); if (userAgentValueMB != null) { String userAgentValue = userAgentValueMB.toString(); for (int i = 0; i < restrictedUserAgents.length; i++) { if (restrictedUserAgents[i].matcher(userAgentValue).matches()) { http11 = false; keepAlive = false; break; } } } } ByteChunk uriBC = request.requestURI().getByteChunk(); if (uriBC.startsWithIgnoreCase("http", 0)) { int pos = uriBC.indexOf("://", 0, 3, 4); int uriBCStart = uriBC.getStart(); int slashPos = -1; if (pos != -1) { byte[] uriB = uriBC.getBytes(); slashPos = uriBC.indexOf('/', pos + 3); if (slashPos == -1) { slashPos = uriBC.getLength(); request.requestURI().setBytes(uriB, uriBCStart + pos + 1, 1); } else { request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos); } MessageBytes hostMB = headers.setValue("host"); hostMB.setBytes(uriB, uriBCStart + pos + 3, slashPos - pos - 3); } } InputFilter[] inputFilters = inputBuffer.getFilters(); MessageBytes transferEncodingValueMB = null; if (http11) transferEncodingValueMB = headers.getValue("transfer-encoding"); if (transferEncodingValueMB != null) { String transferEncodingValue = transferEncodingValueMB.toString(); int startPos = 0; int commaPos = transferEncodingValue.indexOf(','); String encodingName = null; while (commaPos != -1) { encodingName = transferEncodingValue.substring(startPos, commaPos).toLowerCase().trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; response.setStatus(501); } startPos = commaPos + 1; commaPos = transferEncodingValue.indexOf(',', startPos); } encodingName = transferEncodingValue.substring(startPos).toLowerCase().trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; response.setStatus(501); } } long contentLength = request.getContentLengthLong(); if (contentLength >= 0 && !contentDelimitation) { inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } MessageBytes valueMB = headers.getValue("host"); if (http11 && (valueMB == null)) { error = true; response.setStatus(400); } parseHost(valueMB); if (!contentDelimitation) { // If there's no content length // (broken HTTP/1.0 or HTTP/1.1), assume inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } if (endpoint.getUseSendfile()) request.setAttribute("org.apache.tomcat.sendfile.support", Boolean.TRUE); request.setAttribute("org.apache.tomcat.comet.support", Boolean.TRUE); request.setAttribute("org.apache.tomcat.comet.timeout.support", Boolean.TRUE); }	protected void prepareRequest() { http11 = true; http09 = false; contentDelimitation = false; expectation = false; if (sslSupport != null) { request.scheme().setString("https"); } MessageBytes protocolMB = request.protocol(); if (protocolMB.equals(Constants.HTTP_11)) { http11 = true; protocolMB.setString(Constants.HTTP_11); } else if (protocolMB.equals(Constants.HTTP_10)) { http11 = false; keepAlive = false; protocolMB.setString(Constants.HTTP_10); } else if (protocolMB.equals("")) { http09 = true; http11 = false; keepAlive = false; } else { http11 = false; error = true; if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare") + " Unsupported HTTP version \"" + protocolMB + "\""); } response.setStatus(505); } MessageBytes methodMB = request.method(); if (methodMB.equals(Constants.GET)) { methodMB.setString(Constants.GET); } else if (methodMB.equals(Constants.POST)) { methodMB.setString(Constants.POST); } MimeHeaders headers = request.getMimeHeaders(); MessageBytes connectionValueMB = headers.getValue("connection"); if (connectionValueMB != null) { ByteChunk connectionValueBC = connectionValueMB.getByteChunk(); if (findBytes(connectionValueBC, Constants.CLOSE_BYTES) != -1) { keepAlive = false; } else if (findBytes(connectionValueBC, Constants.KEEPALIVE_BYTES) != -1) { keepAlive = true; } } MessageBytes expectMB = null; if (http11) expectMB = headers.getValue("expect"); if ((expectMB != null) && (expectMB.indexOfIgnoreCase("100-continue", 0) != -1)) { inputBuffer.setSwallowInput(false); expectation = true; } if ((restrictedUserAgents != null) && ((http11) || (keepAlive))) { MessageBytes userAgentValueMB = headers.getValue("user-agent"); if (userAgentValueMB != null) { String userAgentValue = userAgentValueMB.toString(); for (int i = 0; i < restrictedUserAgents.length; i++) { if (restrictedUserAgents[i].matcher(userAgentValue).matches()) { http11 = false; keepAlive = false; break; } } } } ByteChunk uriBC = request.requestURI().getByteChunk(); if (uriBC.startsWithIgnoreCase("http", 0)) { int pos = uriBC.indexOf("://", 0, 3, 4); int uriBCStart = uriBC.getStart(); int slashPos = -1; if (pos != -1) { byte[] uriB = uriBC.getBytes(); slashPos = uriBC.indexOf('/', pos + 3); if (slashPos == -1) { slashPos = uriBC.getLength(); request.requestURI().setBytes(uriB, uriBCStart + pos + 1, 1); } else { request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos); } MessageBytes hostMB = headers.setValue("host"); hostMB.setBytes(uriB, uriBCStart + pos + 3, slashPos - pos - 3); } } InputFilter[] inputFilters = inputBuffer.getFilters(); MessageBytes transferEncodingValueMB = null; if (http11) transferEncodingValueMB = headers.getValue("transfer-encoding"); if (transferEncodingValueMB != null) { String transferEncodingValue = transferEncodingValueMB.toString(); int startPos = 0; int commaPos = transferEncodingValue.indexOf(','); String encodingName = null; while (commaPos != -1) { encodingName = transferEncodingValue.substring(startPos, commaPos).toLowerCase().trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; response.setStatus(501); } startPos = commaPos + 1; commaPos = transferEncodingValue.indexOf(',', startPos); } encodingName = transferEncodingValue.substring(startPos).toLowerCase().trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare") + " Unsupported transfer encoding \"" + encodingName + "\""); } response.setStatus(501); } } long contentLength = request.getContentLengthLong(); if (contentLength >= 0 && !contentDelimitation) { inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } MessageBytes valueMB = headers.getValue("host"); if (http11 && (valueMB == null)) { error = true; if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare") + " host header missing"); } response.setStatus(400); } parseHost(valueMB); if (!contentDelimitation) { // If there's no content length // (broken HTTP/1.0 or HTTP/1.1), assume inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } }
private String comparePageEncodings(String thePageDirEnc, Node.PageDirective pageDir) throws JasperException { Node.Root root = pageDir.getRoot(); String configEnc = root.getJspConfigPageEncoding(); String pageDirEnc = thePageDirEnc.toUpperCase(); if (configEnc != null) { configEnc = configEnc.toUpperCase(); if (!pageDirEnc.equals(configEnc) && (!pageDirEnc.startsWith("UTF-16") || !configEnc.startsWith("UTF-16"))) { err.jspError(pageDir, "jsp.error.config_pagedir_encoding_mismatch", configEnc, pageDirEnc); } else { return configEnc; } } if ((root.isXmlSyntax() && root.isEncodingSpecifiedInProlog()) || root.isBomPresent()) { String pageEnc = root.getPageEncoding().toUpperCase(); if (!pageDirEnc.equals(pageEnc) && (!pageDirEnc.startsWith("UTF-16") || !pageEnc.startsWith("UTF-16"))) { err.jspError(pageDir, "jsp.error.prolog_pagedir_encoding_mismatch", pageEnc, pageDirEnc); } else { return pageEnc; } } return pageDirEnc; }	private void compareTagEncodings(String thePageDirEnc, Node.TagDirective pageDir) throws JasperException { Node.Root root = pageDir.getRoot(); String pageDirEnc = thePageDirEnc.toUpperCase(); if ((root.isXmlSyntax() && root.isEncodingSpecifiedInProlog()) || root.isBomPresent()) { String pageEnc = root.getPageEncoding().toUpperCase(); if (!pageDirEnc.equals(pageEnc) && (!pageDirEnc.startsWith("UTF-16") || !pageEnc.startsWith("UTF-16"))) { err.jspError(pageDir, "jsp.error.prolog_pagedir_encoding_mismatch", pageEnc, pageDirEnc); } } }	public static String getContentTypeAttribute(String input, String name) { int begin; int end; int index = input.toUpperCase().indexOf(name.toUpperCase()); if (index == -1) return null; index = index + name.length(); index = input.indexOf('=', index); if (index == -1) return null; index += 1; input = input.substring(index).trim(); if (input.charAt(0) == '"') { begin = 1; end = input.indexOf('"', begin); if (end == -1) return null; } else { begin = 0; end = input.indexOf(';'); if (end == -1) end = input.indexOf(' '); if (end == -1) end = input.length(); } return input.substring(begin, end).trim(); }
protected void checkHandlesTypes(JavaClass javaClass) { if (typeInitializerMap.size() == 0) return; String className = javaClass.getClassName(); Class<?> clazz = null; try { clazz = context.getLoader().getClassLoader().loadClass(className); } catch (NoClassDefFoundError e) { log.debug(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (ClassNotFoundException e) { log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry : typeInitializerMap.entrySet()) { if (entry.getKey().isAssignableFrom(clazz)) { for (ServletContainerInitializer sci : entry.getValue()) { initializerClassMap.get(sci).add(clazz); } } } }	protected void processAnnotationsStream(InputStream is, WebXml fragment) throws ClassFormatException, IOException { ClassParser parser = new ClassParser(is, null); JavaClass clazz = parser.parse(); checkHandlesTypes(clazz); String className = clazz.getClassName(); AnnotationEntry[] annotationsEntries = clazz.getAnnotationEntries(); for (AnnotationEntry ae : annotationsEntries) { String type = ae.getAnnotationType(); if ("Ljavax/servlet/annotation/WebServlet;".equals(type)) { processAnnotationWebServlet(className, ae, fragment); } else if ("Ljavax/servlet/annotation/WebFilter;".equals(type)) { processAnnotationWebFilter(className, ae, fragment); } else if ("Ljavax/servlet/annotation/WebListener;".equals(type)) { fragment.addListener(className); } else { // Unknown annotation - ignore } } }
protected void checkHandlesTypes(JavaClass javaClass) { if (typeInitializerMap.size() == 0) return; String className = javaClass.getClassName(); Class<?> clazz = null; try { clazz = Class.forName(className, true, context.getLoader().getClassLoader()); } catch (ClassNotFoundException e) { log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); } for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry : typeInitializerMap.entrySet()) { if (entry.getKey().isAssignableFrom(clazz)) { for (ServletContainerInitializer sci : entry.getValue()) { initializerClassMap.get(sci).add(clazz); } } } }

public static PoolConfiguration parsePoolProperties(Properties properties) throws IOException { PoolConfiguration poolProperties = new PoolProperties(); String value = null; value = properties.getProperty(PROP_DEFAULTAUTOCOMMIT); if (value != null) { poolProperties.setDefaultAutoCommit(Boolean.valueOf(value)); } value = properties.getProperty(PROP_DEFAULTREADONLY); if (value != null) { poolProperties.setDefaultReadOnly(Boolean.valueOf(value)); } value = properties.getProperty(PROP_DEFAULTTRANSACTIONISOLATION); if (value != null) { int level = UNKNOWN_TRANSACTIONISOLATION; if ("NONE".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_NONE; } else if ("READ_COMMITTED".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_READ_COMMITTED; } else if ("READ_UNCOMMITTED".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_READ_UNCOMMITTED; } else if ("REPEATABLE_READ".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_REPEATABLE_READ; } else if ("SERIALIZABLE".equalsIgnoreCase(value)) { level = Connection.TRANSACTION_SERIALIZABLE; } else { try { level = Integer.parseInt(value); } catch (NumberFormatException e) { System.err.println("Could not parse defaultTransactionIsolation: " + value); System.err.println("WARNING: defaultTransactionIsolation not set"); System.err.println("using default value of database driver"); level = UNKNOWN_TRANSACTIONISOLATION; } } poolProperties.setDefaultTransactionIsolation(level); } value = properties.getProperty(PROP_DEFAULTCATALOG); if (value != null) { poolProperties.setDefaultCatalog(value); } value = properties.getProperty(PROP_DRIVERCLASSNAME); if (value != null) { poolProperties.setDriverClassName(value); } value = properties.getProperty(PROP_MAXACTIVE); if (value != null) { poolProperties.setMaxActive(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXIDLE); if (value != null) { poolProperties.setMaxIdle(Integer.parseInt(value)); } value = properties.getProperty(PROP_MINIDLE); if (value != null) { poolProperties.setMinIdle(Integer.parseInt(value)); } value = properties.getProperty(PROP_INITIALSIZE); if (value != null) { poolProperties.setInitialSize(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXWAIT); if (value != null) { poolProperties.setMaxWait(Integer.parseInt(value)); } value = properties.getProperty(PROP_TESTONBORROW); if (value != null) { poolProperties.setTestOnBorrow(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TESTONRETURN); if (value != null) { poolProperties.setTestOnReturn(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TESTONCONNECT); if (value != null) { poolProperties.setTestOnConnect(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_TIMEBETWEENEVICTIONRUNSMILLIS); if (value != null) { poolProperties.setTimeBetweenEvictionRunsMillis(Integer.parseInt(value)); } value = properties.getProperty(PROP_NUMTESTSPEREVICTIONRUN); if (value != null) { poolProperties.setNumTestsPerEvictionRun(Integer.parseInt(value)); } value = properties.getProperty(PROP_MINEVICTABLEIDLETIMEMILLIS); if (value != null) { poolProperties.setMinEvictableIdleTimeMillis(Integer.parseInt(value)); } value = properties.getProperty(PROP_TESTWHILEIDLE); if (value != null) { poolProperties.setTestWhileIdle(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_PASSWORD); if (value != null) { poolProperties.setPassword(value); } value = properties.getProperty(PROP_URL); if (value != null) { poolProperties.setUrl(value); } value = properties.getProperty(PROP_USERNAME); if (value != null) { poolProperties.setUsername(value); } value = properties.getProperty(PROP_VALIDATIONQUERY); if (value != null) { poolProperties.setValidationQuery(value); } value = properties.getProperty(PROP_VALIDATIONINTERVAL); if (value != null) { poolProperties.setValidationInterval(Long.parseLong(value)); } value = properties.getProperty(PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED); if (value != null) { poolProperties.setAccessToUnderlyingConnectionAllowed(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_REMOVEABANDONED); if (value != null) { poolProperties.setRemoveAbandoned(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_REMOVEABANDONEDTIMEOUT); if (value != null) { poolProperties.setRemoveAbandonedTimeout(Integer.parseInt(value)); } value = properties.getProperty(PROP_LOGABANDONED); if (value != null) { poolProperties.setLogAbandoned(Boolean.valueOf(value).booleanValue()); } value = properties.getProperty(PROP_POOLPREPAREDSTATEMENTS); if (value != null) { log.warn(PROP_POOLPREPAREDSTATEMENTS + " is not a valid setting, it will have no effect."); } value = properties.getProperty(PROP_MAXOPENPREPAREDSTATEMENTS); if (value != null) { log.warn(PROP_MAXOPENPREPAREDSTATEMENTS + " is not a valid setting, it will have no effect."); } value = properties.getProperty(PROP_CONNECTIONPROPERTIES); if (value != null) { Properties p = getProperties(value); poolProperties.setDbProperties(p); } else { poolProperties.setDbProperties(new Properties()); } if (poolProperties.getUsername() != null) { poolProperties.getDbProperties().setProperty("user", poolProperties.getUsername()); } if (poolProperties.getPassword() != null) { poolProperties.getDbProperties().setProperty("password", poolProperties.getPassword()); } value = properties.getProperty(PROP_INITSQL); if (value != null) { poolProperties.setInitSQL(value); } value = properties.getProperty(PROP_INTERCEPTORS); if (value != null) { poolProperties.setJdbcInterceptors(value); } value = properties.getProperty(PROP_JMX_ENABLED); if (value != null) { poolProperties.setJmxEnabled(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_FAIR_QUEUE); if (value != null) { poolProperties.setFairQueue(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_USE_EQUALS); if (value != null) { poolProperties.setUseEquals(Boolean.parseBoolean(value)); } value = properties.getProperty(OBJECT_NAME); if (value != null) { poolProperties.setName(ObjectName.quote(value)); } value = properties.getProperty(PROP_ABANDONWHENPERCENTAGEFULL); if (value != null) { poolProperties.setAbandonWhenPercentageFull(Integer.parseInt(value)); } value = properties.getProperty(PROP_MAXAGE); if (value != null) { poolProperties.setMaxAge(Long.parseLong(value)); } value = properties.getProperty(PROP_USE_CON_LOCK); if (value != null) { poolProperties.setUseLock(Boolean.parseBoolean(value)); } value = properties.getProperty(PROP_DATASOURCE); if (value != null) { throw new IllegalArgumentException("Can't set dataSource property as a string, this must be a javax.sql.DataSource object."); } value = properties.getProperty(PROP_DATASOURCE_JNDI); if (value != null) { poolProperties.setDataSourceJNDI(value); } return poolProperties; }
public static void displayClassPath(String msg, URL[] cp) { if (log.isDebugEnabled()) { log.debug(msg); for (int i = 0; i < cp.length; i++) { log.debug(cp[i].getFile()); } } }
@Override public Collection<String> getUrlPatternMappings() { Collection<String> result = new HashSet<String>(); FilterMap[] filterMaps = context.findFilterMaps(); for (FilterMap filterMap : filterMaps) { if (filterMap.getFilterName().equals(filterDef.getFilterName())) { for (String urlPattern : filterMap.getURLPatterns()) { result.add(urlPattern); } } } return result; }
public void addFilterMapBefore(FilterMap filterMap) { validateFilterMap(filterMap); synchronized (filterMapsLock) { FilterMap[] results = new FilterMap[filterMaps.length + 1]; System.arraycopy(filterMaps, 0, results, 0, filterMapInsertPoint); results[filterMapInsertPoint] = filterMap; System.arraycopy(filterMaps, filterMapInsertPoint, results, filterMaps.length - filterMapInsertPoint + 1, filterMaps.length - filterMapInsertPoint); filterMapInsertPoint++; filterMaps = results; } fireContainerEvent("addFilterMap", filterMap); }
public static Node.Nodes parse(ParserController pc, JspReader reader, Node parent, boolean isTagFile, boolean directivesOnly, URL jarFileUrl, String pageEnc, String jspConfigPageEnc, boolean isDefaultPageEncoding, boolean isBomPresent) throws JasperException { Parser parser = new Parser(pc, reader, isTagFile, directivesOnly, jarFileUrl); Node.Root root = new Node.Root(reader.mark(), parent, false); root.setPageEncoding(pageEnc); root.setJspConfigPageEncoding(jspConfigPageEnc); root.setIsDefaultPageEncoding(isDefaultPageEncoding); root.setIsBomPresent(isBomPresent); PageInfo pageInfo = pc.getCompiler().getPageInfo(); if (parent == null && !isTagFile) { parser.addInclude(root, pageInfo.getIncludePrelude()); } if (directivesOnly) { parser.parseFileDirectives(root); } else { while (reader.hasMoreInput()) { parser.parseElements(root); } } if (parent == null && !isTagFile) { parser.addInclude(root, pageInfo.getIncludeCoda()); } Node.Nodes page = new Node.Nodes(root); return page; }	private TagFileInfo createTagFileInfo(TreeNode elem, URL jarFileUrl) throws JasperException { String name = null; String path = null; Iterator<TreeNode> list = elem.findChildren(); while (list.hasNext()) { TreeNode child = list.next(); String tname = child.getName(); if ("name".equals(tname)) { name = child.getBody(); } else if ("path".equals(tname)) { path = child.getBody(); } else if ("example".equals(tname)) { // Ignore <example> element: Bugzilla 33538 } else if ("tag-extension".equals(tname)) { // Ignore <tag-extension> element: Bugzilla 33538 } else if ("icon".equals(tname) || "display-name".equals(tname) || "description".equals(tname)) { // Ignore these elements: Bugzilla 38015 } else { if (log.isWarnEnabled()) { log.warn(Localizer.getMessage("jsp.warning.unknown.element.in.tagfile", tname)); } } } if (path.startsWith("/META-INF/tags")) { // Tag file packaged in JAR // See https://issues.apache.org/bugzilla/show_bug.cgi?id=46471 // This needs to be removed once all the broken code that depends on ctxt.setTagFileJarUrl(path, jarFileUrl); } else if (!path.startsWith("/WEB-INF/tags")) { err.jspError("jsp.error.tagfile.illegalPath", path); } TagInfo tagInfo = TagFileProcessor.parseTagFileDirectives(parserController, name, path, jarFileUrl, this); return new TagFileInfo(name, path, tagInfo); }	private TagInfo createTagInfo(TreeNode elem, String jspVersion) throws JasperException { String tagName = null; String tagClassName = null; String teiClassName = null; String bodycontent = "JSP"; String info = null; String displayName = null; String smallIcon = null; String largeIcon = null; boolean dynamicAttributes = false; Vector<TagAttributeInfo> attributeVector = new Vector<TagAttributeInfo>(); Vector<TagVariableInfo> variableVector = new Vector<TagVariableInfo>(); Iterator<TreeNode> list = elem.findChildren(); while (list.hasNext()) { TreeNode element = list.next(); String tname = element.getName(); if ("name".equals(tname)) { tagName = element.getBody(); } else if ("tagclass".equals(tname) || "tag-class".equals(tname)) { tagClassName = element.getBody(); } else if ("teiclass".equals(tname) || "tei-class".equals(tname)) { teiClassName = element.getBody(); } else if ("bodycontent".equals(tname) || "body-content".equals(tname)) { bodycontent = element.getBody(); } else if ("display-name".equals(tname)) { displayName = element.getBody(); } else if ("small-icon".equals(tname)) { smallIcon = element.getBody(); } else if ("large-icon".equals(tname)) { largeIcon = element.getBody(); } else if ("icon".equals(tname)) { TreeNode icon = element.findChild("small-icon"); if (icon != null) { smallIcon = icon.getBody(); } icon = element.findChild("large-icon"); if (icon != null) { largeIcon = icon.getBody(); } } else if ("info".equals(tname) || "description".equals(tname)) { info = element.getBody(); } else if ("variable".equals(tname)) { variableVector.addElement(createVariable(element)); } else if ("attribute".equals(tname)) { attributeVector.addElement(createAttribute(element, jspVersion)); } else if ("dynamic-attributes".equals(tname)) { dynamicAttributes = JspUtil.booleanValue(element.getBody()); } else if ("example".equals(tname)) { // Ignored elements } else if ("tag-extension".equals(tname)) { // Ignored } else { if (log.isWarnEnabled()) { log.warn(Localizer.getMessage("jsp.warning.unknown.element.in.tag", tname)); } } } TagExtraInfo tei = null; if (teiClassName != null && !teiClassName.equals("")) { try { Class<?> teiClass = ctxt.getClassLoader().loadClass(teiClassName); tei = (TagExtraInfo) teiClass.newInstance(); } catch (Exception e) { err.jspError("jsp.error.teiclass.instantiation", teiClassName, e); } } TagAttributeInfo[] tagAttributeInfo = new TagAttributeInfo[attributeVector.size()]; attributeVector.copyInto(tagAttributeInfo); TagVariableInfo[] tagVariableInfos = new TagVariableInfo[variableVector.size()]; variableVector.copyInto(tagVariableInfos); TagInfo taginfo = new TagInfo(tagName, tagClassName, bodycontent, info, this, tei, tagAttributeInfo, displayName, smallIcon, largeIcon, tagVariableInfos, dynamicAttributes); return taginfo; }	private TagLibraryInfo getTaglibInfo(String prefix, String uri) throws JasperException { TagLibraryInfo result = null; if (uri.startsWith(URN_JSPTAGDIR)) { String tagdir = uri.substring(URN_JSPTAGDIR.length()); result = new ImplicitTagLibraryInfo(ctxt, parserController, pageInfo, prefix, tagdir, err); } else { boolean isPlainUri = false; if (uri.startsWith(URN_JSPTLD)) { uri = uri.substring(URN_JSPTLD.length()); } else { isPlainUri = true; } String[] location = ctxt.getTldLocation(uri); if (location != null || !isPlainUri) { if (ctxt.getOptions().isCaching()) { result = ctxt.getOptions().getCache().get(uri); } if (result == null) { result = new TagLibraryInfoImpl(ctxt, parserController, pageInfo, prefix, uri, location, err); if (ctxt.getOptions().isCaching()) { ctxt.getOptions().getCache().put(uri, result); } } } } return result; }	private void parseTaglibDirective(Node parent) throws JasperException { Attributes attrs = parseAttributes(); String uri = attrs.getValue("uri"); String prefix = attrs.getValue("prefix"); if (prefix != null) { Mark prevMark = pageInfo.getNonCustomTagPrefix(prefix); if (prevMark != null) { err.jspError(reader.mark(), "jsp.error.prefix.use_before_dcl", prefix, prevMark.getFile(), "" + prevMark.getLineNumber()); } if (uri != null) { String uriPrev = pageInfo.getURI(prefix); if (uriPrev != null && !uriPrev.equals(uri)) { err.jspError(reader.mark(), "jsp.error.prefix.refined", prefix, uri, uriPrev); } if (pageInfo.getTaglib(uri) == null) { TagLibraryInfoImpl impl = null; if (ctxt.getOptions().isCaching()) { impl = (TagLibraryInfoImpl) ctxt.getOptions().getCache().get(uri); } if (impl == null) { String[] location = ctxt.getTldLocation(uri); impl = new TagLibraryInfoImpl(ctxt, parserController, pageInfo, prefix, uri, location, err); if (ctxt.getOptions().isCaching()) { ctxt.getOptions().getCache().put(uri, impl); } } else { for (TagFileInfo info : impl.getTagFiles()) { ctxt.setTagFileJarUrl(info.getPath(), ctxt.getTagFileJarUrl()); } } pageInfo.addTaglib(uri, impl); } pageInfo.addPrefixMapping(prefix, uri); } else { String tagdir = attrs.getValue("tagdir"); if (tagdir != null) { String urnTagdir = URN_JSPTAGDIR + tagdir; if (pageInfo.getTaglib(urnTagdir) == null) { pageInfo.addTaglib(urnTagdir, new ImplicitTagLibraryInfo(ctxt, parserController, pageInfo, prefix, tagdir, err)); } pageInfo.addPrefixMapping(prefix, urnTagdir); } } } new Node.TaglibDirective(attrs, start, parent); }	private void processIncludeDirective(String file, Node parent) throws JasperException { if (file == null) { return; } try { parserController.parse(file, parent, jarFileUrl); } catch (FileNotFoundException ex) { err.jspError(start, "jsp.error.file.not.found", file); } catch (Exception ex) { err.jspError(start, ex.getMessage()); } }	private void tldScanStream(String resourcePath, String entryName, InputStream stream) throws IOException { try { String uri = null; TreeNode tld = new ParserUtils().parseXMLDocument(resourcePath, stream); TreeNode uriNode = tld.findChild("uri"); if (uriNode != null) { String body = uriNode.getBody(); if (body != null) uri = body; } if (uri != null && mappings.get(uri) == null) { mappings.put(uri, new String[] { resourcePath, entryName }); } } catch (JasperException e) { throw new IOException(e); } finally { if (stream != null) { try { stream.close(); } catch (Throwable t) { // do nothing } } } }	void tldScanWebXml() throws Exception { WebXml webXml = null; try { webXml = new WebXml(ctxt); TreeNode webtld = null; webtld = new ParserUtils().parseXMLDocument(webXml.getSystemId(), webXml.getInputSource()); TreeNode jspConfig = webtld.findChild("jsp-config"); if (jspConfig != null) { webtld = jspConfig; } Iterator<TreeNode> taglibs = webtld.findChildren("taglib"); while (taglibs.hasNext()) { TreeNode taglib = taglibs.next(); String tagUri = null; String tagLoc = null; TreeNode child = taglib.findChild("taglib-uri"); if (child != null) tagUri = child.getBody(); child = taglib.findChild("taglib-location"); if (child != null) tagLoc = child.getBody(); if (tagLoc == null) continue; if (uriType(tagLoc) == NOROOT_REL_URI) tagLoc = "/WEB-INF/" + tagLoc; String tagLoc2 = null; if (tagLoc.endsWith(JAR_EXT)) { tagLoc = ctxt.getResource(tagLoc).toString(); tagLoc2 = "META-INF/taglib.tld"; } mappings.put(tagUri, new String[] { tagLoc, tagLoc2 }); } } finally { if (webXml != null) { webXml.close(); } } }	private Node.Nodes doParse(String inFileName, Node parent, URL jarFileUrl) throws FileNotFoundException, JasperException, IOException { Node.Nodes parsedPage = null; isEncodingSpecifiedInProlog = false; isBomPresent = false; isDefaultPageEncoding = false; JarFile jarFile = getJarFile(jarFileUrl); String absFileName = resolveFileName(inFileName); String jspConfigPageEnc = getJspConfigPageEncoding(absFileName); // Figure out what type of JSP document and encoding type we are determineSyntaxAndEncoding(absFileName, jarFile, jspConfigPageEnc); if (parent != null) { if (jarFile == null) { compiler.getPageInfo().addDependant(absFileName); } else { compiler.getPageInfo().addDependant(jarFileUrl.toExternalForm() + absFileName.substring(1)); } } if ((isXml && isEncodingSpecifiedInProlog) || isBomPresent) { if (jspConfigPageEnc != null && !jspConfigPageEnc.equals(sourceEnc) && (!jspConfigPageEnc.startsWith("UTF-16") || !sourceEnc.startsWith("UTF-16"))) { err.jspError("jsp.error.prolog_config_encoding_mismatch", sourceEnc, jspConfigPageEnc); } } if (isXml) { // JSP document (XML syntax) // InputStream for jspx page is created and properly closed in parsedPage = JspDocumentParser.parse(this, absFileName, jarFile, parent, isTagFile, directiveOnly, sourceEnc, jspConfigPageEnc, isEncodingSpecifiedInProlog, isBomPresent); } else { InputStreamReader inStreamReader = null; try { inStreamReader = JspUtil.getReader(absFileName, sourceEnc, jarFile, ctxt, err, skip); JspReader jspReader = new JspReader(ctxt, absFileName, sourceEnc, inStreamReader, err); parsedPage = Parser.parse(this, jspReader, parent, isTagFile, directiveOnly, jarFileUrl, sourceEnc, jspConfigPageEnc, isDefaultPageEncoding, isBomPresent); } finally { if (inStreamReader != null) { try { inStreamReader.close(); } catch (Exception any) { } } } } if (jarFile != null) { try { jarFile.close(); } catch (Throwable t) { } } baseDirStack.pop(); return parsedPage; }	public String getRealPath(String path) { if (context != null) { return context.getRealPath(path); } return path; }	@Override public TagLibraryInfo[] getTagLibraryInfos() { Collection<TagLibraryInfo> coll = pi.getTaglibs(); return coll.toArray(new TagLibraryInfo[0]); }	@Override public TagLibraryInfo[] getTagLibraryInfos() { Collection<TagLibraryInfo> coll = pi.getTaglibs(); return coll.toArray(new TagLibraryInfo[0]); }	public Set<String> getResourcePaths(String path) { return context.getResourcePaths(canonicalURI(path)); }	public URL getTagFileJarUrl(String tagFile) { return this.tagFileJarUrls.get(tagFile); }	private Class<?> loadTagFile(Compiler compiler, String tagFilePath, TagInfo tagInfo, PageInfo parentPageInfo) throws JasperException { URL tagFileJarUrl = null; if (tagFilePath.startsWith("/META-INF/")) { try { tagFileJarUrl = new URL("jar:" + compiler.getCompilationContext().getTldLocation(tagInfo.getTagLibrary().getURI())[0] + "!/"); } catch (MalformedURLException e) { // Ignore - tagFileJarUrl will be null } } String tagFileJarPath; if (tagFileJarUrl == null) { tagFileJarPath = ""; } else { tagFileJarPath = tagFileJarUrl.toString(); } JspCompilationContext ctxt = compiler.getCompilationContext(); JspRuntimeContext rctxt = ctxt.getRuntimeContext(); String wrapperUri = tagFileJarPath + tagFilePath; JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri); synchronized (rctxt) { if (wrapper == null) { wrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), tagFileJarUrl); rctxt.addWrapper(wrapperUri, wrapper); wrapper.getJspEngineContext().setClassLoader(ctxt.getClassLoader()); wrapper.getJspEngineContext().setClassPath(ctxt.getClassPath()); } else { // Make sure that JspCompilationContext gets the latest TagInfo // for the tag file. TagInfo instance was created the last // time the tag file was scanned for directives, and the tag wrapper.getJspEngineContext().setTagInfo(tagInfo); } Class<?> tagClazz; int tripCount = wrapper.incTripCount(); try { if (tripCount > 0) { // When tripCount is greater than zero, a circular // dependency exists. The circularly dependent tag // file is compiled in prototype mode, to avoid infinite JspServletWrapper tempWrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), ctxt.getTagFileJarUrl(tagFilePath)); tagClazz = tempWrapper.loadTagFilePrototype(); tempVector.add(tempWrapper.getJspEngineContext().getCompiler()); } else { tagClazz = wrapper.loadTagFile(); } } finally { wrapper.decTripCount(); } try { Object tagIns = tagClazz.newInstance(); if (tagIns instanceof JspSourceDependent) { Iterator<String> iter = ((JspSourceDependent) tagIns).getDependants().iterator(); while (iter.hasNext()) { parentPageInfo.addDependant(iter.next()); } } } catch (Exception e) { // ignore errors } return tagClazz; } }	public String[] getLocation(String uri) throws JasperException { if (!initialized) { init(); } return mappings.get(uri); }	public void setTagFileJarUrl(String tagFile, URL tagFileURL) { this.tagFileJarUrls.put(tagFile, tagFileURL); }	public String[] getTldLocation(String uri) throws JasperException { String[] location = getOptions().getTldLocationsCache().getLocation(uri); return location; }	private Class<?> loadTagFile(Compiler compiler, String tagFilePath, TagInfo tagInfo, PageInfo parentPageInfo) throws JasperException { URL tagFileJarUrl = null; if (tagFilePath.startsWith("/META-INF/")) { try { tagFileJarUrl = new URL("jar:" + compiler.getCompilationContext().getTldLocation(tagInfo.getTagLibrary().getURI())[0] + "!/"); } catch (MalformedURLException e) { // Ignore - tagFileJarUrl will be null } } String tagFileJarPath; if (tagFileJarUrl == null) { tagFileJarPath = ""; } else { tagFileJarPath = tagFileJarUrl.toString(); } JspCompilationContext ctxt = compiler.getCompilationContext(); JspRuntimeContext rctxt = ctxt.getRuntimeContext(); String wrapperUri = tagFileJarPath + tagFilePath; JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri); synchronized (rctxt) { if (wrapper == null) { wrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), tagFileJarUrl); rctxt.addWrapper(wrapperUri, wrapper); wrapper.getJspEngineContext().setClassLoader(ctxt.getClassLoader()); wrapper.getJspEngineContext().setClassPath(ctxt.getClassPath()); } else { // Make sure that JspCompilationContext gets the latest TagInfo // for the tag file. TagInfo instance was created the last // time the tag file was scanned for directives, and the tag wrapper.getJspEngineContext().setTagInfo(tagInfo); } Class<?> tagClazz; int tripCount = wrapper.incTripCount(); try { if (tripCount > 0) { // When tripCount is greater than zero, a circular // dependency exists. The circularly dependent tag // file is compiled in prototype mode, to avoid infinite JspServletWrapper tempWrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), ctxt.getTagFileJarUrl(tagFilePath)); tagClazz = tempWrapper.loadTagFilePrototype(); tempVector.add(tempWrapper.getJspEngineContext().getCompiler()); } else { tagClazz = wrapper.loadTagFile(); } } finally { wrapper.decTripCount(); } try { Object tagIns = tagClazz.newInstance(); if (tagIns instanceof JspSourceDependent) { Iterator<String> iter = ((JspSourceDependent) tagIns).getDependants().iterator(); while (iter.hasNext()) { parentPageInfo.addDependant(iter.next()); } } } catch (Exception e) { // ignore errors } return tagClazz; } }
private Session getSession(String sessionId, String ctxname) { Map<String, ClusterManager> managers = clusterSSO.getCluster().getManagers(); Session session = null; if (ctxname == null) { java.util.Iterator<String> i = managers.keySet().iterator(); while (i.hasNext()) { String key = i.next(); ClusterManager mgr = managers.get(key); if (mgr != null) { try { session = mgr.findSession(sessionId); } catch (IOException io) { log.error("Session doesn't exist:" + io); } return session; } else { if (log.isDebugEnabled()) log.debug("Context manager doesn't exist:" + key); } } } else { ClusterManager mgr = managers.get(ctxname); if (mgr != null) { try { session = mgr.findSession(sessionId); } catch (IOException io) { log.error("Session doesn't exist:" + io); } return session; } else if (log.isErrorEnabled()) log.error("Context manager doesn't exist:" + ctxname); } return null; }	protected void parseLocalesHeader(String value) { // Store the accumulated languages that have been requested in // a local collection, sorted by the quality value (so we can // add Locales in descending order). The values will be ArrayLists TreeMap<Double, ArrayList<Locale>> locales = new TreeMap<Double, ArrayList<Locale>>(); int white = value.indexOf(' '); if (white < 0) white = value.indexOf('\t'); if (white >= 0) { StringBuilder sb = new StringBuilder(); int len = value.length(); for (int i = 0; i < len; i++) { char ch = value.charAt(i); if ((ch != ' ') && (ch != '\t')) sb.append(ch); } value = sb.toString(); } // Process each comma-delimited language specification parser.setString(value); int length = parser.getLength(); while (true) { int start = parser.getIndex(); if (start >= length) break; int end = parser.findChar(','); String entry = parser.extract(start, end).trim(); parser.advance(); double quality = 1.0; int semi = entry.indexOf(";q="); if (semi >= 0) { try { quality = Double.parseDouble(entry.substring(semi + 3)); } catch (NumberFormatException e) { quality = 0.0; } entry = entry.substring(0, semi); } if (quality < 0.00005) continue; if ("*".equals(entry)) continue; String language = null; String country = null; String variant = null; int dash = entry.indexOf('-'); if (dash < 0) { language = entry; country = ""; variant = ""; } else { language = entry.substring(0, dash); country = entry.substring(dash + 1); int vDash = country.indexOf('-'); if (vDash > 0) { String cTemp = country.substring(0, vDash); variant = country.substring(vDash + 1); country = cTemp; } else { variant = ""; } } if (!isAlpha(language) || !isAlpha(country) || !isAlpha(variant)) { continue; } Locale locale = new Locale(language, country, variant); Double key = new Double(-quality); ArrayList<Locale> values = locales.get(key); if (values == null) { values = new ArrayList<Locale>(); locales.put(key, values); } values.add(locale); } // Process the quality values in highest->lowest order (due to Iterator<Double> keys = locales.keySet().iterator(); while (keys.hasNext()) { Double key = keys.next(); ArrayList<Locale> list = locales.get(key); Iterator<Locale> values = list.iterator(); while (values.hasNext()) { Locale locale = values.next(); addLocale(locale); } } }	protected Map<String, String> processAnnotationWebInitParams(ElementValue ev) { Map<String, String> result = new HashMap<String, String>(); if (ev instanceof ArrayElementValue) { ElementValue[] arrayValues = ((ArrayElementValue) ev).getElementValuesArray(); for (ElementValue value : arrayValues) { if (value instanceof AnnotationElementValue) { ElementValuePair[] evps = ((AnnotationElementValue) value).getAnnotationEntry().getElementValuePairs(); String initParamName = null; String initParamValue = null; for (ElementValuePair evp : evps) { if ("name".equals(evp.getNameString())) { initParamName = evp.getValue().stringifyValue(); } else if ("value".equals(evp.getNameString())) { initParamValue = evp.getValue().stringifyValue(); } else { // Ignore } } result.put(initParamName, initParamValue); } } } return result; }	protected void processAnnotationWebServlet(String className, AnnotationEntry ae, WebXml fragment) { if (fragment.getServlets().containsKey(className)) { return; } boolean urlPatternsSet = false; ServletDef servletDef = new ServletDef(); servletDef.setServletName(className); servletDef.setServletClass(className); String[] urlPatterns = null; ElementValuePair[] evps = ae.getElementValuePairs(); for (ElementValuePair evp : evps) { String name = evp.getNameString(); if ("value".equals(name) || "urlPatterns".equals(name)) { if (urlPatternsSet) { throw new IllegalArgumentException(sm.getString("contextConfig.urlPatternValue", className)); } urlPatternsSet = true; urlPatterns = processAnnotationsStringArray(evp.getValue()); } else if ("name".equals(name)) { servletDef.setServletName(evp.getValue().stringifyValue()); } else if ("description".equals(name)) { servletDef.setDescription(evp.getValue().stringifyValue()); } else if ("displayName".equals(name)) { servletDef.setDisplayName(evp.getValue().stringifyValue()); } else if ("largeIcon".equals(name)) { servletDef.setLargeIcon(evp.getValue().stringifyValue()); } else if ("smallIcon".equals(name)) { servletDef.setSmallIcon(evp.getValue().stringifyValue()); } else if ("asyncSupported".equals(name)) { servletDef.setAsyncSupported(evp.getValue().stringifyValue()); } else if ("loadOnStartup".equals(name)) { servletDef.setLoadOnStartup(evp.getValue().stringifyValue()); } else if ("initParams".equals(name)) { Map<String, String> initParams = processAnnotationWebInitParams(evp.getValue()); for (String paramName : initParams.keySet()) { servletDef.addInitParameter(paramName, initParams.get(paramName)); } } else { // Ignore } } if (urlPatterns != null) { fragment.addServlet(servletDef); for (String urlPattern : urlPatterns) { fragment.addServletMapping(urlPattern, servletDef.getServletName()); } } }	Map<String, String[]> copyMap(Map<String, String[]> orig) { if (orig == null) return (new HashMap<String, String[]>()); HashMap<String, String[]> dest = new HashMap<String, String[]>(); Iterator<String> keys = orig.keySet().iterator(); while (keys.hasNext()) { String key = keys.next(); dest.put(key, orig.get(key)); } return (dest); }	public void loadOnStartup(Container[] children) { TreeMap<Integer, ArrayList<Wrapper>> map = new TreeMap<Integer, ArrayList<Wrapper>>(); for (int i = 0; i < children.length; i++) { Wrapper wrapper = (Wrapper) children[i]; int loadOnStartup = wrapper.getLoadOnStartup(); if (loadOnStartup < 0) continue; Integer key = Integer.valueOf(loadOnStartup); ArrayList<Wrapper> list = map.get(key); if (list == null) { list = new ArrayList<Wrapper>(); map.put(key, list); } list.add(wrapper); } Iterator<Integer> keys = map.keySet().iterator(); while (keys.hasNext()) { Integer key = keys.next(); ArrayList<Wrapper> list = map.get(key); Iterator<Wrapper> wrappers = list.iterator(); while (wrappers.hasNext()) { Wrapper wrapper = wrappers.next(); try { wrapper.load(); } catch (ServletException e) { getLogger().error(sm.getString("standardWrapper.loadException", getName()), StandardWrapper.getRootCause(e)); // NOTE: load errors (including a servlet that throws // UnavailableException from tht init() method) are NOT // fatal to application startup } } } }	@Override public void messageReceived(ClusterMessage myobj) { if (myobj != null && myobj instanceof SessionMessage) { SessionMessage msg = (SessionMessage) myobj; String ctxname = msg.getContextName(); //check if the message is a EVT_GET_ALL_SESSIONS, Map<String, ClusterManager> managers = cluster.getManagers(); if (ctxname == null) { Iterator<String> i = managers.keySet().iterator(); while (i.hasNext()) { String key = i.next(); ClusterManager mgr = managers.get(key); if (mgr != null) mgr.messageDataReceived(msg); else { if (log.isDebugEnabled()) log.debug("Context manager doesn't exist:" + key); } } } else { ClusterManager mgr = managers.get(ctxname); if (mgr != null) mgr.messageDataReceived(msg); } } }
protected void writeObject(ObjectOutputStream stream) throws IOException { stream.writeObject(new Long(creationTime)); stream.writeObject(new Long(lastAccessedTime)); stream.writeObject(new Integer(maxInactiveInterval)); stream.writeObject(new Boolean(isNew)); stream.writeObject(new Boolean(isValid)); stream.writeObject(new Long(thisAccessedTime)); stream.writeObject(id); if (manager.getContainer().getLogger().isDebugEnabled()) manager.getContainer().getLogger().debug("writeObject() storing session " + id); String[] keys = keys(); ArrayList<String> saveNames = new ArrayList<String>(); ArrayList<Object> saveValues = new ArrayList<Object>(); for (int i = 0; i < keys.length; i++) { Object value = attributes.get(keys[i]); if (value == null) continue; } }
public static void main(String[] args) { if (daemon == null) { daemon = new Bootstrap(); try { daemon.init(); } catch (Throwable t) { t.printStackTrace(); return; } } try { String command = "start"; if (args.length > 0) { command = args[args.length - 1]; } if (command.equals("startd")) { args[args.length - 1] = "start"; daemon.load(args); daemon.start(); } else if (command.equals("stopd")) { args[args.length - 1] = "stop"; daemon.stop(); } else if (command.equals("start")) { daemon.setAwait(true); daemon.load(args); daemon.start(); } else if (command.equals("stop")) { daemon.stopServer(args); } else { log.warn("Bootstrap: command \"" + command + "\" does not exist."); } } catch (Throwable t) { t.printStackTrace(); } }	public void setAwait(boolean await) throws Exception { Class<?>[] paramTypes = new Class[1]; paramTypes[0] = Boolean.TYPE; Object[] paramValues = new Object[1]; paramValues[0] = new Boolean(await); Method method = catalinaDaemon.getClass().getMethod("setAwait", paramTypes); method.invoke(catalinaDaemon, paramValues); }
public void testOrder2() throws Exception { final Member[] dest = channels[0].getMembers(); final AtomicInteger value = new AtomicInteger(0); Runnable run = new Runnable() { public void run() { for (int i = 0; i < 100; i++) { try { synchronized (channels[0]) { channels[0].send(dest, new Integer(value.getAndAdd(1)), 0); } } catch (Exception x) { x.printStackTrace(); assertEquals(true, false); } } } }; Thread[] threads = new Thread[5]; for (int i = 0; i < threads.length; i++) { threads[i] = new Thread(run); } for (int i = 0; i < threads.length; i++) { threads[i].start(); } for (int i = 0; i < threads.length; i++) { threads[i].join(); } Thread.sleep(5000); for (int i = 0; i < test.length; i++) { assertEquals(false, test[i].fail); } }	public void testOrder2() throws Exception { final Member[] dest = channels[0].getMembers(); final AtomicInteger value = new AtomicInteger(0); Runnable run = new Runnable() { } }
public static final Tag findAncestorWithClass(Tag from, @SuppressWarnings("unchecked") Class klass) { boolean isInterface = false; if (from == null || klass == null || (!Tag.class.isAssignableFrom(klass) && !(isInterface = klass.isInterface()))) { return null; } for (; ; ) { Tag tag = from.getParent(); if (tag == null) { return null; } if ((isInterface && klass.isInstance(tag)) || klass.isAssignableFrom(tag.getClass())) { return tag; } from = tag; } }
protected void handleGET_ALL_SESSIONS(SessionMessage msg, Member sender) throws IOException { counterReceive_EVT_GET_ALL_SESSIONS++; if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.unloadingBegin", getName())); // Write the number of active sessions, followed by the details Session[] currentSessions = findSessions(); long findSessionTimestamp = System.currentTimeMillis(); if (isSendAllSessions()) { sendSessions(sender, currentSessions, findSessionTimestamp); } else { int len = currentSessions.length < getSendAllSessionsSize() ? currentSessions.length : getSendAllSessionsSize(); Session[] sendSessions = new Session[len]; for (int i = 0; i < currentSessions.length; i += getSendAllSessionsSize()) { len = i + getSendAllSessionsSize() > currentSessions.length ? currentSessions.length - i : getSendAllSessionsSize(); System.arraycopy(currentSessions, i, sendSessions, 0, len); sendSessions(sender, sendSessions, findSessionTimestamp); if (getSendAllSessionsWaitTime() > 0) { try { Thread.sleep(getSendAllSessionsWaitTime()); } catch (Exception sleep) { } } //end if } //for } SessionMessage newmsg = new SessionMessageImpl(name, SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE, null, "SESSION-STATE-TRANSFERED", "SESSION-STATE-TRANSFERED" + getName()); newmsg.setTimestamp(findSessionTimestamp); if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.allSessionTransfered", getName())); counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE++; cluster.send(newmsg, sender); }
@Override protected void startInternal() throws LifecycleException { taskqueue = new TaskQueue(maxQueueSize); TaskThreadFactory tf = new TaskThreadFactory(namePrefix, daemon, getThreadPriority()); executor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS, taskqueue, tf); taskqueue.setParent(executor); setState(LifecycleState.STARTING); }	public String getName() { return name; }	public void setMinSpareThreads(int minSpareThreads) { this.minSpareThreads = minSpareThreads; if (executor != null) { executor.setCorePoolSize(minSpareThreads); } }

@Override protected synchronized void stopInternal() throws LifecycleException { if (log.isDebugEnabled()) log.debug("Stopping"); setState(LifecycleState.STOPPING); LazyReplicatedMap map = (LazyReplicatedMap) sessions; if (map != null) { map.breakdown(); } cluster.removeManager(this); this.random = null; if (initialized) { destroy(); } }
@Override protected synchronized void startInternal() throws LifecycleException { try { cluster.registerManager(this); CatalinaCluster catclust = cluster; LazyReplicatedMap map = new LazyReplicatedMap(this, catclust.getChannel(), DEFAULT_REPL_TIMEOUT, getMapName(), getClassLoaders()); map.setChannelSendOptions(mapSendOptions); this.sessions = map; } catch (Exception x) { log.error("Unable to start BackupManager", x); throw new LifecycleException("Failed to start BackupManager", x); } super.startInternal(); }	@Override protected synchronized void stopInternal() throws LifecycleException { super.stopInternal(); LazyReplicatedMap map = (LazyReplicatedMap) sessions; if (map != null) { map.breakdown(); } cluster.removeManager(this); }

protected void doTrace(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { int responseLength; String CRLF = "\r\n"; String responseString = "TRACE " + req.getRequestURI() + " " + req.getProtocol(); Enumeration<String> reqHeaderEnum = req.getHeaderNames(); while (reqHeaderEnum.hasMoreElements()) { String headerName = reqHeaderEnum.nextElement(); responseString += CRLF + headerName + ": " + req.getHeader(headerName); } responseString += CRLF; responseLength = responseString.length(); resp.setContentType("message/http"); resp.setContentLength(responseLength); ServletOutputStream out = resp.getOutputStream(); out.print(responseString); out.close(); return; }
public PageContext run() { return factory.internalGetPageContext(servlet, request, response, errorPageURL, needsSession, bufferSize, autoflush); }
protected void startInternal() throws LifecycleException { // Configure the list of failed users to delete the oldest entry once it failedUsers = new LinkedHashMap<String, LockRecord>(cacheSize, 0.75f, true) { private static final long serialVersionUID = 1L; @Override protected boolean removeEldestEntry(Map.Entry<String, LockRecord> eldest) { if (size() > cacheSize) { long timeInCache = (System.currentTimeMillis() - eldest.getValue().getLastFailureTime()) / 1000; if (timeInCache < cacheRemovalWarningTime) { log.warn(sm.getString("lockOutRealm.removeWarning", eldest.getKey(), Long.valueOf(timeInCache))); } return true; } return false; } }; super.startInternal(); }	public Principal authenticate(String username, String credentials) { String serverCredentials = getPassword(username); boolean validated; if (serverCredentials == null) { validated = false; } else if (hasMessageDigest()) { validated = serverCredentials.equalsIgnoreCase(digest(credentials)); } else { validated = serverCredentials.equals(credentials); } if (!validated) { if (containerLog.isTraceEnabled()) { containerLog.trace(sm.getString("realmBase.authenticateFailure", username)); } return null; } if (containerLog.isTraceEnabled()) { containerLog.trace(sm.getString("realmBase.authenticateSuccess", username)); } return getPrincipal(username); }	public ObjectName[] getRealms() { ObjectName[] result = new ObjectName[realms.size()]; for (Realm realm : realms) { if (realm instanceof RealmBase) { result[realms.indexOf(realm)] = ((RealmBase) realm).getObjectName(); } } return result; }

protected void forwardToLoginPage(Request request, HttpServletResponse response, LoginConfig config) throws IOException { RequestDispatcher disp = context.getServletContext().getRequestDispatcher(config.getLoginPage()); try { disp.forward(request.getRequest(), response); } catch (Throwable t) { String msg = sm.getString("formAuthenticator.forwardLoginFail"); log.warn(msg, t); request.setAttribute(Globals.EXCEPTION_ATTR, t); response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, msg); } }	public Response[] send(Member[] destination, Serializable message, int rpcOptions, int channelOptions, long timeout) throws ChannelException { if (destination == null || destination.length == 0) return new Response[0]; channelOptions = channelOptions & ~Channel.SEND_OPTIONS_SYNCHRONIZED_ACK; RpcCollectorKey key = new RpcCollectorKey(UUIDGenerator.randomUUID(false)); RpcCollector collector = new RpcCollector(key, rpcOptions, destination.length, timeout); try { synchronized (collector) { if (rpcOptions != NO_REPLY) responseMap.put(key, collector); RpcMessage rmsg = new RpcMessage(rpcId, key.id, message); channel.send(destination, rmsg, channelOptions); if (rpcOptions != NO_REPLY) collector.wait(timeout); } } catch (InterruptedException ix) { Thread.interrupted(); //throw new ChannelException(ix); } finally { responseMap.remove(key); } return collector.getResponses(); }	public Session getSessionInternal() { return doGetSession(true); }	@Override public ValueReference getValueReference(EvaluationContext ctx) { if (this.children.length > 2 && this.jjtGetChild(2) instanceof AstMethodParameters) { return null; } Target t = getTarget(ctx); return new ValueReference(t.base, this.jjtGetChild(1).getValue(ctx)); }	@Override public boolean authenticate(Request request, HttpServletResponse response, LoginConfig config) throws IOException { Session session = null; Principal principal = request.getUserPrincipal(); String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (principal != null) { if (log.isDebugEnabled()) log.debug("Already authenticated '" + principal.getName() + "'"); if (ssoId != null) associate(ssoId, request.getSessionInternal(true)); return (true); } if (ssoId != null) { if (log.isDebugEnabled()) log.debug("SSO Id " + ssoId + " set; attempting " + "reauthentication"); if (reauthenticateFromSSO(ssoId, request)) return true; } if (!cache) { session = request.getSessionInternal(true); if (log.isDebugEnabled()) log.debug("Checking for reauthenticate in session " + session); String username = (String) session.getNote(Constants.SESS_USERNAME_NOTE); String password = (String) session.getNote(Constants.SESS_PASSWORD_NOTE); if ((username != null) && (password != null)) { if (log.isDebugEnabled()) log.debug("Reauthenticating username '" + username + "'"); principal = context.getRealm().authenticate(username, password); if (principal != null) { session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal); if (!matchRequest(request)) { register(request, response, principal, Constants.FORM_METHOD, username, password); return (true); } } if (log.isDebugEnabled()) log.debug("Reauthentication failed, proceed normally"); } } if (matchRequest(request)) { session = request.getSessionInternal(true); if (log.isDebugEnabled()) log.debug("Restore request from session '" + session.getIdInternal() + "'"); principal = (Principal) session.getNote(Constants.FORM_PRINCIPAL_NOTE); register(request, response, principal, Constants.FORM_METHOD, (String) session.getNote(Constants.SESS_USERNAME_NOTE), (String) session.getNote(Constants.SESS_PASSWORD_NOTE)); if (cache) { session.removeNote(Constants.SESS_USERNAME_NOTE); session.removeNote(Constants.SESS_PASSWORD_NOTE); } if (restoreRequest(request, session)) { if (log.isDebugEnabled()) log.debug("Proceed to restored request"); return (true); } else { if (log.isDebugEnabled()) log.debug("Restore of original request failed"); response.sendError(HttpServletResponse.SC_BAD_REQUEST); return (false); } } MessageBytes uriMB = MessageBytes.newInstance(); CharChunk uriCC = uriMB.getCharChunk(); uriCC.setLimit(-1); String contextPath = request.getContextPath(); String requestURI = request.getDecodedRequestURI(); boolean loginAction = requestURI.startsWith(contextPath) && requestURI.endsWith(Constants.FORM_ACTION); if (!loginAction) { session = request.getSessionInternal(true); if (log.isDebugEnabled()) log.debug("Save request in session '" + session.getIdInternal() + "'"); try { saveRequest(request, session); } catch (IOException ioe) { log.debug("Request body too big to save during authentication"); response.sendError(HttpServletResponse.SC_FORBIDDEN, sm.getString("authenticator.requestBodyTooBig")); return (false); } forwardToLoginPage(request, response, config); return (false); } // Yes -- Validate the specified credentials and redirect Realm realm = context.getRealm(); if (characterEncoding != null) { request.setCharacterEncoding(characterEncoding); } String username = request.getParameter(Constants.FORM_USERNAME); String password = request.getParameter(Constants.FORM_PASSWORD); if (log.isDebugEnabled()) log.debug("Authenticating username '" + username + "'"); principal = realm.authenticate(username, password); if (principal == null) { forwardToErrorPage(request, response, config); return (false); } if (log.isDebugEnabled()) log.debug("Authentication of '" + username + "' was successful"); if (session == null) session = request.getSessionInternal(false); if (session == null) { if (containerLog.isDebugEnabled()) containerLog.debug("User took so long to log on the session expired"); response.sendError(HttpServletResponse.SC_REQUEST_TIMEOUT, sm.getString("authenticator.sessionExpired")); return (false); } session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal); session.setNote(Constants.SESS_USERNAME_NOTE, username); session.setNote(Constants.SESS_PASSWORD_NOTE, password); // Redirect the user to the original request URI (which will cause requestURI = savedRequestURL(session); if (log.isDebugEnabled()) log.debug("Redirecting to original '" + requestURI + "'"); if (requestURI == null) response.sendError(HttpServletResponse.SC_BAD_REQUEST, sm.getString("authenticator.formlogin")); else response.sendRedirect(response.encodeRedirectURL(requestURI)); return (false); }	public boolean getClearReferencesThreadLocals() { return (this.clearReferencesThreadLocals); }	public boolean isNamedAttribute() { return namedAttribute; }	public long getLastAccessedTime() { if (!isValidInternal()) { throw new IllegalStateException(sm.getString("standardSession.getLastAccessedTime.ise")); } return (this.lastAccessedTime); }	public long getThisAccessedTime() { if (!isValidInternal()) { throw new IllegalStateException(sm.getString("standardSession.getThisAccessedTime.ise")); } return (this.thisAccessedTime); }	public static ExpressionFactory newInstance() { return newInstance(null); }	public void destroy() throws Exception { if (getState().isAvailable()) { stop(); } initialized = false; if (oname != null) { try { if (controller == oname) { Registry.getRegistry(null, null).unregisterComponent(oname); if (log.isDebugEnabled()) log.debug("unregistering " + oname); } } catch (Throwable t) { log.error("Error unregistering ", t); } } if (parent != null) { parent.removeChild(this); } Container[] children = findChildren(); for (int i = 0; i < children.length; i++) { removeChild(children[i]); } }	public void destroy() { this.attribute = null; this.filterConfig = null; }	public void destroy() { this.encoding = null; this.filterConfig = null; }	@Override public void setSecure(boolean secure) { this.secure = secure; }	public void stop() { running = false; }
public boolean processSocket(SocketWrapper<Socket> socket, SocketStatus status) { try { if (status == SocketStatus.OPEN || status == SocketStatus.STOP || status == SocketStatus.TIMEOUT) { if (waitingRequests.remove(socket)) { SocketProcessor proc = new SocketProcessor(socket, status); ClassLoader loader = Thread.currentThread().getContextClassLoader(); try { if (Globals.IS_SECURITY_ENABLED) { PrivilegedAction<Void> pa = new PrivilegedSetTccl(getClass().getClassLoader()); AccessController.doPrivileged(pa); } else { Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); } getExecutor().execute(proc); } finally { if (Globals.IS_SECURITY_ENABLED) { PrivilegedAction<Void> pa = new PrivilegedSetTccl(loader); AccessController.doPrivileged(pa); } else { Thread.currentThread().setContextClassLoader(loader); } } } } } catch (Throwable t) { // This means we got an OOM or similar creating a thread, or that log.error(sm.getString("endpoint.process.fail"), t); return false; } return true; }	public ServerSocketFactory getServerSocketFactory() { return serverSocketFactory; }	public void setKeepAliveTimeout(int timeout) { keepAliveTimeout = timeout; }	public void setSSLImplementation(String valueS) { sslImplementationName = valueS; setSecure(true); }
@Override public SSLSupport getSSLSupport(Socket s) { SSLSupport ssls = factory.getSSLSupport(s); return ssls; }	@Override public boolean isPaused() { return paused; }	protected boolean processSocket(long socket, SocketStatus status) { try { getExecutor().execute(new SocketEventProcessor(socket, status)); } catch (RejectedExecutionException x) { log.warn("Socket processing request was rejected for:" + socket, x); return false; } catch (Throwable t) { // This means we got an OOM or similar creating a thread, or that log.error(sm.getString("endpoint.process.fail"), t); return false; } return true; }	public void init() throws Exception { if (initialized) return; rootPool = Pool.create(0); serverSockPool = Pool.create(rootPool); String addressStr = null; if (getAddress() != null) { addressStr = getAddress().getHostAddress(); } int family = Socket.APR_INET; if (Library.APR_HAVE_IPV6) { if (addressStr == null) { if (!OS.IS_BSD && !OS.IS_WIN32 && !OS.IS_WIN64) family = Socket.APR_UNSPEC; } else if (addressStr.indexOf(':') >= 0) { family = Socket.APR_UNSPEC; } } long inetAddress = Address.info(addressStr, family, getPort(), 0, rootPool); serverSock = Socket.create(Address.getInfo(inetAddress).family, Socket.SOCK_STREAM, Socket.APR_PROTO_TCP, rootPool); if (OS.IS_UNIX) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } Socket.optSet(serverSock, Socket.APR_SO_KEEPALIVE, 1); int ret = Socket.bind(serverSock, inetAddress); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.bind", "" + ret, Error.strerror(ret))); } ret = Socket.listen(serverSock, getBacklog()); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.listen", "" + ret, Error.strerror(ret))); } if (OS.IS_WIN32 || OS.IS_WIN64) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } if (useSendfile && !Library.APR_HAS_SENDFILE) { useSendfile = false; } if (acceptorThreadCount == 0) { acceptorThreadCount = 1; } if (pollerThreadCount == 0) { if ((OS.IS_WIN32 || OS.IS_WIN64) && (pollerSize > 1024)) { pollerThreadCount = pollerSize / 1024; pollerSize = pollerSize - (pollerSize % 1024); } else { pollerThreadCount = 1; } } if (sendfileThreadCount == 0) { if ((OS.IS_WIN32 || OS.IS_WIN64) && (sendfileSize > 1024)) { sendfileThreadCount = sendfileSize / 1024; sendfileSize = sendfileSize - (sendfileSize % 1024); } else { // No explicit poller size limitation sendfileThreadCount = 1; } } if (deferAccept) { if (Socket.optSet(serverSock, Socket.APR_TCP_DEFER_ACCEPT, 1) == Status.APR_ENOTIMPL) { deferAccept = false; } } if (isSSLEnabled()) { int value = SSL.SSL_PROTOCOL_ALL; if ("SSLv2".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV2; } else if ("SSLv3".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV3; } else if ("TLSv1".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_TLSV1; } else if ("SSLv2+SSLv3".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV2 | SSL.SSL_PROTOCOL_SSLV3; } sslContext = SSLContext.make(rootPool, value, SSL.SSL_MODE_SERVER); if (SSLInsecureRenegotiation) { boolean legacyRenegSupported = false; try { legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); if (legacyRenegSupported) SSLContext.setOptions(sslContext, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION); } catch (UnsatisfiedLinkError e) { // Ignore } if (!legacyRenegSupported) { log.warn(sm.getString("endpoint.warn.noInsecureReneg", SSL.versionString())); } } SSLContext.setCipherSuite(sslContext, SSLCipherSuite); SSLContext.setCertificate(sslContext, SSLCertificateFile, SSLCertificateKeyFile, SSLPassword, SSL.SSL_AIDX_RSA); SSLContext.setCertificateChainFile(sslContext, SSLCertificateChainFile, false); SSLContext.setCACertificate(sslContext, SSLCACertificateFile, SSLCACertificatePath); SSLContext.setCARevocation(sslContext, SSLCARevocationFile, SSLCARevocationPath); value = SSL.SSL_CVERIFY_NONE; if ("optional".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL; } else if ("require".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_REQUIRE; } else if ("optionalNoCA".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA; } SSLContext.setVerify(sslContext, value, SSLVerifyDepth); useSendfile = false; } initialized = true; }	public KeyManager[] wrap(KeyManager[] managers) { if (managers == null) return null; KeyManager[] result = new KeyManager[managers.length]; for (int i = 0; i < result.length; i++) { if (managers[i] instanceof X509KeyManager && getKeyAlias() != null) { result[i] = new NioX509KeyManager((X509KeyManager) managers[i], getKeyAlias()); } else { result[i] = managers[i]; } } return result; }	public void pause() { if (running && !paused) { paused = true; unlockAccept(); } }	public void pause() { if (running && !paused) { paused = true; unlockAccept(); } }	public void start() throws Exception { if (!initialized) { init(); } if (!running) { running = true; paused = false; if (getExecutor() == null) { createExecutor(); } pollers = new Poller[pollerThreadCount]; for (int i = 0; i < pollerThreadCount; i++) { pollers[i] = new Poller(false); pollers[i].init(); Thread pollerThread = new Thread(pollers[i], getName() + "-Poller-" + i); pollerThread.setPriority(threadPriority); pollerThread.setDaemon(true); pollerThread.start(); } cometPollers = new Poller[pollerThreadCount]; for (int i = 0; i < pollerThreadCount; i++) { cometPollers[i] = new Poller(true); cometPollers[i].init(); Thread pollerThread = new Thread(cometPollers[i], getName() + "-CometPoller-" + i); pollerThread.setPriority(threadPriority); pollerThread.setDaemon(true); pollerThread.start(); } if (useSendfile) { sendfiles = new Sendfile[sendfileThreadCount]; for (int i = 0; i < sendfileThreadCount; i++) { sendfiles[i] = new Sendfile(); sendfiles[i].init(); Thread sendfileThread = new Thread(sendfiles[i], getName() + "-Sendfile-" + i); sendfileThread.setPriority(threadPriority); sendfileThread.setDaemon(true); sendfileThread.start(); } } for (int i = 0; i < acceptorThreadCount; i++) { Thread acceptorThread = new Thread(new Acceptor(), getName() + "-Acceptor-" + i); acceptorThread.setPriority(threadPriority); acceptorThread.setDaemon(getDaemon()); acceptorThread.start(); } } }	public void start() throws Exception { if (!initialized) { init(); } if (!running) { running = true; paused = false; if (getExecutor() == null) { createExecutor(); } pollers = new Poller[getPollerThreadCount()]; for (int i = 0; i < pollers.length; i++) { pollers[i] = new Poller(); Thread pollerThread = new Thread(pollers[i], getName() + "-ClientPoller-" + i); pollerThread.setPriority(threadPriority); pollerThread.setDaemon(true); pollerThread.start(); } for (int i = 0; i < acceptorThreadCount; i++) { Thread acceptorThread = new Thread(new Acceptor(), getName() + "-Acceptor-" + i); acceptorThread.setPriority(threadPriority); acceptorThread.setDaemon(getDaemon()); acceptorThread.start(); } } }	public void stop() { if (running) { running = false; unlockAccept(); for (int i = 0; i < pollers.length; i++) { pollers[i].destroy(); } pollers = null; for (int i = 0; i < cometPollers.length; i++) { cometPollers[i].destroy(); } cometPollers = null; if (useSendfile) { for (int i = 0; i < sendfiles.length; i++) { sendfiles[i].destroy(); } sendfiles = null; } } shutdownExecutor(); }	public void stop() { if (running) { running = false; unlockAccept(); for (int i = 0; pollers != null && i < pollers.length; i++) { if (pollers[i] == null) continue; pollers[i].destroy(); pollers[i] = null; } try { stopLatch.await(selectorTimeout + 100, TimeUnit.MILLISECONDS); } catch (InterruptedException ignore) { } } eventCache.clear(); keyCache.clear(); nioChannels.clear(); processorCache.clear(); shutdownExecutor(); }
public String createStandardContext(String parent, String path, String docBase, boolean xmlValidation, boolean xmlNamespaceAware, boolean tldValidation, boolean tldNamespaceAware) throws Exception { StandardContext context = new StandardContext(); path = getPathStr(path); context.setPath(path); context.setDocBase(docBase); context.setXmlValidation(xmlValidation); context.setXmlNamespaceAware(xmlNamespaceAware); context.setTldValidation(tldValidation); context.setTldNamespaceAware(tldNamespaceAware); ContextConfig contextConfig = new ContextConfig(); context.addLifecycleListener(contextConfig); ObjectName pname = new ObjectName(parent); ObjectName deployer = new ObjectName(pname.getDomain() + ":type=Deployer,host=" + pname.getKeyProperty("host")); if (mserver.isRegistered(deployer)) { String contextPath = context.getPath(); mserver.invoke(deployer, "addServiced", new Object[] { contextPath }, new String[] { "java.lang.String" }); String configPath = (String) mserver.getAttribute(deployer, "configBaseName"); String baseName = getConfigFile(contextPath); File configFile = new File(new File(configPath), baseName + ".xml"); context.setConfigFile(configFile.toURI().toURL()); mserver.invoke(deployer, "manageApp", new Object[] { context }, new String[] { "org.apache.catalina.Context" }); mserver.invoke(deployer, "removeServiced", new Object[] { contextPath }, new String[] { "java.lang.String" }); } else { log.warn("Deployer not found for " + pname.getKeyProperty("host")); Service service = getService(pname); Engine engine = (Engine) service.getContainer(); Host host = (Host) engine.findChild(pname.getKeyProperty("host")); host.addChild(context); } ObjectName oname = context.getJmxName(); return (oname.toString()); }	public String createStandardHost(String parent, String name, String appBase, boolean autoDeploy, boolean deployOnStartup, boolean deployXML, boolean unpackWARs, boolean xmlNamespaceAware, boolean xmlValidation) throws Exception { StandardHost host = new StandardHost(); host.setName(name); host.setAppBase(appBase); host.setAutoDeploy(autoDeploy); host.setDeployOnStartup(deployOnStartup); host.setDeployXML(deployXML); host.setUnpackWARs(unpackWARs); host.setXmlNamespaceAware(xmlNamespaceAware); host.setXmlValidation(xmlValidation); HostConfig hostConfig = new HostConfig(); host.addLifecycleListener(hostConfig); ObjectName pname = new ObjectName(parent); Service service = getService(pname); Engine engine = (Engine) service.getContainer(); engine.addChild(host); return (host.getObjectName().toString()); }	public void removeRealm(String name) throws Exception { ObjectName oname = new ObjectName(name); ContainerBase container = getParentContainerFromChild(oname); container.setRealm(null); }

protected void doLoad() throws ClassNotFoundException, IOException { if (log.isDebugEnabled()) log.debug("Start: Loading persisted sessions"); sessions.clear(); File file = file(); if (file == null) return; if (log.isDebugEnabled()) log.debug(sm.getString("standardManager.loading", pathname)); FileInputStream fis = null; BufferedInputStream bis = null; ObjectInputStream ois = null; Loader loader = null; ClassLoader classLoader = null; try { fis = new FileInputStream(file.getAbsolutePath()); bis = new BufferedInputStream(fis); if (container != null) loader = container.getLoader(); if (loader != null) classLoader = loader.getClassLoader(); if (classLoader != null) { if (log.isDebugEnabled()) log.debug("Creating custom object input stream for class loader "); ois = new CustomObjectInputStream(bis, classLoader); } else { if (log.isDebugEnabled()) log.debug("Creating standard object input stream"); ois = new ObjectInputStream(bis); } } catch (FileNotFoundException e) { if (log.isDebugEnabled()) log.debug("No persisted data file found"); return; } catch (IOException e) { log.error(sm.getString("standardManager.loading.ioe", e), e); if (fis != null) { try { fis.close(); } catch (IOException f) { // Ignore } } if (bis != null) { try { bis.close(); } catch (IOException f) { // Ignore } } throw e; } synchronized (sessions) { try { Integer count = (Integer) ois.readObject(); int n = count.intValue(); if (log.isDebugEnabled()) log.debug("Loading " + n + " persisted sessions"); for (int i = 0; i < n; i++) { StandardSession session = getNewSession(); session.readObjectData(ois); session.setManager(this); sessions.put(session.getIdInternal(), session); session.activate(); sessionCounter++; } } catch (ClassNotFoundException e) { log.error(sm.getString("standardManager.loading.cnfe", e), e); try { ois.close(); } catch (IOException f) { // Ignore } throw e; } catch (IOException e) { log.error(sm.getString("standardManager.loading.ioe", e), e); try { ois.close(); } catch (IOException f) { // Ignore } throw e; } finally { try { ois.close(); } catch (IOException f) { // ignored } if (file.exists()) file.delete(); } } if (log.isDebugEnabled()) log.debug("Finish: Loading persisted sessions"); }


protected String getDistinguishedName(DirContext context, String base, SearchResult result) throws NamingException { if (result.isRelative()) { if (containerLog.isTraceEnabled()) { containerLog.trace(" search returned relative name: " + result.getName()); } NameParser parser = context.getNameParser(""); Name contextName = parser.parse(context.getNameInNamespace()); Name baseName = parser.parse(base); Name entryName = parser.parse(new CompositeName(result.getName()).get(0)); Name name = contextName.addAll(baseName); name = name.addAll(entryName); return name.toString(); } else { String absoluteName = result.getName(); if (containerLog.isTraceEnabled()) containerLog.trace(" search returned absolute name: " + result.getName()); try { NameParser parser = context.getNameParser(""); URI userNameUri = new URI(absoluteName); String pathComponent = userNameUri.getPath(); if (pathComponent.length() < 1) { throw new InvalidNameException("Search returned unparseable absolute name: " + absoluteName); } Name name = parser.parse(pathComponent.substring(1)); return name.toString(); } catch (URISyntaxException e) { throw new InvalidNameException("Search returned unparseable absolute name: " + absoluteName); } } }	protected String getDistinguishedName(DirContext context, String base, SearchResult result) throws NamingException { if (result.isRelative()) { if (containerLog.isTraceEnabled()) { containerLog.trace(" search returned relative name: " + result.getName()); } NameParser parser = context.getNameParser(""); Name contextName = parser.parse(context.getNameInNamespace()); Name baseName = parser.parse(base); Name entryName = parser.parse(new CompositeName(result.getName()).get(0)); Name name = contextName.addAll(baseName); name = name.addAll(entryName); return name.toString(); } else { String absoluteName = result.getName(); if (containerLog.isTraceEnabled()) containerLog.trace(" search returned absolute name: " + result.getName()); try { NameParser parser = context.getNameParser(""); URI userNameUri = new URI(absoluteName); String pathComponent = userNameUri.getPath(); if (pathComponent.length() < 1) { throw new InvalidNameException("Search returned unparseable absolute name: " + absoluteName); } Name name = parser.parse(pathComponent.substring(1)); return name.toString(); } catch (URISyntaxException e) { throw new InvalidNameException("Search returned unparseable absolute name: " + absoluteName); } } }
/** * Session information for the web application at the specified context path. * Displays a profile of session thisAccessedTime listing number * of sessions for each 10 minute interval up to 10 hours. * * @param writer Writer to render to * @param path Context path of the application to list session information for * @param idle Expire all sessions with idle time &gt; idle for this context */ protected void sessions(PrintWriter writer, String path, int idle) { if (debug >= 1) { log("sessions: Session information for web application at '" + path + "'"); if (idle >= 0) log("sessions: Session expiration for " + idle + " minutes '" + path + "'"); } if ((path == null) || (!path.startsWith("/") && path.equals(""))) { writer.println(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); return; } String displayPath = path; if( path.equals("/") ) path = ""; try { Context context = (Context) host.findChild(path); if (context == null) { writer.println(sm.getString("managerServlet.noContext", RequestUtil.filter(displayPath))); return; } Manager manager = context.getManager() ; if(manager == null) { writer.println(sm.getString("managerServlet.noManager", RequestUtil.filter(displayPath))); return; } int maxCount = 60; int maxInactiveInterval = manager.getMaxInactiveInterval()/60; int histoInterval = maxInactiveInterval / maxCount; if ( histoInterval * maxCount < maxInactiveInterval ) histoInterval++; if (0==histoInterval) histoInterval=1; maxCount = maxInactiveInterval / histoInterval; if ( histoInterval * maxCount < maxInactiveInterval ) maxCount++; writer.println(sm.getString("managerServlet.sessions", displayPath)); writer.println(sm.getString("managerServlet.sessiondefaultmax", "" + maxInactiveInterval)); Session [] sessions = manager.findSessions(); int [] timeout = new int[maxCount]; int notimeout = 0; int expired = 0; long now = System.currentTimeMillis(); for (int i = 0; i < sessions.length; i++) { int time = (int)((now-sessions[i].getThisAccessedTimeInternal())/1000); if (idle >= 0 && time >= idle*60) { sessions[i].expire(); idle++; } time=time/60/histoInterval; if (time < 0) notimeout++; } } }
public void run() { long maintainTime = 0; while (running) { while (paused) { try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } } while (keepAliveCount < 1 && addCount < 1) { maintainTime = 0; try { synchronized (this) { this.wait(); } } catch (InterruptedException e) { // Ignore } } try { if (addCount > 0) { synchronized (this) { for (int i = (addCount - 1); i >= 0; i--) { int rv = Poll.add(serverPollset, addS[i], Poll.APR_POLLIN); if (rv == Status.APR_SUCCESS) { keepAliveCount++; } else { if (comet) { processSocket(addS[i], SocketStatus.ERROR); } else { Socket.destroy(addS[i]); } } } addCount = 0; } } maintainTime += pollTime; int rv = Poll.poll(serverPollset, pollTime, desc, true); if (rv > 0) { keepAliveCount -= rv; for (int n = 0; n < rv; n++) { if (((desc[n * 2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP) || ((desc[n * 2] & Poll.APR_POLLERR) == Poll.APR_POLLERR) || (comet && (!processSocket(desc[n * 2 + 1], SocketStatus.OPEN))) || (!comet && (!processSocket(desc[n * 2 + 1])))) { if (comet) { processSocket(desc[n * 2 + 1], SocketStatus.DISCONNECT); } else { Socket.destroy(desc[n * 2 + 1]); } continue; } } } else if (rv < 0) { int errn = -rv; if ((errn != Status.TIMEUP) && (errn != Status.EINTR)) { if (errn > Status.APR_OS_START_USERERR) { errn -= Status.APR_OS_START_USERERR; } log.error(sm.getString("endpoint.poll.fail", "" + errn, Error.strerror(errn))); synchronized (this) { destroy(); init(); } continue; } } if (socketProperties.getSoTimeout() > 0 && maintainTime > 1000000L && running) { rv = Poll.maintain(serverPollset, desc, true); maintainTime = 0; if (rv > 0) { keepAliveCount -= rv; for (int n = 0; n < rv; n++) { if (comet) { processSocket(desc[n], SocketStatus.TIMEOUT); } else { Socket.destroy(desc[n]); } } } } } catch (Throwable t) { log.error(sm.getString("endpoint.poll.error"), t); } } synchronized (this) { this.notifyAll(); } }

public void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { if (matchesOne(request.getRemoteAddr(), internalProxies)) { String remoteIp = null; LinkedList<String> proxiesHeaderValue = new LinkedList<String>(); String[] remoteIPHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIPHeader)); int idx; for (idx = remoteIPHeaderValue.length - 1; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; remoteIp = currentRemoteIp; if (matchesOne(currentRemoteIp, internalProxies)) { // do nothing, internalProxies IPs are not appended to the } else if (matchesOne(currentRemoteIp, trustedProxies)) { proxiesHeaderValue.addFirst(currentRemoteIp); } else { idx--; break; } } LinkedList<String> newRemoteIpHeaderValue = new LinkedList<String>(); for (; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; newRemoteIpHeaderValue.addFirst(currentRemoteIp); } XForwardedRequest xRequest = new XForwardedRequest(request); if (remoteIp != null) { xRequest.setRemoteAddr(remoteIp); xRequest.setRemoteHost(remoteIp); if (proxiesHeaderValue.size() == 0) { xRequest.removeHeader(proxiesHeader); } else { String commaDelimitedListOfProxies = listToCommaDelimitedString(proxiesHeaderValue); xRequest.setHeader(proxiesHeader, commaDelimitedListOfProxies); } if (newRemoteIpHeaderValue.size() == 0) { xRequest.removeHeader(remoteIPHeader); } else { String commaDelimitedRemoteIpHeaderValue = listToCommaDelimitedString(newRemoteIpHeaderValue); xRequest.setHeader(remoteIPHeader, commaDelimitedRemoteIpHeaderValue); } } if (protocolHeader != null) { String protocolHeaderValue = request.getHeader(protocolHeader); if (protocolHeaderValue == null) { // don't modify the secure,scheme and serverPort attributes of the request } else if (protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) { xRequest.setSecure(true); xRequest.setScheme("https"); xRequest.setServerPort(httpsServerPort); } else { xRequest.setSecure(false); xRequest.setScheme("http"); xRequest.setServerPort(httpServerPort); } } if (log.isDebugEnabled()) { log.debug("Incoming request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "', originalRemoteHost='" + request.getRemoteHost() + "', originalSecure='" + request.isSecure() + "', originalScheme='" + request.getScheme() + "', original[" + remoteIPHeader + "]='" + request.getHeader(remoteIPHeader) + ", original[" + protocolHeader + "]='" + (protocolHeader == null ? null : request.getHeader(protocolHeader)) + "' will be seen as newRemoteAddr='" + xRequest.getRemoteAddr() + "', newRemoteHost='" + xRequest.getRemoteHost() + "', newScheme='" + xRequest.getScheme() + "', newSecure='" + xRequest.isSecure() + "', new[" + remoteIPHeader + "]='" + xRequest.getHeader(remoteIPHeader) + ", new[" + proxiesHeader + "]='" + xRequest.getHeader(proxiesHeader) + "'"); } chain.doFilter(xRequest, response); } else { chain.doFilter(request, response); } }	@Override public void invoke(Request request, Response response) throws IOException, ServletException { final String originalRemoteAddr = request.getRemoteAddr(); final String originalRemoteHost = request.getRemoteHost(); final String originalScheme = request.getScheme(); final boolean originalSecure = request.isSecure(); final int originalServerPort = request.getServerPort(); if (matchesOne(originalRemoteAddr, internalProxies)) { String remoteIp = null; LinkedList<String> proxiesHeaderValue = new LinkedList<String>(); String[] remoteIPHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIpHeader)); int idx; for (idx = remoteIPHeaderValue.length - 1; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; remoteIp = currentRemoteIp; if (matchesOne(currentRemoteIp, internalProxies)) { // do nothing, internalProxies IPs are not appended to the } else if (matchesOne(currentRemoteIp, trustedProxies)) { proxiesHeaderValue.addFirst(currentRemoteIp); } else { idx--; break; } } LinkedList<String> newRemoteIpHeaderValue = new LinkedList<String>(); for (; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; newRemoteIpHeaderValue.addFirst(currentRemoteIp); } if (remoteIp != null) { request.setRemoteAddr(remoteIp); request.setRemoteHost(remoteIp); if (proxiesHeaderValue.size() == 0) { request.getCoyoteRequest().getMimeHeaders().removeHeader(proxiesHeader); } else { String commaDelimitedListOfProxies = listToCommaDelimitedString(proxiesHeaderValue); request.getCoyoteRequest().getMimeHeaders().setValue(proxiesHeader).setString(commaDelimitedListOfProxies); } if (newRemoteIpHeaderValue.size() == 0) { request.getCoyoteRequest().getMimeHeaders().removeHeader(remoteIpHeader); } else { String commaDelimitedRemoteIpHeaderValue = listToCommaDelimitedString(newRemoteIpHeaderValue); request.getCoyoteRequest().getMimeHeaders().setValue(remoteIpHeader).setString(commaDelimitedRemoteIpHeaderValue); } } if (protocolHeader != null) { String protocolHeaderValue = request.getHeader(protocolHeader); if (protocolHeaderValue == null) { // don't modify the secure,scheme and serverPort attributes // of the request } else if (protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) { request.setSecure(true); request.getCoyoteRequest().scheme().setString("https"); request.setServerPort(httpsServerPort); } else { request.setSecure(false); request.getCoyoteRequest().scheme().setString("http"); request.setServerPort(httpServerPort); } } if (log.isDebugEnabled()) { log.debug("Incoming request " + request.getRequestURI() + " with originalRemoteAddr '" + originalRemoteAddr + "', originalRemoteHost='" + originalRemoteHost + "', originalSecure='" + originalSecure + "', originalScheme='" + originalScheme + "' will be seen as newRemoteAddr='" + request.getRemoteAddr() + "', newRemoteHost='" + request.getRemoteHost() + "', newScheme='" + request.getScheme() + "', newSecure='" + request.isSecure() + "'"); } } try { getNext().invoke(request, response); } finally { request.setRemoteAddr(originalRemoteAddr); request.setRemoteHost(originalRemoteHost); request.setSecure(originalSecure); request.getCoyoteRequest().scheme().setString(originalScheme); request.setServerPort(originalServerPort); } }
private Thread[] getThreads() { ThreadGroup tg = Thread.currentThread().getThreadGroup(); while (tg.getParent() != null) { tg = tg.getParent(); } int threadCountGuess = tg.activeCount() + 50; Thread[] threads = new Thread[threadCountGuess]; int threadCountActual = tg.enumerate(threads); while (threadCountActual == threadCountGuess) { threadCountGuess *= 2; threads = new Thread[threadCountGuess]; // Note tg.enumerate(Thread[]) silently ignores any threads that threadCountActual = tg.enumerate(threads); } return threads; }	@Override protected void startInternal() throws LifecycleException { if (!initialized) init(); if (log.isDebugEnabled()) log.debug(sm.getString("webappLoader.starting")); if (container.getResources() == null) { log.info("No resources for " + container); setState(LifecycleState.STARTING); return; } URLStreamHandlerFactory streamHandlerFactory = new DirContextURLStreamHandlerFactory(); if (first) { first = false; try { URL.setURLStreamHandlerFactory(streamHandlerFactory); } catch (Exception e) { log.error("Error registering jndi stream handler", e); } catch (Throwable t) { log.info("Dual registration of jndi stream handler: " + t.getMessage()); } } try { classLoader = createClassLoader(); classLoader.setResources(container.getResources()); classLoader.setDelegate(this.delegate); if (container instanceof StandardContext) { classLoader.setAntiJARLocking(((StandardContext) container).getAntiJARLocking()); classLoader.setClearReferencesStatic(((StandardContext) container).getClearReferencesStatic()); classLoader.setClearReferencesStopThreads(((StandardContext) container).getClearReferencesStopThreads()); } for (int i = 0; i < repositories.length; i++) { classLoader.addRepository(repositories[i]); } setRepositories(); setClassPath(); setPermissions(); ((Lifecycle) classLoader).start(); DirContextURLStreamHandler.bind(classLoader, this.container.getResources()); StandardContext ctx = (StandardContext) container; String path = ctx.getPath(); if (path.equals("")) { path = "/"; } ObjectName cloname = new ObjectName(ctx.getEngineName() + ":type=WebappClassLoader,path=" + path + ",host=" + ctx.getParent().getName()); Registry.getRegistry(null, null).registerComponent(classLoader, cloname, null); } catch (Throwable t) { log.error("LifecycleException ", t); throw new LifecycleException("start: ", t); } setState(LifecycleState.STARTING); }	public boolean getClearReferencesLogFactoryRelease() { return (this.clearReferencesLogFactoryRelease); }	public void setClearReferencesStopThreads(boolean clearReferencesStopThreads) { boolean oldClearReferencesStopThreads = this.clearReferencesStopThreads; this.clearReferencesStopThreads = clearReferencesStopThreads; support.firePropertyChange("clearReferencesStopThreads", oldClearReferencesStopThreads, this.clearReferencesStopThreads); }
protected byte[] serializeSessions(Session[] currentSessions) throws IOException { ByteArrayOutputStream fos = null; ObjectOutputStream oos = null; try { fos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(new BufferedOutputStream(fos)); oos.writeObject(new Integer(currentSessions.length)); for (int i = 0; i < currentSessions.length; i++) { ((DeltaSession) currentSessions[i]).writeObjectData(oos); } oos.flush(); } catch (IOException e) { log.error(sm.getString("deltaManager.unloading.ioe", e), e); throw e; } finally { if (oos != null) { try { oos.close(); } catch (IOException f) { // Ignore } oos = null; } } return fos.toByteArray(); }
protected void contextConfig() { if (defaultContextXml == null && context instanceof StandardContext) { defaultContextXml = ((StandardContext) context).getDefaultContextXml(); } if (defaultContextXml == null) getDefaultContextXml(); if (!context.getOverride()) { processContextConfig(new File(getBaseDir()), defaultContextXml); processContextConfig(getConfigBase(), getHostConfigPath(Constants.HostContextXml)); } if (context.getConfigFile() != null) processContextConfig(new File(context.getConfigFile()), null); }	protected void deployDescriptor(String contextPath, File contextXml, String file) { if (deploymentExists(contextPath)) { return; } DeployedApplication deployedApp = new DeployedApplication(contextPath); if (log.isInfoEnabled()) { log.info(sm.getString("hostConfig.deployDescriptor", file, configBase.getPath())); } Context context = null; try { synchronized (digester) { try { context = (Context) digester.parse(contextXml); if (context == null) { log.error(sm.getString("hostConfig.deployDescriptor.error", file)); return; } } finally { digester.reset(); } } Class<?> clazz = Class.forName(host.getConfigClass()); LifecycleListener listener = (LifecycleListener) clazz.newInstance(); context.addLifecycleListener(listener); context.setConfigFile(contextXml.getAbsolutePath()); context.setPath(contextPath); boolean isExternalWar = false; boolean isExternal = false; if (context.getDocBase() != null) { File docBase = new File(context.getDocBase()); if (!docBase.isAbsolute()) { docBase = new File(appBase(), context.getDocBase()); } if (!docBase.getCanonicalPath().startsWith(appBase().getAbsolutePath() + File.separator)) { isExternal = true; deployedApp.redeployResources.put(contextXml.getAbsolutePath(), new Long(contextXml.lastModified())); deployedApp.redeployResources.put(docBase.getAbsolutePath(), new Long(docBase.lastModified())); if (docBase.getAbsolutePath().toLowerCase().endsWith(".war")) { isExternalWar = true; } } else { log.warn(sm.getString("hostConfig.deployDescriptor.localDocBaseSpecified", docBase)); context.setDocBase(null); } } host.addChild(context); String name = null; String path = context.getPath(); if (path.equals("")) { name = "ROOT"; } else { if (path.startsWith("/")) { name = path.substring(1); } else { name = path; } } File expandedDocBase = new File(appBase(), name); if (context.getDocBase() != null) { expandedDocBase = new File(context.getDocBase()); if (!expandedDocBase.isAbsolute()) { expandedDocBase = new File(appBase(), context.getDocBase()); } } if (isExternalWar && unpackWARs) { deployedApp.redeployResources.put(expandedDocBase.getAbsolutePath(), new Long(expandedDocBase.lastModified())); deployedApp.redeployResources.put(contextXml.getAbsolutePath(), new Long(contextXml.lastModified())); addWatchedResources(deployedApp, expandedDocBase.getAbsolutePath(), context); } else { if (!isExternal) { File warDocBase = new File(expandedDocBase.getAbsolutePath() + ".war"); if (warDocBase.exists()) { deployedApp.redeployResources.put(warDocBase.getAbsolutePath(), new Long(warDocBase.lastModified())); } } if (expandedDocBase.exists()) { deployedApp.redeployResources.put(expandedDocBase.getAbsolutePath(), new Long(expandedDocBase.lastModified())); addWatchedResources(deployedApp, expandedDocBase.getAbsolutePath(), context); } else { addWatchedResources(deployedApp, null, context); } if (!isExternal) { deployedApp.redeployResources.put(contextXml.getAbsolutePath(), new Long(contextXml.lastModified())); } } } catch (Throwable t) { log.error(sm.getString("hostConfig.deployDescriptor.error", file), t); } if (context != null && host.findChild(context.getName()) != null) { deployed.put(contextPath, deployedApp); } }	protected void deployDirectory(String contextPath, File dir, String file) { DeployedApplication deployedApp = new DeployedApplication(contextPath); if (deploymentExists(contextPath)) return; if (log.isInfoEnabled()) log.info(sm.getString("hostConfig.deployDir", file)); try { Context context = null; File xml = new File(dir, Constants.ApplicationContextXml); File xmlCopy = null; if (deployXML && xml.exists()) { synchronized (digester) { try { context = (Context) digester.parse(xml); if (context == null) { log.error(sm.getString("hostConfig.deployDescriptor.error", xml)); return; } } finally { digester.reset(); } } xmlCopy = new File(configBase(), file + ".xml"); InputStream is = null; OutputStream os = null; try { is = new FileInputStream(xml); os = new FileOutputStream(xmlCopy); IOTools.flow(is, os); // Don't catch IOE - let the outer try/catch handle it } finally { try { if (is != null) is.close(); } catch (IOException e) { // Ignore } try { if (os != null) os.close(); } catch (IOException e) { // Ignore } } context.setConfigFile(xmlCopy.getAbsolutePath()); } else { context = (Context) Class.forName(contextClass).newInstance(); } Class<?> clazz = Class.forName(host.getConfigClass()); LifecycleListener listener = (LifecycleListener) clazz.newInstance(); context.addLifecycleListener(listener); context.setPath(contextPath); context.setDocBase(file); host.addChild(context); deployedApp.redeployResources.put(dir.getAbsolutePath(), new Long(dir.lastModified())); if (xmlCopy != null) { deployedApp.redeployResources.put(xmlCopy.getAbsolutePath(), new Long(xmlCopy.lastModified())); } addWatchedResources(deployedApp, dir.getAbsolutePath(), context); } catch (Throwable t) { log.error(sm.getString("hostConfig.deployDir.error", file), t); } deployed.put(contextPath, deployedApp); }	protected void deployWAR(String contextPath, File war, String file) { if (deploymentExists(contextPath)) return; JarFile jar = null; JarEntry entry = null; InputStream istream = null; BufferedOutputStream ostream = null; File xml = new File(configBase(), file.substring(0, file.lastIndexOf(".")) + ".xml"); if (deployXML && !xml.exists()) { try { jar = new JarFile(war); entry = jar.getJarEntry(Constants.ApplicationContextXml); if (entry != null) { istream = jar.getInputStream(entry); ostream = new BufferedOutputStream(new FileOutputStream(xml), 1024); byte[] buffer = new byte[1024]; while (true) { int n = istream.read(buffer); if (n < 0) { break; } ostream.write(buffer, 0, n); } ostream.flush(); ostream.close(); ostream = null; istream.close(); istream = null; } } catch (Exception e) { if (ostream != null) { try { ostream.close(); } catch (Throwable t) { // Ignore } ostream = null; } if (istream != null) { try { istream.close(); } catch (Throwable t) { // Ignore } istream = null; } } finally { entry = null; if (jar != null) { try { jar.close(); } catch (Throwable t) { // Ignore } jar = null; } } } DeployedApplication deployedApp = new DeployedApplication(contextPath); if (log.isInfoEnabled()) log.info(sm.getString("hostConfig.deployWar", file)); try { Context context = null; if (deployXML && xml.exists()) { synchronized (digester) { try { context = (Context) digester.parse(xml); if (context == null) { log.error(sm.getString("hostConfig.deployDescriptor.error", file)); return; } } finally { digester.reset(); } } context.setConfigFile(xml.getAbsolutePath()); } else { context = (Context) Class.forName(contextClass).newInstance(); } deployedApp.redeployResources.put(war.getAbsolutePath(), new Long(war.lastModified())); if (deployXML && xml.exists()) { deployedApp.redeployResources.put(xml.getAbsolutePath(), new Long(xml.lastModified())); } Class<?> clazz = Class.forName(host.getConfigClass()); LifecycleListener listener = (LifecycleListener) clazz.newInstance(); context.addLifecycleListener(listener); context.setPath(contextPath); context.setDocBase(file); host.addChild(context); if (unpackWARs && (context.getDocBase() != null)) { String name = null; String path = context.getPath(); if (path.equals("")) { name = "ROOT"; } else { if (path.startsWith("/")) { name = path.substring(1); } else { name = path; } } name = name.replace('/', '#'); File docBase = new File(name); if (!docBase.isAbsolute()) { docBase = new File(appBase(), name); } deployedApp.redeployResources.put(docBase.getAbsolutePath(), new Long(docBase.lastModified())); addWatchedResources(deployedApp, docBase.getAbsolutePath(), context); } else { addWatchedResources(deployedApp, null, context); } } catch (Throwable t) { log.error(sm.getString("hostConfig.deployWar.error", file), t); } deployed.put(contextPath, deployedApp); }	protected void processContextConfig(File baseDir, String resourceName) { if (log.isDebugEnabled()) log.debug("Processing context [" + context.getName() + "] configuration file " + baseDir + " " + resourceName); InputSource source = null; InputStream stream = null; File file = baseDir; if (resourceName != null) { file = new File(baseDir, resourceName); } try { if (!file.exists()) { if (resourceName != null) { stream = getClass().getClassLoader().getResourceAsStream(resourceName); if (stream != null) { source = new InputSource(getClass().getClassLoader().getResource(resourceName).toString()); } } } else { source = new InputSource("file://" + file.getAbsolutePath()); stream = new FileInputStream(file); // Add as watched resource so that cascade reload occurs if a default context.addWatchedResource(file.getAbsolutePath()); } } catch (Exception e) { log.error(sm.getString("contextConfig.contextMissing", resourceName + " " + file), e); } if (source == null) return; synchronized (contextDigester) { try { source.setByteStream(stream); contextDigester.setClassLoader(this.getClass().getClassLoader()); contextDigester.setUseContextClassLoader(false); contextDigester.push(context.getParent()); contextDigester.push(context); ContextErrorHandler errorHandler = new ContextErrorHandler(); contextDigester.setErrorHandler(errorHandler); contextDigester.parse(source); if (errorHandler.parseException != null) { ok = false; } if (log.isDebugEnabled()) log.debug("Successfully processed context [" + context.getName() + "] configuration file " + baseDir + " " + resourceName); } catch (SAXParseException e) { log.error(sm.getString("contextConfig.contextParse", context.getName()), e); log.error(sm.getString("contextConfig.defaultPosition", "" + e.getLineNumber(), "" + e.getColumnNumber())); ok = false; } catch (Exception e) { log.error(sm.getString("contextConfig.contextParse", context.getName()), e); ok = false; } finally { contextDigester.reset(); try { if (stream != null) { stream.close(); } } catch (IOException e) { log.error(sm.getString("contextConfig.contextClose"), e); } } } }	public String createStandardContext(String parent, String path, String docBase, boolean xmlValidation, boolean xmlNamespaceAware, boolean tldValidation, boolean tldNamespaceAware) throws Exception { StandardContext context = new StandardContext(); path = getPathStr(path); context.setPath(path); context.setDocBase(docBase); context.setXmlValidation(xmlValidation); context.setXmlNamespaceAware(xmlNamespaceAware); context.setTldValidation(tldValidation); context.setTldNamespaceAware(tldNamespaceAware); ContextConfig contextConfig = new ContextConfig(); context.addLifecycleListener(contextConfig); ObjectName pname = new ObjectName(parent); ObjectName deployer = new ObjectName(pname.getDomain() + ":type=Deployer,host=" + pname.getKeyProperty("host")); if (mserver.isRegistered(deployer)) { String contextPath = context.getPath(); mserver.invoke(deployer, "addServiced", new Object[] { contextPath }, new String[] { "java.lang.String" }); String configPath = (String) mserver.getAttribute(deployer, "configBaseName"); String baseName = getConfigFile(contextPath); File configFile = new File(new File(configPath), baseName + ".xml"); context.setConfigFile(configFile.getAbsolutePath()); mserver.invoke(deployer, "manageApp", new Object[] { context }, new String[] { "org.apache.catalina.Context" }); mserver.invoke(deployer, "removeServiced", new Object[] { contextPath }, new String[] { "java.lang.String" }); } else { log.warn("Deployer not found for " + pname.getKeyProperty("host")); Service service = getService(pname); Engine engine = (Engine) service.getContainer(); Host host = (Host) engine.findChild(pname.getKeyProperty("host")); host.addChild(context); } ObjectName oname = context.getJmxName(); return (oname.toString()); }	public String getConfigFile() { return (this.configFile); }	public void lifecycleEvent(LifecycleEvent event) { if (event.getType().equals(Lifecycle.PERIODIC_EVENT)) check(); try { host = (Host) event.getLifecycle(); if (host instanceof StandardHost) { setDeployXML(((StandardHost) host).isDeployXML()); setUnpackWARs(((StandardHost) host).isUnpackWARs()); setXmlNamespaceAware(((StandardHost) host).getXmlNamespaceAware()); setXmlValidation(((StandardHost) host).getXmlValidation()); } } catch (ClassCastException e) { log.error(sm.getString("hostConfig.cce", event.getLifecycle()), e); return; } if (event.getType().equals(Lifecycle.START_EVENT)) start(); }	public void setCharsetMapper(CharsetMapper mapper) { CharsetMapper oldCharsetMapper = this.charsetMapper; this.charsetMapper = mapper; if (mapper != null) this.charsetMapperClass = mapper.getClass().getName(); support.firePropertyChange("charsetMapper", oldCharsetMapper, this.charsetMapper); }	public void setDeployXML(boolean deployXML) { this.deployXML = deployXML; }	public void setDeployXML(boolean deployXML) { this.deployXML = deployXML; }
public void sendMessage(ChannelMessage message, Member[] destination) throws ChannelException { MultiPointSender sender = getTransport(); try { sender.sendMessage(destination, message); } catch (ChannelException x) { sender.disconnect(); throw x; } }	public void sendMessage(Member[] destination, ChannelMessage message) throws ChannelException { if (!connected) throw new ChannelException("Sender not connected."); ParallelNioSender sender = (ParallelNioSender) getSender(); if (sender == null) { ChannelException cx = new ChannelException("Unable to retrieve a data sender, time out error."); for (int i = 0; i < destination.length; i++) cx.addFaultyMember(destination[i], new NullPointerException("Unable to retrieve a sender from the sender pool")); throw cx; } else { try { sender.sendMessage(destination, message); sender.keepalive(); } finally { if (!connected) disconnect(); returnSender(sender); } } }
@Override public void write(int c) throws IOException { ensureOpen(); if (bufferSize == 0) { initOut(); out.write(c); } else { if (nextChar >= bufferSize) if (autoFlush) flushBuffer(); else bufferOverflow(); cb[nextChar++] = (char) c; } }
protected ArrayList<NamingEntry> list(File file) { ArrayList<NamingEntry> entries = new ArrayList<NamingEntry>(); if (!file.isDirectory()) return entries; String[] names = file.list(); if (names == null) { log.warn(sm.getString("fileResources.listingNull", file.getAbsolutePath())); return entries; } Arrays.sort(names); NamingEntry entry = null; for (int i = 0; i < names.length; i++) { File currentFile = new File(file, names[i]); Object object = null; if (currentFile.isDirectory()) { FileDirContext tempContext = new FileDirContext(env); tempContext.setDocBase(file.getPath()); tempContext.setAllowLinking(getAllowLinking()); object = tempContext; } else { object = new FileResource(currentFile); } entry = new NamingEntry(names[i], object, NamingEntry.ENTRY); entries.add(entry); } return entries; }	@Override public InputStream streamContent() throws IOException { if (binaryContent == null) { inputStream = new FileInputStream(file); } return super.streamContent(); }	@Override public InputStream streamContent() throws IOException { try { if (binaryContent == null) { inputStream = base.getInputStream(entry); } } catch (ZipException e) { throw new IOException(e.getMessage()); } return super.streamContent(); }
public Set<String> getResourcePaths(String path) { return context.getResourcePaths(canonicalURI(path)); }
protected List<String> getRoles(DirContext context, User user) throws NamingException { if (user == null) return (null); String dn = user.dn; String username = user.username; if (dn == null || username == null) return (null); if (containerLog.isTraceEnabled()) containerLog.trace(" getRoles(" + dn + ")"); List<String> list = user.roles; if (list == null) { list = new ArrayList<String>(); } if (commonRole != null) list.add(commonRole); if (containerLog.isTraceEnabled()) { containerLog.trace(" Found " + list.size() + " user internal roles"); for (int i = 0; i < list.size(); i++) containerLog.trace(" Found user internal role " + list.get(i)); } if ((roleFormat == null) || (roleName == null)) return (list); String filter = roleFormat.format(new String[] { doRFC2254Encoding(dn), username }); SearchControls controls = new SearchControls(); if (roleSubtree) controls.setSearchScope(SearchControls.SUBTREE_SCOPE); else controls.setSearchScope(SearchControls.ONELEVEL_SCOPE); controls.setReturningAttributes(new String[] { roleName }); NamingEnumeration<SearchResult> results = context.search(roleBase, filter, controls); if (results == null) return (list); HashMap<String, String> groupMap = new HashMap<String, String>(); try { while (results.hasMore()) { SearchResult result = results.next(); Attributes attrs = result.getAttributes(); if (attrs == null) continue; String dname = getDistinguishedName(context, roleBase, result); String name = getAttributeValue(roleName, attrs); if (name != null && dname != null) { groupMap.put(dname, name); } } } catch (PartialResultException ex) { if (!adCompat) throw ex; } Set<String> keys = groupMap.keySet(); if (containerLog.isTraceEnabled()) { containerLog.trace(" Found " + keys.size() + " direct roles"); for (String key : keys) { containerLog.trace(" Found direct role " + key + " -> " + groupMap.get(key)); } } if (getRoleNested()) { // The following efficient algorithm is known as memberOf Algorithm, as described in "Practices in // Directory Groups". It avoids group slurping and handles cyclic group memberships as well. Map<String, String> newGroups = new HashMap<String, String>(groupMap); while (!newGroups.isEmpty()) { Map<String, String> newThisRound = new HashMap<String, String>(); for (Entry<String, String> group : newGroups.entrySet()) { filter = roleFormat.format(new String[] { group.getKey(), group.getValue() }); if (containerLog.isTraceEnabled()) { containerLog.trace("Perform a nested group search with base " + roleBase + " and filter " + filter); } results = context.search(roleBase, filter, controls); try { while (results.hasMore()) { SearchResult result = results.next(); Attributes attrs = result.getAttributes(); if (attrs == null) continue; String dname = getDistinguishedName(context, roleBase, result); String name = getAttributeValue(roleName, attrs); if (name != null && dname != null && !groupMap.keySet().contains(dname)) { groupMap.put(dname, name); newThisRound.put(dname, name); if (containerLog.isTraceEnabled()) { containerLog.trace(" Found nested role " + dname + " -> " + name); } } } } catch (PartialResultException ex) { if (!adCompat) throw ex; } } newGroups = newThisRound; } } return new ArrayList<String>(groupMap.values()); }
protected boolean custom(Request request, Response response, ErrorPage errorPage) { if (container.getLogger().isDebugEnabled()) container.getLogger().debug("Processing " + errorPage); request.setPathInfo(errorPage.getLocation()); try { response.resetBuffer(true); ServletContext servletContext = request.getContext().getServletContext(); RequestDispatcher rd = servletContext.getRequestDispatcher(errorPage.getLocation()); rd.forward(request.getRequest(), response.getResponse()); response.setSuspended(false); return (true); } catch (Throwable t) { container.getLogger().error("Exception Processing " + errorPage, t); return (false); } }
public ServletContext getServletContext() { return config.getServletContext(); }
public static void securityClassLoad(ClassLoader loader) { if (System.getSecurityManager() == null) { return; } String basePackage = "org.apache.jasper."; try { loader.loadClass(basePackage + "runtime.JspFactoryImpl$PrivilegedGetPageContext"); loader.loadClass(basePackage + "runtime.JspFactoryImpl$PrivilegedReleasePageContext"); loader.loadClass(basePackage + "runtime.JspRuntimeLibrary"); loader.loadClass(basePackage + "runtime.JspRuntimeLibrary$PrivilegedIntrospectHelper"); loader.loadClass(basePackage + "runtime.ServletResponseWrapperInclude"); loader.loadClass(basePackage + "runtime.TagHandlerPool"); loader.loadClass(basePackage + "runtime.JspFragmentHelper"); loader.loadClass(basePackage + "runtime.ProtectedFunctionMapper"); loader.loadClass(basePackage + "runtime.ProtectedFunctionMapper$1"); loader.loadClass(basePackage + "runtime.ProtectedFunctionMapper$2"); loader.loadClass(basePackage + "runtime.ProtectedFunctionMapper$3"); loader.loadClass(basePackage + "runtime.ProtectedFunctionMapper$4"); loader.loadClass(basePackage + "runtime.PageContextImpl"); loader.loadClass(basePackage + "runtime.PageContextImpl$1"); loader.loadClass(basePackage + "runtime.PageContextImpl$2"); loader.loadClass(basePackage + "runtime.PageContextImpl$3"); loader.loadClass(basePackage + "runtime.PageContextImpl$4"); loader.loadClass(basePackage + "runtime.PageContextImpl$5"); loader.loadClass(basePackage + "runtime.PageContextImpl$6"); loader.loadClass(basePackage + "runtime.PageContextImpl$7"); loader.loadClass(basePackage + "runtime.PageContextImpl$8"); loader.loadClass(basePackage + "runtime.PageContextImpl$9"); loader.loadClass(basePackage + "runtime.PageContextImpl$10"); loader.loadClass(basePackage + "runtime.PageContextImpl$11"); loader.loadClass(basePackage + "runtime.PageContextImpl$12"); loader.loadClass(basePackage + "runtime.PageContextImpl$13"); loader.loadClass(basePackage + "runtime.JspContextWrapper"); loader.loadClass(basePackage + "servlet.JspServletWrapper"); loader.loadClass(basePackage + "runtime.JspWriterImpl$1"); } catch (ClassNotFoundException ex) { log.error("SecurityClassLoad", ex); } }

protected InputStream findXsltInputStream(DirContext directory) throws IOException { if (localXsltFile != null) { try { Object obj = directory.lookup(localXsltFile); if ((obj != null) && (obj instanceof Resource)) { InputStream is = ((Resource) obj).streamContent(); if (is != null) return is; } } catch (NamingException e) { if (debug > 10) log("localXsltFile '" + localXsltFile + "' not found", e); return null; } } if (globalXsltFile != null) { FileInputStream fis = null; try { File f = new File(globalXsltFile); if (f.exists()) { fis = new FileInputStream(f); byte[] b = new byte[(int) f.length()]; fis.read(b); return new ByteArrayInputStream(b); } } finally { if (fis != null) fis.close(); } } return null; }	protected InputStream renderXml(String contextPath, CacheEntry cacheEntry, InputStream xsltInputStream) throws IOException, ServletException { StringBuilder sb = new StringBuilder(); sb.append("<?xml version=\"1.0\"?>"); sb.append("<listing "); sb.append(" contextPath='"); sb.append(contextPath); sb.append("'"); sb.append(" directory='"); sb.append(cacheEntry.name); sb.append("' "); sb.append(" hasParent='").append(!cacheEntry.name.equals("/")); sb.append("'>"); sb.append("<entries>"); try { NamingEnumeration<NameClassPair> enumeration = resources.list(cacheEntry.name); String rewrittenContextPath = rewriteUrl(contextPath); while (enumeration.hasMoreElements()) { NameClassPair ncPair = enumeration.nextElement(); String resourceName = ncPair.getName(); String trimmed = resourceName; if (trimmed.equalsIgnoreCase("WEB-INF") || trimmed.equalsIgnoreCase("META-INF") || trimmed.equalsIgnoreCase(localXsltFile)) continue; CacheEntry childCacheEntry = resources.lookupCache(cacheEntry.name + resourceName); if (!childCacheEntry.exists) { continue; } sb.append("<entry"); sb.append(" type='").append((childCacheEntry.context != null) ? "dir" : "file").append("'"); sb.append(" urlPath='").append(rewrittenContextPath).append(rewriteUrl(cacheEntry.name + resourceName)).append((childCacheEntry.context != null) ? "/" : "").append("'"); if (childCacheEntry.resource != null) { sb.append(" size='").append(renderSize(childCacheEntry.attributes.getContentLength())).append("'"); } sb.append(" date='").append(childCacheEntry.attributes.getLastModifiedHttp()).append("'"); sb.append(">"); sb.append(RequestUtil.filter(trimmed)); if (childCacheEntry.context != null) sb.append("/"); sb.append("</entry>"); } } catch (NamingException e) { throw new ServletException("Error accessing resource", e); } sb.append("</entries>"); String readme = getReadme(cacheEntry.context); if (readme != null) { sb.append("<readme><![CDATA["); sb.append(readme); sb.append("]]></readme>"); } sb.append("</listing>"); try { TransformerFactory tFactory = TransformerFactory.newInstance(); Source xmlSource = new StreamSource(new StringReader(sb.toString())); Source xslSource = new StreamSource(xsltInputStream); Transformer transformer = tFactory.newTransformer(xslSource); ByteArrayOutputStream stream = new ByteArrayOutputStream(); OutputStreamWriter osWriter = new OutputStreamWriter(stream, "UTF8"); StreamResult out = new StreamResult(osWriter); transformer.transform(xmlSource, out); osWriter.flush(); return (new ByteArrayInputStream(stream.toByteArray())); } catch (TransformerException e) { throw new ServletException("XSL transformer error", e); } }	@Override public void init() throws ServletException { if (getServletConfig().getInitParameter("debug") != null) debug = Integer.parseInt(getServletConfig().getInitParameter("debug")); if (getServletConfig().getInitParameter("input") != null) input = Integer.parseInt(getServletConfig().getInitParameter("input")); if (getServletConfig().getInitParameter("output") != null) output = Integer.parseInt(getServletConfig().getInitParameter("output")); listings = Boolean.parseBoolean(getServletConfig().getInitParameter("listings")); if (getServletConfig().getInitParameter("readonly") != null) readOnly = Boolean.parseBoolean(getServletConfig().getInitParameter("readonly")); if (getServletConfig().getInitParameter("sendfileSize") != null) sendfileSize = Integer.parseInt(getServletConfig().getInitParameter("sendfileSize")) * 1024; fileEncoding = getServletConfig().getInitParameter("fileEncoding"); globalXsltFile = getServletConfig().getInitParameter("globalXsltFile"); localXsltFile = getServletConfig().getInitParameter("localXsltFile"); readmeFile = getServletConfig().getInitParameter("readmeFile"); if (getServletConfig().getInitParameter("useAcceptRanges") != null) useAcceptRanges = Boolean.parseBoolean(getServletConfig().getInitParameter("useAcceptRanges")); if (input < 256) input = 256; if (output < 256) output = 256; if (debug > 0) { log("DefaultServlet.init: input buffer size=" + input + ", output buffer size=" + output); } resources = (ProxyDirContext) getServletContext().getAttribute(Globals.RESOURCES_ATTR); if (resources == null) { try { resources = (ProxyDirContext) new InitialContext().lookup(RESOURCES_JNDI_NAME); } catch (NamingException e) { throw new ServletException("No resources", e); } } if (resources == null) { throw new UnavailableException("No resources"); } }
protected void mergeIntoWebXml() throws IOException { File webappBase = new File(uriRoot); File webXml = new File(webappBase, "WEB-INF/web.xml"); File webXml2 = new File(webappBase, "WEB-INF/web2.xml"); String insertStartMarker = Localizer.getMessage("jspc.webinc.insertStart"); String insertEndMarker = Localizer.getMessage("jspc.webinc.insertEnd"); BufferedReader reader = new BufferedReader(new FileReader(webXml)); BufferedReader fragmentReader = new BufferedReader(new FileReader(webxmlFile)); PrintWriter writer = new PrintWriter(new FileWriter(webXml2)); int pos = -1; String line = null; while (true) { line = reader.readLine(); if (line == null) { break; } if (line.indexOf(insertStartMarker) >= 0) { while (true) { line = reader.readLine(); if (line == null) { return; } if (line.indexOf(insertEndMarker) >= 0) { line = reader.readLine(); line = reader.readLine(); if (line == null) { return; } break; } } } for (int i = 0; i < insertBefore.length; i++) { pos = line.indexOf(insertBefore[i]); if (pos >= 0) break; } if (pos >= 0) { writer.print(line.substring(0, pos)); break; } else { writer.println(line); } } writer.println(insertStartMarker); while (true) { String line2 = fragmentReader.readLine(); if (line2 == null) { writer.println(); break; } writer.println(line2); } writer.println(insertEndMarker); writer.println(); for (int i = 0; i < pos; i++) { writer.print(" "); } writer.println(line.substring(pos)); while (true) { line = reader.readLine(); if (line == null) { break; } writer.println(line); } writer.close(); reader.close(); fragmentReader.close(); FileInputStream fis = new FileInputStream(webXml2); FileOutputStream fos = new FileOutputStream(webXml); byte[] buf = new byte[512]; while (true) { int n = fis.read(buf); if (n < 0) { break; } fos.write(buf, 0, n); } fis.close(); fos.close(); webXml2.delete(); (new File(webxmlFile)).delete(); }
private void parseProperties(HttpServletRequest req, XMLWriter generatedXML, String path, int type, Vector<String> propertiesVector) { if (path.toUpperCase().startsWith("/WEB-INF") || path.toUpperCase().startsWith("/META-INF")) return; CacheEntry cacheEntry = resources.lookupCache(path); generatedXML.writeElement(null, "response", XMLWriter.OPENING); String status = new String("HTTP/1.1 " + WebdavStatus.SC_OK + " " + WebdavStatus.getStatusText(WebdavStatus.SC_OK)); generatedXML.writeElement(null, "href", XMLWriter.OPENING); String href = req.getContextPath() + req.getServletPath(); if ((href.endsWith("/")) && (path.startsWith("/"))) href += path.substring(1); else href += path; if ((cacheEntry.context != null) && (!href.endsWith("/"))) href += "/"; generatedXML.writeText(rewriteUrl(href)); generatedXML.writeElement(null, "href", XMLWriter.CLOSING); String resourceName = path; int lastSlash = path.lastIndexOf('/'); if (lastSlash != -1) resourceName = resourceName.substring(lastSlash + 1); switch(type) { case FIND_ALL_PROP: generatedXML.writeElement(null, "propstat", XMLWriter.OPENING); generatedXML.writeElement(null, "prop", XMLWriter.OPENING); generatedXML.writeProperty(null, "creationdate", getISOCreationDate(cacheEntry.attributes.getCreation())); generatedXML.writeElement(null, "displayname", XMLWriter.OPENING); generatedXML.writeData(resourceName); generatedXML.writeElement(null, "displayname", XMLWriter.CLOSING); if (cacheEntry.resource != null) { generatedXML.writeProperty(null, "getlastmodified", FastHttpDateFormat.formatDate(cacheEntry.attributes.getLastModified(), null)); generatedXML.writeProperty(null, "getcontentlength", String.valueOf(cacheEntry.attributes.getContentLength())); String contentType = getServletContext().getMimeType(cacheEntry.name); if (contentType != null) { generatedXML.writeProperty(null, "getcontenttype", contentType); } generatedXML.writeProperty(null, "getetag", cacheEntry.attributes.getETag()); generatedXML.writeElement(null, "resourcetype", XMLWriter.NO_CONTENT); } else { generatedXML.writeElement(null, "resourcetype", XMLWriter.OPENING); generatedXML.writeElement(null, "collection", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "resourcetype", XMLWriter.CLOSING); } generatedXML.writeProperty(null, "source", ""); String supportedLocks = "<lockentry>" + "<lockscope><exclusive/></lockscope>" + "<locktype><write/></locktype>" + "</lockentry>" + "<lockentry>" + "<lockscope><shared/></lockscope>" + "<locktype><write/></locktype>" + "</lockentry>"; generatedXML.writeElement(null, "supportedlock", XMLWriter.OPENING); generatedXML.writeText(supportedLocks); generatedXML.writeElement(null, "supportedlock", XMLWriter.CLOSING); generateLockDiscovery(path, generatedXML); generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText(status); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "propstat", XMLWriter.CLOSING); break; case FIND_PROPERTY_NAMES: generatedXML.writeElement(null, "propstat", XMLWriter.OPENING); generatedXML.writeElement(null, "prop", XMLWriter.OPENING); generatedXML.writeElement(null, "creationdate", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "displayname", XMLWriter.NO_CONTENT); if (cacheEntry.resource != null) { generatedXML.writeElement(null, "getcontentlanguage", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "getcontentlength", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "getcontenttype", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "getetag", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "getlastmodified", XMLWriter.NO_CONTENT); } generatedXML.writeElement(null, "resourcetype", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "source", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "lockdiscovery", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText(status); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "propstat", XMLWriter.CLOSING); break; case FIND_BY_PROPERTY: Vector<String> propertiesNotFound = new Vector<String>(); generatedXML.writeElement(null, "propstat", XMLWriter.OPENING); generatedXML.writeElement(null, "prop", XMLWriter.OPENING); Enumeration<String> properties = propertiesVector.elements(); while (properties.hasMoreElements()) { String property = properties.nextElement(); if (property.equals("creationdate")) { generatedXML.writeProperty(null, "creationdate", getISOCreationDate(cacheEntry.attributes.getCreation())); } else if (property.equals("displayname")) { generatedXML.writeElement(null, "displayname", XMLWriter.OPENING); generatedXML.writeData(resourceName); generatedXML.writeElement(null, "displayname", XMLWriter.CLOSING); } else if (property.equals("getcontentlanguage")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeElement(null, "getcontentlanguage", XMLWriter.NO_CONTENT); } } else if (property.equals("getcontentlength")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeProperty(null, "getcontentlength", (String.valueOf(cacheEntry.attributes.getContentLength()))); } } else if (property.equals("getcontenttype")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeProperty(null, "getcontenttype", getServletContext().getMimeType(cacheEntry.name)); } } else if (property.equals("getetag")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeProperty(null, "getetag", cacheEntry.attributes.getETag()); } } else if (property.equals("getlastmodified")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeProperty(null, "getlastmodified", FastHttpDateFormat.formatDate(cacheEntry.attributes.getLastModified(), null)); } } else if (property.equals("resourcetype")) { if (cacheEntry.context != null) { generatedXML.writeElement(null, "resourcetype", XMLWriter.OPENING); generatedXML.writeElement(null, "collection", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "resourcetype", XMLWriter.CLOSING); } else { generatedXML.writeElement(null, "resourcetype", XMLWriter.NO_CONTENT); } } else if (property.equals("source")) { generatedXML.writeProperty(null, "source", ""); } else if (property.equals("supportedlock")) { supportedLocks = "<lockentry>" + "<lockscope><exclusive/></lockscope>" + "<locktype><write/></locktype>" + "</lockentry>" + "<lockentry>" + "<lockscope><shared/></lockscope>" + "<locktype><write/></locktype>" + "</lockentry>"; generatedXML.writeElement(null, "supportedlock", XMLWriter.OPENING); generatedXML.writeText(supportedLocks); generatedXML.writeElement(null, "supportedlock", XMLWriter.CLOSING); } else if (property.equals("lockdiscovery")) { if (!generateLockDiscovery(path, generatedXML)) propertiesNotFound.addElement(property); } else { propertiesNotFound.addElement(property); } } generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText(status); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "propstat", XMLWriter.CLOSING); Enumeration<String> propertiesNotFoundList = propertiesNotFound.elements(); if (propertiesNotFoundList.hasMoreElements()) { status = new String("HTTP/1.1 " + WebdavStatus.SC_NOT_FOUND + " " + WebdavStatus.getStatusText(WebdavStatus.SC_NOT_FOUND)); generatedXML.writeElement(null, "propstat", XMLWriter.OPENING); generatedXML.writeElement(null, "prop", XMLWriter.OPENING); while (propertiesNotFoundList.hasMoreElements()) { generatedXML.writeElement(null, propertiesNotFoundList.nextElement(), XMLWriter.NO_CONTENT); } generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText(status); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "propstat", XMLWriter.CLOSING); } break; } generatedXML.writeElement(null, "response", XMLWriter.CLOSING); }
@Override public void execute() throws BuildException { super.execute(); if (path == null) { throw new BuildException("Must specify 'path' attribute"); } if ((war == null) && (localWar == null) && (config == null) && (tag == null)) { throw new BuildException("Must specify either 'war', 'localWar', 'config', or 'tag' attribute"); } BufferedInputStream stream = null; String contentType = null; int contentLength = -1; if (war != null) { if (war.startsWith("file:")) { try { URL url = new URL(war); URLConnection conn = url.openConnection(); contentLength = conn.getContentLength(); stream = new BufferedInputStream(conn.getInputStream(), 1024); } catch (IOException e) { throw new BuildException(e); } } else { try { stream = new BufferedInputStream(new FileInputStream(war), 1024); } catch (IOException e) { throw new BuildException(e); } } contentType = "application/octet-stream"; } StringBuilder sb = new StringBuilder("/deploy?path="); try { sb.append(URLEncoder.encode(this.path, getCharset())); if ((war == null) && (config != null)) { sb.append("&config="); sb.append(URLEncoder.encode(config, getCharset())); } if ((war == null) && (localWar != null)) { sb.append("&war="); sb.append(URLEncoder.encode(localWar, getCharset())); } if (update) { sb.append("&update=true"); } if (tag != null) { sb.append("&tag="); sb.append(URLEncoder.encode(tag, getCharset())); } } catch (UnsupportedEncodingException e) { throw new BuildException("Invalid 'charset' attribute: " + getCharset()); } execute(sb.toString(), stream, contentType, contentLength); }	public void execute(String command, InputStream istream, String contentType, int contentLength) throws BuildException { URLConnection conn = null; InputStreamReader reader = null; try { conn = (new URL(url + command)).openConnection(); HttpURLConnection hconn = (HttpURLConnection) conn; hconn.setAllowUserInteraction(false); hconn.setDoInput(true); hconn.setUseCaches(false); if (istream != null) { hconn.setDoOutput(true); hconn.setRequestMethod("PUT"); if (contentType != null) { hconn.setRequestProperty("Content-Type", contentType); } if (contentLength >= 0) { hconn.setRequestProperty("Content-Length", "" + contentLength); } } else { hconn.setDoOutput(false); hconn.setRequestMethod("GET"); } hconn.setRequestProperty("User-Agent", "Catalina-Ant-Task/1.0"); String input = username + ":" + password; String output = new String(Base64.encode(input.getBytes())); hconn.setRequestProperty("Authorization", "Basic " + output); hconn.connect(); if (istream != null) { BufferedOutputStream ostream = new BufferedOutputStream(hconn.getOutputStream(), 1024); byte[] buffer = new byte[1024]; while (true) { int n = istream.read(buffer); if (n < 0) { break; } ostream.write(buffer, 0, n); } ostream.flush(); ostream.close(); istream.close(); } reader = new InputStreamReader(hconn.getInputStream(), CHARSET); StringBuilder buff = new StringBuilder(); String error = null; int msgPriority = Project.MSG_INFO; boolean first = true; while (true) { int ch = reader.read(); if (ch < 0) { break; } else if ((ch == '\r') || (ch == '\n')) { if (buff.length() > 0) { String line = buff.toString(); buff.setLength(0); if (first) { if (!line.startsWith("OK -")) { error = line; msgPriority = Project.MSG_ERR; } first = false; } handleOutput(line, msgPriority); } } else { buff.append((char) ch); } } if (buff.length() > 0) { handleOutput(buff.toString(), msgPriority); } if (error != null && isFailOnError()) { throw new BuildException(error); } } catch (Throwable t) { if (isFailOnError()) { throw new BuildException(t); } else { handleErrorOutput(t.getMessage()); } } finally { closeRedirector(); if (reader != null) { try { reader.close(); } catch (Throwable u) { // Ignore } reader = null; } if (istream != null) { try { istream.close(); } catch (Throwable u) { // Ignore } istream = null; } } }
public static synchronized void setDefaultFactory(JspFactory deflt) { JspFactory.deflt = deflt; }
protected ResourceEntry findResourceInternal(String name, String path) { if (!started) { log.info(sm.getString("webappClassLoader.stopped", name)); return null; } if ((name == null) || (path == null)) return null; ResourceEntry entry = resourceEntries.get(name); if (entry != null) return entry; int contentLength = -1; InputStream binaryStream = null; int jarFilesLength = jarFiles.length; int repositoriesLength = repositories.length; int i; Resource resource = null; boolean fileNeedConvert = false; for (i = 0; (entry == null) && (i < repositoriesLength); i++) { try { String fullPath = repositories[i] + path; Object lookupResult = resources.lookup(fullPath); if (lookupResult instanceof Resource) { resource = (Resource) lookupResult; } // Note : Not getting an exception here means the resource was entry = findResourceInternal(files[i], path); ResourceAttributes attributes = (ResourceAttributes) resources.getAttributes(fullPath); contentLength = (int) attributes.getContentLength(); entry.lastModified = attributes.getLastModified(); if (resource != null) { try { binaryStream = resource.streamContent(); } catch (IOException e) { return null; } if (needConvert) { if (path.endsWith(".properties")) { fileNeedConvert = true; } } synchronized (allPermission) { int j; long[] result2 = new long[lastModifiedDates.length + 1]; for (j = 0; j < lastModifiedDates.length; j++) { result2[j] = lastModifiedDates[j]; } result2[lastModifiedDates.length] = entry.lastModified; lastModifiedDates = result2; String[] result = new String[paths.length + 1]; for (j = 0; j < paths.length; j++) { result[j] = paths[j]; } result[paths.length] = fullPath; paths = result; } } } catch (NamingException e) { } } if ((entry == null) && (notFoundResources.containsKey(name))) return null; JarEntry jarEntry = null; synchronized (jarFiles) { if (!openJARs()) { return null; } for (i = 0; (entry == null) && (i < jarFilesLength); i++) { jarEntry = jarFiles[i].getJarEntry(path); if (jarEntry != null) { entry = new ResourceEntry(); try { entry.codeBase = getURL(jarRealFiles[i], false); String jarFakeUrl = getURI(jarRealFiles[i]).toString(); jarFakeUrl = "jar:" + jarFakeUrl + "!/" + path; entry.source = new URL(jarFakeUrl); entry.lastModified = jarRealFiles[i].lastModified(); } catch (MalformedURLException e) { return null; } contentLength = (int) jarEntry.getSize(); try { entry.manifest = jarFiles[i].getManifest(); binaryStream = jarFiles[i].getInputStream(jarEntry); } catch (IOException e) { return null; } if (antiJARLocking && !(path.endsWith(".class"))) { byte[] buf = new byte[1024]; File resourceFile = new File(loaderDir, jarEntry.getName()); if (!resourceFile.exists()) { Enumeration<JarEntry> entries = jarFiles[i].entries(); while (entries.hasMoreElements()) { JarEntry jarEntry2 = entries.nextElement(); if (!(jarEntry2.isDirectory()) && (!jarEntry2.getName().endsWith(".class"))) { resourceFile = new File(loaderDir, jarEntry2.getName()); try { if (!resourceFile.getCanonicalPath().startsWith(canonicalLoaderDir)) { throw new IllegalArgumentException(sm.getString("webappClassLoader.illegalJarPath", jarEntry2.getName())); } } catch (IOException ioe) { throw new IllegalArgumentException(sm.getString("webappClassLoader.validationErrorJarPath", jarEntry2.getName()), ioe); } resourceFile.getParentFile().mkdirs(); FileOutputStream os = null; InputStream is = null; try { is = jarFiles[i].getInputStream(jarEntry2); os = new FileOutputStream(resourceFile); while (true) { int n = is.read(buf); if (n <= 0) { break; } os.write(buf, 0, n); } } catch (IOException e) { // Ignore } finally { try { if (is != null) { is.close(); } } catch (IOException e) { } try { if (os != null) { os.close(); } } catch (IOException e) { } } } } } } } } if (entry == null) { synchronized (notFoundResources) { notFoundResources.put(name, name); } return null; } if (binaryStream != null) { byte[] binaryContent = new byte[contentLength]; int pos = 0; try { while (true) { int n = binaryStream.read(binaryContent, pos, binaryContent.length - pos); if (n <= 0) break; pos += n; } } catch (IOException e) { log.error(sm.getString("webappClassLoader.readError", name), e); return null; } finally { try { binaryStream.close(); } catch (IOException e) { } } if (fileNeedConvert) { // Workaround for certain files on platforms that use // EBCDIC encoding, when they are read through FileInputStream. // See commit message of rev.303915 for details String str = new String(binaryContent, 0, pos); try { binaryContent = str.getBytes("UTF-8"); } catch (Exception e) { return null; } } entry.binaryContent = binaryContent; if (jarEntry != null) { entry.certificates = jarEntry.getCertificates(); } } } synchronized (resourceEntries) { // Ensures that all the threads which may be in a race to load // a particular class all end up with the same ResourceEntry ResourceEntry entry2 = resourceEntries.get(name); if (entry2 == null) { resourceEntries.put(name, entry); } else { entry = entry2; } } return entry; }

protected void doLoad() throws ClassNotFoundException, IOException { if (log.isDebugEnabled()) log.debug("Start: Loading persisted sessions"); sessions.clear(); File file = file(); if (file == null) return; if (log.isDebugEnabled()) log.debug(sm.getString("standardManager.loading", pathname)); FileInputStream fis = null; ObjectInputStream ois = null; Loader loader = null; ClassLoader classLoader = null; try { fis = new FileInputStream(file.getAbsolutePath()); BufferedInputStream bis = new BufferedInputStream(fis); if (container != null) loader = container.getLoader(); if (loader != null) classLoader = loader.getClassLoader(); if (classLoader != null) { if (log.isDebugEnabled()) log.debug("Creating custom object input stream for class loader "); ois = new CustomObjectInputStream(bis, classLoader); } else { if (log.isDebugEnabled()) log.debug("Creating standard object input stream"); ois = new ObjectInputStream(bis); } } catch (FileNotFoundException e) { if (log.isDebugEnabled()) log.debug("No persisted data file found"); return; } catch (IOException e) { log.error(sm.getString("standardManager.loading.ioe", e), e); if (ois != null) { try { ois.close(); } catch (IOException f) { // Ignore } ois = null; } throw e; } synchronized (sessions) { try { Integer count = (Integer) ois.readObject(); int n = count.intValue(); if (log.isDebugEnabled()) log.debug("Loading " + n + " persisted sessions"); for (int i = 0; i < n; i++) { StandardSession session = getNewSession(); session.readObjectData(ois); session.setManager(this); sessions.put(session.getIdInternal(), session); session.activate(); sessionCounter++; } } catch (ClassNotFoundException e) { log.error(sm.getString("standardManager.loading.cnfe", e), e); if (ois != null) { try { ois.close(); } catch (IOException f) { // Ignore } ois = null; } throw e; } catch (IOException e) { log.error(sm.getString("standardManager.loading.ioe", e), e); if (ois != null) { try { ois.close(); } catch (IOException f) { // Ignore } ois = null; } throw e; } finally { try { if (ois != null) ois.close(); } catch (IOException f) { // ignored } if (file.exists()) file.delete(); } } if (log.isDebugEnabled()) log.debug("Finish: Loading persisted sessions"); }	protected void doUnload() throws IOException { if (log.isDebugEnabled()) log.debug("Unloading persisted sessions"); File file = file(); if (file == null) return; if (log.isDebugEnabled()) log.debug(sm.getString("standardManager.unloading", pathname)); FileOutputStream fos = null; ObjectOutputStream oos = null; try { fos = new FileOutputStream(file.getAbsolutePath()); oos = new ObjectOutputStream(new BufferedOutputStream(fos)); } catch (IOException e) { log.error(sm.getString("standardManager.unloading.ioe", e), e); if (oos != null) { try { oos.close(); } catch (IOException f) { // Ignore } oos = null; } throw e; } ArrayList<StandardSession> list = new ArrayList<StandardSession>(); synchronized (sessions) { if (log.isDebugEnabled()) log.debug("Unloading " + sessions.size() + " sessions"); try { oos.writeObject(new Integer(sessions.size())); Iterator<Session> elements = sessions.values().iterator(); while (elements.hasNext()) { StandardSession session = (StandardSession) elements.next(); list.add(session); session.passivate(); session.writeObjectData(oos); } } catch (IOException e) { log.error(sm.getString("standardManager.unloading.ioe", e), e); if (oos != null) { try { oos.close(); } catch (IOException f) { // Ignore } oos = null; } throw e; } } try { oos.flush(); oos.close(); oos = null; } catch (IOException e) { if (oos != null) { try { oos.close(); } catch (IOException f) { // Ignore } oos = null; } throw e; } if (log.isDebugEnabled()) log.debug("Expiring " + list.size() + " persisted sessions"); Iterator<StandardSession> expires = list.iterator(); while (expires.hasNext()) { StandardSession session = expires.next(); try { session.expire(false); } catch (Throwable t) { // Ignore } finally { session.recycle(); } } if (log.isDebugEnabled()) log.debug("Unloading complete"); }	public Session load(String id) throws ClassNotFoundException, IOException { File file = file(id); if (file == null) { return (null); } if (!file.exists()) { return (null); } if (manager.getContainer().getLogger().isDebugEnabled()) { manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".loading", id, file.getAbsolutePath())); } FileInputStream fis = null; ObjectInputStream ois = null; Loader loader = null; ClassLoader classLoader = null; try { fis = new FileInputStream(file.getAbsolutePath()); BufferedInputStream bis = new BufferedInputStream(fis); Container container = manager.getContainer(); if (container != null) loader = container.getLoader(); if (loader != null) classLoader = loader.getClassLoader(); if (classLoader != null) ois = new CustomObjectInputStream(bis, classLoader); else ois = new ObjectInputStream(bis); } catch (FileNotFoundException e) { if (manager.getContainer().getLogger().isDebugEnabled()) manager.getContainer().getLogger().debug("No persisted data file found"); return (null); } catch (IOException e) { if (ois != null) { try { ois.close(); } catch (IOException f) { // Ignore } ois = null; } throw e; } try { StandardSession session = (StandardSession) manager.createEmptySession(); session.readObjectData(ois); session.setManager(manager); return (session); } finally { if (ois != null) { try { ois.close(); } catch (IOException f) { // Ignore } } } }	public void save(Session session) throws IOException { File file = file(session.getIdInternal()); if (file == null) { return; } if (manager.getContainer().getLogger().isDebugEnabled()) { manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".saving", session.getIdInternal(), file.getAbsolutePath())); } FileOutputStream fos = null; ObjectOutputStream oos = null; try { fos = new FileOutputStream(file.getAbsolutePath()); oos = new ObjectOutputStream(new BufferedOutputStream(fos)); } catch (IOException e) { if (oos != null) { try { oos.close(); } catch (IOException f) { // Ignore } } throw e; } try { ((StandardSession) session).writeObjectData(oos); } finally { oos.close(); } }
public void await() { server.await(); }	public void load() { long t1 = System.nanoTime(); initDirs(); initNaming(); Digester digester = createStartDigester(); InputSource inputSource = null; InputStream inputStream = null; File file = null; try { file = configFile(); inputStream = new FileInputStream(file); inputSource = new InputSource("file://" + file.getAbsolutePath()); } catch (Exception e) { // Ignore } if (inputStream == null) { try { inputStream = getClass().getClassLoader().getResourceAsStream(getConfigFile()); inputSource = new InputSource(getClass().getClassLoader().getResource(getConfigFile()).toString()); } catch (Exception e) { // Ignore } } if (inputStream == null) { try { inputStream = getClass().getClassLoader().getResourceAsStream("server-embed.xml"); inputSource = new InputSource(getClass().getClassLoader().getResource("server-embed.xml").toString()); } catch (Exception e) { // Ignore } } if ((inputStream == null) && (file != null)) { log.warn("Can't load server.xml from " + file.getAbsolutePath()); if (file.exists() && !file.canRead()) { log.warn("Permissions incorrect, read permission is not allowed on the file."); } return; } try { inputSource.setByteStream(inputStream); digester.push(this); digester.parse(inputSource); inputStream.close(); } catch (Exception e) { log.warn("Catalina.start using " + getConfigFile() + ": ", e); return; } initStreams(); if (server instanceof Lifecycle) { try { server.initialize(); } catch (LifecycleException e) { if (Boolean.getBoolean("org.apache.catalina.startup.EXIT_ON_INIT_FAILURE")) throw new java.lang.Error(e); else log.error("Catalina.start", e); } } long t2 = System.nanoTime(); if (log.isInfoEnabled()) log.info("Initialization processed in " + ((t2 - t1) / 1000000) + " ms"); }	protected void usage() { System.out.println("usage: java org.apache.catalina.startup.Catalina" + " [ -config {pathname} ]" + " [ -nonaming ] " + " { -help | start | stop }"); }	public void setParentClassLoader(ClassLoader parentClassLoader) { this.parentClassLoader = parentClassLoader; }	@Override public void start() { if (server == null) { load(); } if (server == null) { log.fatal("Cannot start server. Server instance is not configured."); return; } long t1 = System.nanoTime(); if (server instanceof Lifecycle) { try { ((Lifecycle) server).start(); } catch (LifecycleException e) { log.error("Catalina.start: ", e); } } long t2 = System.nanoTime(); if (log.isInfoEnabled()) log.info("Server startup in " + ((t2 - t1) / 1000000) + " ms"); try { if (useShutdownHook) { if (shutdownHook == null) { shutdownHook = new CatalinaShutdownHook(); } Runtime.getRuntime().addShutdownHook(shutdownHook); } } catch (Throwable t) { // This will fail on JDK 1.2. Ignoring, as Tomcat can run // fine without the shutdown hook. } if (await) { await(); stop(); } }	@Override public void stop() { try { if (useShutdownHook) { Runtime.getRuntime().removeShutdownHook(shutdownHook); } } catch (Throwable t) { // This will fail on JDK 1.2. Ignoring, as Tomcat can run // fine without the shutdown hook. } if (server instanceof Lifecycle) { try { ((Lifecycle) server).stop(); } catch (LifecycleException e) { log.error("Catalina.stop", e); } } }	public void stopServer(String[] arguments) { if (arguments != null) { arguments(arguments); } if (server == null) { Digester digester = createStopDigester(); digester.setClassLoader(Thread.currentThread().getContextClassLoader()); File file = configFile(); try { InputSource is = new InputSource("file://" + file.getAbsolutePath()); FileInputStream fis = new FileInputStream(file); is.setByteStream(fis); digester.push(this); digester.parse(is); fis.close(); } catch (Exception e) { log.error("Catalina.stop: ", e); System.exit(1); } } try { if (server.getPort() > 0) { Socket socket = new Socket(server.getAddress(), server.getPort()); OutputStream stream = socket.getOutputStream(); String shutdown = server.getShutdown(); for (int i = 0; i < shutdown.length(); i++) stream.write(shutdown.charAt(i)); stream.flush(); stream.close(); socket.close(); } else { log.error(sm.getString("catalina.stopServer")); System.exit(1); } } catch (IOException e) { log.error("Catalina.stop: ", e); System.exit(1); } }
public static Set<WebXml> orderWebFragments(WebXml application, Map<String, WebXml> fragments) { Set<WebXml> orderedFragments = new LinkedHashSet<WebXml>(); boolean absoluteOrdering = (application.getAbsoluteOrdering() != null); if (absoluteOrdering) { Set<String> requestedOrder = application.getAbsoluteOrdering(); for (String requestedName : requestedOrder) { if (WebXml.ORDER_OTHERS.equals(requestedName)) { for (String name : fragments.keySet()) { if (!requestedOrder.contains(name)) { WebXml fragment = fragments.get(name); if (fragment != null) { orderedFragments.add(fragment); } } } } else { WebXml fragment = fragments.get(requestedName); if (fragment != null) { orderedFragments.add(fragment); } } } } else { List<String> order = new LinkedList<String>(); order.addAll(fragments.keySet()); for (WebXml fragment : fragments.values()) { String name = fragment.getName(); if (fragment.getBeforeOrder().contains(WebXml.ORDER_OTHERS)) { order.remove(name); order.add(0, name); } else if (fragment.getAfterOrder().contains(WebXml.ORDER_OTHERS)) { order.remove(name); order.add(name); } } for (WebXml fragment : fragments.values()) { String name = fragment.getName(); for (String before : fragment.getBeforeOrder()) { if (!before.equals(WebXml.ORDER_OTHERS) && order.contains(before) && order.indexOf(before) < order.indexOf(name)) { order.remove(name); order.add(order.indexOf(before), name); } } for (String after : fragment.getAfterOrder()) { if (!after.equals(WebXml.ORDER_OTHERS) && order.contains(after) && order.indexOf(after) > order.indexOf(name)) { order.remove(name); order.add(order.indexOf(after) + 1, name); } } } for (WebXml fragment : fragments.values()) { String name = fragment.getName(); for (String before : fragment.getBeforeOrder()) { if (!before.equals(WebXml.ORDER_OTHERS) && order.contains(before) && order.indexOf(before) < order.indexOf(name)) { throw new IllegalArgumentException(sm.getString("")); } } for (String after : fragment.getAfterOrder()) { if (!after.equals(WebXml.ORDER_OTHERS) && order.contains(after) && order.indexOf(after) > order.indexOf(name)) { throw new IllegalArgumentException(); } } } for (String name : order) { orderedFragments.add(fragments.get(name)); } } return orderedFragments; }	private static <T> boolean mergeMap(Map<String, T> fragmentMap, Map<String, T> mainMap, Map<String, T> tempMap, WebXml fragment, String mapName) { for (String key : fragmentMap.keySet()) { if (!mainMap.containsKey(key)) { T value = fragmentMap.get(key); if (tempMap.containsKey(key)) { if (value != null && !value.equals(tempMap.get(key))) { log.error(sm.getString("webXml.mergeConflictString", mapName, key, fragment.getName(), fragment.getURL())); return false; } } else { tempMap.put(key, value); } } } return true; }	public static String toString(ByteChunk bc) { if (bcCache == null) { String value = bc.toStringInternal(); if (byteEnabled && (value.length() < maxStringSize)) { synchronized (bcStats) { if (bcCache != null) { return value; } if (bcCount > trainThreshold) { long t1 = System.currentTimeMillis(); TreeMap<Integer, ArrayList<ByteEntry>> tempMap = new TreeMap<Integer, ArrayList<ByteEntry>>(); Iterator<ByteEntry> entries = bcStats.keySet().iterator(); while (entries.hasNext()) { ByteEntry entry = entries.next(); int[] countA = bcStats.get(entry); Integer count = new Integer(countA[0]); ArrayList<ByteEntry> list = tempMap.get(count); if (list == null) { list = new ArrayList<ByteEntry>(); tempMap.put(count, list); } list.add(entry); } int size = bcStats.size(); if (size > cacheSize) { size = cacheSize; } ByteEntry[] tempbcCache = new ByteEntry[size]; // Fill it up using an alphabetical order ByteChunk tempChunk = new ByteChunk(); int n = 0; while (n < size) { Object key = tempMap.lastKey(); ArrayList<ByteEntry> list = tempMap.get(key); for (int i = 0; i < list.size() && n < size; i++) { ByteEntry entry = list.get(i); tempChunk.setBytes(entry.name, 0, entry.name.length); int insertPos = findClosest(tempChunk, tempbcCache, n); if (insertPos == n) { tempbcCache[n + 1] = entry; } else { System.arraycopy(tempbcCache, insertPos + 1, tempbcCache, insertPos + 2, n - insertPos - 1); tempbcCache[insertPos + 1] = entry; } n++; } tempMap.remove(key); } bcCount = 0; bcStats.clear(); bcCache = tempbcCache; if (log.isDebugEnabled()) { long t2 = System.currentTimeMillis(); log.debug("ByteCache generation time: " + (t2 - t1) + "ms"); } } else { bcCount++; ByteEntry entry = new ByteEntry(); entry.value = value; int[] count = bcStats.get(entry); if (count == null) { int end = bc.getEnd(); int start = bc.getStart(); entry.name = new byte[bc.getLength()]; System.arraycopy(bc.getBuffer(), start, entry.name, 0, end - start); entry.enc = bc.getEncoding(); count = new int[1]; count[0] = 1; bcStats.put(entry, count); } else { count[0] = count[0] + 1; } } } } return value; } else { accessCount++; String result = find(bc); if (result == null) { return bc.toStringInternal(); } hitCount++; return result; } }	public static String toString(CharChunk cc) { if (ccCache == null) { String value = cc.toStringInternal(); if (charEnabled && (value.length() < maxStringSize)) { synchronized (ccStats) { if (ccCache != null) { return value; } if (ccCount > trainThreshold) { long t1 = System.currentTimeMillis(); TreeMap<Integer, ArrayList<CharEntry>> tempMap = new TreeMap<Integer, ArrayList<CharEntry>>(); Iterator<CharEntry> entries = ccStats.keySet().iterator(); while (entries.hasNext()) { CharEntry entry = entries.next(); int[] countA = ccStats.get(entry); Integer count = new Integer(countA[0]); ArrayList<CharEntry> list = tempMap.get(count); if (list == null) { list = new ArrayList<CharEntry>(); tempMap.put(count, list); } list.add(entry); } int size = ccStats.size(); if (size > cacheSize) { size = cacheSize; } CharEntry[] tempccCache = new CharEntry[size]; // Fill it up using an alphabetical order CharChunk tempChunk = new CharChunk(); int n = 0; while (n < size) { Object key = tempMap.lastKey(); ArrayList<CharEntry> list = tempMap.get(key); for (int i = 0; i < list.size() && n < size; i++) { CharEntry entry = list.get(i); tempChunk.setChars(entry.name, 0, entry.name.length); int insertPos = findClosest(tempChunk, tempccCache, n); if (insertPos == n) { tempccCache[n + 1] = entry; } else { System.arraycopy(tempccCache, insertPos + 1, tempccCache, insertPos + 2, n - insertPos - 1); tempccCache[insertPos + 1] = entry; } n++; } tempMap.remove(key); } ccCount = 0; ccStats.clear(); ccCache = tempccCache; if (log.isDebugEnabled()) { long t2 = System.currentTimeMillis(); log.debug("CharCache generation time: " + (t2 - t1) + "ms"); } } else { ccCount++; CharEntry entry = new CharEntry(); entry.value = value; int[] count = ccStats.get(entry); if (count == null) { int end = cc.getEnd(); int start = cc.getStart(); entry.name = new char[cc.getLength()]; System.arraycopy(cc.getBuffer(), start, entry.name, 0, end - start); count = new int[1]; count[0] = 1; ccStats.put(entry, count); } else { count[0] = count[0] + 1; } } } } return value; } else { accessCount++; String result = find(cc); if (result == null) { return cc.toStringInternal(); } hitCount++; return result; } }	public void configureContext(Context context) { // As far as possible, process in alphabetical order so it is easy to // check everything is present context.setPublicId(publicId); for (String contextParam : contextParams.keySet()) { context.addParameter(contextParam, contextParams.get(contextParam)); } context.setDisplayName(displayName); context.setDistributable(distributable); for (ContextLocalEjb ejbLocalRef : ejbLocalRefs.values()) { context.getNamingResources().addLocalEjb(ejbLocalRef); } for (ContextEjb ejbRef : ejbRefs.values()) { context.getNamingResources().addEjb(ejbRef); } for (ContextEnvironment environment : envEntries.values()) { context.getNamingResources().addEnvironment(environment); } for (ErrorPage errorPage : errorPages.values()) { context.addErrorPage(errorPage); } for (FilterDef filter : filters.values()) { context.addFilterDef(filter); } for (FilterMap filterMap : filterMaps) { context.addFilterMap(filterMap); } for (String listener : listeners) { context.addApplicationListener(listener); } for (String locale : localeEncodingMappings.keySet()) { context.addLocaleEncodingMappingParameter(locale, localeEncodingMappings.get(locale)); } if (loginConfig != null) { context.setLoginConfig(loginConfig); } for (MessageDestinationRef mdr : messageDestinationRefs.values()) { context.getNamingResources().addMessageDestinationRef(mdr); } context.setIgnoreAnnotations(metadataComplete); for (String extension : mimeMappings.keySet()) { context.addMimeMapping(extension, mimeMappings.get(extension)); } for (ContextResourceEnvRef resource : resourceEnvRefs.values()) { context.getNamingResources().addResourceEnvRef(resource); } for (ContextResource resource : resourceRefs.values()) { context.getNamingResources().addResource(resource); } for (SecurityConstraint constraint : securityConstraints) { context.addConstraint(constraint); } for (String role : securityRoles) { context.addSecurityRole(role); } for (ContextService service : serviceRefs.values()) { context.getNamingResources().addService(service); } for (ServletDef servlet : servlets.values()) { Wrapper wrapper = context.createWrapper(); // Description is ignored // Display name is ignored // Icons are ignored // Only set this if it is non-null else every servlet will get String jspFile = servlet.getJspFile(); if (jspFile != null) { wrapper.setJspFile(jspFile); } if (servlet.getLoadOnStartup() != null) { wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue()); } if (servlet.getEnabled() != null) { wrapper.setEnabled(servlet.getEnabled().booleanValue()); } wrapper.setName(servlet.getServletName()); Map<String, String> params = servlet.getParameterMap(); for (String param : params.keySet()) { wrapper.addInitParameter(param, params.get(param)); } wrapper.setRunAs(servlet.getRunAs()); Set<SecurityRoleRef> roleRefs = servlet.getSecurityRoleRefs(); for (SecurityRoleRef roleRef : roleRefs) { wrapper.addSecurityReference(roleRef.getName(), roleRef.getLink()); } wrapper.setServletClass(servlet.getServletClass()); MultipartDef multipartdef = servlet.getMultipartDef(); if (multipartdef != null) { if (multipartdef.getMaxFileSize() != null && multipartdef.getMaxRequestSize() != null && multipartdef.getFileSizeThreshold() != null) { wrapper.setMultipartConfigElement(new MultipartConfigElement(multipartdef.getLocation(), Long.parseLong(multipartdef.getMaxFileSize()), Long.parseLong(multipartdef.getMaxRequestSize()), Integer.parseInt(multipartdef.getFileSizeThreshold()))); } else { wrapper.setMultipartConfigElement(new MultipartConfigElement(multipartdef.getLocation())); } } if (servlet.getAsyncSupported() != null) { wrapper.setAsyncSupported(servlet.getAsyncSupported().booleanValue()); } context.addChild(wrapper); } for (String pattern : servletMappings.keySet()) { context.addServletMapping(pattern, servletMappings.get(pattern)); } if (sessionConfig != null) { if (sessionConfig.getSessionTimeout() != null) { context.setSessionTimeout(sessionConfig.getSessionTimeout().intValue()); } SessionCookieConfig scc = context.getServletContext().getSessionCookieConfig(); scc.setName(sessionConfig.getCookieName()); scc.setDomain(sessionConfig.getCookieDomain()); scc.setPath(sessionConfig.getCookiePath()); scc.setComment(sessionConfig.getCookieComment()); if (sessionConfig.getCookieHttpOnly() != null) { scc.setHttpOnly(sessionConfig.getCookieHttpOnly().booleanValue()); } if (sessionConfig.getCookieSecure() != null) { scc.setSecure(sessionConfig.getCookieSecure().booleanValue()); } if (sessionConfig.getCookieMaxAge() != null) { scc.setMaxAge(sessionConfig.getCookieMaxAge().intValue()); } if (sessionConfig.getSessionTrackingModes().size() > 0) { context.getServletContext().setSessionTrackingModes(sessionConfig.getSessionTrackingModes()); } } for (String uri : taglibs.keySet()) { context.addTaglib(uri, taglibs.get(uri)); } for (String welcomeFile : welcomeFiles) { context.addWelcomeFile(welcomeFile); } for (JspPropertyGroup jspPropertyGroup : jspPropertyGroups) { context.addJspMapping(jspPropertyGroup.getUrlPattern()); } }
protected static boolean matchesOne(String str, Pattern... patterns) { for (Pattern pattern : patterns) { if (pattern.matcher(str).matches()) { return true; } } return false; }	public String getRemoteHost() { return remoteHost; }	public String getRemoteIpHeader() { return remoteIpHeader; }	public int getHttpsServerPort() { return httpsServerPort; }	@Override public void invoke(Request request, Response response) throws IOException, ServletException { final String originalRemoteAddr = request.getRemoteAddr(); final String originalRemoteHost = request.getRemoteHost(); final String originalScheme = request.getScheme(); final boolean originalSecure = request.isSecure(); final int originalServerPort = request.getServerPort(); if (matchesOne(originalRemoteAddr, internalProxies)) { String remoteIp = null; LinkedList<String> proxiesHeaderValue = new LinkedList<String>(); String[] remoteIPHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIpHeader)); int idx; for (idx = remoteIPHeaderValue.length - 1; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; remoteIp = currentRemoteIp; if (matchesOne(currentRemoteIp, internalProxies)) { // do nothing, internalProxies IPs are not appended to the } else if (matchesOne(currentRemoteIp, trustedProxies)) { proxiesHeaderValue.addFirst(currentRemoteIp); } else { idx--; break; } } LinkedList<String> newRemoteIpHeaderValue = new LinkedList<String>(); for (; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; newRemoteIpHeaderValue.addFirst(currentRemoteIp); } if (remoteIp != null) { request.setRemoteAddr(remoteIp); request.setRemoteHost(remoteIp); if (proxiesHeaderValue.size() == 0) { request.getCoyoteRequest().getMimeHeaders().removeHeader(proxiesHeader); } else { String commaDelimitedListOfProxies = listToCommaDelimitedString(proxiesHeaderValue); request.getCoyoteRequest().getMimeHeaders().setValue(proxiesHeader).setString(commaDelimitedListOfProxies); } if (newRemoteIpHeaderValue.size() == 0) { request.getCoyoteRequest().getMimeHeaders().removeHeader(remoteIpHeader); } else { String commaDelimitedRemoteIpHeaderValue = listToCommaDelimitedString(newRemoteIpHeaderValue); request.getCoyoteRequest().getMimeHeaders().setValue(remoteIpHeader).setString(commaDelimitedRemoteIpHeaderValue); } } if (protocolHeader != null) { String protocolHeaderValue = request.getHeader(protocolHeader); if (protocolHeaderValue != null && protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) { request.setSecure(true); request.getCoyoteRequest().scheme().setString("https"); request.setServerPort(httpsServerPort); } } if (log.isDebugEnabled()) { log.debug("Incoming request " + request.getRequestURI() + " with originalRemoteAddr '" + originalRemoteAddr + "', originalRemoteHost='" + originalRemoteHost + "', originalSecure='" + originalSecure + "', originalScheme='" + originalScheme + "' will be seen as newRemoteAddr='" + request.getRemoteAddr() + "', newRemoteHost='" + request.getRemoteHost() + "', newScheme='" + request.getScheme() + "', newSecure='" + request.isSecure() + "'"); } } try { getNext().invoke(request, response); } finally { request.setRemoteAddr(originalRemoteAddr); request.setRemoteHost(originalRemoteHost); request.setSecure(originalSecure); request.getCoyoteRequest().scheme().setString(originalScheme); request.setServerPort(originalServerPort); } }	@Override public void invoke(Request request, Response response) throws IOException, ServletException { this.remoteHost = request.getRemoteHost(); this.remoteAddr = request.getRemoteAddr(); }	public void testInvokeAllProxiesAreTrustedAndRemoteAddrMatchRegexp() throws Exception { RemoteIpValve remoteIpValve = new RemoteIpValve(); remoteIpValve.setInternalProxies("127\\.0\\.0\\.1, 192\\.168\\..*, another-internal-proxy"); remoteIpValve.setTrustedProxies("proxy1, proxy2, proxy3"); remoteIpValve.setRemoteIpHeader("x-forwarded-for"); remoteIpValve.setProxiesHeader("x-forwarded-by"); RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve(); remoteIpValve.setNext(remoteAddrAndHostTrackerValve); Request request = new Request(); request.setCoyoteRequest(new org.apache.coyote.Request()); request.setRemoteAddr("192.168.0.10"); request.setRemoteHost("remote-host-original-value"); request.getCoyoteRequest().getMimeHeaders().addValue("x-forwarded-for").setString("140.211.11.130, proxy1, proxy2"); remoteIpValve.invoke(request, null); String actualXForwardedFor = request.getHeader("x-forwarded-for"); assertNull("all proxies are trusted, x-forwarded-for must be null", actualXForwardedFor); String actualXForwardedBy = request.getHeader("x-forwarded-by"); assertEquals("all proxies are trusted, they must appear in x-forwarded-by", "proxy1, proxy2", actualXForwardedBy); String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr(); assertEquals("remoteAddr", "140.211.11.130", actualRemoteAddr); String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost(); assertEquals("remoteHost", "140.211.11.130", actualRemoteHost); String actualPostInvokeRemoteAddr = request.getRemoteAddr(); assertEquals("postInvoke remoteAddr", "192.168.0.10", actualPostInvokeRemoteAddr); String actualPostInvokeRemoteHost = request.getRemoteHost(); assertEquals("postInvoke remoteAddr", "remote-host-original-value", actualPostInvokeRemoteHost); }
protected static boolean matchesOne(String str, Pattern... patterns) { for (Pattern pattern : patterns) { if (pattern.matcher(str).matches()) { return true; } } return false; }	public void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { if (matchesOne(request.getRemoteAddr(), internalProxies)) { String remoteIp = null; LinkedList<String> proxiesHeaderValue = new LinkedList<String>(); String[] remoteIPHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIPHeader)); int idx; for (idx = remoteIPHeaderValue.length - 1; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; remoteIp = currentRemoteIp; if (matchesOne(currentRemoteIp, internalProxies)) { // do nothing, internalProxies IPs are not appended to the } else if (matchesOne(currentRemoteIp, trustedProxies)) { proxiesHeaderValue.addFirst(currentRemoteIp); } else { idx--; break; } } LinkedList<String> newRemoteIpHeaderValue = new LinkedList<String>(); for (; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; newRemoteIpHeaderValue.addFirst(currentRemoteIp); } XForwardedRequest xRequest = new XForwardedRequest(request); if (remoteIp != null) { xRequest.setRemoteAddr(remoteIp); xRequest.setRemoteHost(remoteIp); if (proxiesHeaderValue.size() == 0) { xRequest.removeHeader(proxiesHeader); } else { String commaDelimitedListOfProxies = listToCommaDelimitedString(proxiesHeaderValue); xRequest.setHeader(proxiesHeader, commaDelimitedListOfProxies); } if (newRemoteIpHeaderValue.size() == 0) { xRequest.removeHeader(remoteIPHeader); } else { String commaDelimitedRemoteIpHeaderValue = listToCommaDelimitedString(newRemoteIpHeaderValue); xRequest.setHeader(remoteIPHeader, commaDelimitedRemoteIpHeaderValue); } } if (protocolHeader != null) { String protocolHeaderValue = request.getHeader(protocolHeader); if (protocolHeaderValue != null && protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) { xRequest.setSecure(true); xRequest.setScheme("https"); xRequest.setServerPort(httpsServerPort); } } if (log.isDebugEnabled()) { log.debug("Incoming request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "', originalRemoteHost='" + request.getRemoteHost() + "', originalSecure='" + request.isSecure() + "', originalScheme='" + request.getScheme() + "', original[" + remoteIPHeader + "]='" + request.getHeader(remoteIPHeader) + ", original[" + protocolHeader + "]='" + (protocolHeader == null ? null : request.getHeader(protocolHeader)) + "' will be seen as newRemoteAddr='" + xRequest.getRemoteAddr() + "', newRemoteHost='" + xRequest.getRemoteHost() + "', newScheme='" + xRequest.getScheme() + "', newSecure='" + xRequest.isSecure() + "', new[" + remoteIPHeader + "]='" + xRequest.getHeader(remoteIPHeader) + ", new[" + proxiesHeader + "]='" + xRequest.getHeader(proxiesHeader) + "'"); } chain.doFilter(xRequest, response); } else { chain.doFilter(request, response); } }	public void init(FilterConfig filterConfig) throws ServletException { if (filterConfig.getInitParameter(INTERNAL_PROXIES_PARAMETER) != null) { setInternalProxies(filterConfig.getInitParameter(INTERNAL_PROXIES_PARAMETER)); } if (filterConfig.getInitParameter(PROTOCOL_HEADER_PARAMETER) != null) { setProtocolHeader(filterConfig.getInitParameter(PROTOCOL_HEADER_PARAMETER)); } if (filterConfig.getInitParameter(PROTOCOL_HEADER_HTTPS_VALUE_PARAMETER) != null) { setProtocolHeaderHttpsValue(filterConfig.getInitParameter(PROTOCOL_HEADER_HTTPS_VALUE_PARAMETER)); } if (filterConfig.getInitParameter(PROXIES_HEADER_PARAMETER) != null) { setProxiesHeader(filterConfig.getInitParameter(PROXIES_HEADER_PARAMETER)); } if (filterConfig.getInitParameter(REMOTE_IP_HEADER_PARAMETER) != null) { setRemoteIPHeader(filterConfig.getInitParameter(REMOTE_IP_HEADER_PARAMETER)); } if (filterConfig.getInitParameter(TRUSTED_PROXIES_PARAMETER) != null) { setTrustedProxies(filterConfig.getInitParameter(TRUSTED_PROXIES_PARAMETER)); } if (filterConfig.getInitParameter(HTTPS_SERVER_PORT_PARAMETER) != null) { try { setHttpsServerPort(Integer.parseInt(filterConfig.getInitParameter(HTTPS_SERVER_PORT_PARAMETER))); } catch (NumberFormatException e) { throw new NumberFormatException("Illegal serverPort : " + e.getMessage()); } } }	protected static String[] commaDelimitedListToStringArray(String commaDelimitedStrings) { return (commaDelimitedStrings == null || commaDelimitedStrings.length() == 0) ? new String[0] : commaSeparatedValuesPattern.split(commaDelimitedStrings); }
public static String URLDecode(byte[] bytes, String enc) { return URLDecode(bytes, null, false); }
protected synchronized Principal getPrincipal(DirContext context, String username) throws NamingException { User user = getUser(context, username); return new GenericPrincipal(user.username, user.password, getRoles(context, user)); }
protected void prepareResponse() throws IOException { boolean entityBody = true; contentDelimitation = false; OutputFilter[] outputFilters = outputBuffer.getFilters(); if (http09 == true) { outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); return; } int statusCode = response.getStatus(); if ((statusCode == 204) || (statusCode == 205) || (statusCode == 304)) { outputBuffer.addActiveFilter(outputFilters[Constants.VOID_FILTER]); entityBody = false; contentDelimitation = true; } MessageBytes methodMB = request.method(); if (methodMB.equals("HEAD")) { outputBuffer.addActiveFilter(outputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } if (this.endpoint.getUseSendfile()) { String fileName = (String) request.getAttribute("org.apache.tomcat.sendfile.filename"); if (fileName != null) { outputBuffer.addActiveFilter(outputFilters[Constants.VOID_FILTER]); contentDelimitation = true; sendfileData = new NioEndpoint.SendfileData(); sendfileData.fileName = fileName; sendfileData.pos = ((Long) request.getAttribute("org.apache.tomcat.sendfile.start")).longValue(); sendfileData.length = ((Long) request.getAttribute("org.apache.tomcat.sendfile.end")).longValue() - sendfileData.pos; } } boolean useCompression = false; if (entityBody && (compressionLevel > 0) && (sendfileData == null)) { useCompression = isCompressable(); if (useCompression) { response.setContentLength(-1); } } MimeHeaders headers = response.getMimeHeaders(); if (!entityBody) { response.setContentLength(-1); } else { String contentType = response.getContentType(); if (contentType != null) { headers.setValue("Content-Type").setString(contentType); } String contentLanguage = response.getContentLanguage(); if (contentLanguage != null) { headers.setValue("Content-Language").setString(contentLanguage); } } long contentLength = response.getContentLengthLong(); if (contentLength != -1) { headers.setValue("Content-Length").setLong(contentLength); outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } else { if (entityBody && http11 && keepAlive) { outputBuffer.addActiveFilter(outputFilters[Constants.CHUNKED_FILTER]); contentDelimitation = true; headers.addValue(Constants.TRANSFERENCODING).setString(Constants.CHUNKED); } else { outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); } } if (useCompression) { outputBuffer.addActiveFilter(outputFilters[Constants.GZIP_FILTER]); headers.setValue("Content-Encoding").setString("gzip"); headers.setValue("Vary").setString("Accept-Encoding"); } headers.setValue("Date").setString(FastHttpDateFormat.getCurrentDate()); if ((entityBody) && (!contentDelimitation)) { // Mark as close the connection after the request, and add the keepAlive = false; } // If we know that the request is bad this early, add the keepAlive = keepAlive && !statusDropsConnection(statusCode); if (!keepAlive) { headers.addValue(Constants.CONNECTION).setString(Constants.CLOSE); } else if (!http11 && !error) { headers.addValue(Constants.CONNECTION).setString(Constants.KEEPALIVE); } outputBuffer.sendStatus(); if (server != null) { headers.setValue("Server").setString(server); } else { outputBuffer.write(Constants.SERVER_BYTES); } int size = headers.size(); for (int i = 0; i < size; i++) { outputBuffer.sendHeader(headers.getName(i), headers.getValue(i)); } outputBuffer.endHeaders(); }	protected void prepareResponse() { boolean entityBody = true; contentDelimitation = false; OutputFilter[] outputFilters = outputBuffer.getFilters(); if (http09 == true) { outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); return; } int statusCode = response.getStatus(); if ((statusCode == 204) || (statusCode == 205) || (statusCode == 304)) { outputBuffer.addActiveFilter(outputFilters[Constants.VOID_FILTER]); entityBody = false; contentDelimitation = true; } MessageBytes methodMB = request.method(); if (methodMB.equals("HEAD")) { outputBuffer.addActiveFilter(outputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } if (endpoint.getUseSendfile()) { String fileName = (String) request.getAttribute("org.apache.tomcat.sendfile.filename"); if (fileName != null) { outputBuffer.addActiveFilter(outputFilters[Constants.VOID_FILTER]); contentDelimitation = true; sendfileData = new AprEndpoint.SendfileData(); sendfileData.fileName = fileName; sendfileData.start = ((Long) request.getAttribute("org.apache.tomcat.sendfile.start")).longValue(); sendfileData.end = ((Long) request.getAttribute("org.apache.tomcat.sendfile.end")).longValue(); } } boolean useCompression = false; if (entityBody && (compressionLevel > 0) && (sendfileData == null)) { useCompression = isCompressable(); if (useCompression) { response.setContentLength(-1); } } MimeHeaders headers = response.getMimeHeaders(); if (!entityBody) { response.setContentLength(-1); } else { String contentType = response.getContentType(); if (contentType != null) { headers.setValue("Content-Type").setString(contentType); } String contentLanguage = response.getContentLanguage(); if (contentLanguage != null) { headers.setValue("Content-Language").setString(contentLanguage); } } long contentLength = response.getContentLengthLong(); if (contentLength != -1) { headers.setValue("Content-Length").setLong(contentLength); outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } else { if (entityBody && http11 && keepAlive) { outputBuffer.addActiveFilter(outputFilters[Constants.CHUNKED_FILTER]); contentDelimitation = true; headers.addValue(Constants.TRANSFERENCODING).setString(Constants.CHUNKED); } else { outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); } } if (useCompression) { outputBuffer.addActiveFilter(outputFilters[Constants.GZIP_FILTER]); headers.setValue("Content-Encoding").setString("gzip"); headers.setValue("Vary").setString("Accept-Encoding"); } headers.setValue("Date").setString(FastHttpDateFormat.getCurrentDate()); if ((entityBody) && (!contentDelimitation)) { // Mark as close the connection after the request, and add the keepAlive = false; } // If we know that the request is bad this early, add the keepAlive = keepAlive && !statusDropsConnection(statusCode); if (!keepAlive) { headers.addValue(Constants.CONNECTION).setString(Constants.CLOSE); } else if (!http11 && !error) { headers.addValue(Constants.CONNECTION).setString(Constants.KEEPALIVE); } outputBuffer.sendStatus(); if (server != null) { headers.setValue("Server").setString(server); } else { outputBuffer.write(Constants.SERVER_BYTES); } int size = headers.size(); for (int i = 0; i < size; i++) { outputBuffer.sendHeader(headers.getName(i), headers.getValue(i)); } outputBuffer.endHeaders(); }	protected void prepareResponse() { boolean entityBody = true; contentDelimitation = false; OutputFilter[] outputFilters = outputBuffer.getFilters(); if (http09 == true) { outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); return; } int statusCode = response.getStatus(); if ((statusCode == 204) || (statusCode == 205) || (statusCode == 304)) { outputBuffer.addActiveFilter(outputFilters[Constants.VOID_FILTER]); entityBody = false; contentDelimitation = true; } MessageBytes methodMB = request.method(); if (methodMB.equals("HEAD")) { outputBuffer.addActiveFilter(outputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } boolean useCompression = false; if (entityBody && (compressionLevel > 0)) { useCompression = isCompressable(); if (useCompression) { response.setContentLength(-1); } } MimeHeaders headers = response.getMimeHeaders(); if (!entityBody) { response.setContentLength(-1); } else { String contentType = response.getContentType(); if (contentType != null) { headers.setValue("Content-Type").setString(contentType); } String contentLanguage = response.getContentLanguage(); if (contentLanguage != null) { headers.setValue("Content-Language").setString(contentLanguage); } } long contentLength = response.getContentLengthLong(); if (contentLength != -1) { headers.setValue("Content-Length").setLong(contentLength); outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } else { if (entityBody && http11 && keepAlive) { outputBuffer.addActiveFilter(outputFilters[Constants.CHUNKED_FILTER]); contentDelimitation = true; headers.addValue(Constants.TRANSFERENCODING).setString(Constants.CHUNKED); } else { outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]); } } if (useCompression) { outputBuffer.addActiveFilter(outputFilters[Constants.GZIP_FILTER]); headers.setValue("Content-Encoding").setString("gzip"); headers.setValue("Vary").setString("Accept-Encoding"); } String date = null; if (isSecurityEnabled) { date = AccessController.doPrivileged(new PrivilegedAction<String>() { public String run() { return FastHttpDateFormat.getCurrentDate(); } }); } else { date = FastHttpDateFormat.getCurrentDate(); } headers.setValue("Date").setString(date); if ((entityBody) && (!contentDelimitation)) { // Mark as close the connection after the request, and add the keepAlive = false; } // If we know that the request is bad this early, add the keepAlive = keepAlive && !statusDropsConnection(statusCode); if (!keepAlive) { headers.addValue(Constants.CONNECTION).setString(Constants.CLOSE); } else if (!http11 && !error) { headers.addValue(Constants.CONNECTION).setString(Constants.KEEPALIVE); } outputBuffer.sendStatus(); if (server != null) { headers.setValue("Server").setString(server); } else { outputBuffer.write(Constants.SERVER_BYTES); } int size = headers.size(); for (int i = 0; i < size; i++) { outputBuffer.sendHeader(headers.getName(i), headers.getValue(i)); } outputBuffer.endHeaders(); }
String replace(String str) { String result = str; int pos_start = result.indexOf("${"); if (pos_start != -1) { int pos_end = result.indexOf('}'); if (pos_end != -1) { String propName = result.substring(pos_start + 2, pos_end); String replacement = System.getProperty(propName); if (replacement != null) { if (pos_start > 0) { result = result.substring(0, pos_start) + replacement + replace(result.substring(pos_end + 1)); } else { result = replacement + replace(result.substring(pos_end + 1)); } } } } return result; }	public static Log getLog(String name) throws LogConfigurationException { return (getFactory().getInstance(name)); }
protected void processAnnotationsJndi(URL url, WebXml fragment) { try { URLConnection urlConn = url.openConnection(); DirContextURLConnection dcUrlConn; if (!(urlConn instanceof DirContextURLConnection)) { sm.getString("contextConfig.jndiUrl", url); return; } dcUrlConn = (DirContextURLConnection) urlConn; dcUrlConn.setUseCaches(false); String type = dcUrlConn.getHeaderField(ResourceAttributes.TYPE); if (ResourceAttributes.COLLECTION_TYPE.equals(type)) { Enumeration<String> dirs = dcUrlConn.list(); while (dirs.hasMoreElements()) { String dir = dirs.nextElement(); URL dirUrl = new URL(url.toString() + '/' + dir); processAnnotationsJndi(dirUrl, fragment); } } else { if (url.getPath().endsWith(".class")) { InputStream is = null; try { is = dcUrlConn.getInputStream(); processAnnotationsStream(is, fragment); } catch (IOException e) { log.error(sm.getString("contextConfig.inputStreamJndi", url), e); } finally { if (is != null) { try { is.close(); } catch (Throwable t) { // ignore } } } } } } catch (IOException e) { log.error(sm.getString("contextConfig.jndiUrl", url), e); } }
private boolean isAssignable(Object value, Class<?> targetClass) { if (targetClass == null) { return false; } else if (value != null && targetClass.isPrimitive()) { return false; } else if (value != null && !targetClass.isInstance(value)) { return false; } return true; }	private final void clearReferencesJdbc() { InputStream is = getResourceAsStream("org/apache/catalina/loader/JdbcLeakPrevention.class"); // We know roughly how big the class will be (~ 1K) so allow 2k as a byte[] classBytes = new byte[2048]; int offset = 0; try { int read = is.read(classBytes, offset, classBytes.length - offset); while (read > -1) { offset += read; if (offset == classBytes.length) { byte[] tmp = new byte[classBytes.length * 2]; System.arraycopy(classBytes, 0, tmp, 0, classBytes.length); classBytes = tmp; } read = is.read(classBytes, offset, classBytes.length - offset); } Class<?> lpClass = defineClass("org.apache.catalina.loader.JdbcLeakPrevention", classBytes, 0, offset); Object obj = lpClass.newInstance(); @SuppressWarnings("unchecked") List<String> driverNames = (List<String>) obj.getClass().getMethod("clearJdbcDriverRegistrations").invoke(obj); for (String name : driverNames) { log.error(sm.getString("webappClassLoader.clearJbdc", name)); } } catch (Exception e) { log.warn(sm.getString("webappClassLoader.jdbcRemoveFailed"), e); } finally { if (is != null) { try { is.close(); } catch (IOException ioe) { log.warn(sm.getString("webappClassLoader.jdbcRemoveStreamError"), ioe); } } } }	private final void clearReferencesStaticFinal() { @SuppressWarnings("unchecked") Collection<ResourceEntry> values = ((HashMap<String, ResourceEntry>) resourceEntries.clone()).values(); Iterator<ResourceEntry> loadedClasses = values.iterator(); while (loadedClasses.hasNext()) { ResourceEntry entry = loadedClasses.next(); if (entry.loadedClass != null) { Class<?> clazz = entry.loadedClass; try { Field[] fields = clazz.getDeclaredFields(); for (int i = 0; i < fields.length; i++) { if (Modifier.isStatic(fields[i].getModifiers())) { fields[i].get(null); break; } } } catch (Throwable t) { // Ignore } } } loadedClasses = values.iterator(); while (loadedClasses.hasNext()) { ResourceEntry entry = loadedClasses.next(); if (entry.loadedClass != null) { Class<?> clazz = entry.loadedClass; try { Field[] fields = clazz.getDeclaredFields(); for (int i = 0; i < fields.length; i++) { Field field = fields[i]; int mods = field.getModifiers(); if (field.getType().isPrimitive() || (field.getName().indexOf("$") != -1)) { continue; } if (Modifier.isStatic(mods)) { try { field.setAccessible(true); if (Modifier.isFinal(mods)) { if (!((field.getType().getName().startsWith("java.")) || (field.getType().getName().startsWith("javax.")))) { nullInstance(field.get(null)); } } else { field.set(null, null); if (log.isDebugEnabled()) { log.debug("Set field " + field.getName() + " to null in class " + clazz.getName()); } } } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug("Could not set field " + field.getName() + " to null in class " + clazz.getName(), t); } } } } } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug("Could not clean fields for class " + clazz.getName(), t); } } } } }	private void nullInstance(Object instance) { if (instance == null) { return; } Field[] fields = instance.getClass().getDeclaredFields(); for (int i = 0; i < fields.length; i++) { Field field = fields[i]; int mods = field.getModifiers(); if (field.getType().isPrimitive() || (field.getName().indexOf("$") != -1)) { continue; } try { field.setAccessible(true); if (Modifier.isStatic(mods) && Modifier.isFinal(mods)) { continue; } Object value = field.get(instance); if (null != value) { Class<? extends Object> valueClass = value.getClass(); if (!loadedByThisOrChild(valueClass)) { if (log.isDebugEnabled()) { log.debug("Not setting field " + field.getName() + " to null in object of class " + instance.getClass().getName() + " because the referenced object was of type " + valueClass.getName() + " which was not loaded by this WebappClassLoader."); } } else { field.set(instance, null); if (log.isDebugEnabled()) { log.debug("Set field " + field.getName() + " to null in class " + instance.getClass().getName()); } } } } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug("Could not set field " + field.getName() + " to null in object instance of class " + instance.getClass().getName(), t); } } } }	@Override public Attributes getAttributes(String name) throws NamingException { if (name.startsWith("/WEB-INF/") && name.endsWith(".tld")) { String tldName = name.substring(name.lastIndexOf("/") + 1); if (virtualMappings.containsKey(tldName)) { return new FileResourceAttributes(virtualMappings.get(tldName)); } } else if (name.startsWith("/META-INF/tags") && name.endsWith(".tag") || name.endsWith(".tagx")) { if (tagfileMappings.containsKey(name)) { return new FileResourceAttributes(tagfileMappings.get(name)); } StringTokenizer tkn = new StringTokenizer(virtualClasspath, ";"); while (tkn.hasMoreTokens()) { File file = new File(tkn.nextToken(), name); if (file.exists()) { tagfileMappings.put(name, file); return new FileResourceAttributes(file); } } } return super.getAttributes(name); }	private Class<?> getType() { return type; }	@SuppressWarnings("unchecked") @Override public MethodInfo getMethodInfo(EvaluationContext ctx, Class[] paramTypes) throws ELException { Target t = getTarget(ctx); Method m = ReflectionUtil.getMethod(t.base, t.property, paramTypes); return new MethodInfo(m.getName(), m.getReturnType(), m.getParameterTypes()); }	@SuppressWarnings("unchecked") public MethodInfo getMethodInfo(EvaluationContext ctx, Class[] paramTypes) throws ELException { throw new UnsupportedOperationException(); }	@SuppressWarnings("unchecked") public Object getContext(Class key) { if (this.map == null) { return null; } return this.map.get(key); }	@SuppressWarnings("unchecked") @Override public Object invoke(EvaluationContext ctx, Class[] paramTypes, Object[] paramValues) throws ELException { return this.getMethodExpression(ctx).invoke(ctx.getELContext(), paramValues); }	@SuppressWarnings("unchecked") public Object invoke(EvaluationContext ctx, Class[] paramTypes, Object[] paramValues) throws ELException { throw new UnsupportedOperationException(); }	@Override public VariableMapper getVariableMapper() { return this.varMapper; }	@Override public boolean isPropertyResolved() { return this.elContext.isPropertyResolved(); }	@Override public boolean isReadOnly(ELContext context, Object base, Object property) throws NullPointerException, PropertyNotFoundException, ELException { if (context == null) { throw new NullPointerException(); } if (base instanceof ResourceBundle) { context.setPropertyResolved(true); } return true; }	public static final int compare(final Object obj0, final Object obj1) throws ELException { if (obj0 == obj1 || equals(obj0, obj1)) { return 0; } if (isBigDecimalOp(obj0, obj1)) { BigDecimal bd0 = (BigDecimal) coerceToNumber(obj0, BigDecimal.class); BigDecimal bd1 = (BigDecimal) coerceToNumber(obj1, BigDecimal.class); return bd0.compareTo(bd1); } if (isDoubleOp(obj0, obj1)) { Double d0 = (Double) coerceToNumber(obj0, Double.class); Double d1 = (Double) coerceToNumber(obj1, Double.class); return d0.compareTo(d1); } if (isBigIntegerOp(obj0, obj1)) { BigInteger bi0 = (BigInteger) coerceToNumber(obj0, BigInteger.class); BigInteger bi1 = (BigInteger) coerceToNumber(obj1, BigInteger.class); return bi0.compareTo(bi1); } if (isLongOp(obj0, obj1)) { Long l0 = (Long) coerceToNumber(obj0, Long.class); Long l1 = (Long) coerceToNumber(obj1, Long.class); return l0.compareTo(l1); } if (obj0 instanceof String || obj1 instanceof String) { return coerceToString(obj0).compareTo(coerceToString(obj1)); } if (obj0 instanceof Comparable<?>) { @SuppressWarnings("unchecked") final Comparable<Object> comparable = (Comparable<Object>) obj0; return (obj1 != null) ? comparable.compareTo(obj1) : 1; } if (obj1 instanceof Comparable<?>) { @SuppressWarnings("unchecked") final Comparable<Object> comparable = (Comparable<Object>) obj1; return (obj0 != null) ? -comparable.compareTo(obj0) : -1; } throw new ELException(MessageFactory.get("error.compare", obj0, obj1)); }	public void accept(NodeVisitor visitor) throws Exception { visitor.visit(this); if (this.children != null && this.children.length > 0) { for (int i = 0; i < this.children.length; i++) { this.children[i].accept(visitor); } } }	@Override public void setValue(EvaluationContext ctx, Object value) throws ELException { VariableMapper varMapper = ctx.getVariableMapper(); if (varMapper != null) { ValueExpression expr = varMapper.resolveVariable(this.image); if (expr != null) { expr.setValue(ctx.getELContext(), value); return; } } ctx.setPropertyResolved(false); ctx.getELResolver().setValue(ctx, null, this.image, value); }
private String evaluateExpression(String expression) { ELContextImpl ctx = new ELContextImpl(); ExpressionFactoryImpl exprFactory = new ExpressionFactoryImpl(); ValueExpression ve = exprFactory.createValueExpression(ctx, expression, String.class); return (String) ve.getValue(ctx); }	public void testParserStringLiteral() { // Inspired by work on bug 45451, comments from kkolinko on the dev // list and looking at the spec to find some edge cases assertEquals("\\", evaluateExpression("${'\\\\'}")); assertEquals("\\", evaluateExpression("${\"\\\\\"}")); // Can use ''' inside '"' when quoting with '"' and vice versa without assertEquals("\\\"", evaluateExpression("${'\\\\\"'}")); assertEquals("\"\\", evaluateExpression("${'\"\\\\'}")); assertEquals("\\'", evaluateExpression("${'\\\\\\''}")); assertEquals("'\\", evaluateExpression("${'\\'\\\\'}")); assertEquals("\\'", evaluateExpression("${\"\\\\'\"}")); assertEquals("'\\", evaluateExpression("${\"'\\\\\"}")); assertEquals("\\\"", evaluateExpression("${\"\\\\\\\"\"}")); assertEquals("\"\\", evaluateExpression("${\"\\\"\\\\\"}")); }
protected ObjectName createObjectName(String domain, String type) throws MalformedObjectNameException { String encodedAddr = null; if (getProperty("address") != null) { encodedAddr = URLEncoder.encode(getProperty("address").toString()); } String addSuffix = (getProperty("address") == null) ? "" : ",address=" + encodedAddr; ObjectName _oname = new ObjectName(domain + ":type=" + type + ",port=" + getPort() + addSuffix); return _oname; }	static ObjectName createObjectName(String domain, Valve valve) throws MalformedObjectNameException { if (valve instanceof ValveBase) { ObjectName name = ((ValveBase) valve).getObjectName(); if (name != null) return name; } ObjectName name = null; Container container = null; String className = valve.getClass().getName(); int period = className.lastIndexOf('.'); if (period >= 0) className = className.substring(period + 1); if (valve instanceof Contained) { container = ((Contained) valve).getContainer(); } if (container == null) { throw new MalformedObjectNameException("Cannot create mbean for non-contained valve " + valve); } if (container instanceof Engine) { String local = ""; int seq = getSeq(local); String ext = ""; if (seq > 0) { ext = ",seq=" + seq; } name = new ObjectName(domain + ":type=Valve,name=" + className + ext + local); } else if (container instanceof Host) { String local = ",host=" + container.getName(); int seq = getSeq(local); String ext = ""; if (seq > 0) { ext = ",seq=" + seq; } name = new ObjectName(domain + ":type=Valve,name=" + className + ext + local); } else if (container instanceof Context) { String path = ((Context) container).getPath(); if (path.length() < 1) { path = "/"; } Host host = (Host) container.getParent(); String local = ",path=" + path + ",host=" + host.getName(); int seq = getSeq(local); String ext = ""; if (seq > 0) { ext = ",seq=" + seq; } name = new ObjectName(domain + ":type=Valve,name=" + className + ext + local); } return (name); }
public void service(org.apache.coyote.Request req, org.apache.coyote.Response res) throws Exception { Request request = (Request) req.getNote(ADAPTER_NOTES); Response response = (Response) res.getNote(ADAPTER_NOTES); if (request == null) { request = connector.createRequest(); request.setCoyoteRequest(req); response = connector.createResponse(); response.setCoyoteResponse(res); request.setResponse(response); response.setRequest(request); req.setNote(ADAPTER_NOTES, request); res.setNote(ADAPTER_NOTES, response); req.getParameters().setQueryStringEncoding(connector.getURIEncoding()); } if (connector.getXpoweredBy()) { response.addHeader("X-Powered-By", "Servlet/2.5"); } boolean comet = false; boolean async = request.isAsyncStarted(); try { // Parse and set Catalina and configuration specific req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName()); if (postParseRequest(req, request, res, response)) { request.setAsyncSupported(connector.getContainer().getPipeline().isAsyncSupported()); connector.getContainer().getPipeline().getFirst().invoke(request, response); if (request.isComet()) { if (!response.isClosed() && !response.isError()) { if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) { if (event(req, res, SocketStatus.OPEN)) { comet = true; res.action(ActionCode.ACTION_COMET_BEGIN, null); } } else { comet = true; res.action(ActionCode.ACTION_COMET_BEGIN, null); } } else { // Clear the filter chain, as otherwise it will not be reset elsewhere request.setFilterChain(null); } } } if (request.isAsyncStarted()) { res.action(ActionCode.ACTION_ASYNC_START, request.getAsyncContext()); async = true; } else if (!comet) { response.finishResponse(); req.action(ActionCode.ACTION_POST_REQUEST, null); } } catch (IOException e) { // Ignore } catch (Throwable t) { log.error(sm.getString("coyoteAdapter.service"), t); } finally { req.getRequestProcessor().setWorkerThreadName(null); if (!comet && !async) { request.recycle(); response.recycle(); } else { // Clear converters so that the minimum amount of memory request.clearEncoders(); response.clearEncoders(); } } }
private void checkXmlAttributes(Node.CustomTag n, Node.JspAttribute[] jspAttrs, Hashtable<String, Object> tagDataAttrs) throws JasperException { TagInfo tagInfo = n.getTagInfo(); if (tagInfo == null) { err.jspError(n, "jsp.error.missing.tagInfo", n.getQName()); } TagAttributeInfo[] tldAttrs = tagInfo.getAttributes(); Attributes attrs = n.getAttributes(); boolean checkDeferred = !pageInfo.isDeferredSyntaxAllowedAsLiteral() && !(tagInfo.getTagLibrary().getRequiredVersion().equals("2.0") || tagInfo.getTagLibrary().getRequiredVersion().equals("1.2")); for (int i = 0; attrs != null && i < attrs.getLength(); i++) { boolean found = false; boolean runtimeExpression = ((n.getRoot().isXmlSyntax() && attrs.getValue(i).startsWith("%=")) || (!n.getRoot().isXmlSyntax() && attrs.getValue(i).startsWith("<%="))); boolean elExpression = false; boolean deferred = false; boolean deferredValueIsLiteral = false; ELNode.Nodes el = null; if (!runtimeExpression) { el = ELParser.parse(attrs.getValue(i)); Iterator<ELNode> nodes = el.iterator(); while (nodes.hasNext()) { ELNode node = nodes.next(); if (node instanceof ELNode.Root) { if (((ELNode.Root) node).getType() == '$') { elExpression = true; } else if (checkDeferred && ((ELNode.Root) node).getType() == '#') { elExpression = true; deferred = true; if (pageInfo.isELIgnored()) { deferredValueIsLiteral = true; } } } } } boolean expression = runtimeExpression || (elExpression && (!pageInfo.isELIgnored() || (!"true".equalsIgnoreCase(pageInfo.getIsELIgnored()) && checkDeferred && deferred))); for (int j = 0; tldAttrs != null && j < tldAttrs.length; j++) { if (attrs.getLocalName(i).equals(tldAttrs[j].getName()) && (attrs.getURI(i) == null || attrs.getURI(i).length() == 0 || attrs.getURI(i).equals(n.getURI()))) { if (tldAttrs[j].canBeRequestTime() || tldAttrs[j].isDeferredMethod() || tldAttrs[j].isDeferredValue()) { if (!expression) { if (deferredValueIsLiteral && !pageInfo.isDeferredSyntaxAllowedAsLiteral()) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } String expectedType = null; if (tldAttrs[j].isDeferredMethod()) { // The String literal must be castable to what is declared as type String m = tldAttrs[j].getMethodSignature(); if (m != null) { int rti = m.trim().indexOf(' '); if (rti > 0) { expectedType = m.substring(0, rti).trim(); } } else { expectedType = "java.lang.Object"; } if ("void".equals(expectedType)) { // Can't specify a literal for a // deferred method with an expected type err.jspError(n, "jsp.error.literal_with_void", tldAttrs[j].getName()); } } if (tldAttrs[j].isDeferredValue()) { // The String literal must be castable to what is declared as type expectedType = tldAttrs[j].getExpectedTypeName(); } if (expectedType != null) { Class<?> expectedClass = String.class; try { expectedClass = JspUtil.toClass(expectedType, loader); } catch (ClassNotFoundException e) { err.jspError(n, "jsp.error.unknown_attribute_type", tldAttrs[j].getName(), expectedType); } try { ELSupport.checkType(attrs.getValue(i), expectedClass); } catch (Exception e) { err.jspError(n, "jsp.error.coerce_to_type", tldAttrs[j].getName(), expectedType, attrs.getValue(i)); } } jspAttrs[i] = new Node.JspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), false, null, false); } else { if (deferred && !tldAttrs[j].isDeferredMethod() && !tldAttrs[j].isDeferredValue()) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } if (!deferred && !tldAttrs[j].canBeRequestTime()) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } if (elExpression) { validateFunctions(el, n); jspAttrs[i] = new Node.JspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), false, el, false); ELContextImpl ctx = new ELContextImpl(); ctx.setFunctionMapper(getFunctionMapper(el)); try { jspAttrs[i].validateEL(this.pageInfo.getExpressionFactory(), ctx); } catch (ELException e) { this.err.jspError(n.getStart(), "jsp.error.invalid.expression", attrs.getValue(i), e.toString()); } } else { jspAttrs[i] = getJspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), n, false); } } } else { if (expression) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } jspAttrs[i] = new Node.JspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), false, null, false); } if (expression) { tagDataAttrs.put(attrs.getQName(i), TagData.REQUEST_TIME_VALUE); } else { tagDataAttrs.put(attrs.getQName(i), attrs.getValue(i)); } found = true; break; } } if (!found) { if (tagInfo.hasDynamicAttributes()) { jspAttrs[i] = getJspAttribute(null, attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), n, true); } else { err.jspError(n, "jsp.error.bad_attribute", attrs.getQName(i), n.getLocalName()); } } } }	private void compareTagEncodings(String thePageDirEnc, Node.TagDirective pageDir) throws JasperException { Node.Root root = pageDir.getRoot(); String pageDirEnc = thePageDirEnc.toUpperCase(); if ((root.isXmlSyntax() && root.isEncodingSpecifiedInProlog()) || root.isBomPresent()) { String pageEnc = root.getPageEncoding().toUpperCase(); if (!pageDirEnc.equals(pageEnc) && (!pageDirEnc.startsWith("UTF-16") || !pageEnc.startsWith("UTF-16"))) { err.jspError(pageDir, "jsp.error.prolog_pagedir_encoding_mismatch", pageEnc, pageDirEnc); } } }	public static ExpressionFactory newInstance() { return newInstance(null); }	public static ExpressionFactory newInstance(Properties properties) { return null; }
public void processExpires() { String[] keys = null; if (!started) { return; } try { keys = keys(); } catch (IOException e) { manager.getContainer().getLogger().error("Error getting keys", e); return; } if (manager.getContainer().getLogger().isDebugEnabled()) { manager.getContainer().getLogger().debug(getStoreName() + ": processExpires check number of " + keys.length + " sessions"); } for (int i = 0; i < keys.length; i++) { try { StandardSession session = (StandardSession) load(keys[i]); if (session == null) { continue; } if (session.isValid()) { continue; } if (manager.getContainer().getLogger().isDebugEnabled()) { manager.getContainer().getLogger().debug(getStoreName() + ": processExpires expire store session " + keys[i]); } if (((PersistentManagerBase) manager).isLoaded(keys[i])) { session.recycle(); } else { session.expire(); } remove(session.getIdInternal()); } catch (Exception e) { manager.getContainer().getLogger().error("Session: " + keys[i] + "; ", e); try { remove(keys[i]); } catch (IOException e2) { manager.getContainer().getLogger().error("Error removing key", e2); } } } }
/** * Executes a CGI script with the desired environment, current working * directory, and input/output streams * * <p> * This implements the following CGI specification recommedations: * <UL> * <LI> Servers SHOULD provide the "<code>query</code>" component of * the script-URI as command-line arguments to scripts if it * does not contain any unencoded "=" characters and the * command-line arguments can be generated in an unambiguous * manner. * <LI> Servers SHOULD set the AUTH_TYPE metavariable to the value * of the "<code>auth-scheme</code>" token of the * "<code>Authorization</code>" if it was supplied as part of the * request header. See <code>getCGIEnvironment</code> method. * <LI> Where applicable, servers SHOULD set the current working * directory to the directory in which the script is located * before invoking it. * <LI> Server implementations SHOULD define their behavior for the * following cases: * <ul> * <LI> <u>Allowed characters in pathInfo</u>: This implementation * does not allow ASCII NUL nor any character which cannot * be URL-encoded according to internet standards; * <LI> <u>Allowed characters in path segments</u>: This * implementation does not allow non-terminal NULL * segments in the the path -- IOExceptions may be thrown; * <LI> <u>"<code>.</code>" and "<code>..</code>" path * segments</u>: * This implementation does not allow "<code>.</code>" and * "<code>..</code>" in the the path, and such characters * will result in an IOException being thrown; * <LI> <u>Implementation limitations</u>: This implementation * does not impose any limitations except as documented * above. This implementation may be limited by the * servlet container used to house this implementation. * In particular, all the primary CGI variable values * are derived either directly or indirectly from the * container's implementation of the Servlet API methods. * </ul> * </UL> * </p> * * @exception IOException if problems during reading/writing occur * * @see java.lang.Runtime#exec(String command, String[] envp, * File dir) */ protected void run() throws IOException { /* * REMIND: this method feels too big; should it be re-written? */ if (!isReady()) { throw new IOException(this.getClass().getName() + ": not ready to run."); } if (debug >= 1 ) { log("runCGI(envp=[" + env + "], command=" + command + ")"); } if ((command.indexOf(File.separator + "." + File.separator) >= 0) || (command.indexOf(File.separator + "..") >= 0) || (command.indexOf(".." + File.separator) >= 0)) { throw new IOException(this.getClass().getName() + "Illegal Character in CGI command " + "path ('.' or '..') detected. Not " + "running CGI [" + command + "]."); } /* original content/structure of this section taken from * http://developer.java.sun.com/developer/ * bugParade/bugs/4216884.html * with major modifications by Martin Dengler */ Runtime rt = null; BufferedReader cgiHeaderReader = null; InputStream cgiOutput = null; BufferedReader commandsStdErr = null; BufferedOutputStream commandsStdIn = null; Process proc = null; int bufRead = -1; //create query arguments StringBuilder cmdAndArgs = new StringBuilder(); if (command.indexOf(" ") < 0) { cmdAndArgs.append(command); } else { // Spaces used as delimiter, so need to use quotes cmdAndArgs.append("\""); cmdAndArgs.append(command); cmdAndArgs.append("\""); } for (int i=0; i < params.size(); i++) { cmdAndArgs.append(" "); String param = params.get(i); if (param.indexOf(" ") < 0) { cmdAndArgs.append(param); } else { // Spaces used as delimiter, so need to use quotes cmdAndArgs.append("\""); cmdAndArgs.append(param); cmdAndArgs.append("\""); } } StringBuilder command = new StringBuilder(cgiExecutable); command.append(" "); command.append(cmdAndArgs.toString()); cmdAndArgs = command; try { rt = Runtime.getRuntime(); proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd); String sContentLength = env.get("CONTENT_LENGTH"); if(!"".equals(sContentLength)) { commandsStdIn = new BufferedOutputStream(proc.getOutputStream()); IOTools.flow(stdin, commandsStdIn); commandsStdIn.flush(); commandsStdIn.close(); } /* we want to wait for the process to exit, Process.waitFor() * is useless in our situation; see * http://developer.java.sun.com/developer/ * bugParade/bugs/4223650.html */ boolean isRunning = true; commandsStdErr = new BufferedReader (new InputStreamReader(proc.getErrorStream())); final BufferedReader stdErrRdr = commandsStdErr ; new Thread() { @Override } } }	public void init(ServletConfig config) throws ServletException { super.init(config); if (getServletConfig().getInitParameter("debug") != null) debug = Integer.parseInt(getServletConfig().getInitParameter("debug")); cgiPathPrefix = getServletConfig().getInitParameter("cgiPathPrefix"); boolean passShellEnvironment = Boolean.valueOf(getServletConfig().getInitParameter("passShellEnvironment")).booleanValue(); if (passShellEnvironment) { shellEnv.putAll(System.getenv()); } if (getServletConfig().getInitParameter("executable") != null) { cgiExecutable = getServletConfig().getInitParameter("executable"); } if (getServletConfig().getInitParameter("parameterEncoding") != null) { parameterEncoding = getServletConfig().getInitParameter("parameterEncoding"); } }	protected void run() throws IOException { if (!isReady()) { throw new IOException(this.getClass().getName() + ": not ready to run."); } if (debug >= 1) { log("runCGI(envp=[" + env + "], command=" + command + ")"); } if ((command.indexOf(File.separator + "." + File.separator) >= 0) || (command.indexOf(File.separator + "..") >= 0) || (command.indexOf(".." + File.separator) >= 0)) { throw new IOException(this.getClass().getName() + "Illegal Character in CGI command " + "path ('.' or '..') detected. Not " + "running CGI [" + command + "]."); } Runtime rt = null; BufferedReader cgiHeaderReader = null; InputStream cgiOutput = null; BufferedReader commandsStdErr = null; BufferedOutputStream commandsStdIn = null; Process proc = null; int bufRead = -1; StringBuilder cmdAndArgs = new StringBuilder(); if (command.indexOf(" ") < 0) { cmdAndArgs.append(command); } else { cmdAndArgs.append("\""); cmdAndArgs.append(command); cmdAndArgs.append("\""); } for (int i = 0; i < params.size(); i++) { cmdAndArgs.append(" "); String param = params.get(i); if (param.indexOf(" ") < 0) { cmdAndArgs.append(param); } else { cmdAndArgs.append("\""); cmdAndArgs.append(param); cmdAndArgs.append("\""); } } StringBuilder command = new StringBuilder(cgiExecutable); command.append(" "); command.append(cmdAndArgs.toString()); cmdAndArgs = command; try { rt = Runtime.getRuntime(); proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd); String sContentLength = env.get("CONTENT_LENGTH"); if (!"".equals(sContentLength)) { commandsStdIn = new BufferedOutputStream(proc.getOutputStream()); IOTools.flow(stdin, commandsStdIn); commandsStdIn.flush(); commandsStdIn.close(); } boolean isRunning = true; commandsStdErr = new BufferedReader(new InputStreamReader(proc.getErrorStream())); final BufferedReader stdErrRdr = commandsStdErr; new Thread() { @Override public void run() { sendToLog(stdErrRdr); } }.start(); InputStream cgiHeaderStream = new HTTPHeaderInputStream(proc.getInputStream()); cgiHeaderReader = new BufferedReader(new InputStreamReader(cgiHeaderStream)); while (isRunning) { try { String line = null; while (((line = cgiHeaderReader.readLine()) != null) && !("".equals(line))) { if (debug >= 2) { log("runCGI: addHeader(\"" + line + "\")"); } if (line.startsWith("HTTP")) { response.setStatus(getSCFromHttpStatusLine(line)); } else if (line.indexOf(":") >= 0) { String header = line.substring(0, line.indexOf(":")).trim(); String value = line.substring(line.indexOf(":") + 1).trim(); if (header.equalsIgnoreCase("status")) { response.setStatus(getSCFromCGIStatusHeader(value)); } else { response.addHeader(header, value); } } else { log("runCGI: bad header line \"" + line + "\""); } } byte[] bBuf = new byte[2048]; OutputStream out = response.getOutputStream(); cgiOutput = proc.getInputStream(); try { while ((bufRead = cgiOutput.read(bBuf)) != -1) { if (debug >= 4) { log("runCGI: output " + bufRead + " bytes of data"); } out.write(bBuf, 0, bufRead); } } finally { if (bufRead != -1) { while ((bufRead = cgiOutput.read(bBuf)) != -1) { // NOOP - just read the data } } } proc.exitValue(); isRunning = false; } catch (IllegalThreadStateException e) { try { Thread.sleep(500); } catch (InterruptedException ignored) { // Ignore } } } //replacement for Process.waitFor() } catch (IOException e) { log("Caught exception " + e); throw e; } finally { if (cgiHeaderReader != null) { try { cgiHeaderReader.close(); } catch (IOException ioe) { log("Exception closing header reader " + ioe); } } if (cgiOutput != null) { try { cgiOutput.close(); } catch (IOException ioe) { log("Exception closing output stream " + ioe); } } if (debug > 4) { log("Running finally block"); } if (proc != null) { proc.destroy(); proc = null; } } }
public Enumeration<String> list() throws IOException { if (!connected) { connect(); } if ((resource == null) && (collection == null)) { throw new FileNotFoundException(); } Vector<String> result = new Vector<String>(); if (collection != null) { try { String file = getURL().getFile(); // This will be of the form /<hostname>/<contextpath/file name int start = file.indexOf('/', file.indexOf('/', 1) + 1); NamingEnumeration<NameClassPair> enumeration = context.list(file.substring(start)); while (enumeration.hasMoreElements()) { NameClassPair ncp = enumeration.nextElement(); result.addElement(ncp.getName()); } } catch (NamingException e) { throw new FileNotFoundException(); } } return result.elements(); }
public int getNextPoll() { int idx = Math.abs(pollQueue.incrementAndGet()) % LOCK_COUNT; return idx; }
protected Session swapIn(String id) throws IOException { if (store == null) return null; Session session = null; try { if (SecurityUtil.isPackageProtectionEnabled()) { try { session = AccessController.doPrivileged(new PrivilegedStoreLoad(id)); } catch (PrivilegedActionException ex) { Exception exception = ex.getException(); log.error("Exception in the Store during swapIn: " + exception); if (exception instanceof IOException) { throw (IOException) exception; } else if (exception instanceof ClassNotFoundException) { throw (ClassNotFoundException) exception; } } } else { session = store.load(id); } } catch (ClassNotFoundException e) { log.error(sm.getString("persistentManager.deserializeError", id, e)); throw new IllegalStateException(sm.getString("persistentManager.deserializeError", id, e)); } if (session == null) return (null); if (!session.isValid()) { log.error("session swapped in is invalid or expired"); session.expire(); removeSession(id); return (null); } if (log.isDebugEnabled()) log.debug(sm.getString("persistentManager.swapIn", id)); session.setManager(this); ((StandardSession) session).tellNew(); add(session); ((StandardSession) session).activate(); // endAccess() to ensure timeouts happen correctly. session.access(); session.endAccess(); return (session); }	public Void run() throws Exception { store.clear(); return null; }
protected static boolean matchesOne(String str, Pattern... patterns) { for (Pattern pattern : patterns) { if (pattern.matcher(str).matches()) { return true; } } return false; }	public String getProtocolHeader() { return protocolHeader; }	public void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { if (matchesOne(request.getRemoteAddr(), internalProxies)) { String remoteIp = null; LinkedList<String> proxiesHeaderValue = new LinkedList<String>(); String[] remoteIPHeaderValue = commaDelimitedListToStringArray(request.getHeader(remoteIPHeader)); int idx; for (idx = remoteIPHeaderValue.length - 1; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; remoteIp = currentRemoteIp; if (matchesOne(currentRemoteIp, internalProxies)) { // do nothing, internalProxies IPs are not appended to the } else if (matchesOne(currentRemoteIp, trustedProxies)) { proxiesHeaderValue.addFirst(currentRemoteIp); } else { idx--; break; } } LinkedList<String> newRemoteIpHeaderValue = new LinkedList<String>(); for (; idx >= 0; idx--) { String currentRemoteIp = remoteIPHeaderValue[idx]; newRemoteIpHeaderValue.addFirst(currentRemoteIp); } XForwardedRequest xRequest = new XForwardedRequest(request); if (remoteIp != null) { xRequest.setRemoteAddr(remoteIp); xRequest.setRemoteHost(remoteIp); if (proxiesHeaderValue.size() == 0) { xRequest.removeHeader(proxiesHeader); } else { String commaDelimitedListOfProxies = listToCommaDelimitedString(proxiesHeaderValue); xRequest.setHeader(proxiesHeader, commaDelimitedListOfProxies); } if (newRemoteIpHeaderValue.size() == 0) { xRequest.removeHeader(remoteIPHeader); } else { String commaDelimitedRemoteIpHeaderValue = listToCommaDelimitedString(newRemoteIpHeaderValue); xRequest.setHeader(remoteIPHeader, commaDelimitedRemoteIpHeaderValue); } } if (protocolHeader != null) { String protocolHeaderValue = request.getHeader(protocolHeader); if (protocolHeaderValue != null && protocolHeaderSslValue.equalsIgnoreCase(protocolHeaderValue)) { xRequest.setSecure(true); xRequest.setScheme("https"); xRequest.setServerPort(httpsServerPort); } } if (log.isDebugEnabled()) { log.debug("Incoming request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "', originalRemoteHost='" + request.getRemoteHost() + "', originalSecure='" + request.isSecure() + "', originalScheme='" + request.getScheme() + "', original[" + remoteIPHeader + "]='" + request.getHeader(remoteIPHeader) + ", original[" + protocolHeader + "]='" + (protocolHeader == null ? null : request.getHeader(protocolHeader)) + "' will be seen as newRemoteAddr='" + xRequest.getRemoteAddr() + "', newRemoteHost='" + xRequest.getRemoteHost() + "', newScheme='" + xRequest.getScheme() + "', newSecure='" + xRequest.isSecure() + "', new[" + remoteIPHeader + "]='" + xRequest.getHeader(remoteIPHeader) + ", new[" + proxiesHeader + "]='" + xRequest.getHeader(proxiesHeader) + "'"); } chain.doFilter(xRequest, response); } else { chain.doFilter(request, response); } }	public void init(FilterConfig filterConfig) throws ServletException { if (filterConfig.getInitParameter(INTERNAL_PROXIES_PARAMETER) != null) { setInternalProxies(filterConfig.getInitParameter(INTERNAL_PROXIES_PARAMETER)); } if (filterConfig.getInitParameter(PROTOCOL_HEADER_PARAMETER) != null) { setProtocolHeader(filterConfig.getInitParameter(PROTOCOL_HEADER_PARAMETER)); } if (filterConfig.getInitParameter(PROTOCOL_HEADER_SSL_VALUE_PARAMETER) != null) { setProtocolHeaderSslValue(filterConfig.getInitParameter(PROTOCOL_HEADER_SSL_VALUE_PARAMETER)); } if (filterConfig.getInitParameter(PROXIES_HEADER_PARAMETER) != null) { setProxiesHeader(filterConfig.getInitParameter(PROXIES_HEADER_PARAMETER)); } if (filterConfig.getInitParameter(REMOTE_IP_HEADER_PARAMETER) != null) { setRemoteIPHeader(filterConfig.getInitParameter(REMOTE_IP_HEADER_PARAMETER)); } if (filterConfig.getInitParameter(TRUSTED_PROXIES_PARAMETER) != null) { setTrustedProxies(filterConfig.getInitParameter(TRUSTED_PROXIES_PARAMETER)); } if (filterConfig.getInitParameter(HTTPS_SERVER_PORT_PARAMETER) != null) { try { setHttpsServerPort(Integer.parseInt(filterConfig.getInitParameter(HTTPS_SERVER_PORT_PARAMETER))); } catch (NumberFormatException e) { throw new NumberFormatException("Illegal serverPort : " + e.getMessage()); } } }	public void setProtocolHeader(String protocolHeader) { this.protocolHeader = protocolHeader; }	protected static String[] commaDelimitedListToStringArray(String commaDelimitedStrings) { return (commaDelimitedStrings == null || commaDelimitedStrings.length() == 0) ? new String[0] : commaSeparatedValuesPattern.split(commaDelimitedStrings); }
public Integer getKeySize() throws IOException { SSLSupport.CipherData[] c_aux = ciphers; if (session == null) return null; Integer keySize = (Integer) session.getValue(KEY_SIZE_KEY); if (keySize == null) { int size = 0; String cipherSuite = session.getCipherSuite(); for (int i = 0; i < c_aux.length; i++) { if (cipherSuite.indexOf(c_aux[i].phrase) >= 0) { size = c_aux[i].keySize; break; } } keySize = new Integer(size); session.putValue(KEY_SIZE_KEY, keySize); } return keySize; }
protected void forwardToErrorPage(Request request, HttpServletResponse response, LoginConfig config) { RequestDispatcher disp = context.getServletContext().getRequestDispatcher(config.getErrorPage()); try { disp.forward(request.getRequest(), response); } catch (Throwable t) { log.warn("Unexpected error forwarding to error page", t); } }	protected void forwardToLoginPage(Request request, HttpServletResponse response, LoginConfig config) { RequestDispatcher disp = context.getServletContext().getRequestDispatcher(config.getLoginPage()); try { disp.forward(request.getRequest(), response); } catch (Throwable t) { log.warn("Unexpected error forwarding to login page", t); } }	@Override public boolean authenticate(Request request, HttpServletResponse response, LoginConfig config) throws IOException { Session session = null; Principal principal = request.getUserPrincipal(); String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (principal != null) { if (log.isDebugEnabled()) log.debug("Already authenticated '" + principal.getName() + "'"); if (ssoId != null) associate(ssoId, request.getSessionInternal(true)); return (true); } if (ssoId != null) { if (log.isDebugEnabled()) log.debug("SSO Id " + ssoId + " set; attempting " + "reauthentication"); if (reauthenticateFromSSO(ssoId, request)) return true; } if (!cache) { session = request.getSessionInternal(true); if (log.isDebugEnabled()) log.debug("Checking for reauthenticate in session " + session); String username = (String) session.getNote(Constants.SESS_USERNAME_NOTE); String password = (String) session.getNote(Constants.SESS_PASSWORD_NOTE); if ((username != null) && (password != null)) { if (log.isDebugEnabled()) log.debug("Reauthenticating username '" + username + "'"); principal = context.getRealm().authenticate(username, password); if (principal != null) { session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal); if (!matchRequest(request)) { register(request, response, principal, Constants.FORM_METHOD, username, password); return (true); } } if (log.isDebugEnabled()) log.debug("Reauthentication failed, proceed normally"); } } if (matchRequest(request)) { session = request.getSessionInternal(true); if (log.isDebugEnabled()) log.debug("Restore request from session '" + session.getIdInternal() + "'"); principal = (Principal) session.getNote(Constants.FORM_PRINCIPAL_NOTE); register(request, response, principal, Constants.FORM_METHOD, (String) session.getNote(Constants.SESS_USERNAME_NOTE), (String) session.getNote(Constants.SESS_PASSWORD_NOTE)); if (cache) { session.removeNote(Constants.SESS_USERNAME_NOTE); session.removeNote(Constants.SESS_PASSWORD_NOTE); } if (restoreRequest(request, session)) { if (log.isDebugEnabled()) log.debug("Proceed to restored request"); return (true); } else { if (log.isDebugEnabled()) log.debug("Restore of original request failed"); response.sendError(HttpServletResponse.SC_BAD_REQUEST); return (false); } } MessageBytes uriMB = MessageBytes.newInstance(); CharChunk uriCC = uriMB.getCharChunk(); uriCC.setLimit(-1); String contextPath = request.getContextPath(); String requestURI = request.getDecodedRequestURI(); boolean loginAction = requestURI.startsWith(contextPath) && requestURI.endsWith(Constants.FORM_ACTION); if (!loginAction) { session = request.getSessionInternal(true); if (log.isDebugEnabled()) log.debug("Save request in session '" + session.getIdInternal() + "'"); try { saveRequest(request, session); } catch (IOException ioe) { log.debug("Request body too big to save during authentication"); response.sendError(HttpServletResponse.SC_FORBIDDEN, sm.getString("authenticator.requestBodyTooBig")); return (false); } forwardToLoginPage(request, response, config); return (false); } // Yes -- Validate the specified credentials and redirect Realm realm = context.getRealm(); if (characterEncoding != null) { request.setCharacterEncoding(characterEncoding); } String username = request.getParameter(Constants.FORM_USERNAME); String password = request.getParameter(Constants.FORM_PASSWORD); if (log.isDebugEnabled()) log.debug("Authenticating username '" + username + "'"); principal = realm.authenticate(username, password); if (principal == null) { forwardToErrorPage(request, response, config); return (false); } if (log.isDebugEnabled()) log.debug("Authentication of '" + username + "' was successful"); if (session == null) session = request.getSessionInternal(false); if (session == null) { if (containerLog.isDebugEnabled()) containerLog.debug("User took so long to log on the session expired"); response.sendError(HttpServletResponse.SC_REQUEST_TIMEOUT, sm.getString("authenticator.sessionExpired")); return (false); } session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal); session.setNote(Constants.SESS_USERNAME_NOTE, username); session.setNote(Constants.SESS_PASSWORD_NOTE, password); // Redirect the user to the original request URI (which will cause requestURI = savedRequestURL(session); if (log.isDebugEnabled()) log.debug("Redirecting to original '" + requestURI + "'"); if (requestURI == null) response.sendError(HttpServletResponse.SC_BAD_REQUEST, sm.getString("authenticator.formlogin")); else response.sendRedirect(response.encodeRedirectURL(requestURI)); return (false); }
public List<Client> getClients() { return java.util.Arrays.asList(clients.entrySet().toArray(new Client[0])); }
public HttpError validate() { if (channel == null || (!this.getTomcatBayeux().hasChannel(channel))) return new HttpError(400, "Channel Id not valid.", null); if (data == null || data.length() == 0) return new HttpError(400, "Message data missing.", null); try { this.msgData = new JSONObject(data); } catch (JSONException x) { return new HttpError(400, "Invalid JSON object in data attribute.", x); } if (clientId == null || (!this.getTomcatBayeux().hasClient(clientId))) return new HttpError(400, "Client Id not valid.", null); return null; }
public Session getSessionInternal(boolean create) { return doGetSession(create); }	public void setCometTimeout(long timeout) { coyoteRequest.action(ActionCode.ACTION_COMET_SETTIMEOUT, new Long(timeout)); }	public Enumeration<String> getAttributeNames() { if (isSecure()) { getAttribute(Globals.CERTIFICATES_ATTR); } return new Enumerator<String>(attributes.keySet(), true); }
private void writeObject(ObjectOutput stream) throws IOException { stream.writeObject(new Long(creationTime)); stream.writeObject(new Long(lastAccessedTime)); stream.writeObject(new Integer(maxInactiveInterval)); stream.writeObject(new Boolean(isNew)); stream.writeObject(new Boolean(isValid)); stream.writeObject(new Long(thisAccessedTime)); stream.writeObject(new Long(version)); stream.writeBoolean(getPrincipal() != null); if (getPrincipal() != null) { SerializablePrincipal.writePrincipal((GenericPrincipal) principal, stream); } stream.writeObject(id); if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.writeSession", id)); String[] keys = keys(); ArrayList<String> saveNames = new ArrayList<String>(); ArrayList<Object> saveValues = new ArrayList<Object>(); for (int i = 0; i < keys.length; i++) { Object value = null; value = attributes.get(keys[i]); if (value == null) continue; } }
@Override public Map<String, List<String>> getHeaderFields() { if (!connected) { try { connect(); } catch (IOException e) { } } if (attributes == null) return (Collections.EMPTY_MAP); HashMap<String, List<String>> headerFields = new HashMap<String, List<String>>(attributes.size()); NamingEnumeration<String> attributeEnum = attributes.getIDs(); try { while (attributeEnum.hasMore()) { String attributeID = attributeEnum.next(); Attribute attribute = attributes.get(attributeID); if (attribute == null) continue; ArrayList<String> attributeValueList = new ArrayList<String>(attribute.size()); NamingEnumeration<?> attributeValues = attribute.getAll(); while (attributeValues.hasMore()) { Object attrValue = attributeValues.next(); attributeValueList.add(getHeaderValueAsString(attrValue)); } attributeValueList.trimToSize(); headerFields.put(attributeID, Collections.unmodifiableList(attributeValueList)); } } catch (NamingException ne) { // Shouldn't happen } return Collections.unmodifiableMap(headerFields); }	protected void createProperty(String propertyPrefix, Object result) { if (propertyPrefix == null) propertyPrefix = ""; if (result instanceof CompositeDataSupport) { CompositeDataSupport data = (CompositeDataSupport) result; CompositeType compositeType = data.getCompositeType(); Set<String> keys = compositeType.keySet(); for (Iterator<String> iter = keys.iterator(); iter.hasNext(); ) { String key = iter.next(); Object value = data.get(key); OpenType<?> type = compositeType.getType(key); if (type instanceof SimpleType<?>) { setProperty(propertyPrefix + "." + key, value); } else { createProperty(propertyPrefix + "." + key, value); } } } else if (result instanceof TabularDataSupport) { TabularDataSupport data = (TabularDataSupport) result; for (Iterator<Object> iter = data.keySet().iterator(); iter.hasNext(); ) { Object key = iter.next(); for (Iterator<Object> iter1 = ((List<Object>) key).iterator(); iter1.hasNext(); ) { Object key1 = iter1.next(); CompositeData valuedata = data.get(new Object[] { key1 }); Object value = valuedata.get("value"); OpenType<?> type = valuedata.getCompositeType().getType("value"); if (type instanceof SimpleType<?>) { setProperty(propertyPrefix + "." + key1, value); } else { createProperty(propertyPrefix + "." + key1, value); } } } } else if (result.getClass().isArray()) { if (isSeparatearrayresults()) { int size = 0; for (int i = 0; i < Array.getLength(result); i++) { if (setProperty(propertyPrefix + "." + size, Array.get(result, i))) { size++; } } if (size > 0) { setProperty(propertyPrefix + ".Length", Integer.toString(size)); } } } else { String delim = getDelimiter(); if (delim != null) { StringTokenizer tokenizer = new StringTokenizer(result.toString(), delim); int size = 0; for (; tokenizer.hasMoreTokens(); ) { String token = tokenizer.nextToken(); if (setProperty(propertyPrefix + "." + size, token)) { size++; } } if (size > 0) setProperty(propertyPrefix + ".Length", Integer.toString(size)); } else { setProperty(propertyPrefix, result.toString()); } } }	public Object clone() { synchronized (membersLock) { Membership clone = new Membership(local, memberComparator); clone.map = (HashMap<MemberImpl, MbrEntry>) map.clone(); clone.members = new MemberImpl[members.length]; System.arraycopy(members, 0, clone.members, 0, members.length); return clone; } }	@Override public Object getContent() throws IOException { if (!connected) connect(); if (resource != null) return getInputStream(); if (collection != null) return collection; if (object != null) return object; throw new FileNotFoundException(); }	public synchronized void reset() { map.clear(); members = EMPTY_MEMBERS; }
@Override public synchronized void start() throws LifecycleException { if (this.started) return; super.addLifecycleListener(this); try { CatalinaCluster catclust = (CatalinaCluster) this.getCluster(); if (this.context == null) this.context = new ReplApplContext(this); if (catclust != null) { ReplicatedMap map = new ReplicatedMap(this, catclust.getChannel(), DEFAULT_REPL_TIMEOUT, getName(), getClassLoaders()); map.setChannelSendOptions(mapSendOptions); ((ReplApplContext) this.context).setAttributeMap(map); if (getAltDDName() != null) context.setAttribute(Globals.ALT_DD_ATTR, getAltDDName()); } super.start(); } catch (Exception x) { log.error("Unable to start ReplicatedContext", x); throw new LifecycleException("Failed to start ReplicatedContext", x); } }
protected static final Number coerceToNumber(final String val, final Class<?> type) throws IllegalArgumentException { if (Long.TYPE == type || Long.class.equals(type)) { return Long.valueOf(val); } if (Integer.TYPE == type || Integer.class.equals(type)) { return Integer.valueOf(val); } if (Double.TYPE == type || Double.class.equals(type)) { return Double.valueOf(val); } if (BigInteger.class.equals(type)) { return new BigInteger(val); } if (BigDecimal.class.equals(type)) { return new BigDecimal(val); } if (Byte.TYPE == type || Byte.class.equals(type)) { return Byte.valueOf(val); } if (Short.TYPE == type || Short.class.equals(type)) { return Short.valueOf(val); } if (Float.TYPE == type || Float.class.equals(type)) { return Float.valueOf(val); } throw new IllegalArgumentException(MessageFactory.get("error.convert", val, String.class, type)); }	public static final Enum coerceToEnum(final Object obj, Class type) { if (obj == null || "".equals(obj)) { return null; } if (obj.getClass().isEnum()) { return (Enum) obj; } return Enum.valueOf(type, obj.toString()); }	public static final Object coerceToType(final Object obj, final Class<?> type) throws IllegalArgumentException { if (type == null || Object.class.equals(type) || (obj != null && type.isAssignableFrom(obj.getClass()))) { return obj; } if (String.class.equals(type)) { return coerceToString(obj); } if (ELArithmetic.isNumberType(type)) { return coerceToNumber(obj, type); } if (Character.class.equals(type) || Character.TYPE == type) { return coerceToCharacter(obj); } if (Boolean.class.equals(type) || Boolean.TYPE == type) { return coerceToBoolean(obj); } if (type.isEnum()) { return coerceToEnum(obj, type); } if (obj == null) return null; if (obj instanceof String) { if ("".equals(obj)) return null; PropertyEditor editor = PropertyEditorManager.findEditor(type); if (editor != null) { editor.setAsText((String) obj); return editor.getValue(); } } throw new IllegalArgumentException(MessageFactory.get("error.convert", obj, obj.getClass(), type)); }	public static final String coerceToString(final Object obj) { if (obj == null) { return ""; } else if (obj instanceof String) { return (String) obj; } else if (obj instanceof Enum) { return ((Enum) obj).name(); } else { return obj.toString(); } }	public static final int compare(final Object obj0, final Object obj1) throws ELException { if (obj0 == obj1 || equals(obj0, obj1)) { return 0; } if (isBigDecimalOp(obj0, obj1)) { BigDecimal bd0 = (BigDecimal) coerceToNumber(obj0, BigDecimal.class); BigDecimal bd1 = (BigDecimal) coerceToNumber(obj1, BigDecimal.class); return bd0.compareTo(bd1); } if (isDoubleOp(obj0, obj1)) { Double d0 = (Double) coerceToNumber(obj0, Double.class); Double d1 = (Double) coerceToNumber(obj1, Double.class); return d0.compareTo(d1); } if (isBigIntegerOp(obj0, obj1)) { BigInteger bi0 = (BigInteger) coerceToNumber(obj0, BigInteger.class); BigInteger bi1 = (BigInteger) coerceToNumber(obj1, BigInteger.class); return bi0.compareTo(bi1); } if (isLongOp(obj0, obj1)) { Long l0 = (Long) coerceToNumber(obj0, Long.class); Long l1 = (Long) coerceToNumber(obj1, Long.class); return l0.compareTo(l1); } if (obj0 instanceof String || obj1 instanceof String) { return coerceToString(obj0).compareTo(coerceToString(obj1)); } if (obj0 instanceof Comparable) { return (obj1 != null) ? ((Comparable) obj0).compareTo(obj1) : 1; } if (obj1 instanceof Comparable) { return (obj0 != null) ? -((Comparable) obj1).compareTo(obj0) : -1; } throw new ELException(MessageFactory.get("error.compare", obj0, obj1)); }	public static final void throwUnhandled(Object base, Object property) throws ELException { if (base == null) { throw new PropertyNotFoundException(MessageFactory.get("error.resolver.unhandled.null", property)); } else { throw new PropertyNotFoundException(MessageFactory.get("error.resolver.unhandled", base.getClass(), property)); } }	public void testMisc() { assertEquals("\\", evaluateExpression("\\\\")); }
@Override public VariableMapper getVariableMapper() { return this.varMapper; }	@Override public VariableMapper getVariableMapper() { return this.target.getVariableMapper(); }	@Override public boolean isPropertyResolved() { return this.elContext.isPropertyResolved(); }	@Override public boolean isPropertyResolved() { return this.target.isPropertyResolved(); }
public <T extends Servlet> T createServlet(Class<T> c) throws ServletException { if (SecurityUtil.isPackageProtectionEnabled()) { return (T) doPrivileged("createServlet", new Object[] { c }); } else { return context.createServlet(c); } }	@Override public Map<String, ? extends ServletRegistration> getServletRegistrations() { if (SecurityUtil.isPackageProtectionEnabled()) { return (Map<String, ? extends ServletRegistration>) doPrivileged("getServletRegistrations", null); } else { return context.getServletRegistrations(); } }	public Enumeration<String> getAttributeNames() { if (SecurityUtil.isPackageProtectionEnabled()) { return (Enumeration<String>) doPrivileged("getAttributeNames", null); } else { return context.getAttributeNames(); } }	@Deprecated public Enumeration<String> getServletNames() { if (SecurityUtil.isPackageProtectionEnabled()) { return (Enumeration<String>) doPrivileged("getServletNames", null); } else { return context.getServletNames(); } }	public EnumSet<SessionTrackingMode> getEffectiveSessionTrackingModes() { if (SecurityUtil.isPackageProtectionEnabled()) { return (EnumSet<SessionTrackingMode>) doPrivileged("getEffectiveSessionTrackingModes", null); } else { return context.getEffectiveSessionTrackingModes(); } }	public <T extends Filter> T createFilter(Class<T> c) throws ServletException { if (SecurityUtil.isPackageProtectionEnabled()) { return (T) doPrivileged("createFilter", new Object[] { c }); } else { return context.createFilter(c); } }	public Enumeration<String> getInitParameterNames() { if (SecurityUtil.isPackageProtectionEnabled()) { return (Enumeration<String>) doPrivileged("getInitParameterNames", null); } else { return context.getInitParameterNames(); } }	public Set<String> getResourcePaths(String path) { if (SecurityUtil.isPackageProtectionEnabled()) { return (Set<String>) doPrivileged("getResourcePaths", new Object[] { path }); } else { return context.getResourcePaths(path); } }	@Override public Map<String, ? extends FilterRegistration> getFilterRegistrations() { if (SecurityUtil.isPackageProtectionEnabled()) { return (Map<String, ? extends FilterRegistration>) doPrivileged("getFilterRegistrations", null); } else { return context.getFilterRegistrations(); } }	@Override public <T extends EventListener> T createListener(Class<T> c) throws ServletException { if (SecurityUtil.isPackageProtectionEnabled()) { return (T) doPrivileged("createListener", new Object[] { c }); } else { return context.createListener(c); } }
boolean matchDispatcher(FilterMap filterMap, DispatcherType type) { switch(type) { case FORWARD: { if ((filterMap.getDispatcherMapping() & FilterMap.FORWARD) > 0) { return true; } break; } case INCLUDE: { if ((filterMap.getDispatcherMapping() & FilterMap.INCLUDE) > 0) { return true; } break; } case REQUEST: { if ((filterMap.getDispatcherMapping() & FilterMap.REQUEST) > 0) { return true; } break; } case ERROR: { if ((filterMap.getDispatcherMapping() & FilterMap.ERROR) > 0) { return true; } break; } } return false; }	public void addURLPattern(String urlPattern) { if ("*".equals(urlPattern)) { this.matchAllUrlPatterns = true; } else { String[] results = new String[urlPatterns.length + 1]; System.arraycopy(urlPatterns, 0, results, 0, urlPatterns.length); results[urlPatterns.length] = RequestUtil.URLDecode(urlPattern); urlPatterns = results; } }	public void setDispatcher(String dispatcherString) { String dispatcher = dispatcherString.toUpperCase(); if (dispatcher.equals(DispatcherType.FORWARD.name())) { dispatcherMapping |= FORWARD; } else if (dispatcher.equals(DispatcherType.INCLUDE.name())) { dispatcherMapping |= INCLUDE; } else if (dispatcher.equals(DispatcherType.REQUEST.name())) { dispatcherMapping |= REQUEST; } else if (dispatcher.equals(DispatcherType.ERROR.name())) { dispatcherMapping |= ERROR; } }
public String[] findManagedBeans(String group) { ArrayList<String> results = new ArrayList<String>(); Iterator<ManagedBean> items = descriptors.values().iterator(); while (items.hasNext()) { ManagedBean item = items.next(); if ((group == null) && (item.getGroup() == null)) { results.add(item.getName()); } else if (group.equals(item.getGroup())) { results.add(item.getName()); } } String[] values = new String[results.size()]; return results.toArray(values); }	public List<ObjectName> load(String sourceType, Object source, String param) throws Exception { if (log.isTraceEnabled()) { log.trace("load " + source); } String location = null; String type = null; Object inputsource = null; if (source instanceof DynamicMBean) { sourceType = "MbeansDescriptorsDynamicMBeanSource"; inputsource = source; } else if (source instanceof URL) { URL url = (URL) source; location = url.toString(); type = param; inputsource = url.openStream(); if (sourceType == null) { sourceType = sourceTypeFromExt(location); } } else if (source instanceof File) { location = ((File) source).getAbsolutePath(); inputsource = new FileInputStream((File) source); type = param; if (sourceType == null) { sourceType = sourceTypeFromExt(location); } } else if (source instanceof InputStream) { type = param; inputsource = source; } else if (source instanceof Class) { location = ((Class<?>) source).getName(); type = param; inputsource = source; if (sourceType == null) { sourceType = "MbeansDescriptorsIntrospectionSource"; } } if (sourceType == null) { sourceType = "MbeansDescriptorsDigesterSource"; } ModelerSource ds = getModelerSource(sourceType); List<ObjectName> mbeans = ds.loadDescriptors(this, location, type, inputsource); return mbeans; }
final BeanProperty property(ELContext ctx, Object base, Object property) { Class<?> type = base.getClass(); String prop = property.toString(); BeanProperties props = this.cache.get(type.getName()); if (props == null || type != props.getType()) { props = new BeanProperties(type); this.cache.put(type.getName(), props); } return props.get(ctx, prop); }	private Class<?> getType() { return type; }	@Override public Class<?> getCommonPropertyType(ELContext context, Object base) { if (base instanceof ResourceBundle) { return String.class; } return null; }	public Object getContext(Class key) { if (this.map == null) { return null; } return this.map.get(key); }	@Override public Class<?> getType(ELContext context, Object base, Object property) throws NullPointerException, PropertyNotFoundException, ELException { if (context == null) { throw new NullPointerException(); } if (base instanceof List) { context.setPropertyResolved(true); List<Object> list = (List<Object>) base; int idx = coerce(property); if (idx < 0 || idx >= list.size()) { return null; } Object obj = list.get(idx); return (obj != null) ? obj.getClass() : null; } return null; }	@Override public Class<?> getType(ELContext context, Object base, Object property) throws NullPointerException, PropertyNotFoundException, ELException { if (context == null) { throw new NullPointerException(); } if (base instanceof Map) { context.setPropertyResolved(true); Object obj = ((Map) base).get(property); return (obj != null) ? obj.getClass() : null; } return null; }	@Override public Class<?> getCommonPropertyType(ELContext context, Object base) { if (base != null && base instanceof List) { return Integer.class; } return null; }	@Override public Class<?> getCommonPropertyType(ELContext context, Object base) { if (base instanceof Map) { return Object.class; } return null; }	@Override public boolean isReadOnly(ELContext context, Object base, Object property) throws NullPointerException, PropertyNotFoundException, ELException { if (context == null) { throw new NullPointerException(); } if (base instanceof ResourceBundle) { context.setPropertyResolved(true); } return true; }	@Override public void setValue(ELContext context, Object base, Object property, Object value) throws NullPointerException, PropertyNotFoundException, PropertyNotWritableException, ELException { if (context == null) { throw new NullPointerException(); } if (base instanceof List) { context.setPropertyResolved(true); List<Object> list = (List<Object>) base; if (this.readOnly) { throw new PropertyNotWritableException(message(context, "resolverNotWriteable", new Object[] { base.getClass().getName() })); } int idx = coerce(property); try { list.set(idx, value); } catch (UnsupportedOperationException e) { throw new PropertyNotWritableException(e); } catch (IndexOutOfBoundsException e) { throw new PropertyNotFoundException(e); } } }	@Override public void setValue(ELContext context, Object base, Object property, Object value) throws NullPointerException, PropertyNotFoundException, PropertyNotWritableException, ELException { if (context == null) { throw new NullPointerException(); } if (base instanceof Map) { context.setPropertyResolved(true); if (this.readOnly) { throw new PropertyNotWritableException(message(context, "resolverNotWriteable", new Object[] { base.getClass().getName() })); } try { ((Map) base).put(property, value); } catch (UnsupportedOperationException e) { throw new PropertyNotWritableException(e); } } }
protected void createProperty(String propertyPrefix, Object result) { if (propertyPrefix == null) propertyPrefix = ""; if (result instanceof CompositeDataSupport) { CompositeDataSupport data = (CompositeDataSupport) result; CompositeType compositeType = data.getCompositeType(); Set<String> keys = compositeType.keySet(); for (Iterator<String> iter = keys.iterator(); iter.hasNext(); ) { String key = iter.next(); Object value = data.get(key); OpenType<?> type = compositeType.getType(key); if (type instanceof SimpleType) { setProperty(propertyPrefix + "." + key, value); } else { createProperty(propertyPrefix + "." + key, value); } } } else if (result instanceof TabularDataSupport) { TabularDataSupport data = (TabularDataSupport) result; for (Iterator<Object> iter = data.keySet().iterator(); iter.hasNext(); ) { Object key = iter.next(); for (Iterator<Object> iter1 = ((List<Object>) key).iterator(); iter1.hasNext(); ) { Object key1 = iter1.next(); CompositeData valuedata = data.get(new Object[] { key1 }); Object value = valuedata.get("value"); OpenType<?> type = valuedata.getCompositeType().getType("value"); if (type instanceof SimpleType) { setProperty(propertyPrefix + "." + key1, value); } else { createProperty(propertyPrefix + "." + key1, value); } } } } else if (result.getClass().isArray()) { if (isSeparatearrayresults()) { int size = 0; for (int i = 0; i < Array.getLength(result); i++) { if (setProperty(propertyPrefix + "." + size, Array.get(result, i))) { size++; } } if (size > 0) { setProperty(propertyPrefix + ".Length", Integer.toString(size)); } } } else { String delim = getDelimiter(); if (delim != null) { StringTokenizer tokenizer = new StringTokenizer(result.toString(), delim); int size = 0; for (; tokenizer.hasMoreTokens(); ) { String token = tokenizer.nextToken(); if (setProperty(propertyPrefix + "." + size, token)) { size++; } } if (size > 0) setProperty(propertyPrefix + ".Length", Integer.toString(size)); } else { setProperty(propertyPrefix, result.toString()); } } }	protected void printMap(String header) { try { System.out.println("\nDEBUG MAP:" + header); System.out.println("Map[" + new String(mapContextName, chset) + ", Map Size:" + super.size()); Member[] mbrs = getMapMembers(); for (int i = 0; i < mbrs.length; i++) { System.out.println("Mbr[" + (i + 1) + "=" + mbrs[i].getName()); } Iterator i = super.entrySet().iterator(); int cnt = 0; while (i.hasNext()) { Map.Entry e = (Map.Entry) i.next(); System.out.println((++cnt) + ". " + super.get(e.getKey())); } System.out.println("EndMap]\n\n"); } catch (Exception ignore) { ignore.printStackTrace(); } }	protected void resetReplicationRequest(Request request, boolean isCrossContext) { Session contextSession = request.getSessionInternal(false); if (contextSession instanceof DeltaSession) { resetDeltaRequest(contextSession); ((DeltaSession) contextSession).setPrimarySession(true); } if (isCrossContext) { Object sessions = crossContextSessions.get(); if (sessions != null && sessions instanceof List && ((List<Session>) sessions).size() > 0) { Iterator<Session> iter = ((List<Session>) sessions).iterator(); for (; iter.hasNext(); ) { Session session = iter.next(); resetDeltaRequest(session); if (session instanceof DeltaSession) ((DeltaSession) contextSession).setPrimarySession(true); } } } }	protected void sendCrossContextSession(CatalinaCluster containerCluster) { Object sessions = crossContextSessions.get(); if (sessions != null && sessions instanceof List && ((List<Session>) sessions).size() > 0) { for (Iterator<Session> iter = ((List<Session>) sessions).iterator(); iter.hasNext(); ) { Session session = iter.next(); if (log.isDebugEnabled()) log.debug(sm.getString("ReplicationValve.crossContext.sendDelta", session.getManager().getContainer().getName())); sendMessage(session, (ClusterManager) session.getManager(), containerCluster); if (doStatistics()) { nrOfCrossContextSendRequests++; } } } }	public Serializable replyRequest(Serializable msg, final Member sender) { if (!(msg instanceof MapMessage)) return null; MapMessage mapmsg = (MapMessage) msg; if (mapmsg.getMsgType() == MapMessage.MSG_INIT) { mapmsg.setPrimary(channel.getLocalMember(false)); return mapmsg; } if (mapmsg.getMsgType() == MapMessage.MSG_START) { mapmsg.setPrimary(channel.getLocalMember(false)); mapMemberAdded(sender); return mapmsg; } if (mapmsg.getMsgType() == MapMessage.MSG_RETRIEVE_BACKUP) { MapEntry entry = (MapEntry) super.get(mapmsg.getKey()); if (entry == null || (!entry.isSerializable())) return null; mapmsg.setValue((Serializable) entry.getValue()); return mapmsg; } if (mapmsg.getMsgType() == MapMessage.MSG_STATE || mapmsg.getMsgType() == MapMessage.MSG_STATE_COPY) { synchronized (stateMutex) { ArrayList<MapMessage> list = new ArrayList<MapMessage>(); Iterator i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry e = (Map.Entry) i.next(); MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry != null && entry.isSerializable()) { boolean copy = (mapmsg.getMsgType() == MapMessage.MSG_STATE_COPY); MapMessage me = new MapMessage(mapContextName, copy ? MapMessage.MSG_COPY : MapMessage.MSG_PROXY, false, (Serializable) entry.getKey(), copy ? (Serializable) entry.getValue() : null, null, entry.getPrimary(), entry.getBackupNodes()); list.add(me); } } mapmsg.setValue(list); return mapmsg; } //synchronized } return null; }	public String listSessionIdsFull() { StringBuilder sb = new StringBuilder(); LazyReplicatedMap map = (LazyReplicatedMap) sessions; Iterator<String> keys = map.keySetFull().iterator(); while (keys.hasNext()) { sb.append(keys.next()).append(" "); } return sb.toString(); }	@Override public boolean containsValue(Object value) { if (value == null) { return super.containsValue(value); } else { Iterator i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry e = (Map.Entry) i.next(); MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry != null && entry.isPrimary() && value.equals(entry.getValue())) return true; } return false; } //end if }	@Override public Collection<Object> values() { ArrayList<Object> values = new ArrayList<Object>(); Iterator i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry e = (Map.Entry) i.next(); MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry != null && entry.isPrimary() && entry.getValue() != null) values.add(entry.getValue()); } return Collections.unmodifiableCollection(values); }	@Override public Collection<Object> values() { ArrayList<Object> values = new ArrayList<Object>(); Iterator i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry e = (Map.Entry) i.next(); MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry != null && entry.isPrimary() && entry.getValue() != null) values.add(entry.getValue()); } return Collections.unmodifiableCollection(values); }	@Override public boolean keepalive() { boolean result = false; Map.Entry<Member, BioSender>[] entries = bioSenders.entrySet().toArray(new Map.Entry[bioSenders.size()]); for (int i = 0; i < entries.length; i++) { BioSender sender = entries[i].getValue(); if (sender.keepalive()) { bioSenders.remove(entries[i].getKey()); } } return result; }	@Override public int size() { //todo, implement a counter variable instead int counter = 0; Iterator it = super.entrySet().iterator(); while (it != null && it.hasNext()) { Map.Entry e = (Map.Entry) it.next(); if (e != null) { MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry != null && entry.isPrimary() && entry.getValue() != null) counter++; } } return counter; }	@Override public Set<Object> keySet() { //todo implement LinkedHashSet<Object> set = new LinkedHashSet<Object>(super.size()); Iterator i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry e = (Map.Entry) i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry) super.get(key); if (entry != null && entry.isPrimary()) set.add(key); } return Collections.unmodifiableSet(set); }	public void init(String host, int port) throws Exception { int iport = 0; String shost = null; mBeanServer = Registry.getRegistry(null, null).getMBeanServer(); String onStr = "*:type=ThreadPool,*"; ObjectName objectName = new ObjectName(onStr); Set set = mBeanServer.queryMBeans(objectName, null); Iterator<ObjectInstance> iterator = set.iterator(); while (iterator.hasNext()) { ObjectInstance oi = iterator.next(); objName = oi.getObjectName(); String name = objName.getKeyProperty("name"); String[] elenames = name.split("-"); String sport = elenames[elenames.length - 1]; iport = Integer.parseInt(sport); String[] shosts = elenames[1].split("%2F"); shost = shosts[0]; if (port == 0 && host == null) break; if (host == null && iport == port) break; if (shost.compareTo(host) == 0) break; /* Done port and host are the expected ones */ } if (objName == null) throw (new Exception("Can't find connector for " + host + ":" + port)); this.port = iport; this.host = shost; }	public void mapMemberAdded(Member member) { if (member.equals(getChannel().getLocalMember(false))) return; boolean memberAdded = false; synchronized (mapMembers) { if (!mapMembers.containsKey(member)) { mapMembers.put(member, new Long(System.currentTimeMillis())); memberAdded = true; } } if (memberAdded) { synchronized (stateMutex) { Iterator i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry e = (Map.Entry) i.next(); MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry == null) continue; if (entry.isPrimary() && (entry.getBackupNodes() == null || entry.getBackupNodes().length == 0)) { try { Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue()); entry.setBackupNodes(backup); entry.setPrimary(channel.getLocalMember(false)); } catch (ChannelException x) { log.error("Unable to select backup node.", x); } //catch } //end if } //while } //synchronized } //end if }	public void memberDisappeared(Member member) { boolean removed = false; synchronized (mapMembers) { removed = (mapMembers.remove(member) != null); if (!removed) { if (log.isDebugEnabled()) log.debug("Member[" + member + "] disappeared, but was not present in the map."); return; } } Iterator i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry e = (Map.Entry) i.next(); MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry == null) continue; if (entry.isPrimary() && inSet(member, entry.getBackupNodes())) { if (log.isDebugEnabled()) log.debug("[1] Primary choosing a new backup"); try { Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue()); entry.setBackupNodes(backup); entry.setPrimary(channel.getLocalMember(false)); } catch (ChannelException x) { log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node", x); } } else if (member.equals(entry.getPrimary())) { if (log.isDebugEnabled()) log.debug("[2] Primary disappeared"); entry.setPrimary(null); } if (entry.isProxy() && entry.getPrimary() == null && entry.getBackupNodes() != null && entry.getBackupNodes().length == 1 && entry.getBackupNodes()[0].equals(member)) { if (log.isDebugEnabled()) log.debug("[3] Removing orphaned proxy"); i.remove(); } else if (entry.getPrimary() == null && entry.isBackup() && entry.getBackupNodes() != null && entry.getBackupNodes().length == 1 && entry.getBackupNodes()[0].equals(channel.getLocalMember(false))) { try { if (log.isDebugEnabled()) log.debug("[4] Backup becoming primary"); entry.setPrimary(channel.getLocalMember(false)); entry.setBackup(false); entry.setProxy(false); Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue()); entry.setBackupNodes(backup); if (mapOwner != null) mapOwner.objectMadePrimay(entry.getKey(), entry.getValue()); } catch (ChannelException x) { log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node", x); } } } //while }	@Override public void putAll(Map m) { Iterator i = m.entrySet().iterator(); while (i.hasNext()) { Map.Entry entry = (Map.Entry) i.next(); put(entry.getKey(), entry.getValue()); } }	public void replicate(boolean complete) { Iterator i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry e = (Map.Entry) i.next(); replicate(e.getKey(), complete); } //while }	public void transferState() { try { Member[] members = getMapMembers(); Member backup = members.length > 0 ? (Member) members[0] : null; if (backup != null) { MapMessage msg = new MapMessage(mapContextName, getStateMessageType(), false, null, null, null, null, null); Response[] resp = rpcChannel.send(new Member[] { backup }, msg, RpcChannel.FIRST_REPLY, channelSendOptions, rpcTimeout); if (resp.length > 0) { synchronized (stateMutex) { msg = (MapMessage) resp[0].getMessage(); msg.deserialize(getExternalLoaders()); ArrayList list = (ArrayList) msg.getValue(); for (int i = 0; i < list.size(); i++) { messageReceived((Serializable) list.get(i), resp[0].getSource()); } //for } } else { log.warn("Transfer state, 0 replies, probably a timeout."); } } } catch (ChannelException x) { log.error("Unable to transfer LazyReplicatedMap state.", x); } catch (IOException x) { log.error("Unable to transfer LazyReplicatedMap state.", x); } catch (ClassNotFoundException x) { log.error("Unable to transfer LazyReplicatedMap state.", x); } stateTransferred = true; }
private void resetContext() throws Exception, MBeanRegistrationException { // Restore the original state ( pre reading web.xml in start ) children = new HashMap<String, Container>(); startupTime = 0; startTime = 0; tldScanTime = 0; distributable = false; applicationListeners = new String[0]; applicationEventListenersObjects = new Object[0]; applicationLifecycleListenersObjects = new Object[0]; if (log.isDebugEnabled()) log.debug("resetContext " + oname); }	public void lifecycleEvent(LifecycleEvent event) { try { context = (Context) event.getLifecycle(); } catch (ClassCastException e) { log.error(sm.getString("tldConfig.cce", event.getLifecycle()), e); return; } if (event.getType().equals(Lifecycle.INIT_EVENT)) { init(); } else if (event.getType().equals(Lifecycle.START_EVENT)) { try { execute(); } catch (Exception e) { log.error(sm.getString("tldConfig.execute", context.getPath()), e); } } // Ignore the other event types - nothing to do }
protected boolean parseChunkHeader() throws IOException { int result = 0; boolean eol = false; boolean readDigit = false; boolean trailer = false; while (!eol) { if (pos >= lastValid) { if (readBytes() <= 0) return false; } if (buf[pos] == Constants.CR) { } else if (buf[pos] == Constants.LF) { eol = true; } else if (buf[pos] == Constants.SEMI_COLON) { trailer = true; } else if (!trailer) { if (HexUtils.DEC[buf[pos]] != -1) { readDigit = true; result *= 16; result += HexUtils.DEC[buf[pos]]; } else { return false; } } pos++; } if (!readDigit) return false; if (result == 0) endChunk = true; remaining = result; if (remaining < 0) return false; return true; }	protected void parseHost(MessageBytes valueMB) { if (valueMB == null || valueMB.isNull()) { // HTTP/1.0 // Default is what the socket tells us. Overridden if a host is request.setServerPort(socket.getLocalPort()); InetAddress localAddress = socket.getLocalAddress(); // Setting the socket-related fields. The adapter doesn't know request.serverName().setString(localAddress.getHostName()); return; } ByteChunk valueBC = valueMB.getByteChunk(); byte[] valueB = valueBC.getBytes(); int valueL = valueBC.getLength(); int valueS = valueBC.getStart(); int colonPos = -1; if (hostNameC.length < valueL) { hostNameC = new char[valueL]; } boolean ipv6 = (valueB[valueS] == '['); boolean bracketClosed = false; for (int i = 0; i < valueL; i++) { char b = (char) valueB[i + valueS]; hostNameC[i] = b; if (b == ']') { bracketClosed = true; } else if (b == ':') { if (!ipv6 || bracketClosed) { colonPos = i; break; } } } if (colonPos < 0) { if (sslSupport == null) { request.setServerPort(80); } else { request.setServerPort(443); } request.serverName().setChars(hostNameC, 0, valueL); } else { request.serverName().setChars(hostNameC, 0, colonPos); int port = 0; int mult = 1; for (int i = valueL - 1; i > colonPos; i--) { int charValue = HexUtils.DEC[valueB[i + valueS]]; if (charValue == -1) { error = true; response.setStatus(400); break; } port = port + (charValue * mult); mult = 10 * mult; } request.setServerPort(port); } }	public int doWrite(ByteChunk chunk, Response res) throws IOException { int result = chunk.getLength(); if (result <= 0) { return 0; } int pos = 7; int current = result; while (current > 0) { int digit = current % 16; current = current / 16; chunkLength[pos--] = HexUtils.HEX[digit]; } chunkHeader.setBytes(chunkLength, pos + 1, 9 - pos); buffer.doWrite(chunkHeader, res); buffer.doWrite(chunk, res); chunkHeader.setBytes(chunkLength, 8, 2); buffer.doWrite(chunkHeader, res); return result; }	public static void load() { // Nothing to do }	public void parseHost(MessageBytes valueMB) { if (valueMB == null || (valueMB != null && valueMB.isNull())) { request.setServerPort(request.getLocalPort()); try { request.serverName().duplicate(request.localName()); } catch (IOException e) { response.setStatus(400); error = true; } return; } ByteChunk valueBC = valueMB.getByteChunk(); byte[] valueB = valueBC.getBytes(); int valueL = valueBC.getLength(); int valueS = valueBC.getStart(); int colonPos = -1; if (hostNameC.length < valueL) { hostNameC = new char[valueL]; } boolean ipv6 = (valueB[valueS] == '['); boolean bracketClosed = false; for (int i = 0; i < valueL; i++) { char b = (char) valueB[i + valueS]; hostNameC[i] = b; if (b == ']') { bracketClosed = true; } else if (b == ':') { if (!ipv6 || bracketClosed) { colonPos = i; break; } } } if (colonPos < 0) { if (request.scheme().equalsIgnoreCase("https")) { request.setServerPort(443); } else { request.setServerPort(80); } request.serverName().setChars(hostNameC, 0, valueL); } else { request.serverName().setChars(hostNameC, 0, colonPos); int port = 0; int mult = 1; for (int i = valueL - 1; i > colonPos; i--) { int charValue = HexUtils.DEC[valueB[i + valueS]]; if (charValue == -1) { error = true; response.setStatus(400); break; } port = port + (charValue * mult); mult = 10 * mult; } request.setServerPort(port); } }	public void parseHost(MessageBytes valueMB) { if (valueMB == null || (valueMB != null && valueMB.isNull())) { request.setServerPort(request.getLocalPort()); try { request.serverName().duplicate(request.localName()); } catch (IOException e) { response.setStatus(400); error = true; } return; } ByteChunk valueBC = valueMB.getByteChunk(); byte[] valueB = valueBC.getBytes(); int valueL = valueBC.getLength(); int valueS = valueBC.getStart(); int colonPos = -1; if (hostNameC.length < valueL) { hostNameC = new char[valueL]; } boolean ipv6 = (valueB[valueS] == '['); boolean bracketClosed = false; for (int i = 0; i < valueL; i++) { char b = (char) valueB[i + valueS]; hostNameC[i] = b; if (b == ']') { bracketClosed = true; } else if (b == ':') { if (!ipv6 || bracketClosed) { colonPos = i; break; } } } if (colonPos < 0) { if (request.scheme().equalsIgnoreCase("https")) { request.setServerPort(443); } else { request.setServerPort(80); } request.serverName().setChars(hostNameC, 0, valueL); } else { request.serverName().setChars(hostNameC, 0, colonPos); int port = 0; int mult = 1; for (int i = valueL - 1; i > colonPos; i--) { int charValue = HexUtils.DEC[valueB[i + valueS]]; if (charValue == -1) { error = true; response.setStatus(400); break; } port = port + (charValue * mult); mult = 10 * mult; } request.setServerPort(port); } }	public void parseHost(MessageBytes valueMB) { if (valueMB == null || valueMB.isNull()) { // HTTP/1.0 // Default is what the socket tells us. Overridden if a host is request.setServerPort(endpoint.getPort()); return; } ByteChunk valueBC = valueMB.getByteChunk(); byte[] valueB = valueBC.getBytes(); int valueL = valueBC.getLength(); int valueS = valueBC.getStart(); int colonPos = -1; if (hostNameC.length < valueL) { hostNameC = new char[valueL]; } boolean ipv6 = (valueB[valueS] == '['); boolean bracketClosed = false; for (int i = 0; i < valueL; i++) { char b = (char) valueB[i + valueS]; hostNameC[i] = b; if (b == ']') { bracketClosed = true; } else if (b == ':') { if (!ipv6 || bracketClosed) { colonPos = i; break; } } } if (colonPos < 0) { if (!ssl) { request.setServerPort(80); } else { request.setServerPort(443); } request.serverName().setChars(hostNameC, 0, valueL); } else { request.serverName().setChars(hostNameC, 0, colonPos); int port = 0; int mult = 1; for (int i = valueL - 1; i > colonPos; i--) { int charValue = HexUtils.DEC[valueB[i + valueS]]; if (charValue == -1) { error = true; response.setStatus(400); break; } port = port + (charValue * mult); mult = 10 * mult; } request.setServerPort(port); } }	public void parseHost(MessageBytes valueMB) { if (valueMB == null || valueMB.isNull()) { // HTTP/1.0 // Default is what the socket tells us. Overridden if a host is request.setServerPort(endpoint.getPort()); return; } ByteChunk valueBC = valueMB.getByteChunk(); byte[] valueB = valueBC.getBytes(); int valueL = valueBC.getLength(); int valueS = valueBC.getStart(); int colonPos = -1; if (hostNameC.length < valueL) { hostNameC = new char[valueL]; } boolean ipv6 = (valueB[valueS] == '['); boolean bracketClosed = false; for (int i = 0; i < valueL; i++) { char b = (char) valueB[i + valueS]; hostNameC[i] = b; if (b == ']') { bracketClosed = true; } else if (b == ':') { if (!ipv6 || bracketClosed) { colonPos = i; break; } } } if (colonPos < 0) { if (!ssl) { request.setServerPort(80); } else { request.setServerPort(443); } request.serverName().setChars(hostNameC, 0, valueL); } else { request.serverName().setChars(hostNameC, 0, colonPos); int port = 0; int mult = 1; for (int i = valueL - 1; i > colonPos; i--) { int charValue = HexUtils.DEC[valueB[i + valueS]]; if (charValue == -1) { error = true; response.setStatus(400); break; } port = port + (charValue * mult); mult = 10 * mult; } request.setServerPort(port); } }	public void setInt(int i) { byteC.allocate(16, 32); int current = i; byte[] buf = byteC.getBuffer(); int start = 0; int end = 0; if (i == 0) { buf[end++] = (byte) '0'; } if (i < 0) { current = -i; buf[end++] = (byte) '-'; } while (current > 0) { int digit = current % 10; current = current / 10; buf[end++] = HexUtils.HEX[digit]; } byteC.setOffset(0); byteC.setEnd(end); end--; if (i < 0) { start++; } while (end > start) { byte temp = buf[start]; buf[start] = buf[end]; buf[end] = temp; start++; end--; } intValue = i; hasStrValue = false; hasHashCode = false; hasIntValue = true; hasLongValue = false; type = T_BYTES; }	public void setLong(long l) { byteC.allocate(32, 64); long current = l; byte[] buf = byteC.getBuffer(); int start = 0; int end = 0; if (l == 0) { buf[end++] = (byte) '0'; } if (l < 0) { current = -l; buf[end++] = (byte) '-'; } while (current > 0) { int digit = (int) (current % 10); current = current / 10; buf[end++] = HexUtils.HEX[digit]; } byteC.setOffset(0); byteC.setEnd(end); end--; if (l < 0) { start++; } while (end > start) { byte temp = buf[start]; buf[start] = buf[end]; buf[end] = temp; start++; end--; } longValue = l; hasStrValue = false; hasHashCode = false; hasIntValue = false; hasLongValue = true; type = T_BYTES; }
public void remove() { //empty operation }	public long getRecoverySleepTime() { return recoverySleepTime; }
public int read(ByteBuffer buf, NioChannel socket, long readTimeout) throws IOException { SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); if (key == null) throw new IOException("Key no longer registered"); KeyReference reference = new KeyReference(); KeyAttachment att = (KeyAttachment) key.attachment(); int read = 0; boolean timedout = false; int keycount = 1; long time = System.currentTimeMillis(); try { while ((!timedout) && read == 0) { if (keycount > 0) { int cnt = socket.read(buf); if (cnt == -1) throw new EOFException(); read += cnt; if (cnt > 0) break; } try { if (att.getReadLatch() == null || att.getReadLatch().getCount() == 0) att.startReadLatch(1); poller.add(att, SelectionKey.OP_READ, reference); att.awaitReadLatch(readTimeout, TimeUnit.MILLISECONDS); } catch (InterruptedException ignore) { Thread.interrupted(); } if (att.getReadLatch() != null && att.getReadLatch().getCount() > 0) { keycount = 0; } else { keycount = 1; att.resetReadLatch(); } if (readTimeout > 0 && (keycount == 0)) timedout = (System.currentTimeMillis() - time) >= readTimeout; } if (timedout) throw new SocketTimeoutException(); } finally { poller.remove(att, SelectionKey.OP_READ); if (timedout && reference.key != null) { poller.cancelKey(reference.key); } reference.key = null; } return read; }
public void destroySubcontext(Name name) throws NamingException { checkWritable(); while ((!name.isEmpty()) && (name.get(0).length() == 0)) name = name.getSuffix(1); if (name.isEmpty()) throw new NamingException(sm.getString("namingContext.invalidName")); NamingEntry entry = bindings.get(name.get(0)); if (entry == null) { throw new NameNotFoundException(sm.getString("namingContext.nameNotBound", name.get(0))); } if (name.size() > 1) { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).unbind(name.getSuffix(1)); } else { throw new NamingException(sm.getString("namingContext.contextExpected")); } } else { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).close(); bindings.remove(name.get(0)); } else { throw new NotContextException(sm.getString("namingContext.contextExpected")); } } }
public void setDomain(byte[] domain) { this.domain = domain; }	public void setDomain(byte[] domain) { this.domain = domain; if (localMember != null) { localMember.setDomain(domain); localMember.getData(true, true); try { if (impl != null) impl.send(false); } catch (Exception x) { log.error("Unable to send domain update.", x); } } }
@Override public void begin(String namespace, String name, Attributes attributes) throws Exception { if (isLoginConfigSet) { throw new IllegalArgumentException("<login-config> element is limited to 1 occurrence"); } isLoginConfigSet = true; }
private void processGlobalResourcesChange(String name, Object oldValue, Object newValue) { if (name.equals("ejb")) { if (oldValue != null) { ContextEjb ejb = (ContextEjb) oldValue; if (ejb.getName() != null) { removeEjb(ejb.getName()); } } if (newValue != null) { ContextEjb ejb = (ContextEjb) newValue; if (ejb.getName() != null) { addEjb(ejb); } } } else if (name.equals("environment")) { if (oldValue != null) { ContextEnvironment env = (ContextEnvironment) oldValue; if (env.getName() != null) { removeEnvironment(env.getName()); } } if (newValue != null) { ContextEnvironment env = (ContextEnvironment) newValue; if (env.getName() != null) { addEnvironment(env); } } } else if (name.equals("localEjb")) { if (oldValue != null) { ContextLocalEjb ejb = (ContextLocalEjb) oldValue; if (ejb.getName() != null) { removeLocalEjb(ejb.getName()); } } if (newValue != null) { ContextLocalEjb ejb = (ContextLocalEjb) newValue; if (ejb.getName() != null) { addLocalEjb(ejb); } } } else if (name.equals("resource")) { if (oldValue != null) { ContextResource resource = (ContextResource) oldValue; if (resource.getName() != null) { removeResource(resource.getName()); } } if (newValue != null) { ContextResource resource = (ContextResource) newValue; if (resource.getName() != null) { addResource(resource); } } } else if (name.equals("resourceEnvRef")) { if (oldValue != null) { ContextResourceEnvRef resourceEnvRef = (ContextResourceEnvRef) oldValue; if (resourceEnvRef.getName() != null) { removeResourceEnvRef(resourceEnvRef.getName()); } } if (newValue != null) { ContextResourceEnvRef resourceEnvRef = (ContextResourceEnvRef) newValue; if (resourceEnvRef.getName() != null) { addResourceEnvRef(resourceEnvRef); } } } else if (name.equals("resourceLink")) { if (oldValue != null) { ContextResourceLink rl = (ContextResourceLink) oldValue; if (rl.getName() != null) { removeResourceLink(rl.getName()); } } if (newValue != null) { ContextResourceLink rl = (ContextResourceLink) newValue; if (rl.getName() != null) { addResourceLink(rl); } } } else if (name.equals("service")) { if (oldValue != null) { ContextService service = (ContextService) oldValue; if (service.getName() != null) { removeService(service.getName()); } } if (newValue != null) { ContextService service = (ContextService) newValue; if (service.getName() != null) { addService(service); } } } }	public void containerEvent(ContainerEvent event) { if (!initialized) return; ContextAccessController.setWritable(getName(), container); String type = event.getType(); if (type.equals("addEjb")) { String ejbName = (String) event.getData(); if (ejbName != null) { ContextEjb ejb = namingResources.findEjb(ejbName); addEjb(ejb); } } else if (type.equals("addEnvironment")) { String environmentName = (String) event.getData(); if (environmentName != null) { ContextEnvironment env = namingResources.findEnvironment(environmentName); addEnvironment(env); } } else if (type.equals("addLocalEjb")) { String localEjbName = (String) event.getData(); if (localEjbName != null) { ContextLocalEjb localEjb = namingResources.findLocalEjb(localEjbName); addLocalEjb(localEjb); } } else if (type.equals("addResource")) { String resourceName = (String) event.getData(); if (resourceName != null) { ContextResource resource = namingResources.findResource(resourceName); addResource(resource); } } else if (type.equals("addResourceLink")) { String resourceLinkName = (String) event.getData(); if (resourceLinkName != null) { ContextResourceLink resourceLink = namingResources.findResourceLink(resourceLinkName); addResourceLink(resourceLink); } } else if (type.equals("addResourceEnvRef")) { String resourceEnvRefName = (String) event.getData(); if (resourceEnvRefName != null) { ContextResourceEnvRef resourceEnvRef = namingResources.findResourceEnvRef(resourceEnvRefName); addResourceEnvRef(resourceEnvRef); } } else if (type.equals("addService")) { String serviceName = (String) event.getData(); if (serviceName != null) { ContextService service = namingResources.findService(serviceName); addService(service); } } else if (type.equals("removeEjb")) { String ejbName = (String) event.getData(); if (ejbName != null) { removeEjb(ejbName); } } else if (type.equals("removeEnvironment")) { String environmentName = (String) event.getData(); if (environmentName != null) { removeEnvironment(environmentName); } } else if (type.equals("removeLocalEjb")) { String localEjbName = (String) event.getData(); if (localEjbName != null) { removeLocalEjb(localEjbName); } } else if (type.equals("removeResource")) { String resourceName = (String) event.getData(); if (resourceName != null) { removeResource(resourceName); } } else if (type.equals("removeResourceLink")) { String resourceLinkName = (String) event.getData(); if (resourceLinkName != null) { removeResourceLink(resourceLinkName); } } else if (type.equals("removeResourceEnvRef")) { String resourceEnvRefName = (String) event.getData(); if (resourceEnvRefName != null) { removeResourceEnvRef(resourceEnvRefName); } } else if (type.equals("removeService")) { String serviceName = (String) event.getData(); if (serviceName != null) { removeService(serviceName); } } ContextAccessController.setReadOnly(getName()); }	public void lifecycleEvent(LifecycleEvent event) { container = event.getLifecycle(); if (container instanceof Context) { namingResources = ((Context) container).getNamingResources(); logger = log; } else if (container instanceof Server) { namingResources = ((Server) container).getGlobalNamingResources(); } else { return; } if (Lifecycle.START_EVENT.equals(event.getType())) { if (initialized) return; Hashtable<String, Object> contextEnv = new Hashtable<String, Object>(); try { namingContext = new NamingContext(contextEnv, getName()); } catch (NamingException e) { // Never happens } ContextAccessController.setSecurityToken(getName(), container); ContextBindings.bindContext(container, namingContext, container); if (log.isDebugEnabled()) { log.debug("Bound " + container); } ContextAccessController.setWritable(getName(), container); try { createNamingContext(); } catch (NamingException e) { logger.error(sm.getString("naming.namingContextCreationFailed", e)); } if (container instanceof Context) { ContextAccessController.setReadOnly(getName()); try { ContextBindings.bindClassLoader(container, container, ((Container) container).getLoader().getClassLoader()); } catch (NamingException e) { logger.error(sm.getString("naming.bindFailed", e)); } } if (container instanceof Server) { namingResources.addPropertyChangeListener(this); org.apache.naming.factory.ResourceLinkFactory.setGlobalContext(namingContext); try { ContextBindings.bindClassLoader(container, container, this.getClass().getClassLoader()); } catch (NamingException e) { logger.error(sm.getString("naming.bindFailed", e)); } if (container instanceof StandardServer) { ((StandardServer) container).setGlobalNamingContext(namingContext); } } initialized = true; } else if (Lifecycle.STOP_EVENT.equals(event.getType())) { if (!initialized) return; ContextAccessController.setWritable(getName(), container); ContextBindings.unbindContext(container, container); if (container instanceof Context) { ContextBindings.unbindClassLoader(container, container, ((Container) container).getLoader().getClassLoader()); } if (container instanceof Server) { namingResources.removePropertyChangeListener(this); ContextBindings.unbindClassLoader(container, container, this.getClass().getClassLoader()); } ContextAccessController.unsetSecurityToken(getName(), container); namingContext = null; envCtx = null; compCtx = null; initialized = false; } }	public void propertyChange(PropertyChangeEvent event) { if (!initialized) return; Object source = event.getSource(); if (source == namingResources) { ContextAccessController.setWritable(getName(), container); processGlobalResourcesChange(event.getPropertyName(), event.getOldValue(), event.getNewValue()); ContextAccessController.setReadOnly(getName()); } }
public void destroy() { if (oname != null) Registry.getRegistry(null, null).unregisterComponent(oname); initialized = false; oname = null; }
public boolean setProperty(String name, String value) { final String socketName = "socket."; try { if (name.startsWith(socketName)) { return IntrospectionUtils.setProperty(socketProperties, name.substring(socketName.length()), value); } else { return IntrospectionUtils.setProperty(this, name, value); } } catch (Exception x) { log.error("Unable to set attribute \"" + name + "\" to \"" + value + "\"", x); return false; } }	public static boolean setProperty(Object o, String name, String value) { if (log.isDebugEnabled()) log.debug("IntrospectionUtils: setProperty(" + o.getClass() + " " + name + "=" + value + ")"); String setter = "set" + capitalize(name); try { Method[] methods = findMethods(o.getClass()); Method setPropertyMethodVoid = null; Method setPropertyMethodBool = null; for (int i = 0; i < methods.length; i++) { Class<?>[] paramT = methods[i].getParameterTypes(); if (setter.equals(methods[i].getName()) && paramT.length == 1 && "java.lang.String".equals(paramT[0].getName())) { methods[i].invoke(o, new Object[] { value }); return true; } } for (int i = 0; i < methods.length; i++) { boolean ok = true; if (setter.equals(methods[i].getName()) && methods[i].getParameterTypes().length == 1) { Class<?> paramType = methods[i].getParameterTypes()[0]; Object[] params = new Object[1]; if ("java.lang.Integer".equals(paramType.getName()) || "int".equals(paramType.getName())) { try { params[0] = new Integer(value); } catch (NumberFormatException ex) { ok = false; } // Try a setFoo ( long ) } else if ("java.lang.Long".equals(paramType.getName()) || "long".equals(paramType.getName())) { try { params[0] = new Long(value); } catch (NumberFormatException ex) { ok = false; } // Try a setFoo ( boolean ) } else if ("java.lang.Boolean".equals(paramType.getName()) || "boolean".equals(paramType.getName())) { params[0] = new Boolean(value); // Try a setFoo ( InetAddress ) } else if ("java.net.InetAddress".equals(paramType.getName())) { try { params[0] = InetAddress.getByName(value); } catch (UnknownHostException exc) { if (log.isDebugEnabled()) log.debug("IntrospectionUtils: Unable to resolve host name:" + value); ok = false; } // Unknown type } else { if (log.isDebugEnabled()) log.debug("IntrospectionUtils: Unknown type " + paramType.getName()); } if (ok) { methods[i].invoke(o, params); return true; } } if ("setProperty".equals(methods[i].getName())) { if (methods[i].getReturnType() == Boolean.TYPE) { setPropertyMethodBool = methods[i]; } else { setPropertyMethodVoid = methods[i]; } } } if (setPropertyMethodBool != null || setPropertyMethodVoid != null) { Object[] params = new Object[2]; params[0] = name; params[1] = value; if (setPropertyMethodBool != null) { try { return (Boolean) setPropertyMethodBool.invoke(o, params); } catch (IllegalArgumentException biae) { if (setPropertyMethodVoid != null) { setPropertyMethodVoid.invoke(o, params); return true; } else { throw biae; } } } else { setPropertyMethodVoid.invoke(o, params); return true; } } } catch (IllegalArgumentException ex2) { log.warn("IAE " + o + " " + name + " " + value, ex2); } catch (SecurityException ex1) { if (log.isDebugEnabled()) log.debug("IntrospectionUtils: SecurityException for " + o.getClass() + " " + name + "=" + value + ")", ex1); } catch (IllegalAccessException iae) { if (log.isDebugEnabled()) log.debug("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " " + name + "=" + value + ")", iae); } catch (InvocationTargetException ie) { if (log.isDebugEnabled()) log.debug("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " " + name + "=" + value + ")", ie); } return false; }
public synchronized void setLoader(Loader loader) { Loader oldLoader = this.loader; if (oldLoader == loader) return; this.loader = loader; if (started && (oldLoader != null) && (oldLoader instanceof Lifecycle)) { try { ((Lifecycle) oldLoader).stop(); } catch (LifecycleException e) { log.error("ContainerBase.setLoader: stop: ", e); } } if (loader != null) loader.setContainer(this); if (started && (loader != null) && (loader instanceof Lifecycle)) { try { ((Lifecycle) loader).start(); } catch (LifecycleException e) { log.error("ContainerBase.setLoader: start: ", e); } } support.firePropertyChange("loader", oldLoader, this.loader); }
private void initClassPath() { StringBuilder cpath = new StringBuilder(); String sep = System.getProperty("path.separator"); if (parentClassLoader instanceof URLClassLoader) { URL[] urls = ((URLClassLoader) parentClassLoader).getURLs(); for (int i = 0; i < urls.length; i++) { if (urls[i].getProtocol().equals("file")) { cpath.append(urls[i].getFile() + sep); } } } cpath.append(options.getScratchDir() + sep); String cp = (String) context.getAttribute(Constants.SERVLET_CLASSPATH); if (cp == null || cp.equals("")) { cp = options.getClassPath(); } classpath = cpath.toString() + cp; if (log.isDebugEnabled()) { log.debug("Compilation classpath initialized: " + getClassPath()); } }	private void initSecurity() { // Setup the PermissionCollection for this web app context // based on the permissions configured for the root of the // web app context directory, then add a file read permission Policy policy = Policy.getPolicy(); if (policy != null) { try { String docBase = context.getRealPath("/"); if (docBase == null) { docBase = options.getScratchDir().toString(); } String codeBase = docBase; if (!codeBase.endsWith(File.separator)) { codeBase = codeBase + File.separator; } File contextDir = new File(codeBase); URL url = contextDir.getCanonicalFile().toURI().toURL(); codeSource = new CodeSource(url, (Certificate[]) null); permissionCollection = policy.getPermissions(codeSource); if (!docBase.endsWith(File.separator)) { permissionCollection.add(new FilePermission(docBase, "read")); docBase = docBase + File.separator; } else { permissionCollection.add(new FilePermission(docBase.substring(0, docBase.length() - 1), "read")); } docBase = docBase + "-"; permissionCollection.add(new FilePermission(docBase, "read")); // Spec says apps should have read/write for their temp // directory. This is fine, as no security sensitive files, at // least any that the app doesn't have full control of anyway, String workDir = options.getScratchDir().toString(); if (!workDir.endsWith(File.separator)) { permissionCollection.add(new FilePermission(workDir, "read,write")); workDir = workDir + File.separator; } workDir = workDir + "-"; permissionCollection.add(new FilePermission(workDir, "read,write,delete")); permissionCollection.add(new RuntimePermission("accessClassInPackage.org.apache.jasper.runtime")); if (parentClassLoader instanceof URLClassLoader) { URL[] urls = ((URLClassLoader) parentClassLoader).getURLs(); String jarUrl = null; String jndiUrl = null; for (int i = 0; i < urls.length; i++) { if (jndiUrl == null && urls[i].toString().startsWith("jndi:")) { jndiUrl = urls[i].toString() + "-"; } if (jarUrl == null && urls[i].toString().startsWith("jar:jndi:")) { jarUrl = urls[i].toString(); jarUrl = jarUrl.substring(0, jarUrl.length() - 2); jarUrl = jarUrl.substring(0, jarUrl.lastIndexOf('/')) + "/-"; } } if (jarUrl != null) { permissionCollection.add(new FilePermission(jarUrl, "read")); permissionCollection.add(new FilePermission(jarUrl.substring(4), "read")); } if (jndiUrl != null) permissionCollection.add(new FilePermission(jndiUrl, "read")); } } catch (Exception e) { context.log("Security Init for context failed", e); } } }	public String getClassPath() { return classpath; }	public int getJspReloadCount() { return jspReloadCount; }	public synchronized void incrementJspReloadCount() { jspReloadCount++; }	public void destroy() { Iterator<JspServletWrapper> servlets = jsps.values().iterator(); while (servlets.hasNext()) { servlets.next().destroy(); } }
public static byte[] createDataPackage(byte[] data, int doff, int dlength, byte[] buffer, int bufoff) { if ((buffer.length - bufoff) > getDataPackageLength(dlength)) { throw new ArrayIndexOutOfBoundsException("Unable to create data package, buffer is too small."); } System.arraycopy(START_DATA, 0, buffer, bufoff, START_DATA.length); toBytes(data.length, buffer, bufoff + START_DATA.length); System.arraycopy(data, doff, buffer, bufoff + START_DATA.length + 4, dlength); System.arraycopy(END_DATA, 0, buffer, bufoff + START_DATA.length + 4 + data.length, END_DATA.length); return buffer; }	public static Serializable deserialize(byte[] data, int offset, int length) throws IOException, ClassNotFoundException, ClassCastException { return deserialize(data, offset, length, null); }	public static byte[] toBytes(boolean bool, byte[] data, int offset) { data[offset] = (byte) (bool ? 1 : 0); return data; }

public NioEndpoint getEndpoint() { return ((NioEndpoint) endpoint); }	public void deregister(Http11NioProcessor processor) { if (proto.getDomain() != null) { synchronized (this) { try { registerCount.addAndGet(-1); if (log.isDebugEnabled()) log.debug("Deregister [" + processor + "] count=" + registerCount.get()); RequestInfo rp = processor.getRequest().getRequestProcessor(); rp.setGlobalProcessor(null); ObjectName rpName = rp.getRpName(); Registry.getRegistry(null, null).unregisterComponent(rpName); rp.setRpName(null); } catch (Exception e) { log.warn("Error unregistering request", e); } } } }	public void init() throws Exception { endpoint.setName(getName()); ((NioEndpoint) endpoint).setHandler(cHandler); try { endpoint.init(); sslImplementation = new JSSEImplementation(); } catch (Exception ex) { log.error(sm.getString("http11protocol.endpoint.initerror"), ex); throw ex; } if (log.isInfoEnabled()) log.info(sm.getString("http11protocol.init", getName())); }	public void init() throws Exception { ((JIoEndpoint) endpoint).setName(getName()); ((JIoEndpoint) endpoint).setHandler(cHandler); try { if (isSSLEnabled()) { sslImplementation = SSLImplementation.getInstance(sslImplementationName); socketFactory = sslImplementation.getServerSocketFactory(); ((JIoEndpoint) endpoint).setServerSocketFactory(socketFactory); } else if (socketFactoryName != null) { socketFactory = (ServerSocketFactory) Class.forName(socketFactoryName).newInstance(); ((JIoEndpoint) endpoint).setServerSocketFactory(socketFactory); } } catch (Exception ex) { log.error(sm.getString("http11protocol.socketfactory.initerror"), ex); throw ex; } if (socketFactory != null) { Iterator<String> attE = attributes.keySet().iterator(); while (attE.hasNext()) { String key = attE.next(); Object v = attributes.get(key); socketFactory.setAttribute(key, v); } } try { endpoint.init(); } catch (Exception ex) { log.error(sm.getString("http11protocol.endpoint.initerror"), ex); throw ex; } if (log.isInfoEnabled()) log.info(sm.getString("http11protocol.init", getName())); }
@Override public boolean isUnavailable() { return false; }

private boolean copy(InputStream is, OutputStream os) { try { byte[] buf = new byte[4096]; while (true) { int len = is.read(buf); if (len < 0) break; os.write(buf, 0, len); } is.close(); os.close(); } catch (IOException e) { return false; } return true; }	private static String unqualify(String path) { path = path.replace('\\', '/'); return path.substring(path.lastIndexOf('/') + 1); }	public void deregister(Http11NioProcessor processor) { if (proto.getDomain() != null) { synchronized (this) { try { registerCount.addAndGet(-1); if (log.isDebugEnabled()) log.debug("Deregister [" + processor + "] count=" + registerCount.get()); RequestInfo rp = processor.getRequest().getRequestProcessor(); rp.setGlobalProcessor(null); ObjectName rpName = rp.getRpName(); Registry.getRegistry(null, null).unregisterComponent(rpName); rp.setRpName(null); } catch (Exception e) { log.warn("Error unregistering request", e); } } } }	public void remove() { //empty operation }	protected void usage() { System.out.println("usage: java org.apache.catalina.startup.Catalina" + " [ -config {pathname} ]" + " [ -nonaming ] " + " { -help | start | stop }"); }



protected JspFragment getJspBody() { return this.jspBody; }	public boolean isAutoFlush() { return autoFlush; }	protected long getLastModified(@SuppressWarnings("unused") HttpServletRequest req) { return -1; }	public FunctionInfo getFunction(String name) { if (functions == null || functions.length == 0) { System.err.println("No functions"); return null; } for (int i = 0; i < functions.length; i++) { if (functions[i].getName().equals(name)) { return functions[i]; } } return null; }	public String getServletInfo() { return ""; }
private boolean isCompressable() { // Nope Compression could works in HTTP 1.0 also // cf: mod_deflate // Compression only since HTTP 1.1 // if (! http11) // return false; MessageBytes acceptEncodingMB = request.getMimeHeaders().getValue("accept-encoding"); if ((acceptEncodingMB == null) || (acceptEncodingMB.indexOf("gzip") == -1)) return false; MessageBytes contentEncodingMB = response.getMimeHeaders().getValue("Content-Encoding"); if ((contentEncodingMB != null) && (contentEncodingMB.indexOf("gzip") != -1)) return false; if (compressionLevel == 2) return true; if (noCompressionUserAgents != null) { MessageBytes userAgentValueMB = request.getMimeHeaders().getValue("user-agent"); if (userAgentValueMB != null) { String userAgentValue = userAgentValueMB.toString(); for (int i = 0; i < noCompressionUserAgents.length; i++) if (noCompressionUserAgents[i].matcher(userAgentValue).matches()) return false; } } long contentLength = response.getContentLengthLong(); if ((contentLength == -1) || (contentLength > compressionMinSize)) { if (compressableMimeTypes != null) { return (startsWithStringArray(compressableMimeTypes, response.getContentType())); } } return false; }	private final Target getTarget(EvaluationContext ctx) throws ELException { Object base = this.children[0].getValue(ctx); if (base == null) { throw new PropertyNotFoundException(MessageFactory.get("error.unreachable.base", this.children[0].getImage())); } Object property = null; int propCount = this.jjtGetNumChildren() - 1; int i = 1; ELResolver resolver = ctx.getELResolver(); if (propCount > 1) { while (base != null && i < propCount) { property = this.children[i].getValue(ctx); ctx.setPropertyResolved(false); base = resolver.getValue(ctx, base, property); i++; } if (base == null || property == null) { throw new PropertyNotFoundException(MessageFactory.get("error.unreachable.property", property)); } } property = this.children[i].getValue(ctx); if (property == null) { throw new PropertyNotFoundException(MessageFactory.get("error.unreachable.property", this.children[i])); } Target t = new Target(); t.base = base; t.property = property; return t; }	private synchronized int writeToSocket(ByteBuffer bytebuffer, boolean block, boolean flip) throws IOException { if (flip) bytebuffer.flip(); int written = 0; NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment) socket.getAttachment(false); if (att == null) throw new IOException("Key must be cancelled"); long writeTimeout = att.getTimeout(); Selector selector = null; try { selector = getSelectorPool().get(); } catch (IOException x) { //ignore } try { written = getSelectorPool().write(bytebuffer, socket, selector, writeTimeout, block, lastWrite); do { if (socket.flush(true, selector, writeTimeout, lastWrite)) break; } while (true); } finally { if (selector != null) getSelectorPool().put(selector); } if (block) bytebuffer.clear(); this.total = 0; return written; }	protected boolean isCompressable() { // Nope Compression could works in HTTP 1.0 also // cf: mod_deflate // Compression only since HTTP 1.1 // if (! http11) // return false; MessageBytes acceptEncodingMB = request.getMimeHeaders().getValue("accept-encoding"); if ((acceptEncodingMB == null) || (acceptEncodingMB.indexOf("gzip") == -1)) return false; MessageBytes contentEncodingMB = response.getMimeHeaders().getValue("Content-Encoding"); if ((contentEncodingMB != null) && (contentEncodingMB.indexOf("gzip") != -1)) return false; if (compressionLevel == 2) return true; if (noCompressionUserAgents != null) { MessageBytes userAgentValueMB = request.getMimeHeaders().getValue("user-agent"); if (userAgentValueMB != null) { String userAgentValue = userAgentValueMB.toString(); for (int i = 0; i < noCompressionUserAgents.length; i++) if (noCompressionUserAgents[i].matcher(userAgentValue).matches()) return false; } } long contentLength = response.getContentLengthLong(); if ((contentLength == -1) || (contentLength > compressionMinSize)) { if (compressableMimeTypes != null) { return (startsWithStringArray(compressableMimeTypes, response.getContentType())); } } return false; }	protected void commit() throws IOException { committed = true; response.setCommitted(true); if (pos > 0) { bbuf.put(buf, 0, pos); } }	protected void parseHost(MessageBytes valueMB) { if (valueMB == null || valueMB.isNull()) { // HTTP/1.0 // Default is what the socket tells us. Overriden if a host is request.setServerPort(socket.getLocalPort()); InetAddress localAddress = socket.getLocalAddress(); // Setting the socket-related fields. The adapter doesn't know request.serverName().setString(localAddress.getHostName()); return; } ByteChunk valueBC = valueMB.getByteChunk(); byte[] valueB = valueBC.getBytes(); int valueL = valueBC.getLength(); int valueS = valueBC.getStart(); int colonPos = -1; if (hostNameC.length < valueL) { hostNameC = new char[valueL]; } boolean ipv6 = (valueB[valueS] == '['); boolean bracketClosed = false; for (int i = 0; i < valueL; i++) { char b = (char) valueB[i + valueS]; hostNameC[i] = b; if (b == ']') { bracketClosed = true; } else if (b == ':') { if (!ipv6 || bracketClosed) { colonPos = i; break; } } } if (colonPos < 0) { if (sslSupport == null) { request.setServerPort(80); } else { request.setServerPort(443); } request.serverName().setChars(hostNameC, 0, valueL); } else { request.serverName().setChars(hostNameC, 0, colonPos); int port = 0; int mult = 1; for (int i = valueL - 1; i > colonPos; i--) { int charValue = HexUtils.DEC[valueB[i + valueS]]; if (charValue == -1) { error = true; response.setStatus(400); break; } port = port + (charValue * mult); mult = 10 * mult; } request.setServerPort(port); } }	protected void write(ByteChunk bc) { int length = bc.getLength(); System.arraycopy(bc.getBytes(), bc.getStart(), buf, pos, length); pos = pos + length; }	protected void write(ByteChunk bc) { int length = bc.getLength(); System.arraycopy(bc.getBytes(), bc.getStart(), buf, pos, length); pos = pos + length; }	protected void write(CharChunk cc) { int start = cc.getStart(); int end = cc.getEnd(); char[] cbuf = cc.getBuffer(); for (int i = start; i < end; i++) { char c = cbuf[i]; if ((c <= 31) && (c != 9)) { c = ' '; } else if (c == 127) { c = ' '; } buf[pos++] = (byte) c; } }	protected void write(CharChunk cc) { int start = cc.getStart(); int end = cc.getEnd(); char[] cbuf = cc.getBuffer(); for (int i = start; i < end; i++) { char c = cbuf[i]; if ((c <= 31) && (c != 9)) { c = ' '; } else if (c == 127) { c = ' '; } buf[pos++] = (byte) c; } }	protected void write(MessageBytes mb) { if (mb.getType() == MessageBytes.T_BYTES) { ByteChunk bc = mb.getByteChunk(); write(bc); } else if (mb.getType() == MessageBytes.T_CHARS) { CharChunk cc = mb.getCharChunk(); write(cc); } else { write(mb.toString()); } }	protected void write(MessageBytes mb) { if (mb.getType() == MessageBytes.T_BYTES) { ByteChunk bc = mb.getByteChunk(); write(bc); } else if (mb.getType() == MessageBytes.T_CHARS) { CharChunk cc = mb.getCharChunk(); write(cc); } else { write(mb.toString()); } }	public Locale getLocale() { return locale; }	public NioSelectorPool getSelectorPool() { return pool; }	public String getContentLanguage() { return contentLanguage; }	public boolean isWritable() { return lastWrite.get() > 0; }	@Override public boolean parseRequestLine(boolean useAvailableDataOnly) throws IOException { if (!parsingRequestLine) return true; if (parsingRequestLinePhase == 0) { byte chr = 0; do { if (pos >= lastValid) { if (useAvailableDataOnly) { return false; } if (readSocket(true, false) == 0) return false; } chr = buf[pos++]; } while ((chr == Constants.CR) || (chr == Constants.LF)); pos--; parsingRequestLineStart = pos; parsingRequestLinePhase = 1; } if (parsingRequestLinePhase == 1) { if (pos >= lastValid) { if (useAvailableDataOnly) { return false; } if (readSocket(true, false) == 0) return false; } parsingRequestLinePhase = 2; } if (parsingRequestLinePhase == 2) { // // Reading the method name // Method name is always US-ASCII boolean space = false; while (!space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) { throw new IllegalArgumentException(sm.getString("iib.invalidmethod")); } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; request.method().setBytes(buf, parsingRequestLineStart, pos - parsingRequestLineStart); } pos++; } parsingRequestLineStart = pos; parsingRequestLinePhase = 3; } if (parsingRequestLinePhase == 3) { boolean space = true; while (space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { pos++; } else { space = false; } } int end = 0; while (!space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; end = pos; } else if ((buf[pos] == Constants.CR) || (buf[pos] == Constants.LF)) { parsingRequestLineEol = true; space = true; end = pos; } else if ((buf[pos] == Constants.QUESTION) && (parsingRequestLineQPos == -1)) { parsingRequestLineQPos = pos; } pos++; } request.unparsedURI().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); if (parsingRequestLineQPos >= 0) { request.queryString().setBytes(buf, parsingRequestLineQPos + 1, end - parsingRequestLineQPos - 1); request.requestURI().setBytes(buf, parsingRequestLineStart, parsingRequestLineQPos - parsingRequestLineStart); } else { request.requestURI().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); } parsingRequestLineStart = pos; parsingRequestLinePhase = 4; } if (parsingRequestLinePhase == 4) { boolean space = true; while (space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { pos++; } else { space = false; } } end = 0; while (!parsingRequestLineEol) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.CR) { end = pos; } else if (buf[pos] == Constants.LF) { if (end == 0) end = pos; parsingRequestLineEol = true; } pos++; } if ((end - parsingRequestLineStart) > 0) { request.protocol().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); } else { request.protocol().setString(""); } parsingRequestLine = false; parsingRequestLinePhase = 0; parsingRequestLineEol = false; parsingRequestLineStart = 0; return true; } throw new IllegalStateException("Invalid request line parse phase:" + parsingRequestLinePhase); }	public int doRead(ByteChunk chunk, Request req) throws IOException { if (lastActiveFilter == -1) return inputStreamInputBuffer.doRead(chunk, req); else return activeFilters[lastActiveFilter].doRead(chunk, req); }	public int doRead(ByteChunk chunk, Request req) throws IOException { return -1; }	public int doRead(ByteChunk chunk, Request req) throws IOException { if (endOfStream) { return -1; } if (first && req.getContentLengthLong() > 0) { if (!receive()) { return 0; } } else if (empty) { if (!refillReadBuffer()) { return -1; } } ByteChunk bc = bodyBytes.getByteChunk(); chunk.setBytes(bc.getBuffer(), bc.getStart(), bc.getLength()); empty = true; return chunk.getLength(); }	public int doRead(ByteChunk chunk, Request req) throws IOException { if (endOfStream) { return -1; } if (first && req.getContentLengthLong() > 0) { if (!receive()) { return 0; } } else if (empty) { if (!refillReadBuffer()) { return -1; } } ByteChunk bc = bodyBytes.getByteChunk(); chunk.setBytes(bc.getBuffer(), bc.getStart(), bc.getLength()); empty = true; return chunk.getLength(); }	public int doWrite(ByteChunk chunk, Response res) throws IOException { if (!committed) { // Send the connector a request for commit. The connector should // then validate the headers, send them (using sendHeaders) and response.action(ActionCode.ACTION_COMMIT, null); } if (lastActiveFilter == -1) return outputStreamOutputBuffer.doWrite(chunk, res); else return activeFilters[lastActiveFilter].doWrite(chunk, res); }	protected void flushBuffer() throws IOException { if (bbuf.position() > 0) { if (Socket.sendbb(socket, 0, bbuf.position()) < 0) { throw new IOException(); } bbuf.clear(); } }	public void action(ActionCode actionCode, Object param) { if (actionCode == ActionCode.ACTION_COMMIT) { if (response.isCommitted()) return; prepareResponse(); try { outputBuffer.commit(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_ACK) { if ((response.isCommitted()) || !expectation) return; inputBuffer.setSwallowInput(true); try { outputBuffer.sendAck(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_CLIENT_FLUSH) { try { outputBuffer.flush(); } catch (IOException e) { error = true; response.setErrorException(e); } } else if (actionCode == ActionCode.ACTION_CLOSE) { // Close // End the processing of the current request, and stop any further comet = false; try { outputBuffer.endRequest(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_RESET) { // Reset response outputBuffer.reset(); } else if (actionCode == ActionCode.ACTION_CUSTOM) { // Do nothing } else if (actionCode == ActionCode.ACTION_REQ_HOST_ADDR_ATTRIBUTE) { if (remoteAddr == null && (socket != 0)) { try { long sa = Address.get(Socket.APR_REMOTE, socket); remoteAddr = Address.getip(sa); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.remoteAddr().setString(remoteAddr); } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE) { if (localName == null && (socket != 0)) { try { long sa = Address.get(Socket.APR_LOCAL, socket); localName = Address.getnameinfo(sa, 0); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.localName().setString(localName); } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) { if (remoteHost == null && (socket != 0)) { try { long sa = Address.get(Socket.APR_REMOTE, socket); remoteHost = Address.getnameinfo(sa, 0); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.remoteHost().setString(remoteHost); } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) { if (localAddr == null && (socket != 0)) { try { long sa = Address.get(Socket.APR_LOCAL, socket); localAddr = Address.getip(sa); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.localAddr().setString(localAddr); } else if (actionCode == ActionCode.ACTION_REQ_REMOTEPORT_ATTRIBUTE) { if (remotePort == -1 && (socket != 0)) { try { long sa = Address.get(Socket.APR_REMOTE, socket); Sockaddr addr = Address.getInfo(sa); remotePort = addr.port; } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.setRemotePort(remotePort); } else if (actionCode == ActionCode.ACTION_REQ_LOCALPORT_ATTRIBUTE) { if (localPort == -1 && (socket != 0)) { try { long sa = Address.get(Socket.APR_LOCAL, socket); Sockaddr addr = Address.getInfo(sa); localPort = addr.port; } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.setLocalPort(localPort); } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE) { if (ssl && (socket != 0)) { try { Object sslO = SSLSocket.getInfoS(socket, SSL.SSL_INFO_CIPHER); if (sslO != null) { request.setAttribute(AprEndpoint.CIPHER_SUITE_KEY, sslO); } // Get client certificate and the certificate chain if present int certLength = SSLSocket.getInfoI(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN); byte[] clientCert = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT); X509Certificate[] certs = null; if (clientCert != null && certLength > -1) { certs = new X509Certificate[certLength + 1]; CertificateFactory cf = CertificateFactory.getInstance("X.509"); certs[0] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(clientCert)); for (int i = 0; i < certLength; i++) { byte[] data = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i); certs[i + 1] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data)); } } if (certs != null) { request.setAttribute(AprEndpoint.CERTIFICATE_KEY, certs); } sslO = new Integer(SSLSocket.getInfoI(socket, SSL.SSL_INFO_CIPHER_USEKEYSIZE)); request.setAttribute(AprEndpoint.KEY_SIZE_KEY, sslO); sslO = SSLSocket.getInfoS(socket, SSL.SSL_INFO_SESSION_ID); if (sslO != null) { request.setAttribute(AprEndpoint.SESSION_ID_KEY, sslO); } //TODO provide a hook to enable the SSL session to be // invalidated. Set AprEndpoint.SESSION_MGR req attr } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } } else if (actionCode == ActionCode.ACTION_REQ_SSL_CERTIFICATE) { if (ssl && (socket != 0)) { // Consume and buffer the request body, so that it does not InputFilter[] inputFilters = inputBuffer.getFilters(); ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize); inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]); try { SSLSocket.setVerify(socket, SSL.SSL_CVERIFY_REQUIRE, endpoint.getSSLVerifyDepth()); if (SSLSocket.renegotiate(socket) == 0) { // Don't look for certs unless we know renegotiation worked. // Get client certificate and the certificate chain if present int certLength = SSLSocket.getInfoI(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN); byte[] clientCert = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT); X509Certificate[] certs = null; if (clientCert != null && certLength > -1) { certs = new X509Certificate[certLength + 1]; CertificateFactory cf = CertificateFactory.getInstance("X.509"); certs[0] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(clientCert)); for (int i = 0; i < certLength; i++) { byte[] data = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i); certs[i + 1] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data)); } } if (certs != null) { request.setAttribute(AprEndpoint.CERTIFICATE_KEY, certs); } } } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } } else if (actionCode == ActionCode.ACTION_REQ_SET_BODY_REPLAY) { ByteChunk body = (ByteChunk) param; InputFilter savedBody = new SavedRequestInputFilter(body); savedBody.setRequest(request); InternalAprInputBuffer internalBuffer = (InternalAprInputBuffer) request.getInputBuffer(); internalBuffer.addActiveFilter(savedBody); } else if (actionCode == ActionCode.ACTION_AVAILABLE) { request.setAvailable(inputBuffer.available()); } else if (actionCode == ActionCode.ACTION_COMET_BEGIN) { comet = true; } else if (actionCode == ActionCode.ACTION_COMET_END) { comet = false; } else if (actionCode == ActionCode.ACTION_COMET_CLOSE) { //no op } else if (actionCode == ActionCode.ACTION_COMET_SETTIMEOUT) { //no op } else if (actionCode == ActionCode.ACTION_ASYNC_START) { //TODO SERVLET3 - async } else if (actionCode == ActionCode.ACTION_ASYNC_COMPLETE) { //TODO SERVLET3 - async } else if (actionCode == ActionCode.ACTION_ASYNC_SETTIMEOUT) { //TODO SERVLET3 - async } }	public void action(ActionCode actionCode, Object param) { if (actionCode == ActionCode.ACTION_COMMIT) { if (response.isCommitted()) return; try { prepareResponse(); outputBuffer.commit(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_ACK) { if ((response.isCommitted()) || !expectation) return; inputBuffer.setSwallowInput(true); try { outputBuffer.sendAck(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_CLIENT_FLUSH) { try { outputBuffer.flush(); } catch (IOException e) { error = true; response.setErrorException(e); } } else if (actionCode == ActionCode.ACTION_CLOSE) { // Close // End the processing of the current request, and stop any further comet = false; cometClose = true; async = false; SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); if (key != null) { NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment(); if (attach != null && attach.getComet()) { //if this is a comet connection //then execute the connection closure at the next selector loop //request.getAttributes().remove("org.apache.tomcat.comet.timeout"); //attach.setTimeout(5000); //force a cleanup in 5 seconds //attach.setError(true); //this has caused concurrency errors } } try { outputBuffer.endRequest(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_RESET) { // Reset response outputBuffer.reset(); } else if (actionCode == ActionCode.ACTION_CUSTOM) { // Do nothing } else if (actionCode == ActionCode.ACTION_REQ_HOST_ADDR_ATTRIBUTE) { if ((remoteAddr == null) && (socket != null)) { InetAddress inetAddr = socket.getIOChannel().socket().getInetAddress(); if (inetAddr != null) { remoteAddr = inetAddr.getHostAddress(); } } request.remoteAddr().setString(remoteAddr); } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE) { if ((localName == null) && (socket != null)) { InetAddress inetAddr = socket.getIOChannel().socket().getLocalAddress(); if (inetAddr != null) { localName = inetAddr.getHostName(); } } request.localName().setString(localName); } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) { if ((remoteHost == null) && (socket != null)) { InetAddress inetAddr = socket.getIOChannel().socket().getInetAddress(); if (inetAddr != null) { remoteHost = inetAddr.getHostName(); } if (remoteHost == null) { if (remoteAddr != null) { remoteHost = remoteAddr; } else { request.remoteHost().recycle(); } } } request.remoteHost().setString(remoteHost); } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) { if (localAddr == null) localAddr = socket.getIOChannel().socket().getLocalAddress().getHostAddress(); request.localAddr().setString(localAddr); } else if (actionCode == ActionCode.ACTION_REQ_REMOTEPORT_ATTRIBUTE) { if ((remotePort == -1) && (socket != null)) { remotePort = socket.getIOChannel().socket().getPort(); } request.setRemotePort(remotePort); } else if (actionCode == ActionCode.ACTION_REQ_LOCALPORT_ATTRIBUTE) { if ((localPort == -1) && (socket != null)) { localPort = socket.getIOChannel().socket().getLocalPort(); } request.setLocalPort(localPort); } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE) { try { if (sslSupport != null) { Object sslO = sslSupport.getCipherSuite(); if (sslO != null) request.setAttribute(SSLSupport.CIPHER_SUITE_KEY, sslO); sslO = sslSupport.getPeerCertificateChain(false); if (sslO != null) request.setAttribute(SSLSupport.CERTIFICATE_KEY, sslO); sslO = sslSupport.getKeySize(); if (sslO != null) request.setAttribute(SSLSupport.KEY_SIZE_KEY, sslO); sslO = sslSupport.getSessionId(); if (sslO != null) request.setAttribute(SSLSupport.SESSION_ID_KEY, sslO); request.setAttribute(SSLSupport.SESSION_MGR, sslSupport); } } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } else if (actionCode == ActionCode.ACTION_REQ_SSL_CERTIFICATE) { if (sslSupport != null) { InputFilter[] inputFilters = inputBuffer.getFilters(); ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize); inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]); try { Object sslO = sslSupport.getPeerCertificateChain(true); if (sslO != null) { request.setAttribute(SSLSupport.CERTIFICATE_KEY, sslO); } } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } } else if (actionCode == ActionCode.ACTION_REQ_SET_BODY_REPLAY) { ByteChunk body = (ByteChunk) param; InputFilter savedBody = new SavedRequestInputFilter(body); savedBody.setRequest(request); InternalNioInputBuffer internalBuffer = (InternalNioInputBuffer) request.getInputBuffer(); internalBuffer.addActiveFilter(savedBody); } else if (actionCode == ActionCode.ACTION_AVAILABLE) { request.setAvailable(inputBuffer.available()); } else if (actionCode == ActionCode.ACTION_COMET_BEGIN) { comet = true; } else if (actionCode == ActionCode.ACTION_COMET_END) { comet = false; } else if (actionCode == ActionCode.ACTION_COMET_CLOSE) { if (socket == null || socket.getAttachment(false) == null) return; NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) socket.getAttachment(false); attach.setCometOps(NioEndpoint.OP_CALLBACK); RequestInfo rp = request.getRequestProcessor(); if (rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE) socket.getPoller().cometInterest(socket); } else if (actionCode == ActionCode.ACTION_COMET_SETTIMEOUT) { if (param == null) return; if (socket == null || socket.getAttachment(false) == null) return; NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) socket.getAttachment(false); long timeout = ((Long) param).longValue(); RequestInfo rp = request.getRequestProcessor(); if (rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE) attach.setTimeout(timeout); } else if (actionCode == ActionCode.ACTION_ASYNC_START) { async = true; } else if (actionCode == ActionCode.ACTION_ASYNC_COMPLETE) { AtomicBoolean dispatch = (AtomicBoolean) param; RequestInfo rp = request.getRequestProcessor(); if (rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE) { dispatch.set(true); endpoint.processSocket(this.socket, SocketStatus.STOP, true); } } else if (actionCode == ActionCode.ACTION_ASYNC_SETTIMEOUT) { if (param == null) return; if (socket == null || socket.getAttachment(false) == null) return; NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) socket.getAttachment(false); long timeout = ((Long) param).longValue(); attach.setTimeout(timeout); } else if (actionCode == ActionCode.ACTION_ASYNC_DISPATCH) { RequestInfo rp = request.getRequestProcessor(); AtomicBoolean dispatch = (AtomicBoolean) param; if (rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE) { endpoint.processSocket(this.socket, SocketStatus.OPEN, true); dispatch.set(true); } else { } } }	void action(ActionCode actionCode, Object param) { if (actionCode == ActionCode.ACTION_COMMIT) { if (response.isCommitted()) return; prepareResponse(); try { outputBuffer.commit(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_ACK) { if ((response.isCommitted()) || !expectation) return; inputBuffer.setSwallowInput(true); try { outputBuffer.sendAck(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_CLIENT_FLUSH) { try { outputBuffer.flush(); } catch (IOException e) { error = true; response.setErrorException(e); } } else if (actionCode == ActionCode.ACTION_CLOSE) { try { outputBuffer.endRequest(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_RESET) { // Reset response outputBuffer.reset(); } else if (actionCode == ActionCode.ACTION_CUSTOM) { // Do nothing } else if (actionCode == ActionCode.ACTION_START) { started = true; } else if (actionCode == ActionCode.ACTION_STOP) { started = false; } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE) { try { if (sslSupport != null) { Object sslO = sslSupport.getCipherSuite(); if (sslO != null) request.setAttribute(SSLSupport.CIPHER_SUITE_KEY, sslO); sslO = sslSupport.getPeerCertificateChain(false); if (sslO != null) request.setAttribute(SSLSupport.CERTIFICATE_KEY, sslO); sslO = sslSupport.getKeySize(); if (sslO != null) request.setAttribute(SSLSupport.KEY_SIZE_KEY, sslO); sslO = sslSupport.getSessionId(); if (sslO != null) request.setAttribute(SSLSupport.SESSION_ID_KEY, sslO); request.setAttribute(SSLSupport.SESSION_MGR, sslSupport); } } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } else if (actionCode == ActionCode.ACTION_REQ_HOST_ADDR_ATTRIBUTE) { if ((remoteAddr == null) && (socket != null)) { InetAddress inetAddr = socket.getInetAddress(); if (inetAddr != null) { remoteAddr = inetAddr.getHostAddress(); } } request.remoteAddr().setString(remoteAddr); } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE) { if ((localName == null) && (socket != null)) { InetAddress inetAddr = socket.getLocalAddress(); if (inetAddr != null) { localName = inetAddr.getHostName(); } } request.localName().setString(localName); } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) { if ((remoteHost == null) && (socket != null)) { InetAddress inetAddr = socket.getInetAddress(); if (inetAddr != null) { remoteHost = inetAddr.getHostName(); } if (remoteHost == null) { if (remoteAddr != null) { remoteHost = remoteAddr; } else { request.remoteHost().recycle(); } } } request.remoteHost().setString(remoteHost); } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) { if (localAddr == null) localAddr = socket.getLocalAddress().getHostAddress(); request.localAddr().setString(localAddr); } else if (actionCode == ActionCode.ACTION_REQ_REMOTEPORT_ATTRIBUTE) { if ((remotePort == -1) && (socket != null)) { remotePort = socket.getPort(); } request.setRemotePort(remotePort); } else if (actionCode == ActionCode.ACTION_REQ_LOCALPORT_ATTRIBUTE) { if ((localPort == -1) && (socket != null)) { localPort = socket.getLocalPort(); } request.setLocalPort(localPort); } else if (actionCode == ActionCode.ACTION_REQ_SSL_CERTIFICATE) { if (sslSupport != null) { InputFilter[] inputFilters = inputBuffer.getFilters(); ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize); inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]); try { Object sslO = sslSupport.getPeerCertificateChain(true); if (sslO != null) { request.setAttribute(SSLSupport.CERTIFICATE_KEY, sslO); } } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } } else if (actionCode == ActionCode.ACTION_REQ_SET_BODY_REPLAY) { ByteChunk body = (ByteChunk) param; InputFilter savedBody = new SavedRequestInputFilter(body); savedBody.setRequest(request); InternalInputBuffer internalBuffer = (InternalInputBuffer) request.getInputBuffer(); internalBuffer.addActiveFilter(savedBody); } else if (actionCode == ActionCode.ACTION_ASYNC_START) { //TODO SERVLET3 - async } else if (actionCode == ActionCode.ACTION_ASYNC_COMPLETE) { //TODO SERVLET3 - async } else if (actionCode == ActionCode.ACTION_ASYNC_SETTIMEOUT) { //TODO SERVLET3 - async } }	public void addActiveFilter(OutputFilter filter) { if (lastActiveFilter == -1) { filter.setBuffer(outputStreamOutputBuffer); } else { for (int i = 0; i <= lastActiveFilter; i++) { if (activeFilters[i] == filter) return; } filter.setBuffer(activeFilters[lastActiveFilter]); } activeFilters[++lastActiveFilter] = filter; filter.setResponse(response); }	public void addActiveFilter(OutputFilter filter) { if (lastActiveFilter == -1) { filter.setBuffer(outputStreamOutputBuffer); } else { for (int i = 0; i <= lastActiveFilter; i++) { if (activeFilters[i] == filter) return; } filter.setBuffer(activeFilters[lastActiveFilter]); } activeFilters[++lastActiveFilter] = filter; filter.setResponse(response); }	public void addCompressableMimeType(String mimeType) { compressableMimeTypes = addStringArray(compressableMimeTypes, mimeType); }	public void addCompressableMimeType(String mimeType) { compressableMimeTypes = addStringArray(compressableMimeTypes, mimeType); }	public void endHeaders() { buf[pos++] = Constants.CR; buf[pos++] = Constants.LF; }	public void endHeaders() { buf[pos++] = Constants.CR; buf[pos++] = Constants.LF; }	public void endRequest() throws IOException { if (swallowInput && (lastActiveFilter != -1)) { int extraBytes = (int) activeFilters[lastActiveFilter].end(); pos = pos - extraBytes; } }	public void endRequest() throws IOException { if (!committed) { // Send the connector a request for commit. The connector should // then validate the headers, send them (using sendHeader) and response.action(ActionCode.ACTION_COMMIT, null); } if (finished) return; if (lastActiveFilter != -1) activeFilters[lastActiveFilter].end(); flushBuffer(); finished = true; }	@Override public void endRequest() throws IOException { super.endRequest(); if (useSocketBuffer) { socketBuffer.flushBuffer(); } }	public void nextRequest() { request.recycle(); if (lastValid - pos > 0) { int npos = 0; int opos = pos; while (lastValid - opos > opos - npos) { System.arraycopy(buf, opos, buf, npos, opos - npos); npos += pos; opos += pos; } System.arraycopy(buf, opos, buf, npos, lastValid - opos); } for (int i = 0; i <= lastActiveFilter; i++) { activeFilters[i].recycle(); } lastValid = lastValid - pos; pos = 0; lastActiveFilter = -1; parsingHeader = true; swallowInput = true; }	public void nextRequest() { response.recycle(); for (int i = 0; i <= lastActiveFilter; i++) { activeFilters[i].recycle(); } pos = 0; lastActiveFilter = -1; committed = false; finished = false; }	public void nextRequest() { request.recycle(); if (lastValid - pos > 0) { int npos = 0; int opos = pos; while (lastValid - opos > opos - npos) { System.arraycopy(buf, opos, buf, npos, opos - npos); npos += pos; opos += pos; } System.arraycopy(buf, opos, buf, npos, lastValid - opos); } for (int i = 0; i <= lastActiveFilter; i++) { activeFilters[i].recycle(); } lastValid = lastValid - pos; pos = 0; lastActiveFilter = -1; parsingHeader = true; swallowInput = true; }	public void nextRequest() { response.recycle(); for (int i = 0; i <= lastActiveFilter; i++) { activeFilters[i].recycle(); } pos = 0; lastActiveFilter = -1; committed = false; finished = false; }	@Override public void nextRequest() { super.nextRequest(); parsingHeader = true; headerParsePos = HeaderParsePosition.HEADER_START; parsingRequestLine = true; parsingRequestLinePhase = 0; parsingRequestLineEol = false; parsingRequestLineStart = 0; parsingRequestLineQPos = -1; headerData.recycle(); }	public void parseHost(MessageBytes valueMB) { if (valueMB == null || valueMB.isNull()) { // HTTP/1.0 // Default is what the socket tells us. Overriden if a host is request.setServerPort(endpoint.getPort()); return; } ByteChunk valueBC = valueMB.getByteChunk(); byte[] valueB = valueBC.getBytes(); int valueL = valueBC.getLength(); int valueS = valueBC.getStart(); int colonPos = -1; if (hostNameC.length < valueL) { hostNameC = new char[valueL]; } boolean ipv6 = (valueB[valueS] == '['); boolean bracketClosed = false; for (int i = 0; i < valueL; i++) { char b = (char) valueB[i + valueS]; hostNameC[i] = b; if (b == ']') { bracketClosed = true; } else if (b == ':') { if (!ipv6 || bracketClosed) { colonPos = i; break; } } } if (colonPos < 0) { if (!ssl) { request.setServerPort(80); } else { request.setServerPort(443); } request.serverName().setChars(hostNameC, 0, valueL); } else { request.serverName().setChars(hostNameC, 0, colonPos); int port = 0; int mult = 1; for (int i = valueL - 1; i > colonPos; i--) { int charValue = HexUtils.DEC[valueB[i + valueS]]; if (charValue == -1) { error = true; response.setStatus(400); break; } port = port + (charValue * mult); mult = 10 * mult; } request.setServerPort(port); } }	public void parseHost(MessageBytes valueMB) { if (valueMB == null || valueMB.isNull()) { // HTTP/1.0 // Default is what the socket tells us. Overriden if a host is request.setServerPort(endpoint.getPort()); return; } ByteChunk valueBC = valueMB.getByteChunk(); byte[] valueB = valueBC.getBytes(); int valueL = valueBC.getLength(); int valueS = valueBC.getStart(); int colonPos = -1; if (hostNameC.length < valueL) { hostNameC = new char[valueL]; } boolean ipv6 = (valueB[valueS] == '['); boolean bracketClosed = false; for (int i = 0; i < valueL; i++) { char b = (char) valueB[i + valueS]; hostNameC[i] = b; if (b == ']') { bracketClosed = true; } else if (b == ':') { if (!ipv6 || bracketClosed) { colonPos = i; break; } } } if (colonPos < 0) { if (!ssl) { request.setServerPort(80); } else { request.setServerPort(443); } request.serverName().setChars(hostNameC, 0, valueL); } else { request.serverName().setChars(hostNameC, 0, colonPos); int port = 0; int mult = 1; for (int i = valueL - 1; i > colonPos; i--) { int charValue = HexUtils.DEC[valueB[i + valueS]]; if (charValue == -1) { error = true; response.setStatus(400); break; } port = port + (charValue * mult); mult = 10 * mult; } request.setServerPort(port); } }	@Override public void recycle() { super.recycle(); socket.getBufHandler().getWriteBuffer().clear(); socket = null; lastWrite.set(1); }	@Override public void sendAck() throws IOException { if (!committed) outputStream.write(Constants.ACK_BYTES); }	public void setCompressableMimeTypes(String[] compressableMimeTypes) { this.compressableMimeTypes = compressableMimeTypes; }	public void setGlobalProcessor(RequestGroupInfo global) { if (global != null) { this.global = global; global.addRequestProcessor(this); } else { if (this.global != null) { this.global.removeRequestProcessor(this); this.global = null; } } }	public void setNoCompressionUserAgents(String noCompressionUserAgents) { if (noCompressionUserAgents != null) { StringTokenizer st = new StringTokenizer(noCompressionUserAgents, ","); while (st.hasMoreTokens()) { addNoCompressionUserAgent(st.nextToken().trim()); } } }	public void setNoCompressionUserAgents(String noCompressionUserAgents) { if (noCompressionUserAgents != null) { StringTokenizer st = new StringTokenizer(noCompressionUserAgents, ","); while (st.hasMoreTokens()) { addNoCompressionUserAgent(st.nextToken().trim()); } } }	public void write(byte[] b) { System.arraycopy(b, 0, buf, pos, b.length); pos = pos + b.length; }	public void write(byte[] b) { System.arraycopy(b, 0, buf, pos, b.length); pos = pos + b.length; }
final boolean load(int offset, boolean changeEntity) throws IOException { int length = fCurrentEntity.mayReadChunks ? (fCurrentEntity.ch.length - offset) : (DEFAULT_XMLDECL_BUFFER_SIZE); int count = fCurrentEntity.reader.read(fCurrentEntity.ch, offset, length); boolean entityChanged = false; if (count != -1) { if (count != 0) { fCurrentEntity.count = count + offset; fCurrentEntity.position = offset; } } else { fCurrentEntity.count = offset; fCurrentEntity.position = offset; entityChanged = true; if (changeEntity) { endEntity(); if (fCurrentEntity == null) { throw new EOFException(); } if (fCurrentEntity.position == fCurrentEntity.count) { load(0, false); } } } return entityChanged; }	private String getExpressionFactoryVar() { return VAR_EXPRESSIONFACTORY; }	private TagInfo createTagInfo(TreeNode elem, String jspVersion) throws JasperException { String tagName = null; String tagClassName = null; String teiClassName = null; String bodycontent = "JSP"; String info = null; String displayName = null; String smallIcon = null; String largeIcon = null; boolean dynamicAttributes = false; Vector<TagAttributeInfo> attributeVector = new Vector<TagAttributeInfo>(); Vector<TagVariableInfo> variableVector = new Vector<TagVariableInfo>(); Iterator<TreeNode> list = elem.findChildren(); while (list.hasNext()) { TreeNode element = list.next(); String tname = element.getName(); if ("name".equals(tname)) { tagName = element.getBody(); } else if ("tagclass".equals(tname) || "tag-class".equals(tname)) { tagClassName = element.getBody(); } else if ("teiclass".equals(tname) || "tei-class".equals(tname)) { teiClassName = element.getBody(); } else if ("bodycontent".equals(tname) || "body-content".equals(tname)) { bodycontent = element.getBody(); } else if ("display-name".equals(tname)) { displayName = element.getBody(); } else if ("small-icon".equals(tname)) { smallIcon = element.getBody(); } else if ("large-icon".equals(tname)) { largeIcon = element.getBody(); } else if ("icon".equals(tname)) { TreeNode icon = element.findChild("small-icon"); if (icon != null) { smallIcon = icon.getBody(); } icon = element.findChild("large-icon"); if (icon != null) { largeIcon = icon.getBody(); } } else if ("info".equals(tname) || "description".equals(tname)) { info = element.getBody(); } else if ("variable".equals(tname)) { variableVector.addElement(createVariable(element)); } else if ("attribute".equals(tname)) { attributeVector.addElement(createAttribute(element, jspVersion)); } else if ("dynamic-attributes".equals(tname)) { dynamicAttributes = JspUtil.booleanValue(element.getBody()); } else if ("example".equals(tname)) { // Ignored elements } else if ("tag-extension".equals(tname)) { // Ignored } else { if (log.isWarnEnabled()) { log.warn(Localizer.getMessage("jsp.warning.unknown.element.in.tag", tname)); } } } TagExtraInfo tei = null; if (teiClassName != null && !teiClassName.equals("")) { try { Class<?> teiClass = ctxt.getClassLoader().loadClass(teiClassName); tei = (TagExtraInfo) teiClass.newInstance(); } catch (Exception e) { err.jspError("jsp.error.teiclass.instantiation", teiClassName, e); } } TagAttributeInfo[] tagAttributeInfo = new TagAttributeInfo[attributeVector.size()]; attributeVector.copyInto(tagAttributeInfo); TagVariableInfo[] tagVariableInfos = new TagVariableInfo[variableVector.size()]; variableVector.copyInto(tagVariableInfos); TagInfo taginfo = new TagInfo(tagName, tagClassName, bodycontent, info, this, tei, tagAttributeInfo, displayName, smallIcon, largeIcon, tagVariableInfos, dynamicAttributes); return taginfo; }	private boolean popFile() throws JasperException { if (current == null || currFileId < 0) { return false; } String fName = getFile(currFileId); currFileId = unregisterSourceFile(fName); if (currFileId < -1) { err.jspError("jsp.error.file.not.registered", fName); } Mark previous = current.popStream(); if (previous != null) { master = current.baseDir; current = previous; return true; } return false; }	private int registerSourceFile(final String file) { if (sourceFiles.contains(file)) { return -1; } sourceFiles.add(file); this.size++; return sourceFiles.size() - 1; }	private void addToParent(Node parent) { if (parent != null) { this.parent = parent; Nodes parentBody = parent.getBody(); if (parentBody == null) { parentBody = new Nodes(); parent.setBody(parentBody); } parentBody.add(this); } }	private void checkUniqueName(String name, String type, Node n, TagAttributeInfo attr) throws JasperException { HashMap<String, NameEntry> table = (type == VAR_NAME_FROM) ? nameFromTable : nameTable; NameEntry nameEntry = table.get(name); if (nameEntry != null) { if (type != TAG_DYNAMIC || nameEntry.getType() != TAG_DYNAMIC) { int line = nameEntry.getNode().getStart().getLineNumber(); err.jspError(n, "jsp.error.tagfile.nameNotUnique", type, nameEntry.getType(), Integer.toString(line)); } } else { table.put(name, new NameEntry(type, n, attr)); } }	private void checkXmlAttributes(Node.CustomTag n, Node.JspAttribute[] jspAttrs, Hashtable<String, Object> tagDataAttrs) throws JasperException { TagInfo tagInfo = n.getTagInfo(); if (tagInfo == null) { err.jspError(n, "jsp.error.missing.tagInfo", n.getQName()); } TagAttributeInfo[] tldAttrs = tagInfo.getAttributes(); Attributes attrs = n.getAttributes(); boolean checkDeferred = !pageInfo.isDeferredSyntaxAllowedAsLiteral() && !(tagInfo.getTagLibrary().getRequiredVersion().equals("2.0") || tagInfo.getTagLibrary().getRequiredVersion().equals("1.2")); for (int i = 0; attrs != null && i < attrs.getLength(); i++) { boolean found = false; boolean runtimeExpression = ((n.getRoot().isXmlSyntax() && attrs.getValue(i).startsWith("%=")) || (!n.getRoot().isXmlSyntax() && attrs.getValue(i).startsWith("<%="))); boolean elExpression = false; boolean deferred = false; boolean deferredValueIsLiteral = false; ELNode.Nodes el = null; if (!runtimeExpression) { el = ELParser.parse(attrs.getValue(i)); Iterator<ELNode> nodes = el.iterator(); while (nodes.hasNext()) { ELNode node = nodes.next(); if (node instanceof ELNode.Root) { if (((ELNode.Root) node).getType() == '$') { elExpression = true; } else if (checkDeferred && ((ELNode.Root) node).getType() == '#') { elExpression = true; deferred = true; if (pageInfo.isELIgnored()) { deferredValueIsLiteral = true; } } } } } boolean expression = runtimeExpression || (elExpression && (!pageInfo.isELIgnored() || (!"true".equalsIgnoreCase(pageInfo.getIsELIgnored()) && checkDeferred && deferred))); for (int j = 0; tldAttrs != null && j < tldAttrs.length; j++) { if (attrs.getLocalName(i).equals(tldAttrs[j].getName()) && (attrs.getURI(i) == null || attrs.getURI(i).length() == 0 || attrs.getURI(i).equals(n.getURI()))) { if (tldAttrs[j].canBeRequestTime() || tldAttrs[j].isDeferredMethod() || tldAttrs[j].isDeferredValue()) { if (!expression) { if (deferredValueIsLiteral && !pageInfo.isDeferredSyntaxAllowedAsLiteral()) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } String expectedType = null; if (tldAttrs[j].isDeferredMethod()) { // The String literal must be castable to what is declared as type String m = tldAttrs[j].getMethodSignature(); if (m != null) { int rti = m.trim().indexOf(' '); if (rti > 0) { expectedType = m.substring(0, rti).trim(); } } else { expectedType = "java.lang.Object"; } } if (tldAttrs[j].isDeferredValue()) { // The String litteral must be castable to what is declared as type expectedType = tldAttrs[j].getExpectedTypeName(); } if (expectedType != null) { Class<?> expectedClass = String.class; try { expectedClass = JspUtil.toClass(expectedType, loader); } catch (ClassNotFoundException e) { err.jspError(n, "jsp.error.unknown_attribute_type", tldAttrs[j].getName(), expectedType); } try { ELSupport.checkType(attrs.getValue(i), expectedClass); } catch (Exception e) { err.jspError(n, "jsp.error.coerce_to_type", tldAttrs[j].getName(), expectedType, attrs.getValue(i)); } } jspAttrs[i] = new Node.JspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), false, null, false); } else { if (deferred && !tldAttrs[j].isDeferredMethod() && !tldAttrs[j].isDeferredValue()) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } if (!deferred && !tldAttrs[j].canBeRequestTime()) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } if (elExpression) { validateFunctions(el, n); jspAttrs[i] = new Node.JspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), false, el, false); ELContextImpl ctx = new ELContextImpl(); ctx.setFunctionMapper(getFunctionMapper(el)); try { jspAttrs[i].validateEL(this.pageInfo.getExpressionFactory(), ctx); } catch (ELException e) { this.err.jspError(n.getStart(), "jsp.error.invalid.expression", attrs.getValue(i), e.toString()); } } else { jspAttrs[i] = getJspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), n, false); } } } else { if (expression) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } jspAttrs[i] = new Node.JspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), false, null, false); } if (expression) { tagDataAttrs.put(attrs.getQName(i), TagData.REQUEST_TIME_VALUE); } else { tagDataAttrs.put(attrs.getQName(i), attrs.getValue(i)); } found = true; break; } } if (!found) { if (tagInfo.hasDynamicAttributes()) { jspAttrs[i] = getJspAttribute(null, attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), n, true); } else { err.jspError(n, "jsp.error.bad_attribute", attrs.getQName(i), n.getLocalName()); } } } }	private void genPreambleImports() { Iterator<String> iter = pageInfo.getImports().iterator(); while (iter.hasNext()) { out.printin("import "); out.print(iter.next()); out.println(";"); } out.println(); }	protected void locateUriRoot(File f) { String tUriBase = uriBase; if (tUriBase == null) { tUriBase = "/"; } try { if (f.exists()) { f = new File(f.getAbsolutePath()); while (f != null) { File g = new File(f, "WEB-INF"); if (g.exists() && g.isDirectory()) { uriRoot = f.getCanonicalPath(); uriBase = tUriBase; if (log.isInfoEnabled()) { log.info(Localizer.getMessage("jspc.implicit.uriRoot", uriRoot)); } break; } if (f.exists() && f.isDirectory()) { tUriBase = "/" + f.getName() + "/" + tUriBase; } String fParent = f.getParent(); if (fParent == null) { break; } else { f = new File(fParent); } // If there is no acceptible candidate, uriRoot will // remain null to indicate to the CompilerContext to // use the current working/user dir. } if (uriRoot != null) { File froot = new File(uriRoot); uriRoot = froot.getCanonicalPath(); } } } catch (IOException ioe) { // since this is an optional default and a null value // for uriRoot has a non-error meaning, we can just // pass straight through } }	protected static void doSetParentLogger(final Logger logger, final Logger parent) { AccessController.doPrivileged(new PrivilegedAction<Object>() { public Object run() { logger.setParent(parent); return null; } }); }	public PermissionCollection getPermissionCollection() { return permissionCollection; }	public java.io.InputStream getResourceAsStream(String res) { return context.getResourceAsStream(canonicalURI(res)); }	public boolean getClassDebugInfo() { return classDebugInfo; }	public boolean getDevelopment() { return development; }	public boolean getDevelopment() { return false; }	public boolean getFailOnError() { return failOnError; }	public boolean isAllSpace() { boolean isAllSpace = true; for (int i = 0; i < text.length(); i++) { if (!Character.isWhitespace(text.charAt(i))) { isAllSpace = false; break; } } return isAllSpace; }	public boolean isOutDated() { return isOutDated(true); }	public final void fatal(Object message, Throwable t) { log(Level.SEVERE, String.valueOf(message), t); }	public int getJspCount() { return jsps.size(); }	public int getJspReloadCount() { return this.rctxt.getJspReloadCount(); }	@Override public int read(char[] ch, int offset, int length) throws IOException { int out = offset; if (fSurrogate != -1) { ch[offset + 1] = (char) fSurrogate; fSurrogate = -1; length--; out++; } int count = 0; if (fOffset == 0) { if (length > fBuffer.length) { length = fBuffer.length; } count = fInputStream.read(fBuffer, 0, length); if (count == -1) { return -1; } count += out - offset; } else // skip read; last character was in error // NOTE: Having an offset value other than zero means that there was // an error in the last character read. In this case, we have // skipped the read so we don't consume any bytes past the // error. By signalling the error on the next block read we // allow the method to return the most valid characters that { count = fOffset; fOffset = 0; } final int total = count; for (int in = 0; in < total; in++) { int b0 = fBuffer[in] & 0x00FF; if (b0 < 0x80) { ch[out++] = (char) b0; continue; } if ((b0 & 0xE0) == 0xC0) { int b1 = -1; if (++in < total) { b1 = fBuffer[in] & 0x00FF; } else { b1 = fInputStream.read(); if (b1 == -1) { if (out > offset) { fBuffer[0] = (byte) b0; fOffset = 1; return out - offset; } expectedByte(2, 2); } count++; } if ((b1 & 0xC0) != 0x80) { if (out > offset) { fBuffer[0] = (byte) b0; fBuffer[1] = (byte) b1; fOffset = 2; return out - offset; } invalidByte(2, 2); } int c = ((b0 << 6) & 0x07C0) | (b1 & 0x003F); ch[out++] = (char) c; count -= 1; continue; } if ((b0 & 0xF0) == 0xE0) { int b1 = -1; if (++in < total) { b1 = fBuffer[in] & 0x00FF; } else { b1 = fInputStream.read(); if (b1 == -1) { if (out > offset) { fBuffer[0] = (byte) b0; fOffset = 1; return out - offset; } expectedByte(2, 3); } count++; } if ((b1 & 0xC0) != 0x80) { if (out > offset) { fBuffer[0] = (byte) b0; fBuffer[1] = (byte) b1; fOffset = 2; return out - offset; } invalidByte(2, 3); } int b2 = -1; if (++in < total) { b2 = fBuffer[in] & 0x00FF; } else { b2 = fInputStream.read(); if (b2 == -1) { if (out > offset) { fBuffer[0] = (byte) b0; fBuffer[1] = (byte) b1; fOffset = 2; return out - offset; } expectedByte(3, 3); } count++; } if ((b2 & 0xC0) != 0x80) { if (out > offset) { fBuffer[0] = (byte) b0; fBuffer[1] = (byte) b1; fBuffer[2] = (byte) b2; fOffset = 3; return out - offset; } invalidByte(3, 3); } int c = ((b0 << 12) & 0xF000) | ((b1 << 6) & 0x0FC0) | (b2 & 0x003F); ch[out++] = (char) c; count -= 2; continue; } if ((b0 & 0xF8) == 0xF0) { int b1 = -1; if (++in < total) { b1 = fBuffer[in] & 0x00FF; } else { b1 = fInputStream.read(); if (b1 == -1) { if (out > offset) { fBuffer[0] = (byte) b0; fOffset = 1; return out - offset; } expectedByte(2, 4); } count++; } if ((b1 & 0xC0) != 0x80) { if (out > offset) { fBuffer[0] = (byte) b0; fBuffer[1] = (byte) b1; fOffset = 2; return out - offset; } invalidByte(2, 4); } int b2 = -1; if (++in < total) { b2 = fBuffer[in] & 0x00FF; } else { b2 = fInputStream.read(); if (b2 == -1) { if (out > offset) { fBuffer[0] = (byte) b0; fBuffer[1] = (byte) b1; fOffset = 2; return out - offset; } expectedByte(3, 4); } count++; } if ((b2 & 0xC0) != 0x80) { if (out > offset) { fBuffer[0] = (byte) b0; fBuffer[1] = (byte) b1; fBuffer[2] = (byte) b2; fOffset = 3; return out - offset; } invalidByte(3, 4); } int b3 = -1; if (++in < total) { b3 = fBuffer[in] & 0x00FF; } else { b3 = fInputStream.read(); if (b3 == -1) { if (out > offset) { fBuffer[0] = (byte) b0; fBuffer[1] = (byte) b1; fBuffer[2] = (byte) b2; fOffset = 3; return out - offset; } expectedByte(4, 4); } count++; } if ((b3 & 0xC0) != 0x80) { if (out > offset) { fBuffer[0] = (byte) b0; fBuffer[1] = (byte) b1; fBuffer[2] = (byte) b2; fBuffer[3] = (byte) b3; fOffset = 4; return out - offset; } invalidByte(4, 4); } int uuuuu = ((b0 << 2) & 0x001C) | ((b1 >> 4) & 0x0003); if (uuuuu > 0x10) { invalidSurrogate(uuuuu); } int wwww = uuuuu - 1; int zzzz = b1 & 0x000F; int yyyyyy = b2 & 0x003F; int xxxxxx = b3 & 0x003F; int hs = 0xD800 | ((wwww << 6) & 0x03C0) | (zzzz << 2) | (yyyyyy >> 4); int ls = 0xDC00 | ((yyyyyy << 6) & 0x03C0) | xxxxxx; ch[out++] = (char) hs; ch[out++] = (char) ls; count -= 2; continue; } if (out > offset) { fBuffer[0] = (byte) b0; fOffset = 1; return out - offset; } invalidByte(1, 1); } if (DEBUG_READ) { if (log.isDebugEnabled()) log.debug("read(char[]," + offset + ',' + length + "): count=" + count); } return count; }	public static String toJavaSourceType(String type) { if (type.charAt(0) != '[') { return type; } int dims = 1; String t = null; for (int i = 1; i < type.length(); i++) { if (type.charAt(i) == '[') { dims++; } else { switch(type.charAt(i)) { case 'Z': t = "boolean"; break; case 'B': t = "byte"; break; case 'C': t = "char"; break; case 'D': t = "double"; break; case 'F': t = "float"; break; case 'I': t = "int"; break; case 'J': t = "long"; break; case 'S': t = "short"; break; case 'L': t = type.substring(i + 1, type.indexOf(';')); break; } break; } } StringBuilder resultType = new StringBuilder(t); for (; dims > 0; dims--) { resultType.append("[]"); } return resultType.toString(); }	private Class<?> loadTagFile(Compiler compiler, String tagFilePath, TagInfo tagInfo, PageInfo parentPageInfo) throws JasperException { URL tagFileJarUrl = null; if (tagFilePath.startsWith("/META-INF/")) { try { tagFileJarUrl = new URL("jar:" + compiler.getCompilationContext().getTldLocation(tagInfo.getTagLibrary().getURI())[0] + "!/"); } catch (MalformedURLException e) { // Ignore - tagFileJarUrl will be null } } String tagFileJarPath; if (tagFileJarUrl == null) { tagFileJarPath = ""; } else { tagFileJarPath = tagFileJarUrl.toString(); } JspCompilationContext ctxt = compiler.getCompilationContext(); JspRuntimeContext rctxt = ctxt.getRuntimeContext(); String wrapperUri = tagFileJarPath + tagFilePath; JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri); synchronized (rctxt) { if (wrapper == null) { wrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), tagFileJarUrl); rctxt.addWrapper(wrapperUri, wrapper); wrapper.getJspEngineContext().setClassLoader(ctxt.getClassLoader()); wrapper.getJspEngineContext().setClassPath(ctxt.getClassPath()); } else { // Make sure that JspCompilationContext gets the latest TagInfo // for the tag file. TagInfo instance was created the last // time the tag file was scanned for directives, and the tag wrapper.getJspEngineContext().setTagInfo(tagInfo); } Class<?> tagClazz; int tripCount = wrapper.incTripCount(); try { if (tripCount > 0) { // When tripCount is greater than zero, a circular // dependency exists. The circularily dependant tag // file is compiled in prototype mode, to avoid infinite JspServletWrapper tempWrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), ctxt.getTagFileJarUrl(tagFilePath)); tagClazz = tempWrapper.loadTagFilePrototype(); tempVector.add(tempWrapper.getJspEngineContext().getCompiler()); } else { tagClazz = wrapper.loadTagFile(); } } finally { wrapper.decTripCount(); } try { Object tagIns = tagClazz.newInstance(); if (tagIns instanceof JspSourceDependent) { Iterator<String> iter = ((JspSourceDependent) tagIns).getDependants().iterator(); while (iter.hasNext()) { parentPageInfo.addDependant(iter.next()); } } } catch (Exception e) { // ignore errors } return tagClazz; } }	public static void releaseAll() { singleton.release(); }	public ArrayList<Integer> getExtraSmap() { return extraSmap; }	@Override public void clear() throws IOException { if (writer != null) { throw new IOException(); } else { nextChar = 0; if (LIMIT_BUFFER && (cb.length > Constants.DEFAULT_TAG_BUFFER_SIZE)) { bufferSize = Constants.DEFAULT_TAG_BUFFER_SIZE; cb = new char[bufferSize]; } } }	public void doTag(TagPluginContext ctxt) { boolean hasContext, hasVar, hasScope, hasVarReader, hasCharEncoding; hasContext = ctxt.isAttributeSpecified("context"); hasVar = ctxt.isAttributeSpecified("var"); hasScope = ctxt.isAttributeSpecified("scope"); hasVarReader = ctxt.isAttributeSpecified("varReader"); hasCharEncoding = ctxt.isAttributeSpecified("charEncoding"); String urlName = ctxt.getTemporaryVariableName(); String contextName = ctxt.getTemporaryVariableName(); String iauName = ctxt.getTemporaryVariableName(); String urlObjName = ctxt.getTemporaryVariableName(); String ucName = ctxt.getTemporaryVariableName(); String inputStreamName = ctxt.getTemporaryVariableName(); String tempReaderName = ctxt.getTemporaryVariableName(); String tempReaderName2 = ctxt.getTemporaryVariableName(); String charSetName = ctxt.getTemporaryVariableName(); String charEncodingName = ctxt.getTemporaryVariableName(); String contentTypeName = ctxt.getTemporaryVariableName(); String varReaderName = ctxt.getTemporaryVariableName(); String servletContextName = ctxt.getTemporaryVariableName(); String servletPathName = ctxt.getTemporaryVariableName(); String requestDispatcherName = ctxt.getTemporaryVariableName(); String irwName = ctxt.getTemporaryVariableName(); String brName = ctxt.getTemporaryVariableName(); String sbName = ctxt.getTemporaryVariableName(); String tempStringName = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource("boolean " + iauName + ";"); ctxt.generateJavaSource("String " + urlName + " = "); ctxt.generateAttribute("url"); ctxt.generateJavaSource(";"); ctxt.generateJavaSource("if(" + urlName + " == null || " + urlName + ".equals(\"\")){"); ctxt.generateJavaSource(" throw new JspTagException(\"The \\\"url\\\" attribute " + "illegally evaluated to \\\"null\\\" or \\\"\\\" in &lt;import&gt;\");"); ctxt.generateJavaSource("}"); ctxt.generateJavaSource(iauName + " = " + "org.apache.jasper.tagplugins.jstl.Util.isAbsoluteUrl(" + urlName + ");"); if (hasContext) { ctxt.generateJavaSource("String " + contextName + " = "); ctxt.generateAttribute("context"); ctxt.generateJavaSource(";"); ctxt.generateJavaSource("if((!" + contextName + ".startsWith(\"/\")) " + "|| (!" + urlName + ".startsWith(\"/\"))){"); ctxt.generateJavaSource(" throw new JspTagException" + "(\"In URL tags, when the \\\"context\\\" attribute is specified, " + "values of both \\\"context\\\" and \\\"url\\\" must start with \\\"/\\\".\");"); ctxt.generateJavaSource("}"); } ctxt.generateJavaSource("String " + charSetName + " = null;"); if (hasCharEncoding) { ctxt.generateJavaSource("String " + charEncodingName + " = "); ctxt.generateAttribute("charEncoding"); ctxt.generateJavaSource(";"); ctxt.generateJavaSource("if(null != " + charEncodingName + " " + "&& !" + charEncodingName + ".equals(\"\")){"); ctxt.generateJavaSource(" " + charSetName + " = " + charEncodingName + ";"); ctxt.generateJavaSource("}"); } ctxt.generateJavaSource("if(!" + iauName + "){"); ctxt.generateJavaSource(" if(!" + urlName + ".startsWith(\"/\")){"); ctxt.generateJavaSource(" String " + servletPathName + " = " + "((HttpServletRequest)pageContext.getRequest()).getServletPath();"); ctxt.generateJavaSource(" " + urlName + " = " + servletPathName + ".substring(0," + servletPathName + ".lastIndexOf('/')) + '/' + " + urlName + ";"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource("}"); if (hasVarReader) { ctxt.generateJavaSource("String " + varReaderName + " = "); ctxt.generateAttribute("varReader"); ctxt.generateJavaSource(";"); ctxt.generateJavaSource("if(" + iauName + "){"); ctxt.generateJavaSource(" java.net.URL " + urlObjName + " = new java.net.URL(" + urlName + ");"); ctxt.generateJavaSource(" java.net.URLConnection " + ucName + " = " + urlObjName + ".openConnection();"); ctxt.generateJavaSource(" java.io.InputStream " + inputStreamName + " = " + ucName + ".getInputStream();"); ctxt.generateJavaSource(" if(" + charSetName + " == null){"); ctxt.generateJavaSource(" String " + contentTypeName + " = " + ucName + ".getContentType();"); ctxt.generateJavaSource(" if(null != " + contentTypeName + "){"); ctxt.generateJavaSource(" " + charSetName + " = " + "org.apache.jasper.tagplugins.jstl.Util.getContentTypeAttribute(" + contentTypeName + ", \"charset\");"); ctxt.generateJavaSource(" if(" + charSetName + " == null) " + charSetName + " = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;"); ctxt.generateJavaSource(" }else{"); ctxt.generateJavaSource(" " + charSetName + " = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" }"); if (!hasCharEncoding) { ctxt.generateJavaSource(" String " + contentTypeName + " = " + ucName + ".getContentType();"); } ctxt.generateJavaSource(" java.io.Reader " + tempReaderName + " = null;"); ctxt.generateJavaSource(" try{"); ctxt.generateJavaSource(" " + tempReaderName + " = new java.io.InputStreamReader(" + inputStreamName + ", " + charSetName + ");"); ctxt.generateJavaSource(" }catch(Exception ex){"); ctxt.generateJavaSource(" " + tempReaderName + " = new java.io.InputStreamReader(" + inputStreamName + ", org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING);"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" if(" + ucName + " instanceof java.net.HttpURLConnection){"); ctxt.generateJavaSource(" int status = ((java.net.HttpURLConnection) " + ucName + ").getResponseCode();"); ctxt.generateJavaSource(" if(status < 200 || status > 299){"); ctxt.generateJavaSource(" throw new JspTagException(status + \" \" + " + urlName + ");"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" pageContext.setAttribute(" + varReaderName + ", " + tempReaderName + ");"); ctxt.generateJavaSource("}else{"); ctxt.generateJavaSource(" if (!(pageContext.getRequest() instanceof HttpServletRequest " + "&& pageContext.getResponse() instanceof HttpServletResponse)){"); ctxt.generateJavaSource(" throw new JspTagException(\"Relative &lt;import&gt; from non-HTTP request not allowed\");"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" ServletContext " + servletContextName + " = null;"); if (hasContext) { ctxt.generateJavaSource(" if(null != " + contextName + "){"); ctxt.generateJavaSource(" " + servletContextName + " = pageContext.getServletContext().getContext(" + contextName + ");"); ctxt.generateJavaSource(" }else{"); ctxt.generateJavaSource(" " + servletContextName + " = pageContext.getServletContext();"); ctxt.generateJavaSource(" }"); } else { ctxt.generateJavaSource(" " + servletContextName + " = pageContext.getServletContext();"); } ctxt.generateJavaSource(" if(" + servletContextName + " == null){"); if (hasContext) { ctxt.generateJavaSource(" throw new JspTagException(\"Unable to get RequestDispatcher for Context: \\\" \"+" + contextName + "+\" \\\" and URL: \\\" \" +" + urlName + "+ \" \\\". Verify values and/or enable cross context access.\");"); } else { ctxt.generateJavaSource(" throw new JspTagException(\"Unable to get RequestDispatcher for URL: \\\" \" +" + urlName + "+ \" \\\". Verify values and/or enable cross context access.\");"); } ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" RequestDispatcher " + requestDispatcherName + " = " + servletContextName + ".getRequestDispatcher(org.apache.jasper.tagplugins.jstl.Util.stripSession(" + urlName + "));"); ctxt.generateJavaSource(" if(" + requestDispatcherName + " == null) throw new JspTagException(org.apache.jasper.tagplugins.jstl.Util.stripSession(" + urlName + "));"); ctxt.generateJavaSource(" org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper " + irwName + " = new org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper((HttpServletResponse) pageContext.getResponse());"); ctxt.generateJavaSource(" if(" + charSetName + " == null){"); ctxt.generateJavaSource(" " + charSetName + " = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" " + irwName + ".setCharEncoding(" + charSetName + ");"); ctxt.generateJavaSource(" try{"); ctxt.generateJavaSource(" " + requestDispatcherName + ".include(pageContext.getRequest(), " + irwName + ");"); ctxt.generateJavaSource(" }catch(java.io.IOException ex){"); ctxt.generateJavaSource(" throw new JspException(ex);"); ctxt.generateJavaSource(" }catch(RuntimeException ex){"); ctxt.generateJavaSource(" throw new JspException(ex);"); ctxt.generateJavaSource(" }catch(ServletException ex){"); ctxt.generateJavaSource(" Throwable rc = ex.getRootCause();"); ctxt.generateJavaSource(" if (rc == null)"); ctxt.generateJavaSource(" throw new JspException(ex);"); ctxt.generateJavaSource(" else"); ctxt.generateJavaSource(" throw new JspException(rc);"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" if(" + irwName + ".getStatus() < 200 || " + irwName + ".getStatus() > 299){"); ctxt.generateJavaSource(" throw new JspTagException(" + irwName + ".getStatus()+\" \" + org.apache.jasper.tagplugins.jstl.Util.stripSession(" + urlName + "));"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" java.io.Reader " + tempReaderName + " = new java.io.StringReader(" + irwName + ".getString());"); ctxt.generateJavaSource(" pageContext.setAttribute(" + varReaderName + ", " + tempReaderName + ");"); ctxt.generateJavaSource("}"); ctxt.generateBody(); ctxt.generateJavaSource("java.io.Reader " + tempReaderName2 + " = (java.io.Reader)pageContext.getAttribute(" + varReaderName + ");"); ctxt.generateJavaSource("if(" + tempReaderName2 + " != null) " + tempReaderName2 + ".close();"); ctxt.generateJavaSource("pageContext.removeAttribute(" + varReaderName + ",1);"); } else { ctxt.generateJavaSource("pageContext.setAttribute(\"url_without_param\"," + urlName + ");"); ctxt.generateBody(); ctxt.generateJavaSource(urlName + " = (String)pageContext.getAttribute(\"url_without_param\");"); ctxt.generateJavaSource("pageContext.removeAttribute(\"url_without_param\");"); String strScope = "page"; if (hasScope) { strScope = ctxt.getConstantAttribute("scope"); } int iScope = Util.getScope(strScope); ctxt.generateJavaSource("String " + tempStringName + " = null;"); ctxt.generateJavaSource("if(" + iauName + "){"); ctxt.generateJavaSource(" java.net.URL " + urlObjName + " = new java.net.URL(" + urlName + ");"); ctxt.generateJavaSource(" java.net.URLConnection " + ucName + " = " + urlObjName + ".openConnection();"); ctxt.generateJavaSource(" java.io.InputStream " + inputStreamName + " = " + ucName + ".getInputStream();"); ctxt.generateJavaSource(" java.io.Reader " + tempReaderName + " = null;"); ctxt.generateJavaSource(" if(" + charSetName + " == null){"); ctxt.generateJavaSource(" String " + contentTypeName + " = " + ucName + ".getContentType();"); ctxt.generateJavaSource(" if(null != " + contentTypeName + "){"); ctxt.generateJavaSource(" " + charSetName + " = " + "org.apache.jasper.tagplugins.jstl.Util.getContentTypeAttribute(" + contentTypeName + ", \"charset\");"); ctxt.generateJavaSource(" if(" + charSetName + " == null) " + charSetName + " = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;"); ctxt.generateJavaSource(" }else{"); ctxt.generateJavaSource(" " + charSetName + " = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" try{"); ctxt.generateJavaSource(" " + tempReaderName + " = new java.io.InputStreamReader(" + inputStreamName + "," + charSetName + ");"); ctxt.generateJavaSource(" }catch(Exception ex){"); ctxt.generateJavaSource(" " + tempReaderName + " = new java.io.InputStreamReader(" + inputStreamName + ",org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING);"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" if(" + ucName + " instanceof java.net.HttpURLConnection){"); ctxt.generateJavaSource(" int status = ((java.net.HttpURLConnection) " + ucName + ").getResponseCode();"); ctxt.generateJavaSource(" if(status < 200 || status > 299){"); ctxt.generateJavaSource(" throw new JspTagException(status + \" \" + " + urlName + ");"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" java.io.BufferedReader " + brName + " = new java.io.BufferedReader(" + tempReaderName + ");"); ctxt.generateJavaSource(" StringBuilder " + sbName + " = new StringBuilder();"); String index = ctxt.getTemporaryVariableName(); ctxt.generateJavaSource(" int " + index + ";"); ctxt.generateJavaSource(" while((" + index + " = " + brName + ".read()) != -1) " + sbName + ".append((char)" + index + ");"); ctxt.generateJavaSource(" " + tempStringName + " = " + sbName + ".toString();"); ctxt.generateJavaSource("}else{"); ctxt.generateJavaSource(" if (!(pageContext.getRequest() instanceof HttpServletRequest " + "&& pageContext.getResponse() instanceof HttpServletResponse)){"); ctxt.generateJavaSource(" throw new JspTagException(\"Relative &lt;import&gt; from non-HTTP request not allowed\");"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" ServletContext " + servletContextName + " = null;"); if (hasContext) { ctxt.generateJavaSource(" if(null != " + contextName + "){"); ctxt.generateJavaSource(" " + servletContextName + " = pageContext.getServletContext().getContext(" + contextName + ");"); ctxt.generateJavaSource(" }else{"); ctxt.generateJavaSource(" " + servletContextName + " = pageContext.getServletContext();"); ctxt.generateJavaSource(" }"); } else { ctxt.generateJavaSource(" " + servletContextName + " = pageContext.getServletContext();"); } ctxt.generateJavaSource(" if(" + servletContextName + " == null){"); if (hasContext) { ctxt.generateJavaSource(" throw new JspTagException(\"Unable to get RequestDispatcher for Context: \\\" \" +" + contextName + "+ \" \\\" and URL: \\\" \" +" + urlName + "+ \" \\\". Verify values and/or enable cross context access.\");"); } else { ctxt.generateJavaSource(" throw new JspTagException(\"Unable to get RequestDispatcher for URL: \\\" \" +" + urlName + "+ \" \\\". Verify values and/or enable cross context access.\");"); } ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" RequestDispatcher " + requestDispatcherName + " = " + servletContextName + ".getRequestDispatcher(org.apache.jasper.tagplugins.jstl.Util.stripSession(" + urlName + "));"); ctxt.generateJavaSource(" if(" + requestDispatcherName + " == null) throw new JspTagException(org.apache.jasper.tagplugins.jstl.Util.stripSession(" + urlName + "));"); ctxt.generateJavaSource(" org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper " + irwName + " = new org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper((HttpServletResponse) pageContext.getResponse());"); ctxt.generateJavaSource(" if(" + charSetName + " == null){"); ctxt.generateJavaSource(" " + charSetName + " = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" " + irwName + ".setCharEncoding(" + charSetName + ");"); ctxt.generateJavaSource(" try{"); ctxt.generateJavaSource(" " + requestDispatcherName + ".include(pageContext.getRequest(), " + irwName + ");"); ctxt.generateJavaSource(" }catch(java.io.IOException ex){"); ctxt.generateJavaSource(" throw new JspException(ex);"); ctxt.generateJavaSource(" }catch(RuntimeException ex){"); ctxt.generateJavaSource(" throw new JspException(ex);"); ctxt.generateJavaSource(" }catch(ServletException ex){"); ctxt.generateJavaSource(" Throwable rc = ex.getRootCause();"); ctxt.generateJavaSource(" if (rc == null)"); ctxt.generateJavaSource(" throw new JspException(ex);"); ctxt.generateJavaSource(" else"); ctxt.generateJavaSource(" throw new JspException(rc);"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" if(" + irwName + ".getStatus() < 200 || " + irwName + ".getStatus() > 299){"); ctxt.generateJavaSource(" throw new JspTagException(" + irwName + ".getStatus()+\" \" + org.apache.jasper.tagplugins.jstl.Util.stripSession(" + urlName + "));"); ctxt.generateJavaSource(" }"); ctxt.generateJavaSource(" " + tempStringName + " = " + irwName + ".getString();"); ctxt.generateJavaSource("}"); if (hasVar) { String strVar = ctxt.getConstantAttribute("var"); ctxt.generateJavaSource("pageContext.setAttribute(\"" + strVar + "\"," + tempStringName + "," + iScope + ");"); } else { ctxt.generateJavaSource("pageContext.getOut().print(" + tempStringName + ");"); } } }	@Override public void doVisit(Node n) throws JasperException { collectText(); }	public void setPrototypeMode(boolean pm) { protoTypeMode = pm; }	public java.util.List<String> getDependants() { try { Object target; if (isTagFile) { if (reload) { tagHandlerClass = ctxt.load(); reload = false; } target = tagHandlerClass.newInstance(); } else { target = getServlet(); } if (target != null && target instanceof JspSourceDependent) { return ((JspSourceDependent) target).getDependants(); } } catch (Throwable ex) { } return null; }	public void syncBeginTagFile() { saveNestedVariables(); }	private void generateXmlProlog(Node.Nodes page) { String omitXmlDecl = pageInfo.getOmitXmlDecl(); if ((omitXmlDecl != null && !JspUtil.booleanValue(omitXmlDecl)) || (omitXmlDecl == null && page.getRoot().isXmlSyntax() && !pageInfo.hasJspRoot() && !ctxt.isTagFile())) { String cType = pageInfo.getContentType(); String charSet = cType.substring(cType.indexOf("charset=") + 8); out.printil("out.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"" + charSet + "\\\"?>\\n\");"); } String doctypeName = pageInfo.getDoctypeName(); if (doctypeName != null) { String doctypePublic = pageInfo.getDoctypePublic(); String doctypeSystem = pageInfo.getDoctypeSystem(); out.printin("out.write(\"<!DOCTYPE "); out.print(doctypeName); if (doctypePublic == null) { out.print(" SYSTEM \\\""); } else { out.print(" PUBLIC \\\""); out.print(doctypePublic); out.print("\\\" \\\""); } out.print(doctypeSystem); out.println("\\\">\\n\");"); } }	private Class<?> loadTagFile(Compiler compiler, String tagFilePath, TagInfo tagInfo, PageInfo parentPageInfo) throws JasperException { URL tagFileJarUrl = null; if (tagFilePath.startsWith("/META-INF/")) { try { tagFileJarUrl = new URL("jar:" + compiler.getCompilationContext().getTldLocation(tagInfo.getTagLibrary().getURI())[0] + "!/"); } catch (MalformedURLException e) { // Ignore - tagFileJarUrl will be null } } String tagFileJarPath; if (tagFileJarUrl == null) { tagFileJarPath = ""; } else { tagFileJarPath = tagFileJarUrl.toString(); } JspCompilationContext ctxt = compiler.getCompilationContext(); JspRuntimeContext rctxt = ctxt.getRuntimeContext(); String wrapperUri = tagFileJarPath + tagFilePath; JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri); synchronized (rctxt) { if (wrapper == null) { wrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), tagFileJarUrl); rctxt.addWrapper(wrapperUri, wrapper); wrapper.getJspEngineContext().setClassLoader(ctxt.getClassLoader()); wrapper.getJspEngineContext().setClassPath(ctxt.getClassPath()); } else { // Make sure that JspCompilationContext gets the latest TagInfo // for the tag file. TagInfo instance was created the last // time the tag file was scanned for directives, and the tag wrapper.getJspEngineContext().setTagInfo(tagInfo); } Class<?> tagClazz; int tripCount = wrapper.incTripCount(); try { if (tripCount > 0) { // When tripCount is greater than zero, a circular // dependency exists. The circularily dependant tag // file is compiled in prototype mode, to avoid infinite JspServletWrapper tempWrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), ctxt.getTagFileJarUrl(tagFilePath)); tagClazz = tempWrapper.loadTagFilePrototype(); tempVector.add(tempWrapper.getJspEngineContext().getCompiler()); } else { tagClazz = wrapper.loadTagFile(); } } finally { wrapper.decTripCount(); } try { Object tagIns = tagClazz.newInstance(); if (tagIns instanceof JspSourceDependent) { Iterator<String> iter = ((JspSourceDependent) tagIns).getDependants().iterator(); while (iter.hasNext()) { parentPageInfo.addDependant(iter.next()); } } } catch (Exception e) { // ignore errors } return tagClazz; } }	private FunctionMapper getFunctionMapper(ELNode.Nodes el) throws JasperException { class ValidateFunctionMapper extends FunctionMapper { private HashMap<String, Method> fnmap = new HashMap<String, Method>(); public void mapFunction(String fnQName, Method method) { fnmap.put(fnQName, method); } @Override public Method resolveFunction(String prefix, String localName) { return this.fnmap.get(prefix + ":" + localName); } } class MapperELVisitor extends ELNode.Visitor { ValidateFunctionMapper fmapper; MapperELVisitor(ValidateFunctionMapper fmapper) { this.fmapper = fmapper; } @Override public void visit(ELNode.Function n) throws JasperException { Class<?> c = null; Method method = null; try { c = loader.loadClass(n.getFunctionInfo().getFunctionClass()); } catch (ClassNotFoundException e) { err.jspError("jsp.error.function.classnotfound", n.getFunctionInfo().getFunctionClass(), n.getPrefix() + ':' + n.getName(), e.getMessage()); } String[] paramTypes = n.getParameters(); int size = paramTypes.length; Class<?>[] params = new Class[size]; int i = 0; try { for (i = 0; i < size; i++) { params[i] = JspUtil.toClass(paramTypes[i], loader); } method = c.getDeclaredMethod(n.getMethodName(), params); } catch (ClassNotFoundException e) { err.jspError("jsp.error.signature.classnotfound", paramTypes[i], n.getPrefix() + ':' + n.getName(), e.getMessage()); } catch (NoSuchMethodException e) { err.jspError("jsp.error.noFunctionMethod", n.getMethodName(), n.getName(), c.getName()); } fmapper.mapFunction(n.getPrefix() + ':' + n.getName(), method); } } ValidateFunctionMapper fmapper = new ValidateFunctionMapper(); el.visit(new MapperELVisitor(fmapper)); return fmapper; }	@Override public void visit(Node.TemplateText n) throws JasperException { String text = n.getText(); int textSize = text.length(); if (textSize == 0) { return; } if (textSize <= 3) { n.setBeginJavaLine(out.getJavaLine()); int lineInc = 0; for (int i = 0; i < textSize; i++) { char ch = text.charAt(i); out.printil("out.write(" + quote(ch) + ");"); if (i > 0) { n.addSmap(lineInc); } if (ch == '\n') { lineInc++; } } n.setEndJavaLine(out.getJavaLine()); return; } if (ctxt.getOptions().genStringAsCharArray()) { ServletWriter caOut; if (charArrayBuffer == null) { charArrayBuffer = new GenBuffer(); caOut = charArrayBuffer.getOut(); caOut.pushIndent(); textMap = new HashMap<String, String>(); } else { caOut = charArrayBuffer.getOut(); } String charArrayName = textMap.get(text); if (charArrayName == null) { charArrayName = "_jspx_char_array_" + charArrayCount++; textMap.put(text, charArrayName); caOut.printin("static char[] "); caOut.print(charArrayName); caOut.print(" = "); caOut.print(quote(text)); caOut.println(".toCharArray();"); } n.setBeginJavaLine(out.getJavaLine()); out.printil("out.write(" + charArrayName + ");"); n.setEndJavaLine(out.getJavaLine()); return; } n.setBeginJavaLine(out.getJavaLine()); out.printin(); StringBuilder sb = new StringBuilder("out.write(\""); int initLength = sb.length(); int count = JspUtil.CHUNKSIZE; int srcLine = 0; for (int i = 0; i < text.length(); i++) { char ch = text.charAt(i); --count; switch(ch) { case '"': sb.append('\\').append('\"'); break; case '\\': sb.append('\\').append('\\'); break; case '\r': sb.append('\\').append('r'); break; case '\n': sb.append('\\').append('n'); srcLine++; if (breakAtLF || count < 0) { sb.append("\");"); out.println(sb.toString()); if (i < text.length() - 1) { out.printin(); } sb.setLength(initLength); count = JspUtil.CHUNKSIZE; } n.addSmap(srcLine); break; case '\t': sb.append('\\').append('t'); break; default: sb.append(ch); } } if (sb.length() > initLength) { sb.append("\");"); out.println(sb.toString()); } n.setEndJavaLine(out.getJavaLine()); }	@Override public void visit(Node.UseBean n) throws JasperException { String name = n.getTextAttribute("id"); String scope = n.getTextAttribute("scope"); String klass = n.getTextAttribute("class"); String type = n.getTextAttribute("type"); Node.JspAttribute beanName = n.getBeanName(); boolean generateNew = false; String canonicalName = null; if (klass != null) { try { Class<?> bean = ctxt.getClassLoader().loadClass(klass); if (klass.indexOf('$') >= 0) { canonicalName = JspUtil.getCanonicalName(bean); } else { canonicalName = klass; } int modifiers = bean.getModifiers(); if (!Modifier.isPublic(modifiers) || Modifier.isInterface(modifiers) || Modifier.isAbstract(modifiers)) { throw new Exception("Invalid bean class modifier"); } bean.getConstructor(new Class[] {}); // At compile time, we have determined that the bean class // exists, with a public zero constructor, new() can be generateNew = true; } catch (Exception e) { if (ctxt.getOptions().getErrorOnUseBeanInvalidClassAttribute()) { err.jspError(n, "jsp.error.invalid.bean", klass); } if (canonicalName == null) { // Doing our best here to get a canonical name canonicalName = klass.replace('$', '.'); } } if (type == null) { type = canonicalName; } } String scopename = "PageContext.PAGE_SCOPE"; String lock = "_jspx_page_context"; if ("request".equals(scope)) { scopename = "PageContext.REQUEST_SCOPE"; lock = "request"; } else if ("session".equals(scope)) { scopename = "PageContext.SESSION_SCOPE"; lock = "session"; } else if ("application".equals(scope)) { scopename = "PageContext.APPLICATION_SCOPE"; lock = "application"; } n.setBeginJavaLine(out.getJavaLine()); out.printin(type); out.print(' '); out.print(name); out.println(" = null;"); out.printin("synchronized ("); out.print(lock); out.println(") {"); out.pushIndent(); out.printin(name); out.print(" = ("); out.print(type); out.print(") _jspx_page_context.getAttribute("); out.print(quote(name)); out.print(", "); out.print(scopename); out.println(");"); // Create bean out.printin("if ("); out.print(name); out.println(" == null){"); out.pushIndent(); if (klass == null && beanName == null) { out.printin("throw new java.lang.InstantiationException(\"bean "); out.print(name); out.println(" not found within scope\");"); } else { if (!generateNew) { String binaryName; if (beanName != null) { if (beanName.isNamedAttribute()) { // If the value for beanName was specified via // jsp:attribute, first generate code to evaluate binaryName = generateNamedAttributeValue(beanName.getNamedAttributeNode()); } else { binaryName = attributeValue(beanName, false, String.class); } } else { binaryName = quote(klass); } out.printil("try {"); out.pushIndent(); out.printin(name); out.print(" = ("); out.print(type); out.print(") java.beans.Beans.instantiate("); out.print("this.getClass().getClassLoader(), "); out.print(binaryName); out.println(");"); out.popIndent(); out.printil("} catch (ClassNotFoundException exc) {"); out.pushIndent(); out.printil("throw new InstantiationException(exc.getMessage());"); out.popIndent(); out.printil("} catch (Exception exc) {"); out.pushIndent(); out.printin("throw new ServletException("); out.print("\"Cannot create bean of class \" + "); out.print(binaryName); out.println(", exc);"); out.popIndent(); out.printil("}"); } else { // Implies klass is not null out.printin(name); out.print(" = new "); out.print(canonicalName); out.println("();"); } out.printin("_jspx_page_context.setAttribute("); out.print(quote(name)); out.print(", "); out.print(name); out.print(", "); out.print(scopename); out.println(");"); visitBody(n); } out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); n.setEndJavaLine(out.getJavaLine()); }	void postCheck() throws JasperException { Iterator<String> iter = nameFromTable.keySet().iterator(); while (iter.hasNext()) { String nameFrom = iter.next(); NameEntry nameEntry = nameTable.get(nameFrom); NameEntry nameFromEntry = nameFromTable.get(nameFrom); Node nameFromNode = nameFromEntry.getNode(); if (nameEntry == null) { err.jspError(nameFromNode, "jsp.error.tagfile.nameFrom.noAttribute", nameFrom); } else { Node node = nameEntry.getNode(); TagAttributeInfo tagAttr = nameEntry.getTagAttributeInfo(); if (!"java.lang.String".equals(tagAttr.getTypeName()) || !tagAttr.isRequired() || tagAttr.canBeRequestTime()) { err.jspError(nameFromNode, "jsp.error.tagfile.nameFrom.badAttribute", nameFrom, Integer.toString(node.getStart().getLineNumber())); } } } }
protected ArrayList<NamingEntry> list(File file) { ArrayList<NamingEntry> entries = new ArrayList<NamingEntry>(); if (!file.isDirectory()) return entries; String[] names = file.list(); if (names == null) { log.warn(sm.getString("fileResources.listingNull", file.getAbsolutePath())); return entries; } Arrays.sort(names); NamingEntry entry = null; for (int i = 0; i < names.length; i++) { File currentFile = new File(file, names[i]); Object object = null; if (currentFile.isDirectory()) { FileDirContext tempContext = new FileDirContext(env); tempContext.setDocBase(file.getPath()); tempContext.setAllowLinking(getAllowLinking()); object = tempContext; } else { object = new FileResource(currentFile); } entry = new NamingEntry(names[i], object, NamingEntry.ENTRY); entries.add(entry); } return entries; }	protected void cacheLoad(CacheEntry entry) { String name = entry.name; boolean exists = true; if (entry.attributes == null) { try { Attributes attributes = dirContext.getAttributes(entry.name); if (!(attributes instanceof ResourceAttributes)) { entry.attributes = new ResourceAttributes(attributes); } else { entry.attributes = (ResourceAttributes) attributes; } } catch (NamingException e) { exists = false; } } if ((exists) && (entry.resource == null) && (entry.context == null)) { try { Object object = dirContext.lookup(name); if (object instanceof InputStream) { entry.resource = new Resource((InputStream) object); } else if (object instanceof DirContext) { entry.context = (DirContext) object; } else if (object instanceof Resource) { entry.resource = (Resource) object; } else { entry.resource = new Resource(new ByteArrayInputStream(object.toString().getBytes())); } } catch (NamingException e) { exists = false; } } if ((exists) && (entry.resource != null) && (entry.resource.getContent() == null) && (entry.attributes.getContentLength() >= 0) && (entry.attributes.getContentLength() < (cacheObjectMaxSize * 1024))) { int length = (int) entry.attributes.getContentLength(); // The entry size is 1 + the resource size in KB, if it will be entry.size += (entry.attributes.getContentLength() / 1024); InputStream is = null; try { is = entry.resource.streamContent(); int pos = 0; byte[] b = new byte[length]; while (pos < length) { int n = is.read(b, pos, length - pos); if (n < 0) break; pos = pos + n; } entry.resource.setContent(b); } catch (IOException e) { // Ignore } finally { try { if (is != null) is.close(); } catch (IOException e) { // Ignore } } } entry.exists = exists; entry.timestamp = System.currentTimeMillis() + cacheTTL; synchronized (cache) { if ((cache.lookup(name) == null) && cache.allocate(entry.size)) { cache.load(entry); } } }	@Override public NamingEnumeration<SearchResult> search(String name, String filterExpr, Object[] filterArgs, SearchControls cons) throws NamingException { return null; }	@Override public NamingEnumeration<SearchResult> search(String name, String filterExpr, Object[] filterArgs, SearchControls cons) throws NamingException { throw new OperationNotSupportedException(); }	public NamingEnumeration<SearchResult> search(Name name, String filterExpr, Object[] filterArgs, SearchControls cons) throws NamingException { return search(name.toString(), filterExpr, filterArgs, cons); }	public boolean unload(String name) { CacheEntry removedEntry = removeCache(name); if (removedEntry != null) { cacheSize -= removedEntry.size; return true; } else if (notFoundCache.remove(name) != null) { cacheSize--; return true; } return false; }	public void postDeregister() { destroy(); }
private void removeHeader(int idx) { MimeHeaderField mh = headers[idx]; mh.recycle(); headers[idx] = headers[count - 1]; headers[count - 1] = mh; count--; }	private final void internalMapExtensionWrapper(Wrapper[] wrappers, CharChunk path, MappingData mappingData) { char[] buf = path.getBuffer(); int pathEnd = path.getEnd(); int servletPath = path.getOffset(); int slash = -1; for (int i = pathEnd - 1; i >= servletPath; i--) { if (buf[i] == '/') { slash = i; break; } } if (slash >= 0) { int period = -1; for (int i = pathEnd - 1; i > slash; i--) { if (buf[i] == '.') { period = i; break; } } if (period >= 0) { path.setOffset(period + 1); path.setEnd(pathEnd); int pos = find(wrappers, path); if ((pos != -1) && (path.equals(wrappers[pos].name))) { mappingData.wrapperPath.setChars(buf, servletPath, pathEnd - servletPath); mappingData.requestPath.setChars(buf, servletPath, pathEnd - servletPath); mappingData.wrapper = wrappers[pos].object; } path.setOffset(servletPath); path.setEnd(pathEnd); } } }	private static final int find(MapElement[] map, CharChunk name) { return find(map, name, name.getStart(), name.getEnd()); }	private static final int find(MapElement[] map, CharChunk name, int start, int end) { int a = 0; int b = map.length - 1; if (b == -1) { return -1; } if (compare(name, start, end, map[0].name) < 0) { return -1; } if (b == 0) { return 0; } int i = 0; while (true) { i = (b + a) / 2; int result = compare(name, start, end, map[i].name); if (result == 1) { a = i; } else if (result == 0) { return i; } else { b = i; } if ((b - a) == 1) { int result2 = compare(name, start, end, map[b].name); if (result2 < 0) { return a; } else { return b; } } } }	private static final int findIgnoreCase(MapElement[] map, CharChunk name) { return findIgnoreCase(map, name, name.getStart(), name.getEnd()); }	private static final int getTokenEndPosition(byte[] bytes, int off, int end, int version, boolean isName) { int pos = off; while (pos < end && (!CookieSupport.isHttpSeparator((char) bytes[pos]) || version == 0 && CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 && bytes[pos] != '=' && !CookieSupport.isV0Separator((char) bytes[pos]) || !isName && bytes[pos] == '=' && CookieSupport.ALLOW_EQUALS_IN_VALUE)) { pos++; } if (pos > end) return end; return pos; }	private void notifyListener() { if (listener != null) { listener.update(bytesRead, contentLength, items); } }	private void removeHeader(int idx) { MimeHeaderField mh = headers[idx]; mh.recycle(); headers[idx] = headers[count - 1]; headers[count - 1] = mh; count--; }	protected boolean isBeanCompatible(Class<?> javaType) { if (javaType.isArray() || javaType.isPrimitive()) { return false; } if (javaType.getName().startsWith("java.") || javaType.getName().startsWith("javax.")) { return false; } try { javaType.getConstructor(new Class[] {}); } catch (java.lang.NoSuchMethodException e) { return false; } Class<?> superClass = javaType.getSuperclass(); if (superClass != null && superClass != java.lang.Object.class && superClass != java.lang.Exception.class && superClass != java.lang.Throwable.class) { if (!isBeanCompatible(superClass)) { return false; } } return true; }	protected boolean processKey(SelectionKey sk, KeyAttachment attachment) { boolean result = true; try { if (close) { cancelledKey(sk, SocketStatus.STOP, false); } else if (sk.isValid() && attachment != null) { attachment.access(); sk.attach(attachment); NioChannel channel = attachment.getChannel(); if (sk.isReadable() || sk.isWritable()) { if (attachment.getSendfileData() != null) { processSendfile(sk, attachment, true, false); } else if (attachment.getComet()) { if (isWorkerAvailable()) { //set interest ops to 0 so we don't get multiple reg(sk, attachment, 0); if (sk.isReadable()) { if (!processSocket(channel, SocketStatus.OPEN, true)) processSocket(channel, SocketStatus.DISCONNECT, true); } else { if (!processSocket(channel, SocketStatus.OPEN, true)) processSocket(channel, SocketStatus.DISCONNECT, true); } } else { result = false; } } else { if (isWorkerAvailable()) { unreg(sk, attachment, sk.readyOps()); boolean close = (!processSocket(channel, null, true)); if (close) { cancelledKey(sk, SocketStatus.DISCONNECT, false); } } else { result = false; } } } } else { cancelledKey(sk, SocketStatus.ERROR, false); } } catch (CancelledKeyException ckx) { cancelledKey(sk, SocketStatus.ERROR, false); } catch (Throwable t) { log.error("", t); } return result; }	protected final void processCookieHeader(byte[] bytes, int off, int len) { if (len <= 0 || bytes == null) return; int end = off + len; int pos = off; int nameStart = 0; int nameEnd = 0; int valueStart = 0; int valueEnd = 0; int version = 0; ServerCookie sc = null; boolean isSpecial; boolean isQuoted; while (pos < end) { isSpecial = false; isQuoted = false; while (pos < end && (CookieSupport.isHttpSeparator((char) bytes[pos]) && !CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 || CookieSupport.isV0Separator((char) bytes[pos]) || isWhiteSpace(bytes[pos]))) { pos++; } if (pos >= end) return; if (bytes[pos] == '$') { isSpecial = true; pos++; } valueEnd = valueStart = nameStart = pos; pos = nameEnd = getTokenEndPosition(bytes, pos, end, version, true); while (pos < end && isWhiteSpace(bytes[pos])) { pos++; } if (pos < end && bytes[pos] == '=') { do { pos++; } while (pos < end && isWhiteSpace(bytes[pos])); if (pos >= end) return; switch(bytes[pos]) { case '"': isQuoted = true; valueStart = pos + 1; // getQuotedValue returns the position before // at the last qoute. This must be dealt with valueEnd = getQuotedValueEndPosition(bytes, valueStart, end); pos = valueEnd; if (pos >= end) return; break; case ';': case ',': // Name-only cookie with an '=' after the name token valueStart = valueEnd = -1; break; default: if (version == 0 && !CookieSupport.isV0Separator((char) bytes[pos]) && CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 || !CookieSupport.isHttpSeparator((char) bytes[pos]) || bytes[pos] == '=' && CookieSupport.ALLOW_EQUALS_IN_VALUE) { valueStart = pos; // getToken returns the position at the delimeter valueEnd = getTokenEndPosition(bytes, valueStart, end, version, false); pos = valueEnd; } else { // INVALID COOKIE, advance to next delimiter // The starting character of the cookie value was log.info("Cookies: Invalid cookie. " + "Value not a token or quoted value"); while (pos < end && bytes[pos] != ';' && bytes[pos] != ',') { pos++; } pos++; // Make sure no special avpairs can be attributed to // the previous cookie by setting the current cookie sc = null; continue; } } } else { valueStart = valueEnd = -1; pos = nameEnd; } while (pos < end && isWhiteSpace(bytes[pos])) { pos++; } while (pos < end && bytes[pos] != ';' && bytes[pos] != ',') { pos++; } pos++; if (isSpecial) { isSpecial = false; if (equals("Version", bytes, nameStart, nameEnd) && sc == null) { if (bytes[valueStart] == '1' && valueEnd == (valueStart + 1)) { version = 1; } else { // unknown version (Versioning is not very strict) } continue; } if (sc == null) { continue; } if (equals("Domain", bytes, nameStart, nameEnd)) { sc.getDomain().setBytes(bytes, valueStart, valueEnd - valueStart); continue; } if (equals("Path", bytes, nameStart, nameEnd)) { sc.getPath().setBytes(bytes, valueStart, valueEnd - valueStart); continue; } if (equals("Port", bytes, nameStart, nameEnd)) { continue; } if (equals("CommentURL", bytes, nameStart, nameEnd)) { continue; } log.info("Cookies: Unknown Special Cookie"); } else { sc = addCookie(); sc.setVersion(version); sc.getName().setBytes(bytes, nameStart, nameEnd - nameStart); if (valueStart != -1) { sc.getValue().setBytes(bytes, valueStart, valueEnd - valueStart); if (isQuoted) { unescapeDoubleQuotes(sc.getValue().getByteChunk()); } } else { sc.getValue().setString(""); } continue; } } }	public void run() { long maintainTime = 0; while (running) { while (paused) { try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } } while (keepAliveCount < 1 && addCount < 1) { maintainTime = 0; try { synchronized (this) { this.wait(); } } catch (InterruptedException e) { // Ignore } } try { if (addCount > 0) { synchronized (this) { for (int i = (addCount - 1); i >= 0; i--) { int rv = Poll.add(serverPollset, addS[i], Poll.APR_POLLIN); if (rv == Status.APR_SUCCESS) { keepAliveCount++; } else { if (comet) { processSocket(addS[i], SocketStatus.ERROR); } else { Socket.destroy(addS[i]); } } } addCount = 0; } } maintainTime += pollTime; int rv = Poll.poll(serverPollset, pollTime, desc, true); if (rv > 0) { keepAliveCount -= rv; for (int n = 0; n < rv; n++) { if (((desc[n * 2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP) || ((desc[n * 2] & Poll.APR_POLLERR) == Poll.APR_POLLERR) || (comet && (!processSocket(desc[n * 2 + 1], SocketStatus.OPEN))) || (!comet && (!processSocket(desc[n * 2 + 1])))) { if (comet) { processSocket(desc[n * 2 + 1], SocketStatus.DISCONNECT); } else { Socket.destroy(desc[n * 2 + 1]); } continue; } } } else if (rv < 0) { int errn = -rv; if ((errn != Status.TIMEUP) && (errn != Status.EINTR)) { if (errn > Status.APR_OS_START_USERERR) { errn -= Status.APR_OS_START_USERERR; } log.error(sm.getString("endpoint.poll.fail", "" + errn, Error.strerror(errn))); synchronized (this) { destroy(); init(); } continue; } } if (socketProperties.getSoTimeout() > 0 && maintainTime > 1000000L && running) { rv = Poll.maintain(serverPollset, desc, true); maintainTime = 0; if (rv > 0) { keepAliveCount -= rv; for (int n = 0; n < rv; n++) { if (comet) { processSocket(desc[n], SocketStatus.TIMEOUT); } else { Socket.destroy(desc[n]); } } } } } catch (Throwable t) { log.error(sm.getString("endpoint.poll.error"), t); } } synchronized (this) { this.notifyAll(); } }	protected void timeout(int keyCount, boolean hasEvents) { long now = System.currentTimeMillis(); if (((keyCount > 0 || hasEvents) || (now < nextExpiration)) && (!close)) { return; } long prevExp = nextExpiration; nextExpiration = now + socketProperties.getTimeoutInterval(); Set<SelectionKey> keys = selector.keys(); int keycount = 0; for (Iterator<SelectionKey> iter = keys.iterator(); iter.hasNext(); ) { SelectionKey key = iter.next(); keycount++; try { KeyAttachment ka = (KeyAttachment) key.attachment(); if (ka == null) { cancelledKey(key, SocketStatus.ERROR, false); } else if (ka.getError()) { cancelledKey(key, SocketStatus.ERROR, true); } else if (ka.getComet() && ka.getCometNotify()) { ka.setCometNotify(false); reg(key, ka, 0); if (!processSocket(ka.getChannel(), SocketStatus.OPEN, true)) processSocket(ka.getChannel(), SocketStatus.DISCONNECT, true); } else if ((ka.interestOps() & SelectionKey.OP_READ) == SelectionKey.OP_READ || (ka.interestOps() & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) { long delta = now - ka.getLastAccess(); long timeout = (ka.getTimeout() == -1) ? ((long) socketProperties.getSoTimeout()) : (ka.getTimeout()); boolean isTimedout = delta > timeout; if (close) { key.interestOps(0); ka.interestOps(0); processKey(key, ka); } else if (isTimedout) { key.interestOps(0); ka.interestOps(0); cancelledKey(key, SocketStatus.TIMEOUT, true); } else { long nextTime = now + (timeout - delta); nextExpiration = (nextTime < nextExpiration) ? nextTime : nextExpiration; } } else if (ka.isAsync()) { long delta = now - ka.getLastAccess(); long timeout = (ka.getTimeout() == -1) ? ((long) socketProperties.getSoTimeout()) : (ka.getTimeout()); boolean isTimedout = delta > timeout; if (isTimedout) { processSocket(ka.getChannel(), SocketStatus.TIMEOUT, true); } } //end if } catch (CancelledKeyException ckx) { cancelledKey(key, SocketStatus.ERROR, false); } } if (log.isTraceEnabled()) log.trace("timeout completed: keys processed=" + keycount + "; now=" + now + "; nextExpiration=" + prevExp + "; " + "keyCount=" + keyCount + "; hasEvents=" + hasEvents + "; eval=" + ((now < prevExp) && (keyCount > 0 || hasEvents) && (!close))); }	public Digester getDigester() { return wrappedRules.getDigester(); }	public void reset() throws IOException { iis = new IntermediateInputStream(); conv = new ReadConvertor(iis, encoding); }	public String toStringInternal() { String strValue=null; try { if( enc==null ) enc=DEFAULT_CHARACTER_ENCODING; strValue = new String( buff, start, end-start, enc ); } }	public final void flushBuffer() throws IOException { conv.flush(); }	public boolean equals(MessageBytes mb) { switch(type) { case T_STR: return mb.equals(strValue); } if (mb.type != T_CHARS && mb.type != T_BYTES) { return equals(mb.toString()); } if (mb.type == T_CHARS && type == T_CHARS) { return charC.equals(mb.charC); } if (mb.type == T_BYTES && type == T_BYTES) { return byteC.equals(mb.byteC); } if (mb.type == T_CHARS && type == T_BYTES) { return byteC.equals(mb.charC); } if (mb.type == T_BYTES && type == T_CHARS) { return mb.byteC.equals(charC); } return true; }	public boolean skipPreamble() throws IOException { System.arraycopy(boundary, 2, boundary, 0, boundary.length - 2); boundaryLength = boundary.length - 2; try { discardBodyData(); return readBoundary(); } catch (MalformedStreamException e) { return false; } finally { System.arraycopy(boundary, 0, boundary, 2, boundary.length - 2); boundaryLength = boundary.length; boundary[0] = CR; boundary[1] = LF; } }	public int getCookieCount() { if (unprocessed) { unprocessed = false; processCookies(headers); } return cookieCount; }	public int getLength() { return end - start; }	public int substract(byte[] src, int off, int len) throws IOException { if ((end - start) == 0) { if (in == null) return -1; int n = in.realReadBytes(buff, 0, buff.length); if (n < 0) return -1; } int n = len; if (len > getLength()) { n = getLength(); } System.arraycopy(buff, start, src, off, n); start += n; return n; }	public static String getContent(Node n) { if (n == null) return null; Node n1 = DomUtil.getChild(n, Node.TEXT_NODE); if (n1 == null) return null; String s1 = n1.getNodeValue(); return s1.trim(); }	public static String toString(ByteChunk bc) { if (bcCache == null) { String value = bc.toStringInternal(); if (byteEnabled && (value.length() < maxStringSize)) { synchronized (bcStats) { if (bcCache != null) { return value; } if (bcCount > trainThreshold) { long t1 = System.currentTimeMillis(); TreeMap<Integer, ArrayList<ByteEntry>> tempMap = new TreeMap<Integer, ArrayList<ByteEntry>>(); Iterator<ByteEntry> entries = bcStats.keySet().iterator(); while (entries.hasNext()) { ByteEntry entry = entries.next(); int[] countA = bcStats.get(entry); Integer count = new Integer(countA[0]); ArrayList<ByteEntry> list = tempMap.get(count); if (list == null) { list = new ArrayList<ByteEntry>(); tempMap.put(count, list); } list.add(entry); } int size = bcStats.size(); if (size > cacheSize) { size = cacheSize; } ByteEntry[] tempbcCache = new ByteEntry[size]; // Fill it up using an alphabetical order ByteChunk tempChunk = new ByteChunk(); int n = 0; while (n < size) { Object key = tempMap.lastKey(); ArrayList<ByteEntry> list = tempMap.get(key); for (int i = 0; i < list.size() && n < size; i++) { ByteEntry entry = list.get(i); tempChunk.setBytes(entry.name, 0, entry.name.length); int insertPos = findClosest(tempChunk, tempbcCache, n); if (insertPos == n) { tempbcCache[n + 1] = entry; } else { System.arraycopy(tempbcCache, insertPos + 1, tempbcCache, insertPos + 2, n - insertPos - 1); tempbcCache[insertPos + 1] = entry; } n++; } tempMap.remove(key); } bcCount = 0; bcStats.clear(); bcCache = tempbcCache; if (log.isDebugEnabled()) { long t2 = System.currentTimeMillis(); log.debug("ByteCache generation time: " + (t2 - t1) + "ms"); } } else { bcCount++; ByteEntry entry = new ByteEntry(); entry.value = value; int[] count = bcStats.get(entry); if (count == null) { int end = bc.getEnd(); int start = bc.getStart(); entry.name = new byte[bc.getLength()]; System.arraycopy(bc.getBuffer(), start, entry.name, 0, end - start); entry.enc = bc.getEncoding(); count = new int[1]; count[0] = 1; bcStats.put(entry, count); } else { count[0] = count[0] + 1; } } } } return value; } else { accessCount++; String result = find(bc); if (result == null) { return bc.toStringInternal(); } hitCount++; return result; } }	public static boolean hasHook(Object obj, String methodN) { try { Method[] myMethods = findMethods(obj.getClass()); for (int i = 0; i < myMethods.length; i++) { if (methodN.equals(myMethods[i].getName())) { Class<?> declaring = myMethods[i].getDeclaringClass(); Class<?> parentOfDeclaring = declaring.getSuperclass(); if (!"java.lang.Object".equals(parentOfDeclaring.getName())) { return true; } } } } catch (Exception ex) { ex.printStackTrace(); } return false; }	public static long msec(long t) { return t / APR_MSEC_PER_USEC; }	public void addCallMethod(String pattern, String methodName, int paramCount, Class<?>[] paramTypes) { addRule(pattern, new CallMethodRule(methodName, paramCount, paramTypes)); }	public void addSetNext(String pattern, String methodName) { addRule(pattern, new SetNextRule(methodName)); }	public void addSetTop(String pattern, String methodName) { addRule(pattern, new SetTopRule(methodName)); }	public void convert(ByteChunk mb, boolean query) throws IOException { int start = mb.getOffset(); byte[] buff = mb.getBytes(); int end = mb.getEnd(); int idx = ByteChunk.indexOf(buff, start, end, '%'); int idx2 = -1; if (query) idx2 = ByteChunk.indexOf(buff, start, end, '+'); if (idx < 0 && idx2 < 0) { return; } if (idx2 >= 0 && idx2 < idx) idx = idx2; if (idx < 0) idx = idx2; boolean noSlash = !(ALLOW_ENCODED_SLASH || query); for (int j = idx; j < end; j++, idx++) { if (buff[j] == '+' && query) { buff[idx] = (byte) ' '; } else if (buff[j] != '%') { buff[idx] = buff[j]; } else { if (j + 2 >= end) { throw new CharConversionException("EOF"); } byte b1 = buff[j + 1]; byte b2 = buff[j + 2]; if (!isHexDigit(b1) || !isHexDigit(b2)) throw new CharConversionException("isHexDigit"); j += 2; int res = x2c(b1, b2); if (noSlash && (res == '/')) { throw new CharConversionException("noSlash"); } buff[idx] = (byte) res; } } mb.setEnd(idx); return; }	public void remove(int i) { Field mh = fields[i]; mh.recycle(); fields[i] = fields[count - 1]; fields[count - 1] = mh; count--; }	public void resetStringValue() { if (type != T_STR) { // If this was cread as a byte[] or char[], we remove hasStrValue = false; strValue = null; } }	protected boolean processSocket(long socket, SocketStatus status) { try { getExecutor().execute(new SocketEventProcessor(socket, status)); } catch (RejectedExecutionException x) { log.warn("Socket processing request was rejected for:" + socket, x); return false; } catch (Throwable t) { // This means we got an OOM or similar creating a thread, or that log.error(sm.getString("endpoint.process.fail"), t); return false; } return true; }	public void setChars(char[] c, int off, int len) { buff = c; start = off; end = start + len; isSet = true; }	public void setEncoding(String enc) { if (!byteC.isNull()) { charC.recycle(); hasStrValue = false; } byteC.setEncoding(enc); }	public void setNamespaceAware(boolean namespaceAware) { this.namespaceAware = namespaceAware; }	public void setSetMethod(String setMethod) { this.setMethod = setMethod; }	public List<ObjectName> loadMBeans(Object source, ClassLoader cl) throws Exception { return load("MbeansSource", source, null); }	public void urlEncode(Writer buf, byte[] bytes, int off, int len) throws IOException { for (int j = off; j < len; j++) { buf.write('%'); char ch = Character.forDigit((bytes[j] >> 4) & 0xF, 16); if (log.isDebugEnabled()) log.debug("Encoder: Encode: " + ch); buf.write(ch); ch = Character.forDigit(bytes[j] & 0xF, 16); if (log.isDebugEnabled()) log.debug("Encoder: Encode: " + ch); buf.write(ch); } }	protected TrustManager[] getTrustManagers(String keystoreType, String keystoreProvider, String algorithm) throws Exception { String crlf = (String) attributes.get("crlFile"); TrustManager[] tms = null; KeyStore trustStore = getTrustStore(keystoreType, keystoreProvider); if (trustStore != null) { if (crlf == null) { TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm); tmf.init(trustStore); tms = tmf.getTrustManagers(); } else { TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm); CertPathParameters params = getParameters(algorithm, crlf, trustStore); ManagerFactoryParameters mfp = new CertPathTrustManagerParameters(params); tmf.init(mfp); tms = tmf.getTrustManagers(); } } return tms; }
void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { if (pos < n) { ApplicationFilterConfig filterConfig = filters[pos++]; Filter filter = null; try { filter = filterConfig.getFilter(); support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT, filter, request, response); if (Globals.IS_SECURITY_ENABLED) { final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[] { req, res, this }; SecurityUtil.doAsPrivilege("doFilter", filter, classType, args, principal); args = null; } else { filter.doFilter(request, response, this); } support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response); } catch (IOException e) { if (filter != null) support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response, e); throw e; } catch (ServletException e) { if (filter != null) support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response, e); throw e; } catch (RuntimeException e) { if (filter != null) support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response, e); throw e; } catch (Throwable e) { if (filter != null) support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response, e); throw new ServletException(sm.getString("filterChain.filter"), e); } return; } try { if (Globals.STRICT_SERVLET_COMPLIANCE) { lastServicedRequest.set(request); lastServicedResponse.set(response); } support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT, servlet, request, response); if ((request instanceof HttpServletRequest) && (response instanceof HttpServletResponse)) { if (Globals.IS_SECURITY_ENABLED) { final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[] { req, res }; SecurityUtil.doAsPrivilege("service", servlet, classTypeUsedInService, args, principal); args = null; } else { servlet.service(request, response); } } else { servlet.service(request, response); } support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response); } catch (IOException e) { support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response, e); throw e; } catch (ServletException e) { support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response, e); throw e; } catch (RuntimeException e) { support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response, e); throw e; } catch (Throwable e) { support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response, e); throw new ServletException(sm.getString("filterChain.servlet"), e); } finally { if (Globals.STRICT_SERVLET_COMPLIANCE) { lastServicedRequest.set(null); lastServicedResponse.set(null); } } }	public byte[] getData(boolean getalive) { return getData(getalive, false); }	public static byte[] createDataPackage(byte[] data, int doff, int dlength, byte[] buffer, int bufoff) { if ((buffer.length - bufoff) > getDataPackageLength(dlength)) { throw new ArrayIndexOutOfBoundsException("Unable to create data package, buffer is too small."); } System.arraycopy(START_DATA, 0, buffer, bufoff, START_DATA.length); toBytes(data.length, buffer, bufoff + START_DATA.length); System.arraycopy(data, doff, buffer, bufoff + START_DATA.length + 4, dlength); System.arraycopy(END_DATA, 0, buffer, bufoff + START_DATA.length + 4 + data.length, END_DATA.length); return buffer; }	private Node.Nodes doParse(String inFileName, Node parent, URL jarFileUrl) throws FileNotFoundException, JasperException, IOException { Node.Nodes parsedPage = null; isEncodingSpecifiedInProlog = false; isBomPresent = false; isDefaultPageEncoding = false; JarFile jarFile = getJarFile(jarFileUrl); String absFileName = resolveFileName(inFileName); String jspConfigPageEnc = getJspConfigPageEncoding(absFileName); // Figure out what type of JSP document and encoding type we are determineSyntaxAndEncoding(absFileName, jarFile, jspConfigPageEnc); if (parent != null) { if (jarFile == null) { compiler.getPageInfo().addDependant(absFileName); } else { compiler.getPageInfo().addDependant(jarFileUrl.toExternalForm() + absFileName.substring(1)); } } if ((isXml && isEncodingSpecifiedInProlog) || isBomPresent) { if (jspConfigPageEnc != null && !jspConfigPageEnc.equals(sourceEnc) && (!jspConfigPageEnc.startsWith("UTF-16") || !sourceEnc.startsWith("UTF-16"))) { err.jspError("jsp.error.prolog_config_encoding_mismatch", sourceEnc, jspConfigPageEnc); } } if (isXml) { // JSP document (XML syntax) // InputStream for jspx page is created and properly closed in parsedPage = JspDocumentParser.parse(this, absFileName, jarFile, parent, isTagFile, directiveOnly, sourceEnc, jspConfigPageEnc, isEncodingSpecifiedInProlog, isBomPresent); } else { InputStreamReader inStreamReader = null; try { inStreamReader = JspUtil.getReader(absFileName, sourceEnc, jarFile, ctxt, err, skip); JspReader jspReader = new JspReader(ctxt, absFileName, sourceEnc, inStreamReader, err); parsedPage = Parser.parse(this, jspReader, parent, isTagFile, directiveOnly, jarFileUrl, sourceEnc, jspConfigPageEnc, isDefaultPageEncoding, isBomPresent); } finally { if (inStreamReader != null) { try { inStreamReader.close(); } catch (Exception any) { } } } } if (jarFile != null) { try { jarFile.close(); } catch (Throwable t) { } } baseDirStack.pop(); return parsedPage; }	public Object clone() { synchronized (membersLock) { Membership clone = new Membership(local, memberComparator); clone.map = (HashMap<MemberImpl, MbrEntry>) map.clone(); clone.members = new MemberImpl[members.length]; System.arraycopy(members, 0, clone.members, 0, members.length); return clone; } }	@Override public Principal authenticate(String username, String clientDigest, String once, String nc, String cnonce, String qop, String realmName, String md5a2) { Principal authenticatedUser = null; for (Realm realm : realms) { if (log.isDebugEnabled()) { log.debug(sm.getString("combinedRealm.authStart", username, realm.getInfo())); } authenticatedUser = realm.authenticate(username, clientDigest, once, nc, cnonce, qop, realmName, md5a2); if (authenticatedUser == null) { if (log.isDebugEnabled()) { log.debug(sm.getString("combinedRealm.authFail", username, realm.getInfo())); } } else { if (log.isDebugEnabled()) { log.debug(sm.getString("combinedRealm.authSucess", username, realm.getInfo())); } break; } } return authenticatedUser; }	@Override public Principal authenticate(String username, String clientDigest, String once, String nc, String cnonce, String qop, String realmName, String md5a2) { if (isLocked(username)) { registerAuthFailure(username); log.warn(sm.getString("lockOutRealm.authLockedUser", username)); return null; } Principal authenticatedUser = super.authenticate(username, clientDigest, once, nc, cnonce, qop, realmName, md5a2); if (authenticatedUser == null) { registerAuthFailure(username); } else { registerAuthSuccess(username); } return authenticatedUser; }	@Override public Principal authenticate(String username, byte[] credentials) { Principal authenticatedUser = null; for (Realm realm : realms) { if (log.isDebugEnabled()) { log.debug(sm.getString("combinedRealm.authStart", username, realm.getInfo())); } authenticatedUser = realm.authenticate(username, credentials); if (authenticatedUser == null) { if (log.isDebugEnabled()) { log.debug(sm.getString("combinedRealm.authFail", username, realm.getInfo())); } } else { if (log.isDebugEnabled()) { log.debug(sm.getString("combinedRealm.authSucess", username, realm.getInfo())); } break; } } return authenticatedUser; }	@Override public Principal authenticate(String username, byte[] credentials) { if (isLocked(username)) { registerAuthFailure(username); log.warn(sm.getString("lockOutRealm.authLockedUser", username)); return null; } Principal authenticatedUser = super.authenticate(username, credentials); if (authenticatedUser == null) { registerAuthFailure(username); } else { registerAuthSuccess(username); } return authenticatedUser; }	public void body(String namespace, String name, String text) throws Exception { String namespaceuri = null; String localpart = text; int colon = text.indexOf(':'); if (colon >= 0) { String prefix = text.substring(0, colon); namespaceuri = digester.findNamespaceURI(prefix); localpart = text.substring(colon + 1); } ContextHandler contextHandler = (ContextHandler) digester.peek(); contextHandler.addSoapHeaders(localpart, namespaceuri); }	public void begin(String namespace, String name, Attributes attributes) throws Exception { digester.getLogger().warn(WebRuleSet.sm.getString("webRuleSet.relativeOrdering")); }	public String getClassLoader() { return classLoader; }	@Override public String getInfo() { return (info); }	@Override public String getInfo() { return (info); }	public String getObjectName() { if (oname != null) { return oname.toString(); } else { return null; } }	public boolean getReadonly() { return (this.readonly); }	public boolean isAccessed() { return this.accessed; }	public boolean isRedirectStreams() { return (this.redirectStreams); }	@Override public final void invoke(Request request, Response response) throws IOException, ServletException { MessageBytes requestPathMB = request.getRequestPathMB(); if ((requestPathMB.startsWithIgnoreCase("/META-INF/", 0)) || (requestPathMB.equalsIgnoreCase("/META-INF")) || (requestPathMB.startsWithIgnoreCase("/WEB-INF/", 0)) || (requestPathMB.equalsIgnoreCase("/WEB-INF"))) { notFound(response); return; } boolean reloaded = false; while (context.getPaused()) { reloaded = true; try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } } if (reloaded && context.getLoader() != null && context.getLoader().getClassLoader() != null) { Thread.currentThread().setContextClassLoader(context.getLoader().getClassLoader()); } Wrapper wrapper = request.getWrapper(); if (wrapper == null) { notFound(response); return; } else if (wrapper.isUnavailable()) { wrapper = (Wrapper) container.findChild(wrapper.getName()); if (wrapper == null) { notFound(response); return; } } Object[] instances = context.getApplicationEventListeners(); ServletRequestEvent event = null; if ((instances != null) && (instances.length > 0)) { event = new ServletRequestEvent(((StandardContext) container).getServletContext(), request.getRequest()); for (int i = 0; i < instances.length; i++) { if (instances[i] == null) continue; if (!(instances[i] instanceof ServletRequestListener)) continue; ServletRequestListener listener = (ServletRequestListener) instances[i]; try { listener.requestInitialized(event); } catch (Throwable t) { container.getLogger().error(sm.getString("standardContext.requestListener.requestInit", instances[i].getClass().getName()), t); ServletRequest sreq = request.getRequest(); sreq.setAttribute(Globals.EXCEPTION_ATTR, t); return; } } } if (request.isAsyncSupported()) { request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported()); } wrapper.getPipeline().getFirst().invoke(request, response); if ((instances != null) && (instances.length > 0)) { for (int i = 0; i < instances.length; i++) { if (instances[i] == null) continue; if (!(instances[i] instanceof ServletRequestListener)) continue; ServletRequestListener listener = (ServletRequestListener) instances[i]; try { listener.requestDestroyed(event); } catch (Throwable t) { container.getLogger().error(sm.getString("standardContext.requestListener.requestDestroy", instances[i].getClass().getName()), t); ServletRequest sreq = request.getRequest(); sreq.setAttribute(Globals.EXCEPTION_ATTR, t); } } } }	@Override public final void invoke(Request request, Response response) throws IOException, ServletException { Host host = request.getHost(); if (host == null) { response.sendError(HttpServletResponse.SC_BAD_REQUEST, sm.getString("standardEngine.noHost", request.getServerName())); return; } if (request.isAsyncSupported()) { request.setAsyncSupported(host.getPipeline().isAsyncSupported()); } host.getPipeline().getFirst().invoke(request, response); }	@Override public final void invoke(Request request, Response response) throws IOException, ServletException { Context context = request.getContext(); if (context == null) { response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, sm.getString("standardHost.noContext")); return; } if (context.getLoader() != null) { // Not started - it should check for availability first Thread.currentThread().setContextClassLoader(context.getLoader().getClassLoader()); } if (request.isAsyncSupported()) { request.setAsyncSupported(context.getPipeline().isAsyncSupported()); } context.getPipeline().getFirst().invoke(request, response); if (Globals.STRICT_SERVLET_COMPLIANCE) { request.getSession(false); } response.setSuspended(false); Throwable t = (Throwable) request.getAttribute(Globals.EXCEPTION_ATTR); if (t != null) { throwable(request, response, t); } else { status(request, response); } Thread.currentThread().setContextClassLoader(StandardHostValve.class.getClassLoader()); }	public byte[] getDataPackage(byte[] data, int offset) { byte[] addr = ((MemberImpl) address).getData(false); XByteBuffer.toBytes(options, data, offset); offset += 4; XByteBuffer.toBytes(timestamp, data, offset); offset += 8; XByteBuffer.toBytes(uniqueId.length, data, offset); offset += 4; System.arraycopy(uniqueId, 0, data, offset, uniqueId.length); offset += uniqueId.length; XByteBuffer.toBytes(addr.length, data, offset); offset += 4; System.arraycopy(addr, 0, data, offset, addr.length); offset += addr.length; XByteBuffer.toBytes(message.getLength(), data, offset); offset += 4; System.arraycopy(message.getBytesDirect(), 0, data, offset, message.getLength()); offset += message.getLength(); return data; }	public int getOptions() { return options; }	public int write(ByteBuffer buf, NioChannel socket, long writeTimeout, MutableInteger lastWrite) throws IOException { SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); if (key == null) throw new IOException("Key no longer registered"); KeyReference reference = new KeyReference(); KeyAttachment att = (KeyAttachment) key.attachment(); int written = 0; boolean timedout = false; int keycount = 1; long time = System.currentTimeMillis(); try { while ((!timedout) && buf.hasRemaining()) { if (keycount > 0) { //only write if we were registered for a write int cnt = socket.write(buf); lastWrite.set(cnt); if (cnt == -1) throw new EOFException(); written += cnt; if (cnt > 0) { time = System.currentTimeMillis(); continue; } } try { if (att.getWriteLatch() == null || att.getWriteLatch().getCount() == 0) att.startWriteLatch(1); poller.add(att, SelectionKey.OP_WRITE, reference); att.awaitWriteLatch(writeTimeout, TimeUnit.MILLISECONDS); } catch (InterruptedException ignore) { Thread.interrupted(); } if (att.getWriteLatch() != null && att.getWriteLatch().getCount() > 0) { keycount = 0; } else { keycount = 1; att.resetWriteLatch(); } if (writeTimeout > 0 && (keycount == 0)) timedout = (System.currentTimeMillis() - time) >= writeTimeout; } if (timedout) throw new SocketTimeoutException(); } finally { poller.remove(att, SelectionKey.OP_WRITE); if (timedout && reference.key != null) { poller.cancelKey(reference.key); } reference.key = null; } return written; }	public static byte[] serialize(Serializable msg) throws IOException { ByteArrayOutputStream outs = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(outs); out.writeObject(msg); out.flush(); byte[] data = outs.toByteArray(); return data; }	public static byte[] toBytes(boolean bool, byte[] data, int offset) { data[offset] = (byte) (bool ? 1 : 0); return data; }	public static void setContentType(HttpServletResponse response, int mode) { if (mode == 0) { response.setContentType("text/html;charset=" + Constants.CHARSET); } else if (mode == 1) { response.setContentType("text/xml;charset=" + Constants.CHARSET); } }	public void addFileset(FileSet fs) { filesets.add(fs); }	public void clear() { bufSize = 0; }	public void memberDisappeared(Member member) { try { hasMembers = channel.hasMembers(); if (log.isInfoEnabled()) log.info("Received member disappeared:" + member); lifecycle.fireLifecycleEvent(BEFORE_MEMBERUNREGISTER_EVENT, member); lifecycle.fireLifecycleEvent(AFTER_MEMBERUNREGISTER_EVENT, member); } catch (Exception x) { log.error("Unable remove cluster node from replication system.", x); } }	public void release() { // No action taken by the default implementation }	public void removeNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback) throws ListenerNotFoundException { removeNotificationListener(listener); }	public long getRecoverySleepTime() { return recoverySleepTime; }	@Override public void setContainer(Container container) { super.setContainer(container); context = (StandardContext) container; }	public void setProxiesHeader(String proxiesHeader) { this.proxiesHeader = proxiesHeader; }	public void setRemoteIpHeader(String remoteIpHeader) { this.remoteIpHeader = remoteIpHeader; }	public void setSSLSupport(SSLSupport sslSupport) { this.sslSupport = sslSupport; }	public void setTodir(File todir) { this.todir = todir; }	@Override public void stop() { this.stopListening(); super.stop(); }	void postCheck() throws JasperException { Iterator<String> iter = nameFromTable.keySet().iterator(); while (iter.hasNext()) { String nameFrom = iter.next(); NameEntry nameEntry = nameTable.get(nameFrom); NameEntry nameFromEntry = nameFromTable.get(nameFrom); Node nameFromNode = nameFromEntry.getNode(); if (nameEntry == null) { err.jspError(nameFromNode, "jsp.error.tagfile.nameFrom.noAttribute", nameFrom); } else { Node node = nameEntry.getNode(); TagAttributeInfo tagAttr = nameEntry.getTagAttributeInfo(); if (!"java.lang.String".equals(tagAttr.getTypeName()) || !tagAttr.isRequired() || tagAttr.canBeRequestTime()) { err.jspError(nameFromNode, "jsp.error.tagfile.nameFrom.badAttribute", nameFrom, Integer.toString(node.getStart().getLineNumber())); } } } }
public StandardContext addContext(StandardHost host, String contextPath, String dir) { silence(contextPath); StandardContext ctx = new StandardContext(); ctx.setPath(contextPath); ctx.setDocBase(dir); ctx.addLifecycleListener(new FixContextListener()); if (host == null) { host = getHost(); } host.addChild(ctx); return ctx; }	public StandardContext addWebapp(StandardHost host, String url, String path) throws ServletException { silence(url); StandardContext ctx = new StandardContext(); ctx.setPath(url); ctx.setDocBase(path); if (defaultRealm == null) { initSimpleAuth(); } ctx.setRealm(defaultRealm); ctx.addLifecycleListener(new DefaultWebXmlListener()); ContextConfig ctxCfg = new ContextConfig(); ctx.addLifecycleListener(ctxCfg); ctxCfg.setDefaultWebXml("org/apache/catalin/startup/NO_DEFAULT_XML"); if (host == null) { host = getHost(); } host.addChild(ctx); return ctx; }	public StandardContext addWebapp(String contextPath, String baseDir) throws ServletException { return addWebapp(getHost(), contextPath, baseDir); }	public StandardWrapper addServlet(String contextPath, String servletName, Servlet servlet) { Container ctx = getHost().findChild(contextPath); return addServlet((StandardContext) ctx, servletName, servlet); }	public void addUser(String user, String pass) { userPass.put(user, pass); }	public void initWebappDefaults(String contextPath) { Container ctx = getHost().findChild(contextPath); initWebappDefaults((StandardContext) ctx); }	public void setHostname(String s) { hostname = s; }
private StringBuilder createLink() { StringBuilder sb = new StringBuilder(); try { sb.append("?cmd=update&mime=txt"); sb.append("&w="); sb.append(URLEncoder.encode(worker, getCharset())); if (isLBMode) { if ((lbRetries != null)) { sb.append("&lr="); sb.append(lbRetries); } if ((lbRecovertime != null)) { sb.append("&lt="); sb.append(lbRecovertime); } if ((lbStickySession != null)) { sb.append("&ls="); sb.append(lbStickySession); } if ((lbForceSession != null)) { sb.append("&lf="); sb.append(lbForceSession); } } else { if ((workerLb != null)) { sb.append("&l="); sb.append(URLEncoder.encode(workerLb, getCharset())); } if ((workerLoadFactor != null)) { sb.append("&wf="); sb.append(workerLoadFactor); } if ((workerDisabled != null)) { sb.append("&wd="); sb.append(workerDisabled); } if ((workerStopped != null)) { sb.append("&ws="); sb.append(workerStopped); } if ((workerRedirect != null)) { sb.append("&wr="); } if ((workerClusterDomain != null)) { sb.append("&wc="); sb.append(URLEncoder.encode(workerClusterDomain, getCharset())); } } } catch (UnsupportedEncodingException e) { throw new BuildException("Invalid 'charset' attribute: " + getCharset()); } return sb; }	private static Method findMethod(Method[] methodsCache, String methodName) { if (methodName.equalsIgnoreCase(INIT_METHOD) && methodsCache[INIT] != null) { return methodsCache[INIT]; } else if (methodName.equalsIgnoreCase(DESTROY_METHOD) && methodsCache[DESTROY] != null) { return methodsCache[DESTROY]; } else if (methodName.equalsIgnoreCase(SERVICE_METHOD) && methodsCache[SERVICE] != null) { return methodsCache[SERVICE]; } else if (methodName.equalsIgnoreCase(DOFILTER_METHOD) && methodsCache[DOFILTER] != null) { return methodsCache[DOFILTER]; } else if (methodName.equalsIgnoreCase(EVENT_METHOD) && methodsCache[EVENT] != null) { return methodsCache[EVENT]; } else if (methodName.equalsIgnoreCase(DOFILTEREVENT_METHOD) && methodsCache[DOFILTEREVENT] != null) { return methodsCache[DOFILTEREVENT]; } return null; }	private static ArrayList<Extension> buildAvailableExtensionsList(ArrayList<ManifestResource> resources) { ArrayList<Extension> availableList = null; Iterator<ManifestResource> it = resources.iterator(); while (it.hasNext()) { ManifestResource mre = it.next(); ArrayList<Extension> list = mre.getAvailableExtensions(); if (list != null) { Iterator<Extension> values = list.iterator(); while (values.hasNext()) { Extension ext = values.next(); if (availableList == null) { availableList = new ArrayList<Extension>(); availableList.add(ext); } else { availableList.add(ext); } } } } return availableList; }	private void parseExpression(String expr) throws ParseException { StringNode currStringNode = null; // We cheat a little and start an artificial pushOpp(null); ExpressionTokenizer et = new ExpressionTokenizer(expr); while (et.hasMoreTokens()) { int token = et.nextToken(); if (token != ExpressionTokenizer.TOKEN_STRING) currStringNode = null; switch(token) { case ExpressionTokenizer.TOKEN_STRING: if (currStringNode == null) { currStringNode = new StringNode(et.getTokenValue()); nodeStack.add(0, currStringNode); } else { currStringNode.value.append(" "); currStringNode.value.append(et.getTokenValue()); } break; case ExpressionTokenizer.TOKEN_AND: pushOpp(new AndNode()); break; case ExpressionTokenizer.TOKEN_OR: pushOpp(new OrNode()); break; case ExpressionTokenizer.TOKEN_NOT: pushOpp(new NotNode()); break; case ExpressionTokenizer.TOKEN_EQ: pushOpp(new EqualNode()); break; case ExpressionTokenizer.TOKEN_NOT_EQ: pushOpp(new NotNode()); // Sneak the regular node in. The NOT will oppStack.add(0, new EqualNode()); break; case ExpressionTokenizer.TOKEN_RBRACE: resolveGroup(); break; case ExpressionTokenizer.TOKEN_LBRACE: pushOpp(null); break; case ExpressionTokenizer.TOKEN_GE: pushOpp(new NotNode()); // Similar stategy to NOT_EQ above, except this oppStack.add(0, new LessThanNode()); break; case ExpressionTokenizer.TOKEN_LE: pushOpp(new NotNode()); // Similar stategy to NOT_EQ above, except this oppStack.add(0, new GreaterThanNode()); break; case ExpressionTokenizer.TOKEN_GT: pushOpp(new GreaterThanNode()); break; case ExpressionTokenizer.TOKEN_LT: pushOpp(new LessThanNode()); break; case ExpressionTokenizer.TOKEN_END: break; } } resolveGroup(); if (nodeStack.size() == 0) { throw new ParseException("No nodes created.", et.getIndex()); } if (nodeStack.size() > 1) { throw new ParseException("Extra nodes created.", et.getIndex()); } if (oppStack.size() != 0) { throw new ParseException("Unused opp nodes exist.", et.getIndex()); } root = nodeStack.get(0); }	private void parseProperties(HttpServletRequest req, XMLWriter generatedXML, String path, int type, Vector<String> propertiesVector) { if (path.toUpperCase().startsWith("/WEB-INF") || path.toUpperCase().startsWith("/META-INF")) return; CacheEntry cacheEntry = resources.lookupCache(path); generatedXML.writeElement(null, "response", XMLWriter.OPENING); String status = new String("HTTP/1.1 " + WebdavStatus.SC_OK + " " + WebdavStatus.getStatusText(WebdavStatus.SC_OK)); generatedXML.writeElement(null, "href", XMLWriter.OPENING); String href = req.getContextPath() + req.getServletPath(); if ((href.endsWith("/")) && (path.startsWith("/"))) href += path.substring(1); else href += path; if ((cacheEntry.context != null) && (!href.endsWith("/"))) href += "/"; generatedXML.writeText(rewriteUrl(href)); generatedXML.writeElement(null, "href", XMLWriter.CLOSING); String resourceName = path; int lastSlash = path.lastIndexOf('/'); if (lastSlash != -1) resourceName = resourceName.substring(lastSlash + 1); switch(type) { case FIND_ALL_PROP: generatedXML.writeElement(null, "propstat", XMLWriter.OPENING); generatedXML.writeElement(null, "prop", XMLWriter.OPENING); generatedXML.writeProperty(null, "creationdate", getISOCreationDate(cacheEntry.attributes.getCreation())); generatedXML.writeElement(null, "displayname", XMLWriter.OPENING); generatedXML.writeData(resourceName); generatedXML.writeElement(null, "displayname", XMLWriter.CLOSING); if (cacheEntry.resource != null) { generatedXML.writeProperty(null, "getlastmodified", FastHttpDateFormat.formatDate(cacheEntry.attributes.getLastModified(), null)); generatedXML.writeProperty(null, "getcontentlength", String.valueOf(cacheEntry.attributes.getContentLength())); String contentType = getServletContext().getMimeType(cacheEntry.name); if (contentType != null) { generatedXML.writeProperty(null, "getcontenttype", contentType); } generatedXML.writeProperty(null, "getetag", cacheEntry.attributes.getETag()); generatedXML.writeElement(null, "resourcetype", XMLWriter.NO_CONTENT); } else { generatedXML.writeElement(null, "resourcetype", XMLWriter.OPENING); generatedXML.writeElement(null, "collection", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "resourcetype", XMLWriter.CLOSING); } generatedXML.writeProperty(null, "source", ""); String supportedLocks = "<lockentry>" + "<lockscope><exclusive/></lockscope>" + "<locktype><write/></locktype>" + "</lockentry>" + "<lockentry>" + "<lockscope><shared/></lockscope>" + "<locktype><write/></locktype>" + "</lockentry>"; generatedXML.writeElement(null, "supportedlock", XMLWriter.OPENING); generatedXML.writeText(supportedLocks); generatedXML.writeElement(null, "supportedlock", XMLWriter.CLOSING); generateLockDiscovery(path, generatedXML); generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText(status); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "propstat", XMLWriter.CLOSING); break; case FIND_PROPERTY_NAMES: generatedXML.writeElement(null, "propstat", XMLWriter.OPENING); generatedXML.writeElement(null, "prop", XMLWriter.OPENING); generatedXML.writeElement(null, "creationdate", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "displayname", XMLWriter.NO_CONTENT); if (cacheEntry.resource != null) { generatedXML.writeElement(null, "getcontentlanguage", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "getcontentlength", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "getcontenttype", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "getetag", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "getlastmodified", XMLWriter.NO_CONTENT); } generatedXML.writeElement(null, "resourcetype", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "source", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "lockdiscovery", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText(status); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "propstat", XMLWriter.CLOSING); break; case FIND_BY_PROPERTY: Vector<String> propertiesNotFound = new Vector<String>(); generatedXML.writeElement(null, "propstat", XMLWriter.OPENING); generatedXML.writeElement(null, "prop", XMLWriter.OPENING); Enumeration<String> properties = propertiesVector.elements(); while (properties.hasMoreElements()) { String property = properties.nextElement(); if (property.equals("creationdate")) { generatedXML.writeProperty(null, "creationdate", getISOCreationDate(cacheEntry.attributes.getCreation())); } else if (property.equals("displayname")) { generatedXML.writeElement(null, "displayname", XMLWriter.OPENING); generatedXML.writeData(resourceName); generatedXML.writeElement(null, "displayname", XMLWriter.CLOSING); } else if (property.equals("getcontentlanguage")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeElement(null, "getcontentlanguage", XMLWriter.NO_CONTENT); } } else if (property.equals("getcontentlength")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeProperty(null, "getcontentlength", (String.valueOf(cacheEntry.attributes.getContentLength()))); } } else if (property.equals("getcontenttype")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeProperty(null, "getcontenttype", getServletContext().getMimeType(cacheEntry.name)); } } else if (property.equals("getetag")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeProperty(null, "getetag", cacheEntry.attributes.getETag()); } } else if (property.equals("getlastmodified")) { if (cacheEntry.context != null) { propertiesNotFound.addElement(property); } else { generatedXML.writeProperty(null, "getlastmodified", FastHttpDateFormat.formatDate(cacheEntry.attributes.getLastModified(), null)); } } else if (property.equals("resourcetype")) { if (cacheEntry.context != null) { generatedXML.writeElement(null, "resourcetype", XMLWriter.OPENING); generatedXML.writeElement(null, "collection", XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "resourcetype", XMLWriter.CLOSING); } else { generatedXML.writeElement(null, "resourcetype", XMLWriter.NO_CONTENT); } } else if (property.equals("source")) { generatedXML.writeProperty(null, "source", ""); } else if (property.equals("supportedlock")) { supportedLocks = "<lockentry>" + "<lockscope><exclusive/></lockscope>" + "<locktype><write/></locktype>" + "</lockentry>" + "<lockentry>" + "<lockscope><shared/></lockscope>" + "<locktype><write/></locktype>" + "</lockentry>"; generatedXML.writeElement(null, "supportedlock", XMLWriter.OPENING); generatedXML.writeText(supportedLocks); generatedXML.writeElement(null, "supportedlock", XMLWriter.CLOSING); } else if (property.equals("lockdiscovery")) { if (!generateLockDiscovery(path, generatedXML)) propertiesNotFound.addElement(property); } else { propertiesNotFound.addElement(property); } } generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText(status); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "propstat", XMLWriter.CLOSING); Enumeration<String> propertiesNotFoundList = propertiesNotFound.elements(); if (propertiesNotFoundList.hasMoreElements()) { status = new String("HTTP/1.1 " + WebdavStatus.SC_NOT_FOUND + " " + WebdavStatus.getStatusText(WebdavStatus.SC_NOT_FOUND)); generatedXML.writeElement(null, "propstat", XMLWriter.OPENING); generatedXML.writeElement(null, "prop", XMLWriter.OPENING); while (propertiesNotFoundList.hasMoreElements()) { generatedXML.writeElement(null, propertiesNotFoundList.nextElement(), XMLWriter.NO_CONTENT); } generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText(status); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "propstat", XMLWriter.CLOSING); } break; } generatedXML.writeElement(null, "response", XMLWriter.CLOSING); }	protected B2CConverter getURIConverter() { return URIConverter; }	protected byte[] serializeDeltaRequest(DeltaSession session, DeltaRequest deltaRequest) throws IOException { try { session.lock(); return deltaRequest.serialize(); } finally { session.unlock(); } }	@Override protected Principal getPrincipal(String username) { DirContext context = null; Principal principal = null; try { context = open(); try { principal = getPrincipal(context, username); } catch (CommunicationException e) { containerLog.warn(sm.getString("jndiRealm.exception"), e); if (context != null) close(context); context = open(); principal = getPrincipal(context, username); } catch (ServiceUnavailableException e) { containerLog.warn(sm.getString("jndiRealm.exception"), e); if (context != null) close(context); context = open(); principal = getPrincipal(context, username); } release(context); return (principal); } catch (NamingException e) { containerLog.error(sm.getString("jndiRealm.exception"), e); if (context != null) close(context); return (null); } }	protected String blanksToString(String couldBeBlank, String subForBlanks) { return (("".equals(couldBeBlank) || couldBeBlank == null) ? subForBlanks : couldBeBlank); }	protected String getPathWithoutFileName(String servletPath) { String retVal = null; int lastSlash = servletPath.lastIndexOf('/'); if (lastSlash >= 0) { retVal = servletPath.substring(0, lastSlash + 1); } return retVal; }	protected String jmxSet(MBeanServerConnection jmxServerConnection, String name) throws Exception { Object realValue; if (type != null) { realValue = convertStringToType(value, type); } else { if (isConvert()) { String mType = getMBeanAttributeType(jmxServerConnection, name, attribute); realValue = convertStringToType(value, mType); } else realValue = value; } jmxServerConnection.setAttribute(new ObjectName(name), new Attribute(attribute, realValue)); return null; }	protected String reload(String path) { StringWriter stringWriter = new StringWriter(); PrintWriter printWriter = new PrintWriter(stringWriter); super.reload(printWriter, path); return stringWriter.toString(); }	protected boolean checkIfHeaders(HttpServletRequest request, HttpServletResponse response, ResourceAttributes resourceAttributes) throws IOException { return checkIfMatch(request, response, resourceAttributes) && checkIfModifiedSince(request, response, resourceAttributes) && checkIfNoneMatch(request, response, resourceAttributes) && checkIfUnmodifiedSince(request, response, resourceAttributes); }	protected boolean filter(String name) { if (name == null) return false; String packageName = null; int pos = name.lastIndexOf('.'); if (pos != -1) packageName = name.substring(0, pos); else return false; for (int i = 0; i < packageTriggers.length; i++) { if (packageName.startsWith(packageTriggers[i])) return true; } return false; }	protected boolean postParseRequest(org.apache.coyote.Request req, Request request, org.apache.coyote.Response res, Response response) throws Exception { if (!req.scheme().isNull()) { request.setSecure(req.scheme().equals("https")); } else { // use connector scheme and secure configuration, (defaults to req.scheme().setString(connector.getScheme()); request.setSecure(connector.getSecure()); } // FIXME: the code below doesnt belongs to here, // this is only have sense // in Http11, not in ajp13.. // At this point the Host header has been processed. String proxyName = connector.getProxyName(); int proxyPort = connector.getProxyPort(); if (proxyPort != 0) { req.setServerPort(proxyPort); } if (proxyName != null) { req.serverName().setString(proxyName); } parseSessionId(req, request); MessageBytes decodedURI = req.decodedURI(); decodedURI.duplicate(req.requestURI()); if (decodedURI.getType() == MessageBytes.T_BYTES) { ByteChunk uriBB = decodedURI.getByteChunk(); int semicolon = uriBB.indexOf(';', 0); if (semicolon > 0) { decodedURI.setBytes(uriBB.getBuffer(), uriBB.getStart(), semicolon); } try { req.getURLDecoder().convert(decodedURI, false); } catch (IOException ioe) { res.setStatus(400); res.setMessage("Invalid URI: " + ioe.getMessage()); return false; } if (!normalize(req.decodedURI())) { res.setStatus(400); res.setMessage("Invalid URI"); return false; } convertURI(decodedURI, request); if (!checkNormalize(req.decodedURI())) { res.setStatus(400); res.setMessage("Invalid URI character encoding"); return false; } } else { // The URL is chars or String, and has been sent using an in-memory // protocol handler, we have to assume the URL has been properly decodedURI.toChars(); CharChunk uriCC = decodedURI.getCharChunk(); int semicolon = uriCC.indexOf(';'); if (semicolon > 0) { decodedURI.setChars(uriCC.getBuffer(), uriCC.getStart(), semicolon); } } String principal = req.getRemoteUser().toString(); if (principal != null) { request.setUserPrincipal(new CoyotePrincipal(principal)); } String authtype = req.getAuthType().toString(); if (authtype != null) { request.setAuthType(authtype); } MessageBytes serverName; if (connector.getUseIPVHosts()) { serverName = req.localName(); if (serverName.isNull()) { res.action(ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE, null); } } else { serverName = req.serverName(); } if (request.isAsyncStarted()) { //TODO SERVLET3 - async request.getMappingData().recycle(); } connector.getMapper().map(serverName, decodedURI, request.getMappingData()); request.setContext((Context) request.getMappingData().context); request.setWrapper((Wrapper) request.getMappingData().wrapper); if (!connector.getAllowTrace() && req.method().equalsIgnoreCase("TRACE")) { Wrapper wrapper = request.getWrapper(); String header = null; if (wrapper != null) { String[] methods = wrapper.getServletMethods(); if (methods != null) { for (int i = 0; i < methods.length; i++) { if ("TRACE".equals(methods[i])) { continue; } if (header == null) { header = methods[i]; } else { header += ", " + methods[i]; } } } } res.setStatus(405); res.addHeader("Allow", header); res.setMessage("TRACE method is not allowed"); return false; } MessageBytes redirectPathMB = request.getMappingData().redirectPath; if (!redirectPathMB.isNull()) { String redirectPath = urlEncoder.encode(redirectPathMB.toString()); String query = request.getQueryString(); if (request.isRequestedSessionIdFromURL()) { // This is not optimal, but as this is not very common, it redirectPath = redirectPath + ";" + Globals.SESSION_PARAMETER_NAME + "=" + request.getRequestedSessionId(); } if (query != null) { // This is not optimal, but as this is not very common, it redirectPath = redirectPath + "?" + query; } response.sendRedirect(redirectPath); return false; } if (!request.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.URL)) { request.setRequestedSessionId(null); request.setRequestedSessionURL(false); } parseSessionCookiesId(req, request); parseSessionSslId(request); return true; }	protected boolean restoreRequest(Request request, Session session) throws IOException { SavedRequest saved = (SavedRequest) session.getNote(Constants.FORM_REQUEST_NOTE); session.removeNote(Constants.FORM_REQUEST_NOTE); session.removeNote(Constants.FORM_PRINCIPAL_NOTE); if (saved == null) return (false); request.clearCookies(); Iterator<Cookie> cookies = saved.getCookies(); while (cookies.hasNext()) { request.addCookie(cookies.next()); } MimeHeaders rmh = request.getCoyoteRequest().getMimeHeaders(); rmh.recycle(); boolean cachable = "GET".equalsIgnoreCase(saved.getMethod()) || "HEAD".equalsIgnoreCase(saved.getMethod()); Iterator<String> names = saved.getHeaderNames(); while (names.hasNext()) { String name = names.next(); if (!("If-Modified-Since".equalsIgnoreCase(name) || (cachable && "If-None-Match".equalsIgnoreCase(name)))) { Iterator<String> values = saved.getHeaderValues(name); while (values.hasNext()) { rmh.addValue(name).setString(values.next()); } } } request.clearLocales(); Iterator<Locale> locales = saved.getLocales(); while (locales.hasNext()) { request.addLocale(locales.next()); } request.getCoyoteRequest().getParameters().recycle(); request.getCoyoteRequest().getParameters().setQueryStringEncoding(request.getConnector().getURIEncoding()); if ("POST".equalsIgnoreCase(saved.getMethod())) { ByteChunk body = saved.getBody(); if (body != null) { request.getCoyoteRequest().action(ActionCode.ACTION_REQ_SET_BODY_REPLAY, body); MessageBytes contentType = MessageBytes.newInstance(); String savedContentType = saved.getContentType(); if (savedContentType == null) { savedContentType = "application/x-www-form-urlencoded"; } contentType.setString(savedContentType); request.getCoyoteRequest().setContentType(contentType); } } request.getCoyoteRequest().method().setString(saved.getMethod()); request.getCoyoteRequest().queryString().setString(saved.getQueryString()); request.getCoyoteRequest().requestURI().setString(saved.getRequestURI()); return (true); }	protected boolean write(SelectionKey key) throws IOException { if ((!isConnected()) || (this.socketChannel == null && this.dataChannel == null)) { throw new IOException("NioSender is not connected, this should not occur."); } if (current != null) { if (remaining > 0) { //weve written everything, or we are starting a new package int byteswritten = isUdpBased() ? dataChannel.write(writebuf) : socketChannel.write(writebuf); if (byteswritten == -1) throw new EOFException(); remaining -= byteswritten; if (remaining < 0) { remaining = 0; } } return (remaining == 0); } return true; }	protected ArrayList<String> getRoles(String username) { PreparedStatement stmt = null; ResultSet rs = null; // Number of tries is the numebr of attempts to connect to the database // during this login attempt (if we need to open the database) // This needs rewritten wuth better pooling support, the existing code // needs signature changes since the Prepared statements needs cached // with the connections. // The code below will try twice if there is a SQLException so the // connection may try to be opened again. On normal conditions (including int numberOfTries = 2; while (numberOfTries > 0) { try { open(); try { ArrayList<String> roleList = new ArrayList<String>(); stmt = roles(dbConnection, username); rs = stmt.executeQuery(); while (rs.next()) { String role = rs.getString(1); if (null != role) { roleList.add(role.trim()); } } rs.close(); rs = null; return (roleList); } finally { if (rs != null) { try { rs.close(); } catch (SQLException e) { containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet")); } } dbConnection.commit(); } } catch (SQLException e) { containerLog.error(sm.getString("jdbcRealm.exception"), e); if (dbConnection != null) close(dbConnection); } numberOfTries--; } return (null); }	@Override protected synchronized String getPassword(String username) { String dbCredentials = null; PreparedStatement stmt = null; ResultSet rs = null; // Number of tries is the numebr of attempts to connect to the database // during this login attempt (if we need to open the database) // This needs rewritten wuth better pooling support, the existing code // needs signature changes since the Prepared statements needs cached // with the connections. // The code below will try twice if there is a SQLException so the // connection may try to be opened again. On normal conditions (including int numberOfTries = 2; while (numberOfTries > 0) { try { open(); try { stmt = credentials(dbConnection, username); rs = stmt.executeQuery(); if (rs.next()) { dbCredentials = rs.getString(1); } rs.close(); rs = null; if (dbCredentials == null) { return (null); } dbCredentials = dbCredentials.trim(); return dbCredentials; } finally { if (rs != null) { try { rs.close(); } catch (SQLException e) { containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet")); } } dbConnection.commit(); } } catch (SQLException e) { containerLog.error(sm.getString("jdbcRealm.exception"), e); if (dbConnection != null) close(dbConnection); } numberOfTries--; } return (null); }	@Override public Class<?> findClass(String name) throws ClassNotFoundException { if (log.isDebugEnabled()) log.debug(" findClass(" + name + ")"); if (!started) { throw new ClassNotFoundException(name); } if (securityManager != null) { int i = name.lastIndexOf('.'); if (i >= 0) { try { if (log.isTraceEnabled()) log.trace(" securityManager.checkPackageDefinition"); securityManager.checkPackageDefinition(name.substring(0, i)); } catch (Exception se) { if (log.isTraceEnabled()) log.trace(" -->Exception-->ClassNotFoundException", se); throw new ClassNotFoundException(name, se); } } } // Ask our superclass to locate this class, if possible Class<?> clazz = null; try { if (log.isTraceEnabled()) log.trace(" findClassInternal(" + name + ")"); try { clazz = findClassInternal(name); } catch (ClassNotFoundException cnfe) { if (!hasExternalRepositories) { throw cnfe; } } catch (AccessControlException ace) { log.warn("WebappClassLoader.findClassInternal(" + name + ") security exception: " + ace.getMessage(), ace); throw new ClassNotFoundException(name, ace); } catch (RuntimeException e) { if (log.isTraceEnabled()) log.trace(" -->RuntimeException Rethrown", e); throw e; } if ((clazz == null) && hasExternalRepositories) { try { clazz = super.findClass(name); } catch (AccessControlException ace) { log.warn("WebappClassLoader.findClassInternal(" + name + ") security exception: " + ace.getMessage(), ace); throw new ClassNotFoundException(name, ace); } catch (RuntimeException e) { if (log.isTraceEnabled()) log.trace(" -->RuntimeException Rethrown", e); throw e; } } if (clazz == null) { if (log.isDebugEnabled()) log.debug(" --> Returning ClassNotFoundException"); throw new ClassNotFoundException(name); } } catch (ClassNotFoundException e) { if (log.isTraceEnabled()) log.trace(" --> Passing on ClassNotFoundException"); throw e; } if (log.isTraceEnabled()) log.debug(" Returning class " + clazz); if (log.isTraceEnabled()) { ClassLoader cl; if (Globals.IS_SECURITY_ENABLED) { cl = AccessController.doPrivileged(new PrivilegedGetClassLoader(clazz)); } else { cl = clazz.getClassLoader(); } log.debug(" Loaded by " + cl.toString()); } return (clazz); }	protected void changeRequestSessionID(Request request, Response response, String sessionId, String newSessionID) { request.setRequestedSessionId(newSessionID); if (request.isRequestedSessionIdFromCookie()) setNewSessionCookie(request, response, newSessionID); if (sessionIdAttribute != null && !"".equals(sessionIdAttribute)) { if (log.isDebugEnabled()) { log.debug(sm.getString("jvmRoute.set.orignalsessionid", sessionIdAttribute, sessionId)); } request.setAttribute(sessionIdAttribute, sessionId); } }	protected void changeSessionID(Request request, Response response, String sessionId, String newSessionID, Session catalinaSession) { lifecycle.fireLifecycleEvent("Before session migration", catalinaSession); catalinaSession.setId(newSessionID); if (catalinaSession instanceof DeltaSession) ((DeltaSession) catalinaSession).resetDeltaRequest(); changeRequestSessionID(request, response, sessionId, newSessionID); if (getCluster() != null) { ClusterManager manager = (ClusterManager) catalinaSession.getManager(); sendSessionIDClusterBackup(manager, request, sessionId, newSessionID); } lifecycle.fireLifecycleEvent("After session migration", catalinaSession); if (log.isDebugEnabled()) { log.debug(sm.getString("jvmRoute.changeSession", sessionId, newSessionID)); } }	protected void closeRedirector() { try { if (redirectOutput) { redirector.complete(); } } catch (IOException ioe) { log("Error closing redirector: " + ioe.getMessage(), Project.MSG_ERR); } redirectOutStream = null; redirectOutPrintStream = null; redirectErrStream = null; redirectErrPrintStream = null; }	protected void closeSocket() { if (isConnected()) { if (socket != null) { try { socket.close(); } catch (IOException x) { } finally { socket = null; soOut = null; soIn = null; } } setRequestCount(0); setConnected(false); if (log.isDebugEnabled()) log.debug(sm.getString("IDataSender.closeSocket", getAddress().getHostAddress(), new Integer(getPort()), new Long(0))); } }	protected void createMBeans(Connector connector) throws Exception { // Create the MBean for the Connnector itself // if (log.isDebugEnabled()) // log.debug("Creating MBean for Connector " + connector); // MBeanUtils.createMBean(connector); }	protected void createProperty(Object result) { if (resultproperty != null) { createProperty(resultproperty, result); } }	protected void drainSocket() throws Exception { InputStream in = socket.getInputStream(); byte[] buf = new byte[1024]; int length = in.read(buf); while (length >= 0) { int count = reader.append(buf, 0, length, true); if (count > 0) execute(reader); length = in.read(buf); } }	protected void forwardToErrorPage(Request request, Response response, LoginConfig config) { RequestDispatcher disp = context.getServletContext().getRequestDispatcher(config.getErrorPage()); try { disp.forward(request.getRequest(), response.getResponse()); } catch (Throwable t) { log.warn("Unexpected error forwarding to error page", t); } }	@Override protected void handleErrorFlush(String output) { handleErrorOutput(output); redirectErrPrintStream.flush(); }	protected void handleOutput(String output, int priority) { if (priority == Project.MSG_ERR) { handleErrorOutput(output); } else { handleOutput(output); } }	protected void pushMessage(byte[] data, boolean reconnect, boolean waitForAck) throws IOException { keepalive(); if (reconnect) closeSocket(); if (!isConnected()) openSocket(); soOut.write(data); soOut.flush(); if (waitForAck) waitForAck(); SenderState.getSenderState(getDestination()).setReady(); }	protected void sendCrossContextSession(CatalinaCluster containerCluster) { Object sessions = crossContextSessions.get(); if (sessions != null && sessions instanceof List && ((List<Session>) sessions).size() > 0) { for (Iterator<Session> iter = ((List<Session>) sessions).iterator(); iter.hasNext(); ) { Session session = iter.next(); if (log.isDebugEnabled()) log.debug(sm.getString("ReplicationValve.crossContext.sendDelta", session.getManager().getContainer().getName())); sendMessage(session, (ClusterManager) session.getManager(), containerCluster); if (doStatistics()) { nrOfCrossContextSendRequests++; } } } }	protected void serverinfo(PrintWriter writer) { if (debug >= 1) log("serverinfo"); try { StringBuilder props = new StringBuilder(); props.append("OK - Server info"); props.append("\nTomcat Version: "); props.append(ServerInfo.getServerInfo()); props.append("\nOS Name: "); props.append(System.getProperty("os.name")); props.append("\nOS Version: "); props.append(System.getProperty("os.version")); props.append("\nOS Architecture: "); props.append(System.getProperty("os.arch")); props.append("\nJVM Version: "); props.append(System.getProperty("java.runtime.version")); props.append("\nJVM Vendor: "); props.append(System.getProperty("java.vm.vendor")); writer.println(props.toString()); } catch (Throwable t) { getServletContext().log("ManagerServlet.serverinfo", t); writer.println(sm.getString("managerServlet.exception", t.toString())); } }	protected void sessionExpired(String id) { counterSend_EVT_SESSION_EXPIRED++; SessionMessage msg = new SessionMessageImpl(getName(), SessionMessage.EVT_SESSION_EXPIRED, null, id, id + "-EXPIRED-MSG"); if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.expire", getName(), id)); send(msg); }	protected String[] findCGI(String pathInfo, String webAppRootDir, String contextPath, String servletPath, String cgiPathPrefix) { String path = null; String name = null; String scriptname = null; String cginame = ""; if ((webAppRootDir != null) && (webAppRootDir.lastIndexOf(File.separator) == (webAppRootDir.length() - 1))) { webAppRootDir = webAppRootDir.substring(0, (webAppRootDir.length() - 1)); } if (cgiPathPrefix != null) { webAppRootDir = webAppRootDir + File.separator + cgiPathPrefix; } if (debug >= 2) { log("findCGI: path=" + pathInfo + ", " + webAppRootDir); } File currentLocation = new File(webAppRootDir); StringTokenizer dirWalker = new StringTokenizer(pathInfo, "/"); if (debug >= 3) { log("findCGI: currentLoc=" + currentLocation); } while (!currentLocation.isFile() && dirWalker.hasMoreElements()) { if (debug >= 3) { log("findCGI: currentLoc=" + currentLocation); } String nextElement = (String) dirWalker.nextElement(); currentLocation = new File(currentLocation, nextElement); cginame = cginame + "/" + nextElement; } if (!currentLocation.isFile()) { return new String[] { null, null, null, null }; } else { if (debug >= 2) { log("findCGI: FOUND cgi at " + currentLocation); } path = currentLocation.getAbsolutePath(); name = currentLocation.getName(); if (".".equals(contextPath)) { scriptname = servletPath; } else { scriptname = contextPath + servletPath; } if (!servletPath.equals(cginame)) { scriptname = scriptname + cginame; } } if (debug >= 1) { log("findCGI calc: name=" + name + ", path=" + path + ", scriptname=" + scriptname + ", cginame=" + cginame); } return new String[] { path, scriptname, cginame, name }; }	protected void setupSocket() throws IOException { if (mcastBindAddress != null) { try { log.info("Attempting to bind the multicast socket to " + address + ":" + port); socket = new MulticastSocket(new InetSocketAddress(address, port)); } catch (BindException e) { log.info("Binding to multicast address, failed. Binding to port only."); socket = new MulticastSocket(port); } } else { socket = new MulticastSocket(port); } socket.setLoopbackMode(localLoopbackDisabled); if (mcastBindAddress != null) { if (log.isInfoEnabled()) log.info("Setting multihome multicast interface to:" + mcastBindAddress); socket.setInterface(mcastBindAddress); } if (mcastSoTimeout <= 0) mcastSoTimeout = (int) sendFrequency; if (log.isInfoEnabled()) log.info("Setting cluster mcast soTimeout to " + mcastSoTimeout); socket.setSoTimeout(mcastSoTimeout); if (mcastTTL >= 0) { if (log.isInfoEnabled()) log.info("Setting cluster mcast TTL to " + mcastTTL); socket.setTimeToLive(mcastTTL); } }	public InputSource resolveEntity(String publicId, String systemId) { context.log(sm.getString("webdavservlet.enternalEntityIgnored", publicId, systemId)); return new InputSource(new StringReader("Ignored external entity")); }	public Iterator<Group> getGroups() { synchronized (groups) { return (groups.values().iterator()); } }	public Cookie[] getCookies() { if (!cookiesParsed) parseCookies(); return cookies; }	@Override public Principal authenticate(String username, String credentials) { return authenticate(username, new JAASCallbackHandler(this, username, credentials)); }	public Cookie[] getCookies() { if (request == null) { throw new IllegalStateException(sm.getString("requestFacade.nullRequest")); } Cookie[] ret = null; if (SecurityUtil.isPackageProtectionEnabled()) { ret = AccessController.doPrivileged(new GetCookiesPrivilegedAction()); if (ret != null) { ret = ret.clone(); } } else { ret = request.getCookies(); } return ret; }	public Map<String, String[]> getParameterMap() { if (request == null) { throw new IllegalStateException(sm.getString("requestFacade.nullRequest")); } if (Globals.IS_SECURITY_ENABLED) { return AccessController.doPrivileged(new GetParameterMapPrivilegedAction()); } else { return request.getParameterMap(); } }	public String getSessionIdAttribute() { return sessionIdAttribute; }	@Override public String jmxExecute(MBeanServerConnection jmxServerConnection) throws Exception { if (getName() == null) { throw new BuildException("Must specify a 'name'"); } return jmxQuery(jmxServerConnection, getName()); }	public String padLeft(String str, int maxChars) { String result = str; int charsToAdd = maxChars - str.length(); if (charsToAdd > 0) { result = repeat(' ', charsToAdd) + str; } return result; }	public boolean getHeartbeat() { return heartbeat; }	boolean hasRole(Principal principal, String role) { if ((principal == null) || (role == null) || !(principal instanceof GenericPrincipal)) return (false); GenericPrincipal gp = (GenericPrincipal) principal; boolean result = gp.hasRole(role); if (log.isDebugEnabled()) { String name = principal.getName(); if (result) log.debug(sm.getString("realmBase.hasRoleSuccess", name, role)); else log.debug(sm.getString("realmBase.hasRoleFailure", name, role)); } return (result); }	public boolean isAccessed() { return this.accessed; }	public boolean isResolveHosts() { return resolveHosts; }	public boolean isUserInRole(String role) { if (userPrincipal == null) return (false); if (context == null) return (false); Realm realm = context.getRealm(); if (realm == null) return (false); if (wrapper != null) { String realRole = wrapper.findSecurityReference(role); if ((realRole != null) && realm.hasRole(userPrincipal, realRole)) return (true); } return (realm.hasRole(userPrincipal, role)); }	@Override public boolean keepalive() { boolean result = false; for (Iterator<Entry<Member, NioSender>> i = nioSenders.entrySet().iterator(); i.hasNext(); ) { Map.Entry<Member, NioSender> entry = i.next(); NioSender sender = entry.getValue(); if (sender.keepalive()) { i.remove(); result = true; } else { try { sender.read(null); } catch (IOException x) { sender.disconnect(); sender.reset(); i.remove(); result = true; } catch (Exception x) { log.warn("Error during keepalive test for sender:" + sender, x); } } } if (result) try { selector.selectNow(); } catch (Exception ignore) { } return result; }	public boolean login() throws LoginException { if (callbackHandler == null) throw new LoginException("No CallbackHandler specified"); Callback[] callbacks = new Callback[9]; callbacks[0] = new NameCallback("Username: "); callbacks[1] = new PasswordCallback("Password: ", false); callbacks[2] = new TextInputCallback("nonce"); callbacks[3] = new TextInputCallback("nc"); callbacks[4] = new TextInputCallback("cnonce"); callbacks[5] = new TextInputCallback("qop"); callbacks[6] = new TextInputCallback("realmName"); callbacks[7] = new TextInputCallback("md5a2"); callbacks[8] = new TextInputCallback("authMethod"); String username = null; String password = null; String nonce = null; String nc = null; String cnonce = null; String qop = null; String realmName = null; String md5a2 = null; String authMethod = null; try { callbackHandler.handle(callbacks); username = ((NameCallback) callbacks[0]).getName(); password = new String(((PasswordCallback) callbacks[1]).getPassword()); nonce = ((TextInputCallback) callbacks[2]).getText(); nc = ((TextInputCallback) callbacks[3]).getText(); cnonce = ((TextInputCallback) callbacks[4]).getText(); qop = ((TextInputCallback) callbacks[5]).getText(); realmName = ((TextInputCallback) callbacks[6]).getText(); md5a2 = ((TextInputCallback) callbacks[7]).getText(); authMethod = ((TextInputCallback) callbacks[8]).getText(); } catch (IOException e) { throw new LoginException(e.toString()); } catch (UnsupportedCallbackException e) { throw new LoginException(e.toString()); } if (authMethod == null) { principal = super.authenticate(username, password); } else if (authMethod.equals(Constants.DIGEST_METHOD)) { principal = super.authenticate(username, password, nonce, nc, cnonce, qop, realmName, md5a2); } else if (authMethod.equals(Constants.CERT_METHOD)) { principal = super.getPrincipal(username); } else { throw new LoginException("Unknown authentication method"); } log.debug("login " + username + " " + principal); if (principal != null) { return (true); } else { throw new FailedLoginException("Username or password is incorrect"); } }	public int getMaxActiveSessions() { return (this.maxActiveSessions); }	public int getMaxActiveSessions() { return (this.maxActiveSessions); }	public int getRequiredExtensionCount() { return (requiredExtensions != null) ? requiredExtensions.size() : 0; }	@Override public int readLine(byte[] b, int off, int len) throws IOException { return super.readLine(b, off, len); }	protected Comparator<Session> getComparator(String sortBy) { Comparator<Session> comparator = null; if ("CreationTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(session.getCreationTime()); } }; } else if ("id".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { @Override public Comparable<String> getComparableObject(Session session) { return session.getId(); } }; } else if ("LastAccessedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(session.getLastAccessedTime()); } }; } else if ("MaxInactiveInterval".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(session.getMaxInactiveInterval()); } }; } else if ("new".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Boolean>() { @Override public Comparable<Boolean> getComparableObject(Session session) { return Boolean.valueOf(session.getSession().isNew()); } }; } else if ("locale".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { @Override public Comparable<String> getComparableObject(Session session) { return JspHelper.guessDisplayLocaleFromSession(session); } }; } else if ("user".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { @Override public Comparable<String> getComparableObject(Session session) { return JspHelper.guessDisplayUserFromSession(session); } }; } else if ("UsedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getUsedTimeForSession(session)); } }; } else if ("InactiveTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getInactiveTimeForSession(session)); } }; } else if ("TTL".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { @Override public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getTTLForSession(session)); } }; } return comparator; }	public static String URLDecode(byte[] bytes, String enc, boolean isQuery) { if (bytes == null) return (null); int len = bytes.length; int ix = 0; int ox = 0; while (ix < len) { byte b = bytes[ix++]; if (b == '+' && isQuery) { b = (byte) ' '; } else if (b == '%') { b = (byte) ((convertHexDigit(bytes[ix++]) << 4) + convertHexDigit(bytes[ix++])); } bytes[ox++] = b; } if (enc != null) { try { return new String(bytes, 0, ox, enc); } catch (Exception e) { e.printStackTrace(); } } return new String(bytes, 0, ox); }	public static byte[] encode(byte[] binaryData) { int lengthDataBits = binaryData.length * EIGHTBIT; int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP; int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP; byte[] encodedData = null; if (fewerThan24bits != 0) { encodedData = new byte[(numberTriplets + 1) * 4]; } else { encodedData = new byte[numberTriplets * 4]; } byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0; int encodedIndex = 0; int dataIndex = 0; int i = 0; for (i = 0; i < numberTriplets; i++) { dataIndex = i * 3; b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; b3 = binaryData[dataIndex + 2]; l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); encodedIndex = i * 4; byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; //log.debug( "val2 = " + val2 ); //log.debug( "k4 = " + (k<<4) ); encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3]; encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f]; } dataIndex = i * 3; encodedIndex = i * 4; if (fewerThan24bits == EIGHTBIT) { b1 = binaryData[dataIndex]; k = (byte) (b1 & 0x03); //log.debug("b1=" + b1); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4]; encodedData[encodedIndex + 2] = PAD; encodedData[encodedIndex + 3] = PAD; } }	public static synchronized boolean validateApplication(DirContext dirContext, StandardContext context) throws IOException { String appName = context.getPath(); ArrayList<ManifestResource> appManifestResources = new ArrayList<ManifestResource>(); if (dirContext == null) return false; InputStream inputStream = null; try { NamingEnumeration<Binding> wne = dirContext.listBindings("/META-INF/"); Binding binding = wne.nextElement(); if (binding.getName().toUpperCase().equals("MANIFEST.MF")) { Resource resource = (Resource) dirContext.lookup("/META-INF/" + binding.getName()); inputStream = resource.streamContent(); Manifest manifest = new Manifest(inputStream); inputStream.close(); inputStream = null; ManifestResource mre = new ManifestResource(sm.getString("extensionValidator.web-application-manifest"), manifest, ManifestResource.WAR); appManifestResources.add(mre); } } catch (NamingException nex) { // Application does not contain a MANIFEST.MF file } catch (NoSuchElementException nse) { // Application does not contain a MANIFEST.MF file } finally { if (inputStream != null) { try { inputStream.close(); } catch (Throwable t) { // Ignore } } } NamingEnumeration<Binding> ne = null; try { ne = dirContext.listBindings("WEB-INF/lib/"); while ((ne != null) && ne.hasMoreElements()) { Binding binding = ne.nextElement(); if (!binding.getName().toLowerCase().endsWith(".jar")) { continue; } Object obj = dirContext.lookup("/WEB-INF/lib/" + binding.getName()); if (!(obj instanceof Resource)) { continue; } Resource resource = (Resource) obj; Manifest jmanifest = getManifest(resource.streamContent()); if (jmanifest != null) { ManifestResource mre = new ManifestResource(binding.getName(), jmanifest, ManifestResource.APPLICATION); appManifestResources.add(mre); } } } catch (NamingException nex) { // Jump out of the check for this application because it // has no resources } return validateManifestResources(appName, appManifestResources); }	public static void addSystemResource(File jarFile) throws IOException { Manifest manifest = getManifest(new FileInputStream(jarFile)); if (manifest != null) { ManifestResource mre = new ManifestResource(jarFile.getAbsolutePath(), manifest, ManifestResource.SYSTEM); containerManifestResources.add(mre); } }	public static void doAsPrivilege(final String methodName, final Filter targetObject, final Class<?>[] targetType, final Object[] targetArguments, Principal principal) throws java.lang.Exception { Method method = null; Method[] methodsCache = null; if (objectCache.containsKey(targetObject)) { methodsCache = objectCache.get(targetObject); method = findMethod(methodsCache, methodName); if (method == null) { method = createMethodAndCacheIt(methodsCache, methodName, targetObject, targetType); } } else { method = createMethodAndCacheIt(methodsCache, methodName, targetObject, targetType); } execute(method, targetObject, targetArguments, principal); }	@Override public synchronized Principal authenticate(String username, String credentials) { // Number of tries is the numebr of attempts to connect to the database // during this login attempt (if we need to open the database) // This needs rewritten wuth better pooling support, the existing code // needs signature changes since the Prepared statements needs cached // with the connections. // The code below will try twice if there is a SQLException so the // connection may try to be opened again. On normal conditions (including int numberOfTries = 2; while (numberOfTries > 0) { try { open(); Principal principal = authenticate(dbConnection, username, credentials); return (principal); } catch (SQLException e) { containerLog.error(sm.getString("jdbcRealm.exception"), e); if (dbConnection != null) close(dbConnection); } numberOfTries--; } return null; }	public synchronized void sendMessage(Member[] destination, ChannelMessage msg) throws ChannelException { long start = System.currentTimeMillis(); this.setUdpBased((msg.getOptions() & Channel.SEND_OPTIONS_UDP) == Channel.SEND_OPTIONS_UDP); byte[] data = XByteBuffer.createDataPackage((ChannelData) msg); NioSender[] senders = setupForSend(destination); connect(senders); setData(senders, data); int remaining = senders.length; ChannelException cx = null; try { long delta = System.currentTimeMillis() - start; boolean waitForAck = (Channel.SEND_OPTIONS_USE_ACK & msg.getOptions()) == Channel.SEND_OPTIONS_USE_ACK; while ((remaining > 0) && (delta < getTimeout())) { try { remaining -= doLoop(selectTimeout, getMaxRetryAttempts(), waitForAck, msg); } catch (Exception x) { int faulty = (cx == null) ? 0 : cx.getFaultyMembers().length; if (cx == null) { if (x instanceof ChannelException) cx = (ChannelException) x; else cx = new ChannelException("Parallel NIO send failed.", x); } else { if (x instanceof ChannelException) cx.addFaultyMember(((ChannelException) x).getFaultyMembers()); } if (faulty < cx.getFaultyMembers().length) remaining -= (cx.getFaultyMembers().length - faulty); } if (cx != null && cx.getFaultyMembers().length == remaining) throw cx; delta = System.currentTimeMillis() - start; } if (remaining > 0) { ChannelException cxtimeout = new ChannelException("Operation has timed out(" + getTimeout() + " ms.)."); if (cx == null) cx = new ChannelException("Operation has timed out(" + getTimeout() + " ms.)."); for (int i = 0; i < senders.length; i++) { if (!senders[i].isComplete()) cx.addFaultyMember(senders[i].getDestination(), cxtimeout); } throw cx; } else if (cx != null) { throw cx; } } catch (Exception x) { try { this.disconnect(); } catch (Exception ignore) { } if (x instanceof ChannelException) throw (ChannelException) x; else throw new ChannelException(x); } }	public void add(Member member) { // no op, senders created upon demans }	/** * Add the specified Cookie to those that will be included with * this Response. * * @param cookie Cookie to be added */ public void addCookieInternal(final Cookie cookie) { if (isCommitted()) return; final StringBuffer sb = new StringBuffer(); //web application code can receive a IllegalArgumentException //from the appendCookieValue invokation if (SecurityUtil.isPackageProtectionEnabled()) { AccessController.doPrivileged(new PrivilegedAction<Void>() { } } }	protected AccessLogElement[] createLogElements() { List<AccessLogElement> list = new ArrayList<AccessLogElement>(); boolean replace = false; StringBuilder buf = new StringBuilder(); for (int i = 0; i < pattern.length(); i++) { char ch = pattern.charAt(i); if (replace) { if ('{' == ch) { StringBuilder name = new StringBuilder(); int j = i + 1; for (; j < pattern.length() && '}' != pattern.charAt(j); j++) { name.append(pattern.charAt(j)); } if (j + 1 < pattern.length()) { j++; list.add(createAccessLogElement(name.toString(), pattern.charAt(j))); i = j; /* Since we walked more than one character */ } else { // D'oh - end of string - pretend we never did this list.add(createAccessLogElement(ch)); } } else { list.add(createAccessLogElement(ch)); } replace = false; } else if (ch == '%') { replace = true; list.add(new StringElement(buf.toString())); buf = new StringBuilder(); } else { buf.append(ch); } } if (buf.length() > 0) { list.add(new StringElement(buf.toString())); } return list.toArray(new AccessLogElement[0]); }	public Iterator<String> getHandlers() { return handlers.keySet().iterator(); }	public void fileModified(File newWar) { try { File deployWar = new File(getDeployDir(), newWar.getName()); copy(newWar, deployWar); String contextName = getContextName(deployWar); if (log.isInfoEnabled()) log.info("Installing webapp[" + contextName + "] from " + deployWar.getAbsolutePath()); try { remove(contextName, false); } catch (Exception x) { log.error("No removal", x); } install(contextName, deployWar.toURI().toURL()); } catch (Exception x) { log.error("Unable to install WAR file", x); } }	@Override public void invoke(Request request, Response response) throws IOException, ServletException { long totalstart = 0; if (doStatistics()) { totalstart = System.currentTimeMillis(); } if (primaryIndicator) { createPrimaryIndicator(request); } Context context = request.getContext(); boolean isCrossContext = context != null && context instanceof StandardContext && ((StandardContext) context).getCrossContext(); try { if (isCrossContext) { if (log.isDebugEnabled()) log.debug(sm.getString("ReplicationValve.crossContext.add")); crossContextSessions.set(new ArrayList<DeltaSession>()); } getNext().invoke(request, response); if (context != null) { Manager manager = context.getManager(); if (manager != null && manager instanceof ClusterManager) { ClusterManager clusterManager = (ClusterManager) manager; CatalinaCluster containerCluster = (CatalinaCluster) getContainer().getCluster(); if (containerCluster == null) { if (log.isWarnEnabled()) log.warn(sm.getString("ReplicationValve.nocluster")); return; } if (containerCluster.getManager(clusterManager.getName()) == null) return; if (containerCluster.hasMembers()) { sendReplicationMessage(request, totalstart, isCrossContext, clusterManager, containerCluster); } else { resetReplicationRequest(request, isCrossContext); } } } } finally { if (isCrossContext) { if (log.isDebugEnabled()) log.debug(sm.getString("ReplicationValve.crossContext.remove")); // crossContextSessions.remove() only exist at Java 5 crossContextSessions.set(null); } } }	@Override public void invoke(Request request, Response response) throws IOException, ServletException { getNext().invoke(request, response); if (request.isComet() && !response.isClosed()) { // Start tracking this connection, since this is a HttpSession session = request.getSession(true); cometRequests.add(request); synchronized (session) { Request[] requests = (Request[]) session.getAttribute(cometRequestsAttribute); if (requests == null) { requests = new Request[1]; requests[0] = request; session.setAttribute(cometRequestsAttribute, requests); } else { Request[] newRequests = new Request[requests.length + 1]; for (int i = 0; i < requests.length; i++) { newRequests[i] = requests[i]; } newRequests[requests.length] = request; session.setAttribute(cometRequestsAttribute, newRequests); } } } }	public void list(HttpServletRequest request, HttpServletResponse response, String message) throws IOException { String newNonce = generateNonce(); request.getSession().setAttribute(NONCE_SESSION, newNonce); PrintWriter writer = response.getWriter(); writer.print(Constants.HTML_HEADER_SECTION); Object[] args = new Object[2]; args[0] = request.getContextPath(); args[1] = sm.getString("htmlHostManagerServlet.title"); writer.print(MessageFormat.format(Constants.BODY_HEADER_SECTION, args)); args = new Object[3]; args[0] = sm.getString("htmlHostManagerServlet.messageLabel"); if (message == null || message.length() == 0) { args[1] = "OK"; } else { args[1] = RequestUtil.filter(message); } writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args)); args = new Object[9]; args[0] = sm.getString("htmlHostManagerServlet.manager"); args[1] = response.encodeURL(request.getContextPath() + "/html/list"); args[2] = sm.getString("htmlHostManagerServlet.list"); args[3] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlHostManagerServlet.helpHtmlManagerFile")); args[4] = sm.getString("htmlHostManagerServlet.helpHtmlManager"); args[5] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlHostManagerServlet.helpManagerFile")); args[6] = sm.getString("htmlHostManagerServlet.helpManager"); args[7] = response.encodeURL("/manager/status"); args[8] = sm.getString("statusServlet.title"); writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args)); args = new Object[3]; args[0] = sm.getString("htmlHostManagerServlet.hostName"); args[1] = sm.getString("htmlHostManagerServlet.hostAliases"); args[2] = sm.getString("htmlHostManagerServlet.hostTasks"); writer.print(MessageFormat.format(HOSTS_HEADER_SECTION, args)); // Hosts Row Section Container[] children = engine.findChildren(); String[] hostNames = new String[children.length]; for (int i = 0; i < children.length; i++) hostNames[i] = children[i].getName(); TreeMap<String, String> sortedHostNamesMap = new TreeMap<String, String>(); for (int i = 0; i < hostNames.length; i++) { String displayPath = hostNames[i]; sortedHostNamesMap.put(displayPath, hostNames[i]); } String hostsStart = sm.getString("htmlHostManagerServlet.hostsStart"); String hostsStop = sm.getString("htmlHostManagerServlet.hostsStop"); String hostsRemove = sm.getString("htmlHostManagerServlet.hostsRemove"); Iterator<Map.Entry<String, String>> iterator = sortedHostNamesMap.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry<String, String> entry = iterator.next(); String hostName = entry.getKey(); Host host = (Host) engine.findChild(hostName); if (host != null) { args = new Object[2]; args[0] = RequestUtil.filter(hostName); String[] aliases = host.findAliases(); StringBuilder buf = new StringBuilder(); if (aliases.length > 0) { buf.append(aliases[0]); for (int j = 1; j < aliases.length; j++) { buf.append(", ").append(aliases[j]); } } if (buf.length() == 0) { buf.append("&nbsp;"); args[1] = buf.toString(); } else { args[1] = RequestUtil.filter(buf.toString()); } writer.print(MessageFormat.format(HOSTS_ROW_DETAILS_SECTION, args)); args = new Object[7]; args[0] = response.encodeURL(request.getContextPath() + "/html/start?name=" + URLEncoder.encode(hostName, "UTF-8")); args[1] = hostsStart; args[2] = response.encodeURL(request.getContextPath() + "/html/stop?name=" + URLEncoder.encode(hostName, "UTF-8")); args[3] = hostsStop; args[4] = response.encodeURL(request.getContextPath() + "/html/remove?name=" + URLEncoder.encode(hostName, "UTF-8")); args[5] = hostsRemove; args[6] = newNonce; if (host == this.host) { writer.print(MessageFormat.format(MANAGER_HOST_ROW_BUTTON_SECTION, args)); } else { writer.print(MessageFormat.format(HOSTS_ROW_BUTTON_SECTION, args)); } } } args = new Object[7]; args[0] = sm.getString("htmlHostManagerServlet.addTitle"); args[1] = sm.getString("htmlHostManagerServlet.addHost"); args[2] = response.encodeURL(request.getContextPath() + "/html/add"); args[3] = sm.getString("htmlHostManagerServlet.addName"); args[4] = sm.getString("htmlHostManagerServlet.addAliases"); args[5] = sm.getString("htmlHostManagerServlet.addAppBase"); args[6] = newNonce; writer.print(MessageFormat.format(ADD_SECTION_START, args)); args = new Object[3]; args[0] = sm.getString("htmlHostManagerServlet.addAutoDeploy"); args[1] = "autoDeploy"; args[2] = "checked"; writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args)); args[0] = sm.getString("htmlHostManagerServlet.addDeployOnStartup"); args[1] = "deployOnStartup"; args[2] = "checked"; writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args)); args[0] = sm.getString("htmlHostManagerServlet.addDeployXML"); args[1] = "deployXML"; args[2] = "checked"; writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args)); args[0] = sm.getString("htmlHostManagerServlet.addUnpackWARs"); args[1] = "unpackWARs"; args[2] = "checked"; writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args)); args[0] = sm.getString("htmlHostManagerServlet.addXmlNamespaceAware"); args[1] = "xmlNamespaceAware"; args[2] = ""; writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args)); args[0] = sm.getString("htmlHostManagerServlet.addXmlValidation"); args[1] = "xmlValidation"; args[2] = ""; writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args)); args[0] = sm.getString("htmlHostManagerServlet.addManager"); args[1] = "manager"; args[2] = "checked"; writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args)); args = new Object[1]; args[0] = sm.getString("htmlHostManagerServlet.addButton"); writer.print(MessageFormat.format(ADD_SECTION_END, args)); args = new Object[7]; args[0] = sm.getString("htmlHostManagerServlet.serverTitle"); args[1] = sm.getString("htmlHostManagerServlet.serverVersion"); args[2] = sm.getString("htmlHostManagerServlet.serverJVMVersion"); args[3] = sm.getString("htmlHostManagerServlet.serverJVMVendor"); args[4] = sm.getString("htmlHostManagerServlet.serverOSName"); args[5] = sm.getString("htmlHostManagerServlet.serverOSVersion"); args[6] = sm.getString("htmlHostManagerServlet.serverOSArch"); writer.print(MessageFormat.format(Constants.SERVER_HEADER_SECTION, args)); args = new Object[6]; args[0] = ServerInfo.getServerInfo(); args[1] = System.getProperty("java.runtime.version"); args[2] = System.getProperty("java.vm.vendor"); args[3] = System.getProperty("os.name"); args[4] = System.getProperty("os.version"); args[5] = System.getProperty("os.arch"); writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args)); writer.print(Constants.HTML_TAIL_SECTION); writer.flush(); writer.close(); }	public void listBeans(PrintWriter writer, String qry) { Set<ObjectName> names = null; try { names = mBeanServer.queryNames(new ObjectName(qry), null); writer.println("OK - Number of results: " + names.size()); writer.println(); } catch (Exception e) { writer.println("Error - " + e.toString()); return; } Iterator<ObjectName> it = names.iterator(); while (it.hasNext()) { ObjectName oname = it.next(); writer.println("Name: " + oname.toString()); try { MBeanInfo minfo = mBeanServer.getMBeanInfo(oname); String code = minfo.getClassName(); if ("org.apache.commons.modeler.BaseModelMBean".equals(code)) { code = (String) mBeanServer.getAttribute(oname, "modelerType"); } writer.println("modelerType: " + code); MBeanAttributeInfo[] attrs = minfo.getAttributes(); Object value = null; for (int i = 0; i < attrs.length; i++) { if (!attrs[i].isReadable()) continue; if (!isSupported(attrs[i].getType())) continue; String attName = attrs[i].getName(); if (attName.indexOf("=") >= 0 || attName.indexOf(":") >= 0 || attName.indexOf(" ") >= 0) { continue; } try { value = mBeanServer.getAttribute(oname, attName); } catch (Throwable t) { log("Error getting attribute " + oname + " " + attName + " " + t.toString()); continue; } if (value == null) continue; if ("modelerType".equals(attName)) continue; String valueString = value.toString(); writer.println(attName + ": " + escape(valueString)); } } catch (Exception e) { // Ignore } writer.println(); } }	public void memberDisappeared(Member member) { try { hasMembers = channel.hasMembers(); if (log.isInfoEnabled()) log.info("Received member disappeared:" + member); lifecycle.fireLifecycleEvent(BEFORE_MEMBERUNREGISTER_EVENT, member); lifecycle.fireLifecycleEvent(AFTER_MEMBERUNREGISTER_EVENT, member); } catch (Exception x) { log.error("Unable remove cluster node from replication system.", x); } }	public void remove(String contextPath, boolean undeploy) throws IOException { if (log.isInfoEnabled()) log.info("Cluster wide remove of web app " + contextPath); Member localMember = getCluster().getLocalMember(); UndeployMessage msg = new UndeployMessage(localMember, System.currentTimeMillis(), "Undeploy:" + contextPath + ":" + System.currentTimeMillis(), contextPath, undeploy); if (log.isDebugEnabled()) log.debug("Send cluster wide undeployment from " + contextPath); cluster.send(msg); if (undeploy) { try { if (!isServiced(contextPath)) { addServiced(contextPath); try { remove(contextPath); } finally { removeServiced(contextPath); } } else log.error("Local remove from " + contextPath + "failed, other manager has app in service!"); } catch (Exception ex) { log.error("local remove from " + contextPath + " failed", ex); } } }	public void removeAttribute(String name) { Object value = null; boolean found = false; if (readOnlyAttributes.containsKey(name)) { return; } if (name.startsWith("org.apache.tomcat.")) { coyoteRequest.getAttributes().remove(name); } found = attributes.containsKey(name); if (found) { value = attributes.get(name); attributes.remove(name); } else { return; } Object[] listeners = context.getApplicationEventListeners(); if ((listeners == null) || (listeners.length == 0)) return; ServletRequestAttributeEvent event = new ServletRequestAttributeEvent(context.getServletContext(), getRequest(), name, value); for (int i = 0; i < listeners.length; i++) { if (!(listeners[i] instanceof ServletRequestAttributeListener)) continue; ServletRequestAttributeListener listener = (ServletRequestAttributeListener) listeners[i]; try { listener.attributeRemoved(event); } catch (Throwable t) { context.getLogger().error(sm.getString("coyoteRequest.attributeEvent"), t); attributes.put(Globals.EXCEPTION_ATTR, t); } } }	public void removeConnector(String name) throws Exception { ObjectName oname = new ObjectName(name); Service service = getService(oname); String port = oname.getKeyProperty("port"); Connector[] conns = service.findConnectors(); for (int i = 0; i < conns.length; i++) { String connAddress = String.valueOf(conns[i].getProperty("address")); String connPort = "" + conns[i].getPort(); if ((connAddress == null) && port.equals(connPort)) { service.removeConnector(conns[i]); conns[i].destroy(); break; } if (port.equals(connPort)) { service.removeConnector(conns[i]); conns[i].destroy(); break; } } }	public void removeContext(String contextName) throws Exception { ObjectName oname = new ObjectName(contextName); String domain = oname.getDomain(); StandardService service = (StandardService) getService(oname); Engine engine = (Engine) service.getContainer(); String name = oname.getKeyProperty("name"); name = name.substring(2); int i = name.indexOf("/"); String hostName = name.substring(0, i); String path = name.substring(i); ObjectName deployer = new ObjectName(domain + ":type=Deployer,host=" + hostName); String pathStr = getPathStr(path); if (mserver.isRegistered(deployer)) { mserver.invoke(deployer, "addServiced", new Object[] { pathStr }, new String[] { "java.lang.String" }); mserver.invoke(deployer, "unmanageApp", new Object[] { pathStr }, new String[] { "java.lang.String" }); mserver.invoke(deployer, "removeServiced", new Object[] { pathStr }, new String[] { "java.lang.String" }); } else { log.warn("Deployer not found for " + hostName); Host host = (Host) engine.findChild(hostName); Context context = (Context) host.findChild(pathStr); host.removeChild(context); if (context instanceof StandardContext) try { ((StandardContext) context).destroy(); } catch (Exception e) { log.warn("Error during context [" + context.getName() + "] destroy ", e); } } }	public void removeHost(String name) throws Exception { ObjectName oname = new ObjectName(name); String hostName = oname.getKeyProperty("host"); Service service = getService(oname); Engine engine = (Engine) service.getContainer(); Host host = (Host) engine.findChild(hostName); if (host != null) { if (host instanceof StandardHost) ((StandardHost) host).destroy(); else engine.removeChild(host); } }	public void removeLoader(String name) throws Exception { ObjectName oname = new ObjectName(name); ContainerBase container = getParentContainerFromChild(oname); container.setLoader(null); }	public void removeManager(String name) throws Exception { ObjectName oname = new ObjectName(name); ContainerBase container = getParentContainerFromChild(oname); container.setManager(null); }	public void removeRealm(String name) throws Exception { ObjectName oname = new ObjectName(name); ContainerBase container = getParentContainerFromChild(oname); container.setRealm(null); }	public void save(Session session) throws IOException { ObjectOutputStream oos = null; ByteArrayOutputStream bos = null; ByteArrayInputStream bis = null; InputStream in = null; synchronized (this) { int numberOfTries = 2; while (numberOfTries > 0) { Connection _conn = getConnection(); if (_conn == null) { return; } // If sessions already exist in DB, remove and insert again. // TODO: remove(session.getIdInternal()); try { bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(new BufferedOutputStream(bos)); ((StandardSession) session).writeObjectData(oos); oos.close(); oos = null; byte[] obs = bos.toByteArray(); int size = obs.length; bis = new ByteArrayInputStream(obs, 0, size); in = new BufferedInputStream(bis, size); if (preparedSaveSql == null) { String saveSql = "INSERT INTO " + sessionTable + " (" + sessionIdCol + ", " + sessionAppCol + ", " + sessionDataCol + ", " + sessionValidCol + ", " + sessionMaxInactiveCol + ", " + sessionLastAccessedCol + ") VALUES (?, ?, ?, ?, ?, ?)"; preparedSaveSql = _conn.prepareStatement(saveSql); } preparedSaveSql.setString(1, session.getIdInternal()); preparedSaveSql.setString(2, getName()); preparedSaveSql.setBinaryStream(3, in, size); preparedSaveSql.setString(4, session.isValid() ? "1" : "0"); preparedSaveSql.setInt(5, session.getMaxInactiveInterval()); preparedSaveSql.setLong(6, session.getLastAccessedTime()); preparedSaveSql.execute(); numberOfTries = 0; } catch (SQLException e) { manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException", e)); if (dbConnection != null) close(dbConnection); } catch (IOException e) { // Ignore } finally { if (oos != null) { oos.close(); } if (bis != null) { bis.close(); } if (in != null) { in.close(); } release(_conn); } numberOfTries--; } } if (manager.getContainer().getLogger().isDebugEnabled()) { manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".saving", session.getIdInternal(), sessionTable)); } }	@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException { super.setAttribute(attribute); ContextEnvironment ce = null; try { ce = (ContextEnvironment) getManagedResource(); } catch (InstanceNotFoundException e) { throw new MBeanException(e); } catch (InvalidTargetObjectTypeException e) { throw new MBeanException(e); } // cannot use side-efects. It's removed and added back each time NamingResources nr = ce.getNamingResources(); nr.removeEnvironment(ce.getName()); nr.addEnvironment(ce); }	@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException { super.setAttribute(attribute); ContextResourceLink crl = null; try { crl = (ContextResourceLink) getManagedResource(); } catch (InstanceNotFoundException e) { throw new MBeanException(e); } catch (InvalidTargetObjectTypeException e) { throw new MBeanException(e); } // cannot use side-efects. It's removed and added back each time NamingResources nr = crl.getNamingResources(); nr.removeResourceLink(crl.getName()); nr.addResourceLink(crl); }	@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException { if (attribute == null) throw new RuntimeOperationsException(new IllegalArgumentException("Attribute is null"), "Attribute is null"); String name = attribute.getName(); Object value = attribute.getValue(); if (name == null) throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"), "Attribute name is null"); ContextResource cr = null; try { cr = (ContextResource) getManagedResource(); } catch (InstanceNotFoundException e) { throw new MBeanException(e); } catch (InvalidTargetObjectTypeException e) { throw new MBeanException(e); } if ("auth".equals(name)) { cr.setAuth((String) value); } else if ("description".equals(name)) { cr.setDescription((String) value); } else if ("name".equals(name)) { cr.setName((String) value); } else if ("scope".equals(name)) { cr.setScope((String) value); } else if ("type".equals(name)) { cr.setType((String) value); } else { cr.setProperty(name, "" + value); } // cannot use side-efects. It's removed and added back each time NamingResources nr = cr.getNamingResources(); nr.removeResource(cr.getName()); nr.addResource(cr); }	public void setAttribute(String name, Object value) { if (name == null) throw new IllegalArgumentException(sm.getString("coyoteRequest.setAttribute.namenull")); if (value == null) { removeAttribute(name); return; } if (name.equals(Globals.DISPATCHER_TYPE_ATTR)) { internalDispatcherType = (DispatcherType) value; return; } else if (name.equals(Globals.DISPATCHER_REQUEST_PATH_ATTR)) { requestDispatcherPath = value; return; } if (name.equals(Globals.ASYNC_SUPPORTED_ATTR)) { this.asyncSupported = (Boolean) value; } Object oldValue = null; boolean replaced = false; if (readOnlyAttributes.containsKey(name)) { return; } oldValue = attributes.put(name, value); if (oldValue != null) { replaced = true; } if (name.startsWith("org.apache.tomcat.")) { coyoteRequest.setAttribute(name, value); } Object[] listeners = context.getApplicationEventListeners(); if ((listeners == null) || (listeners.length == 0)) return; ServletRequestAttributeEvent event = null; if (replaced) event = new ServletRequestAttributeEvent(context.getServletContext(), getRequest(), name, oldValue); else event = new ServletRequestAttributeEvent(context.getServletContext(), getRequest(), name, value); for (int i = 0; i < listeners.length; i++) { if (!(listeners[i] instanceof ServletRequestAttributeListener)) continue; ServletRequestAttributeListener listener = (ServletRequestAttributeListener) listeners[i]; try { if (replaced) { listener.attributeReplaced(event); } else { listener.attributeAdded(event); } } catch (Throwable t) { context.getLogger().error(sm.getString("coyoteRequest.attributeEvent"), t); attributes.put(Globals.EXCEPTION_ATTR, t); } } }	public void setCluster(CatalinaCluster cluster) { this.cluster = cluster; }	public void setContentType(String type) { if (isCommitted()) return; if (included) return; if (usingWriter) { if (type != null) { int index = type.indexOf(";"); if (index != -1) { type = type.substring(0, index); } } } coyoteResponse.setContentType(type); if (type != null) { int index = type.indexOf(";"); if (index != -1) { int len = type.length(); index++; while (index < len && Character.isSpace(type.charAt(index))) { index++; } if (index + 7 < len && type.charAt(index) == 'c' && type.charAt(index + 1) == 'h' && type.charAt(index + 2) == 'a' && type.charAt(index + 3) == 'r' && type.charAt(index + 4) == 's' && type.charAt(index + 5) == 'e' && type.charAt(index + 6) == 't' && type.charAt(index + 7) == '=') { isCharacterEncodingSet = true; } } } }	public org.apache.coyote.Request getCoyoteRequest() { return (this.coyoteRequest); }	public void setRejectedSessions(int rejectedSessions) { this.rejectedSessions = rejectedSessions; }	@Override public long getTimestamp() { return serializationTimestamp; }
private Object getProxyPortQNameClass(Object[] args) throws ServiceException { QName name = (QName) args[0]; String nameString = name.getLocalPart(); Class serviceendpointClass = (Class) args[1]; for (Iterator ports = service.getPorts(); ports.hasNext(); ) { QName portName = (QName) ports.next(); String portnameString = portName.getLocalPart(); if (portnameString.equals(nameString)) { return service.getPort(name, serviceendpointClass); } } throw new ServiceException("Port-component-ref : " + name + " not found"); }	private Remote getProxyPortClass(Object[] args) throws ServiceException { Class serviceendpointClass = (Class) args[0]; if (this.portComponentRef == null) return service.getPort(serviceendpointClass); QName portname = (QName) this.portComponentRef.get(serviceendpointClass.getName()); if (portname != null) { return service.getPort(portname, serviceendpointClass); } else { return service.getPort(serviceendpointClass); } }	private String getSOAPLocation(Port port) { String endpoint = null; List extensions = port.getExtensibilityElements(); for (Iterator i = extensions.iterator(); i.hasNext(); ) { ExtensibilityElement ext = (ExtensibilityElement) i.next(); if (ext instanceof SOAPAddress) { SOAPAddress addr = (SOAPAddress) ext; endpoint = addr.getLocationURI(); } } return endpoint; }	private void initHandlerChain(QName portName, HandlerRegistry handlerRegistry, HandlerInfo handlerref, ArrayList soaprolesToAdd) { HandlerChain handlerList = (HandlerChain) handlerRegistry.getHandlerChain(portName); handlerList.add(handlerref); String[] soaprolesRegistered = handlerList.getRoles(); String[] soaproles = new String[soaprolesRegistered.length + soaprolesToAdd.size()]; int i; for (i = 0; i < soaprolesRegistered.length; i++) soaproles[i] = soaprolesRegistered[i]; for (int j = 0; j < soaprolesToAdd.size(); j++) soaproles[i + j] = (String) soaprolesToAdd.get(j); handlerList.setRoles(soaproles); handlerRegistry.setHandlerChain(portName, handlerList); }	public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception { if (obj instanceof ServiceRef) { Reference ref = (Reference) obj; ClassLoader tcl = Thread.currentThread().getContextClassLoader(); if (tcl == null) tcl = this.getClass().getClassLoader(); ServiceFactory factory = ServiceFactory.newInstance(); javax.xml.rpc.Service service = null; RefAddr tmp = ref.get(ServiceRef.SERVICE_INTERFACE); String serviceInterface = null; if (tmp != null) serviceInterface = (String) tmp.getContent(); tmp = ref.get(ServiceRef.WSDL); String wsdlRefAddr = null; if (tmp != null) wsdlRefAddr = (String) tmp.getContent(); Hashtable portComponentRef = new Hashtable(); QName serviceQname = null; tmp = ref.get(ServiceRef.SERVICE_LOCAL_PART); if (tmp != null) { String serviceLocalPart = (String) tmp.getContent(); tmp = ref.get(ServiceRef.SERVICE_NAMESPACE); if (tmp == null) { serviceQname = new QName(serviceLocalPart); } else { String serviceNamespace = (String) tmp.getContent(); serviceQname = new QName(serviceNamespace, serviceLocalPart); } } Class serviceInterfaceClass = null; if (serviceInterface == null) { if (serviceQname == null) { throw new NamingException("Could not create service-ref instance"); } try { if (wsdlRefAddr == null) { service = factory.createService(serviceQname); } else { service = factory.createService(new URL(wsdlRefAddr), serviceQname); } } catch (Throwable t) { NamingException ex = new NamingException("Could not create service"); ex.initCause(t); throw ex; } } else { try { serviceInterfaceClass = tcl.loadClass(serviceInterface); } catch (ClassNotFoundException e) { NamingException ex = new NamingException("Could not load service Interface"); ex.initCause(e); throw ex; } if (serviceInterfaceClass == null) { throw new NamingException("Could not load service Interface"); } try { if (wsdlRefAddr == null) { if (!Service.class.isAssignableFrom(serviceInterfaceClass)) { throw new NamingException("service Interface should extend javax.xml.rpc.Service"); } service = factory.loadService(serviceInterfaceClass); } else { service = factory.loadService(new URL(wsdlRefAddr), serviceInterfaceClass, new Properties()); } } catch (Throwable t) { NamingException ex = new NamingException("Could not create service"); ex.initCause(t); throw ex; } } if (service == null) { throw new NamingException("Cannot create service object"); } serviceQname = service.getServiceName(); serviceInterfaceClass = service.getClass(); if (wsdlRefAddr != null) { try { WSDLFactory wsdlfactory = WSDLFactory.newInstance(); WSDLReader reader = wsdlfactory.newWSDLReader(); reader.setFeature("javax.wsdl.importDocuments", true); Definition def = reader.readWSDL((new URL(wsdlRefAddr)).toExternalForm()); javax.wsdl.Service wsdlservice = def.getService(serviceQname); Map ports = wsdlservice.getPorts(); Method m = serviceInterfaceClass.getMethod("setEndpointAddress", new Class[] { java.lang.String.class, java.lang.String.class }); for (Iterator i = ports.keySet().iterator(); i.hasNext(); ) { String portName = (String) i.next(); Port port = wsdlservice.getPort(portName); String endpoint = getSOAPLocation(port); m.invoke(service, new Object[] { port.getName(), endpoint }); portComponentRef.put(endpoint, new QName(port.getName())); } } catch (Throwable t) { NamingException ex = new NamingException("Error while reading Wsdl File"); ex.initCause(t); throw ex; } } ServiceProxy proxy = new ServiceProxy(service); for (int i = 0; i < ref.size(); i++) if (ServiceRef.SERVICEENDPOINTINTERFACE.equals(ref.get(i).getType())) { String serviceendpoint = ""; String portlink = ""; serviceendpoint = (String) ref.get(i).getContent(); if (ServiceRef.PORTCOMPONENTLINK.equals(ref.get(i + 1).getType())) { i++; portlink = (String) ref.get(i).getContent(); } portComponentRef.put(serviceendpoint, new QName(portlink)); } proxy.setPortComponentRef(portComponentRef); Class[] interfaces = null; Class[] serviceInterfaces = serviceInterfaceClass.getInterfaces(); if (serviceInterfaceClass != null) { interfaces = new Class[serviceInterfaces.length + 1]; for (int i = 0; i < serviceInterfaces.length; i++) { interfaces[i] = serviceInterfaces[i]; } } else { interfaces = new Class[1]; } interfaces[interfaces.length - 1] = javax.xml.rpc.Service.class; Object proxyInstance = null; try { proxyInstance = Proxy.newProxyInstance(tcl, interfaces, proxy); } catch (IllegalArgumentException e) { proxyInstance = Proxy.newProxyInstance(tcl, serviceInterfaces, proxy); } if (((ServiceRef) ref).getHandlersSize() > 0) { HandlerRegistry handlerRegistry = service.getHandlerRegistry(); ArrayList soaproles = new ArrayList(); while (((ServiceRef) ref).getHandlersSize() > 0) { HandlerRef handler = ((ServiceRef) ref).getHandler(); HandlerInfo handlerref = new HandlerInfo(); tmp = handler.get(HandlerRef.HANDLER_CLASS); if ((tmp == null) || (tmp.getContent() == null)) break; Class handlerClass = null; try { handlerClass = tcl.loadClass((String) tmp.getContent()); } catch (ClassNotFoundException e) { break; } // Load all datas relative to the handler : SOAPHeaders, config init element, ArrayList headers = new ArrayList(); Hashtable config = new Hashtable(); ArrayList portNames = new ArrayList(); for (int i = 0; i < handler.size(); i++) if (HandlerRef.HANDLER_LOCALPART.equals(handler.get(i).getType())) { String localpart = ""; String namespace = ""; localpart = (String) handler.get(i).getContent(); if (HandlerRef.HANDLER_NAMESPACE.equals(handler.get(i + 1).getType())) { i++; namespace = (String) handler.get(i).getContent(); } QName header = new QName(namespace, localpart); headers.add(header); } else if (HandlerRef.HANDLER_PARAMNAME.equals(handler.get(i).getType())) { String paramName = ""; String paramValue = ""; paramName = (String) handler.get(i).getContent(); if (HandlerRef.HANDLER_PARAMVALUE.equals(handler.get(i + 1).getType())) { i++; paramValue = (String) handler.get(i).getContent(); } config.put(paramName, paramValue); } else if (HandlerRef.HANDLER_SOAPROLE.equals(handler.get(i).getType())) { String soaprole = ""; soaprole = (String) handler.get(i).getContent(); soaproles.add(soaprole); } else if (HandlerRef.HANDLER_PORTNAME.equals(handler.get(i).getType())) { String portName = ""; portName = (String) handler.get(i).getContent(); portNames.add(portName); } handlerref.setHandlerClass(handlerClass); handlerref.setHeaders((QName[]) headers.toArray(new QName[headers.size()])); handlerref.setHandlerConfig(config); if (!portNames.isEmpty()) { Iterator iter = portNames.iterator(); while (iter.hasNext()) initHandlerChain(new QName((String) iter.next()), handlerRegistry, handlerref, soaproles); } else { Enumeration e = portComponentRef.elements(); while (e.hasMoreElements()) initHandlerChain((QName) e.nextElement(), handlerRegistry, handlerref, soaproles); } } } return proxyInstance; } return null; }
private String getCombinedPath() { if (servletPath == null) { return null; } if (pathInfo == null) { return servletPath; } return servletPath + pathInfo; }	private void doForward(ServletRequest request, ServletResponse response) throws ServletException, IOException { if (response.isCommitted()) { throw new IllegalStateException(sm.getString("applicationDispatcher.forward.ise")); } try { response.resetBuffer(); } catch (IllegalStateException e) { throw e; } State state = new State(request, response, false); if (Globals.STRICT_SERVLET_COMPLIANCE) { checkSameObjects(request, response); } wrapResponse(state); if ((servletPath == null) && (pathInfo == null)) { ApplicationHttpRequest wrequest = (ApplicationHttpRequest) wrapRequest(state); HttpServletRequest hrequest = state.hrequest; wrequest.setRequestURI(hrequest.getRequestURI()); wrequest.setContextPath(hrequest.getContextPath()); wrequest.setServletPath(hrequest.getServletPath()); wrequest.setPathInfo(hrequest.getPathInfo()); wrequest.setQueryString(hrequest.getQueryString()); processRequest(request, response, state); } else { ApplicationHttpRequest wrequest = (ApplicationHttpRequest) wrapRequest(state); String contextPath = context.getPath(); HttpServletRequest hrequest = state.hrequest; if (hrequest.getAttribute(Globals.FORWARD_REQUEST_URI_ATTR) == null) { wrequest.setAttribute(Globals.FORWARD_REQUEST_URI_ATTR, hrequest.getRequestURI()); wrequest.setAttribute(Globals.FORWARD_CONTEXT_PATH_ATTR, hrequest.getContextPath()); wrequest.setAttribute(Globals.FORWARD_SERVLET_PATH_ATTR, hrequest.getServletPath()); wrequest.setAttribute(Globals.FORWARD_PATH_INFO_ATTR, hrequest.getPathInfo()); wrequest.setAttribute(Globals.FORWARD_QUERY_STRING_ATTR, hrequest.getQueryString()); } wrequest.setContextPath(contextPath); wrequest.setRequestURI(requestURI); wrequest.setServletPath(servletPath); wrequest.setPathInfo(pathInfo); if (queryString != null) { wrequest.setQueryString(queryString); wrequest.setQueryParams(queryString); } processRequest(request, response, state); } if (wrapper.getLogger().isDebugEnabled()) wrapper.getLogger().debug(" Disabling the response for futher output"); if (response instanceof ResponseFacade) { ((ResponseFacade) response).finish(); } else { if (wrapper.getLogger().isDebugEnabled()) { wrapper.getLogger().debug(" The Response is vehiculed using a wrapper: " + response.getClass().getName()); } try { PrintWriter writer = response.getWriter(); writer.close(); } catch (IllegalStateException e) { try { ServletOutputStream stream = response.getOutputStream(); stream.close(); } catch (IllegalStateException f) { // Ignore } catch (IOException f) { // Ignore } } catch (IOException e) { // Ignore } } }	@Override public Realm getRealm() { Realm configured = super.getRealm(); if (configured == null) { configured = new JAASRealm(); this.setRealm(configured); } return configured; }	public String getInfo() { return (info); }	public String getOriginalDocBase() { return (this.originalDocBase); }	public Valve getBasic() { return (this.basic); }	public boolean getXmlValidation() { return xmlValidation; }	public synchronized void removeValve(Valve valve) { pipeline.removeValve(valve); fireContainerEvent(REMOVE_VALVE_EVENT, valve); }	public String[] getAliases() { synchronized (aliasesLock) { return aliases; } }	public void destroy() throws Exception { if (started) { stop(); } initialized = false; if (oname != null) { try { if (controller == oname) { Registry.getRegistry(null, null).unregisterComponent(oname); if (log.isDebugEnabled()) log.debug("unregistering " + oname); } } catch (Throwable t) { log.error("Error unregistering ", t); } } if (parent != null) { parent.removeChild(this); } Container[] children = findChildren(); for (int i = 0; i < children.length; i++) { removeChild(children[i]); } }	public void fireContainerEvent(String type, Object data) { if (listeners.size() < 1) return; ContainerEvent event = new ContainerEvent(this, type, data); ContainerListener[] list = new ContainerListener[0]; synchronized (listeners) { list = listeners.toArray(list); } for (int i = 0; i < list.length; i++) list[i].containerEvent(event); }	@Override public void init() { if (initialized) return; initialized = true; if (oname == null) { try { if (domain == null) { domain = getName(); } if (log.isDebugEnabled()) log.debug("Register " + domain); oname = new ObjectName(domain + ":type=Engine"); controller = oname; Registry.getRegistry(null, null).registerComponent(this, oname, null); } catch (Throwable t) { log.info("Error registering ", t); } } if (mbeansFile == null) { String defaultMBeansFile = getBaseDir() + "/conf/tomcat5-mbeans.xml"; File f = new File(defaultMBeansFile); if (f.exists()) mbeansFile = f.getAbsolutePath(); } if (mbeansFile != null) { readEngineMbeans(); } if (mbeans != null) { try { Registry.getRegistry(null, null).invoke(mbeans, "init", false); } catch (Exception e) { log.error("Error in init() for " + mbeansFile, e); } } if (service == null) { try { service = new StandardService(); service.setContainer(this); service.initialize(); } catch (Throwable t) { log.error(t); } } }	public void initialize() throws LifecycleException { if (initialized) { if (log.isInfoEnabled()) log.info(sm.getString("standardService.initialize.initialized")); return; } initialized = true; if (oname == null) { try { Container engine = this.getContainer(); domain = engine.getName(); oname = new ObjectName(domain + ":type=Service,serviceName=" + name); this.controller = oname; Registry.getRegistry(null, null).registerComponent(this, oname, null); Executor[] executors = findExecutors(); for (int i = 0; i < executors.length; i++) { ObjectName executorObjectName = new ObjectName(domain + ":type=Executor,name=" + executors[i].getName()); Registry.getRegistry(null, null).registerComponent(executors[i], executorObjectName, null); } } catch (Exception e) { log.error(sm.getString("standardService.register.failed", domain), e); } } if (server == null) { server = new StandardServer(); server.addService(this); } synchronized (connectors) { for (int i = 0; i < connectors.length; i++) { connectors[i].initialize(); } } }	public void removeValve(Valve valve) { Valve current; if (first == valve) { first = first.getNext(); current = null; } else { current = first; } while (current != null) { if (current.getNext() == valve) { current.setNext(valve.getNext()); break; } current = current.getNext(); } if (first == basic) first = null; if (valve instanceof Contained) ((Contained) valve).setContainer(null); if (started) { if (valve instanceof Lifecycle) { try { ((Lifecycle) valve).stop(); } catch (LifecycleException e) { log.error("StandardPipeline.removeValve: stop: ", e); } } unregisterValve(valve); } }	public void setBasic(Valve valve) { Valve oldBasic = this.basic; if (oldBasic == valve) return; if (oldBasic != null) { if (started && (oldBasic instanceof Lifecycle)) { try { ((Lifecycle) oldBasic).stop(); } catch (LifecycleException e) { log.error("StandardPipeline.setBasic: stop", e); } } if (oldBasic instanceof Contained) { try { ((Contained) oldBasic).setContainer(null); } catch (Throwable t) { // Ignore } } } if (valve == null) return; if (valve instanceof Contained) { ((Contained) valve).setContainer(this.container); } if (valve instanceof Lifecycle) { try { ((Lifecycle) valve).start(); } catch (LifecycleException e) { log.error("StandardPipeline.setBasic: start", e); return; } } Valve current = first; while (current != null) { if (current.getNext() == oldBasic) { current.setNext(valve); break; } current = current.getNext(); } this.basic = valve; }	public void setContextClass(String contextClass) { String oldContextClass = this.contextClass; this.contextClass = contextClass; support.firePropertyChange("contextClass", oldContextClass, this.contextClass); }	public void stop() throws LifecycleException { if (!started) { return; } lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, null); synchronized (connectors) { for (int i = 0; i < connectors.length; i++) { connectors[i].pause(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { // Ignore } lifecycle.fireLifecycleEvent(STOP_EVENT, null); if (log.isInfoEnabled()) log.info(sm.getString("standardService.stop.name", this.name)); started = false; if (container != null) { synchronized (container) { if (container instanceof Lifecycle) { ((Lifecycle) container).stop(); } } } synchronized (connectors) { for (int i = 0; i < connectors.length; i++) { ((Lifecycle) connectors[i]).stop(); } } synchronized (executors) { for (int i = 0; i < executors.size(); i++) { executors.get(i).stop(); } } if (oname == controller) { // we registered ourself on init(). // That should be the typical case - this object is just for Registry.getRegistry(null, null).unregisterComponent(oname); Executor[] executors = findExecutors(); for (int i = 0; i < executors.length; i++) { try { ObjectName executorObjectName = new ObjectName(domain + ":type=Executor,name=" + executors[i].getName()); Registry.getRegistry(null, null).unregisterComponent(executorObjectName); } catch (Exception e) { // Ignore (invalid ON, which cannot happen) } } } lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null); }
protected void removeAttributeInternal(String name, boolean notify) { if (name == null) return; Object value = attributes.remove(name); if (!notify || (value == null)) { return; } HttpSessionBindingEvent event = null; if (value instanceof HttpSessionBindingListener) { event = new HttpSessionBindingEvent(getSession(), name, value); ((HttpSessionBindingListener) value).valueUnbound(event); } Context context = (Context) manager.getContainer(); Object[] listeners = context.getApplicationEventListeners(); if (listeners == null) return; for (int i = 0; i < listeners.length; i++) { if (!(listeners[i] instanceof HttpSessionAttributeListener)) continue; HttpSessionAttributeListener listener = (HttpSessionAttributeListener) listeners[i]; try { fireContainerEvent(context, "beforeSessionAttributeRemoved", listener); if (event == null) { event = new HttpSessionBindingEvent(getSession(), name, value); } listener.attributeRemoved(event); fireContainerEvent(context, "afterSessionAttributeRemoved", listener); } catch (Throwable t) { try { fireContainerEvent(context, "afterSessionAttributeRemoved", listener); } catch (Exception e) { // Ignore } manager.getContainer().getLogger().error(sm.getString("standardSession.attributeEvent"), t); } } }	protected void setAccessCount(int count) { if (accessCount == null && ACTIVITY_CHECK) accessCount = new AtomicInteger(); if (accessCount != null) super.accessCount.set(count); }	public BufferedReader getReader() throws IOException { if (usingInputStream) throw new IllegalStateException(sm.getString("coyoteRequest.getReader.ise")); usingReader = true; inputBuffer.checkConverter(); if (reader == null) { reader = new CoyoteReader(inputBuffer); } return reader; }	public Enumeration<String> getAttributeNames() { if (!isValidInternal()) throw new IllegalStateException(sm.getString("standardSession.getAttributeNames.ise")); return (new Enumerator<String>(attributes.keySet(), true)); }	public Object getAttribute(String name) { return session.getAttribute(name); }	public String[] getValueNames() { if (!isValidInternal()) throw new IllegalStateException(sm.getString("standardSession.getValueNames.ise")); return (keys()); }	public String[] getValueNames() { return session.getValueNames(); }	public RequestDispatcher getNamedDispatcher(String name) { if (SecurityUtil.isPackageProtectionEnabled()) { return (RequestDispatcher) doPrivileged("getNamedDispatcher", new Object[] { name }); } else { return context.getNamedDispatcher(name); } }	public RequestDispatcher getRequestDispatcher(String path) { return this.request.getRequestDispatcher(path); }	public RxTaskPool getTaskPool() { return pool; }	public Enumeration<String> getServletNames() { if (SecurityUtil.isPackageProtectionEnabled()) { return (Enumeration<String>) doPrivileged("getServletNames", null); } else { return context.getServletNames(); } }	public ServletContext getServletContext() { if (manager == null) return (null); Context context = (Context) manager.getContainer(); if (context == null) return (null); else return (context.getServletContext()); }	public boolean isSecure() { return false; }	public String encodeRedirectURL(String url) { return this._getHttpServletResponse().encodeRedirectURL(url); }	public String encodeRedirectURL(String url) { if (isEncodeable(toAbsolute(url))) { return (toEncoded(url, request.getSessionInternal().getIdInternal())); } else { return (url); } }	public String encodeURL(String url) { String absolute = toAbsolute(url); if (isEncodeable(absolute)) { if (url.equalsIgnoreCase("")) { url = absolute; } return (toEncoded(url, request.getSessionInternal().getIdInternal())); } else { return (url); } }	public String encodeUrl(String url) { return this._getHttpServletResponse().encodeUrl(url); }	public String getAddress() { return properties.getProperty("mcastAddress"); }	public String getBind() { return properties.getProperty("mcastBindAddress"); }	public String getManagerClassName() { return managerTemplate.getClass().getName(); }	public String getServerInfo() { return (ServerInfo.getServerInfo()); }	String getServerInfo() { return ("JspCServletContext/1.0"); }	public Enumeration<Servlet> getServlets() { return (new Enumerator<Servlet>(emptyServlet)); }	public Enumeration<Servlet> getServlets() { return (new Vector<Servlet>().elements()); }	public boolean isListening() { return listen; }	public boolean isNew() { if (!isValidInternal()) throw new IllegalStateException(sm.getString("standardSession.isNew.ise")); return (this.isNew); }	public boolean isPermanent() { return permanent; }	public boolean isRequestedSessionIdFromURL() { return this._getHttpServletRequest().isRequestedSessionIdFromURL(); }	public boolean isRequestedSessionIdFromURL() { if (requestedSessionId != null) return (requestedSessionURL); else return (false); }	char readChar() throws java.io.IOException { if (inBuf > 0) { --inBuf; if (++bufpos == bufsize) bufpos = 0; return buffer[bufpos]; } if (++bufpos >= maxNextCharInd) FillBuff(); char c = buffer[bufpos]; UpdateLineColumn(c); return c; }	public int getColumn() { return bufcolumn[bufpos]; }	public int getMaxInactiveInterval() { return session.getMaxInactiveInterval(); }	public int getPort() { String p = properties.getProperty("mcastPort"); return new Integer(p).intValue(); }	public int getSoTimeout() { return mcastSoTimeout; }	public byte[] getDomain() { return domain; }	public int getTxBufSize() { return txBufSize; }	public long getSelectorTimeout() { return tcpSelectorTimeout; }	public static byte[] toBytes(long n, byte[] b, int offset) { b[offset + 7] = (byte) (n); n >>>= 8; b[offset + 6] = (byte) (n); n >>>= 8; b[offset + 5] = (byte) (n); n >>>= 8; b[offset + 4] = (byte) (n); n >>>= 8; b[offset + 3] = (byte) (n); n >>>= 8; b[offset + 2] = (byte) (n); n >>>= 8; b[offset + 1] = (byte) (n); n >>>= 8; b[offset + 0] = (byte) (n); return b; }	public static byte[] toBytes(boolean bool, byte[] data, int offset) { data[offset] = (byte) (bool ? 1 : 0); return data; }	public String encodeUrl(String url) { return null; }	public void addPropertyChangeListener(PropertyChangeListener listener) { support.addPropertyChangeListener(listener); }	public void begin(String namespace, String name, Attributes attributes) throws Exception { begin(attributes); }	public void body(String namespace, String name, String text) throws Exception { body(text); }	public void broadcast(ChannelMessage message) throws ChannelException { if (impl == null || (impl.startLevel & Channel.MBR_TX_SEQ) != Channel.MBR_TX_SEQ) throw new ChannelException("Multicast send is not started or enabled."); byte[] data = XByteBuffer.createDataPackage((ChannelData) message); if (data.length > McastServiceImpl.MAX_PACKET_SIZE) { throw new ChannelException("Packet length[" + data.length + "] exceeds max packet size of " + McastServiceImpl.MAX_PACKET_SIZE + " bytes."); } DatagramPacket packet = new DatagramPacket(data, 0, data.length); try { impl.send(false, packet); } catch (Exception x) { throw new ChannelException(x); } }	public void log(String message) { context.getLogger().info(message); }	public void log(String message) { myLogWriter.println(message); }	public void log(String msg) { if (SecurityUtil.isPackageProtectionEnabled()) { doPrivileged("log", new Object[] { msg }); } else { context.log(msg); } }	public void removeAttribute(String name) { session.removeAttribute(name); }	public void removeAttribute(String name, boolean notify) { if (!isValidInternal()) throw new IllegalStateException(sm.getString("standardSession.removeAttribute.ise")); removeAttributeInternal(name, notify); }	public void setAddress(String addr) { properties.setProperty("mcastAddress", addr); }	public void setAttribute(String name, Object value) { session.setAttribute(name, value); }	public void setBind(String bindaddr) { properties.setProperty("mcastBindAddress", bindaddr); }	public void setBind(java.net.InetAddress bind) { this.bind = bind; }	public void setCatalinaBase() { initDirs(); }	public void setDropTime(long time) { properties.setProperty("memberDropTime", String.valueOf(time)); }	public void setFrequency(long time) { properties.setProperty("mcastFrequency", String.valueOf(time)); }	public void setLastModified(long lastModified) { this.lastModified = lastModified; this.lastModifiedDate = null; if (attributes != null) attributes.put(LAST_MODIFIED, new Date(lastModified)); }	public void setLocalLoopbackDisabled(boolean localLoopbackDisabled) { properties.setProperty("localLoopbackDisabled", String.valueOf(localLoopbackDisabled)); }	public void setMessageListener(MessageListener listener) { this.listener = listener; }	public void setNamespaceURI(String namespaceURI) { this.namespaceURI = namespaceURI; }	public void setNotifyLifecycleListenerOnFailure(boolean notifyListenerOnFailure) { boolean oldNotifyListenerOnFailure = this.notifyLifecycleListenerOnFailure; this.notifyLifecycleListenerOnFailure = notifyListenerOnFailure; support.firePropertyChange("notifyLifecycleListenerOnFailure", oldNotifyListenerOnFailure, this.notifyLifecycleListenerOnFailure); }	public void setSoTimeout(int mcastSoTimeout) { this.mcastSoTimeout = mcastSoTimeout; properties.setProperty("mcastSoTimeout", String.valueOf(mcastSoTimeout)); }	public void setStatus(int sc) { this._getHttpServletResponse().setStatus(sc); }	public void setStatus(int sc) { if (!included) ((HttpServletResponse) getResponse()).setStatus(sc); }	public void setStatus(int status) { setStatus(status, null); }	public void setStatus(int status) { }	public void setTcpListenPort(int tcpListenPort) { setPort(tcpListenPort); }	public void setTxBufSize(int txBufSize) { this.txBufSize = txBufSize; }	public void stopServer(String[] arguments) { if (arguments != null) { arguments(arguments); } if (server == null) { Digester digester = createStopDigester(); digester.setClassLoader(Thread.currentThread().getContextClassLoader()); File file = configFile(); try { InputSource is = new InputSource("file://" + file.getAbsolutePath()); FileInputStream fis = new FileInputStream(file); is.setByteStream(fis); digester.push(this); digester.parse(is); fis.close(); } catch (Exception e) { log.error("Catalina.stop: ", e); System.exit(1); } } try { if (server.getPort() > 0) { Socket socket = new Socket(server.getAddress(), server.getPort()); OutputStream stream = socket.getOutputStream(); String shutdown = server.getShutdown(); for (int i = 0; i < shutdown.length(); i++) stream.write(shutdown.charAt(i)); stream.flush(); stream.close(); socket.close(); } else { log.error(sm.getString("catalina.stopServer")); System.exit(1); } } catch (IOException e) { log.error("Catalina.stop: ", e); System.exit(1); } }
public void begin(String namespace, String name, Attributes attributes) throws Exception { if (isLoginConfigSet) { throw new IllegalArgumentException("<login-config> element is limited to 1 occurrence"); } isLoginConfigSet = true; }	public void recycle() { jspConfig.isJspConfigSet = false; sessionConfig.isSessionConfigSet = false; loginConfig.isLoginConfigSet = false; }
private static Digester createTldDigester(boolean namespaceAware, boolean validation) { Digester digester = null; if (!namespaceAware && !validation) { if (tldDigesters[0] == null) { tldDigesters[0] = DigesterFactory.newDigester(validation, namespaceAware, new TldRuleSet()); } digester = tldDigesters[0]; } else if (!namespaceAware && validation) { if (tldDigesters[1] == null) { tldDigesters[1] = DigesterFactory.newDigester(validation, namespaceAware, new TldRuleSet()); } digester = tldDigesters[1]; } else if (namespaceAware && !validation) { if (tldDigesters[2] == null) { tldDigesters[2] = DigesterFactory.newDigester(validation, namespaceAware, new TldRuleSet()); } digester = tldDigesters[2]; } else { if (tldDigesters[3] == null) { tldDigesters[3] = DigesterFactory.newDigester(validation, namespaceAware, new TldRuleSet()); } digester = tldDigesters[3]; } return digester; }	public boolean getTldValidation() { return this.tldValidation; }

protected InputSource getContextWebXmlSource() { InputStream stream = null; InputSource source = null; URL url = null; String altDDName = null; ServletContext servletContext = context.getServletContext(); if (servletContext != null) { altDDName = (String) servletContext.getAttribute(Globals.ALT_DD_ATTR); if (altDDName != null) { try { stream = new FileInputStream(altDDName); url = new File(altDDName).toURI().toURL(); } catch (FileNotFoundException e) { log.error(sm.getString("contextConfig.altDDNotFound", altDDName)); } catch (MalformedURLException e) { log.error(sm.getString("contextConfig.applicationUrl")); } } else { stream = servletContext.getResourceAsStream(Constants.ApplicationWebXml); try { url = servletContext.getResource(Constants.ApplicationWebXml); } catch (MalformedURLException e) { log.error(sm.getString("contextConfig.applicationUrl")); } } } if (stream == null || url == null) { if (log.isDebugEnabled()) { log.debug(sm.getString("contextConfig.applicationMissing") + " " + context); } } else { source = new InputSource(url.toExternalForm()); source.setByteStream(stream); } return source; }	protected synchronized void stop() { if (log.isDebugEnabled()) log.debug(sm.getString("contextConfig.stop")); int i; Container[] children = context.findChildren(); for (i = 0; i < children.length; i++) { context.removeChild(children[i]); } // Removing application parameters /* ApplicationParameter[] applicationParameters = context.findApplicationParameters(); for (i = 0; i < applicationParameters.length; i++) { context.removeApplicationParameter (applicationParameters[i].getName()); } */ SecurityConstraint[] securityConstraints = context.findConstraints(); for (i = 0; i < securityConstraints.length; i++) { context.removeConstraint(securityConstraints[i]); } // Removing Ejbs /* ContextEjb[] contextEjbs = context.findEjbs(); for (i = 0; i < contextEjbs.length; i++) { context.removeEjb(contextEjbs[i].getName()); } */ // Removing environments /* ContextEnvironment[] contextEnvironments = context.findEnvironments(); for (i = 0; i < contextEnvironments.length; i++) { context.removeEnvironment(contextEnvironments[i].getName()); } */ ErrorPage[] errorPages = context.findErrorPages(); for (i = 0; i < errorPages.length; i++) { context.removeErrorPage(errorPages[i]); } FilterDef[] filterDefs = context.findFilterDefs(); for (i = 0; i < filterDefs.length; i++) { context.removeFilterDef(filterDefs[i]); } FilterMap[] filterMaps = context.findFilterMaps(); for (i = 0; i < filterMaps.length; i++) { context.removeFilterMap(filterMaps[i]); } // Removing local ejbs /* ContextLocalEjb[] contextLocalEjbs = context.findLocalEjbs(); for (i = 0; i < contextLocalEjbs.length; i++) { context.removeLocalEjb(contextLocalEjbs[i].getName()); } */ String[] mimeMappings = context.findMimeMappings(); for (i = 0; i < mimeMappings.length; i++) { context.removeMimeMapping(mimeMappings[i]); } String[] parameters = context.findParameters(); for (i = 0; i < parameters.length; i++) { context.removeParameter(parameters[i]); } // Removing resource env refs /* String[] resourceEnvRefs = context.findResourceEnvRefs(); for (i = 0; i < resourceEnvRefs.length; i++) { context.removeResourceEnvRef(resourceEnvRefs[i]); } */ // Removing resource links /* ContextResourceLink[] contextResourceLinks = context.findResourceLinks(); for (i = 0; i < contextResourceLinks.length; i++) { context.removeResourceLink(contextResourceLinks[i].getName()); } */ // Removing resources /* ContextResource[] contextResources = context.findResources(); for (i = 0; i < contextResources.length; i++) { context.removeResource(contextResources[i].getName()); } */ String[] securityRoles = context.findSecurityRoles(); for (i = 0; i < securityRoles.length; i++) { context.removeSecurityRole(securityRoles[i]); } String[] servletMappings = context.findServletMappings(); for (i = 0; i < servletMappings.length; i++) { context.removeServletMapping(servletMappings[i]); } // FIXME : Removing status pages String[] taglibs = context.findTaglibs(); for (i = 0; i < taglibs.length; i++) { context.removeTaglib(taglibs[i]); } String[] welcomeFiles = context.findWelcomeFiles(); for (i = 0; i < welcomeFiles.length; i++) { context.removeWelcomeFile(welcomeFiles[i]); } String[] wrapperLifecycles = context.findWrapperLifecycles(); for (i = 0; i < wrapperLifecycles.length; i++) { context.removeWrapperLifecycle(wrapperLifecycles[i]); } String[] wrapperListeners = context.findWrapperListeners(); for (i = 0; i < wrapperListeners.length; i++) { context.removeWrapperListener(wrapperListeners[i]); } Host host = (Host) context.getParent(); String appBase = host.getAppBase(); String docBase = context.getDocBase(); if ((docBase != null) && (originalDocBase != null)) { File docBaseFile = new File(docBase); if (!docBaseFile.isAbsolute()) { docBaseFile = new File(appBase, docBase); } ExpandWar.delete(docBaseFile); } ok = true; }
public boolean getXmlNamespaceAware() { return xmlNamespaceAware; }	public boolean getXmlValidation() { return xmlValidation; }	public long getDeploymentTime(String name) { DeployedApplication app = deployed.get(name); if (app == null) { return 0L; } else { return app.timestamp; } }	public void check(String name) { DeployedApplication app = deployed.get(name); if (app != null) { checkResources(app); } else { deployApps(name); } }
public void setUseNaming(boolean useNaming) { boolean oldUseNaming = this.useNaming; this.useNaming = useNaming; support.firePropertyChange("useNaming", new Boolean(oldUseNaming), new Boolean(this.useNaming)); }	public void stop() throws LifecycleException { if (log.isDebugEnabled()) log.debug("Stopping embedded server"); if (!started) throw new LifecycleException(sm.getString("embedded.notStarted")); lifecycle.fireLifecycleEvent(STOP_EVENT, null); started = false; for (int i = 0; i < connectors.length; i++) { ((Lifecycle) connectors[i]).stop(); } for (int i = 0; i < engines.length; i++) { if (engines[i] instanceof Lifecycle) ((Lifecycle) engines[i]).stop(); } }
public static MBeanServerConnection accessJMXConnection(Project project, String url, String host, String port, String username, String password, String refId) throws MalformedURLException, IOException { MBeanServerConnection jmxServerConnection = null; boolean isRef = project != null && refId != null && refId.length() > 0; if (isRef) { Object pref = project.getReference(refId); try { jmxServerConnection = (MBeanServerConnection) pref; } catch (ClassCastException cce) { if (project != null) { project.log("wrong object reference " + refId + " - " + pref.getClass()); } return null; } } if (jmxServerConnection == null) { jmxServerConnection = createJMXConnection(url, host, port, username, password); } if (isRef && jmxServerConnection != null) { project.addReference(refId, jmxServerConnection); } return jmxServerConnection; }	public void countDown(CountDownLatch latch) { if (latch == null) return; latch.countDown(); }	public void invoke(Request request, Response response) throws IOException, ServletException { final String EMPTY = ""; getNext().invoke(request, response); String remoteHost = EMPTY; if (resolveHosts) remoteHost = request.getRemoteHost(); else remoteHost = request.getRemoteAddr(); String user = EMPTY; if (request != null) user = request.getRemoteUser(); String query = ""; if (request != null) query = request.getRequestURI(); long bytes = response.getContentCountLong(); if (bytes < 0) bytes = 0; int status = response.getStatus(); String virtualHost = EMPTY; String method = EMPTY; String referer = EMPTY; String userAgent = EMPTY; if (pattern.equals("combined") && request != null) { virtualHost = request.getServerName(); method = request.getMethod(); referer = request.getHeader("referer"); userAgent = request.getHeader("user-agent"); } synchronized (this) { int numberOfTries = 2; while (numberOfTries > 0) { try { open(); ps.setString(1, remoteHost); ps.setString(2, user); ps.setTimestamp(3, new Timestamp(getCurrentTimeMillis())); ps.setString(4, query); ps.setInt(5, status); if (useLongContentLength) { ps.setLong(6, bytes); } else { if (bytes > Integer.MAX_VALUE) bytes = -1; ps.setInt(6, (int) bytes); } if (pattern.equals("combined")) { ps.setString(7, virtualHost); ps.setString(8, method); ps.setString(9, referer); ps.setString(10, userAgent); } ps.executeUpdate(); return; } catch (SQLException e) { container.getLogger().error(sm.getString("jdbcAccessLogValve.exception"), e); if (conn != null) close(); } numberOfTries--; } } }	public void run() { while (run) { try { events(); int keyCount = 0; try { int i = wakeupCounter.get(); if (i > 0) keyCount = selector.selectNow(); else { wakeupCounter.set(-1); keyCount = selector.select(1000); } wakeupCounter.set(0); if (!run) break; } catch (NullPointerException x) { if (selector == null) throw x; if (log.isDebugEnabled()) log.debug("Possibly encountered sun bug 5076772 on windows JDK 1.5", x); continue; } catch (CancelledKeyException x) { if (log.isDebugEnabled()) log.debug("Possibly encountered sun bug 5076772 on windows JDK 1.5", x); continue; } catch (Throwable x) { log.error("", x); continue; } Iterator<SelectionKey> iterator = keyCount > 0 ? selector.selectedKeys().iterator() : null; while (run && iterator != null && iterator.hasNext()) { SelectionKey sk = iterator.next(); KeyAttachment attachment = (KeyAttachment) sk.attachment(); try { attachment.access(); iterator.remove(); sk.interestOps(sk.interestOps() & (~sk.readyOps())); if (sk.isReadable()) { countDown(attachment.getReadLatch()); } if (sk.isWritable()) { countDown(attachment.getWriteLatch()); } } catch (CancelledKeyException ckx) { if (sk != null) sk.cancel(); countDown(attachment.getReadLatch()); countDown(attachment.getWriteLatch()); } } //while } catch (Throwable t) { log.error("", t); } } events.clear(); try { selector.selectNow(); } catch (Exception ignore) { if (log.isDebugEnabled()) log.debug("", ignore); } try { selector.close(); } catch (Exception ignore) { if (log.isDebugEnabled()) log.debug("", ignore); } }
public void stop() throws Exception { Method method = catalinaDaemon.getClass().getMethod("stop", (Class[]) null); method.invoke(catalinaDaemon, (Object[]) null); }	public void stopServer() throws Exception { Method method = catalinaDaemon.getClass().getMethod("stopServer", (Class[]) null); method.invoke(catalinaDaemon, (Object[]) null); }
protected void usage() { System.out.println("usage: java org.apache.catalina.startup.Catalina" + " [ -config {pathname} ]" + " [ -nonaming ] { start | stop }"); }
public static void main(String[] args) { if (daemon == null) { daemon = new Bootstrap(); try { daemon.init(); } catch (Throwable t) { t.printStackTrace(); return; } } try { String command = "start"; if (args.length > 0) { command = args[args.length - 1]; } if (command.equals("startd")) { args[0] = "start"; daemon.load(args); daemon.start(); } else if (command.equals("stopd")) { args[0] = "stop"; daemon.stop(); } else if (command.equals("start")) { daemon.setAwait(true); daemon.load(args); daemon.start(); } else if (command.equals("stop")) { daemon.stopServer(args); } else { log.warn("Bootstrap: command \"" + command + "\" does not exist."); } } catch (Throwable t) { t.printStackTrace(); } }
private void checkXmlAttributes(Node.CustomTag n, Node.JspAttribute[] jspAttrs, Hashtable<String, Object> tagDataAttrs) throws JasperException { TagInfo tagInfo = n.getTagInfo(); if (tagInfo == null) { err.jspError(n, "jsp.error.missing.tagInfo", n.getQName()); } TagAttributeInfo[] tldAttrs = tagInfo.getAttributes(); Attributes attrs = n.getAttributes(); boolean checkDeferred = !pageInfo.isDeferredSyntaxAllowedAsLiteral() && !(tagInfo.getTagLibrary().getRequiredVersion().equals("2.0") || tagInfo.getTagLibrary().getRequiredVersion().equals("1.2")); for (int i = 0; attrs != null && i < attrs.getLength(); i++) { boolean found = false; boolean runtimeExpression = ((n.getRoot().isXmlSyntax() && attrs.getValue(i).startsWith("%=")) || (!n.getRoot().isXmlSyntax() && attrs.getValue(i).startsWith("<%="))); boolean elExpression = false; boolean deferred = false; boolean deferredValueIsLiteral = false; ELNode.Nodes el = null; if (!runtimeExpression) { el = ELParser.parse(attrs.getValue(i)); Iterator<ELNode> nodes = el.iterator(); while (nodes.hasNext()) { ELNode node = nodes.next(); if (node instanceof ELNode.Root) { if (((ELNode.Root) node).getType() == '$') { elExpression = true; } else if (checkDeferred && ((ELNode.Root) node).getType() == '#') { elExpression = true; deferred = true; if (pageInfo.isELIgnored()) { deferredValueIsLiteral = true; } } } } } boolean expression = runtimeExpression || (elExpression && (!pageInfo.isELIgnored() || (!"true".equalsIgnoreCase(pageInfo.getIsELIgnored()) && checkDeferred && deferred))); for (int j = 0; tldAttrs != null && j < tldAttrs.length; j++) { if (attrs.getLocalName(i).equals(tldAttrs[j].getName()) && (attrs.getURI(i) == null || attrs.getURI(i).length() == 0 || attrs.getURI(i).equals(n.getURI()))) { if (tldAttrs[j].canBeRequestTime() || tldAttrs[j].isDeferredMethod() || tldAttrs[j].isDeferredValue()) { if (!expression) { if (deferredValueIsLiteral && !pageInfo.isDeferredSyntaxAllowedAsLiteral()) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } String expectedType = null; if (tldAttrs[j].isDeferredMethod()) { // The String litteral must be castable to what is declared as type String m = tldAttrs[j].getMethodSignature(); if (m != null) { int rti = m.trim().indexOf(' '); if (rti > 0) { expectedType = m.substring(0, rti).trim(); } } else { expectedType = "java.lang.Object"; } } if (tldAttrs[j].isDeferredValue()) { // The String litteral must be castable to what is declared as type expectedType = tldAttrs[j].getExpectedTypeName(); } if (expectedType != null) { Class<?> expectedClass = String.class; try { expectedClass = JspUtil.toClass(expectedType, loader); } catch (ClassNotFoundException e) { err.jspError(n, "jsp.error.unknown_attribute_type", tldAttrs[j].getName(), expectedType); } try { ELSupport.checkType(attrs.getValue(i), expectedClass); } catch (Exception e) { err.jspError(n, "jsp.error.coerce_to_type", tldAttrs[j].getName(), expectedType, attrs.getValue(i)); } } jspAttrs[i] = new Node.JspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), false, null, false); } else { if (deferred && !tldAttrs[j].isDeferredMethod() && !tldAttrs[j].isDeferredValue()) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } if (!deferred && !tldAttrs[j].canBeRequestTime()) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } if (elExpression) { validateFunctions(el, n); jspAttrs[i] = new Node.JspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), false, el, false); ELContextImpl ctx = new ELContextImpl(); ctx.setFunctionMapper(getFunctionMapper(el)); try { jspAttrs[i].validateEL(this.pageInfo.getExpressionFactory(), ctx); } catch (ELException e) { this.err.jspError(n.getStart(), "jsp.error.invalid.expression", attrs.getValue(i), e.toString()); } } else { jspAttrs[i] = getJspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), n, false); } } } else { if (expression) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } jspAttrs[i] = new Node.JspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), false, null, false); } if (expression) { tagDataAttrs.put(attrs.getQName(i), TagData.REQUEST_TIME_VALUE); } else { tagDataAttrs.put(attrs.getQName(i), attrs.getValue(i)); } found = true; break; } } if (!found) { if (tagInfo.hasDynamicAttributes()) { jspAttrs[i] = getJspAttribute(null, attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), n, true); } else { err.jspError(n, "jsp.error.bad_attribute", attrs.getQName(i), n.getLocalName()); } } } }	public void visit(Node.UninterpretedTag n) throws JasperException { if (n.getNamedAttributeNodes().size() != 0) { err.jspError(n, "jsp.error.namedAttribute.invalidUse"); } Attributes attrs = n.getAttributes(); if (attrs != null) { int attrSize = attrs.getLength(); Node.JspAttribute[] jspAttrs = new Node.JspAttribute[attrSize]; for (int i = 0; i < attrSize; i++) { jspAttrs[i] = getJspAttribute(null, attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), n, false); } n.setJspAttributes(jspAttrs); } visitBody(n); }
void addDateHeader(String name, long value) { if (isCommitted()) return; if (included) { return; } if (format == null) { format = new SimpleDateFormat(DateTool.HTTP_RESPONSE_DATE_HEADER, Locale.US); format.setTimeZone(TimeZone.getTimeZone("GMT")); } addHeader(name, FastHttpDateFormat.formatDate(value, format)); }	public void addHeader(String name, String value) { if (isCommitted()) return; if (included) return; coyoteResponse.addHeader(name, value); }	public void addIntHeader(String name, int value) { if (isCommitted()) return; if (included) return; addHeader(name, "" + value); }	public void setDateHeader(String name, long value) { if (isCommitted()) return; if (included) { return; } if (format == null) { format = new SimpleDateFormat(DateTool.HTTP_RESPONSE_DATE_HEADER, Locale.US); format.setTimeZone(TimeZone.getTimeZone("GMT")); } setHeader(name, FastHttpDateFormat.formatDate(value, format)); }	public void setHeader(String name, String value) { if (isCommitted()) return; if (included) return; coyoteResponse.setHeader(name, value); }	public void setIntHeader(String name, int value) { if (isCommitted()) return; if (included) return; setHeader(name, "" + value); }
public Enumeration<String> getAttributeNames() { if (isSecure()) { getAttribute(Globals.CERTIFICATES_ATTR); } return new Enumerator<String>(attributes.keySet(), true); }
protected synchronized void checkResources(DeployedApplication app) { String[] resources = app.redeployResources.keySet().toArray(new String[0]); for (int i = 0; i < resources.length; i++) { File resource = new File(resources[i]); if (log.isDebugEnabled()) log.debug("Checking context[" + app.name + "] redeploy resource " + resource); if (resource.exists()) { long lastModified = app.redeployResources.get(resources[i]).longValue(); if ((!resource.isDirectory()) && resource.lastModified() > lastModified) { if (log.isInfoEnabled()) log.info(sm.getString("hostConfig.undeploy", app.name)); ContainerBase context = (ContainerBase) host.findChild(app.name); try { host.removeChild(context); } catch (Throwable t) { log.warn(sm.getString("hostConfig.context.remove", app.name), t); } try { context.destroy(); } catch (Throwable t) { log.warn(sm.getString("hostConfig.context.destroy", app.name), t); } for (int j = i + 1; j < resources.length; j++) { try { File current = new File(resources[j]); current = current.getCanonicalFile(); if ((current.getAbsolutePath().startsWith(appBase().getAbsolutePath() + File.separator)) || (current.getAbsolutePath().startsWith(configBase().getAbsolutePath()))) { if (log.isDebugEnabled()) log.debug("Delete " + current); ExpandWar.delete(current); } } catch (IOException e) { log.warn(sm.getString("hostConfig.canonicalizing", app.name), e); } } deployed.remove(app.name); return; } } else { long lastModified = app.redeployResources.get(resources[i]).longValue(); if (lastModified == 0L) { continue; } if (log.isInfoEnabled()) log.info(sm.getString("hostConfig.undeploy", app.name)); ContainerBase context = (ContainerBase) host.findChild(app.name); try { host.removeChild(context); } catch (Throwable t) { log.warn(sm.getString("hostConfig.context.remove", app.name), t); } try { context.destroy(); } catch (Throwable t) { log.warn(sm.getString("hostConfig.context.destroy", app.name), t); } for (int j = i + 1; j < resources.length; j++) { try { File current = new File(resources[j]); current = current.getCanonicalFile(); if ((current.getAbsolutePath().startsWith(appBase().getAbsolutePath() + File.separator)) || (current.getAbsolutePath().startsWith(configBase().getAbsolutePath()))) { if (log.isDebugEnabled()) log.debug("Delete " + current); ExpandWar.delete(current); } } catch (IOException e) { log.warn(sm.getString("hostConfig.canonicalizing", app.name), e); } } String[] resources2 = app.reloadResources.keySet().toArray(new String[0]); for (int j = 0; j < resources2.length; j++) { try { File current = new File(resources2[j]); current = current.getCanonicalFile(); if ((current.getAbsolutePath().startsWith(appBase().getAbsolutePath() + File.separator)) || ((current.getAbsolutePath().startsWith(configBase().getAbsolutePath()) && (current.getAbsolutePath().endsWith(".xml"))))) { if (log.isDebugEnabled()) log.debug("Delete " + current); ExpandWar.delete(current); } } catch (IOException e) { log.warn(sm.getString("hostConfig.canonicalizing", app.name), e); } } deployed.remove(app.name); return; } } resources = app.reloadResources.keySet().toArray(new String[0]); for (int i = 0; i < resources.length; i++) { File resource = new File(resources[i]); if (log.isDebugEnabled()) log.debug("Checking context[" + app.name + "] reload resource " + resource); long lastModified = app.reloadResources.get(resources[i]).longValue(); if ((!resource.exists() && lastModified != 0L) || (resource.lastModified() != lastModified)) { if (log.isInfoEnabled()) log.info(sm.getString("hostConfig.reload", app.name)); Container context = host.findChild(app.name); try { ((Lifecycle) context).stop(); } catch (Exception e) { log.warn(sm.getString("hostConfig.context.restart", app.name), e); } try { ((Lifecycle) context).start(); } catch (Exception e) { log.warn(sm.getString("hostConfig.context.restart", app.name), e); } app.reloadResources.put(resources[i], new Long(resource.lastModified())); app.timestamp = System.currentTimeMillis(); return; } } }
private void parseFileDirectives(Node parent) throws JasperException { reader.setSingleFile(true); reader.skipUntil("<"); while (reader.hasMoreInput()) { start = reader.mark(); if (reader.matches("%--")) { parseComment(parent); } else if (reader.matches("%@")) { parseDirective(parent); } else if (reader.matches("jsp:directive.")) { parseXMLDirective(parent); } reader.skipUntil("<"); } }
protected Comparator<Session> getComparator(String sortBy) { Comparator<Session> comparator = null; if ("CreationTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { public Comparable<Date> getComparableObject(Session session) { return new Date(session.getCreationTime()); } }; } else if ("id".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { public Comparable<String> getComparableObject(Session session) { return session.getId(); } }; } else if ("LastAccessedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { public Comparable<Date> getComparableObject(Session session) { return new Date(session.getLastAccessedTime()); } }; } else if ("MaxInactiveInterval".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { public Comparable<Date> getComparableObject(Session session) { return new Date(session.getMaxInactiveInterval()); } }; } else if ("new".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Boolean>() { public Comparable<Boolean> getComparableObject(Session session) { return Boolean.valueOf(session.getSession().isNew()); } }; } else if ("locale".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { public Comparable<String> getComparableObject(Session session) { return JspHelper.guessDisplayLocaleFromSession(session); } }; } else if ("user".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<String>() { public Comparable<String> getComparableObject(Session session) { return JspHelper.guessDisplayUserFromSession(session); } }; } else if ("UsedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getUsedTimeForSession(session)); } }; } else if ("InactiveTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getInactiveTimeForSession(session)); } }; } else if ("TTL".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator<Date>() { public Comparable<Date> getComparableObject(Session session) { return new Date(SessionUtils.getTTLForSession(session)); } }; } return comparator; }	public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { // Identify the request parameters that we need // By obtaining the command from the pathInfo, per-command security can String command = request.getPathInfo(); String path = request.getParameter("path"); String deployPath = request.getParameter("deployPath"); String deployConfig = request.getParameter("deployConfig"); String deployWar = request.getParameter("deployWar"); response.setContentType("text/html; charset=" + Constants.CHARSET); String message = ""; if (command == null || command.equals("/")) { // No command == list } else if (command.equals("/deploy")) { message = deployInternal(deployConfig, deployPath, deployWar); } else if (command.equals("/list")) { // List always displayed - nothing to do here } else if (command.equals("/reload")) { message = reload(path); } else if (command.equals("/undeploy")) { message = undeploy(path); } else if (command.equals("/expire")) { message = expireSessions(path, request); } else if (command.equals("/sessions")) { try { doSessions(path, request, response); return; } catch (Exception e) { log("HTMLManagerServlet.sessions[" + path + "]", e); message = sm.getString("managerServlet.exception", e.toString()); } } else if (command.equals("/start")) { message = start(path); } else if (command.equals("/stop")) { message = stop(path); } else { message = sm.getString("managerServlet.unknownCommand", command); } list(request, response, message); }	public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { // Identify the request parameters that we need // By obtaining the command from the pathInfo, per-command security can String command = request.getPathInfo(); if (command == null || !command.equals("/upload")) { doGet(request, response); return; } response.setContentType("text/html; charset=" + Constants.CHARSET); String message = upload(request); list(request, response, message); }
protected void parseSessionId(org.apache.coyote.Request req, Request request) { ByteChunk uriBC = req.requestURI().getByteChunk(); int semicolon = uriBC.indexOf(match, 0, match.length(), 0); if (semicolon > 0) { int start = uriBC.getStart(); int end = uriBC.getEnd(); int sessionIdStart = semicolon + match.length(); int semicolon2 = uriBC.indexOf(';', sessionIdStart); if (semicolon2 >= 0) { request.setRequestedSessionId(new String(uriBC.getBuffer(), start + sessionIdStart, semicolon2 - sessionIdStart)); byte[] buf = uriBC.getBuffer(); for (int i = 0; i < end - start - semicolon2; i++) { buf[start + semicolon + i] = buf[start + i + semicolon2]; } uriBC.setBytes(buf, start, end - start - semicolon2 + semicolon); } else { request.setRequestedSessionId(new String(uriBC.getBuffer(), start + sessionIdStart, (end - start) - sessionIdStart)); uriBC.setEnd(start + semicolon); } request.setRequestedSessionURL(true); } else { request.setRequestedSessionId(null); request.setRequestedSessionURL(false); } }
void init() throws Exception { if (initialized) return; if (acceptorThreadCount == 0) { acceptorThreadCount = 1; } if (serverSocketFactory == null) { serverSocketFactory = ServerSocketFactory.getDefault(); } if (serverSocket == null) { try { if (getAddress() == null) { serverSocket = serverSocketFactory.createSocket(getPort(), getBacklog()); } else { serverSocket = serverSocketFactory.createSocket(getPort(), getBacklog(), getAddress()); } } catch (BindException be) { if (getAddress() == null) throw new BindException(be.getMessage() + "<null>:" + getPort()); else throw new BindException(be.getMessage() + " " + getAddress().toString() + ":" + getPort()); } } //if( serverTimeout >= 0 ) initialized = true; }
public void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException { res.getWriter().write("Hello world"); }	public void testEnableNaming() throws Exception { Tomcat tomcat = getTomcatInstance(); StandardContext ctx = tomcat.addContext("/", System.getProperty("java.io.tmpdir")); // You can customise the context by calling its API tomcat.enableNaming(); ContextEnvironment environment = new ContextEnvironment(); environment.setType("java.lang.String"); environment.setName(HelloWorldJndi.JNDI_ENV_NAME); environment.setValue("Tomcat User"); ctx.getNamingResources().addEnvironment(environment); Tomcat.addServlet(ctx, "jndiServlet", new HelloWorldJndi()); ctx.addServletMapping("/", "jndiServlet"); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/"); assertEquals(res.toString(), "Hello, Tomcat User"); }	void testProgrammatic() throws Exception { Tomcat tomcat = getTomcatInstance(); StandardContext ctx = tomcat.addContext("/", System.getProperty("java.io.tmpdir")); // You can customize the context by calling Tomcat.addServlet(ctx, "myServlet", new HelloWorld()); ctx.addServletMapping("/", "myServlet"); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/"); assertEquals(res.toString(), "Hello world"); }	public void testSingleWebapp() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File("output/build/webapps/examples"); tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/examples/servlets/servlet/HelloWorldExample"); assertTrue(res.toString().indexOf("<h1>Hello World!</h1>") > 0); }
private final void internalMapExtensionWrapper(Wrapper[] wrappers, CharChunk path, MappingData mappingData) { char[] buf = path.getBuffer(); int pathEnd = path.getEnd(); int servletPath = path.getOffset(); int slash = -1; for (int i = pathEnd - 1; i >= servletPath; i--) { if (buf[i] == '/') { slash = i; break; } } if (slash >= 0) { int period = -1; for (int i = pathEnd - 1; i > slash; i--) { if (buf[i] == '.') { period = i; break; } } if (period >= 0) { path.setOffset(period + 1); path.setEnd(pathEnd); int pos = find(wrappers, path); if ((pos != -1) && (path.equals(wrappers[pos].name))) { mappingData.wrapperPath.setChars(buf, servletPath, pathEnd - servletPath); mappingData.requestPath.setChars(buf, servletPath, pathEnd - servletPath); mappingData.wrapper = wrappers[pos].object; } path.setOffset(servletPath); path.setEnd(pathEnd); } } }
public int getMaxThreads() { return maxThreads; }
public void action(ActionCode actionCode, Object param) { if (actionCode == ActionCode.ACTION_COMMIT) { if (response.isCommitted()) return; prepareResponse(); try { outputBuffer.commit(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_ACK) { if ((response.isCommitted()) || !expectation) return; inputBuffer.setSwallowInput(true); try { outputBuffer.sendAck(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_CLIENT_FLUSH) { try { outputBuffer.flush(); } catch (IOException e) { error = true; response.setErrorException(e); } } else if (actionCode == ActionCode.ACTION_CLOSE) { // Close // End the processing of the current request, and stop any further comet = false; try { outputBuffer.endRequest(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_RESET) { // Reset response outputBuffer.reset(); } else if (actionCode == ActionCode.ACTION_CUSTOM) { // Do nothing } else if (actionCode == ActionCode.ACTION_REQ_HOST_ADDR_ATTRIBUTE) { if (remoteAddr == null && (socket != 0)) { try { long sa = Address.get(Socket.APR_REMOTE, socket); remoteAddr = Address.getip(sa); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.remoteAddr().setString(remoteAddr); } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE) { if (localName == null && (socket != 0)) { try { long sa = Address.get(Socket.APR_LOCAL, socket); localName = Address.getnameinfo(sa, 0); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.localName().setString(localName); } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) { if (remoteHost == null && (socket != 0)) { try { long sa = Address.get(Socket.APR_REMOTE, socket); remoteHost = Address.getnameinfo(sa, 0); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.remoteHost().setString(remoteHost); } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) { if (localAddr == null && (socket != 0)) { try { long sa = Address.get(Socket.APR_LOCAL, socket); localAddr = Address.getip(sa); } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.localAddr().setString(localAddr); } else if (actionCode == ActionCode.ACTION_REQ_REMOTEPORT_ATTRIBUTE) { if (remotePort == -1 && (socket != 0)) { try { long sa = Address.get(Socket.APR_REMOTE, socket); Sockaddr addr = Address.getInfo(sa); remotePort = addr.port; } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.setRemotePort(remotePort); } else if (actionCode == ActionCode.ACTION_REQ_LOCALPORT_ATTRIBUTE) { if (localPort == -1 && (socket != 0)) { try { long sa = Address.get(Socket.APR_LOCAL, socket); Sockaddr addr = Address.getInfo(sa); localPort = addr.port; } catch (Exception e) { log.warn(sm.getString("http11processor.socket.info"), e); } } request.setLocalPort(localPort); } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE) { if (ssl && (socket != 0)) { try { Object sslO = SSLSocket.getInfoS(socket, SSL.SSL_INFO_CIPHER); if (sslO != null) { request.setAttribute(AprEndpoint.CIPHER_SUITE_KEY, sslO); } int certLength = SSLSocket.getInfoI(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN); byte[] clientCert = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT); X509Certificate[] certs = null; if (clientCert != null) { certs = new X509Certificate[certLength + 1]; CertificateFactory cf = CertificateFactory.getInstance("X.509"); certs[0] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(clientCert)); for (int i = 0; i < certLength; i++) { byte[] data = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i); certs[i + 1] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data)); } } if (certs != null) { request.setAttribute(AprEndpoint.CERTIFICATE_KEY, certs); } sslO = new Integer(SSLSocket.getInfoI(socket, SSL.SSL_INFO_CIPHER_USEKEYSIZE)); request.setAttribute(AprEndpoint.KEY_SIZE_KEY, sslO); sslO = SSLSocket.getInfoS(socket, SSL.SSL_INFO_SESSION_ID); if (sslO != null) { request.setAttribute(AprEndpoint.SESSION_ID_KEY, sslO); } //TODO provide a hook to enable the SSL session to be // invalidated. Set AprEndpoint.SESSION_MGR req attr } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } } else if (actionCode == ActionCode.ACTION_REQ_SSL_CERTIFICATE) { if (ssl && (socket != 0)) { // Consume and buffer the request body, so that it does not InputFilter[] inputFilters = inputBuffer.getFilters(); ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize); inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]); try { SSLSocket.renegotiate(socket); int certLength = SSLSocket.getInfoI(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN); byte[] clientCert = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT); X509Certificate[] certs = null; if (clientCert != null) { certs = new X509Certificate[certLength + 1]; CertificateFactory cf = CertificateFactory.getInstance("X.509"); certs[0] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(clientCert)); for (int i = 0; i < certLength; i++) { byte[] data = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i); certs[i + 1] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data)); } } if (certs != null) { request.setAttribute(AprEndpoint.CERTIFICATE_KEY, certs); } } catch (Exception e) { log.warn(sm.getString("http11processor.socket.ssl"), e); } } } else if (actionCode == ActionCode.ACTION_REQ_SET_BODY_REPLAY) { ByteChunk body = (ByteChunk) param; InputFilter savedBody = new SavedRequestInputFilter(body); savedBody.setRequest(request); InternalAprInputBuffer internalBuffer = (InternalAprInputBuffer) request.getInputBuffer(); internalBuffer.addActiveFilter(savedBody); } else if (actionCode == ActionCode.ACTION_AVAILABLE) { request.setAvailable(inputBuffer.available()); } else if (actionCode == ActionCode.ACTION_COMET_BEGIN) { comet = true; } else if (actionCode == ActionCode.ACTION_COMET_END) { comet = false; } else if (actionCode == ActionCode.ACTION_COMET_CLOSE) { //no op } else if (actionCode == ActionCode.ACTION_COMET_SETTIMEOUT) { //no op } else if (actionCode == ActionCode.ACTION_ASYNC_START) { //TODO SERVLET3 - async } else if (actionCode == ActionCode.ACTION_ASYNC_COMPLETE) { //TODO SERVLET3 - async } else if (actionCode == ActionCode.ACTION_ASYNC_SETTIMEOUT) { //TODO SERVLET3 - async } }
void initBaseDir() { if (basedir == null) { basedir = System.getProperty("catalina.base"); } if (basedir == null) { basedir = System.getProperty("catalina.home"); } if (basedir == null) { basedir = System.getProperty("user.dir") + "/tomcat." + port; File home = new File(basedir); home.mkdir(); if (!home.isAbsolute()) { try { basedir = home.getCanonicalPath(); } catch (IOException e) { basedir = home.getAbsolutePath(); } } } System.setProperty("catalina.home", basedir); System.setProperty("catalina.base", basedir); }	public void setSilent() { for (String s : silences) { Logger.getLogger(s).setLevel(Level.WARNING); } }
public StandardContext addContext(String contextPath, String baseDir) { return addContext(getHost(), contextPath, baseDir); }	public StandardWrapper addServlet(String contextPath, String servletName, String servletClass) { Container ctx = getHost().findChild(contextPath); return addServlet((StandardContext) ctx, servletName, servletClass); }	public static StandardWrapper addServlet(StandardContext ctx, String servletName, Servlet servlet) { StandardWrapper sw = new ExistingStandardWrapper(servlet); sw.setName(servletName); ctx.addChild(sw); return sw; }	public static void initWebappDefaults(StandardContext ctx) { StandardWrapper servlet = addServlet(ctx, "default", "org.apache.catalina.servlets.DefaultServlet"); servlet.setLoadOnStartup(1); servlet = addServlet(ctx, "jsp", "org.apache.jasper.servlet.JspServlet"); servlet.addInitParameter("fork", "false"); servlet.setLoadOnStartup(3); ctx.addServletMapping("/", "default"); ctx.addServletMapping("*.jsp", "jsp"); ctx.addServletMapping("*.jspx", "jsp"); ctx.setManager(new StandardManager()); ctx.setSessionTimeout(30); for (int i = 0; i < DEFAULT_MIME_MAPPINGS.length; ) { ctx.addMimeMapping(DEFAULT_MIME_MAPPINGS[i++], DEFAULT_MIME_MAPPINGS[i++]); } ctx.addWelcomeFile("index.html"); ctx.addWelcomeFile("index.htm"); ctx.addWelcomeFile("index.jsp"); }	public void enableNaming() { // Make sure getServer() has been called as that is where naming is getServer(); System.setProperty("catalina.useNaming", "true"); String value = "org.apache.naming"; String oldValue = System.getProperty(javax.naming.Context.URL_PKG_PREFIXES); if (oldValue != null) { value = value + ":" + oldValue; } System.setProperty(javax.naming.Context.URL_PKG_PREFIXES, value); value = System.getProperty(javax.naming.Context.INITIAL_CONTEXT_FACTORY); if (value == null) { System.setProperty(javax.naming.Context.INITIAL_CONTEXT_FACTORY, "org.apache.naming.java.javaURLContextFactory"); } }	public static void initWebappDefaults(StandardContext ctx) { StandardWrapper servlet = addServlet(ctx, "default", "org.apache.catalina.servlets.DefaultServlet"); servlet.setLoadOnStartup(1); servlet = addServlet(ctx, "jsp", "org.apache.jasper.servlet.JspServlet"); servlet.addInitParameter("fork", "false"); servlet.setLoadOnStartup(3); ctx.addServletMapping("/", "default"); ctx.addServletMapping("*.jsp", "jsp"); ctx.addServletMapping("*.jspx", "jsp"); ctx.setManager(new StandardManager()); ctx.setSessionTimeout(30); for (int i = 0; i < DEFAULT_MIME_MAPPINGS.length; ) { ctx.addMimeMapping(DEFAULT_MIME_MAPPINGS[i++], DEFAULT_MIME_MAPPINGS[i++]); } ctx.addWelcomeFile("index.html"); ctx.addWelcomeFile("index.htm"); ctx.addWelcomeFile("index.jsp"); }
private ClassLoader createClassLoader(String name, ClassLoader parent) throws Exception { String value = CatalinaProperties.getProperty(name + ".loader"); if ((value == null) || (value.equals(""))) return parent; ArrayList<String> repositoryLocations = new ArrayList<String>(); ArrayList<Integer> repositoryTypes = new ArrayList<Integer>(); int i; StringTokenizer tokenizer = new StringTokenizer(value, ","); while (tokenizer.hasMoreElements()) { String repository = tokenizer.nextToken(); boolean replace = false; String before = repository; while ((i = repository.indexOf(CATALINA_HOME_TOKEN)) >= 0) { replace = true; if (i > 0) { repository = repository.substring(0, i) + getCatalinaHome() + repository.substring(i + CATALINA_HOME_TOKEN.length()); } else { repository = getCatalinaHome() + repository.substring(CATALINA_HOME_TOKEN.length()); } } while ((i = repository.indexOf(CATALINA_BASE_TOKEN)) >= 0) { replace = true; if (i > 0) { repository = repository.substring(0, i) + getCatalinaBase() + repository.substring(i + CATALINA_BASE_TOKEN.length()); } else { repository = getCatalinaBase() + repository.substring(CATALINA_BASE_TOKEN.length()); } } if (replace && log.isDebugEnabled()) log.debug("Expanded " + before + " to " + replace); try { new URL(repository); repositoryLocations.add(repository); repositoryTypes.add(ClassLoaderFactory.IS_URL); continue; } catch (MalformedURLException e) { // Ignore } if (repository.endsWith("*.jar")) { repository = repository.substring(0, repository.length() - "*.jar".length()); repositoryLocations.add(repository); repositoryTypes.add(ClassLoaderFactory.IS_GLOB); } else if (repository.endsWith(".jar")) { repositoryLocations.add(repository); repositoryTypes.add(ClassLoaderFactory.IS_JAR); } else { repositoryLocations.add(repository); repositoryTypes.add(ClassLoaderFactory.IS_DIR); } } String[] locations = repositoryLocations.toArray(new String[0]); Integer[] types = repositoryTypes.toArray(new Integer[0]); ClassLoader classLoader = ClassLoaderFactory.createClassLoader(locations, types, parent); MBeanServer mBeanServer = null; if (MBeanServerFactory.findMBeanServer(null).size() > 0) { mBeanServer = MBeanServerFactory.findMBeanServer(null).get(0); } else { mBeanServer = ManagementFactory.getPlatformMBeanServer(); } ObjectName objectName = new ObjectName("Catalina:type=ServerClassLoader,name=" + name); mBeanServer.registerMBean(classLoader, objectName); return classLoader; }
/** * Session information for the web application at the specified context path. * Displays a profile of session thisAccessedTime listing number * of sessions for each 10 minute interval up to 10 hours. * * @param writer Writer to render to * @param path Context path of the application to list session information for * @param idle Expire all sessions with idle time &ge; idle for this context */ protected void sessions(PrintWriter writer, String path, int idle) { if (debug >= 1) { log("sessions: Session information for web application at '" + path + "'"); if (idle >= 0) log("sessions: Session expiration for " + idle + " minutes '" + path + "'"); } if ((path == null) || (!path.startsWith("/") && path.equals(""))) { writer.println(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); return; } String displayPath = path; if( path.equals("/") ) path = ""; try { Context context = (Context) host.findChild(path); if (context == null) { writer.println(sm.getString("managerServlet.noContext", RequestUtil.filter(displayPath))); return; } Manager manager = context.getManager() ; if(manager == null) { writer.println(sm.getString("managerServlet.noManager", RequestUtil.filter(displayPath))); return; } int maxCount = 60; int maxInactiveInterval = manager.getMaxInactiveInterval()/60; int histoInterval = maxInactiveInterval / maxCount; if ( histoInterval * maxCount < maxInactiveInterval ) histoInterval++; maxCount = maxInactiveInterval / histoInterval; if ( histoInterval * maxCount < maxInactiveInterval ) maxCount++; writer.println(sm.getString("managerServlet.sessions", displayPath)); writer.println(sm.getString("managerServlet.sessiondefaultmax", "" + maxInactiveInterval)); Session [] sessions = manager.findSessions(); int [] timeout = new int[maxCount]; int notimeout = 0; int expired = 0; long now = System.currentTimeMillis(); for (int i = 0; i < sessions.length; i++) { int time = (int)((now-sessions[i].getThisAccessedTimeInternal())/1000); if (idle >= 0 && time >= idle*60) { sessions[i].expire(); idle++; } time=time/60/histoInterval; if (time < 0) notimeout++; } } }
private final void internalMapExtensionWrapper(Wrapper[] wrappers, CharChunk path, MappingData mappingData) { char[] buf = path.getBuffer(); int pathEnd = path.getEnd(); int servletPath = path.getOffset(); int slash = -1; for (int i = pathEnd - 1; i >= servletPath; i--) { if (buf[i] == '/') { slash = i; break; } } if (slash >= 0) { int period = -1; for (int i = pathEnd - 1; i > slash; i--) { if (buf[i] == '.') { period = i; break; } } if (period >= 0) { path.setOffset(period + 1); path.setEnd(pathEnd); int pos = find(wrappers, path); if ((pos != -1) && (path.equals(wrappers[pos].name))) { mappingData.wrapperPath.setChars(buf, servletPath, pathEnd - servletPath); mappingData.requestPath.setChars(buf, servletPath, pathEnd - servletPath); mappingData.wrapper = wrappers[pos].object; } path.setOffset(servletPath); path.setEnd(pathEnd); } } }
protected String reportFailedQuery(String query, Object[] args, final String name, long start, Throwable t) { String sql = (query == null && args != null && args.length > 0) ? (String) args[0] : query; if (sql == null && compare(executes[3], name)) { sql = "batch"; } return sql; }	protected String reportQuery(String query, Object[] args, final String name, long start, long delta) { String sql = (query == null && args != null && args.length > 0) ? (String) args[0] : query; if (sql == null && compare(executes[3], name)) { sql = "batch"; } return sql; }	protected String reportSlowQuery(String query, Object[] args, final String name, long start, long delta) { String sql = (query == null && args != null && args.length > 0) ? (String) args[0] : query; if (sql == null && compare(executes[3], name)) { sql = "batch"; } return sql; }	@Override public Object createStatement(Object proxy, Method method, Object[] args, Object statement, long time) { try { Object result = null; String name = method.getName(); String sql = null; Constructor<?> constructor = null; if (compare(statements[0], name)) { constructor = getConstructor(0, Statement.class); } else if (compare(statements[1], name)) { sql = (String) args[0]; constructor = getConstructor(1, PreparedStatement.class); if (sql != null) { prepareStatement(sql, time); } } else if (compare(statements[2], name)) { sql = (String) args[0]; constructor = getConstructor(2, CallableStatement.class); prepareCall(sql, time); } else { return statement; } result = constructor.newInstance(new Object[] { new StatementProxy(statement, sql) }); return result; } catch (Exception x) { log.warn("Unable to create statement proxy for slow query report.", x); } return statement; }	@Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (compare(CLOSE_VAL, method)) { closeInvoked(); return super.invoke(proxy, method, args); } else { boolean process = false; process = process(statements, method, process); if (process) { long start = System.currentTimeMillis(); Object statement = super.invoke(proxy, method, args); long delta = System.currentTimeMillis() - start; return createStatement(proxy, method, args, statement, delta); } else { return super.invoke(proxy, method, args); } } }	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { final String name = method.getName(); boolean close = compare(JdbcInterceptor.CLOSE_VAL, name); if (close && closed) return null; if (compare(JdbcInterceptor.ISCLOSED_VAL, name)) return Boolean.valueOf(closed); if (closed) throw new SQLException("Statement closed."); boolean process = false; process = process(executes, method, process); long start = (process) ? System.currentTimeMillis() : 0; Object result = null; try { result = method.invoke(delegate, args); } catch (Throwable t) { reportFailedQuery(query, args, name, start, t); if (t instanceof InvocationTargetException) { InvocationTargetException it = (InvocationTargetException) t; throw it.getCause() != null ? it.getCause() : it; } else { throw t; } } long delta = (process) ? (System.currentTimeMillis() - start) : Long.MIN_VALUE; if (delta > threshold) { try { reportSlowQuery(query, args, name, start, delta); } catch (Exception t) { if (log.isWarnEnabled()) log.warn("Unable to process slow query", t); } } else if (process) { reportQuery(query, args, name, start, delta); } if (close) { closed = true; delegate = null; } return result; }
@Override protected void tearDown() throws Exception { Driver.reset(); ds.close(true); super.tearDown(); }	public void testBrutalNonFair() throws Exception { ds.getPoolProperties().setRemoveAbandoned(false); ds.getPoolProperties().setRemoveAbandonedTimeout(1); ds.getPoolProperties().setMinEvictableIdleTimeMillis(100); ds.getPoolProperties().setTimeBetweenEvictionRunsMillis(10); ds.getConnection().close(); final int iter = 100000 * 10; final AtomicInteger loopcount = new AtomicInteger(0); final Runnable run = new Runnable() { public void run() { try { while (loopcount.incrementAndGet() < iter) { Connection con = ds.getConnection(); con.close(); } } catch (Exception x) { loopcount.set(iter); x.printStackTrace(); } } }; Thread[] threads = new Thread[20]; for (int i = 0; i < threads.length; i++) { threads[i] = new Thread(run); } for (int i = 0; i < threads.length; i++) { threads[i].start(); } try { while (loopcount.get() < iter) { assertTrue("Size comparison(less than 11):", ds.getPool().getSize() <= 10); ds.getPool().testAllIdle(); ds.getPool().checkAbandoned(); ds.getPool().checkIdle(); } } catch (Exception x) { loopcount.set(iter); x.printStackTrace(); } for (int i = 0; i < threads.length; i++) { threads[i].join(); } System.out.println("Connect count:" + Driver.connectCount.get()); System.out.println("DisConnect count:" + Driver.disconnectCount.get()); assertEquals("Size comparison:", 10, ds.getPool().getSize()); assertEquals("Idle comparison:", 10, ds.getPool().getIdle()); assertEquals("Used comparison:", 0, ds.getPool().getActive()); assertEquals("Connect count", 10, Driver.connectCount.get()); }
public E element() { throw new UnsupportedOperationException("E element()"); }	public E element() { throw new UnsupportedOperationException("E element()"); }	public E peek() { throw new UnsupportedOperationException("E peek()"); }	public E peek() { throw new UnsupportedOperationException("E peek()"); }	public boolean add(E e) { return offer(e); }	public boolean add(E e) { return offer(e); }	public boolean addAll(Collection<? extends E> c) { Iterator i = c.iterator(); while (i.hasNext()) { E e = (E) i.next(); offer(e); } return true; }	public boolean addAll(Collection<? extends E> c) { Iterator i = c.iterator(); while (i.hasNext()) { E e = (E) i.next(); offer(e); } return true; }	public boolean isEmpty() { return size() == 0; }	public boolean isEmpty() { return size() == 0; }	public boolean removeAll(Collection<?> c) { throw new UnsupportedOperationException("boolean removeAll(Collection<?> c)"); }	public boolean removeAll(Collection<?> c) { throw new UnsupportedOperationException("boolean removeAll(Collection<?> c)"); }	public <T> T[] toArray(T[] a) { throw new UnsupportedOperationException("<T> T[] toArray(T[] a)"); }	public <T> T[] toArray(T[] a) { throw new UnsupportedOperationException("<T> T[] toArray(T[] a)"); }	public int drainTo(Collection<? super E> c, int maxElements) { throw new UnsupportedOperationException("int drainTo(Collection<? super E> c, int maxElements)"); }	public int drainTo(Collection<? super E> c, int maxElements) { throw new UnsupportedOperationException("int drainTo(Collection<? super E> c, int maxElements)"); }	public void clear() { throw new UnsupportedOperationException("void clear()"); }	public void clear() { throw new UnsupportedOperationException("void clear()"); }
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType("text/plain"); PrintWriter out = resp.getWriter(); Enumeration<String> names = req.getParameterNames(); while (names.hasMoreElements()) { String name = names.nextElement(); out.println(name + "=" + req.getParameter(name)); } }	public void testBug37794() throws Exception { Bug37794Client client = new Bug37794Client(); // Edge cases around zero client.doRequest(-1, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(0, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(1, false); assertTrue(client.isResponse500()); client.reset(); client.reset(); client.doRequest(6, false); assertTrue(client.isResponse500()); client.reset(); client.doRequest(7, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(8, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(8096, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(8096, true); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); }	public boolean isResponseBodyOK() { if (getResponseBody() == null) { return false; } if (!getResponseBody().contains("a=1")) { return false; } if (!getResponseBody().contains("b=2")) { return false; } return true; }	public void connect() throws UnknownHostException, IOException { socket = new Socket("localhost", 8080); OutputStream os = socket.getOutputStream(); writer = new OutputStreamWriter(os); InputStream is = socket.getInputStream(); Reader r = new InputStreamReader(is); reader = new BufferedReader(r); }	public void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException { res.getWriter().write("Hello world"); }	public void testBug37794() throws Exception { Bug37794Client client = new Bug37794Client(); // Edge cases around zero client.doRequest(-1, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(0, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(1, false); assertTrue(client.isResponse500()); client.reset(); client.reset(); client.doRequest(6, false); assertTrue(client.isResponse500()); client.reset(); client.doRequest(7, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(8, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(8096, false); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); client.reset(); client.doRequest(8096, true); assertTrue(client.isResponse200()); assertTrue(client.isResponseBodyOK()); }	public void testLaunchTime() throws Exception { tomcat.addContext(null, "/", base); tomcat.start(); }	public void testProgrammatic() throws Exception { StandardContext ctx = tomcat.addContext("/", tempDir.getAbsolutePath()); // You can customize the context by calling Tomcat.addServlet(ctx, "myServlet", new HelloWorld()); ctx.addServletMapping("/", "myServlet"); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + port + "/"); assertEquals(res.toString(), "Hello world"); }	public void testSingleWebapp() throws Exception { File appDir = new File(base + "output/build/webapps/examples"); tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + port + "/examples/servlets/servlet/HelloWorldExample"); assertTrue(res.toString().indexOf("<h1>Hello World!</h1>") > 0); }
void setUp() throws Exception { t0 = System.currentTimeMillis(); tempDir = new File("output/tmp"); tempDir.mkdir(); tomcat = new Tomcat(); tomcat.getHost().setAppBase(tempDir.getAbsolutePath()); tomcat.setBaseDir(tempDir.getAbsolutePath()); // If each test is running on same port - they port++; tomcat.setPort(port); }	public void tearDown() throws Exception { tomcat.stop(); System.err.println("Test time: " + (System.currentTimeMillis() - t0)); }
static String interpreterCall(boolean isTagFile, String expression, Class<?> expectedType, String fnmapvar, boolean XmlEscape) { String jspCtxt = null; if (isTagFile) jspCtxt = "this.getJspContext()"; else jspCtxt = "_jspx_page_context"; String targetType = expectedType.getName(); String primitiveConverterMethod = null; if (expectedType.isPrimitive()) { if (expectedType.equals(Boolean.TYPE)) { targetType = Boolean.class.getName(); primitiveConverterMethod = "booleanValue"; } else if (expectedType.equals(Byte.TYPE)) { targetType = Byte.class.getName(); primitiveConverterMethod = "byteValue"; } else if (expectedType.equals(Character.TYPE)) { targetType = Character.class.getName(); primitiveConverterMethod = "charValue"; } else if (expectedType.equals(Short.TYPE)) { targetType = Short.class.getName(); primitiveConverterMethod = "shortValue"; } else if (expectedType.equals(Integer.TYPE)) { targetType = Integer.class.getName(); primitiveConverterMethod = "intValue"; } else if (expectedType.equals(Long.TYPE)) { targetType = Long.class.getName(); primitiveConverterMethod = "longValue"; } else if (expectedType.equals(Float.TYPE)) { targetType = Float.class.getName(); primitiveConverterMethod = "floatValue"; } else if (expectedType.equals(Double.TYPE)) { targetType = Double.class.getName(); primitiveConverterMethod = "doubleValue"; } } if (primitiveConverterMethod != null) { XmlEscape = false; } /* * Build up the base call to the interpreter. */ // XXX - We use a proprietary call to the interpreter for now // as the current standard machinery is inefficient and requires // lots of wrappers and adapters. This should all clear up once // the EL interpreter moves out of JSTL and into its own project. // In the future, this should be replaced by code that calls // ExpressionEvaluator.parseExpression() and then cache the resulting // expression objects. The interpreterCall would simply select // one of the pre-cached expressions and evaluate it. // Note that PageContextImpl implements VariableResolver and // the generated Servlet/SimpleTag implements FunctionMapper, so targetType = toJavaSourceType(targetType); StringBuffer call = new StringBuffer("(" + targetType + ") " + "org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate" + "(" + Generator.quote(expression) + ", " + targetType + ".class, " + "(PageContext)" + jspCtxt + ", " + fnmapvar + ", " + XmlEscape + ")"); if (primitiveConverterMethod != null) { call.insert(0, "("); call.append(")." + primitiveConverterMethod + "()"); } return call.toString(); }
public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String jspUri = null; String jspFile = (String) request.getAttribute(Constants.JSP_FILE); if (jspFile != null) { jspUri = jspFile; } else { jspUri = (String) request.getAttribute(Constants.INC_SERVLET_PATH); if (jspUri != null) { String pathInfo = (String) request.getAttribute("javax.servlet.include.path_info"); if (pathInfo != null) { jspUri += pathInfo; } } else { jspUri = request.getServletPath(); String pathInfo = request.getPathInfo(); if (pathInfo != null) { jspUri += pathInfo; } } } if (log.isDebugEnabled()) { log.debug("JspEngine --> " + jspUri); log.debug("\t ServletPath: " + request.getServletPath()); log.debug("\t PathInfo: " + request.getPathInfo()); log.debug("\t RealPath: " + context.getRealPath(jspUri)); log.debug("\t RequestURI: " + request.getRequestURI()); log.debug("\t QueryString: " + request.getQueryString()); log.debug("\t Request Params: "); Enumeration<String> e = request.getParameterNames(); while (e.hasMoreElements()) { String name = e.nextElement(); log.debug("\t\t " + name + " = " + request.getParameter(name)); } } try { boolean precompile = preCompile(request); serviceJspFile(request, response, jspUri, null, precompile); } catch (RuntimeException e) { throw e; } catch (ServletException e) { throw e; } catch (IOException e) { throw e; } catch (Throwable e) { throw new ServletException(e); } }

protected void clearReferences() { InputStream is = getResourceAsStream("org/apache/catalina/loader/JdbcLeakPrevention.class"); // Cheat - we know roughly how big the class will be (~1K) but allow byte[] classBytes = new byte[4096]; int offset = 0; try { int read = is.read(classBytes, offset, 4096 - offset); while (read > -1) { offset += read; read = is.read(classBytes, offset, 4096 - offset); } Class<?> lpClass = defineClass("org.apache.catalina.loader.JdbcLeakPrevention", classBytes, 0, offset); Object obj = lpClass.newInstance(); obj.getClass().getMethod("clearJdbcDriverRegistrations").invoke(obj); } catch (Exception e) { log.warn(sm.getString("webappClassLoader.jdbcRemoveFailed"), e); } finally { if (is != null) { try { is.close(); } catch (IOException ioe) { log.warn(sm.getString("webappClassLoader.jdbcRemoveStreamError"), ioe); } } } if (ENABLE_CLEAR_REFERENCES) { Iterator<ResourceEntry> loadedClasses = ((HashMap<String, ResourceEntry>) resourceEntries.clone()).values().iterator(); while (loadedClasses.hasNext()) { ResourceEntry entry = loadedClasses.next(); if (entry.loadedClass != null) { Class<?> clazz = entry.loadedClass; try { Field[] fields = clazz.getDeclaredFields(); for (int i = 0; i < fields.length; i++) { Field field = fields[i]; int mods = field.getModifiers(); if (field.getType().isPrimitive() || (field.getName().indexOf("$") != -1)) { continue; } if (Modifier.isStatic(mods)) { try { field.setAccessible(true); if (Modifier.isFinal(mods)) { if (!((field.getType().getName().startsWith("java.")) || (field.getType().getName().startsWith("javax.")))) { nullInstance(field.get(null)); } } else { field.set(null, null); if (log.isDebugEnabled()) { log.debug("Set field " + field.getName() + " to null in class " + clazz.getName()); } } } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug("Could not set field " + field.getName() + " to null in class " + clazz.getName(), t); } } } } } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug("Could not clean fields for class " + clazz.getName(), t); } } } } } IntrospectionUtils.clear(); org.apache.juli.logging.LogFactory.release(this); java.beans.Introspector.flushCaches(); }
protected void changeSessionID(Request request, Response response, String sessionId, String newSessionID, Session catalinaSession) { lifecycle.fireLifecycleEvent("Before session migration", catalinaSession); catalinaSession.setId(newSessionID); if (catalinaSession instanceof DeltaSession) ((DeltaSession) catalinaSession).resetDeltaRequest(); changeRequestSessionID(request, response, sessionId, newSessionID); ClusterManager manager = (ClusterManager) catalinaSession.getManager(); sendSessionIDClusterBackup(manager, request, sessionId, newSessionID); lifecycle.fireLifecycleEvent("After session migration", catalinaSession); if (log.isDebugEnabled()) { log.debug(sm.getString("jvmRoute.changeSession", sessionId, newSessionID)); } }	public void invoke(Request request, Response response) throws IOException, ServletException { if (getEnabled() && getCluster() != null && request.getContext() != null && request.getContext().getDistributable()) { // valve cluster can access manager - other cluster handle turnover Manager manager = request.getContext().getManager(); if (manager != null && manager instanceof ClusterManager && getCluster().getManager(((ClusterManager) manager).getName()) != null) handlePossibleTurnover(request, response); } getNext().invoke(request, response); }	public void start() throws LifecycleException { if (started) throw new LifecycleException(sm.getString("jvmRoute.valve.alreadyStarted")); lifecycle.fireLifecycleEvent(START_EVENT, null); started = true; if (cluster == null) { Container hostContainer = getContainer(); if (!(hostContainer instanceof Host)) { if (log.isWarnEnabled()) log.warn(sm.getString("jvmRoute.configure.warn")); hostContainer = hostContainer.getParent(); } if (hostContainer instanceof Host && ((Host) hostContainer).getCluster() != null) { cluster = (CatalinaCluster) ((Host) hostContainer).getCluster(); } else { Container engine = hostContainer.getParent(); if (engine instanceof Engine && ((Engine) engine).getCluster() != null) { cluster = (CatalinaCluster) ((Engine) engine).getCluster(); } } } if (cluster == null) { throw new RuntimeException("No clustering support at container " + container.getName()); } if (log.isInfoEnabled()) log.info(sm.getString("jvmRoute.valve.started")); }
public ClusterMessage requestCompleted(String sessionId) { DeltaSession session = null; try { session = (DeltaSession) findSession(sessionId); DeltaRequest deltaRequest = session.getDeltaRequest(); session.lock(); SessionMessage msg = null; boolean isDeltaRequest = false; synchronized (deltaRequest) { isDeltaRequest = deltaRequest.getSize() > 0; if (isDeltaRequest) { counterSend_EVT_SESSION_DELTA++; byte[] data = serializeDeltaRequest(session, deltaRequest); msg = new SessionMessageImpl(getName(), SessionMessage.EVT_SESSION_DELTA, data, sessionId, sessionId + "-" + System.currentTimeMillis()); session.resetDeltaRequest(); } } if (!isDeltaRequest) { if (!session.isPrimarySession()) { counterSend_EVT_SESSION_ACCESSED++; msg = new SessionMessageImpl(getName(), SessionMessage.EVT_SESSION_ACCESSED, null, sessionId, sessionId + "-" + System.currentTimeMillis()); if (log.isDebugEnabled()) { log.debug(sm.getString("deltaManager.createMessage.accessChangePrimary", getName(), sessionId)); } } } else { if (log.isDebugEnabled()) { log.debug(sm.getString("deltaManager.createMessage.delta", getName(), sessionId)); } } session.setPrimarySession(true); if ((msg == null)) { long replDelta = System.currentTimeMillis() - session.getLastTimeReplicated(); if (replDelta > (getMaxInactiveInterval() * 1000)) { counterSend_EVT_SESSION_ACCESSED++; msg = new SessionMessageImpl(getName(), SessionMessage.EVT_SESSION_ACCESSED, null, sessionId, sessionId + "-" + System.currentTimeMillis()); if (log.isDebugEnabled()) { log.debug(sm.getString("deltaManager.createMessage.access", getName(), sessionId)); } } } if (msg != null) session.setLastTimeReplicated(System.currentTimeMillis()); return msg; } catch (IOException x) { log.error(sm.getString("deltaManager.createMessage.unableCreateDeltaRequest", sessionId), x); return null; } finally { if (session != null) session.unlock(); } }
public void expire(boolean notify) { if (expiring) return; synchronized (this) { if (manager == null) return; expiring = true; // Notify interested application event listeners Context context = (Context) manager.getContainer(); Object[] listeners = context.getApplicationLifecycleListeners(); if (notify && (listeners != null)) { HttpSessionEvent event = new HttpSessionEvent(getSession()); for (int i = 0; i < listeners.length; i++) { int j = (listeners.length - 1) - i; if (!(listeners[j] instanceof HttpSessionListener)) continue; HttpSessionListener listener = (HttpSessionListener) listeners[j]; try { fireContainerEvent(context, "beforeSessionDestroyed", listener); listener.sessionDestroyed(event); fireContainerEvent(context, "afterSessionDestroyed", listener); } catch (Throwable t) { try { fireContainerEvent(context, "afterSessionDestroyed", listener); } catch (Exception e) { // Ignore } manager.getContainer().getLogger().error(sm.getString("standardSession.sessionEvent"), t); } } } if (ACTIVITY_CHECK) { accessCount.set(0); } setValid(false); long timeNow = System.currentTimeMillis(); int timeAlive = (int) ((timeNow - creationTime) / 1000); synchronized (manager) { if (timeAlive > manager.getSessionMaxAliveTime()) { manager.setSessionMaxAliveTime(timeAlive); } int numExpired = manager.getExpiredSessions(); numExpired++; manager.setExpiredSessions(numExpired); int average = manager.getSessionAverageAliveTime(); average = ((average * (numExpired - 1)) + timeAlive) / numExpired; manager.setSessionAverageAliveTime(average); } manager.remove(this); if (notify) { fireSessionEvent(Session.SESSION_DESTROYED_EVENT, null); } if (principal instanceof GenericPrincipal) { GenericPrincipal gp = (GenericPrincipal) principal; try { gp.logout(); } catch (Exception e) { manager.getContainer().getLogger().error(sm.getString("standardSession.logoutfail"), e); } } expiring = false; String[] keys = keys(); for (int i = 0; i < keys.length; i++) removeAttributeInternal(keys[i], notify); } }
public void setUdpTxBufSize(int udpTxBufSize) { this.udpTxBufSize = udpTxBufSize; }	public void start() throws IOException { if (executor == null) { TaskQueue taskqueue = new TaskQueue(); TaskThreadFactory tf = new TaskThreadFactory("Tribes-Task-Receiver-"); executor = new ThreadPoolExecutor(minThreads, maxThreads, maxIdleTime, TimeUnit.MILLISECONDS, taskqueue, tf); taskqueue.setParent((ThreadPoolExecutor) executor); } }
protected Principal authenticate(String username, CallbackHandler callbackHandler) { try { LoginContext loginContext = null; if (appName == null) appName = "Tomcat"; if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.beginLogin", username, appName)); ClassLoader ocl = null; if (!isUseContextClassLoader()) { ocl = Thread.currentThread().getContextClassLoader(); Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); } try { loginContext = new LoginContext(appName, callbackHandler); } catch (Throwable e) { log.error(sm.getString("jaasRealm.unexpectedError"), e); return (null); } finally { if (!isUseContextClassLoader()) { Thread.currentThread().setContextClassLoader(ocl); } } if (log.isDebugEnabled()) log.debug("Login context created " + username); Subject subject = null; try { loginContext.login(); subject = loginContext.getSubject(); if (subject == null) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.failedLogin", username)); return (null); } } catch (AccountExpiredException e) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.accountExpired", username)); return (null); } catch (CredentialExpiredException e) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.credentialExpired", username)); return (null); } catch (FailedLoginException e) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.failedLogin", username)); return (null); } catch (LoginException e) { log.warn(sm.getString("jaasRealm.loginException", username), e); return (null); } catch (Throwable e) { log.error(sm.getString("jaasRealm.unexpectedError"), e); return (null); } if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.loginContextCreated", username)); Principal principal = createPrincipal(username, subject); if (principal == null) { log.debug(sm.getString("jaasRealm.authenticateFailure", username)); return (null); } if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.authenticateSuccess", username)); } return (principal); } catch (Throwable t) { log.error("error ", t); return null; } }	protected Principal createPrincipal(String username, Subject subject) { List<String> roles = new ArrayList<String>(); Principal userPrincipal = null; Iterator<Principal> principals = subject.getPrincipals().iterator(); while (principals.hasNext()) { Principal principal = principals.next(); String principalClass = principal.getClass().getName(); if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.checkPrincipal", principal, principalClass)); } if (userPrincipal == null && userClasses.contains(principalClass)) { userPrincipal = principal; if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.userPrincipalSuccess", principal.getName())); } } if (roleClasses.contains(principalClass)) { roles.add(principal.getName()); if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.rolePrincipalAdd", principal.getName())); } } } if (userPrincipal == null) { if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.userPrincipalFailure")); log.debug(sm.getString("jaasRealm.rolePrincipalFailure")); } } else { if (roles.size() == 0) { if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.rolePrincipalFailure")); } } } return new GenericPrincipal(this, username, null, roles, userPrincipal); }	protected Principal getPrincipal(String username) { return authenticate(username, new JAASCallbackHandler(this, username, null, null, null, null, null, null, null, Constants.CERT_METHOD)); }	public Principal getUserPrincipal() { if (userPrincipal != null) { return userPrincipal; } else { return this; } }	public void expire(boolean notify) { if (expiring) return; synchronized (this) { if (manager == null) return; expiring = true; // Notify interested application event listeners Context context = (Context) manager.getContainer(); Object[] listeners = context.getApplicationLifecycleListeners(); if (notify && (listeners != null)) { HttpSessionEvent event = new HttpSessionEvent(getSession()); for (int i = 0; i < listeners.length; i++) { int j = (listeners.length - 1) - i; if (!(listeners[j] instanceof HttpSessionListener)) continue; HttpSessionListener listener = (HttpSessionListener) listeners[j]; try { fireContainerEvent(context, "beforeSessionDestroyed", listener); listener.sessionDestroyed(event); fireContainerEvent(context, "afterSessionDestroyed", listener); } catch (Throwable t) { try { fireContainerEvent(context, "afterSessionDestroyed", listener); } catch (Exception e) { // Ignore } manager.getContainer().getLogger().error(sm.getString("standardSession.sessionEvent"), t); } } } if (ACTIVITY_CHECK) { accessCount.set(0); } setValid(false); long timeNow = System.currentTimeMillis(); int timeAlive = (int) ((timeNow - creationTime) / 1000); synchronized (manager) { if (timeAlive > manager.getSessionMaxAliveTime()) { manager.setSessionMaxAliveTime(timeAlive); } int numExpired = manager.getExpiredSessions(); numExpired++; manager.setExpiredSessions(numExpired); int average = manager.getSessionAverageAliveTime(); average = ((average * (numExpired - 1)) + timeAlive) / numExpired; manager.setSessionAverageAliveTime(average); } manager.remove(this); if (notify) { fireSessionEvent(Session.SESSION_DESTROYED_EVENT, null); } expiring = false; String[] keys = keys(); for (int i = 0; i < keys.length; i++) removeAttributeInternal(keys[i], notify); } }
void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException { try { lock(); ReplicationStream stream = ((ClusterManager) getManager()).getReplicationStream(diff, offset, length); getDeltaRequest().readExternal(stream); ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); try { ClassLoader[] loaders = getClassLoaders(); if (loaders != null && loaders.length > 0) Thread.currentThread().setContextClassLoader(loaders[0]); getDeltaRequest().execute(this); } finally { Thread.currentThread().setContextClassLoader(contextLoader); } } finally { unlock(); } }
private void generatePostamble() { out.popIndent(); out.printil("} catch (Throwable t) {"); out.pushIndent(); out.printil("if (!(t instanceof SkipPageException)){"); out.pushIndent(); out.printil("out = _jspx_out;"); out.printil("if (out != null && out.getBufferSize() != 0)"); out.pushIndent(); out.printil("try { out.clearBuffer(); } catch (java.io.IOException e) {}"); out.popIndent(); out.printil("if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("} finally {"); out.pushIndent(); out.printil("_jspxFactory.releasePageContext(_jspx_page_context);"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); genCommonPostamble(); }	public void setTrimDirectiveWhitespaces(boolean trimDirectiveWhitespaces) { this.trimDirectiveWhitespaces = trimDirectiveWhitespaces; }	private void generateXmlProlog(Node.Nodes page) { String omitXmlDecl = pageInfo.getOmitXmlDecl(); if ((omitXmlDecl != null && !JspUtil.booleanValue(omitXmlDecl)) || (omitXmlDecl == null && page.getRoot().isXmlSyntax() && !pageInfo.hasJspRoot() && !ctxt.isTagFile())) { String cType = pageInfo.getContentType(); String charSet = cType.substring(cType.indexOf("charset=") + 8); out.printil("out.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"" + charSet + "\\\"?>\\n\");"); } String doctypeName = pageInfo.getDoctypeName(); if (doctypeName != null) { String doctypePublic = pageInfo.getDoctypePublic(); String doctypeSystem = pageInfo.getDoctypeSystem(); out.printin("out.write(\"<!DOCTYPE "); out.print(doctypeName); if (doctypePublic == null) { out.print(" SYSTEM \\\""); } else { out.print(" PUBLIC \\\""); out.print(doctypePublic); out.print("\\\" \\\""); } out.print(doctypeSystem); out.println("\\\">\\n\");"); } }	public void visit(Node.GetProperty n) throws JasperException { String name = n.getTextAttribute("name"); String property = n.getTextAttribute("property"); n.setBeginJavaLine(out.getJavaLine()); if (beanInfo.checkVariable(name)) { Class<?> bean = beanInfo.getBeanType(name); String beanName = JspUtil.getCanonicalName(bean); java.lang.reflect.Method meth = JspRuntimeLibrary.getReadMethod(bean, property); String methodName = meth.getName(); out.printil("out.write(org.apache.jasper.runtime.JspRuntimeLibrary.toString(" + "(((" + beanName + ")_jspx_page_context.findAttribute(" + "\"" + name + "\"))." + methodName + "())));"); } else { // The object could be a custom action with an associated // VariableInfo entry for this name. out.printil("out.write(org.apache.jasper.runtime.JspRuntimeLibrary.toString" + "(org.apache.jasper.runtime.JspRuntimeLibrary.handleGetProperty" + "(_jspx_page_context.getAttribute(\"" + name + "\", PageContext.PAGE_SCOPE), \"" + property + "\")));"); } n.setEndJavaLine(out.getJavaLine()); }
protected boolean compareCredentials(DirContext context, User info, String credentials) throws NamingException { if (info == null || credentials == null) return (false); String password = info.password; if (password == null) return (false); if (containerLog.isTraceEnabled()) containerLog.trace(" validating credentials"); boolean validated = false; if (hasMessageDigest()) { if (password.startsWith("{SHA}")) { synchronized (this) { password = password.substring(5); md.reset(); md.update(credentials.getBytes()); String digestedPassword = new String(Base64.encode(md.digest())); validated = password.equals(digestedPassword); } } else if (password.startsWith("{SSHA}")) { synchronized (this) { password = password.substring(6); md.reset(); md.update(credentials.getBytes()); ByteChunk pwbc = new ByteChunk(password.length()); try { pwbc.append(password.getBytes(), 0, password.length()); } catch (IOException e) { containerLog.error("Could not append password bytes to chunk: ", e); } CharChunk decoded = new CharChunk(); Base64.decode(pwbc, decoded); char[] pwarray = decoded.getBuffer(); final int saltpos = 20; byte[] hash = new byte[saltpos]; for (int i = 0; i < hash.length; i++) { hash[i] = (byte) pwarray[i]; } byte[] salt = new byte[pwarray.length - saltpos]; for (int i = 0; i < salt.length; i++) salt[i] = (byte) pwarray[i + saltpos]; md.update(salt); byte[] dp = md.digest(); validated = Arrays.equals(dp, hash); } // End synchronized(this) block } else { validated = (digest(credentials).equalsIgnoreCase(password)); } } else validated = (digest(credentials).equals(password)); return (validated); }
public void testC3P0Threads10Connections10Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setValidationQuery("SELECT 1"); this.datasource.getPoolProperties().setTestOnBorrow(true); this.threadcount = 10; this.transferPropertiesToC3P0(); this.c3p0Datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); for (int i = 0; i < threadcount; i++) { TestThread t = new TestThread(); t.setName("tomcat-pool-validate-" + i); t.d = this.c3p0Datasource; t.start(); } latch.await(); long delta = System.currentTimeMillis() - start; System.out.println("[testC3P0Threads10Connections10Validate]Test complete:" + delta + " ms. Iterations:" + (threadcount * this.iterations)); tearDown(); }	public void testC3P0Threads10Connections20Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setValidationQuery("SELECT 1"); this.datasource.getPoolProperties().setTestOnBorrow(true); this.threadcount = 20; this.transferPropertiesToC3P0(); this.c3p0Datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); for (int i = 0; i < threadcount; i++) { TestThread t = new TestThread(); t.setName("tomcat-pool-validate-" + i); t.d = this.c3p0Datasource; t.start(); } latch.await(); long delta = System.currentTimeMillis() - start; System.out.println("[testC3P0Threads10Connections20Validate]Test complete:" + delta + " ms. Iterations:" + (threadcount * this.iterations)); tearDown(); }	public void testDBCPThreads10Connections10Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setValidationQuery("SELECT 1"); this.datasource.getPoolProperties().setTestOnBorrow(true); this.threadcount = 10; this.transferProperties(); this.tDatasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); for (int i = 0; i < threadcount; i++) { TestThread t = new TestThread(); t.setName("tomcat-dbcp-validate-" + i); t.d = this.tDatasource; t.start(); } latch.await(); long delta = System.currentTimeMillis() - start; System.out.println("[testDBCPThreads10Connections10Validate]Test complete:" + delta + " ms. Iterations:" + (threadcount * this.iterations)); tearDown(); }	public void testDBCPThreads20Connections10Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setValidationQuery("SELECT 1"); this.datasource.getPoolProperties().setTestOnBorrow(true); this.threadcount = 20; this.transferProperties(); this.tDatasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); for (int i = 0; i < threadcount; i++) { TestThread t = new TestThread(); t.setName("tomcat-dbcp-validate-" + i); t.d = this.tDatasource; t.start(); } latch.await(); long delta = System.currentTimeMillis() - start; System.out.println("[testDBCPThreads20Connections10Validate]Test complete:" + delta + " ms. Iterations:" + (threadcount * this.iterations)); tearDown(); }	public void testFastSql() throws Exception { int count = 3; this.init(); this.datasource.setMaxActive(1); this.datasource.setJdbcInterceptors(SlowQueryReport.class.getName()); Connection con = this.datasource.getConnection(); String slowSql = "select 1"; for (int i = 0; i < count; i++) { Statement st = con.createStatement(); ResultSet rs = st.executeQuery(slowSql); rs.close(); st.close(); } Map<String, SlowQueryReport.QueryStats> map = SlowQueryReport.getPoolStats(datasource.getPool().getName()); assertNotNull(map); assertEquals(0, map.size()); ConnectionPool pool = datasource.getPool(); con.close(); tearDown(); assertNull(SlowQueryReport.getPoolStats(pool.getName())); }	public void testPoolThreads10Connections10Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setValidationQuery("SELECT 1"); this.datasource.getPoolProperties().setTestOnBorrow(true); this.datasource.getPoolProperties().setFairQueue(false); this.threadcount = 10; this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); for (int i = 0; i < threadcount; i++) { TestThread t = new TestThread(); t.setName("tomcat-pool-validate-" + i); t.d = this.datasource; t.start(); } latch.await(); long delta = System.currentTimeMillis() - start; System.out.println("[testPoolThreads10Connections10Validate]Test complete:" + delta + " ms. Iterations:" + (threadcount * this.iterations)); tearDown(); }	public void testPoolThreads10Connections10ValidateFair() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setValidationQuery("SELECT 1"); this.datasource.getPoolProperties().setTestOnBorrow(true); this.datasource.getPoolProperties().setFairQueue(true); this.threadcount = 10; this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); for (int i = 0; i < threadcount; i++) { TestThread t = new TestThread(); t.setName("tomcat-pool-validate-" + i); t.d = this.datasource; t.start(); } latch.await(); long delta = System.currentTimeMillis() - start; System.out.println("[testPoolThreads10Connections10ValidateFair]Test complete:" + delta + " ms. Iterations:" + (threadcount * this.iterations)); tearDown(); }	public void testPoolThreads10Connections20Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setValidationQuery("SELECT 1"); this.datasource.getPoolProperties().setTestOnBorrow(true); this.datasource.getPoolProperties().setFairQueue(false); this.threadcount = 20; this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); for (int i = 0; i < threadcount; i++) { TestThread t = new TestThread(); t.setName("tomcat-pool-validate-" + i); t.d = this.datasource; t.start(); } latch.await(); long delta = System.currentTimeMillis() - start; System.out.println("[testPoolThreads20Connections10Validate]Test complete:" + delta + " ms. Iterations:" + (threadcount * this.iterations)); tearDown(); }	public void testPoolThreads10Connections20ValidateFair() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setValidationQuery("SELECT 1"); this.datasource.getPoolProperties().setTestOnBorrow(true); this.datasource.getPoolProperties().setFairQueue(true); this.threadcount = 20; this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); for (int i = 0; i < threadcount; i++) { TestThread t = new TestThread(); t.setName("tomcat-pool-validate-" + i); t.d = this.datasource; t.start(); } latch.await(); long delta = System.currentTimeMillis() - start; System.out.println("[testPoolThreads20Connections10ValidateFair]Test complete:" + delta + " ms. Iterations:" + (threadcount * this.iterations)); tearDown(); }
public void connect() throws SQLException { if (released.get()) throw new SQLException("A connection once released, can't be reestablished."); if (connection != null) { try { this.disconnect(false); } catch (Exception x) { log.debug("Unable to disconnect previous connection.", x); } //catch } java.sql.Driver driver = null; try { driver = (java.sql.Driver) Class.forName(poolProperties.getDriverClassName(), true, PooledConnection.class.getClassLoader()).newInstance(); } catch (java.lang.Exception cn) { if (log.isDebugEnabled()) { log.debug("Unable to instantiate JDBC driver.", cn); } SQLException ex = new SQLException(cn.getMessage()); ex.initCause(cn); throw ex; } String driverURL = poolProperties.getUrl(); String usr = poolProperties.getUsername(); String pwd = poolProperties.getPassword(); poolProperties.getDbProperties().setProperty("user", usr); poolProperties.getDbProperties().setProperty("password", pwd); try { connection = driver.connect(driverURL, poolProperties.getDbProperties()); } catch (Exception x) { if (log.isDebugEnabled()) { log.debug("Unable to connect to database.", x); } if (parent.jmxPool != null) { parent.jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_CONNECT, ConnectionPool.getStackTrace(x)); } if (x instanceof SQLException) { throw (SQLException) x; } else { SQLException ex = new SQLException(x.getMessage()); ex.initCause(x); throw ex; } } if (poolProperties.getJdbcInterceptors() == null || poolProperties.getJdbcInterceptors().indexOf(ConnectionState.class.getName()) < 0) { if (poolProperties.getDefaultReadOnly() != null) connection.setReadOnly(poolProperties.getDefaultReadOnly().booleanValue()); if (poolProperties.getDefaultAutoCommit() != null) connection.setAutoCommit(poolProperties.getDefaultAutoCommit().booleanValue()); if (poolProperties.getDefaultCatalog() != null) connection.setCatalog(poolProperties.getDefaultCatalog()); if (poolProperties.getDefaultTransactionIsolation() != DataSourceFactory.UNKNOWN_TRANSACTIONISOLATION) connection.setTransactionIsolation(poolProperties.getDefaultTransactionIsolation()); } this.discarded = false; this.lastConnected = System.currentTimeMillis(); }
private void initSecurity() { // Setup the PermissionCollection for this web app context // based on the permissions configured for the root of the // web app context directory, then add a file read permission Policy policy = Policy.getPolicy(); if (policy != null) { try { String docBase = context.getRealPath("/"); if (docBase == null) { docBase = options.getScratchDir().toString(); } String codeBase = docBase; if (!codeBase.endsWith(File.separator)) { codeBase = codeBase + File.separator; } File contextDir = new File(codeBase); URL url = contextDir.getCanonicalFile().toURI().toURL(); codeSource = new CodeSource(url, (Certificate[]) null); permissionCollection = policy.getPermissions(codeSource); if (!docBase.endsWith(File.separator)) { permissionCollection.add(new FilePermission(docBase, "read")); docBase = docBase + File.separator; } else { permissionCollection.add(new FilePermission(docBase.substring(0, docBase.length() - 1), "read")); } docBase = docBase + "-"; permissionCollection.add(new FilePermission(docBase, "read")); // Create a file read permission for web app tempdir (work) String workDir = options.getScratchDir().toString(); if (!workDir.endsWith(File.separator)) { permissionCollection.add(new FilePermission(workDir, "read")); workDir = workDir + File.separator; } workDir = workDir + "-"; permissionCollection.add(new FilePermission(workDir, "read")); permissionCollection.add(new RuntimePermission("accessClassInPackage.org.apache.jasper.runtime")); if (parentClassLoader instanceof URLClassLoader) { URL[] urls = ((URLClassLoader) parentClassLoader).getURLs(); String jarUrl = null; String jndiUrl = null; for (int i = 0; i < urls.length; i++) { if (jndiUrl == null && urls[i].toString().startsWith("jndi:")) { jndiUrl = urls[i].toString() + "-"; } if (jarUrl == null && urls[i].toString().startsWith("jar:jndi:")) { jarUrl = urls[i].toString(); jarUrl = jarUrl.substring(0, jarUrl.length() - 2); jarUrl = jarUrl.substring(0, jarUrl.lastIndexOf('/')) + "/-"; } } if (jarUrl != null) { permissionCollection.add(new FilePermission(jarUrl, "read")); permissionCollection.add(new FilePermission(jarUrl.substring(4), "read")); } if (jndiUrl != null) permissionCollection.add(new FilePermission(jndiUrl, "read")); } } catch (Exception e) { context.log("Security Init for context failed", e); } } }
protected void setupSocket() throws IOException { if (mcastBindAddress != null) { try { log.info("Attempting to bind the multicast socket to " + address + ":" + port); socket = new MulticastSocket(new InetSocketAddress(address, port)); } catch (BindException e) { log.info("Binding to multicast address, failed. Binding to port only."); socket = new MulticastSocket(port); } } else { socket = new MulticastSocket(port); } socket.setLoopbackMode(true); if (mcastBindAddress != null) { if (log.isInfoEnabled()) log.info("Setting multihome multicast interface to:" + mcastBindAddress); socket.setInterface(mcastBindAddress); } if (mcastSoTimeout <= 0) mcastSoTimeout = (int) sendFrequency; if (log.isInfoEnabled()) log.info("Setting cluster mcast soTimeout to " + mcastSoTimeout); socket.setSoTimeout(mcastSoTimeout); if (mcastTTL >= 0) { if (log.isInfoEnabled()) log.info("Setting cluster mcast TTL to " + mcastTTL); socket.setTimeToLive(mcastTTL); } }	public void setRecoverySleepTime(long recoverySleepTime) { properties.setProperty("recoverySleepTime", String.valueOf(recoverySleepTime)); }	public void start(int level) throws java.lang.Exception { hasProperty(properties, "mcastPort"); hasProperty(properties, "mcastAddress"); hasProperty(properties, "memberDropTime"); hasProperty(properties, "mcastFrequency"); hasProperty(properties, "tcpListenPort"); hasProperty(properties, "tcpListenHost"); hasProperty(properties, "tcpSecurePort"); hasProperty(properties, "udpListenPort"); if (impl != null) { impl.start(level); return; } String host = getProperties().getProperty("tcpListenHost"); int port = Integer.parseInt(getProperties().getProperty("tcpListenPort")); int securePort = Integer.parseInt(getProperties().getProperty("tcpSecurePort")); int udpPort = Integer.parseInt(getProperties().getProperty("udpListenPort")); if (localMember == null) { localMember = new MemberImpl(host, port, 100); localMember.setUniqueId(UUIDGenerator.randomUUID(true)); } else { localMember.setHostname(host); localMember.setPort(port); localMember.setMemberAliveTime(100); } localMember.setSecurePort(securePort); localMember.setUdpPort(udpPort); if (this.payload != null) localMember.setPayload(payload); if (this.domain != null) localMember.setDomain(domain); localMember.setServiceStartTime(System.currentTimeMillis()); java.net.InetAddress bind = null; if (properties.getProperty("mcastBindAddress") != null) { bind = java.net.InetAddress.getByName(properties.getProperty("mcastBindAddress")); } int ttl = -1; int soTimeout = -1; if (properties.getProperty("mcastTTL") != null) { try { ttl = Integer.parseInt(properties.getProperty("mcastTTL")); } catch (Exception x) { log.error("Unable to parse mcastTTL=" + properties.getProperty("mcastTTL"), x); } } if (properties.getProperty("mcastSoTimeout") != null) { try { soTimeout = Integer.parseInt(properties.getProperty("mcastSoTimeout")); } catch (Exception x) { log.error("Unable to parse mcastSoTimeout=" + properties.getProperty("mcastSoTimeout"), x); } } impl = new McastServiceImpl(localMember, Long.parseLong(properties.getProperty("mcastFrequency")), Long.parseLong(properties.getProperty("memberDropTime")), Integer.parseInt(properties.getProperty("mcastPort")), bind, java.net.InetAddress.getByName(properties.getProperty("mcastAddress")), ttl, soTimeout, this, this); String value = properties.getProperty("recoveryEnabled", "true"); boolean recEnabled = Boolean.valueOf(value).booleanValue(); impl.setRecoveryEnabled(recEnabled); int recCnt = Integer.parseInt(properties.getProperty("recoveryCounter", "10")); impl.setRecoveryCounter(recCnt); long recSlpTime = Long.parseLong(properties.getProperty("recoverySleepTime", "5000")); impl.setRecoverySleepTime(recSlpTime); impl.start(level); }
protected void handleSESSION_CREATED(SessionMessage msg, Member sender) { counterReceive_EVT_SESSION_CREATED++; if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.createNewSession", getName(), msg.getSessionID())); DeltaSession session = (DeltaSession) createEmptySession(); session.setManager(this); session.setValid(true); session.setPrimarySession(false); session.setCreationTime(msg.getTimestamp()); session.setMaxInactiveInterval(getMaxInactiveInterval()); session.access(); if (notifySessionListenersOnReplication) session.setId(msg.getSessionID()); else session.setIdInternal(msg.getSessionID()); session.resetDeltaRequest(); session.endAccess(); }
public void replicate(Object key, boolean complete) { if (log.isTraceEnabled()) log.trace("Replicate invoked on key:" + key); MapEntry entry = (MapEntry) super.get(key); if (entry == null) return; if (!entry.isSerializable()) return; if (entry.isPrimary() && entry.getBackupNodes() != null && entry.getBackupNodes().length > 0) { Object value = entry.getValue(); boolean repl = complete || ((value instanceof ReplicatedMapEntry) && ((ReplicatedMapEntry) value).isDirty()); if (!repl) { if (log.isTraceEnabled()) log.trace("Not replicating:" + key + ", no change made"); return; } boolean diff = ((value instanceof ReplicatedMapEntry) && ((ReplicatedMapEntry) value).isDiffable()); MapMessage msg = null; if (diff) { ReplicatedMapEntry rentry = (ReplicatedMapEntry) entry.getValue(); try { rentry.lock(); msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP, true, (Serializable) entry.getKey(), null, rentry.getDiff(), entry.getPrimary(), entry.getBackupNodes()); } catch (IOException x) { log.error("Unable to diff object. Will replicate the entire object instead.", x); } finally { rentry.unlock(); } } if (msg == null) { msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP, false, (Serializable) entry.getKey(), (Serializable) entry.getValue(), null, entry.getPrimary(), entry.getBackupNodes()); } try { if (channel != null && entry.getBackupNodes() != null && entry.getBackupNodes().length > 0) { channel.send(entry.getBackupNodes(), msg, channelSendOptions); } } catch (ChannelException x) { log.error("Unable to replicate data.", x); } } //end if }
protected void deployDirectory(String contextPath, File dir, String file) { DeployedApplication deployedApp = new DeployedApplication(contextPath); if (deploymentExists(contextPath)) return; if (log.isInfoEnabled()) log.info(sm.getString("hostConfig.deployDir", file)); try { Context context = null; File xml = new File(dir, Constants.ApplicationContextXml); if (deployXML && xml.exists()) { synchronized (digester) { try { context = (Context) digester.parse(xml); if (context == null) { log.error(sm.getString("hostConfig.deployDescriptor.error", xml)); return; } } finally { digester.reset(); } } File xmlCopy = new File(configBase(), file + ".xml"); InputStream is = null; OutputStream os = null; try { is = new FileInputStream(xml); os = new FileOutputStream(xmlCopy); IOTools.flow(is, os); // Don't catch IOE - let the outer try/catch handle it } finally { try { if (is != null) is.close(); } catch (IOException e) { // Ignore } try { if (os != null) os.close(); } catch (IOException e) { // Ignore } } context.setConfigFile(xmlCopy.getAbsolutePath()); deployedApp.redeployResources.put(xmlCopy.getAbsolutePath(), new Long(xmlCopy.lastModified())); } else { context = (Context) Class.forName(contextClass).newInstance(); } if (context instanceof Lifecycle) { Class<?> clazz = Class.forName(host.getConfigClass()); LifecycleListener listener = (LifecycleListener) clazz.newInstance(); ((Lifecycle) context).addLifecycleListener(listener); } context.setPath(contextPath); context.setDocBase(file); host.addChild(context); deployedApp.redeployResources.put(dir.getAbsolutePath(), new Long(dir.lastModified())); addWatchedResources(deployedApp, dir.getAbsolutePath(), context); } catch (Throwable t) { log.error(sm.getString("hostConfig.deployDir.error", file), t); } deployed.put(contextPath, deployedApp); }	protected void deployWAR(String contextPath, File war, String file) { if (deploymentExists(contextPath)) return; JarFile jar = null; JarEntry entry = null; InputStream istream = null; BufferedOutputStream ostream = null; File xml = new File(configBase(), file.substring(0, file.lastIndexOf(".")) + ".xml"); if (deployXML && !xml.exists()) { try { jar = new JarFile(war); entry = jar.getJarEntry(Constants.ApplicationContextXml); if (entry != null) { istream = jar.getInputStream(entry); ostream = new BufferedOutputStream(new FileOutputStream(xml), 1024); byte[] buffer = new byte[1024]; while (true) { int n = istream.read(buffer); if (n < 0) { break; } ostream.write(buffer, 0, n); } ostream.flush(); ostream.close(); ostream = null; istream.close(); istream = null; entry = null; jar.close(); jar = null; } } catch (Exception e) { if (ostream != null) { try { ostream.close(); } catch (Throwable t) { // Ignore } ostream = null; } if (istream != null) { try { istream.close(); } catch (Throwable t) { // Ignore } istream = null; } } finally { entry = null; if (jar != null) { try { jar.close(); } catch (Throwable t) { // Ignore } jar = null; } } } DeployedApplication deployedApp = new DeployedApplication(contextPath); if (log.isInfoEnabled()) log.info(sm.getString("hostConfig.deployJar", file)); try { Context context = null; if (deployXML && xml.exists()) { synchronized (digester) { try { context = (Context) digester.parse(xml); if (context == null) { log.error(sm.getString("hostConfig.deployDescriptor.error", file)); return; } } finally { digester.reset(); } } context.setConfigFile(xml.getAbsolutePath()); deployedApp.redeployResources.put(xml.getAbsolutePath(), new Long(xml.lastModified())); } else { context = (Context) Class.forName(contextClass).newInstance(); } deployedApp.redeployResources.put(war.getAbsolutePath(), new Long(war.lastModified())); if (context instanceof Lifecycle) { Class<?> clazz = Class.forName(host.getConfigClass()); LifecycleListener listener = (LifecycleListener) clazz.newInstance(); ((Lifecycle) context).addLifecycleListener(listener); } context.setPath(contextPath); context.setDocBase(file); host.addChild(context); if (unpackWARs && (context.getDocBase() != null)) { String name = null; String path = context.getPath(); if (path.equals("")) { name = "ROOT"; } else { if (path.startsWith("/")) { name = path.substring(1); } else { name = path; } } name = name.replace('/', '#'); File docBase = new File(name); if (!docBase.isAbsolute()) { docBase = new File(appBase(), name); } deployedApp.redeployResources.put(docBase.getAbsolutePath(), new Long(docBase.lastModified())); addWatchedResources(deployedApp, docBase.getAbsolutePath(), context); } else { addWatchedResources(deployedApp, null, context); } } catch (Throwable t) { log.error(sm.getString("hostConfig.deployJar.error", file), t); } deployed.put(contextPath, deployedApp); }
protected void fireContainerEvent(Context context, String type, Object data) throws Exception { if (!"org.apache.catalina.core.StandardContext".equals(context.getClass().getName())) { return; } if (containerEventMethod == null) { containerEventMethod = context.getClass().getMethod("fireContainerEvent", containerEventTypes); } Object[] containerEventParams = new Object[2]; containerEventParams[0] = type; containerEventParams[1] = data; containerEventMethod.invoke(context, containerEventParams); }
public synchronized boolean rotate(String newFileName) { if (currentLogFile != null) { File holder = currentLogFile; close(); try { holder.renameTo(new File(newFileName)); } catch (Throwable e) { log.error("rotate failed", e); } currentDate = new Date(System.currentTimeMillis()); dateStamp = fileDateFormatter.format(currentDate); open(); return true; } else { return false; } }	public void log(String message) { if (rotatable) { long systime = System.currentTimeMillis(); if ((systime - rotationLastChecked) > 1000) { currentDate = new Date(systime); rotationLastChecked = systime; String tsDate = fileDateFormatter.format(currentDate); if (!dateStamp.equals(tsDate)) { synchronized (this) { if (!dateStamp.equals(tsDate)) { close(); dateStamp = tsDate; open(); } } } } } if (checkExists) { synchronized (this) { if (currentLogFile != null && !currentLogFile.exists()) { try { close(); } catch (Throwable e) { log.info("at least this wasn't swallowed", e); } currentDate = new Date(System.currentTimeMillis()); dateStamp = fileDateFormatter.format(currentDate); open(); } } } if (writer != null) { writer.println(message); if (!buffered) { writer.flush(); } } }
protected void prepareRequest() { http11 = true; http09 = false; contentDelimitation = false; expectation = false; if (sslSupport != null) { request.scheme().setString("https"); } MessageBytes protocolMB = request.protocol(); if (protocolMB.equals(Constants.HTTP_11)) { http11 = true; protocolMB.setString(Constants.HTTP_11); } else if (protocolMB.equals(Constants.HTTP_10)) { http11 = false; keepAlive = false; protocolMB.setString(Constants.HTTP_10); } else if (protocolMB.equals("")) { http09 = true; http11 = false; keepAlive = false; } else { http11 = false; error = true; if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare") + " Unsupported HTTP version \"" + protocolMB + "\""); } response.setStatus(505); } MessageBytes methodMB = request.method(); if (methodMB.equals(Constants.GET)) { methodMB.setString(Constants.GET); } else if (methodMB.equals(Constants.POST)) { methodMB.setString(Constants.POST); } MimeHeaders headers = request.getMimeHeaders(); MessageBytes connectionValueMB = headers.getValue("connection"); if (connectionValueMB != null) { ByteChunk connectionValueBC = connectionValueMB.getByteChunk(); if (findBytes(connectionValueBC, Constants.CLOSE_BYTES) != -1) { keepAlive = false; } else if (findBytes(connectionValueBC, Constants.KEEPALIVE_BYTES) != -1) { keepAlive = true; } } MessageBytes expectMB = null; if (http11) expectMB = headers.getValue("expect"); if ((expectMB != null) && (expectMB.indexOfIgnoreCase("100-continue", 0) != -1)) { inputBuffer.setSwallowInput(false); expectation = true; } if ((restrictedUserAgents != null) && ((http11) || (keepAlive))) { MessageBytes userAgentValueMB = headers.getValue("user-agent"); if (userAgentValueMB != null) { String userAgentValue = userAgentValueMB.toString(); for (int i = 0; i < restrictedUserAgents.length; i++) { if (restrictedUserAgents[i].matcher(userAgentValue).matches()) { http11 = false; keepAlive = false; break; } } } } ByteChunk uriBC = request.requestURI().getByteChunk(); if (uriBC.startsWithIgnoreCase("http", 0)) { int pos = uriBC.indexOf("://", 0, 3, 4); int uriBCStart = uriBC.getStart(); int slashPos = -1; if (pos != -1) { byte[] uriB = uriBC.getBytes(); slashPos = uriBC.indexOf('/', pos + 3); if (slashPos == -1) { slashPos = uriBC.getLength(); request.requestURI().setBytes(uriB, uriBCStart + pos + 1, 1); } else { request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos); } MessageBytes hostMB = headers.setValue("host"); hostMB.setBytes(uriB, uriBCStart + pos + 3, slashPos - pos - 3); } } InputFilter[] inputFilters = inputBuffer.getFilters(); MessageBytes transferEncodingValueMB = null; if (http11) transferEncodingValueMB = headers.getValue("transfer-encoding"); if (transferEncodingValueMB != null) { String transferEncodingValue = transferEncodingValueMB.toString(); int startPos = 0; int commaPos = transferEncodingValue.indexOf(','); String encodingName = null; while (commaPos != -1) { encodingName = transferEncodingValue.substring(startPos, commaPos).toLowerCase().trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; response.setStatus(501); } startPos = commaPos + 1; commaPos = transferEncodingValue.indexOf(',', startPos); } encodingName = transferEncodingValue.substring(startPos).toLowerCase().trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare") + " Unsupported transfer encoding \"" + encodingName + "\""); } response.setStatus(501); } } long contentLength = request.getContentLengthLong(); if (contentLength >= 0 && !contentDelimitation) { inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } MessageBytes valueMB = headers.getValue("host"); if (http11 && (valueMB == null)) { error = true; if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare") + " host header missing"); } response.setStatus(400); } parseHost(valueMB); if (!contentDelimitation) { // If there's no content length // (broken HTTP/1.0 or HTTP/1.1), assume inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } }
public long getServiceStartTime() { return this.serviceStartTime; }	public synchronized boolean stop(int level) throws IOException { boolean valid = false; if ((level & Channel.MBR_RX_SEQ) == Channel.MBR_RX_SEQ) { valid = true; doRunReceiver = false; if (receiver != null) receiver.interrupt(); receiver = null; } if ((level & Channel.MBR_TX_SEQ) == Channel.MBR_TX_SEQ) { valid = true; doRunSender = false; if (sender != null) sender.interrupt(); sender = null; } if (!valid) { throw new IllegalArgumentException("Invalid stop level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ"); } startLevel = (startLevel & (~level)); if (startLevel == 0) { member.setCommand(Member.SHUTDOWN_PAYLOAD); member.getData(true, true); send(false); try { socket.leaveGroup(address); } catch (Exception ignore) { } try { socket.close(); } catch (Exception ignore) { } serviceStartTime = Long.MAX_VALUE; } return (startLevel == 0); }	public synchronized void start(int level) throws IOException { boolean valid = false; if ((level & Channel.MBR_RX_SEQ) == Channel.MBR_RX_SEQ) { if (receiver != null) throw new IllegalStateException("McastService.receive already running."); try { if (sender == null) socket.joinGroup(address); } catch (IOException iox) { log.error("Unable to join multicast group, make sure your system has multicasting enabled."); throw iox; } doRunReceiver = true; receiver = new ReceiverThread(); receiver.setDaemon(true); receiver.start(); valid = true; } if ((level & Channel.MBR_TX_SEQ) == Channel.MBR_TX_SEQ) { if (sender != null) throw new IllegalStateException("McastService.send already running."); if (receiver == null) socket.joinGroup(address); send(false); doRunSender = true; serviceStartTime = System.currentTimeMillis(); sender = new SenderThread(sendFrequency); sender.setDaemon(true); sender.start(); valid = true; } if (!valid) { throw new IllegalArgumentException("Invalid start level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ"); } waitForMembers(level); startLevel = (startLevel | level); }
public static synchronized StringManager getManager(String packageName) { StringManager mgr = managers.get(packageName); if (mgr == null) { mgr = new StringManager(packageName); managers.put(packageName, mgr); } return mgr; }
protected static ErrorPage findErrorPage(Context context, Throwable exception) { if (exception == null) return (null); Class<?> clazz = exception.getClass(); String name = clazz.getName(); while (!Object.class.equals(clazz)) { ErrorPage errorPage = context.findErrorPage(name); if (errorPage != null) return (errorPage); clazz = clazz.getSuperclass(); if (clazz == null) break; name = clazz.getName(); } return (null); }
private void unregisterHost(ObjectName objectName) throws Exception { String name = objectName.getKeyProperty("host"); if (name != null) { Host host = (Host) ServerFactory.getServer().findService(domain).getContainer().findChild(name); mapper.removeHost(name); host.removeContainerListener(this); if (log.isDebugEnabled()) log.debug(sm.getString("mapperListener.unregisterHost", name, domain)); } }	protected void createMBeans(Service service) throws Exception { if (log.isDebugEnabled()) log.debug("Creating MBean for Service " + service); if (service instanceof StandardService) { ((StandardService) service).addPropertyChangeListener(this); } Connector[] connectors = service.findConnectors(); for (int j = 0; j < connectors.length; j++) { createMBeans(connectors[j]); } Engine engine = (Engine) service.getContainer(); if (engine != null) { createMBeans(engine); } }	protected void destroyMBeans(Connector connector, Service service) throws Exception { // // deregister the MBean for the Connector itself // if (log.isDebugEnabled()) // log.debug("Destroying MBean for Connector " + connector); // MBeanUtils.destroyMBean(connector, service); }	protected void destroyMBeans(Context context) throws Exception { context.removeContainerListener(this); Realm hRealm = context.getParent().getRealm(); Realm cRealm = context.getRealm(); if ((cRealm != null) && (cRealm != hRealm)) { if (log.isDebugEnabled()) log.debug("Destroying MBean for Realm " + cRealm); //MBeanUtils.destroyMBean(cRealm); } Manager cManager = context.getManager(); if (cManager != null) { if (log.isDebugEnabled()) log.debug("Destroying MBean for Manager " + cManager); //MBeanUtils.destroyMBean(cManager); } Loader cLoader = context.getLoader(); if (cLoader != null) { if (log.isDebugEnabled()) log.debug("Destroying MBean for Loader " + cLoader); //MBeanUtils.destroyMBean(cLoader); } NamingResources resources = context.getNamingResources(); if (resources != null) { destroyMBeans(resources); } if (log.isDebugEnabled()) log.debug("Destroying MBean for Context " + context); if (context instanceof StandardContext) { ((StandardContext) context).removePropertyChangeListener(this); } }	protected void destroyMBeans(Engine engine) throws Exception { engine.removeContainerListener(this); Container[] hosts = engine.findChildren(); for (int k = 0; k < hosts.length; k++) { destroyMBeans((Host) hosts[k]); } Realm eRealm = engine.getRealm(); if (eRealm != null) { if (log.isDebugEnabled()) log.debug("Destroying MBean for Realm " + eRealm); //MBeanUtils.destroyMBean(eRealm); } if (log.isDebugEnabled()) { log.debug("Destroying MBean for Engine " + engine); } //MBeanUtils.destroyMBean(engine); }	protected void destroyMBeans(Host host) throws Exception { host.removeContainerListener(this); Container[] contexts = host.findChildren(); for (int k = 0; k < contexts.length; k++) { destroyMBeans((Context) contexts[k]); } Realm eRealm = host.getParent().getRealm(); Realm hRealm = host.getRealm(); if ((hRealm != null) && (hRealm != eRealm)) { if (log.isDebugEnabled()) log.debug("Destroying MBean for Realm " + hRealm); //MBeanUtils.destroyMBean(hRealm); } if (log.isDebugEnabled()) { log.debug("Destroying MBean for Host " + host); } //MBeanUtils.destroyMBean(host); }	protected void destroyMBeans(Server server) throws Exception { NamingResources resources = server.getGlobalNamingResources(); if (resources != null) { destroyMBeans(resources); } Service[] services = server.findServices(); for (int i = 0; i < services.length; i++) { destroyMBeans(services[i]); } if (log.isDebugEnabled()) { log.debug("Destroying MBean for Server " + server); } if (server instanceof StandardServer) { ((StandardServer) server).removePropertyChangeListener(this); } }	protected void destroyMBeans(Service service) throws Exception { Engine engine = (Engine) service.getContainer(); if (engine != null) { //destroyMBeans(engine); } if (log.isDebugEnabled()) { log.debug("Destroying MBean for Service " + service); } if (service instanceof StandardService) { ((StandardService) service).removePropertyChangeListener(this); } }	public void lifecycleEvent(LifecycleEvent event) { Lifecycle lifecycle = event.getLifecycle(); if (Lifecycle.START_EVENT.equals(event.getType())) { if (lifecycle instanceof Server) { createMBeans(); } if (lifecycle instanceof Service) { try { MBeanFactory factory = new MBeanFactory(); createMBeans(factory); createMBeans((Service) lifecycle); } catch (Exception ex) { log.error("Create mbean factory"); } } /* // Ignore events from StandardContext objects to avoid // reregistering the context if (lifecycle instanceof StandardContext) return; createMBeans(); */ } else if (Lifecycle.STOP_EVENT.equals(event.getType())) { try { if (lifecycle instanceof Server) { destroyMBeans((Server) lifecycle); } if (lifecycle instanceof Service) { destroyMBeans((Service) lifecycle); } } catch (MBeanException t) { Exception e = t.getTargetException(); if (e == null) { e = t; } log.error("destroyMBeans: MBeanException", e); } catch (Throwable t) { log.error("destroyMBeans: Throwable", t); } // FIXME: RMI adaptor should be stopped; however, this is // undocumented in MX4J, and reports exist in the MX4J bug DB that // this doesn't work } if ((Context.RELOAD_EVENT.equals(event.getType())) || (Lifecycle.START_EVENT.equals(event.getType()))) { if (lifecycle instanceof StandardContext) { // If the context is privileged, give a reference to it StandardContext context = (StandardContext) lifecycle; if (context.getPrivileged()) { context.getServletContext().setAttribute(Globals.MBEAN_REGISTRY_ATTR, MBeanUtils.createRegistry()); context.getServletContext().setAttribute(Globals.MBEAN_SERVER_ATTR, MBeanUtils.createServer()); } } } }	static ObjectName createObjectName(String domain, Valve valve) throws MalformedObjectNameException { if (valve instanceof ValveBase) { ObjectName name = ((ValveBase) valve).getObjectName(); if (name != null) return name; } ObjectName name = null; Container container = null; String className = valve.getClass().getName(); int period = className.lastIndexOf('.'); if (period >= 0) className = className.substring(period + 1); if (valve instanceof Contained) { container = ((Contained) valve).getContainer(); } if (container == null) { throw new MalformedObjectNameException("Cannot create mbean for non-contained valve " + valve); } if (container instanceof Engine) { String local = ""; int seq = getSeq(local); String ext = ""; if (seq > 0) { ext = ",seq=" + seq; } name = new ObjectName(domain + ":type=Valve,name=" + className + ext + local); } else if (container instanceof Host) { String local = ",host=" + container.getName(); int seq = getSeq(local); String ext = ""; if (seq > 0) { ext = ",seq=" + seq; } name = new ObjectName(domain + ":type=Valve,name=" + className + ext + local); } else if (container instanceof Context) { String path = ((Context) container).getPath(); if (path.length() < 1) { path = "/"; } Host host = (Host) container.getParent(); String local = ",path=" + path + ",host=" + host.getName(); int seq = getSeq(local); String ext = ""; if (seq > 0) { ext = ",seq=" + seq; } name = new ObjectName(domain + ":type=Valve,name=" + className + ext + local); } return (name); }	static void destroyMBean(Connector connector, Service service) throws Exception { connector.setService(service); String mname = createManagedName(connector); ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { return; } String domain = managed.getDomain(); if (domain == null) domain = mserver.getDefaultDomain(); ObjectName oname = createObjectName(domain, connector); connector.setService(null); if (mserver.isRegistered(oname)) { mserver.unregisterMBean(oname); } }	static void destroyMBean(Context context) throws Exception { String mname = createManagedName(context); ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { return; } String domain = managed.getDomain(); if (domain == null) domain = mserver.getDefaultDomain(); ObjectName oname = createObjectName(domain, context); if (mserver.isRegistered(oname)) mserver.unregisterMBean(oname); }	static void destroyMBean(ContextResource resource) throws Exception { String mname = createManagedName(resource); ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { return; } String domain = managed.getDomain(); if (domain == null) domain = mserver.getDefaultDomain(); ObjectName oname = createObjectName(domain, resource); if (mserver.isRegistered(oname)) mserver.unregisterMBean(oname); }	static void destroyMBean(Engine engine) throws Exception { String mname = createManagedName(engine); ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { return; } String domain = managed.getDomain(); if (domain == null) domain = mserver.getDefaultDomain(); ObjectName oname = createObjectName(domain, engine); if (mserver.isRegistered(oname)) mserver.unregisterMBean(oname); }	static void destroyMBean(Host host) throws Exception { String mname = createManagedName(host); ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { return; } String domain = managed.getDomain(); if (domain == null) domain = mserver.getDefaultDomain(); ObjectName oname = createObjectName(domain, host); if (mserver.isRegistered(oname)) mserver.unregisterMBean(oname); }	static void destroyMBean(NamingResources resources) throws Exception { String mname = createManagedName(resources); ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { return; } String domain = managed.getDomain(); if (domain == null) domain = mserver.getDefaultDomain(); ObjectName oname = createObjectName(domain, resources); if (mserver.isRegistered(oname)) mserver.unregisterMBean(oname); }	static void destroyMBean(Server server) throws Exception { String mname = createManagedName(server); ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { return; } String domain = managed.getDomain(); if (domain == null) domain = mserver.getDefaultDomain(); ObjectName oname = createObjectName(domain, server); if (mserver.isRegistered(oname)) mserver.unregisterMBean(oname); }	static void destroyMBean(UserDatabase userDatabase) throws Exception { String mname = createManagedName(userDatabase); ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { return; } String domain = managed.getDomain(); if (domain == null) domain = mserver.getDefaultDomain(); ObjectName oname = createObjectName(domain, userDatabase); if (mserver.isRegistered(oname)) mserver.unregisterMBean(oname); }
protected List<String> getRoles(DirContext context, User user) throws NamingException { if (user == null) return (null); String dn = user.dn; String username = user.username; if (dn == null || username == null) return (null); if (containerLog.isTraceEnabled()) containerLog.trace(" getRoles(" + dn + ")"); ArrayList<String> list = user.roles; if (list == null) { list = new ArrayList<String>(); } if (commonRole != null) list.add(commonRole); if (containerLog.isTraceEnabled()) { containerLog.trace(" Found " + list.size() + " user internal roles"); for (int i = 0; i < list.size(); i++) containerLog.trace(" Found user internal role " + list.get(i)); } if ((roleFormat == null) || (roleName == null)) return (list); String filter = roleFormat.format(new String[] { doRFC2254Encoding(dn), username }); SearchControls controls = new SearchControls(); if (roleSubtree) controls.setSearchScope(SearchControls.SUBTREE_SCOPE); else controls.setSearchScope(SearchControls.ONELEVEL_SCOPE); controls.setReturningAttributes(new String[] { roleName }); NamingEnumeration<SearchResult> results = context.search(roleBase, filter, controls); if (results == null) return (list); HashMap<String, String> groupMap = new HashMap<String, String>(); try { while (results.hasMore()) { SearchResult result = results.next(); Attributes attrs = result.getAttributes(); if (attrs == null) continue; String dname = getDistinguishedName(context, roleBase, result); String name = getAttributeValue(roleName, attrs); if (name != null && dname != null) { groupMap.put(dname, name); } } } catch (PartialResultException ex) { if (!adCompat) throw ex; } Set<String> keys = groupMap.keySet(); if (containerLog.isTraceEnabled()) { containerLog.trace(" Found " + keys.size() + " direct roles"); for (Iterator<String> i = keys.iterator(); i.hasNext(); ) { Object k = i.next(); containerLog.trace(" Found direct role " + k + " -> " + groupMap.get(k)); } } HashSet<String> recursiveSet = new HashSet<String>(); HashMap<String, String> recursiveMap = new HashMap<String, String>(); for (Iterator<String> i = keys.iterator(); i.hasNext(); ) { String k = i.next(); getRolesRecursive(0, context, recursiveMap, recursiveSet, groupMap.get(k), k); } HashSet<String> resultSet = new HashSet<String>(list); resultSet.addAll(recursiveMap.values()); if (containerLog.isTraceEnabled()) { containerLog.trace(" Returning " + resultSet.size() + " roles"); for (Iterator<String> i = resultSet.iterator(); i.hasNext(); ) containerLog.trace(" Found role " + i.next()); } return new ArrayList<String>(resultSet); }	protected boolean bindAsUser(DirContext context, User user, String credentials) throws NamingException { if (credentials == null || user == null) return (false); String dn = user.dn; if (dn == null) return (false); if (containerLog.isTraceEnabled()) { containerLog.trace(" validating credentials by binding as the user"); } context.addToEnvironment(Context.SECURITY_PRINCIPAL, dn); context.addToEnvironment(Context.SECURITY_CREDENTIALS, credentials); boolean validated = false; try { if (containerLog.isTraceEnabled()) { containerLog.trace(" binding as " + dn); } context.getAttributes("", null); validated = true; } catch (AuthenticationException e) { if (containerLog.isTraceEnabled()) { containerLog.trace(" bind attempt failed"); } } if (connectionName != null) { context.addToEnvironment(Context.SECURITY_PRINCIPAL, connectionName); } else { context.removeFromEnvironment(Context.SECURITY_PRINCIPAL); } if (connectionPassword != null) { context.addToEnvironment(Context.SECURITY_CREDENTIALS, connectionPassword); } else { context.removeFromEnvironment(Context.SECURITY_CREDENTIALS); } return (validated); }	public void setRoleSubtree(boolean roleSubtree) { this.roleSubtree = roleSubtree; }	public void setUserRoleName(String userRoleName) { this.userRoleName = userRoleName; }
private Enumeration<String> doGetAttributeNamesInScope(int scope) { switch(scope) { case PAGE_SCOPE: return new Enumerator<String>(attributes.keySet().iterator()); case REQUEST_SCOPE: return request.getAttributeNames(); case SESSION_SCOPE: if (session == null) { throw new IllegalStateException(Localizer.getMessage("jsp.error.page.noSession")); } return session.getAttributeNames(); case APPLICATION_SCOPE: return context.getAttributeNames(); default: throw new IllegalArgumentException("Invalid scope"); } }	int doGetAttributeScope(String name) { if (attributes.get(name) != null) return PAGE_SCOPE; if (request.getAttribute(name) != null) return REQUEST_SCOPE; if (session != null) { if (session.getAttribute(name) != null) return SESSION_SCOPE; } if (context.getAttribute(name) != null) return APPLICATION_SCOPE; return 0; }	void doRemoveAttribute(String name) { try { removeAttribute(name, PAGE_SCOPE); removeAttribute(name, REQUEST_SCOPE); if (session != null) { removeAttribute(name, SESSION_SCOPE); } removeAttribute(name, APPLICATION_SCOPE); } catch (Exception ex) { // we remove as much as we can, and // simply ignore possible exceptions } }
public synchronized Servlet loadServlet() throws ServletException { if (!singleThreadModel && (instance != null)) return instance; PrintStream out = System.out; if (swallowOutput) { SystemLogHandler.startCapture(); } Servlet servlet; try { long t1 = System.currentTimeMillis(); // If this "servlet" is really a JSP file, get the right class. // HOLD YOUR NOSE - this is a kludge that avoids having to do special // case Catalina-specific code in Jasper - it also requires that the // servlet path be replaced by the <jsp-file> element content in String actualClass = servletClass; if ((actualClass == null) && (jspFile != null)) { Wrapper jspWrapper = (Wrapper) ((Context) getParent()).findChild(Constants.JSP_SERVLET_NAME); if (jspWrapper != null) { actualClass = jspWrapper.getServletClass(); String[] paramNames = jspWrapper.findInitParameters(); for (int i = 0; i < paramNames.length; i++) { if (parameters.get(paramNames[i]) == null) { parameters.put(paramNames[i], jspWrapper.findInitParameter(paramNames[i])); } } } } if (actualClass == null) { unavailable(null); throw new ServletException(sm.getString("standardWrapper.notClass", getName())); } InstanceManager instanceManager = ((StandardContext) getParent()).getInstanceManager(); try { servlet = (Servlet) instanceManager.newInstance(actualClass); } catch (ClassCastException e) { unavailable(null); throw new ServletException(sm.getString("standardWrapper.notServlet", actualClass), e); } catch (Throwable e) { unavailable(null); if (log.isDebugEnabled()) { log.debug(sm.getString("standardWrapper.instantiate", actualClass), e); } throw new ServletException(sm.getString("standardWrapper.instantiate", actualClass), e); } if ((servlet instanceof ContainerServlet) && (isContainerProvidedServlet(actualClass) || ((Context) getParent()).getPrivileged())) { ((ContainerServlet) servlet).setWrapper(this); } classLoadTime = (int) (System.currentTimeMillis() - t1); try { instanceSupport.fireInstanceEvent(InstanceEvent.BEFORE_INIT_EVENT, servlet); if (Globals.IS_SECURITY_ENABLED) { Object[] args = new Object[] { (facade) }; SecurityUtil.doAsPrivilege("init", servlet, classType, args); args = null; } else { servlet.init(facade); } if ((loadOnStartup >= 0) && (jspFile != null)) { DummyRequest req = new DummyRequest(); req.setServletPath(jspFile); req.setQueryString("jsp_precompile=true"); DummyResponse res = new DummyResponse(); if (Globals.IS_SECURITY_ENABLED) { Object[] args = new Object[] { req, res }; SecurityUtil.doAsPrivilege("service", servlet, classTypeUsedInService, args); args = null; } else { servlet.service(req, res); } } instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT, servlet); } catch (UnavailableException f) { instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT, servlet, f); unavailable(f); throw f; } catch (ServletException f) { instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT, servlet, f); throw f; } catch (Throwable f) { getServletContext().log("StandardWrapper.Throwable", f); instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT, servlet, f); throw new ServletException(sm.getString("standardWrapper.initException", getName()), f); } singleThreadModel = servlet instanceof SingleThreadModel; if (singleThreadModel) { if (instancePool == null) instancePool = new Stack<Servlet>(); } fireContainerEvent("load", this); loadTime = System.currentTimeMillis() - t1; } finally { if (swallowOutput) { String log = SystemLogHandler.stopCapture(); if (log != null && log.length() > 0) { if (getServletContext() != null) { getServletContext().log(log); } else { out.println(log); } } } } return servlet; }
protected String doRFC2254Encoding(String inString) { StringBuffer buf = new StringBuffer(inString.length()); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); switch(c) { case '\\': buf.append("\\5c"); break; case '*': buf.append("\\2a"); break; case '(': buf.append("\\28"); break; case ')': buf.append("\\29"); break; case '\0': buf.append("\\00"); break; default: buf.append(c); break; } } return buf.toString(); }
public void close() throws IOException { if (writer != null) { writer.close(); } else { closed = true; } }	void setWriter(Writer writer) { this.writer = writer; closed = false; if (writer != null) { if (bufferSize != 0) { bufferSizeSave = bufferSize; bufferSize = 0; } } else { bufferSize = bufferSizeSave; clearBody(); } }
public SocketState process(NioChannel socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); this.socket = socket; inputBuffer.setSocket(socket); outputBuffer.setSocket(socket); inputBuffer.setSelectorPool(endpoint.getSelectorPool()); outputBuffer.setSelectorPool(endpoint.getSelectorPool()); error = false; keepAlive = true; comet = false; long soTimeout = endpoint.getSoTimeout(); int keepAliveTimeout = endpoint.getKeepAliveTimeout(); boolean keptAlive = false; boolean openSocket = false; boolean recycle = true; final KeyAttachment ka = (KeyAttachment) socket.getAttachment(false); while (!error && keepAlive && !comet) { ka.setTimeout(soTimeout); try { if (!disableUploadTimeout && keptAlive && soTimeout > 0) { socket.getIOChannel().socket().setSoTimeout((int) soTimeout); } if (!inputBuffer.parseRequestLine(keptAlive)) { //no data available yet, since we might have read part openSocket = true; recycle = false; if (inputBuffer.getParsingRequestLinePhase() < 2) { if (keepAliveTimeout > 0) ka.setTimeout(keepAliveTimeout); } break; } keptAlive = true; if (!inputBuffer.parseHeaders()) { //we've read part of the request, don't recycle it openSocket = true; recycle = false; break; } request.setStartTime(System.currentTimeMillis()); if (!disableUploadTimeout) { socket.getIOChannel().socket().setSoTimeout(timeout); } } catch (IOException e) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.header.parse"), e); } error = true; break; } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.header.parse"), t); } response.setStatus(400); error = true; } rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare"), t); } response.setStatus(400); error = true; } if (maxKeepAliveRequests == 1) keepAlive = false; if (maxKeepAliveRequests > 0 && ka.decrementKeepAlive() <= 0) keepAlive = false; if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); if (keepAlive && !error) { error = response.getErrorException() != null || statusDropsConnection(response.getStatus()); } SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); if (key != null) { NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment(); if (attach != null) { attach.setComet(comet); if (comet) { Integer comettimeout = (Integer) request.getAttribute("org.apache.tomcat.comet.timeout"); if (comettimeout != null) attach.setTimeout(comettimeout.longValue()); } } } } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("http11processor.request.process"), t); response.setStatus(500); error = true; } } if (!comet) { if (error) inputBuffer.setSwallowInput(false); endRequest(); } if (error) { response.setStatus(500); } request.updateCounters(); if (!comet) { inputBuffer.nextRequest(); outputBuffer.nextRequest(); } if (sendfileData != null && !error) { ka.setSendfileData(sendfileData); sendfileData.keepAlive = keepAlive; SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); openSocket = socket.getPoller().processSendfile(key, ka, true, true); break; } rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (comet) { if (error) { recycle(); return SocketState.CLOSED; } else { return SocketState.LONG; } } else { if (recycle) { recycle(); } return (openSocket) ? (recycle ? SocketState.OPEN : SocketState.LONG) : SocketState.CLOSED; } }	public SocketState process(long socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); remoteAddr = null; remoteHost = null; localAddr = null; localName = null; remotePort = -1; localPort = -1; this.socket = socket; inputBuffer.setSocket(socket); outputBuffer.setSocket(socket); error = false; comet = false; keepAlive = true; int keepAliveLeft = maxKeepAliveRequests; long soTimeout = endpoint.getSoTimeout(); boolean keptAlive = false; boolean openSocket = false; while (!error && keepAlive && !comet) { try { if (!disableUploadTimeout && keptAlive && soTimeout > 0) { Socket.timeoutSet(socket, soTimeout * 1000); } if (!inputBuffer.parseRequestLine(keptAlive)) { // This means that no data is available right now // (long keepalive), so that the processor should be recycled openSocket = true; endpoint.getPoller().add(socket); break; } request.setStartTime(System.currentTimeMillis()); keptAlive = true; if (!disableUploadTimeout) { Socket.timeoutSet(socket, timeout * 1000); } inputBuffer.parseHeaders(); } catch (IOException e) { error = true; break; } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.header.parse"), t); } response.setStatus(400); error = true; } rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare"), t); } response.setStatus(400); error = true; } if (maxKeepAliveRequests > 0 && --keepAliveLeft == 0) keepAlive = false; if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); if (keepAlive && !error) { error = response.getErrorException() != null || statusDropsConnection(response.getStatus()); } } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("http11processor.request.process"), t); response.setStatus(500); error = true; } } if (!comet) { if (error) inputBuffer.setSwallowInput(false); endRequest(); } if (error) { response.setStatus(500); } request.updateCounters(); if (!comet) { inputBuffer.nextRequest(); outputBuffer.nextRequest(); } if (sendfileData != null && !error) { sendfileData.socket = socket; sendfileData.keepAlive = keepAlive; if (!endpoint.getSendfile().add(sendfileData)) { openSocket = true; break; } } rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (comet) { if (error) { inputBuffer.nextRequest(); outputBuffer.nextRequest(); recycle(); return SocketState.CLOSED; } else { return SocketState.LONG; } } else { recycle(); return (openSocket) ? SocketState.OPEN : SocketState.CLOSED; } }	public boolean parseRequestLine(boolean useAvailableData) throws IOException { int start = 0; // // Skipping blank lines byte chr = 0; do { if (pos >= lastValid) { if (useAvailableData) { return false; } if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } chr = buf[pos++]; } while ((chr == Constants.CR) || (chr == Constants.LF)); pos--; start = pos; if (pos >= lastValid) { if (useAvailableData) { return false; } if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } // // Reading the method name // Method name is always US-ASCII boolean space = false; while (!space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; request.method().setBytes(buf, start, pos - start); } pos++; } while (space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { pos++; } else { space = false; } } start = pos; int end = 0; int questionPos = -1; // // Reading the URI boolean eol = false; while (!space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; end = pos; } else if ((buf[pos] == Constants.CR) || (buf[pos] == Constants.LF)) { eol = true; space = true; end = pos; } else if ((buf[pos] == Constants.QUESTION) && (questionPos == -1)) { questionPos = pos; } pos++; } request.unparsedURI().setBytes(buf, start, end - start); if (questionPos >= 0) { request.queryString().setBytes(buf, questionPos + 1, end - questionPos - 1); request.requestURI().setBytes(buf, start, questionPos - start); } else { request.requestURI().setBytes(buf, start, end - start); } while (space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { pos++; } else { space = false; } } start = pos; end = 0; while (!eol) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.CR) { end = pos; } else if (buf[pos] == Constants.LF) { if (end == 0) end = pos; eol = true; } pos++; } if ((end - start) > 0) { request.protocol().setBytes(buf, start, end - start); } else { request.protocol().setString(""); } return true; }	public boolean parseRequestLine(boolean useAvailableData) throws IOException { if (!parsingRequestLine) return true; if (parsingRequestLinePhase == 0) { byte chr = 0; do { if (pos >= lastValid) { if (useAvailableData) { return false; } if (readSocket(true, false) == 0) return false; } chr = buf[pos++]; } while ((chr == Constants.CR) || (chr == Constants.LF)); pos--; parsingRequestLineStart = pos; parsingRequestLinePhase = 1; } if (parsingRequestLinePhase == 1) { if (pos >= lastValid) { if (useAvailableData) { return false; } if (readSocket(true, false) == 0) return false; } parsingRequestLinePhase = 2; } if (parsingRequestLinePhase == 2) { // // Reading the method name // Method name is always US-ASCII boolean space = false; while (!space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; request.method().setBytes(buf, parsingRequestLineStart, pos - parsingRequestLineStart); } pos++; } parsingRequestLineStart = pos; parsingRequestLinePhase = 3; } if (parsingRequestLinePhase == 3) { boolean space = true; while (space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { pos++; } else { space = false; } } int end = 0; while (!space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; end = pos; } else if ((buf[pos] == Constants.CR) || (buf[pos] == Constants.LF)) { parsingRequestLineEol = true; space = true; end = pos; } else if ((buf[pos] == Constants.QUESTION) && (parsingRequestLineQPos == -1)) { parsingRequestLineQPos = pos; } pos++; } request.unparsedURI().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); if (parsingRequestLineQPos >= 0) { request.queryString().setBytes(buf, parsingRequestLineQPos + 1, end - parsingRequestLineQPos - 1); request.requestURI().setBytes(buf, parsingRequestLineStart, parsingRequestLineQPos - parsingRequestLineStart); } else { request.requestURI().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); } parsingRequestLineStart = pos; parsingRequestLinePhase = 4; } if (parsingRequestLinePhase == 4) { boolean space = true; while (space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { pos++; } else { space = false; } } end = 0; while (!parsingRequestLineEol) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.CR) { end = pos; } else if (buf[pos] == Constants.LF) { if (end == 0) end = pos; parsingRequestLineEol = true; } pos++; } if ((end - parsingRequestLineStart) > 0) { request.protocol().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); } else { request.protocol().setString(""); } parsingRequestLine = false; parsingRequestLinePhase = 0; parsingRequestLineEol = false; parsingRequestLineStart = 0; return true; } throw new IllegalStateException("Invalid request line parse phase:" + parsingRequestLinePhase); }	public void parseRequestLine() throws IOException { int start = 0; // // Skipping blank lines byte chr = 0; do { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } chr = buf[pos++]; } while ((chr == Constants.CR) || (chr == Constants.LF)); pos--; start = pos; // // Reading the method name // Method name is always US-ASCII boolean space = false; while (!space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; request.method().setBytes(buf, start, pos - start); } pos++; } while (space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { pos++; } else { space = false; } } start = pos; int end = 0; int questionPos = -1; // // Reading the URI boolean eol = false; while (!space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; end = pos; } else if ((buf[pos] == Constants.CR) || (buf[pos] == Constants.LF)) { eol = true; space = true; end = pos; } else if ((buf[pos] == Constants.QUESTION) && (questionPos == -1)) { questionPos = pos; } pos++; } request.unparsedURI().setBytes(buf, start, end - start); if (questionPos >= 0) { request.queryString().setBytes(buf, questionPos + 1, end - questionPos - 1); request.requestURI().setBytes(buf, start, questionPos - start); } else { request.requestURI().setBytes(buf, start, end - start); } while (space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { pos++; } else { space = false; } } start = pos; end = 0; while (!eol) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.CR) { end = pos; } else if (buf[pos] == Constants.LF) { if (end == 0) end = pos; eol = true; } pos++; } if ((end - start) > 0) { request.protocol().setBytes(buf, start, end - start); } else { request.protocol().setString(""); } }
public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { if (log.isDebugEnabled()) log.debug("loadClass(" + name + ", " + resolve + ")"); Class<?> clazz = null; if (!started) { try { throw new IllegalStateException(); } catch (IllegalStateException e) { log.info(sm.getString("webappClassLoader.stopped", name), e); } } clazz = findLoadedClass0(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(" Returning class from cache"); if (resolve) resolveClass(clazz); return (clazz); } clazz = findLoadedClass(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(" Returning class from cache"); if (resolve) resolveClass(clazz); return (clazz); } try { clazz = system.loadClass(name); if (clazz != null) { if (resolve) resolveClass(clazz); return (clazz); } } catch (ClassNotFoundException e) { // Ignore } if (securityManager != null) { int i = name.lastIndexOf('.'); if (i >= 0) { try { securityManager.checkPackageAccess(name.substring(0, i)); } catch (SecurityException se) { String error = "Security Violation, attempt to use " + "Restricted Class: " + name; log.info(error, se); throw new ClassNotFoundException(error, se); } } } boolean delegateLoad = delegate || filter(name); if (delegateLoad) { if (log.isDebugEnabled()) log.debug(" Delegating to parent classloader1 " + parent); ClassLoader loader = parent; if (loader == null) loader = system; try { clazz = loader.loadClass(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(" Loading class from parent"); if (resolve) resolveClass(clazz); return (clazz); } } catch (ClassNotFoundException e) { // Ignore } } if (log.isDebugEnabled()) log.debug(" Searching local repositories"); try { clazz = findClass(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(" Loading class from local repository"); if (resolve) resolveClass(clazz); return (clazz); } } catch (ClassNotFoundException e) { // Ignore } if (!delegateLoad) { if (log.isDebugEnabled()) log.debug(" Delegating to parent classloader at end: " + parent); ClassLoader loader = parent; if (loader == null) loader = system; try { clazz = loader.loadClass(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(" Loading class from parent"); if (resolve) resolveClass(clazz); return (clazz); } } catch (ClassNotFoundException e) { // Ignore } } throw new ClassNotFoundException(name); }

protected void processSSI(HttpServletRequest req, HttpServletResponse res, URL resource) throws IOException { SSIExternalResolver ssiExternalResolver = new SSIServletExternalResolver(getServletContext(), req, res, isVirtualWebappRelative, debug, inputEncoding); SSIProcessor ssiProcessor = new SSIProcessor(ssiExternalResolver, debug); PrintWriter printWriter = null; StringWriter stringWriter = null; if (buffered) { stringWriter = new StringWriter(); printWriter = new PrintWriter(stringWriter); } else { printWriter = res.getWriter(); } URLConnection resourceInfo = resource.openConnection(); InputStream resourceInputStream = resourceInfo.getInputStream(); String encoding = resourceInfo.getContentEncoding(); if (encoding == null) { encoding = inputEncoding; } InputStreamReader isr; if (encoding == null) { isr = new InputStreamReader(resourceInputStream); } else { isr = new InputStreamReader(resourceInputStream, encoding); } BufferedReader bufferedReader = new BufferedReader(isr); long lastModified = ssiProcessor.process(bufferedReader, resourceInfo.getLastModified(), printWriter); if (lastModified > 0) { res.setDateHeader("last-modified", lastModified); } if (buffered) { printWriter.flush(); String text = stringWriter.toString(); res.getWriter().write(text); } }

public boolean offer(Runnable o) { if (parent == null) return super.offer(o); if (parent.getPoolSize() == parent.getMaximumPoolSize()) return super.offer(o); if (parent.getActiveCount() < (parent.getPoolSize())) return super.offer(o); if (parent.getPoolSize() < parent.getMaximumPoolSize()) return false; return super.offer(o); }
public int invoke(Msg msg, MsgContext ep) throws IOException { if (ep.isLogTimeEnabled()) ep.setLong(MsgContext.TIMER_PRE_REQUEST, System.currentTimeMillis()); Request req = ep.getRequest(); Response res = req.getResponse(); if (log.isDebugEnabled()) log.debug("Invoke " + req + " " + res + " " + req.requestURI().toString()); res.setNote(epNote, ep); ep.setStatus(MsgContext.JK_STATUS_HEAD); RequestInfo rp = req.getRequestProcessor(); rp.setStage(Constants.STAGE_SERVICE); try { adapter.service(req, res); } catch (Exception ex) { log.info("Error servicing request " + req, ex); } if (ep.getStatus() != MsgContext.JK_STATUS_CLOSED) { res.finish(); } req.recycle(); req.updateCounters(); res.recycle(); ep.recycle(); if (ep.getStatus() == MsgContext.JK_STATUS_ERROR) { return ERROR; } ep.setStatus(MsgContext.JK_STATUS_NEW); rp.setStage(Constants.STAGE_KEEPALIVE); return OK; }
public String[] findInstanceListeners() { return (instanceListeners); }	public Object clone() { synchronized (members) { Membership clone = new Membership(local, memberComparator); clone.map = (HashMap<MemberImpl, MbrEntry>) map.clone(); clone.members = new MemberImpl[members.length]; System.arraycopy(members, 0, clone.members, 0, members.length); return clone; } }	public String[] findServletMappings() { synchronized (servletMappings) { String[] results = new String[servletMappings.size()]; return (servletMappings.keySet().toArray(results)); } }	public SecurityConstraint[] findConstraints() { return (constraints); }	public String[] findSecurityRoles() { return (securityRoles); }	public String[] findWrapperListeners() { return (wrapperListeners); }	public synchronized MbrEntry addMember(MemberImpl member) { synchronized (members) { MbrEntry entry = new MbrEntry(member); if (!map.containsKey(member)) { map.put(member, entry); MemberImpl[] results = new MemberImpl[members.length + 1]; for (int i = 0; i < members.length; i++) results[i] = members[i]; results[members.length] = member; members = results; Arrays.sort(members, memberComparator); } return entry; } }	public String[] getAliases() { return aliases; }	public void addAlias(String alias) { alias = alias.toLowerCase(); for (int i = 0; i < aliases.length; i++) { if (aliases[i].equals(alias)) return; } String[] newAliases = new String[aliases.length + 1]; for (int i = 0; i < aliases.length; i++) newAliases[i] = aliases[i]; newAliases[aliases.length] = alias; aliases = newAliases; fireContainerEvent(ADD_ALIAS_EVENT, alias); }	public void addApplicationListener(String listener) { synchronized (applicationListeners) { String[] results = new String[applicationListeners.length + 1]; for (int i = 0; i < applicationListeners.length; i++) { if (listener.equals(applicationListeners[i])) { log.info(sm.getString("standardContext.duplicateListener", listener)); return; } results[i] = applicationListeners[i]; } results[applicationListeners.length] = listener; applicationListeners = results; } fireContainerEvent("addApplicationListener", listener); // FIXME - add instance if already started? }	public void addApplicationParameter(ApplicationParameter parameter) { synchronized (applicationParameters) { String newName = parameter.getName(); for (int i = 0; i < applicationParameters.length; i++) { if (newName.equals(applicationParameters[i].getName()) && !applicationParameters[i].getOverride()) return; } ApplicationParameter[] results = new ApplicationParameter[applicationParameters.length + 1]; System.arraycopy(applicationParameters, 0, results, 0, applicationParameters.length); results[applicationParameters.length] = parameter; applicationParameters = results; } fireContainerEvent("addApplicationParameter", parameter); }	public String[] findAliases() { return (this.aliases); }	public void addConstraint(SecurityConstraint constraint) { SecurityCollection[] collections = constraint.findCollections(); for (int i = 0; i < collections.length; i++) { String[] patterns = collections[i].findPatterns(); for (int j = 0; j < patterns.length; j++) { patterns[j] = adjustURLPattern(patterns[j]); if (!validateURLPattern(patterns[j])) throw new IllegalArgumentException(sm.getString("standardContext.securityConstraint.pattern", patterns[j])); } } synchronized (constraints) { SecurityConstraint[] results = new SecurityConstraint[constraints.length + 1]; for (int i = 0; i < constraints.length; i++) results[i] = constraints[i]; results[constraints.length] = constraint; constraints = results; } }	public void addFilterMap(FilterMap filterMap) { validateFilterMap(filterMap); synchronized (filterMaps) { FilterMap[] results = new FilterMap[filterMaps.length + 1]; System.arraycopy(filterMaps, 0, results, 0, filterMaps.length); results[filterMaps.length] = filterMap; filterMaps = results; } fireContainerEvent("addFilterMap", filterMap); }	public void addFilterMapBefore(FilterMap filterMap) { validateFilterMap(filterMap); synchronized (filterMaps) { FilterMap[] results = new FilterMap[filterMaps.length + 1]; System.arraycopy(filterMaps, 0, results, 0, filterMapInsertPoint); results[filterMapInsertPoint] = filterMap; System.arraycopy(filterMaps, filterMapInsertPoint, results, filterMaps.length - filterMapInsertPoint + 1, filterMapInsertPoint); filterMapInsertPoint++; results[filterMaps.length] = filterMap; filterMaps = results; } fireContainerEvent("addFilterMap", filterMap); }	public void addInstanceListener(InstanceListener listener) { synchronized (listeners) { InstanceListener[] results = new InstanceListener[listeners.length + 1]; for (int i = 0; i < listeners.length; i++) results[i] = listeners[i]; results[listeners.length] = listener; listeners = results; } }	public void addInstanceListener(String listener) { synchronized (instanceListeners) { String[] results = new String[instanceListeners.length + 1]; for (int i = 0; i < instanceListeners.length; i++) results[i] = instanceListeners[i]; results[instanceListeners.length] = listener; instanceListeners = results; } fireContainerEvent("addInstanceListener", listener); }	public LifecycleListener[] findLifecycleListeners() { return listeners; }	public void addSecurityRole(String role) { synchronized (securityRoles) { String[] results = new String[securityRoles.length + 1]; for (int i = 0; i < securityRoles.length; i++) results[i] = securityRoles[i]; results[securityRoles.length] = role; securityRoles = results; } fireContainerEvent("addSecurityRole", role); }	public void addServletMapping(String pattern, String name, boolean jspWildCard) { if (findChild(name) == null) throw new IllegalArgumentException(sm.getString("standardContext.servletMap.name", name)); pattern = adjustURLPattern(RequestUtil.URLDecode(pattern)); if (!validateURLPattern(pattern)) throw new IllegalArgumentException(sm.getString("standardContext.servletMap.pattern", pattern)); synchronized (servletMappings) { String name2 = servletMappings.get(pattern); if (name2 != null) { Wrapper wrapper = (Wrapper) findChild(name2); wrapper.removeMapping(pattern); mapper.removeWrapper(pattern); } servletMappings.put(pattern, name); } Wrapper wrapper = (Wrapper) findChild(name); wrapper.addMapping(pattern); mapper.addWrapper(pattern, wrapper, jspWildCard); fireContainerEvent("addServletMapping", pattern); }	public void addWatchedResource(String name) { synchronized (watchedResources) { String[] results = new String[watchedResources.length + 1]; for (int i = 0; i < watchedResources.length; i++) results[i] = watchedResources[i]; results[watchedResources.length] = name; watchedResources = results; } fireContainerEvent("addWatchedResource", name); }	public void addWelcomeFile(String name) { synchronized (welcomeFiles) { if (replaceWelcomeFiles) { welcomeFiles = new String[0]; setReplaceWelcomeFiles(false); } String[] results = new String[welcomeFiles.length + 1]; for (int i = 0; i < welcomeFiles.length; i++) results[i] = welcomeFiles[i]; results[welcomeFiles.length] = name; welcomeFiles = results; } postWelcomeFiles(); fireContainerEvent("addWelcomeFile", name); }	public void addWrapperLifecycle(String listener) { synchronized (wrapperLifecycles) { String[] results = new String[wrapperLifecycles.length + 1]; for (int i = 0; i < wrapperLifecycles.length; i++) results[i] = wrapperLifecycles[i]; results[wrapperLifecycles.length] = listener; wrapperLifecycles = results; } fireContainerEvent("addWrapperLifecycle", listener); }	public void addWrapperListener(String listener) { synchronized (wrapperListeners) { String[] results = new String[wrapperListeners.length + 1]; for (int i = 0; i < wrapperListeners.length; i++) results[i] = wrapperListeners[i]; results[wrapperListeners.length] = listener; wrapperListeners = results; } fireContainerEvent("addWrapperListener", listener); }	public void destroy() throws Exception { if (oname != null) { Notification notification = new Notification("j2ee.object.deleted", this.getObjectName(), sequenceNumber++); broadcaster.sendNotification(notification); } super.destroy(); lifecycle.fireLifecycleEvent(DESTROY_EVENT, null); instanceListeners = new String[0]; }	public void removeAlias(String alias) { alias = alias.toLowerCase(); synchronized (aliases) { int n = -1; for (int i = 0; i < aliases.length; i++) { if (aliases[i].equals(alias)) { n = i; break; } } if (n < 0) return; int j = 0; String[] results = new String[aliases.length - 1]; for (int i = 0; i < aliases.length; i++) { if (i != n) results[j++] = aliases[i]; } aliases = results; } fireContainerEvent(REMOVE_ALIAS_EVENT, alias); }	public void removeApplicationListener(String listener) { synchronized (applicationListeners) { int n = -1; for (int i = 0; i < applicationListeners.length; i++) { if (applicationListeners[i].equals(listener)) { n = i; break; } } if (n < 0) return; int j = 0; String[] results = new String[applicationListeners.length - 1]; for (int i = 0; i < applicationListeners.length; i++) { if (i != n) results[j++] = applicationListeners[i]; } applicationListeners = results; } fireContainerEvent("removeApplicationListener", listener); // FIXME - behavior if already started? }	public void removeApplicationParameter(String name) { synchronized (applicationParameters) { int n = -1; for (int i = 0; i < applicationParameters.length; i++) { if (name.equals(applicationParameters[i].getName())) { n = i; break; } } if (n < 0) return; int j = 0; ApplicationParameter[] results = new ApplicationParameter[applicationParameters.length - 1]; for (int i = 0; i < applicationParameters.length; i++) { if (i != n) results[j++] = applicationParameters[i]; } applicationParameters = results; } fireContainerEvent("removeApplicationParameter", name); }	public void removeConstraint(SecurityConstraint constraint) { synchronized (constraints) { int n = -1; for (int i = 0; i < constraints.length; i++) { if (constraints[i].equals(constraint)) { n = i; break; } } if (n < 0) return; int j = 0; SecurityConstraint[] results = new SecurityConstraint[constraints.length - 1]; for (int i = 0; i < constraints.length; i++) { if (i != n) results[j++] = constraints[i]; } constraints = results; } fireContainerEvent("removeConstraint", constraint); }	public void removeFilterMap(FilterMap filterMap) { synchronized (filterMaps) { int n = -1; for (int i = 0; i < filterMaps.length; i++) { if (filterMaps[i] == filterMap) { n = i; break; } } if (n < 0) return; FilterMap[] results = new FilterMap[filterMaps.length - 1]; System.arraycopy(filterMaps, 0, results, 0, n); System.arraycopy(filterMaps, n + 1, results, n, (filterMaps.length - 1) - n); if (n < filterMapInsertPoint) { filterMapInsertPoint--; } filterMaps = results; } fireContainerEvent("removeFilterMap", filterMap); }	public void removeInstanceListener(InstanceListener listener) { synchronized (listeners) { int n = -1; for (int i = 0; i < listeners.length; i++) { if (listeners[i] == listener) { n = i; break; } } if (n < 0) return; InstanceListener[] results = new InstanceListener[listeners.length - 1]; int j = 0; for (int i = 0; i < listeners.length; i++) { if (i != n) results[j++] = listeners[i]; } listeners = results; } }	public void removeInstanceListener(String listener) { synchronized (instanceListeners) { int n = -1; for (int i = 0; i < instanceListeners.length; i++) { if (instanceListeners[i].equals(listener)) { n = i; break; } } if (n < 0) return; int j = 0; String[] results = new String[instanceListeners.length - 1]; for (int i = 0; i < instanceListeners.length; i++) { if (i != n) results[j++] = instanceListeners[i]; } instanceListeners = results; } fireContainerEvent("removeInstanceListener", listener); }	public void removeLifecycleListener(LifecycleListener listener) { synchronized (listeners) { int n = -1; for (int i = 0; i < listeners.length; i++) { if (listeners[i] == listener) { n = i; break; } } if (n < 0) return; LifecycleListener[] results = new LifecycleListener[listeners.length - 1]; int j = 0; for (int i = 0; i < listeners.length; i++) { if (i != n) results[j++] = listeners[i]; } listeners = results; } }	public synchronized MemberImpl[] expire(long maxtime) { if (!hasMembers()) return EMPTY_MEMBERS; ArrayList<MemberImpl> list = null; Iterator<MbrEntry> i = map.values().iterator(); while (i.hasNext()) { MbrEntry entry = i.next(); if (entry.hasExpired(maxtime)) { if (list == null) list = new java.util.ArrayList<MemberImpl>(); list.add(entry.getMember()); } } if (list != null) { MemberImpl[] result = new MemberImpl[list.size()]; list.toArray(result); for (int j = 0; j < result.length; j++) { removeMember(result[j]); } return result; } else { return EMPTY_MEMBERS; } }	public void removeSecurityRole(String role) { synchronized (securityRoles) { int n = -1; for (int i = 0; i < securityRoles.length; i++) { if (role.equals(securityRoles[i])) { n = i; break; } } if (n < 0) return; int j = 0; String[] results = new String[securityRoles.length - 1]; for (int i = 0; i < securityRoles.length; i++) { if (i != n) results[j++] = securityRoles[i]; } securityRoles = results; } fireContainerEvent("removeSecurityRole", role); }	public void removeServletMapping(String pattern) { String name = null; synchronized (servletMappings) { name = servletMappings.remove(pattern); } Wrapper wrapper = (Wrapper) findChild(name); if (wrapper != null) { wrapper.removeMapping(pattern); } mapper.removeWrapper(pattern); fireContainerEvent("removeServletMapping", pattern); }	public void removeWatchedResource(String name) { synchronized (watchedResources) { int n = -1; for (int i = 0; i < watchedResources.length; i++) { if (watchedResources[i].equals(name)) { n = i; break; } } if (n < 0) return; int j = 0; String[] results = new String[watchedResources.length - 1]; for (int i = 0; i < watchedResources.length; i++) { if (i != n) results[j++] = watchedResources[i]; } watchedResources = results; } fireContainerEvent("removeWatchedResource", name); }	public void removeWelcomeFile(String name) { synchronized (welcomeFiles) { int n = -1; for (int i = 0; i < welcomeFiles.length; i++) { if (welcomeFiles[i].equals(name)) { n = i; break; } } if (n < 0) return; int j = 0; String[] results = new String[welcomeFiles.length - 1]; for (int i = 0; i < welcomeFiles.length; i++) { if (i != n) results[j++] = welcomeFiles[i]; } welcomeFiles = results; } postWelcomeFiles(); fireContainerEvent("removeWelcomeFile", name); }	public void removeWrapperLifecycle(String listener) { synchronized (wrapperLifecycles) { int n = -1; for (int i = 0; i < wrapperLifecycles.length; i++) { if (wrapperLifecycles[i].equals(listener)) { n = i; break; } } if (n < 0) return; int j = 0; String[] results = new String[wrapperLifecycles.length - 1]; for (int i = 0; i < wrapperLifecycles.length; i++) { if (i != n) results[j++] = wrapperLifecycles[i]; } wrapperLifecycles = results; } fireContainerEvent("removeWrapperLifecycle", listener); }	public void removeWrapperListener(String listener) { synchronized (wrapperListeners) { int n = -1; for (int i = 0; i < wrapperListeners.length; i++) { if (wrapperListeners[i].equals(listener)) { n = i; break; } } if (n < 0) return; int j = 0; String[] results = new String[wrapperListeners.length - 1]; for (int i = 0; i < wrapperListeners.length; i++) { if (i != n) results[j++] = wrapperListeners[i]; } wrapperListeners = results; } fireContainerEvent("removeWrapperListener", listener); }

protected TreeNode convert(TreeNode parent, Node node) { TreeNode treeNode = new TreeNode(node.getNodeName(), parent); NamedNodeMap attributes = node.getAttributes(); if (attributes != null) { int n = attributes.getLength(); for (int i = 0; i < n; i++) { Node attribute = attributes.item(i); treeNode.addAttribute(attribute.getNodeName(), attribute.getNodeValue()); } } NodeList children = node.getChildNodes(); if (children != null) { int n = children.getLength(); for (int i = 0; i < n; i++) { Node child = children.item(i); if (child instanceof Comment) continue; if (child instanceof Text) { String body = ((Text) child).getData(); if (body != null) { body = body.trim(); if (body.length() > 0) treeNode.setBody(body); } } else { convert(treeNode, child); } } } return (treeNode); }
public DataInputStream run() { try { File f = new File(devRandomSource); if (!f.exists()) return null; randomIS = new DataInputStream(new FileInputStream(f)); randomIS.readLong(); if (log.isDebugEnabled()) log.debug("Opening " + devRandomSource); return randomIS; } catch (IOException ex) { return null; } }	public void setRandomFile(String s) { if (Globals.IS_SECURITY_ENABLED) { randomIS = AccessController.doPrivileged(new PrivilegedSetRandomFile()); } else { try { devRandomSource = s; File f = new File(devRandomSource); if (!f.exists()) return; randomIS = new DataInputStream(new FileInputStream(f)); randomIS.readLong(); if (log.isDebugEnabled()) log.debug("Opening " + devRandomSource); } catch (IOException ex) { try { randomIS.close(); } catch (Exception e) { log.warn("Failed to close randomIS."); } randomIS = null; } } }

public String getString(String key) { if (key == null) { String msg = "key may not have a null value"; throw new IllegalArgumentException(msg); } String str = null; try { str = bundle.getString(key); } catch (MissingResourceException mre) { //bad: shouldn't mask an exception the following way: // str = "[cannot find message associated with key '" + key + "' due to " + mre + "]"; // because it hides the fact that the String was missing // from the calling code. //good: could just throw the exception (or wrap it in another) // but that would probably cause much havoc on existing // code. //better: consistent with container pattern to // simply return null. Calling code can then do str = null; } return str; }	public String getString(String key, Object arg) { Object[] args = new Object[] { arg }; return getString(key, args); }	public String getString(String key, Object[] args) { String iString = null; String value = getString(key); try { if (args == null) { args = new Object[1]; } Object[] nonNullArgs = args; for (int i = 0; i < args.length; i++) { if (args[i] == null) { if (nonNullArgs == args) { nonNullArgs = args.clone(); } nonNullArgs[i] = "null"; } } if (value == null) value = key; MessageFormat mf = new MessageFormat(value); mf.setLocale(locale); iString = mf.format(nonNullArgs, new StringBuffer(), null).toString(); } catch (IllegalArgumentException iae) { StringBuffer buf = new StringBuffer(); buf.append(value); for (int i = 0; i < args.length; i++) { buf.append(" arg[" + i + "]=" + args[i]); } iString = buf.toString(); } return iString; }
public void start() throws LifecycleException { if (started) throw new LifecycleException(sm.getString("accessLogValve.alreadyStarted")); lifecycle.fireLifecycleEvent(START_EVENT, null); started = true; timezone = TimeZone.getDefault(); timeZoneNoDST = calculateTimeZoneOffset(timezone.getRawOffset()); Calendar calendar = Calendar.getInstance(timezone); int offset = calendar.get(Calendar.DST_OFFSET); timeZoneDST = calculateTimeZoneOffset(timezone.getRawOffset() + offset); if (fileDateFormat == null || fileDateFormat.length() == 0) fileDateFormat = "yyyy-MM-dd"; fileDateFormatter = new SimpleDateFormat(fileDateFormat); fileDateFormatter.setTimeZone(timezone); dayFormatter = new SimpleDateFormat("dd"); dayFormatter.setTimeZone(timezone); monthFormatter = new SimpleDateFormat("MM"); monthFormatter.setTimeZone(timezone); yearFormatter = new SimpleDateFormat("yyyy"); yearFormatter.setTimeZone(timezone); timeFormatter = new SimpleDateFormat("HH:mm:ss"); timeFormatter.setTimeZone(timezone); currentDate = new Date(); dateStamp = fileDateFormatter.format(currentDate); open(); }
public void compile(boolean compileClass, boolean jspcMode) throws FileNotFoundException, JasperException, Exception { if (errDispatcher == null) { this.errDispatcher = new ErrorDispatcher(jspcMode); } try { String[] smap = generateJava(); if (compileClass) { generateClass(smap); } } finally { if (tfp != null && ctxt.isPrototypeMode()) { tfp.removeProtoTypeFiles(null); } // Make sure these object which are only used during the // generation and compilation of the JSP page get // dereferenced so that they can be GC'd and reduce the tfp = null; errDispatcher = null; pageInfo = null; if (!this.options.getDevelopment()) { pageNodes = null; } if (ctxt.getWriter() != null) { ctxt.getWriter().close(); ctxt.setWriter(null); } } }
public ErrorPage findErrorPage(int errorCode) { if (errorCode == 200) { return (okErrorPage); } else { return (statusPages.get(new Integer(errorCode))); } }	public int[] findStatusPages() { synchronized (statusPages) { int[] results = new int[statusPages.size()]; Iterator<Integer> elements = statusPages.keySet().iterator(); int i = 0; while (elements.hasNext()) results[i++] = elements.next().intValue(); return (results); } }	public void addErrorPage(ErrorPage errorPage) { if (errorPage == null) throw new IllegalArgumentException(sm.getString("standardContext.errorPage.required")); String location = errorPage.getLocation(); if ((location != null) && !location.startsWith("/")) { if (isServlet22()) { if (log.isDebugEnabled()) log.debug(sm.getString("standardContext.errorPage.warning", location)); errorPage.setLocation("/" + location); } else { throw new IllegalArgumentException(sm.getString("standardContext.errorPage.error", location)); } } String exceptionType = errorPage.getExceptionType(); if (exceptionType != null) { synchronized (exceptionPages) { exceptionPages.put(exceptionType, errorPage); } } else { synchronized (statusPages) { if (errorPage.getErrorCode() == 200) { this.okErrorPage = errorPage; } statusPages.put(new Integer(errorPage.getErrorCode()), errorPage); } } fireContainerEvent("addErrorPage", errorPage); }	public void loadOnStartup(Container[] children) { TreeMap<Integer, ArrayList<Wrapper>> map = new TreeMap<Integer, ArrayList<Wrapper>>(); for (int i = 0; i < children.length; i++) { Wrapper wrapper = (Wrapper) children[i]; int loadOnStartup = wrapper.getLoadOnStartup(); if (loadOnStartup < 0) continue; Integer key = new Integer(loadOnStartup); ArrayList<Wrapper> list = map.get(key); if (list == null) { list = new ArrayList<Wrapper>(); map.put(key, list); } list.add(wrapper); } Iterator<Integer> keys = map.keySet().iterator(); while (keys.hasNext()) { Integer key = keys.next(); ArrayList<Wrapper> list = map.get(key); Iterator<Wrapper> wrappers = list.iterator(); while (wrappers.hasNext()) { Wrapper wrapper = wrappers.next(); try { wrapper.load(); } catch (ServletException e) { getLogger().error(sm.getString("standardWrapper.loadException", getName()), StandardWrapper.getRootCause(e)); // NOTE: load errors (including a servlet that throws // UnavailableException from tht init() method) are NOT // fatal to application startup } } } }	public void removeErrorPage(ErrorPage errorPage) { String exceptionType = errorPage.getExceptionType(); if (exceptionType != null) { synchronized (exceptionPages) { exceptionPages.remove(exceptionType); } } else { synchronized (statusPages) { if (errorPage.getErrorCode() == 200) { this.okErrorPage = null; } statusPages.remove(new Integer(errorPage.getErrorCode())); } } fireContainerEvent("removeErrorPage", errorPage); }	public void setAntiJARLocking(boolean antiJARLocking) { boolean oldAntiJARLocking = this.antiJARLocking; this.antiJARLocking = antiJARLocking; support.firePropertyChange("antiJARLocking", new Boolean(oldAntiJARLocking), new Boolean(this.antiJARLocking)); }	public void setAntiResourceLocking(boolean antiResourceLocking) { boolean oldAntiResourceLocking = this.antiResourceLocking; this.antiResourceLocking = antiResourceLocking; support.firePropertyChange("antiResourceLocking", new Boolean(oldAntiResourceLocking), new Boolean(this.antiResourceLocking)); }	public void setAvailable(boolean available) { boolean oldAvailable = this.available; this.available = available; support.firePropertyChange("available", new Boolean(oldAvailable), new Boolean(this.available)); }	public void setConfigured(boolean configured) { boolean oldConfigured = this.configured; this.configured = configured; support.firePropertyChange("configured", new Boolean(oldConfigured), new Boolean(this.configured)); }	public void setCookies(boolean cookies) { boolean oldCookies = this.cookies; this.cookies = cookies; support.firePropertyChange("cookies", new Boolean(oldCookies), new Boolean(this.cookies)); }	public void setCrossContext(boolean crossContext) { boolean oldCrossContext = this.crossContext; this.crossContext = crossContext; support.firePropertyChange("crossContext", new Boolean(oldCrossContext), new Boolean(this.crossContext)); }	public void setDelegate(boolean delegate) { boolean oldDelegate = this.delegate; this.delegate = delegate; support.firePropertyChange("delegate", new Boolean(oldDelegate), new Boolean(this.delegate)); }	public void setDistributable(boolean distributable) { boolean oldDistributable = this.distributable; this.distributable = distributable; support.firePropertyChange("distributable", new Boolean(oldDistributable), new Boolean(this.distributable)); if (getManager() != null) { if (log.isDebugEnabled()) { log.debug("Propagating distributable=" + distributable + " to manager"); } getManager().setDistributable(distributable); } }	public void setIgnoreAnnotations(boolean ignoreAnnotations) { boolean oldIgnoreAnnotations = this.ignoreAnnotations; this.ignoreAnnotations = ignoreAnnotations; support.firePropertyChange("ignoreAnnotations", Boolean.valueOf(oldIgnoreAnnotations), Boolean.valueOf(this.ignoreAnnotations)); }	public void setOverride(boolean override) { boolean oldOverride = this.override; this.override = override; support.firePropertyChange("override", new Boolean(oldOverride), new Boolean(this.override)); }	public void setPrivileged(boolean privileged) { boolean oldPrivileged = this.privileged; this.privileged = privileged; support.firePropertyChange("privileged", new Boolean(oldPrivileged), new Boolean(this.privileged)); }	public void setReloadable(boolean reloadable) { boolean oldReloadable = this.reloadable; this.reloadable = reloadable; support.firePropertyChange("reloadable", new Boolean(oldReloadable), new Boolean(this.reloadable)); }	public void setReplaceWelcomeFiles(boolean replaceWelcomeFiles) { boolean oldReplaceWelcomeFiles = this.replaceWelcomeFiles; this.replaceWelcomeFiles = replaceWelcomeFiles; support.firePropertyChange("replaceWelcomeFiles", new Boolean(oldReplaceWelcomeFiles), new Boolean(this.replaceWelcomeFiles)); }	public void setSessionTimeout(int timeout) { int oldSessionTimeout = this.sessionTimeout; this.sessionTimeout = (timeout == 0) ? -1 : timeout; support.firePropertyChange("sessionTimeout", new Integer(oldSessionTimeout), new Integer(this.sessionTimeout)); }	public void setSwallowOutput(boolean swallowOutput) { boolean oldSwallowOutput = this.swallowOutput; this.swallowOutput = swallowOutput; support.firePropertyChange("swallowOutput", new Boolean(oldSwallowOutput), new Boolean(this.swallowOutput)); }	public void setUnloadDelay(long unloadDelay) { long oldUnloadDelay = this.unloadDelay; this.unloadDelay = unloadDelay; support.firePropertyChange("unloadDelay", new Long(oldUnloadDelay), new Long(this.unloadDelay)); }	public void setUseHttpOnly(boolean useHttpOnly) { boolean oldUseHttpOnly = this.useHttpOnly; this.useHttpOnly = useHttpOnly; support.firePropertyChange("useHttpOnly", new Boolean(oldUseHttpOnly), new Boolean(this.useHttpOnly)); }
protected void tearDown() throws Exception { for (int i = 0; i < channels.length; i++) { channels[i].stop(Channel.DEFAULT); } }	public static void printArray(byte[] data) { System.out.print("{"); for (int i = 0; i < data.length; i++) { System.out.print(data[i]); System.out.print(","); } System.out.println("} size:" + data.length); }	public void await() { if (port == -2) { return; } if (port == -1) { while (true) { try { Thread.sleep(10000); } catch (InterruptedException ex) { } if (stopAwait) return; } } ServerSocket serverSocket = null; try { serverSocket = new ServerSocket(port, 1, InetAddress.getByName(address)); } catch (IOException e) { log.error("StandardServer.await: create[" + address + ":" + port + "]: ", e); System.exit(1); } while (true) { Socket socket = null; InputStream stream = null; try { socket = serverSocket.accept(); socket.setSoTimeout(10 * 1000); stream = socket.getInputStream(); } catch (AccessControlException ace) { log.warn("StandardServer.accept security exception: " + ace.getMessage(), ace); continue; } catch (IOException e) { log.error("StandardServer.await: accept: ", e); System.exit(1); } StringBuffer command = new StringBuffer(); int expected = 1024; while (expected < shutdown.length()) { if (random == null) random = new Random(System.currentTimeMillis()); expected += (random.nextInt() % 1024); } while (expected > 0) { int ch = -1; try { ch = stream.read(); } catch (IOException e) { log.warn("StandardServer.await: read: ", e); ch = -1; } if (ch < 32) break; command.append((char) ch); expected--; } try { socket.close(); } catch (IOException e) { // Ignore } boolean match = command.toString().equals(shutdown); if (match) { break; } else log.warn("StandardServer.await: Invalid command '" + command.toString() + "' received"); } try { serverSocket.close(); } catch (IOException e) { // Ignore } }	public void messageReceived(Serializable s, Member m) { Data d = (Data) s; if (!Data.verify(d)) { System.err.println("ERROR"); } else { count++; if ((count % 1000) == 0) { System.err.println("SUCCESS:" + count); } } }	public void messageReceived(Serializable s, Member m) { try { Data d = (Data) s; if (!Data.verify(d)) { System.err.println("ERROR - Unable to verify data package"); } else { long c = count.addAndGet(1); if ((c % 1000) == 0) { System.err.println("SUCCESS:" + c); } int nr = d.getNumber(); if (nr >= 0 && nr < nrs.length) { maxIdx = Math.max(maxIdx, nr); nrs[nr] = 1; } } } catch (Exception x) { x.printStackTrace(); } }	public void messageReceived(Serializable s, Member m) { try { Data d = (Data) s; if (!Data.verify(d)) { System.err.println("ERROR - Unable to verify data package"); } else { long c = count.addAndGet(1); if ((c % 1000) == 0) { System.err.println("SUCCESS:" + c); } int nr = d.getNumber(); if (nr >= 0 && nr < nrs.length) { maxIdx = Math.max(maxIdx, nr); nrs[nr] = 1; } } } catch (Exception x) { x.printStackTrace(); } }	public void printStats(PrintStream stream) { stream.println("NORMAL:" + noErrCnt); stream.println("FAILURES:" + errCnt); stream.println("TOTAL:" + (errCnt + noErrCnt)); }	public void run() { System.out.println("Shutting down..."); SystemExit exit = new SystemExit(5000); exit.setDaemon(true); exit.start(); try { channel.stop(Channel.DEFAULT); } catch (Exception x) { x.printStackTrace(); } System.out.println("Channel stopped."); }
public void event(Request request, Response response, CometEvent event) throws IOException, ServletException { boolean ok = false; try { getNext().event(request, response, event); ok = true; } finally { if (!ok || response.isClosed() || (event.getEventType() == CometEvent.EventType.END) || (event.getEventType() == CometEvent.EventType.ERROR && !(event.getEventSubType() == CometEvent.EventSubType.TIMEOUT))) { cometRequests.remove(request); // Remove connection from session expiration tracking // Note: can't get the session if it has been invalidated but HttpSession session = request.getSession(false); if (session != null) { synchronized (session) { Request[] reqs = (Request[]) session.getAttribute(cometRequestsAttribute); if (reqs != null) { boolean found = false; for (int i = 0; !found && (i < reqs.length); i++) { found = (reqs[i] == request); } if (found) { if (reqs.length > 1) { Request[] newConnectionInfos = new Request[reqs.length - 1]; int pos = 0; for (int i = 0; i < reqs.length; i++) { if (reqs[i] != request) { newConnectionInfos[pos++] = reqs[i]; } } session.setAttribute(cometRequestsAttribute, newConnectionInfos); } else { session.removeAttribute(cometRequestsAttribute); } } } } } } } }
/** * Process pipelined HTTP requests using the specified input and output * streams. * * @param input stream from which the HTTP requests will be read * @param output stream which will be used to output the HTTP * responses * @throws IOException error during an I/O operation */ public void process(Socket socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); // Set the remote address remoteAddr = null; remoteHost = null; localAddr = null; localName = null; remotePort = -1; localPort = -1; // Setting up the I/O this.socket = socket; inputBuffer.setInputStream(socket.getInputStream()); outputBuffer.setOutputStream(socket.getOutputStream()); // Error flag error = false; keepAlive = true; int keepAliveLeft = maxKeepAliveRequests; int soTimeout = socket.getSoTimeout(); int oldSoTimeout = soTimeout; int threadRatio = (endpoint.getCurrentThreadsBusy() * 100) / endpoint.getMaxThreads(); if (threadRatio > 75) { keepAliveLeft = 1; } if (soTimeout != oldSoTimeout) { try { socket.setSoTimeout(soTimeout); } catch (Throwable t) { log.debug(sm.getString("http11processor.socket.timeout"), t); error = true; } } boolean keptAlive = false; while (started && !error && keepAlive) { // Parsing the request header try { if (!disableUploadTimeout && keptAlive) { if (keepAliveTimeout > 0) { socket.setSoTimeout(keepAliveTimeout); } } } } }

protected void doHead(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { serveResource(request, response, false); }	public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) throws IllegalStateException { return null; }
protected void fixDocBase() throws IOException { Host host = (Host) context.getParent(); String appBase = host.getAppBase(); boolean unpackWARs = true; if (host instanceof StandardHost) { unpackWARs = ((StandardHost) host).isUnpackWARs() && ((StandardContext) context).getUnpackWAR(); } File canonicalAppBase = new File(appBase); if (canonicalAppBase.isAbsolute()) { canonicalAppBase = canonicalAppBase.getCanonicalFile(); } else { canonicalAppBase = new File(System.getProperty("catalina.base"), appBase).getCanonicalFile(); } String docBase = context.getDocBase(); if (docBase == null) { String path = context.getPath(); if (path == null) { return; } if (path.equals("")) { docBase = "ROOT"; } else { if (path.startsWith("/")) { docBase = path.substring(1).replace('/', '#'); } else { docBase = path.replace('/', '#'); } } } File file = new File(docBase); if (!file.isAbsolute()) { docBase = (new File(canonicalAppBase, docBase)).getPath(); } else { docBase = file.getCanonicalPath(); } file = new File(docBase); String origDocBase = docBase; String contextPath = context.getPath(); if (contextPath.equals("")) { contextPath = "ROOT"; } else { if (contextPath.lastIndexOf('/') > 0) { contextPath = "/" + contextPath.substring(1).replace('/', '#'); } } if (docBase.toLowerCase().endsWith(".war") && !file.isDirectory() && unpackWARs) { URL war = new URL("jar:" + (new File(docBase)).toURI().toURL() + "!/"); docBase = ExpandWar.expand(host, war, contextPath); file = new File(docBase); docBase = file.getCanonicalPath(); if (context instanceof StandardContext) { ((StandardContext) context).setOriginalDocBase(origDocBase); } } else { File docDir = new File(docBase); if (!docDir.exists()) { File warFile = new File(docBase + ".war"); if (warFile.exists()) { if (unpackWARs) { URL war = new URL("jar:" + warFile.toURI().toURL() + "!/"); docBase = ExpandWar.expand(host, war, contextPath); file = new File(docBase); docBase = file.getCanonicalPath(); } else { docBase = warFile.getCanonicalPath(); } } if (context instanceof StandardContext) { ((StandardContext) context).setOriginalDocBase(origDocBase); } } } if (docBase.startsWith(canonicalAppBase.getPath())) { docBase = docBase.substring(canonicalAppBase.getPath().length()); docBase = docBase.replace(File.separatorChar, '/'); if (docBase.startsWith("/")) { docBase = docBase.substring(1); } } else { docBase = docBase.replace(File.separatorChar, '/'); } context.setDocBase(docBase); }
public boolean authenticate(Request request, Response response, LoginConfig config) throws IOException { Principal principal = request.getUserPrincipal(); if (principal != null) { if (containerLog.isDebugEnabled()) containerLog.debug("Already authenticated '" + principal.getName() + "'"); // Associate the session with any existing SSO session in order String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (ssoId != null) associate(ssoId, request.getSessionInternal(true)); return (true); } if (containerLog.isDebugEnabled()) containerLog.debug(" Looking up certificates"); X509Certificate[] certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR); if ((certs == null) || (certs.length < 1)) { request.getCoyoteRequest().action(ActionCode.ACTION_REQ_SSL_CERTIFICATE, null); certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR); } if ((certs == null) || (certs.length < 1)) { if (containerLog.isDebugEnabled()) containerLog.debug(" No certificates included with this request"); response.sendError(HttpServletResponse.SC_BAD_REQUEST, sm.getString("authenticator.certificates")); return (false); } principal = context.getRealm().authenticate(certs); if (principal == null) { if (containerLog.isDebugEnabled()) containerLog.debug(" Realm.authenticate() returned false"); response.sendError(HttpServletResponse.SC_UNAUTHORIZED, sm.getString("authenticator.unauthorized")); return (false); } register(request, response, principal, Constants.CERT_METHOD, null, null); return (true); }
private String createTagHandlerPoolName(String prefix, String shortName, Attributes attrs, boolean hasEmptyBody) { String poolName = null; poolName = "_jspx_tagPool_" + prefix + "_" + shortName; if (attrs != null) { String[] attrNames = new String[attrs.getLength()]; for (int i = 0; i < attrNames.length; i++) { attrNames[i] = attrs.getQName(i); } Arrays.sort(attrNames, Collections.reverseOrder()); if (attrNames.length > 0) { poolName = poolName + "&"; } for (int i = 0; i < attrNames.length; i++) { poolName = poolName + "_" + attrNames[i]; } } if (hasEmptyBody) { poolName = poolName + "_nobody"; } return JspUtil.makeJavaIdentifier(poolName); }	private void generateXmlProlog(Node.Nodes page) { String omitXmlDecl = pageInfo.getOmitXmlDecl(); if ((omitXmlDecl != null && !JspUtil.booleanValue(omitXmlDecl)) || (omitXmlDecl == null && page.getRoot().isXmlSyntax() && !pageInfo.hasJspRoot() && !ctxt.isTagFile())) { String cType = pageInfo.getContentType(); String charSet = cType.substring(cType.indexOf("charset=") + 8); out.printil("out.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"" + charSet + "\\\"?>\\n\");"); } String doctypeName = pageInfo.getDoctypeName(); if (doctypeName != null) { String doctypePublic = pageInfo.getDoctypePublic(); String doctypeSystem = pageInfo.getDoctypeSystem(); out.printin("out.write(\"<!DOCTYPE "); out.print(doctypeName); if (doctypePublic == null) { out.print(" SYSTEM \\\""); } else { out.print(" PUBLIC \\\""); out.print(doctypePublic); out.print("\\\" \\\""); } out.print(doctypeSystem); out.println("\\\">\\n\");"); } }
protected void doLock(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { if (readOnly) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return; } if (isLocked(req)) { resp.sendError(WebdavStatus.SC_LOCKED); return; } LockInfo lock = new LockInfo(); // Parsing lock request String depthStr = req.getHeader("Depth"); if (depthStr == null) { lock.depth = INFINITY; } else { if (depthStr.equals("0")) { lock.depth = 0; } else { lock.depth = INFINITY; } } int lockDuration = DEFAULT_TIMEOUT; String lockDurationStr = req.getHeader("Timeout"); if (lockDurationStr == null) { lockDuration = DEFAULT_TIMEOUT; } else { int commaPos = lockDurationStr.indexOf(","); if (commaPos != -1) { lockDurationStr = lockDurationStr.substring(0, commaPos); } if (lockDurationStr.startsWith("Second-")) { lockDuration = (new Integer(lockDurationStr.substring(7))).intValue(); } else { if (lockDurationStr.equalsIgnoreCase("infinity")) { lockDuration = MAX_TIMEOUT; } else { try { lockDuration = (new Integer(lockDurationStr)).intValue(); } catch (NumberFormatException e) { lockDuration = MAX_TIMEOUT; } } } if (lockDuration == 0) { lockDuration = DEFAULT_TIMEOUT; } if (lockDuration > MAX_TIMEOUT) { lockDuration = MAX_TIMEOUT; } } lock.expiresAt = System.currentTimeMillis() + (lockDuration * 1000); int lockRequestType = LOCK_CREATION; Node lockInfoNode = null; DocumentBuilder documentBuilder = getDocumentBuilder(); try { Document document = documentBuilder.parse(new InputSource(req.getInputStream())); Element rootElement = document.getDocumentElement(); lockInfoNode = rootElement; } catch (IOException e) { lockRequestType = LOCK_REFRESH; } catch (SAXException e) { lockRequestType = LOCK_REFRESH; } if (lockInfoNode != null) { NodeList childList = lockInfoNode.getChildNodes(); StringWriter strWriter = null; DOMWriter domWriter = null; Node lockScopeNode = null; Node lockTypeNode = null; Node lockOwnerNode = null; for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: String nodeName = currentNode.getNodeName(); if (nodeName.endsWith("lockscope")) { lockScopeNode = currentNode; } if (nodeName.endsWith("locktype")) { lockTypeNode = currentNode; } if (nodeName.endsWith("owner")) { lockOwnerNode = currentNode; } break; } } if (lockScopeNode != null) { childList = lockScopeNode.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: String tempScope = currentNode.getNodeName(); if (tempScope.indexOf(':') != -1) { lock.scope = tempScope.substring(tempScope.indexOf(':') + 1); } else { lock.scope = tempScope; } break; } } if (lock.scope == null) { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } } else { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } if (lockTypeNode != null) { childList = lockTypeNode.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: String tempType = currentNode.getNodeName(); if (tempType.indexOf(':') != -1) { lock.type = tempType.substring(tempType.indexOf(':') + 1); } else { lock.type = tempType; } break; } } if (lock.type == null) { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } } else { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } if (lockOwnerNode != null) { childList = lockOwnerNode.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: lock.owner += currentNode.getNodeValue(); break; case Node.ELEMENT_NODE: strWriter = new StringWriter(); domWriter = new DOMWriter(strWriter, true); domWriter.setQualifiedNames(false); domWriter.print(currentNode); lock.owner += strWriter.toString(); break; } } if (lock.owner == null) { resp.setStatus(WebdavStatus.SC_BAD_REQUEST); } } else { lock.owner = new String(); } } String path = getRelativePath(req); lock.path = path; boolean exists = true; Object object = null; try { object = resources.lookup(path); } catch (NamingException e) { exists = false; } Enumeration<LockInfo> locksList = null; if (lockRequestType == LOCK_CREATION) { String lockTokenStr = req.getServletPath() + "-" + lock.type + "-" + lock.scope + "-" + req.getUserPrincipal() + "-" + lock.depth + "-" + lock.owner + "-" + lock.tokens + "-" + lock.expiresAt + "-" + System.currentTimeMillis() + "-" + secret; String lockToken = md5Encoder.encode(md5Helper.digest(lockTokenStr.getBytes())); if ((exists) && (object instanceof DirContext) && (lock.depth == INFINITY)) { // Locking a collection (and all its member resources) // Checking if a child resource of this collection is Vector<String> lockPaths = new Vector<String>(); locksList = collectionLocks.elements(); while (locksList.hasMoreElements()) { LockInfo currentLock = locksList.nextElement(); if (currentLock.hasExpired()) { resourceLocks.remove(currentLock.path); continue; } if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) { lockPaths.addElement(currentLock.path); } } locksList = resourceLocks.elements(); while (locksList.hasMoreElements()) { LockInfo currentLock = locksList.nextElement(); if (currentLock.hasExpired()) { resourceLocks.remove(currentLock.path); continue; } if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) { lockPaths.addElement(currentLock.path); } } if (!lockPaths.isEmpty()) { // One of the child paths was locked Enumeration<String> lockPathsList = lockPaths.elements(); resp.setStatus(WebdavStatus.SC_CONFLICT); XMLWriter generatedXML = new XMLWriter(); generatedXML.writeXMLHeader(); generatedXML.writeElement(null, "multistatus" + generateNamespaceDeclarations(), XMLWriter.OPENING); while (lockPathsList.hasMoreElements()) { generatedXML.writeElement(null, "response", XMLWriter.OPENING); generatedXML.writeElement(null, "href", XMLWriter.OPENING); generatedXML.writeText(lockPathsList.nextElement()); generatedXML.writeElement(null, "href", XMLWriter.CLOSING); generatedXML.writeElement(null, "status", XMLWriter.OPENING); generatedXML.writeText("HTTP/1.1 " + WebdavStatus.SC_LOCKED + " " + WebdavStatus.getStatusText(WebdavStatus.SC_LOCKED)); generatedXML.writeElement(null, "status", XMLWriter.CLOSING); generatedXML.writeElement(null, "response", XMLWriter.CLOSING); } generatedXML.writeElement(null, "multistatus", XMLWriter.CLOSING); Writer writer = resp.getWriter(); writer.write(generatedXML.toString()); writer.close(); return; } boolean addLock = true; locksList = collectionLocks.elements(); while (locksList.hasMoreElements()) { LockInfo currentLock = locksList.nextElement(); if (currentLock.path.equals(lock.path)) { if (currentLock.isExclusive()) { resp.sendError(WebdavStatus.SC_LOCKED); return; } else { if (lock.isExclusive()) { resp.sendError(WebdavStatus.SC_LOCKED); return; } } currentLock.tokens.addElement(lockToken); lock = currentLock; addLock = false; } } if (addLock) { lock.tokens.addElement(lockToken); collectionLocks.addElement(lock); } } else { // Locking a single resource LockInfo presentLock = resourceLocks.get(lock.path); if (presentLock != null) { if ((presentLock.isExclusive()) || (lock.isExclusive())) { // If either lock is exclusive, the lock can't be resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED); return; } else { presentLock.tokens.addElement(lockToken); lock = presentLock; } } else { lock.tokens.addElement(lockToken); resourceLocks.put(lock.path, lock); exists = true; try { object = resources.lookup(path); } catch (NamingException e) { exists = false; } if (!exists) { int slash = lock.path.lastIndexOf('/'); String parentPath = lock.path.substring(0, slash); Vector<String> lockNulls = lockNullResources.get(parentPath); if (lockNulls == null) { lockNulls = new Vector<String>(); lockNullResources.put(parentPath, lockNulls); } lockNulls.addElement(lock.path); } // Add the Lock-Token header as by RFC 2518 8.10.1 resp.addHeader("Lock-Token", "<opaquelocktoken:" + lockToken + ">"); } } } if (lockRequestType == LOCK_REFRESH) { String ifHeader = req.getHeader("If"); if (ifHeader == null) ifHeader = ""; LockInfo toRenew = resourceLocks.get(path); Enumeration<String> tokenList = null; if (lock != null) { tokenList = toRenew.tokens.elements(); while (tokenList.hasMoreElements()) { String token = tokenList.nextElement(); if (ifHeader.indexOf(token) != -1) { toRenew.expiresAt = lock.expiresAt; lock = toRenew; } } } Enumeration<LockInfo> collectionLocksList = collectionLocks.elements(); while (collectionLocksList.hasMoreElements()) { toRenew = collectionLocksList.nextElement(); if (path.equals(toRenew.path)) { tokenList = toRenew.tokens.elements(); while (tokenList.hasMoreElements()) { String token = tokenList.nextElement(); if (ifHeader.indexOf(token) != -1) { toRenew.expiresAt = lock.expiresAt; lock = toRenew; } } } } } // Set the status, then generate the XML response containing XMLWriter generatedXML = new XMLWriter(); generatedXML.writeXMLHeader(); generatedXML.writeElement(null, "prop" + generateNamespaceDeclarations(), XMLWriter.OPENING); generatedXML.writeElement(null, "lockdiscovery", XMLWriter.OPENING); lock.toXML(generatedXML); generatedXML.writeElement(null, "lockdiscovery", XMLWriter.CLOSING); generatedXML.writeElement(null, "prop", XMLWriter.CLOSING); resp.setStatus(WebdavStatus.SC_OK); resp.setContentType("text/xml; charset=UTF-8"); Writer writer = resp.getWriter(); writer.write(generatedXML.toString()); writer.close(); }	protected void doPropfind(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { if (!listings) { StringBuffer methodsAllowed = determineMethodsAllowed(resources, req); resp.addHeader("Allow", methodsAllowed.toString()); resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED); return; } String path = getRelativePath(req); if (path.endsWith("/")) path = path.substring(0, path.length() - 1); if ((path.toUpperCase().startsWith("/WEB-INF")) || (path.toUpperCase().startsWith("/META-INF"))) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return; } Vector<String> properties = null; int depth = INFINITY; int type = FIND_ALL_PROP; String depthStr = req.getHeader("Depth"); if (depthStr == null) { depth = INFINITY; } else { if (depthStr.equals("0")) { depth = 0; } else if (depthStr.equals("1")) { depth = 1; } else if (depthStr.equals("infinity")) { depth = INFINITY; } } Node propNode = null; if (req.getInputStream().available() > 0) { DocumentBuilder documentBuilder = getDocumentBuilder(); try { Document document = documentBuilder.parse(new InputSource(req.getInputStream())); Element rootElement = document.getDocumentElement(); NodeList childList = rootElement.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: if (currentNode.getNodeName().endsWith("prop")) { type = FIND_BY_PROPERTY; propNode = currentNode; } if (currentNode.getNodeName().endsWith("propname")) { type = FIND_PROPERTY_NAMES; } if (currentNode.getNodeName().endsWith("allprop")) { type = FIND_ALL_PROP; } break; } } } catch (SAXException e) { // Something went wrong - use the defaults. } catch (IOException e) { // Something went wrong - use the defaults. } } if (type == FIND_BY_PROPERTY) { properties = new Vector<String>(); NodeList childList = propNode.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node currentNode = childList.item(i); switch(currentNode.getNodeType()) { case Node.TEXT_NODE: break; case Node.ELEMENT_NODE: String nodeName = currentNode.getNodeName(); String propertyName = null; if (nodeName.indexOf(':') != -1) { propertyName = nodeName.substring(nodeName.indexOf(':') + 1); } else { propertyName = nodeName; } properties.addElement(propertyName); break; } } } boolean exists = true; Object object = null; try { object = resources.lookup(path); } catch (NamingException e) { exists = false; int slash = path.lastIndexOf('/'); if (slash != -1) { String parentPath = path.substring(0, slash); Vector<String> currentLockNullResources = lockNullResources.get(parentPath); if (currentLockNullResources != null) { Enumeration<String> lockNullResourcesList = currentLockNullResources.elements(); while (lockNullResourcesList.hasMoreElements()) { String lockNullPath = lockNullResourcesList.nextElement(); if (lockNullPath.equals(path)) { resp.setStatus(WebdavStatus.SC_MULTI_STATUS); resp.setContentType("text/xml; charset=UTF-8"); XMLWriter generatedXML = new XMLWriter(resp.getWriter()); generatedXML.writeXMLHeader(); generatedXML.writeElement(null, "multistatus" + generateNamespaceDeclarations(), XMLWriter.OPENING); parseLockNullProperties(req, generatedXML, lockNullPath, type, properties); generatedXML.writeElement(null, "multistatus", XMLWriter.CLOSING); generatedXML.sendData(); return; } } } } } if (!exists) { resp.sendError(HttpServletResponse.SC_NOT_FOUND, path); return; } resp.setStatus(WebdavStatus.SC_MULTI_STATUS); resp.setContentType("text/xml; charset=UTF-8"); XMLWriter generatedXML = new XMLWriter(resp.getWriter()); generatedXML.writeXMLHeader(); generatedXML.writeElement(null, "multistatus" + generateNamespaceDeclarations(), XMLWriter.OPENING); if (depth == 0) { parseProperties(req, generatedXML, path, type, properties); } else { Stack<String> stack = new Stack<String>(); stack.push(path); Stack<String> stackBelow = new Stack<String>(); while ((!stack.isEmpty()) && (depth >= 0)) { String currentPath = stack.pop(); parseProperties(req, generatedXML, currentPath, type, properties); try { object = resources.lookup(currentPath); } catch (NamingException e) { continue; } if ((object instanceof DirContext) && (depth > 0)) { try { NamingEnumeration<NameClassPair> enumeration = resources.list(currentPath); while (enumeration.hasMoreElements()) { NameClassPair ncPair = enumeration.nextElement(); String newPath = currentPath; if (!(newPath.endsWith("/"))) newPath += "/"; newPath += ncPair.getName(); stackBelow.push(newPath); } } catch (NamingException e) { resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, path); return; } // Displaying the lock-null resources present in that String lockPath = currentPath; if (lockPath.endsWith("/")) lockPath = lockPath.substring(0, lockPath.length() - 1); Vector<String> currentLockNullResources = lockNullResources.get(lockPath); if (currentLockNullResources != null) { Enumeration<String> lockNullResourcesList = currentLockNullResources.elements(); while (lockNullResourcesList.hasMoreElements()) { String lockNullPath = lockNullResourcesList.nextElement(); parseLockNullProperties(req, generatedXML, lockNullPath, type, properties); } } } if (stack.isEmpty()) { depth--; stack = stackBelow; stackBelow = new Stack<String>(); } generatedXML.sendData(); } } generatedXML.writeElement(null, "multistatus", XMLWriter.CLOSING); generatedXML.sendData(); }	public void init() throws ServletException { super.init(); if (getServletConfig().getInitParameter("secret") != null) secret = getServletConfig().getInitParameter("secret"); try { md5Helper = MessageDigest.getInstance("MD5"); } catch (NoSuchAlgorithmException e) { throw new UnavailableException("No MD5"); } }	public void toXML(XMLWriter generatedXML) { generatedXML.writeElement(null, "activelock", XMLWriter.OPENING); generatedXML.writeElement(null, "locktype", XMLWriter.OPENING); generatedXML.writeElement(null, type, XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "locktype", XMLWriter.CLOSING); generatedXML.writeElement(null, "lockscope", XMLWriter.OPENING); generatedXML.writeElement(null, scope, XMLWriter.NO_CONTENT); generatedXML.writeElement(null, "lockscope", XMLWriter.CLOSING); generatedXML.writeElement(null, "depth", XMLWriter.OPENING); if (depth == INFINITY) { generatedXML.writeText("Infinity"); } else { generatedXML.writeText("0"); } generatedXML.writeElement(null, "depth", XMLWriter.CLOSING); generatedXML.writeElement(null, "owner", XMLWriter.OPENING); generatedXML.writeText(owner); generatedXML.writeElement(null, "owner", XMLWriter.CLOSING); generatedXML.writeElement(null, "timeout", XMLWriter.OPENING); long timeout = (expiresAt - System.currentTimeMillis()) / 1000; generatedXML.writeText("Second-" + timeout); generatedXML.writeElement(null, "timeout", XMLWriter.CLOSING); generatedXML.writeElement(null, "locktoken", XMLWriter.OPENING); Enumeration<String> tokensList = tokens.elements(); while (tokensList.hasMoreElements()) { generatedXML.writeElement(null, "href", XMLWriter.OPENING); generatedXML.writeText("opaquelocktoken:" + tokensList.nextElement()); generatedXML.writeElement(null, "href", XMLWriter.CLOSING); } generatedXML.writeElement(null, "locktoken", XMLWriter.CLOSING); generatedXML.writeElement(null, "activelock", XMLWriter.CLOSING); }
private String comparePageEncodings(String thePageDirEnc, Node.PageDirective pageDir) throws JasperException { Node.Root root = pageDir.getRoot(); String configEnc = root.getJspConfigPageEncoding(); String pageDirEnc = thePageDirEnc.toUpperCase(); if (configEnc != null) { configEnc = configEnc.toUpperCase(); if (!pageDirEnc.equals(configEnc) && (!pageDirEnc.startsWith("UTF-16") || !configEnc.startsWith("UTF-16"))) { err.jspError(pageDir, "jsp.error.config_pagedir_encoding_mismatch", configEnc, pageDirEnc); } else { return configEnc; } } if ((root.isXmlSyntax() && root.isEncodingSpecifiedInProlog()) || root.isBomPresent()) { String pageEnc = root.getPageEncoding().toUpperCase(); if (!pageDirEnc.equals(pageEnc) && (!pageDirEnc.startsWith("UTF-16") || !pageEnc.startsWith("UTF-16"))) { err.jspError(pageDir, "jsp.error.prolog_pagedir_encoding_mismatch", pageEnc, pageDirEnc); } else { return pageEnc; } } return pageDirEnc; }	private void compareTagEncodings(String pageDirEnc, Node.TagDirective pageDir) throws JasperException { Node.Root root = pageDir.getRoot(); if ((root.isXmlSyntax() && root.isEncodingSpecifiedInProlog()) || root.isBomPresent()) { String pageEnc = root.getPageEncoding(); if (!pageDirEnc.equals(pageEnc) && (!pageDirEnc.startsWith("UTF-16") || !pageEnc.startsWith("UTF-16"))) { err.jspError(pageDir, "jsp.error.prolog_pagedir_encoding_mismatch", pageEnc, pageDirEnc); } } }
private TagFileInfo createTagFileInfo(TreeNode elem, String uri, URL jarFileUrl) throws JasperException { String name = null; String path = null; Iterator<TreeNode> list = elem.findChildren(); while (list.hasNext()) { TreeNode child = list.next(); String tname = child.getName(); if ("name".equals(tname)) { name = child.getBody(); } else if ("path".equals(tname)) { path = child.getBody(); } else if ("example".equals(tname)) { // Ignore <example> element: Bugzilla 33538 } else if ("tag-extension".equals(tname)) { // Ignore <tag-extension> element: Bugzilla 33538 } else if ("icon".equals(tname) || "display-name".equals(tname) || "description".equals(tname)) { // Ignore these elements: Bugzilla 38015 } else { if (log.isWarnEnabled()) { log.warn(Localizer.getMessage("jsp.warning.unknown.element.in.tagfile", tname)); } } } if (path.startsWith("/META-INF/tags")) { ctxt.setTagFileJarUrl(path, jarFileUrl); } else if (!path.startsWith("/WEB-INF/tags")) { err.jspError("jsp.error.tagfile.illegalPath", path); } TagInfo tagInfo = TagFileProcessor.parseTagFileDirectives(parserController, name, path, this); return new TagFileInfo(name, path, tagInfo); }	private Node.Nodes doParse(String inFileName, Node parent, URL jarFileUrl) throws FileNotFoundException, JasperException, IOException { Node.Nodes parsedPage = null; isEncodingSpecifiedInProlog = false; isBomPresent = false; isDefaultPageEncoding = false; JarFile jarFile = getJarFile(jarFileUrl); String absFileName = resolveFileName(inFileName); String jspConfigPageEnc = getJspConfigPageEncoding(absFileName); // Figure out what type of JSP document and encoding type we are determineSyntaxAndEncoding(absFileName, jarFile, jspConfigPageEnc); if (parent != null) { if (jarFile == null) { compiler.getPageInfo().addDependant(absFileName); } else { compiler.getPageInfo().addDependant(jarFileUrl.toExternalForm() + absFileName.substring(1)); } } if ((isXml && isEncodingSpecifiedInProlog) || isBomPresent) { if (jspConfigPageEnc != null && !jspConfigPageEnc.equals(sourceEnc) && (!jspConfigPageEnc.startsWith("UTF-16") || !sourceEnc.startsWith("UTF-16"))) { err.jspError("jsp.error.prolog_config_encoding_mismatch", sourceEnc, jspConfigPageEnc); } } if (isXml) { // JSP document (XML syntax) // InputStream for jspx page is created and properly closed in parsedPage = JspDocumentParser.parse(this, absFileName, jarFile, parent, isTagFile, directiveOnly, sourceEnc, jspConfigPageEnc, isEncodingSpecifiedInProlog, isBomPresent); } else { InputStreamReader inStreamReader = null; try { inStreamReader = JspUtil.getReader(absFileName, sourceEnc, jarFile, ctxt, err, skip); JspReader jspReader = new JspReader(ctxt, absFileName, sourceEnc, inStreamReader, err); parsedPage = Parser.parse(this, jspReader, parent, isTagFile, directiveOnly, jarFileUrl, sourceEnc, jspConfigPageEnc, isDefaultPageEncoding, isBomPresent); } finally { if (inStreamReader != null) { try { inStreamReader.close(); } catch (Exception any) { } } } } if (jarFile != null) { try { jarFile.close(); } catch (Throwable t) { } } baseDirStack.pop(); return parsedPage; }	public TagLibraryInfo[] getTagLibraryInfos() { Collection<TagLibraryInfo> coll = pi.getTaglibs(); return coll.toArray(new TagLibraryInfo[0]); }	public TagInfo getTagInfo() throws JasperException { if (name == null) { // XXX Get it from tag file name } if (bodycontent == null) { bodycontent = TagInfo.BODY_CONTENT_SCRIPTLESS; } String tagClassName = JspUtil.getTagHandlerClassName(path, err); TagVariableInfo[] tagVariableInfos = new TagVariableInfo[variableVector.size()]; variableVector.copyInto(tagVariableInfos); TagAttributeInfo[] tagAttributeInfo = new TagAttributeInfo[attributeVector.size()]; attributeVector.copyInto(tagAttributeInfo); return new JasperTagInfo(name, tagClassName, bodycontent, description, tagLibInfo, tei, tagAttributeInfo, displayName, smallIcon, largeIcon, tagVariableInfos, dynamicAttrsMapName); }	public static InputStream getInputStream(String fname, JarFile jarFile, JspCompilationContext ctxt, ErrorDispatcher err) throws JasperException, IOException { InputStream in = null; if (jarFile != null) { String jarEntryName = fname.substring(1, fname.length()); ZipEntry jarEntry = jarFile.getEntry(jarEntryName); if (jarEntry == null) { err.jspError("jsp.error.file.not.found", fname); } in = jarFile.getInputStream(jarEntry); } else { in = ctxt.getResourceAsStream(fname); } if (in == null) { err.jspError("jsp.error.file.not.found", fname); } return in; }	public static String getTagHandlerClassName(String path, ErrorDispatcher err) throws JasperException { String className = null; int begin = 0; int index; index = path.lastIndexOf(".tag"); if (index == -1) { err.jspError("jsp.error.tagfile.badSuffix", path); } // It's tempting to remove the ".tag" suffix here, but we can't. // If we remove it, the fully-qualified class name of this tag // could conflict with the package name of other tags. // For instance, the tag file // /WEB-INF/tags/foo.tag // would have fully-qualified class name // org.apache.jsp.tag.web.foo // which would conflict with the package name of the tag file index = path.indexOf(WEB_INF_TAGS); if (index != -1) { className = "org.apache.jsp.tag.web."; begin = index + WEB_INF_TAGS.length(); } else { index = path.indexOf(META_INF_TAGS); if (index != -1) { className = "org.apache.jsp.tag.meta."; begin = index + META_INF_TAGS.length(); } else { err.jspError("jsp.error.tagfile.illegalPath", path); } } className += makeJavaPackage(path.substring(begin)); return className; }	private Class<?> loadTagFile(Compiler compiler, String tagFilePath, TagInfo tagInfo, PageInfo parentPageInfo) throws JasperException { JspCompilationContext ctxt = compiler.getCompilationContext(); JspRuntimeContext rctxt = ctxt.getRuntimeContext(); JspServletWrapper wrapper = rctxt.getWrapper(tagFilePath); synchronized (rctxt) { if (wrapper == null) { wrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), ctxt.getTagFileJarUrl(tagFilePath)); rctxt.addWrapper(tagFilePath, wrapper); wrapper.getJspEngineContext().setClassLoader((URLClassLoader) ctxt.getClassLoader()); wrapper.getJspEngineContext().setClassPath(ctxt.getClassPath()); } else { // Make sure that JspCompilationContext gets the latest TagInfo // for the tag file. TagInfo instance was created the last // time the tag file was scanned for directives, and the tag wrapper.getJspEngineContext().setTagInfo(tagInfo); } Class<?> tagClazz; int tripCount = wrapper.incTripCount(); try { if (tripCount > 0) { // When tripCount is greater than zero, a circular // dependency exists. The circularily dependant tag // file is compiled in prototype mode, to avoid infinite JspServletWrapper tempWrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt.getOptions(), tagFilePath, tagInfo, ctxt.getRuntimeContext(), ctxt.getTagFileJarUrl(tagFilePath)); tagClazz = tempWrapper.loadTagFilePrototype(); tempVector.add(tempWrapper.getJspEngineContext().getCompiler()); } else { tagClazz = wrapper.loadTagFile(); } } finally { wrapper.decTripCount(); } try { Object tagIns = tagClazz.newInstance(); if (tagIns instanceof JspSourceDependent) { Iterator<String> iter = ((JspSourceDependent) tagIns).getDependants().iterator(); while (iter.hasNext()) { parentPageInfo.addDependant(iter.next()); } } } catch (Exception e) { // ignore errors } return tagClazz; } }	void postCheck() throws JasperException { Iterator<String> iter = nameFromTable.keySet().iterator(); while (iter.hasNext()) { String nameFrom = iter.next(); NameEntry nameEntry = nameTable.get(nameFrom); NameEntry nameFromEntry = nameFromTable.get(nameFrom); Node nameFromNode = nameFromEntry.getNode(); if (nameEntry == null) { err.jspError(nameFromNode, "jsp.error.tagfile.nameFrom.noAttribute", nameFrom); } else { Node node = nameEntry.getNode(); TagAttributeInfo tagAttr = nameEntry.getTagAttributeInfo(); if (!"java.lang.String".equals(tagAttr.getTypeName()) || !tagAttr.isRequired() || tagAttr.canBeRequestTime()) { err.jspError(nameFromNode, "jsp.error.tagfile.nameFrom.badAttribute", nameFrom, Integer.toString(node.getStart().getLineNumber())); } } } }
public Class<?> loadClass(final String name, boolean resolve) throws ClassNotFoundException { Class<?> clazz = null; clazz = findLoadedClass(name); if (clazz != null) { if (resolve) resolveClass(clazz); return (clazz); } if (securityManager != null) { int dot = name.lastIndexOf('.'); if (dot >= 0) { try { if (!"org.apache.jasper.runtime".equalsIgnoreCase(name.substring(0, dot))) { securityManager.checkPackageAccess(name.substring(0, dot)); } } catch (SecurityException se) { String error = "Security Violation, attempt to use " + "Restricted Class: " + name; se.printStackTrace(); throw new ClassNotFoundException(error); } } } if (!name.startsWith(Constants.JSP_PACKAGE_NAME)) { // Class is not in org.apache.jsp, therefore, have our clazz = parent.loadClass(name); if (resolve) resolveClass(clazz); return clazz; } return findClass(name); }
protected Connection open() throws SQLException { if (dbConnection != null) return (dbConnection); if (driver == null) { try { Class<?> clazz = Class.forName(driverName); driver = (Driver) clazz.newInstance(); } catch (Throwable e) { throw new SQLException(e.getMessage()); } } Properties props = new Properties(); if (connectionName != null) props.put("user", connectionName); if (connectionPassword != null) props.put("password", connectionPassword); dbConnection = driver.connect(connectionURL, props); dbConnection.setAutoCommit(false); return (dbConnection); }
protected Comparator getComparator(String sortBy) { Comparator comparator = null; if ("CreationTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(session.getCreationTime()); } }; } else if ("id".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return session.getId(); } }; } else if ("LastAccessedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(session.getLastAccessedTime()); } }; } else if ("MaxInactiveInterval".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(session.getMaxInactiveInterval()); } }; } else if ("new".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return Boolean.valueOf(session.getSession().isNew()); } }; } else if ("locale".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return JspHelper.guessDisplayLocaleFromSession(session); } }; } else if ("user".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return JspHelper.guessDisplayUserFromSession(session); } }; } else if ("UsedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(SessionUtils.getUsedTimeForSession(session)); } }; } else if ("InactiveTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(SessionUtils.getInactiveTimeForSession(session)); } }; } else if ("TTL".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(SessionUtils.getTTLForSession(session)); } }; } return comparator; }	public void list(HttpServletRequest request, HttpServletResponse response, String message) throws IOException { if (debug >= 1) log("list: Listing contexts for virtual host '" + host.getName() + "'"); PrintWriter writer = response.getWriter(); writer.print(Constants.HTML_HEADER_SECTION); Object[] args = new Object[2]; args[0] = request.getContextPath(); args[1] = sm.getString("htmlManagerServlet.title"); writer.print(MessageFormat.format(Constants.BODY_HEADER_SECTION, args)); args = new Object[3]; args[0] = sm.getString("htmlManagerServlet.messageLabel"); if (message == null || message.length() == 0) { args[1] = "OK"; } else { args[1] = RequestUtil.filter(message); } writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args)); args = new Object[9]; args[0] = sm.getString("htmlManagerServlet.manager"); args[1] = response.encodeURL(request.getContextPath() + "/html/list"); args[2] = sm.getString("htmlManagerServlet.list"); args[3] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpHtmlManagerFile")); args[4] = sm.getString("htmlManagerServlet.helpHtmlManager"); args[5] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpManagerFile")); args[6] = sm.getString("htmlManagerServlet.helpManager"); args[7] = response.encodeURL(request.getContextPath() + "/status"); args[8] = sm.getString("statusServlet.title"); writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args)); args = new Object[6]; args[0] = sm.getString("htmlManagerServlet.appsTitle"); args[1] = sm.getString("htmlManagerServlet.appsPath"); args[2] = sm.getString("htmlManagerServlet.appsName"); args[3] = sm.getString("htmlManagerServlet.appsAvailable"); args[4] = sm.getString("htmlManagerServlet.appsSessions"); args[5] = sm.getString("htmlManagerServlet.appsTasks"); writer.print(MessageFormat.format(APPS_HEADER_SECTION, args)); // Apps Row Section Container[] children = host.findChildren(); String[] contextPaths = new String[children.length]; for (int i = 0; i < children.length; i++) contextPaths[i] = children[i].getName(); TreeMap sortedContextPathsMap = new TreeMap(); for (int i = 0; i < contextPaths.length; i++) { String displayPath = contextPaths[i]; sortedContextPathsMap.put(displayPath, contextPaths[i]); } String appsStart = sm.getString("htmlManagerServlet.appsStart"); String appsStop = sm.getString("htmlManagerServlet.appsStop"); String appsReload = sm.getString("htmlManagerServlet.appsReload"); String appsUndeploy = sm.getString("htmlManagerServlet.appsUndeploy"); String appsExpire = sm.getString("htmlManagerServlet.appsExpire"); Iterator iterator = sortedContextPathsMap.entrySet().iterator(); boolean isHighlighted = true; boolean isDeployed = true; String highlightColor = null; while (iterator.hasNext()) { isHighlighted = !isHighlighted; if (isHighlighted) { highlightColor = "#C3F3C3"; } else { highlightColor = "#FFFFFF"; } Map.Entry entry = (Map.Entry) iterator.next(); String displayPath = (String) entry.getKey(); String contextPath = (String) entry.getValue(); Context context = (Context) host.findChild(contextPath); if (displayPath.equals("")) { displayPath = "/"; } if (context != null) { try { isDeployed = isDeployed(contextPath); } catch (Exception e) { isDeployed = false; } args = new Object[6]; args[0] = displayPath; args[1] = context.getDisplayName(); if (args[1] == null) { args[1] = "&nbsp;"; } args[2] = new Boolean(context.getAvailable()); args[3] = response.encodeURL(request.getContextPath() + "/html/sessions?path=" + displayPath); if (context.getManager() != null) { args[4] = new Integer(context.getManager().getActiveSessions()); } else { args[4] = new Integer(0); } args[5] = highlightColor; writer.print(MessageFormat.format(APPS_ROW_DETAILS_SECTION, args)); args = new Object[14]; args[0] = response.encodeURL(request.getContextPath() + "/html/start?path=" + displayPath); args[1] = appsStart; args[2] = response.encodeURL(request.getContextPath() + "/html/stop?path=" + displayPath); args[3] = appsStop; args[4] = response.encodeURL(request.getContextPath() + "/html/reload?path=" + displayPath); args[5] = appsReload; args[6] = response.encodeURL(request.getContextPath() + "/html/undeploy?path=" + displayPath); args[7] = appsUndeploy; args[8] = response.encodeURL(request.getContextPath() + "/html/expire?path=" + displayPath); args[9] = appsExpire; args[10] = sm.getString("htmlManagerServlet.expire.explain"); Manager manager = context.getManager(); if (manager == null) { args[11] = sm.getString("htmlManagerServlet.noManager"); } else { args[11] = new Integer(context.getManager().getMaxInactiveInterval() / 60); } args[12] = sm.getString("htmlManagerServlet.expire.unit"); args[13] = highlightColor; if (context.getPath().equals(this.context.getPath())) { writer.print(MessageFormat.format(MANAGER_APP_ROW_BUTTON_SECTION, args)); } else if (context.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STARTED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (context.getAvailable() && !isDeployed) { writer.print(MessageFormat.format(STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (!context.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STOPPED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else { writer.print(MessageFormat.format(STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } } } args = new Object[7]; args[0] = sm.getString("htmlManagerServlet.deployTitle"); args[1] = sm.getString("htmlManagerServlet.deployServer"); args[2] = response.encodeURL(request.getContextPath() + "/html/deploy"); args[3] = sm.getString("htmlManagerServlet.deployPath"); args[4] = sm.getString("htmlManagerServlet.deployConfig"); args[5] = sm.getString("htmlManagerServlet.deployWar"); args[6] = sm.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(DEPLOY_SECTION, args)); args = new Object[4]; args[0] = sm.getString("htmlManagerServlet.deployUpload"); args[1] = response.encodeURL(request.getContextPath() + "/html/upload"); args[2] = sm.getString("htmlManagerServlet.deployUploadFile"); args[3] = sm.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(UPLOAD_SECTION, args)); args = new Object[7]; args[0] = sm.getString("htmlManagerServlet.serverTitle"); args[1] = sm.getString("htmlManagerServlet.serverVersion"); args[2] = sm.getString("htmlManagerServlet.serverJVMVersion"); args[3] = sm.getString("htmlManagerServlet.serverJVMVendor"); args[4] = sm.getString("htmlManagerServlet.serverOSName"); args[5] = sm.getString("htmlManagerServlet.serverOSVersion"); args[6] = sm.getString("htmlManagerServlet.serverOSArch"); writer.print(MessageFormat.format(Constants.SERVER_HEADER_SECTION, args)); args = new Object[6]; args[0] = ServerInfo.getServerInfo(); args[1] = System.getProperty("java.runtime.version"); args[2] = System.getProperty("java.vm.vendor"); args[3] = System.getProperty("os.name"); args[4] = System.getProperty("os.version"); args[5] = System.getProperty("os.arch"); writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args)); writer.print(Constants.HTML_TAIL_SECTION); writer.flush(); writer.close(); }	public void setPath(String path) { setName(RequestUtil.URLDecode(path)); }
private String attributeValueWithEL(boolean isTag, String tx, Class<?> expectedType, String mapName) { if (tx == null) return null; int size = tx.length(); StringBuffer output = new StringBuffer(size); boolean el = false; int i = 0; int mark = 0; char ch; while (i < size) { ch = tx.charAt(i); if (!el && i + 1 < size && ch == '$' && tx.charAt(i + 1) == '{') { if (mark < i) { if (output.length() > 0) { output.append(" + "); } output.append(quote(tx.substring(mark, i))); } mark = i; el = true; i += 2; } else if (ch == '\\' && i + 1 < size && (tx.charAt(i + 1) == '$' || tx.charAt(i + 1) == '}')) { i += 2; } else if (el && ch == '}') { if (output.length() > 0) { output.append(" + "); } output.append(JspUtil.interpreterCall(isTag, tx.substring(mark, i + 1), expectedType, mapName, false)); mark = i + 1; el = false; ++i; } else { ++i; } } if (!el && mark < i) { if (output.length() > 0) { output.append(" + "); } output.append(quote(tx.substring(mark, i))); } return output.toString(); }
public void start() throws Exception { if (started) return; Container hcontainer = getCluster().getContainer(); if (!(hcontainer instanceof Host)) { log.error("FarmWarDeployer can only work as host cluster subelement!"); return; } host = (Host) hcontainer; Container econtainer = host.getParent(); if (econtainer == null && econtainer instanceof Engine) { log.error("FarmWarDeployer can only work if parent of " + host.getName() + " is an engine!"); return; } Engine engine = (Engine) econtainer; String hostname = null; hostname = host.getName(); try { oname = new ObjectName(engine.getName() + ":type=Deployer,host=" + hostname); } catch (Exception e) { log.error("Can't construct MBean object name" + e); return; } if (watchEnabled) { watcher = new WarWatcher(this, new File(getWatchDir())); if (log.isInfoEnabled()) { log.info("Cluster deployment is watching " + getWatchDir() + " for changes."); } } configBase = new File(System.getProperty("catalina.base"), "conf"); if (engine != null) { configBase = new File(configBase, engine.getName()); } if (host != null) { configBase = new File(configBase, hostname); } mBeanServer = Registry.getRegistry(null, null).getMBeanServer(); started = true; count = 0; getCluster().addClusterListener(this); if (log.isInfoEnabled()) log.info("Cluster FarmWarDeployer started."); }
private void generateCustomEnd(Node.CustomTag n, String tagHandlerVar, String tagEvalVar, String tagPushBodyCountVar) { if (!n.hasEmptyBody()) { if (n.implementsIterationTag()) { out.printin("int evalDoAfterBody = "); out.print(tagHandlerVar); out.println(".doAfterBody();"); syncScriptingVars(n, VariableInfo.AT_BEGIN); syncScriptingVars(n, VariableInfo.NESTED); out.printil("if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN)"); out.pushIndent(); out.printil("break;"); out.popIndent(); out.popIndent(); out.printil("} while (true);"); } restoreScriptingVars(n, VariableInfo.NESTED); if (n.implementsBodyTag()) { out.printin("if ("); out.print(tagEvalVar); out.println(" != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {"); out.pushIndent(); out.printil("out = _jspx_page_context.popBody();"); if (n.implementsTryCatchFinally()) { out.printin(tagPushBodyCountVar); out.println("[0]--;"); } else if (pushBodyCountVar != null) { out.printin(pushBodyCountVar); out.println("[0]--;"); } out.popIndent(); out.printil("}"); } out.popIndent(); out.printil("}"); } out.printin("if ("); out.print(tagHandlerVar); out.println(".doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {"); out.pushIndent(); if (!n.implementsTryCatchFinally()) { if (isPoolingEnabled && !(n.implementsJspIdConsumer())) { out.printin(n.getTagHandlerPoolName()); out.print(".reuse("); out.print(tagHandlerVar); out.println(");"); } else { out.printin(tagHandlerVar); out.println(".release();"); writeDestroyInstance(tagHandlerVar); } } if (isTagFile || isFragment) { out.printil("throw new SkipPageException();"); } else { out.printil((methodNesting > 0) ? "return true;" : "return;"); } out.popIndent(); out.printil("}"); syncScriptingVars(n, VariableInfo.AT_BEGIN); if (n.implementsTryCatchFinally()) { out.popIndent(); out.printil("} catch (Throwable _jspx_exception) {"); out.pushIndent(); out.printin("while ("); out.print(tagPushBodyCountVar); out.println("[0]-- > 0)"); out.pushIndent(); out.printil("out = _jspx_page_context.popBody();"); out.popIndent(); out.printin(tagHandlerVar); out.println(".doCatch(_jspx_exception);"); out.popIndent(); out.printil("} finally {"); out.pushIndent(); out.printin(tagHandlerVar); out.println(".doFinally();"); } if (isPoolingEnabled) { out.printin(n.getTagHandlerPoolName()); out.print(".reuse("); out.print(tagHandlerVar); out.println(");"); } else { out.printin(tagHandlerVar); out.println(".release();"); writeDestroyInstance(tagHandlerVar); } if (n.implementsTryCatchFinally()) { out.popIndent(); out.printil("}"); } // Declare and synchronize AT_END scripting variables (must do this declareScriptingVars(n, VariableInfo.AT_END); syncScriptingVars(n, VariableInfo.AT_END); restoreScriptingVars(n, VariableInfo.AT_BEGIN); }
public static void appendCookieValue(StringBuffer headerBuf, int version, String name, String value, String path, String domain, String comment, int maxAge, boolean isSecure, boolean isHttpOnly) { StringBuffer buf = new StringBuffer(); buf.append(name); buf.append("="); version = maybeQuote2(version, buf, value, true); if (version == 1) { buf.append("; Version=1"); if (comment != null) { buf.append("; Comment="); maybeQuote2(version, buf, comment); } } if (domain != null) { buf.append("; Domain="); maybeQuote2(version, buf, domain); } if (maxAge >= 0) { if (version == 0) { buf.append("; Expires="); if (maxAge == 0) buf.append(ancientDate); else synchronized (OLD_COOKIE_FORMAT) { OLD_COOKIE_FORMAT.format(new Date(System.currentTimeMillis() + maxAge * 1000L), buf, new FieldPosition(0)); } } else { buf.append("; Max-Age="); buf.append(maxAge); } } if (path != null) { buf.append("; Path="); if (version == 0) { maybeQuote2(version, buf, path); } else { maybeQuote2(version, buf, path, ServerCookie.tspecials2NoSlash, false); } } if (isSecure) { buf.append("; Secure"); } if (isHttpOnly) { buf.append("; HttpOnly"); } headerBuf.append(buf); }
private static void execute(final Method method, final Object targetObject, final Object[] targetArguments, Principal principal) throws java.lang.Exception { try { Subject subject = null; PrivilegedExceptionAction pea = new PrivilegedExceptionAction() { public Object run() throws Exception { method.invoke(targetObject, targetArguments); return null; } }; if (targetArguments != null && targetArguments[0] instanceof HttpServletRequest) { HttpServletRequest request = (HttpServletRequest) targetArguments[0]; boolean hasSubject = false; HttpSession session = request.getSession(false); if (session != null) { subject = (Subject) session.getAttribute(Globals.SUBJECT_ATTR); hasSubject = (subject != null); } if (subject == null) { subject = new Subject(); if (principal != null) { subject.getPrincipals().add(principal); } } if (session != null && !hasSubject) { session.setAttribute(Globals.SUBJECT_ATTR, subject); } } Subject.doAsPrivileged(subject, pea, null); } catch (PrivilegedActionException pe) { Throwable e = ((InvocationTargetException) pe.getException()).getTargetException(); if (log.isDebugEnabled()) { log.debug(sm.getString("SecurityUtil.doAsPrivilege"), e); } if (e instanceof UnavailableException) throw (UnavailableException) e; } }

private void guaranteeIterator() { while (this.itr == null && this.idx < this.size) { this.itr = this.resolvers[this.idx].getFeatureDescriptors(this.context, this.base); this.idx++; } }	public FeatureDescriptor next() { Object result = null; if (this.itr != null) { if (this.itr.hasNext()) { result = this.itr.next(); if (!this.itr.hasNext()) { this.itr = null; this.guaranteeIterator(); } } } return (FeatureDescriptor) result; }	public Class<?> getType(ELContext context, Object base, Object property) throws NullPointerException, PropertyNotFoundException, ELException { context.setPropertyResolved(false); int sz = this.size; Class<?> type; for (int i = 0; i < sz; i++) { type = this.resolvers[i].getType(context, base, property); if (context.isPropertyResolved()) { return type; } } return null; }
public void compile(boolean compileClass, boolean jspcMode) throws FileNotFoundException, JasperException, Exception { if (errDispatcher == null) { this.errDispatcher = new ErrorDispatcher(jspcMode); } try { String[] smap = generateJava(); if (compileClass) { generateClass(smap); } } finally { if (tfp != null) { tfp.removeProtoTypeFiles(null); } // Make sure these object which are only used during the // generation and compilation of the JSP page get // dereferenced so that they can be GC'd and reduce the tfp = null; errDispatcher = null; pageInfo = null; if (!this.options.getDevelopment()) { pageNodes = null; } if (ctxt.getWriter() != null) { ctxt.getWriter().close(); ctxt.setWriter(null); } } }
private static final int findIgnoreCase(MapElement[] map, CharChunk name, int start, int end) { int a = 0; int b = map.length - 1; if (b == -1) { return -1; } if (compareIgnoreCase(name, start, end, map[0].name) < 0) { return -1; } if (b == 0) { return 0; } int i = 0; while (true) { i = (b + a) / 2; int result = compareIgnoreCase(name, start, end, map[i].name); if (result == 1) { a = i; } else if (result == 0) { return i; } else { b = i; } if ((b - a) == 1) { int result2 = compareIgnoreCase(name, start, end, map[b].name); if (result2 < 0) { return a; } else { return b; } } } }	private void registerEngine() throws Exception { ObjectName engineName = new ObjectName(domain + ":type=Engine"); if (!mBeanServer.isRegistered(engineName)) return; String defaultHost = (String) mBeanServer.getAttribute(engineName, "defaultHost"); ObjectName hostName = new ObjectName(domain + ":type=Host," + "host=" + defaultHost); if (!mBeanServer.isRegistered(hostName)) { String onStr = domain + ":type=Host,*"; ObjectName objectName = new ObjectName(onStr); Set set = mBeanServer.queryMBeans(objectName, null); Iterator iterator = set.iterator(); String[] aliases; boolean isRegisteredWithAlias = false; while (iterator.hasNext()) { if (isRegisteredWithAlias) break; ObjectInstance oi = (ObjectInstance) iterator.next(); hostName = oi.getObjectName(); aliases = (String[]) mBeanServer.invoke(hostName, "findAliases", null, null); for (int i = 0; i < aliases.length; i++) { if (aliases[i].equalsIgnoreCase(defaultHost)) { isRegisteredWithAlias = true; break; } } } if (!isRegisteredWithAlias && log.isWarnEnabled()) log.warn(sm.getString("mapperListener.unknownDefaultHost", defaultHost)); } if (defaultHost != null) { mapper.setDefaultHostName(defaultHost); } }	private void registerHost(ObjectName objectName) throws Exception { String name = objectName.getKeyProperty("host"); if (name != null) { String[] aliases = (String[]) mBeanServer.invoke(objectName, "findAliases", null, null); mapper.addHost(name, aliases, objectName); if (log.isDebugEnabled()) log.debug(sm.getString("mapperListener.registerHost", name, domain)); } }	private void unregisterHost(ObjectName objectName) throws Exception { String name = objectName.getKeyProperty("host"); mapper.removeHost(name); if (log.isDebugEnabled()) log.debug(sm.getString("mapperListener.unregisterHost", name, domain)); }	public String[] getHosts() { String[] hostN = new String[hosts.length]; for (int i = 0; i < hosts.length; i++) { hostN[i] = hosts[i].name; } return hostN; }	public void handleNotification(Notification notification, java.lang.Object handback) { if (notification instanceof MBeanServerNotification) { ObjectName objectName = ((MBeanServerNotification) notification).getMBeanName(); String j2eeType = objectName.getKeyProperty("j2eeType"); String engineName = null; if (j2eeType != null) { if ((j2eeType.equals("WebModule")) || (j2eeType.equals("Servlet"))) { if (mBeanServer.isRegistered(objectName)) { try { engineName = (String) mBeanServer.getAttribute(objectName, "engineName"); } catch (Exception e) { // Ignore } } } } if ((!"*".equals(domain)) && (!domain.equals(objectName.getDomain())) && ((!domain.equals(engineName)) && (engineName != null))) { return; } if (log.isDebugEnabled()) log.debug("Handle " + objectName + " type : " + notification.getType()); if (notification.getType().equals(MBeanServerNotification.REGISTRATION_NOTIFICATION)) { String type = objectName.getKeyProperty("type"); if ("Host".equals(type) && domain.equals(objectName.getDomain())) { try { registerHost(objectName); } catch (Exception e) { log.warn("Error registering Host " + objectName, e); } } if (j2eeType != null) { if (j2eeType.equals("WebModule")) { try { registerContext(objectName); } catch (Throwable t) { log.warn("Error registering Context " + objectName, t); } } else if (j2eeType.equals("Servlet")) { try { registerWrapper(objectName); } catch (Throwable t) { log.warn("Error registering Wrapper " + objectName, t); } } } } else if (notification.getType().equals(MBeanServerNotification.UNREGISTRATION_NOTIFICATION)) { String type = objectName.getKeyProperty("type"); if ("Host".equals(type) && domain.equals(objectName.getDomain())) { try { unregisterHost(objectName); } catch (Exception e) { log.warn("Error unregistering Host " + objectName, e); } } if (j2eeType != null) { if (j2eeType.equals("WebModule")) { try { unregisterContext(objectName); } catch (Throwable t) { log.warn("Error unregistering webapp " + objectName, t); } } } } } }
protected ServletContextAndPath getServletContextAndPathFromVirtualPath(String virtualPath) throws IOException { if (!virtualPath.startsWith("/") && !virtualPath.startsWith("\\")) { return new ServletContextAndPath(context, getAbsolutePath(virtualPath)); } else { String normalized = SSIServletRequestUtil.normalize(virtualPath); if (isVirtualWebappRelative) { return new ServletContextAndPath(context, normalized); } else { ServletContext normContext = context.getContext(normalized); if (normContext == null) { throw new IOException("Couldn't get context for path: " + normalized); } if (!isRootContext(normContext)) { String noContext = getPathWithoutContext(normalized); if (noContext == null) { throw new IOException("Couldn't remove context from path: " + normalized); } return new ServletContextAndPath(normContext, noContext); } else { return new ServletContextAndPath(normContext, normalized); } } } }	protected String getPathWithoutContext(String servletPath) { String retVal = null; int secondSlash = servletPath.indexOf('/', 1); if (secondSlash >= 0) { retVal = servletPath.substring(secondSlash); } return retVal; }	protected String getPathWithoutFileName(String servletPath) { String retVal = null; int lastSlash = servletPath.lastIndexOf('/'); if (lastSlash >= 0) { retVal = servletPath.substring(0, lastSlash + 1); } return retVal; }
void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { if (pos < n) { ApplicationFilterConfig filterConfig = filters[pos++]; Filter filter = null; try { filter = filterConfig.getFilter(); support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT, filter, request, response); if (Globals.IS_SECURITY_ENABLED) { final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[] { req, res, this }; SecurityUtil.doAsPrivilege("doFilter", filter, classType, args); args = null; } else { filter.doFilter(request, response, this); } support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response); } catch (IOException e) { if (filter != null) support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response, e); throw e; } catch (ServletException e) { if (filter != null) support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response, e); throw e; } catch (RuntimeException e) { if (filter != null) support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response, e); throw e; } catch (Throwable e) { if (filter != null) support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response, e); throw new ServletException(sm.getString("filterChain.filter"), e); } return; } try { if (Globals.STRICT_SERVLET_COMPLIANCE) { lastServicedRequest.set(request); lastServicedResponse.set(response); } support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT, servlet, request, response); if ((request instanceof HttpServletRequest) && (response instanceof HttpServletResponse)) { if (Globals.IS_SECURITY_ENABLED) { final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[] { req, res }; SecurityUtil.doAsPrivilege("service", servlet, classTypeUsedInService, args, principal); args = null; } else { servlet.service((HttpServletRequest) request, (HttpServletResponse) response); } } else { servlet.service(request, response); } support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response); } catch (IOException e) { support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response, e); throw e; } catch (ServletException e) { support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response, e); throw e; } catch (RuntimeException e) { support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response, e); throw e; } catch (Throwable e) { support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response, e); throw new ServletException(sm.getString("filterChain.servlet"), e); } finally { if (Globals.STRICT_SERVLET_COMPLIANCE) { lastServicedRequest.set(null); lastServicedResponse.set(null); } } }	public static void doAsPrivilege(final String methodName, final Filter targetObject, final Class[] targetType, final Object[] targetArguments) throws java.lang.Exception { Method method = null; Method[] methodsCache = null; if (objectCache.containsKey(targetObject)) { methodsCache = (Method[]) objectCache.get(targetObject); method = findMethod(methodsCache, methodName); if (method == null) { method = createMethodAndCacheIt(methodsCache, methodName, targetObject, targetType); } } else { method = createMethodAndCacheIt(methodsCache, methodName, targetObject, targetType); } execute(method, targetObject, targetArguments, null); }
private Node.Nodes doParse(String inFileName, Node parent, URL jarFileUrl) throws FileNotFoundException, JasperException, IOException { Node.Nodes parsedPage = null; isEncodingSpecifiedInProlog = false; isBomPresent = false; isDefaultPageEncoding = false; JarFile jarFile = getJarFile(jarFileUrl); String absFileName = resolveFileName(inFileName); String jspConfigPageEnc = getJspConfigPageEncoding(absFileName); // Figure out what type of JSP document and encoding type we are determineSyntaxAndEncoding(absFileName, jarFile, jspConfigPageEnc); if (parent != null) { compiler.getPageInfo().addDependant(absFileName); } if ((isXml && isEncodingSpecifiedInProlog) || isBomPresent) { if (jspConfigPageEnc != null && !jspConfigPageEnc.equals(sourceEnc) && (!jspConfigPageEnc.startsWith("UTF-16") || !sourceEnc.startsWith("UTF-16"))) { err.jspError("jsp.error.prolog_config_encoding_mismatch", sourceEnc, jspConfigPageEnc); } } if (isXml) { // JSP document (XML syntax) // InputStream for jspx page is created and properly closed in parsedPage = JspDocumentParser.parse(this, absFileName, jarFile, parent, isTagFile, directiveOnly, sourceEnc, jspConfigPageEnc, isEncodingSpecifiedInProlog, isBomPresent); } else { InputStreamReader inStreamReader = null; try { inStreamReader = JspUtil.getReader(absFileName, sourceEnc, jarFile, ctxt, err, skip); JspReader jspReader = new JspReader(ctxt, absFileName, sourceEnc, inStreamReader, err); parsedPage = Parser.parse(this, jspReader, parent, isTagFile, directiveOnly, jarFileUrl, sourceEnc, jspConfigPageEnc, isDefaultPageEncoding, isBomPresent); } finally { if (inStreamReader != null) { try { inStreamReader.close(); } catch (Exception any) { } } } } if (jarFile != null) { try { jarFile.close(); } catch (Throwable t) { } } baseDirStack.pop(); return parsedPage; }
protected boolean custom(Request request, Response response, ErrorPage errorPage) { if (container.getLogger().isDebugEnabled()) container.getLogger().debug("Processing " + errorPage); request.setPathInfo(errorPage.getLocation()); try { // Reset the response if possible (else IllegalStateException) //hres.reset(); Integer statusCodeObj = (Integer) request.getAttribute(Globals.STATUS_CODE_ATTR); int statusCode = statusCodeObj.intValue(); String message = (String) request.getAttribute(Globals.ERROR_MESSAGE_ATTR); response.reset(statusCode, message); ServletContext servletContext = request.getContext().getServletContext(); RequestDispatcher rd = servletContext.getRequestDispatcher(errorPage.getLocation()); rd.forward(request.getRequest(), response.getResponse()); response.setSuspended(false); return (true); } catch (Throwable t) { container.getLogger().error("Exception Processing " + errorPage, t); return (false); } }	protected static ErrorPage findErrorPage(Context context, Throwable exception) { if (exception == null) return (null); Class clazz = exception.getClass(); String name = clazz.getName(); while (!Object.class.equals(clazz)) { ErrorPage errorPage = context.findErrorPage(name); if (errorPage != null) return (errorPage); clazz = clazz.getSuperclass(); if (clazz == null) break; name = clazz.getName(); } return (null); }

protected boolean restoreRequest(Request request, Session session) throws IOException { SavedRequest saved = (SavedRequest) session.getNote(Constants.FORM_REQUEST_NOTE); session.removeNote(Constants.FORM_REQUEST_NOTE); session.removeNote(Constants.FORM_PRINCIPAL_NOTE); if (saved == null) return (false); request.clearCookies(); Iterator cookies = saved.getCookies(); while (cookies.hasNext()) { request.addCookie((Cookie) cookies.next()); } MimeHeaders rmh = request.getCoyoteRequest().getMimeHeaders(); rmh.recycle(); boolean cachable = "GET".equalsIgnoreCase(saved.getMethod()) || "HEAD".equalsIgnoreCase(saved.getMethod()); Iterator names = saved.getHeaderNames(); while (names.hasNext()) { String name = (String) names.next(); if (!("If-Modified-Since".equalsIgnoreCase(name) || (cachable && "If-None-Match".equalsIgnoreCase(name)))) { Iterator values = saved.getHeaderValues(name); while (values.hasNext()) { rmh.addValue(name).setString((String) values.next()); } } } request.clearLocales(); Iterator locales = saved.getLocales(); while (locales.hasNext()) { request.addLocale((Locale) locales.next()); } request.getCoyoteRequest().getParameters().recycle(); if ("POST".equalsIgnoreCase(saved.getMethod())) { ByteChunk body = saved.getBody(); if (body != null) { request.getCoyoteRequest().action(ActionCode.ACTION_REQ_SET_BODY_REPLAY, body); MessageBytes contentType = MessageBytes.newInstance(); String savedContentType = saved.getContentType(); if (savedContentType == null) { savedContentType = "application/x-www-form-urlencoded"; } contentType.setString(savedContentType); request.getCoyoteRequest().setContentType(contentType); } } request.getCoyoteRequest().method().setString(saved.getMethod()); request.getCoyoteRequest().queryString().setString(saved.getQueryString()); request.getCoyoteRequest().requestURI().setString(saved.getRequestURI()); return (true); }


protected void postConstruct(Object instance, Class<?> clazz) throws IllegalAccessException, InvocationTargetException { Class<?> superClass = clazz.getSuperclass(); if (superClass != Object.class) { postConstruct(instance, superClass); } Method[] methods = clazz.getDeclaredMethods(); Method postConstruct = null; for (Method method : methods) { if (method.isAnnotationPresent(PostConstruct.class)) { if ((postConstruct != null) || (method.getParameterTypes().length != 0) || (Modifier.isStatic(method.getModifiers())) || (method.getExceptionTypes().length > 0) || (!method.getReturnType().getName().equals("void"))) { throw new IllegalArgumentException("Invalid PostConstruct annotation"); } postConstruct = method; } } if (postConstruct != null) { boolean accessibility = postConstruct.isAccessible(); postConstruct.setAccessible(true); postConstruct.invoke(instance); postConstruct.setAccessible(accessibility); } }	Class<?> loadClass(String className, ClassLoader classLoader) throws ClassNotFoundException { if (className.startsWith("org.apache.catalina")) { return containerClassLoader.loadClass(className); } try { Class<?> clazz = containerClassLoader.loadClass(className); if (ContainerServlet.class.isAssignableFrom(clazz)) { return clazz; } } catch (Throwable t) { //ignore } return classLoader.loadClass(className); }	public void destroyInstance(Object instance) throws IllegalAccessException, InvocationTargetException { if (!ignoreAnnotations) { preDestroy(instance, instance.getClass()); } }
public String getETag() { String result = null; if (attributes != null) { Attribute attribute = attributes.get(ETAG); if (attribute != null) { try { result = attribute.get().toString(); } catch (NamingException e) { ; } } } if (result == null) { if (strongETag != null) { result = strongETag; } else { if (weakETag == null) { long contentLength = getContentLength(); long lastModified = getLastModified(); if ((contentLength >= 0) || (lastModified >= 0)) { weakETag = "W/\"" + contentLength + "-" + lastModified + "\""; } } result = weakETag; } } return result; }	public void setResourceType(String resourceType) { collection = resourceType.equals(COLLECTION_TYPE); if (attributes != null) attributes.put(TYPE, resourceType); }
protected boolean postParseRequest(org.apache.coyote.Request req, Request request, org.apache.coyote.Response res, Response response) throws Exception { if (!req.scheme().isNull()) { request.setSecure(req.scheme().equals("https")); } else { // use connector scheme and secure configuration, (defaults to req.scheme().setString(connector.getScheme()); request.setSecure(connector.getSecure()); } // FIXME: the code below doesnt belongs to here, // this is only have sense // in Http11, not in ajp13.. // At this point the Host header has been processed. String proxyName = connector.getProxyName(); int proxyPort = connector.getProxyPort(); if (proxyPort != 0) { req.setServerPort(proxyPort); } if (proxyName != null) { req.serverName().setString(proxyName); } parseSessionId(req, request); MessageBytes decodedURI = req.decodedURI(); decodedURI.duplicate(req.requestURI()); if (decodedURI.getType() == MessageBytes.T_BYTES) { ByteChunk uriBB = decodedURI.getByteChunk(); int semicolon = uriBB.indexOf(';', 0); if (semicolon > 0) { decodedURI.setBytes(uriBB.getBuffer(), uriBB.getStart(), semicolon); } try { req.getURLDecoder().convert(decodedURI, false); } catch (IOException ioe) { res.setStatus(400); res.setMessage("Invalid URI: " + ioe.getMessage()); return false; } if (!normalize(req.decodedURI())) { res.setStatus(400); res.setMessage("Invalid URI"); return false; } convertURI(decodedURI, request); if (!checkNormalize(req.decodedURI())) { res.setStatus(400); res.setMessage("Invalid URI character encoding"); return false; } } else { // The URL is chars or String, and has been sent using an in-memory // protocol handler, we have to assume the URL has been properly decodedURI.toChars(); CharChunk uriCC = decodedURI.getCharChunk(); int semicolon = uriCC.indexOf(';'); if (semicolon > 0) { decodedURI.setChars(uriCC.getBuffer(), uriCC.getStart(), semicolon); } } String principal = req.getRemoteUser().toString(); if (principal != null) { request.setUserPrincipal(new CoyotePrincipal(principal)); } String authtype = req.getAuthType().toString(); if (authtype != null) { request.setAuthType(authtype); } MessageBytes serverName; if (connector.getUseIPVHosts()) { serverName = req.localName(); if (serverName.isNull()) { res.action(ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE, null); } } else { serverName = req.serverName(); } connector.getMapper().map(serverName, decodedURI, request.getMappingData()); request.setContext((Context) request.getMappingData().context); request.setWrapper((Wrapper) request.getMappingData().wrapper); if (!connector.getAllowTrace() && req.method().equalsIgnoreCase("TRACE")) { Wrapper wrapper = request.getWrapper(); String header = null; if (wrapper != null) { String[] methods = wrapper.getServletMethods(); if (methods != null) { for (int i = 0; i < methods.length; i++) { if ("TRACE".equals(methods[i])) { continue; } if (header == null) { header = methods[i]; } else { header += ", " + methods[i]; } } } } res.setStatus(405); res.addHeader("Allow", header); res.setMessage("TRACE method is not allowed"); return false; } MessageBytes redirectPathMB = request.getMappingData().redirectPath; if (!redirectPathMB.isNull()) { String redirectPath = urlEncoder.encode(redirectPathMB.toString()); String query = request.getQueryString(); if (request.isRequestedSessionIdFromURL()) { // This is not optimal, but as this is not very common, it redirectPath = redirectPath + ";" + Globals.SESSION_PARAMETER_NAME + "=" + request.getRequestedSessionId(); } if (query != null) { // This is not optimal, but as this is not very common, it redirectPath = redirectPath + "?" + query; } response.sendRedirect(redirectPath); return false; } parseSessionCookiesId(req, request); return true; }

private void addInjectionTarget(Injectable resource, Map<String, Map<String, String>> injectionMap) { List<InjectionTarget> injectionTargets = resource.getInjectionTargets(); if (injectionTargets != null && injectionTargets.size() > 0) { String jndiName = resource.getName(); for (InjectionTarget injectionTarget : injectionTargets) { String clazz = injectionTarget.getTargetClass(); Map<String, String> injections = injectionMap.get(clazz); if (injections == null) { injections = new HashMap<String, String>(); injectionMap.put(clazz, injections); } injections.put(injectionTarget.getTargetName(), jndiName); } } }	private void processCache(File tldCache) throws IOException { try { FileInputStream in = new FileInputStream(tldCache); ObjectInputStream ois = new ObjectInputStream(in); String[] list = (String[]) ois.readObject(); if (log.isDebugEnabled()) log.debug("Reusing tldCache " + tldCache + " " + list.length); for (int i = 0; list != null && i < list.length; i++) { context.addApplicationListener(list[i]); } ois.close(); } catch (ClassNotFoundException ex) { ex.printStackTrace(); } }	private Map<String, File> getJarPaths() { HashMap<String, File> jarPathMap = null; ClassLoader webappLoader = Thread.currentThread().getContextClassLoader(); ClassLoader loader = webappLoader; while (loader != null) { if (loader instanceof URLClassLoader) { URL[] urls = ((URLClassLoader) loader).getURLs(); for (int i = 0; i < urls.length; i++) { if (!"file".equals(urls[i].getProtocol())) { continue; } File file = null; try { file = new File(urls[i].toURI()); } catch (URISyntaxException e) { file = new File(urls[i].getFile()); } try { file = file.getCanonicalFile(); } catch (IOException e) { // Ignore } if (!file.exists()) { continue; } String path = file.getAbsolutePath(); if (!path.endsWith(".jar")) { continue; } if (loader == webappLoader || noTldJars == null || !noTldJars.contains(file.getName())) { if (jarPathMap == null) { jarPathMap = new HashMap<String, File>(); jarPathMap.put(path, file); } else if (!jarPathMap.containsKey(path)) { jarPathMap.put(path, file); } } } } loader = loader.getParent(); } return jarPathMap; }	private void tldScanStream(InputSource resourceStream) throws Exception { if (tldDigester == null) { tldDigester = createTldDigester(); } synchronized (tldDigester) { try { tldDigester.push(this); tldDigester.parse(resourceStream); } finally { tldDigester.reset(); } } }	private Map<String, Map<String, String>> buildInjectionMap(NamingResources namingResources) { Map<String, Map<String, String>> injectionMap = new HashMap<String, Map<String, String>>(); for (Injectable resource : namingResources.findLocalEjbs()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findEjbs()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findEnvironments()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findMessageDestinationRefs()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findResourceEnvRefs()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findResources()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findServices()) { addInjectionTarget(resource, injectionMap); } return injectionMap; }	public void init() throws Exception { if (this.getParent() == null) { ObjectName parentName = getParentName(); if (!mserver.isRegistered(parentName)) { if (log.isDebugEnabled()) log.debug("No host, creating one " + parentName); StandardHost host = new StandardHost(); host.setName(hostName); host.setAutoDeploy(false); Registry.getRegistry(null, null).registerComponent(host, parentName, null); // We could do it the hard way... //mserver.invoke(parentName, "init", new Object[] {}, new String[] {} ); host.init(); } LifecycleListener config = null; try { String configClassName = null; try { configClassName = String.valueOf(mserver.getAttribute(parentName, "configClass")); } catch (AttributeNotFoundException e) { // Ignore, it's normal a host may not have this optional attribute } if (configClassName != null) { Class<?> clazz = Class.forName(configClassName); config = (LifecycleListener) clazz.newInstance(); } else { config = new ContextConfig(); } } catch (Exception e) { log.warn("Error creating ContextConfig for " + parentName, e); throw e; } this.addLifecycleListener(config); if (log.isDebugEnabled()) { log.debug("AddChild " + parentName + " " + this); } try { mserver.invoke(parentName, "addChild", new Object[] { this }, new String[] { "org.apache.catalina.Container" }); } catch (Exception e) { destroy(); throw e; } if (initialized) { return; } } super.init(); lifecycle.fireLifecycleEvent(INIT_EVENT, null); if (this.getObjectName() != null) { Notification notification = new Notification("j2ee.state.starting", this.getObjectName(), sequenceNumber++); broadcaster.sendNotification(notification); } }
public File getFile() { return file; }	public boolean writeMessage(FileMessage msg) throws IllegalArgumentException, IOException { if (!openForWrite) throw new IllegalArgumentException("Can't write message, this factory is reading."); if (log.isDebugEnabled()) log.debug("Message " + msg + " data " + msg.getData() + " data length " + msg.getDataLength() + " out " + out); if (out != null) { out.write(msg.getData(), 0, msg.getDataLength()); nrOfMessagesProcessed++; out.flush(); if (msg.getMessageNumber() == msg.getTotalNrOfMsgs()) { out.close(); cleanup(); return true; } //end if } else { if (log.isWarnEnabled()) log.warn("Receive Message again -- Sender ActTimeout to short [ path: " + msg.getContextPath() + " war: " + msg.getFileName() + " data: " + msg.getData() + " data length: " + msg.getDataLength() + " ]"); } return false; }	public void cleanup() { if (in != null) try { in.close(); } catch (Exception ignore) { } if (out != null) try { out.close(); } catch (Exception ignore) { } in = null; out = null; size = 0; closed = true; data = null; nrOfMessagesProcessed = 0; totalNrOfMessages = 0; }	public void start() throws Exception { if (started) return; getCluster().addClusterListener(this); if (watchEnabled) { watcher = new WarWatcher(this, new File(getWatchDir())); if (log.isInfoEnabled()) log.info("Cluster deployment is watching " + getWatchDir() + " for changes."); } Object parent = getCluster().getContainer(); Engine engine = null; String hostname = null; if (parent instanceof Host) { host = (Host) parent; engine = (Engine) host.getParent(); hostname = host.getName(); } else { engine = (Engine) parent; hostname = engine.getDefaultHost(); } try { oname = new ObjectName(engine.getName() + ":type=Deployer,host=" + hostname); } catch (Exception e) { log.error("Can't construct MBean object name" + e); } configBase = new File(System.getProperty("catalina.base"), "conf"); if (engine != null) { configBase = new File(configBase, engine.getName()); } else if (host != null) { configBase = new File(configBase, host.getName()); } mBeanServer = Registry.getRegistry(null, null).getMBeanServer(); started = true; count = 0; if (log.isInfoEnabled()) log.info("Cluster FarmWarDeployer started."); }
public void appendHead(Response res) throws IOException { if (log.isDebugEnabled()) log.debug("COMMIT sending headers " + res + " " + res.getMimeHeaders()); C2BConverter c2b = mc.getConverter(); outputMsg.reset(); outputMsg.appendByte(AjpConstants.JK_AJP13_SEND_HEADERS); outputMsg.appendInt(res.getStatus()); String message = null; if (org.apache.coyote.Constants.USE_CUSTOM_STATUS_MSG_IN_HEADER) { message = res.getMessage(); } if (message == null) { message = HttpMessages.getMessage(res.getStatus()); } else { message = message.replace('\n', ' ').replace('\r', ' '); } tempMB.setString(message); c2b.convert(tempMB); outputMsg.appendBytes(tempMB); MimeHeaders headers = res.getMimeHeaders(); String contentType = res.getContentType(); if (contentType != null) { headers.setValue("Content-Type").setString(contentType); } String contentLanguage = res.getContentLanguage(); if (contentLanguage != null) { headers.setValue("Content-Language").setString(contentLanguage); } long contentLength = res.getContentLengthLong(); if (contentLength >= 0) { headers.setValue("Content-Length").setLong(contentLength); } int numHeaders = headers.size(); outputMsg.appendInt(numHeaders); for (int i = 0; i < numHeaders; i++) { MessageBytes hN = headers.getName(i); // no header to sc conversion - there's little benefit c2b.convert(hN); outputMsg.appendBytes(hN); MessageBytes hV = headers.getValue(i); c2b.convert(hV); outputMsg.appendBytes(hV); } mc.getSource().send(outputMsg, mc); }
protected void serveResource(HttpServletRequest request, HttpServletResponse response, boolean content) throws IOException, ServletException { String path = getRelativePath(request); if (debug > 0) { if (content) log("DefaultServlet.serveResource: Serving resource '" + path + "' headers and data"); else log("DefaultServlet.serveResource: Serving resource '" + path + "' headers only"); } CacheEntry cacheEntry = resources.lookupCache(path); if (!cacheEntry.exists) { // Check if we're included so we can return the appropriate String requestUri = (String) request.getAttribute(Globals.INCLUDE_REQUEST_URI_ATTR); if (requestUri == null) { requestUri = request.getRequestURI(); } else { // We're included, and the response.sendError() below is going // to be ignored by the resource that is including us. // Therefore, the only way we can let the including resource response.getWriter().write(sm.getString("defaultServlet.missingResource", requestUri)); } response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri); return; } if (cacheEntry.context == null) { if (path.endsWith("/") || (path.endsWith("\\"))) { // Check if we're included so we can return the appropriate String requestUri = (String) request.getAttribute(Globals.INCLUDE_REQUEST_URI_ATTR); if (requestUri == null) { requestUri = request.getRequestURI(); } response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri); return; } } if (cacheEntry.context == null) { boolean included = (request.getAttribute(Globals.INCLUDE_CONTEXT_PATH_ATTR) != null); if (!included && !checkIfHeaders(request, response, cacheEntry.attributes)) { return; } } String contentType = cacheEntry.attributes.getMimeType(); if (contentType == null) { contentType = getServletContext().getMimeType(cacheEntry.name); cacheEntry.attributes.setMimeType(contentType); } ArrayList<Range> ranges = null; long contentLength = -1L; if (cacheEntry.context != null) { if (!listings) { response.sendError(HttpServletResponse.SC_NOT_FOUND, request.getRequestURI()); return; } contentType = "text/html;charset=UTF-8"; } else { ranges = parseRange(request, response, cacheEntry.attributes); response.setHeader("ETag", getETag(cacheEntry.attributes)); response.setHeader("Last-Modified", cacheEntry.attributes.getLastModifiedHttp()); contentLength = cacheEntry.attributes.getContentLength(); if (contentLength == 0L) { content = false; } } ServletOutputStream ostream = null; PrintWriter writer = null; if (content) { try { ostream = response.getOutputStream(); } catch (IllegalStateException e) { if ((contentType == null) || (contentType.startsWith("text")) || (contentType.endsWith("xml"))) { writer = response.getWriter(); } else { throw e; } } } if ((cacheEntry.context != null) || (((ranges == null) || (ranges.isEmpty())) && (request.getHeader("Range") == null)) || (ranges == FULL)) { if (contentType != null) { if (debug > 0) log("DefaultServlet.serveFile: contentType='" + contentType + "'"); response.setContentType(contentType); } if ((cacheEntry.resource != null) && (contentLength >= 0)) { if (debug > 0) log("DefaultServlet.serveFile: contentLength=" + contentLength); if (contentLength < Integer.MAX_VALUE) { response.setContentLength((int) contentLength); } else { response.setHeader("content-length", "" + contentLength); } } InputStream renderResult = null; if (cacheEntry.context != null) { if (content) { renderResult = render(request.getContextPath(), cacheEntry); } } if (content) { try { response.setBufferSize(output); } catch (IllegalStateException e) { // Silent catch } if (ostream != null) { if (!checkSendfile(request, response, cacheEntry, contentLength, null)) copy(cacheEntry, renderResult, ostream); } else { copy(cacheEntry, renderResult, writer); } } } else { if ((ranges == null) || (ranges.isEmpty())) return; response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT); if (ranges.size() == 1) { Range range = ranges.get(0); response.addHeader("Content-Range", "bytes " + range.start + "-" + range.end + "/" + range.length); long length = range.end - range.start + 1; if (length < Integer.MAX_VALUE) { response.setContentLength((int) length); } else { response.setHeader("content-length", "" + length); } if (contentType != null) { if (debug > 0) log("DefaultServlet.serveFile: contentType='" + contentType + "'"); response.setContentType(contentType); } if (content) { try { response.setBufferSize(output); } catch (IllegalStateException e) { // Silent catch } if (ostream != null) { if (!checkSendfile(request, response, cacheEntry, range.end - range.start + 1, range)) copy(cacheEntry, ostream, range); } else { copy(cacheEntry, writer, range); } } } else { response.setContentType("multipart/byteranges; boundary=" + mimeSeparation); if (content) { try { response.setBufferSize(output); } catch (IllegalStateException e) { // Silent catch } if (ostream != null) { copy(cacheEntry, ostream, ranges.iterator(), contentType); } else { copy(cacheEntry, writer, ranges.iterator(), contentType); } } } } }	public void init() throws ServletException { if (getServletConfig().getInitParameter("debug") != null) debug = Integer.parseInt(getServletConfig().getInitParameter("debug")); if (getServletConfig().getInitParameter("input") != null) input = Integer.parseInt(getServletConfig().getInitParameter("input")); if (getServletConfig().getInitParameter("output") != null) output = Integer.parseInt(getServletConfig().getInitParameter("output")); listings = Boolean.parseBoolean(getServletConfig().getInitParameter("listings")); if (getServletConfig().getInitParameter("readonly") != null) readOnly = Boolean.parseBoolean(getServletConfig().getInitParameter("readonly")); if (getServletConfig().getInitParameter("sendfileSize") != null) sendfileSize = Integer.parseInt(getServletConfig().getInitParameter("sendfileSize")) * 1024; fileEncoding = getServletConfig().getInitParameter("fileEncoding"); globalXsltFile = getServletConfig().getInitParameter("globalXsltFile"); localXsltFile = getServletConfig().getInitParameter("localXsltFile"); readmeFile = getServletConfig().getInitParameter("readmeFile"); if (input < 256) input = 256; if (output < 256) output = 256; if (debug > 0) { log("DefaultServlet.init: input buffer size=" + input + ", output buffer size=" + output); } resources = (ProxyDirContext) getServletContext().getAttribute(Globals.RESOURCES_ATTR); if (resources == null) { try { resources = (ProxyDirContext) new InitialContext().lookup(RESOURCES_JNDI_NAME); } catch (NamingException e) { throw new ServletException("No resources", e); } } if (resources == null) { throw new UnavailableException("No resources"); } }
private void doInclude(ServletRequest request, ServletResponse response) throws ServletException, IOException { State state = new State(request, response, true); if (Globals.STRICT_SERVLET_COMPLIANCE) { checkSameObjects(request, response); } wrapResponse(state); if (name != null) { ApplicationHttpRequest wrequest = (ApplicationHttpRequest) wrapRequest(state); wrequest.setAttribute(Globals.NAMED_DISPATCHER_ATTR, name); if (servletPath != null) wrequest.setServletPath(servletPath); wrequest.setAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR, Integer.valueOf(ApplicationFilterFactory.INCLUDE)); wrequest.setAttribute(ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, servletPath); invoke(state.outerRequest, state.outerResponse, state); } else { ApplicationHttpRequest wrequest = (ApplicationHttpRequest) wrapRequest(state); String contextPath = context.getPath(); if (requestURI != null) wrequest.setAttribute(Globals.INCLUDE_REQUEST_URI_ATTR, requestURI); if (contextPath != null) wrequest.setAttribute(Globals.INCLUDE_CONTEXT_PATH_ATTR, contextPath); if (servletPath != null) wrequest.setAttribute(Globals.INCLUDE_SERVLET_PATH_ATTR, servletPath); if (pathInfo != null) wrequest.setAttribute(Globals.INCLUDE_PATH_INFO_ATTR, pathInfo); if (queryString != null) { wrequest.setAttribute(Globals.INCLUDE_QUERY_STRING_ATTR, queryString); wrequest.setQueryParams(queryString); } wrequest.setAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR, Integer.valueOf(ApplicationFilterFactory.INCLUDE)); wrequest.setAttribute(ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, servletPath); invoke(state.outerRequest, state.outerResponse, state); } }	private void processRequest(ServletRequest request, ServletResponse response, State state) throws IOException, ServletException { Integer disInt = (Integer) request.getAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR); if (disInt != null) { if (disInt.intValue() != ApplicationFilterFactory.ERROR) { state.outerRequest.setAttribute(ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, servletPath); state.outerRequest.setAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR, Integer.valueOf(ApplicationFilterFactory.FORWARD)); invoke(state.outerRequest, response, state); } else { invoke(state.outerRequest, response, state); } } }
protected AccessLogElement[] createLogElements() { List<AccessLogElement> list = new ArrayList<AccessLogElement>(); boolean replace = false; StringBuffer buf = new StringBuffer(); for (int i = 0; i < pattern.length(); i++) { char ch = pattern.charAt(i); if (replace) { if ('{' == ch) { StringBuffer name = new StringBuffer(); int j = i + 1; for (; j < pattern.length() && '}' != pattern.charAt(j); j++) { name.append(pattern.charAt(j)); } if (j + 1 < pattern.length()) { j++; list.add(createAccessLogElement(name.toString(), pattern.charAt(j))); i = j; /* Since we walked more than one character */ } else { // D'oh - end of string - pretend we never did this list.add(createAccessLogElement(ch)); } } else { list.add(createAccessLogElement(ch)); } replace = false; } else if (ch == '%') { replace = true; list.add(new StringElement(buf.toString())); buf = new StringBuffer(); } else { buf.append(ch); } } if (buf.length() > 0) { list.add(new StringElement(buf.toString())); } return (AccessLogElement[]) list.toArray(new AccessLogElement[0]); }
public void finalize() { try { disconnect(); } catch (Exception ignore) { } }

public boolean isFulfilled() { if (requiredExtensions == null) { return false; } Iterator it = requiredExtensions.iterator(); while (it.hasNext()) { Extension ext = (Extension) it.next(); if (!ext.isFulfilled()) return false; } return true; }
public void include(String relativeUrlPath, boolean flush) throws ServletException, IOException { include(relativeUrlPath, false); }
public final void Function() throws ParseException { AstFunction jjtn000 = new AstFunction(JJTFUNCTION); boolean jjtc000 = true; jjtree.openNodeScope(jjtn000); Token t0 = null; Token t1 = null; try { switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) { case IDENTIFIER: t0 = jj_consume_token(IDENTIFIER); jj_consume_token(COLON); break; default: jj_la1[30] = jj_gen; ; } t1 = jj_consume_token(IDENTIFIER); if (t0 != null) { jjtn000.setPrefix(t0.image.substring(0, t0.image.length() - 1)); jjtn000.setLocalName(t1.image); } else { jjtn000.setLocalName(t1.image); } jj_consume_token(LPAREN); switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) { case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case STRING_LITERAL: case TRUE: case FALSE: case NULL: case LPAREN: case NOT0: case NOT1: case EMPTY: case MINUS: case IDENTIFIER: Expression(); label_10: while (true) { switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) { case COMMA: ; break; default: jj_la1[31] = jj_gen; break label_10; } jj_consume_token(COMMA); Expression(); } break; default: jj_la1[32] = jj_gen; ; } jj_consume_token(RPAREN); } catch (Throwable jjte000) { if (jjtc000) { jjtree.clearNodeScope(jjtn000); jjtc000 = false; } else { jjtree.popNode(); } if (jjte000 instanceof RuntimeException) { { if (true) throw (RuntimeException) jjte000; } } if (jjte000 instanceof ParseException) { { if (true) throw (ParseException) jjte000; } } { if (true) throw (Error) jjte000; } } finally { if (jjtc000) { jjtree.closeNodeScope(jjtn000, true); } } }
private void addToParent(Node parent) { if (parent != null) { this.parent = parent; Nodes parentBody = parent.getBody(); if (parentBody == null) { parentBody = new Nodes(); parent.setBody(parentBody); } parentBody.add(this); } }	public Root getParentRoot() { return parentRoot; }	public String getTemporaryVariableName() { if (temporaryVariableName == null) { temporaryVariableName = JspUtil.nextTemporaryVariableName(); } return temporaryVariableName; }	public String getTemporaryVariableName() { return JspUtil.nextTemporaryVariableName(); }	public static void validateExpressions(Mark where, String expressions, Class expectedType, FunctionMapper functionMapper, ErrorDispatcher err) throws JasperException { // try { // // JspUtil.expressionEvaluator.parseExpression( expressions, // expectedType, functionMapper ); // } // catch( ELParseException e ) { // err.jspError(where, "jsp.error.invalid.expression", expressions, // e.toString() ); // } // catch( ELException e ) { // err.jspError(where, "jsp.error.invalid.expression", expressions, // e.toString() ); // } }	protected String[] generateJava() throws Exception { String[] smapStr = null; long t1, t2, t3, t4; t1 = t2 = t3 = t4 = 0; if (log.isDebugEnabled()) { t1 = System.currentTimeMillis(); } pageInfo = new PageInfo(new BeanRepository(ctxt.getClassLoader(), errDispatcher), ctxt.getJspFile()); JspConfig jspConfig = options.getJspConfig(); JspConfig.JspProperty jspProperty = jspConfig.findJspProperty(ctxt.getJspFile()); if (jspProperty.isELIgnored() != null) { pageInfo.setELIgnored(JspUtil.booleanValue(jspProperty.isELIgnored())); } if (jspProperty.isScriptingInvalid() != null) { pageInfo.setScriptingInvalid(JspUtil.booleanValue(jspProperty.isScriptingInvalid())); } if (jspProperty.getIncludePrelude() != null) { pageInfo.setIncludePrelude(jspProperty.getIncludePrelude()); } if (jspProperty.getIncludeCoda() != null) { pageInfo.setIncludeCoda(jspProperty.getIncludeCoda()); } if (jspProperty.isDeferedSyntaxAllowedAsLiteral() != null) { pageInfo.setDeferredSyntaxAllowedAsLiteral(JspUtil.booleanValue(jspProperty.isDeferedSyntaxAllowedAsLiteral())); } if (jspProperty.isTrimDirectiveWhitespaces() != null) { pageInfo.setTrimDirectiveWhitespaces(JspUtil.booleanValue(jspProperty.isTrimDirectiveWhitespaces())); } ctxt.checkOutputDir(); String javaFileName = ctxt.getServletJavaFileName(); ServletWriter writer = null; try { JspUtil.resetTemporaryVariableName(); ParserController parserCtl = new ParserController(ctxt, this); pageNodes = parserCtl.parse(ctxt.getJspFile()); if (ctxt.isPrototypeMode()) { writer = setupContextWriter(javaFileName); Generator.generate(writer, this, pageNodes); writer.close(); writer = null; return null; } Validator.validate(this, pageNodes); if (log.isDebugEnabled()) { t2 = System.currentTimeMillis(); } Collector.collect(this, pageNodes); // Compile (if necessary) and load the tag files referenced in tfp = new TagFileProcessor(); tfp.loadTagFiles(this, pageNodes); if (log.isDebugEnabled()) { t3 = System.currentTimeMillis(); } ScriptingVariabler.set(pageNodes, errDispatcher); TagPluginManager tagPluginManager = options.getTagPluginManager(); tagPluginManager.apply(pageNodes, errDispatcher, pageInfo); TextOptimizer.concatenate(this, pageNodes); ELFunctionMapper.map(this, pageNodes); writer = setupContextWriter(javaFileName); Generator.generate(writer, this, pageNodes); writer.close(); writer = null; // The writer is only used during the compile, dereference // it in the JspCompilationContext when done to allow it ctxt.setWriter(null); if (log.isDebugEnabled()) { t4 = System.currentTimeMillis(); log.debug("Generated " + javaFileName + " total=" + (t4 - t1) + " generate=" + (t4 - t3) + " validate=" + (t2 - t1)); } } catch (Exception e) { if (writer != null) { try { writer.close(); writer = null; } catch (Exception e1) { // do nothing } } new File(javaFileName).delete(); throw e; } finally { if (writer != null) { try { writer.close(); } catch (Exception e2) { // do nothing } } } if (!options.isSmapSuppressed()) { smapStr = SmapUtil.generateSmap(ctxt, pageNodes); } // If any proto type .java and .class files was generated, // the prototype .java may have been replaced by the current // compilation (if the tag file is self referencing), but the // .class file need to be removed, to make sure that javac would tfp.removeProtoTypeFiles(ctxt.getClassFileName()); return smapStr; }
public void setMaxKeepAliveRequests(int mkar) { maxKeepAliveRequests = mkar; }
public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.INIT_EVENT.equals(event.getType())) { aprInitialized = init(); if (aprInitialized) { try { initializeSSL(); } catch (Throwable t) { if (!log.isDebugEnabled()) { log.info(sm.getString("aprListener.sslInit")); } else { log.debug(sm.getString("aprListener.sslInit")); } } } } else if (Lifecycle.AFTER_STOP_EVENT.equals(event.getType())) { if (!aprInitialized) { return; } try { terminateAPR(); } catch (Throwable t) { if (!log.isDebugEnabled()) { log.info(sm.getString("aprListener.aprDestroy")); } else { log.debug(sm.getString("aprListener.aprDestroy"), t); } } } }
public void init() throws Exception { if (initialized) return; rootPool = Pool.create(0); serverSockPool = Pool.create(rootPool); String addressStr = null; if (address == null) { addressStr = null; } else { addressStr = address.getHostAddress(); } int family = Socket.APR_INET; if (Library.APR_HAVE_IPV6) { if (addressStr == null) { if (!OS.IS_BSD && !OS.IS_WIN32 && !OS.IS_WIN64) family = Socket.APR_UNSPEC; } else if (addressStr.indexOf(':') >= 0) { family = Socket.APR_UNSPEC; } } long inetAddress = Address.info(addressStr, family, port, 0, rootPool); serverSock = Socket.create(family, Socket.SOCK_STREAM, Socket.APR_PROTO_TCP, rootPool); if (OS.IS_UNIX) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } Socket.optSet(serverSock, Socket.APR_SO_KEEPALIVE, 1); int ret = Socket.bind(serverSock, inetAddress); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.bind", "" + ret, Error.strerror(ret))); } ret = Socket.listen(serverSock, backlog); if (ret != 0) { throw new Exception(sm.getString("endpoint.init.listen", "" + ret, Error.strerror(ret))); } if (OS.IS_WIN32 || OS.IS_WIN64) { Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1); } if (useSendfile && !Library.APR_HAS_SENDFILE) { useSendfile = false; } if (acceptorThreadCount == 0) { acceptorThreadCount = 1; } if (pollerThreadCount == 0) { if ((OS.IS_WIN32 || OS.IS_WIN64) && (pollerSize > 1024)) { pollerThreadCount = pollerSize / 1024; pollerSize = pollerSize - (pollerSize % 1024); } else { pollerThreadCount = 1; } } if (sendfileThreadCount == 0) { if ((OS.IS_WIN32 || OS.IS_WIN64) && (sendfileSize > 1024)) { sendfileThreadCount = sendfileSize / 1024; sendfileSize = sendfileSize - (sendfileSize % 1024); } else { // No explicit poller size limitation sendfileThreadCount = 1; } } if (Socket.optSet(serverSock, Socket.APR_TCP_DEFER_ACCEPT, 1) == Status.APR_ENOTIMPL) { deferAccept = false; } if (SSLEnabled) { int value = SSL.SSL_PROTOCOL_ALL; if ("SSLv2".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV2; } else if ("SSLv3".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV3; } else if ("TLSv1".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_TLSV1; } else if ("SSLv2+SSLv3".equalsIgnoreCase(SSLProtocol)) { value = SSL.SSL_PROTOCOL_SSLV2 | SSL.SSL_PROTOCOL_SSLV3; } sslContext = SSLContext.make(rootPool, value, SSL.SSL_MODE_SERVER); SSLContext.setCipherSuite(sslContext, SSLCipherSuite); SSLContext.setCertificate(sslContext, SSLCertificateFile, SSLCertificateKeyFile, SSLPassword, SSL.SSL_AIDX_RSA); SSLContext.setCertificateChainFile(sslContext, SSLCertificateChainFile, false); SSLContext.setCACertificate(sslContext, SSLCACertificateFile, SSLCACertificatePath); SSLContext.setCARevocation(sslContext, SSLCARevocationFile, SSLCARevocationPath); value = SSL.SSL_CVERIFY_NONE; if ("optional".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL; } else if ("require".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_REQUIRE; } else if ("optionalNoCA".equalsIgnoreCase(SSLVerifyClient)) { value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA; } SSLContext.setVerify(sslContext, value, SSLVerifyDepth); useSendfile = false; } initialized = true; }
protected String replace(String str) { String result = str; int pos_start = result.indexOf("${"); if (pos_start != -1) { int pos_end = result.indexOf('}'); if (pos_end != -1) { String propName = result.substring(pos_start + 2, pos_end); String replacement = System.getProperty(propName); if (replacement != null) { if (pos_start > 0) { result = result.substring(0, pos_start) + replacement + replace(result.substring(pos_end + 1)); } else { result = replacement + replace(result.substring(pos_end + 1)); } } } } return result; }	/** * Retrieve the configuration associated with the specified classloader. If * it does not exist, it will be created. * * @param classLoader The classloader for which we will retrieve or build the * configuration */ protected ClassLoaderLogInfo getClassLoaderInfo(ClassLoader classLoader) { if (classLoader == null) { classLoader = ClassLoader.getSystemClassLoader(); } ClassLoaderLogInfo info = (ClassLoaderLogInfo) classLoaderLoggers .get(classLoader); if (info == null) { final ClassLoader classLoaderParam = classLoader; AccessController.doPrivileged(new PrivilegedAction() { } } }	protected void readConfiguration(InputStream is, ClassLoader classLoader) throws IOException { ClassLoaderLogInfo info = (ClassLoaderLogInfo) classLoaderLoggers.get(classLoader); try { info.props.load(is); } catch (IOException e) { System.err.println("Configuration error"); e.printStackTrace(); } finally { try { is.close(); } catch (Throwable t) { } } String rootHandlers = info.props.getProperty(".handlers"); String handlers = info.props.getProperty("handlers"); Logger localRootLogger = info.rootNode.logger; if (handlers != null) { StringTokenizer tok = new StringTokenizer(handlers, ","); while (tok.hasMoreTokens()) { String handlerName = (tok.nextToken().trim()); String handlerClassName = handlerName; String prefix = ""; if (handlerClassName.length() <= 0) { continue; } if (Character.isDigit(handlerClassName.charAt(0))) { int pos = handlerClassName.indexOf('.'); if (pos >= 0) { prefix = handlerClassName.substring(0, pos + 1); handlerClassName = handlerClassName.substring(pos + 1); } } try { this.prefix.set(prefix); Handler handler = (Handler) classLoader.loadClass(handlerClassName).newInstance(); // The specification strongly implies all configuration should be done // during the creation of the handler object. this.prefix.set(null); info.handlers.put(handlerName, handler); if (rootHandlers == null) { localRootLogger.addHandler(handler); } } catch (Exception e) { System.err.println("Handler error"); e.printStackTrace(); } } } }	protected static void doSetParentLogger(final Logger logger, final Logger parent) { AccessController.doPrivileged(new PrivilegedAction() { public Object run() { logger.setParent(parent); return null; } }); }	public String getProperty(String name) { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); String prefix = (String) this.prefix.get(); if (prefix != null) { name = prefix + name; } ClassLoaderLogInfo info = getClassLoaderInfo(classLoader); String result = info.props.getProperty(name); if ((result == null) && (info.props.isEmpty())) { ClassLoader current = classLoader.getParent(); while (current != null) { info = (ClassLoaderLogInfo) classLoaderLoggers.get(current); if (info != null) { result = info.props.getProperty(name); if ((result != null) || (!info.props.isEmpty())) { break; } } current = current.getParent(); } if (result == null) { result = super.getProperty(name); } } if (result != null) { result = replace(result); } return result; }	public synchronized Enumeration<String> getLoggerNames() { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); return Collections.enumeration(getClassLoaderInfo(classLoader).loggers.keySet()); }
public Servlet allocate() throws ServletException { if (unloading) throw new ServletException(sm.getString("standardWrapper.unloading", getName())); boolean newInstance = false; if (!singleThreadModel) { if (instance == null) { synchronized (this) { if (instance == null) { try { if (log.isDebugEnabled()) log.debug("Allocating non-STM instance"); instance = loadServlet(); if (!singleThreadModel) { newInstance = true; countAllocated++; } } catch (ServletException e) { throw e; } catch (Throwable e) { throw new ServletException(sm.getString("standardWrapper.allocate"), e); } } } } if (!singleThreadModel) { if (log.isTraceEnabled()) log.trace(" Returning non-STM instance"); if (!newInstance) { countAllocated++; } return (instance); } } synchronized (instancePool) { while (countAllocated >= nInstances) { if (nInstances < maxInstances) { try { instancePool.push(loadServlet()); nInstances++; } catch (ServletException e) { throw e; } catch (Throwable e) { throw new ServletException(sm.getString("standardWrapper.allocate"), e); } } else { try { instancePool.wait(); } catch (InterruptedException e) { ; } } } if (log.isTraceEnabled()) log.trace(" Returning allocated STM instance"); countAllocated++; return (Servlet) instancePool.pop(); } }	public int getCountAllocated() { return (this.countAllocated); }	synchronized void unload() throws ServletException { if (!singleThreadModel && (instance == null)) return; unloading = true; if (countAllocated > 0) { int nRetries = 0; long delay = unloadDelay / 20; while ((nRetries < 21) && (countAllocated > 0)) { if ((nRetries % 10) == 0) { log.info(sm.getString("standardWrapper.waiting", new Integer(countAllocated))); } try { Thread.sleep(delay); } catch (InterruptedException e) { ; } nRetries++; } } PrintStream out = System.out; if (swallowOutput) { SystemLogHandler.startCapture(); } try { instanceSupport.fireInstanceEvent(InstanceEvent.BEFORE_DESTROY_EVENT, instance); if (Globals.IS_SECURITY_ENABLED) { SecurityUtil.doAsPrivilege("destroy", instance); SecurityUtil.remove(instance); } else { instance.destroy(); } instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_DESTROY_EVENT, instance); if (!((Context) getParent()).getIgnoreAnnotations()) { ((StandardContext) getParent()).getInstanceManager().destroyInstance(instance); } } catch (Throwable t) { instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_DESTROY_EVENT, instance, t); instance = null; instancePool = null; nInstances = 0; fireContainerEvent("unload", this); unloading = false; throw new ServletException(sm.getString("standardWrapper.destroyException", getName()), t); } finally { if (swallowOutput) { String log = SystemLogHandler.stopCapture(); if (log != null && log.length() > 0) { if (getServletContext() != null) { getServletContext().log(log); } else { out.println(log); } } } } instance = null; if (singleThreadModel && (instancePool != null)) { try { while (!instancePool.isEmpty()) { Servlet s = (Servlet) instancePool.pop(); if (Globals.IS_SECURITY_ENABLED) { SecurityUtil.doAsPrivilege("destroy", s); SecurityUtil.remove(instance); } else { s.destroy(); } if (!((Context) getParent()).getIgnoreAnnotations()) { ((StandardContext) getParent()).getInstanceManager().destroyInstance(s); } } } catch (Throwable t) { instancePool = null; nInstances = 0; unloading = false; fireContainerEvent("unload", this); throw new ServletException(sm.getString("standardWrapper.destroyException", getName()), t); } instancePool = null; nInstances = 0; } singleThreadModel = false; unloading = false; fireContainerEvent("unload", this); }	public void deallocate(Servlet servlet) throws ServletException { if (!singleThreadModel) { countAllocated--; return; } synchronized (instancePool) { countAllocated--; instancePool.push(servlet); instancePool.notify(); } }
protected Principal getPrincipal(String username) { return (null); }	public Principal authenticate(String username, String clientDigest, String nonce, String nc, String cnonce, String qop, String realmName, String md5a2) { return authenticate(username, new JAASCallbackHandler(this, username, clientDigest, nonce, nc, cnonce, qop, realmName, md5a2)); }	public Principal authenticate(String username, String credentials) { return authenticate(username, new JAASCallbackHandler(this, username, credentials)); }	public boolean login() throws LoginException { if (callbackHandler == null) throw new LoginException("No CallbackHandler specified"); Callback[] callbacks = new Callback[8]; callbacks[0] = new NameCallback("Username: "); callbacks[1] = new PasswordCallback("Password: ", false); callbacks[2] = new TextInputCallback("nonce"); callbacks[3] = new TextInputCallback("nc"); callbacks[4] = new TextInputCallback("cnonce"); callbacks[5] = new TextInputCallback("qop"); callbacks[6] = new TextInputCallback("realmName"); callbacks[7] = new TextInputCallback("md5a2"); String username = null; String password = null; String nonce = null; String nc = null; String cnonce = null; String qop = null; String realmName = null; String md5a2 = null; try { callbackHandler.handle(callbacks); username = ((NameCallback) callbacks[0]).getName(); password = new String(((PasswordCallback) callbacks[1]).getPassword()); nonce = ((TextInputCallback) callbacks[2]).getText(); nc = ((TextInputCallback) callbacks[3]).getText(); cnonce = ((TextInputCallback) callbacks[4]).getText(); qop = ((TextInputCallback) callbacks[5]).getText(); realmName = ((TextInputCallback) callbacks[6]).getText(); md5a2 = ((TextInputCallback) callbacks[7]).getText(); } catch (IOException e) { throw new LoginException(e.toString()); } catch (UnsupportedCallbackException e) { throw new LoginException(e.toString()); } if (md5a2 == null) { principal = super.authenticate(username, password); } else { principal = super.authenticate(username, password, nonce, nc, cnonce, qop, realmName, md5a2); } log.debug("login " + username + " " + principal); if (principal != null) { return (true); } else { throw new FailedLoginException("Username or password is incorrect"); } }	public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException { for (int i = 0; i < callbacks.length; i++) { if (callbacks[i] instanceof NameCallback) { if (realm.getContainer().getLogger().isTraceEnabled()) realm.getContainer().getLogger().trace(sm.getString("jaasCallback.username", username)); ((NameCallback) callbacks[i]).setName(username); } else if (callbacks[i] instanceof PasswordCallback) { final char[] passwordcontents; if (password != null) { passwordcontents = password.toCharArray(); } else { passwordcontents = new char[0]; } ((PasswordCallback) callbacks[i]).setPassword(passwordcontents); } else if (callbacks[i] instanceof TextInputCallback) { TextInputCallback cb = ((TextInputCallback) callbacks[i]); if (cb.getPrompt().equals("nonce")) { cb.setText(nonce); } else if (cb.getPrompt().equals("nc")) { cb.setText(nc); } else if (cb.getPrompt().equals("cnonce")) { cb.setText(cnonce); } else if (cb.getPrompt().equals("qop")) { cb.setText(qop); } else if (cb.getPrompt().equals("realmName")) { cb.setText(realmName); } else if (cb.getPrompt().equals("md5a2")) { cb.setText(md5a2); } else { throw new UnsupportedCallbackException(callbacks[i]); } } else { throw new UnsupportedCallbackException(callbacks[i]); } } }
protected String getName() { return (name); }	public Principal authenticate(String username, String credentials) { try { LoginContext loginContext = null; if (appName == null) appName = "Tomcat"; if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.beginLogin", username, appName)); ClassLoader ocl = null; if (!isUseContextClassLoader()) { ocl = Thread.currentThread().getContextClassLoader(); Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); } try { loginContext = new LoginContext(appName, new JAASCallbackHandler(this, username, credentials)); } catch (Throwable e) { log.error(sm.getString("jaasRealm.unexpectedError"), e); return (null); } finally { if (!isUseContextClassLoader()) { Thread.currentThread().setContextClassLoader(ocl); } } if (log.isDebugEnabled()) log.debug("Login context created " + username); Subject subject = null; try { loginContext.login(); subject = loginContext.getSubject(); if (subject == null) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.failedLogin", username)); return (null); } } catch (AccountExpiredException e) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.accountExpired", username)); return (null); } catch (CredentialExpiredException e) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.credentialExpired", username)); return (null); } catch (FailedLoginException e) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.failedLogin", username)); return (null); } catch (LoginException e) { log.warn(sm.getString("jaasRealm.loginException", username), e); return (null); } catch (Throwable e) { log.error(sm.getString("jaasRealm.unexpectedError"), e); return (null); } if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.loginContextCreated", username)); Principal principal = createPrincipal(username, subject); if (principal == null) { log.debug(sm.getString("jaasRealm.authenticateFailure", username)); return (null); } if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.authenticateSuccess", username)); } return (principal); } catch (Throwable t) { log.error("error ", t); return null; } }	public boolean login() throws LoginException { if (callbackHandler == null) throw new LoginException("No CallbackHandler specified"); Callback[] callbacks = new Callback[2]; callbacks[0] = new NameCallback("Username: "); callbacks[1] = new PasswordCallback("Password: ", false); String username = null; String password = null; try { callbackHandler.handle(callbacks); username = ((NameCallback) callbacks[0]).getName(); password = new String(((PasswordCallback) callbacks[1]).getPassword()); } catch (IOException e) { throw new LoginException(e.toString()); } catch (UnsupportedCallbackException e) { throw new LoginException(e.toString()); } principal = super.authenticate(username, password); log.debug("login " + username + " " + principal); if (principal != null) { return (true); } else { throw new FailedLoginException("Username or password is incorrect"); } }	public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException { for (int i = 0; i < callbacks.length; i++) { if (callbacks[i] instanceof NameCallback) { if (realm.getContainer().getLogger().isTraceEnabled()) realm.getContainer().getLogger().trace(sm.getString("jaasCallback.username", username)); ((NameCallback) callbacks[i]).setName(username); } else if (callbacks[i] instanceof PasswordCallback) { final char[] passwordcontents; if (password != null) { passwordcontents = password.toCharArray(); } else { passwordcontents = new char[0]; } ((PasswordCallback) callbacks[i]).setPassword(passwordcontents); } else { throw new UnsupportedCallbackException(callbacks[i]); } } }	public void setUserClassNames(String userClassNames) { this.userClassNames = userClassNames; }
public void pause() throws Exception { for (int i = 0; i < wEnv.getHandlerCount(); i++) { if (wEnv.getHandler(i) != null) { wEnv.getHandler(i).pause(); } } }
protected synchronized String getPassword(String username) { String dbCredentials = null; PreparedStatement stmt = null; ResultSet rs = null; // Number of tries is the numebr of attempts to connect to the database // during this login attempt (if we need to open the database) // This needs rewritten wuth better pooling support, the existing code // needs signature changes since the Prepared statements needs cached // with the connections. // The code below will try twice if there is a SQLException so the // connection may try to be opened again. On normal conditions (including int numberOfTries = 2; while (numberOfTries > 0) { try { open(); try { stmt = credentials(dbConnection, username); rs = stmt.executeQuery(); if (rs.next()) { dbCredentials = rs.getString(1); } rs.close(); rs = null; if (dbCredentials == null) { return (null); } dbCredentials = dbCredentials.trim(); return dbCredentials; } finally { if (rs != null) { try { rs.close(); } catch (SQLException e) { containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet")); } } dbConnection.commit(); } } catch (SQLException e) { containerLog.error(sm.getString("jdbcRealm.exception"), e); if (dbConnection != null) close(dbConnection); } numberOfTries--; } return (null); }
public boolean listenerStart() { if (log.isDebugEnabled()) log.debug("Configuring application event listeners"); String[] listeners = findApplicationListeners(); Object[] results = new Object[listeners.length]; boolean ok = true; for (int i = 0; i < results.length; i++) { if (getLogger().isDebugEnabled()) getLogger().debug(" Configuring event listener class '" + listeners[i] + "'"); try { results[i] = instanceManager.newInstance(listeners[i]); } catch (Throwable t) { getLogger().error(sm.getString("standardContext.applicationListener", listeners[i]), t); ok = false; } } if (!ok) { getLogger().error(sm.getString("standardContext.applicationSkipped")); return (false); } ArrayList<Object> eventListeners = new ArrayList<Object>(); ArrayList<Object> lifecycleListeners = new ArrayList<Object>(); for (int i = 0; i < results.length; i++) { if ((results[i] instanceof ServletContextAttributeListener) || (results[i] instanceof ServletRequestAttributeListener) || (results[i] instanceof ServletRequestListener) || (results[i] instanceof HttpSessionAttributeListener)) { eventListeners.add(results[i]); } if ((results[i] instanceof ServletContextListener) || (results[i] instanceof HttpSessionListener)) { lifecycleListeners.add(results[i]); } } setApplicationEventListeners(eventListeners.toArray()); setApplicationLifecycleListeners(lifecycleListeners.toArray()); if (getLogger().isDebugEnabled()) getLogger().debug("Sending application start events"); Object[] instances = getApplicationLifecycleListeners(); if (instances == null) return (ok); ServletContextEvent event = new ServletContextEvent(getServletContext()); for (int i = 0; i < instances.length; i++) { if (instances[i] == null) continue; if (!(instances[i] instanceof ServletContextListener)) continue; ServletContextListener listener = (ServletContextListener) instances[i]; try { fireContainerEvent("beforeContextInitialized", listener); listener.contextInitialized(event); fireContainerEvent("afterContextInitialized", listener); } catch (Throwable t) { fireContainerEvent("afterContextInitialized", listener); getLogger().error(sm.getString("standardContext.listenerStart", instances[i].getClass().getName()), t); ok = false; } } return (ok); }
public String readLine() throws IOException { if (lineBuffer == null) { lineBuffer = new char[MAX_LINE_LENGTH]; } String result = null; int pos = 0; int end = -1; int skip = -1; StringBuffer aggregator = null; while (end < 0) { mark(MAX_LINE_LENGTH); while ((pos < MAX_LINE_LENGTH) && (end < 0)) { int nRead = read(lineBuffer, pos, MAX_LINE_LENGTH - pos); if (nRead < 0) { if (pos == 0) { return null; } end = pos; skip = pos; } for (int i = pos; (i < (pos + nRead)) && (end < 0); i++) { if (lineBuffer[i] == LINE_SEP[0]) { end = i; skip = i + 1; char nextchar; if (i == (pos + nRead - 1)) { nextchar = (char) read(); } else { nextchar = lineBuffer[i + 1]; } if (nextchar == LINE_SEP[1]) { skip++; } } else if (lineBuffer[i] == LINE_SEP[1]) { end = i; skip = i + 1; } } if (nRead > 0) { pos += nRead; } } if (end < 0) { if (aggregator == null) { aggregator = new StringBuffer(); } aggregator.append(lineBuffer); pos = 0; } else { reset(); skip(skip); } } if (aggregator == null) { result = new String(lineBuffer, 0, end); } else { aggregator.append(lineBuffer, 0, end); result = aggregator.toString(); } return result; }
protected void run() throws IOException { if (!isReady()) { throw new IOException(this.getClass().getName() + ": not ready to run."); } if (debug >= 1) { log("runCGI(envp=[" + env + "], command=" + command + ")"); } if ((command.indexOf(File.separator + "." + File.separator) >= 0) || (command.indexOf(File.separator + "..") >= 0) || (command.indexOf(".." + File.separator) >= 0)) { throw new IOException(this.getClass().getName() + "Illegal Character in CGI command " + "path ('.' or '..') detected. Not " + "running CGI [" + command + "]."); } Runtime rt = null; InputStream cgiOutput = null; BufferedReader commandsStdErr = null; BufferedOutputStream commandsStdIn = null; Process proc = null; int bufRead = -1; StringBuffer cmdAndArgs = new StringBuffer(); if (command.indexOf(" ") < 0) { cmdAndArgs.append(command); } else { cmdAndArgs.append("\""); cmdAndArgs.append(command); cmdAndArgs.append("\""); } for (int i = 0; i < params.size(); i++) { cmdAndArgs.append(" "); String param = (String) params.get(i); if (param.indexOf(" ") < 0) { cmdAndArgs.append(param); } else { cmdAndArgs.append("\""); cmdAndArgs.append(param); cmdAndArgs.append("\""); } } StringBuffer command = new StringBuffer(cgiExecutable); command.append(" "); command.append(cmdAndArgs.toString()); cmdAndArgs = command; try { rt = Runtime.getRuntime(); proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd); String sContentLength = (String) env.get("CONTENT_LENGTH"); if (!"".equals(sContentLength)) { commandsStdIn = new BufferedOutputStream(proc.getOutputStream()); IOTools.flow(stdin, commandsStdIn); commandsStdIn.flush(); commandsStdIn.close(); } boolean isRunning = true; commandsStdErr = new BufferedReader(new InputStreamReader(proc.getErrorStream())); final BufferedReader stdErrRdr = commandsStdErr; new Thread() { public void run() { sendToLog(stdErrRdr); } ; }.start(); InputStream cgiHeaderStream = new HTTPHeaderInputStream(proc.getInputStream()); BufferedReader cgiHeaderReader = new BufferedReader(new InputStreamReader(cgiHeaderStream)); while (isRunning) { try { String line = null; while (((line = cgiHeaderReader.readLine()) != null) && !("".equals(line))) { if (debug >= 2) { log("runCGI: addHeader(\"" + line + "\")"); } if (line.startsWith("HTTP")) { response.setStatus(getSCFromHttpStatusLine(line)); } else if (line.indexOf(":") >= 0) { String header = line.substring(0, line.indexOf(":")).trim(); String value = line.substring(line.indexOf(":") + 1).trim(); if (header.equalsIgnoreCase("status")) { response.setStatus(getSCFromCGIStatusHeader(value)); } else { response.addHeader(header, value); } } else { log("runCGI: bad header line \"" + line + "\""); } } byte[] bBuf = new byte[2048]; OutputStream out = response.getOutputStream(); cgiOutput = proc.getInputStream(); try { while ((bufRead = cgiOutput.read(bBuf)) != -1) { if (debug >= 4) { log("runCGI: output " + bufRead + " bytes of data"); } out.write(bBuf, 0, bufRead); } } finally { if (bufRead != -1) { while ((bufRead = cgiOutput.read(bBuf)) != -1) { } } } proc.exitValue(); isRunning = false; } catch (IllegalThreadStateException e) { try { Thread.sleep(500); } catch (InterruptedException ignored) { } } } //replacement for Process.waitFor() cgiOutput.close(); } catch (IOException e) { log("Caught exception " + e); throw e; } finally { if (debug > 4) { log("Running finally block"); } if (proc != null) { proc.destroy(); proc = null; } } }
protected void deployDescriptor(String contextPath, File contextXml, String file) { if (deploymentExists(contextPath)) { return; } DeployedApplication deployedApp = new DeployedApplication(contextPath); if (log.isDebugEnabled()) { log.debug(sm.getString("hostConfig.deployDescriptor", file)); } Context context = null; try { synchronized (digester) { try { context = (Context) digester.parse(contextXml); if (context == null) { log.error(sm.getString("hostConfig.deployDescriptor.error", file)); return; } } finally { digester.reset(); } } if (context instanceof Lifecycle) { Class<?> clazz = Class.forName(host.getConfigClass()); LifecycleListener listener = (LifecycleListener) clazz.newInstance(); ((Lifecycle) context).addLifecycleListener(listener); } context.setConfigFile(contextXml.getAbsolutePath()); context.setPath(contextPath); boolean isWar = false; boolean isExternal = false; if (context.getDocBase() != null) { File docBase = new File(context.getDocBase()); if (!docBase.isAbsolute()) { docBase = new File(appBase(), context.getDocBase()); } if (!docBase.getCanonicalPath().startsWith(appBase().getAbsolutePath())) { isExternal = true; deployedApp.redeployResources.put(contextXml.getAbsolutePath(), new Long(contextXml.lastModified())); deployedApp.redeployResources.put(docBase.getAbsolutePath(), new Long(docBase.lastModified())); if (docBase.getAbsolutePath().toLowerCase().endsWith(".war")) { isWar = true; } } else { log.warn(sm.getString("hostConfig.deployDescriptor.localDocBaseSpecified", docBase)); context.setDocBase(null); } } host.addChild(context); String name = null; String path = context.getPath(); if (path.equals("")) { name = "ROOT"; } else { if (path.startsWith("/")) { name = path.substring(1); } else { name = path; } } File expandedDocBase = new File(appBase(), name); if (context.getDocBase() != null) { expandedDocBase = new File(context.getDocBase()); if (!expandedDocBase.isAbsolute()) { expandedDocBase = new File(appBase(), context.getDocBase()); } } if (isWar && unpackWARs) { deployedApp.redeployResources.put(expandedDocBase.getAbsolutePath(), new Long(expandedDocBase.lastModified())); deployedApp.redeployResources.put(contextXml.getAbsolutePath(), new Long(contextXml.lastModified())); addWatchedResources(deployedApp, expandedDocBase.getAbsolutePath(), context); } else { File warDocBase = new File(expandedDocBase.getAbsolutePath() + ".war"); if (warDocBase.exists()) { deployedApp.redeployResources.put(warDocBase.getAbsolutePath(), new Long(warDocBase.lastModified())); } if (expandedDocBase.exists()) { deployedApp.redeployResources.put(expandedDocBase.getAbsolutePath(), new Long(expandedDocBase.lastModified())); addWatchedResources(deployedApp, expandedDocBase.getAbsolutePath(), context); } else { addWatchedResources(deployedApp, null, context); } if (!isExternal) { deployedApp.redeployResources.put(contextXml.getAbsolutePath(), new Long(contextXml.lastModified())); } } } catch (Throwable t) { log.error(sm.getString("hostConfig.deployDescriptor.error", file), t); } if (context != null && host.findChild(context.getName()) != null) { deployed.put(contextPath, deployedApp); } }
public synchronized void getAllClusterSessions() { if (cluster != null && cluster.getMembers().length > 0) { long beforeSendTime = System.currentTimeMillis(); Member mbr = findSessionMasterMember(); if (mbr == null) { return; } SessionMessage msg = new SessionMessageImpl(this.getName(), SessionMessage.EVT_GET_ALL_SESSIONS, null, "GET-ALL", "GET-ALL-" + getName()); stateTransferCreateSendTime = beforeSendTime; counterSend_EVT_GET_ALL_SESSIONS++; stateTransfered = false; try { synchronized (receivedMessageQueue) { receiverQueue = true; } cluster.send(msg, mbr); if (log.isWarnEnabled()) log.warn(sm.getString("deltaManager.waitForSessionState", getName(), mbr)); waitForSendAllSessions(beforeSendTime); } finally { synchronized (receivedMessageQueue) { for (Iterator iter = receivedMessageQueue.iterator(); iter.hasNext(); ) { SessionMessage smsg = (SessionMessage) iter.next(); if (!stateTimestampDrop) { messageReceived(smsg, smsg.getAddress() != null ? (Member) smsg.getAddress() : null); } else { if (smsg.getEventType() != SessionMessage.EVT_GET_ALL_SESSIONS && smsg.getTimestamp() >= stateTransferCreateSendTime) { messageReceived(smsg, smsg.getAddress() != null ? (Member) smsg.getAddress() : null); } else { if (log.isWarnEnabled()) { log.warn(sm.getString("deltaManager.dropMessage", getName(), smsg.getEventTypeString(), new Date(stateTransferCreateSendTime), new Date(smsg.getTimestamp()))); } } } } receivedMessageQueue.clear(); receiverQueue = false; } } } else { if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.noMembers", getName())); } }
public void getBytes(MessageBytes mb) { int length = getInt(); if ((length == 0xFFFF) || (length == -1)) { mb.recycle(); return; } mb.setBytes(buf, pos, length); pos += length; pos++; }
public synchronized boolean stop(int level) throws IOException { boolean valid = false; if ((level & Channel.MBR_RX_SEQ) == Channel.MBR_RX_SEQ) { valid = true; doRunReceiver = false; if (receiver != null) receiver.interrupt(); receiver = null; } if ((level & Channel.MBR_TX_SEQ) == Channel.MBR_TX_SEQ) { valid = true; doRunSender = false; if (sender != null) sender.interrupt(); sender = null; } if (!valid) { throw new IllegalArgumentException("Invalid stop level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ"); } startLevel = (startLevel & (~level)); if (startLevel == 0) { member.setCommand(Member.SHUTDOWN_PAYLOAD); member.getData(true, true); send(false); try { socket.leaveGroup(address); } catch (Exception ignore) { } serviceStartTime = Long.MAX_VALUE; } return (startLevel == 0); }
public Map getHeaderFields() { if (!connected) { try { connect(); } catch (IOException e) { } } if (attributes == null) return (Collections.EMPTY_MAP); HashMap headerFields = new HashMap(attributes.size()); NamingEnumeration attributeEnum = attributes.getIDs(); try { while (attributeEnum.hasMore()) { String attributeID = (String) attributeEnum.next(); Attribute attribute = attributes.get(attributeID); if (attribute == null) continue; ArrayList attributeValueList = new ArrayList(attribute.size()); NamingEnumeration attributeValues = attribute.getAll(); while (attributeValues.hasMore()) { attributeValueList.add(attributeValues.next().toString()); } attributeValueList.trimToSize(); headerFields.put(attributeID, Collections.unmodifiableList(attributeValueList)); } } catch (NamingException ne) { // Shouldn't happen } return Collections.unmodifiableMap(headerFields); }	public String getHeaderField(String name) { if (!connected) { try { connect(); } catch (IOException e) { } } if (attributes == null) return (null); NamingEnumeration attributeEnum = attributes.getIDs(); try { while (attributeEnum.hasMore()) { String attributeID = (String) attributeEnum.next(); if (attributeID.equalsIgnoreCase(name)) { Attribute attribute = attributes.get(attributeID); if (attribute == null) return null; return attribute.get(attribute.size() - 1).toString(); } } } catch (NamingException ne) { // Shouldn't happen } return (null); }	public long getLastModified() { if (!connected) { try { connect(); } catch (IOException e) { } } if (attributes == null) return 0; Attribute lastModified = attributes.get(ResourceAttributes.LAST_MODIFIED); if (lastModified != null) { try { Date lmDate = (Date) lastModified.get(); return lmDate.getTime(); } catch (Exception e) { } } return 0; }
public boolean parseRequestLine(boolean useAvailableData) throws IOException { int start = 0; // // Skipping blank lines byte chr = 0; do { if (pos >= lastValid) { if (useAvailableData) { return false; } if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } chr = buf[pos++]; } while ((chr == Constants.CR) || (chr == Constants.LF)); pos--; start = pos; if (pos >= lastValid) { if (useAvailableData) { return false; } if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } // // Reading the method name // Method name is always US-ASCII boolean space = false; while (!space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.SP) { space = true; request.method().setBytes(buf, start, pos - start); } pos++; } start = pos; int end = 0; int questionPos = -1; // // Reading the URI space = false; boolean eol = false; while (!space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.SP) { space = true; end = pos; } else if ((buf[pos] == Constants.CR) || (buf[pos] == Constants.LF)) { eol = true; space = true; end = pos; } else if ((buf[pos] == Constants.QUESTION) && (questionPos == -1)) { questionPos = pos; } pos++; } request.unparsedURI().setBytes(buf, start, end - start); if (questionPos >= 0) { request.queryString().setBytes(buf, questionPos + 1, end - questionPos - 1); request.requestURI().setBytes(buf, start, questionPos - start); } else { request.requestURI().setBytes(buf, start, end - start); } start = pos; end = 0; while (!eol) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.CR) { end = pos; } else if (buf[pos] == Constants.LF) { if (end == 0) end = pos; eol = true; } pos++; } if ((end - start) > 0) { request.protocol().setBytes(buf, start, end - start); } else { request.protocol().setString(""); } return true; }	public boolean parseRequestLine(boolean useAvailableData) throws IOException { if (!parsingRequestLine) return true; if (parsingRequestLinePhase == 0) { byte chr = 0; do { if (pos >= lastValid) { if (useAvailableData) { return false; } if (readSocket(true, false) == 0) return false; } chr = buf[pos++]; } while ((chr == Constants.CR) || (chr == Constants.LF)); pos--; parsingRequestLineStart = pos; parsingRequestLinePhase = 1; } if (parsingRequestLinePhase == 1) { if (pos >= lastValid) { if (useAvailableData) { return false; } if (readSocket(true, false) == 0) return false; } parsingRequestLinePhase = 2; } if (parsingRequestLinePhase == 2) { // // Reading the method name // Method name is always US-ASCII boolean space = false; while (!space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP) { space = true; request.method().setBytes(buf, parsingRequestLineStart, pos - parsingRequestLineStart); } pos++; } parsingRequestLineStart = pos; parsingRequestLinePhase = 3; } if (parsingRequestLinePhase == 3) { int end = 0; // // Reading the URI boolean space = false; while (!space) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.SP) { space = true; end = pos; } else if ((buf[pos] == Constants.CR) || (buf[pos] == Constants.LF)) { parsingRequestLineEol = true; space = true; end = pos; } else if ((buf[pos] == Constants.QUESTION) && (parsingRequestLineQPos == -1)) { parsingRequestLineQPos = pos; } pos++; } request.unparsedURI().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); if (parsingRequestLineQPos >= 0) { request.queryString().setBytes(buf, parsingRequestLineQPos + 1, end - parsingRequestLineQPos - 1); request.requestURI().setBytes(buf, parsingRequestLineStart, parsingRequestLineQPos - parsingRequestLineStart); } else { request.requestURI().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); } parsingRequestLineStart = pos; parsingRequestLinePhase = 4; } if (parsingRequestLinePhase == 4) { end = 0; while (!parsingRequestLineEol) { if (pos >= lastValid) { if (!fill(true, false)) return false; } if (buf[pos] == Constants.CR) { end = pos; } else if (buf[pos] == Constants.LF) { if (end == 0) end = pos; parsingRequestLineEol = true; } pos++; } if ((end - parsingRequestLineStart) > 0) { request.protocol().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart); } else { request.protocol().setString(""); } parsingRequestLine = false; parsingRequestLinePhase = 0; parsingRequestLineEol = false; parsingRequestLineStart = 0; return true; } throw new IllegalStateException("Invalid request line parse phase:" + parsingRequestLinePhase); }	public void parseRequestLine() throws IOException { int start = 0; // // Skipping blank lines byte chr = 0; do { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } chr = buf[pos++]; } while ((chr == Constants.CR) || (chr == Constants.LF)); pos--; start = pos; // // Reading the method name // Method name is always US-ASCII boolean space = false; while (!space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.SP) { space = true; request.method().setBytes(buf, start, pos - start); } pos++; } start = pos; int end = 0; int questionPos = -1; // // Reading the URI space = false; boolean eol = false; while (!space) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.SP) { space = true; end = pos; } else if ((buf[pos] == Constants.CR) || (buf[pos] == Constants.LF)) { eol = true; space = true; end = pos; } else if ((buf[pos] == Constants.QUESTION) && (questionPos == -1)) { questionPos = pos; } pos++; } request.unparsedURI().setBytes(buf, start, end - start); if (questionPos >= 0) { request.queryString().setBytes(buf, questionPos + 1, end - questionPos - 1); request.requestURI().setBytes(buf, start, questionPos - start); } else { request.requestURI().setBytes(buf, start, end - start); } start = pos; end = 0; while (!eol) { if (pos >= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } if (buf[pos] == Constants.CR) { end = pos; } else if (buf[pos] == Constants.LF) { if (end == 0) end = pos; eol = true; } pos++; } if ((end - start) > 0) { request.protocol().setBytes(buf, start, end - start); } else { request.protocol().setString(""); } }
private String comparePageEncodings(String pageDirEnc, Node.PageDirective pageDir) throws JasperException { Node.Root root = pageDir.getRoot(); String configEnc = root.getJspConfigPageEncoding(); if (configEnc != null) { if (!pageDirEnc.equals(configEnc) && (!pageDirEnc.startsWith("UTF-16") || !configEnc.startsWith("UTF-16"))) { err.jspError(pageDir, "jsp.error.config_pagedir_encoding_mismatch", configEnc, pageDirEnc); } else { return configEnc; } } if ((root.isXmlSyntax() && root.isEncodingSpecifiedInProlog()) || root.isBomPresent()) { String pageEnc = root.getPageEncoding(); if (!pageDirEnc.equals(pageEnc) && (!pageDirEnc.startsWith("UTF-16") || !pageEnc.startsWith("UTF-16"))) { err.jspError(pageDir, "jsp.error.prolog_pagedir_encoding_mismatch", pageEnc, pageDirEnc); } else { return pageEnc; } } return pageDirEnc; }	public void visit(Node.VariableDirective n) throws JasperException { // Do nothing, since this variable directive has already been // validated by TagFileProcessor when it created a TagInfo object // from the tag file in which the directive appeared }
private Map<String, Map<String, String>> buildInjectionMap(NamingResources namingResources) { Map<String, Map<String, String>> injectionMap = new HashMap<String, Map<String, String>>(); for (Injectable resource : namingResources.findLocalEjbs()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findEjbs()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findEnvironments()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findMessageDestinationRefs()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findResourceEnvRefs()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findResources()) { addInjectionTarget(resource, injectionMap); } for (Injectable resource : namingResources.findServices()) { addInjectionTarget(resource, injectionMap); } return injectionMap; }
private Node parseCustomAction(String qName, String localName, String uri, Attributes nonTaglibAttrs, Attributes nonTaglibXmlnsAttrs, Attributes taglibAttrs, Mark start, Node parent) throws SAXException { TagLibraryInfo tagLibInfo = pageInfo.getTaglib(uri); if (tagLibInfo == null) { return null; } TagInfo tagInfo = tagLibInfo.getTag(localName); TagFileInfo tagFileInfo = tagLibInfo.getTagFile(localName); if (tagInfo == null && tagFileInfo == null) { throw new SAXException(Localizer.getMessage("jsp.error.xml.bad_tag", localName, uri)); } Class tagHandlerClass = null; if (tagInfo != null) { String handlerClassName = tagInfo.getTagClassName(); try { tagHandlerClass = ctxt.getClassLoader().loadClass(handlerClassName); } catch (Exception e) { throw new SAXException(Localizer.getMessage("jsp.error.loadclass.taghandler", handlerClassName, qName), e); } } String prefix = ""; int colon = qName.indexOf(':'); if (colon != -1) { prefix = qName.substring(0, colon); } Node.CustomTag ret = null; if (tagInfo != null) { ret = new Node.CustomTag(qName, prefix, localName, uri, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, start, parent, tagInfo, tagHandlerClass); } else { ret = new Node.CustomTag(qName, prefix, localName, uri, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, start, parent, tagFileInfo); } return ret; }	private void checkPrefix(String uri, String qName) { int index = qName.indexOf(':'); if (index != -1) { String prefix = qName.substring(0, index); pageInfo.addPrefix(prefix); if ("jsp".equals(prefix) && !JSP_URI.equals(uri)) { pageInfo.setIsJspPrefixHijacked(true); } } }	public void startElement(String uri, String localName, String qName, Attributes attrs) throws SAXException { AttributesImpl taglibAttrs = null; AttributesImpl nonTaglibAttrs = null; AttributesImpl nonTaglibXmlnsAttrs = null; processChars(); checkPrefixes(uri, qName, attrs); if (directivesOnly && !(JSP_URI.equals(uri) && localName.startsWith(DIRECTIVE_ACTION))) { return; } if (JSP_URI.equals(uri) && TEXT_ACTION.equals(current.getLocalName())) { throw new SAXParseException(Localizer.getMessage("jsp.error.text.has_subelement"), locator); } startMark = new Mark(ctxt, path, locator.getLineNumber(), locator.getColumnNumber()); if (attrs != null) { boolean isTaglib = false; for (int i = attrs.getLength() - 1; i >= 0; i--) { isTaglib = false; String attrQName = attrs.getQName(i); if (!attrQName.startsWith("xmlns")) { if (nonTaglibAttrs == null) { nonTaglibAttrs = new AttributesImpl(); } nonTaglibAttrs.addAttribute(attrs.getURI(i), attrs.getLocalName(i), attrs.getQName(i), attrs.getType(i), attrs.getValue(i)); } else { if (attrQName.startsWith("xmlns:jsp")) { isTaglib = true; } else { String attrUri = attrs.getValue(i); // TaglibInfo for this uri already established in isTaglib = pageInfo.hasTaglib(attrUri); } if (isTaglib) { if (taglibAttrs == null) { taglibAttrs = new AttributesImpl(); } taglibAttrs.addAttribute(attrs.getURI(i), attrs.getLocalName(i), attrs.getQName(i), attrs.getType(i), attrs.getValue(i)); } else { if (nonTaglibXmlnsAttrs == null) { nonTaglibXmlnsAttrs = new AttributesImpl(); } nonTaglibXmlnsAttrs.addAttribute(attrs.getURI(i), attrs.getLocalName(i), attrs.getQName(i), attrs.getType(i), attrs.getValue(i)); } } } } Node node = null; if (tagDependentPending && JSP_URI.equals(uri) && localName.equals(BODY_ACTION)) { tagDependentPending = false; tagDependentNesting++; current = parseStandardAction(qName, localName, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, startMark, current); return; } if (tagDependentPending && JSP_URI.equals(uri) && localName.equals(ATTRIBUTE_ACTION)) { current = parseStandardAction(qName, localName, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, startMark, current); return; } if (tagDependentPending) { tagDependentPending = false; tagDependentNesting++; } if (tagDependentNesting > 0) { node = new Node.UninterpretedTag(qName, localName, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, startMark, current); } else if (JSP_URI.equals(uri)) { node = parseStandardAction(qName, localName, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, startMark, current); } else { node = parseCustomAction(qName, localName, uri, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, startMark, current); if (node == null) { node = new Node.UninterpretedTag(qName, localName, nonTaglibAttrs, nonTaglibXmlnsAttrs, taglibAttrs, startMark, current); } else { String bodyType = getBodyType((Node.CustomTag) node); if (scriptlessBodyNode == null && bodyType.equalsIgnoreCase(TagInfo.BODY_CONTENT_SCRIPTLESS)) { scriptlessBodyNode = node; } } } }
private boolean validateURLPattern(String urlPattern) { if (urlPattern == null) return (false); if (urlPattern.indexOf('\n') >= 0 || urlPattern.indexOf('\r') >= 0) { return (false); } if (urlPattern.startsWith("*.")) { if (urlPattern.indexOf('/') < 0) return (true); else return (false); } if ((urlPattern.startsWith("/")) && (urlPattern.indexOf("*.") < 0)) return (true); else return (false); }	public void addPattern(String pattern) { if (pattern == null) return; if (pattern.endsWith("*")) { if (pattern.charAt(pattern.length() - 1) != '/') { if (log.isDebugEnabled()) { log.warn("Suspicious url pattern: \"" + pattern + "\"" + " - see http://java.sun.com/aboutJava/communityprocess/first/jsr053/servlet23_PFD.pdf" + " section 11.2"); } } } pattern = RequestUtil.URLDecode(pattern); String[] results = new String[patterns.length + 1]; for (int i = 0; i < patterns.length; i++) { results[i] = patterns[i]; } results[patterns.length] = pattern; patterns = results; }
public String[] findCompressableMimeTypes() { return (compressableMimeTypes); }	public String[] findCompressableMimeTypes() { return (compressableMimeTypes); }	public String[] findCompressableMimeTypes() { return (compressableMimeTypes); }
protected void createOutputDir() { String path = null; if (isTagFile()) { String tagName = tagInfo.getTagClassName(); path = tagName.replace('.', '/'); path = path.substring(0, path.lastIndexOf('/')); } else { path = getServletPackageName().replace('.', '/'); } try { baseUrl = options.getScratchDir().toURL(); String outUrlString = baseUrl.toString() + '/' + path; URL outUrl = new URL(outUrlString); outputDir = outUrl.getFile() + File.separator; if (!makeOutputDir()) { throw new IllegalStateException(Localizer.getMessage("jsp.error.outputfolder")); } } catch (MalformedURLException e) { throw new IllegalStateException(Localizer.getMessage("jsp.error.outputfolder"), e); } }	public static ClassLoader createClassLoader(File[] unpacked, File[] packed, URL[] urls, ClassLoader parent) throws Exception { if (log.isDebugEnabled()) log.debug("Creating new class loader"); ArrayList list = new ArrayList(); if (unpacked != null) { for (int i = 0; i < unpacked.length; i++) { File file = unpacked[i]; if (!file.exists() || !file.canRead()) continue; file = new File(file.getCanonicalPath() + File.separator); URL url = file.toURL(); if (log.isDebugEnabled()) log.debug(" Including directory " + url); list.add(url); } } if (packed != null) { for (int i = 0; i < packed.length; i++) { File directory = packed[i]; if (!directory.isDirectory() || !directory.exists() || !directory.canRead()) continue; String[] filenames = directory.list(); for (int j = 0; j < filenames.length; j++) { String filename = filenames[j].toLowerCase(); if (!filename.endsWith(".jar")) continue; File file = new File(directory, filenames[j]); if (log.isDebugEnabled()) log.debug(" Including jar file " + file.getAbsolutePath()); URL url = file.toURL(); list.add(url); } } } URL[] array = (URL[]) list.toArray(new URL[list.size()]); StandardClassLoader classLoader = null; if (parent == null) classLoader = new StandardClassLoader(array); else classLoader = new StandardClassLoader(array, parent); return (classLoader); }	public static ClassLoader createClassLoader(String[] locations, Integer[] types, ClassLoader parent) throws Exception { if (log.isDebugEnabled()) log.debug("Creating new class loader"); ArrayList list = new ArrayList(); if (locations != null && types != null && locations.length == types.length) { for (int i = 0; i < locations.length; i++) { String location = locations[i]; if (types[i] == IS_URL) { URL url = new URL(location); if (log.isDebugEnabled()) log.debug(" Including URL " + url); list.add(url); } else if (types[i] == IS_DIR) { File directory = new File(location); directory = new File(directory.getCanonicalPath()); if (!directory.exists() || !directory.isDirectory() || !directory.canRead()) continue; URL url = directory.toURL(); if (log.isDebugEnabled()) log.debug(" Including directory " + url); list.add(url); } else if (types[i] == IS_JAR) { File file = new File(location); file = new File(file.getCanonicalPath()); if (!file.exists() || !file.canRead()) continue; URL url = file.toURL(); if (log.isDebugEnabled()) log.debug(" Including jar file " + url); list.add(url); } else if (types[i] == IS_GLOB) { File directory = new File(location); if (!directory.exists() || !directory.isDirectory() || !directory.canRead()) continue; if (log.isDebugEnabled()) log.debug(" Including directory glob " + directory.getAbsolutePath()); String[] filenames = directory.list(); for (int j = 0; j < filenames.length; j++) { String filename = filenames[j].toLowerCase(); if (!filename.endsWith(".jar")) continue; File file = new File(directory, filenames[j]); file = new File(file.getCanonicalPath()); if (!file.exists() || !file.canRead()) continue; if (log.isDebugEnabled()) log.debug(" Including glob jar file " + file.getAbsolutePath()); URL url = file.toURL(); list.add(url); } } } } URL[] array = (URL[]) list.toArray(new URL[list.size()]); if (log.isDebugEnabled()) for (int i = 0; i < array.length; i++) { log.debug(" location " + i + " is " + array[i]); } StandardClassLoader classLoader = null; if (parent == null) classLoader = new StandardClassLoader(array); else classLoader = new StandardClassLoader(array, parent); return (classLoader); }
protected void deployWARs(File appBase, String[] files) { if (files == null) return; for (int i = 0; i < files.length; i++) { if (files[i].equalsIgnoreCase("META-INF")) continue; if (files[i].equalsIgnoreCase("WEB-INF")) continue; File dir = new File(appBase, files[i]); if (files[i].toLowerCase().endsWith(".war")) { String contextPath = "/" + files[i]; int period = contextPath.lastIndexOf("."); if (period >= 0) contextPath = contextPath.substring(0, period); if (contextPath.equals("/ROOT")) contextPath = ""; if (isServiced(contextPath)) continue; String file = files[i]; deployWAR(contextPath, dir, file); } } }
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { if (request.getAttribute(Globals.INVOKED_ATTR) != null) throw new UnavailableException(sm.getString("managerServlet.cannotInvoke")); String command = request.getPathInfo(); if (command == null) command = request.getServletPath(); String config = request.getParameter("config"); String path = request.getParameter("path"); String type = request.getParameter("type"); String war = request.getParameter("war"); String tag = request.getParameter("tag"); boolean update = false; if ((request.getParameter("update") != null) && (request.getParameter("update").equals("true"))) { update = true; } response.setContentType("text/plain; charset=" + Constants.CHARSET); PrintWriter writer = response.getWriter(); if (command == null) { writer.println(sm.getString("managerServlet.noCommand")); } else if (command.equals("/deploy")) { if (war != null || config != null) { deploy(writer, config, path, war, update); } else { deploy(writer, path, tag); } } else if (command.equals("/install")) { deploy(writer, config, path, war, false); } else if (command.equals("/list")) { list(writer); } else if (command.equals("/reload")) { reload(writer, path); } else if (command.equals("/remove")) { undeploy(writer, path); } else if (command.equals("/resources")) { resources(writer, type); } else if (command.equals("/roles")) { roles(writer); } else if (command.equals("/save")) { save(writer, path); } else if (command.equals("/serverinfo")) { serverinfo(writer); } else if (command.equals("/expire")) { expireSessions(writer, path, request); } else if (command.equals("/start")) { start(writer, path); } else if (command.equals("/stop")) { stop(writer, path); } else if (command.equals("/undeploy")) { undeploy(writer, path); } else { writer.println(sm.getString("managerServlet.unknownCommand", command)); } writer.flush(); writer.close(); }
private String createTagHandlerPoolName(String prefix, String shortName, Attributes attrs, boolean hasEmptyBody) { String poolName = null; poolName = "_jspx_tagPool_" + prefix + "_" + shortName; if (attrs != null) { String[] attrNames = new String[attrs.getLength()]; for (int i = 0; i < attrNames.length; i++) { attrNames[i] = attrs.getQName(i); } Arrays.sort(attrNames, Collections.reverseOrder()); for (int i = 0; i < attrNames.length; i++) { poolName = poolName + "_" + attrNames[i]; } } if (hasEmptyBody) { poolName = poolName + "_nobody"; } return JspUtil.makeJavaIdentifier(poolName); }

void generateClass(String[] smap) throws FileNotFoundException, JasperException, Exception { long t1 = 0; if (log.isDebugEnabled()) { t1 = System.currentTimeMillis(); } String javaEncoding = ctxt.getOptions().getJavaEncoding(); String javaFileName = ctxt.getServletJavaFileName(); String classpath = ctxt.getClassPath(); String sep = System.getProperty("path.separator"); StringBuffer errorReport = new StringBuffer(); StringBuffer info = new StringBuffer(); info.append("Compile: javaFileName=" + javaFileName + "\n"); info.append(" classpath=" + classpath + "\n"); SystemLogHandler.setThread(); getProject(); Javac javac = (Javac) project.createTask("javac"); Path path = new Path(project); path.setPath(System.getProperty("java.class.path")); info.append(" cp=" + System.getProperty("java.class.path") + "\n"); StringTokenizer tokenizer = new StringTokenizer(classpath, sep); while (tokenizer.hasMoreElements()) { String pathElement = tokenizer.nextToken(); File repository = new File(pathElement); path.setLocation(repository); info.append(" cp=" + repository + "\n"); } if (log.isDebugEnabled()) log.debug("Using classpath: " + System.getProperty("java.class.path") + sep + classpath); Path srcPath = new Path(project); srcPath.setLocation(options.getScratchDir()); info.append(" work dir=" + options.getScratchDir() + "\n"); String exts = System.getProperty("java.ext.dirs"); if (exts != null) { Path extdirs = new Path(project); extdirs.setPath(exts); javac.setExtdirs(extdirs); info.append(" extension dir=" + exts + "\n"); } if (ctxt.getOptions().getFork()) { String endorsed = System.getProperty("java.endorsed.dirs"); if (endorsed != null) { Javac.ImplementationSpecificArgument endorsedArg = javac.createCompilerArg(); endorsedArg.setLine("-J-Djava.endorsed.dirs=" + endorsed); info.append(" endorsed dir=" + endorsed + "\n"); } else { info.append(" no endorsed dirs specified\n"); } } javac.setEncoding(javaEncoding); javac.setClasspath(path); javac.setDebug(ctxt.getOptions().getClassDebugInfo()); javac.setSrcdir(srcPath); javac.setTempdir(options.getScratchDir()); javac.setOptimize(!ctxt.getOptions().getClassDebugInfo()); javac.setFork(ctxt.getOptions().getFork()); info.append(" srcDir=" + srcPath + "\n"); if (options.getCompiler() != null) { javac.setCompiler(options.getCompiler()); info.append(" compiler=" + options.getCompiler() + "\n"); } if (options.getCompilerTargetVM() != null) { javac.setTarget(options.getCompilerTargetVM()); info.append(" compilerTargetVM=" + options.getCompilerTargetVM() + "\n"); } if (options.getCompilerSourceVM() != null) { javac.setSource(options.getCompilerSourceVM()); info.append(" compilerSourceVM=" + options.getCompilerSourceVM() + "\n"); } PatternSet.NameEntry includes = javac.createInclude(); includes.setName(ctxt.getJavaPath()); info.append(" include=" + ctxt.getJavaPath() + "\n"); BuildException be = null; try { if (ctxt.getOptions().getFork()) { javac.execute(); } else { synchronized (javacLock) { javac.execute(); } } } catch (BuildException e) { be = e; log.error(Localizer.getMessage("jsp.error.javac"), e); log.error(Localizer.getMessage("jsp.error.javac.env") + info.toString()); } errorReport.append(logger.getReport()); String errorCapture = SystemLogHandler.unsetThread(); if (errorCapture != null) { errorReport.append(System.getProperty("line.separator")); errorReport.append(errorCapture); } if (!ctxt.keepGenerated()) { File javaFile = new File(javaFileName); javaFile.delete(); } if (be != null) { String errorReportString = errorReport.toString(); log.error(Localizer.getMessage("jsp.error.compilation", javaFileName, errorReportString)); JavacErrorDetail[] javacErrors = ErrorDispatcher.parseJavacErrors(errorReportString, javaFileName, pageNodes); if (javacErrors != null) { errDispatcher.javacError(javacErrors); } else { errDispatcher.javacError(errorReportString, be); } } if (log.isDebugEnabled()) { long t2 = System.currentTimeMillis(); log.debug("Compiled " + ctxt.getServletJavaFileName() + " " + (t2 - t1) + "ms"); } logger = null; project = null; if (ctxt.isPrototypeMode()) { return; } if (!options.isSmapSuppressed()) { SmapUtil.installSmap(smap); } }
protected void applicationWebConfig() { String altDDName = null; InputStream stream = null; ServletContext servletContext = context.getServletContext(); if (servletContext != null) { altDDName = (String) servletContext.getAttribute(Globals.ALT_DD_ATTR); if (altDDName != null) { try { stream = new FileInputStream(altDDName); } catch (FileNotFoundException e) { log.error(sm.getString("contextConfig.altDDNotFound", altDDName)); } } else { stream = servletContext.getResourceAsStream(Constants.ApplicationWebXml); } } if (stream == null) { if (log.isDebugEnabled()) { log.debug(sm.getString("contextConfig.applicationMissing") + " " + context); } return; } long t1 = System.currentTimeMillis(); if (webDigester == null) { webDigester = createWebDigester(); } URL url = null; synchronized (webDigester) { try { if (altDDName != null) { url = new File(altDDName).toURL(); } else { url = servletContext.getResource(Constants.ApplicationWebXml); } if (url != null) { InputSource is = new InputSource(url.toExternalForm()); is.setByteStream(stream); if (context instanceof StandardContext) { ((StandardContext) context).setReplaceWelcomeFiles(true); } webDigester.push(context); webDigester.setErrorHandler(new ContextErrorHandler()); if (log.isDebugEnabled()) { log.debug("Parsing application web.xml file at " + url.toExternalForm()); } webDigester.parse(is); if (parseException != null) { ok = false; } } else { log.info("No web.xml, using defaults " + context); } } catch (SAXParseException e) { log.error(sm.getString("contextConfig.applicationParse", url.toExternalForm()), e); log.error(sm.getString("contextConfig.applicationPosition", "" + e.getLineNumber(), "" + e.getColumnNumber())); ok = false; } catch (Exception e) { log.error(sm.getString("contextConfig.applicationParse", url.toExternalForm()), e); ok = false; } finally { webDigester.reset(); parseException = null; try { if (stream != null) { stream.close(); } } catch (IOException e) { log.error(sm.getString("contextConfig.applicationClose"), e); } } } webRuleSet.recycle(); long t2 = System.currentTimeMillis(); if (context instanceof StandardContext) { ((StandardContext) context).setStartupTime(t2 - t1); } }	protected void defaultWebConfig() { long t1 = System.currentTimeMillis(); if (defaultWebXml == null && context instanceof StandardContext) { defaultWebXml = ((StandardContext) context).getDefaultWebXml(); } if (defaultWebXml == null) getDefaultWebXml(); File file = new File(this.defaultWebXml); if (!file.isAbsolute()) { file = new File(getBaseDir(), this.defaultWebXml); } InputStream stream = null; InputSource source = null; try { if (!file.exists()) { stream = getClass().getClassLoader().getResourceAsStream(defaultWebXml); if (stream != null) { source = new InputSource(getClass().getClassLoader().getResource(defaultWebXml).toString()); } if (stream == null) { stream = getClass().getClassLoader().getResourceAsStream("web-embed.xml"); if (stream != null) { source = new InputSource(getClass().getClassLoader().getResource("web-embed.xml").toString()); } } if (stream == null) { log.info("No default web.xml"); } } else { source = new InputSource("file://" + file.getAbsolutePath()); stream = new FileInputStream(file); context.addWatchedResource(file.getAbsolutePath()); } } catch (Exception e) { log.error(sm.getString("contextConfig.defaultMissing") + " " + defaultWebXml + " " + file, e); } if (webDigester == null) { webDigester = createWebDigester(); } if (stream != null) { processDefaultWebConfig(webDigester, stream, source); webRuleSet.recycle(); } long t2 = System.currentTimeMillis(); if ((t2 - t1) > 200) log.debug("Processed default web.xml " + file + " " + (t2 - t1)); stream = null; source = null; String resourceName = getHostConfigPath(Constants.HostWebXml); file = new File(getConfigBase(), resourceName); try { if (!file.exists()) { stream = getClass().getClassLoader().getResourceAsStream(resourceName); if (stream != null) { source = new InputSource(getClass().getClassLoader().getResource(resourceName).toString()); } } else { source = new InputSource("file://" + file.getAbsolutePath()); stream = new FileInputStream(file); } } catch (Exception e) { log.error(sm.getString("contextConfig.defaultMissing") + " " + resourceName + " " + file, e); } if (stream != null) { processDefaultWebConfig(webDigester, stream, source); webRuleSet.recycle(); } }	protected void init() { if (log.isDebugEnabled()) log.debug(sm.getString("contextConfig.init")); context.setConfigured(false); ok = true; contextConfig(); try { fixDocBase(); } catch (IOException e) { log.error(sm.getString("contextConfig.fixDocBase"), e); } }	protected void processContextConfig(File baseDir, String resourceName) { if (log.isDebugEnabled()) log.debug("Processing context [" + context.getName() + "] configuration file " + baseDir + " " + resourceName); InputSource source = null; InputStream stream = null; File file = baseDir; if (resourceName != null) { file = new File(baseDir, resourceName); } try { if (!file.exists()) { if (resourceName != null) { stream = getClass().getClassLoader().getResourceAsStream(resourceName); if (stream != null) { source = new InputSource(getClass().getClassLoader().getResource(resourceName).toString()); } } } else { source = new InputSource("file://" + file.getAbsolutePath()); stream = new FileInputStream(file); // Add as watched resource so that cascade reload occurs if a default context.addWatchedResource(file.getAbsolutePath()); } } catch (Exception e) { log.error(sm.getString("contextConfig.contextMissing", resourceName + " " + file), e); } if (source == null) return; if (contextDigester == null) { contextDigester = createContextDigester(); } synchronized (contextDigester) { try { source.setByteStream(stream); contextDigester.setClassLoader(this.getClass().getClassLoader()); contextDigester.setUseContextClassLoader(false); contextDigester.push(context.getParent()); contextDigester.push(context); contextDigester.setErrorHandler(new ContextErrorHandler()); contextDigester.parse(source); if (parseException != null) { ok = false; } if (log.isDebugEnabled()) log.debug("Successfully processed context [" + context.getName() + "] configuration file " + baseDir + " " + resourceName); } catch (SAXParseException e) { log.error(sm.getString("contextConfig.contextParse", context.getName()), e); log.error(sm.getString("contextConfig.defaultPosition", "" + e.getLineNumber(), "" + e.getColumnNumber())); ok = false; } catch (Exception e) { log.error(sm.getString("contextConfig.contextParse", context.getName()), e); ok = false; } finally { contextDigester.reset(); parseException = null; try { if (stream != null) { stream.close(); } } catch (IOException e) { log.error(sm.getString("contextConfig.contextClose"), e); } } } }
private Map<String, File> getJarPaths() { HashMap<String, File> jarPathMap = null; ClassLoader webappLoader = Thread.currentThread().getContextClassLoader(); ClassLoader loader = webappLoader; while (loader != null) { if (loader instanceof URLClassLoader) { URL[] urls = ((URLClassLoader) loader).getURLs(); for (int i = 0; i < urls.length; i++) { // Expect file URLs, these are %xx encoded or not depending on // the class loader // This is definitely not as clean as using JAR URLs either // over file or the custom jndi handler, but a lot less File file = null; try { file = new File(urls[i].toURI()); } catch (URISyntaxException e) { file = new File(urls[i].getFile()); } try { file = file.getCanonicalFile(); } catch (IOException e) { // Ignore } if (!file.exists()) { continue; } String path = file.getAbsolutePath(); if (!path.endsWith(".jar")) { continue; } if (loader == webappLoader || noTldJars == null || !noTldJars.contains(file.getName())) { if (jarPathMap == null) { jarPathMap = new HashMap<String, File>(); jarPathMap.put(path, file); } else if (!jarPathMap.containsKey(path)) { jarPathMap.put(path, file); } } } } loader = loader.getParent(); } return jarPathMap; }
private static String getJNDIUri(String hostName, String path) { if (!path.startsWith("/")) return "/" + hostName + "/" + path; else return "/" + hostName + path; }
protected String[] parseParamValues(StringBuffer cmd, int start, int count) { int valIndex = 0; boolean inside = false; String[] vals = new String[count]; StringBuffer sb = new StringBuffer(); char endQuote = 0; for (int bIdx = start; bIdx < cmd.length(); bIdx++) { if (!inside) { while (bIdx < cmd.length() && !isQuote(cmd.charAt(bIdx))) bIdx++; if (bIdx >= cmd.length()) break; inside = !inside; endQuote = cmd.charAt(bIdx); } else { boolean escaped = false; for (; bIdx < cmd.length(); bIdx++) { char c = cmd.charAt(bIdx); if (c == '\\' && !escaped) { escaped = true; continue; } if (c == endQuote && !escaped) break; if (c == '$' && escaped) sb.append('\\'); escaped = false; sb.append(c); } if (bIdx == cmd.length()) return null; vals[valIndex++] = sb.toString(); sb.delete(0, sb.length()); inside = !inside; } } return vals; }
protected String encode(String value, String encoding) { String retVal = null; if (encoding.equalsIgnoreCase("url")) { retVal = urlEncoder.encode(value); } else if (encoding.equalsIgnoreCase("none")) { retVal = value; } else if (encoding.equalsIgnoreCase("entity")) { retVal = value; } else { throw new IllegalArgumentException("Unknown encoding: " + encoding); } return retVal; }	public String substituteVariables(String val) { if (val.indexOf('$') < 0) return val; StringBuffer sb = new StringBuffer(val); for (int i = 0; i < sb.length(); ) { for (; i < sb.length(); i++) { if (sb.charAt(i) == '$') { i++; break; } } if (i == sb.length()) break; if (i > 1 && sb.charAt(i - 2) == '\\') { sb.deleteCharAt(i - 2); i--; continue; } int nameStart = i; int start = i - 1; int end = -1; int nameEnd = -1; char endChar = ' '; if (sb.charAt(i) == '{') { nameStart++; endChar = '}'; } for (; i < sb.length(); i++) { if (sb.charAt(i) == endChar) break; } end = i; nameEnd = end; if (endChar == '}') end++; String varName = sb.substring(nameStart, nameEnd); String value = getVariableValue(varName); if (value == null) value = ""; sb.replace(start, end, value); // Start searching for the next $ after the value i = start + value.length(); } return sb.toString(); }	public long process(SSIMediator ssiMediator, String commandName, String[] paramNames, String[] paramValues, PrintWriter writer) { long lastModified = 0; String encoding = DEFAULT_ENCODING; String errorMessage = ssiMediator.getConfigErrMsg(); for (int i = 0; i < paramNames.length; i++) { String paramName = paramNames[i]; String paramValue = paramValues[i]; if (paramName.equalsIgnoreCase("var")) { String variableValue = ssiMediator.getVariableValue(paramValue, encoding); if (variableValue == null) { variableValue = MISSING_VARIABLE_VALUE; } writer.write(variableValue); lastModified = System.currentTimeMillis(); } else if (paramName.equalsIgnoreCase("encoding")) { if (isValidEncoding(paramValue)) { encoding = paramValue; } else { ssiMediator.log("#echo--Invalid encoding: " + paramValue); writer.write(errorMessage); } } else { ssiMediator.log("#echo--Invalid attribute: " + paramName); writer.write(errorMessage); } } return lastModified; }
/** * Proprietary method to evaluate EL expressions. XXX - This method should * go away once the EL interpreter moves out of JSTL and into its own * project. For now, this is necessary because the standard machinery is too * slow. * * @param expression * The expression to be evaluated * @param expectedType * The expected resulting type * @param pageContext * The page context * @param functionMap * Maps prefix and name to Method * @return The result of the evaluation */ public static Object proprietaryEvaluate(final String expression, final Class expectedType, final PageContext pageContext, final ProtectedFunctionMapper functionMap, final boolean escape) throws ELException { Object retValue; final ExpressionFactory exprFactory = JspFactory.getDefaultFactory().getJspApplicationContext(pageContext.getServletContext()).getExpressionFactory(); if (SecurityUtil.isPackageProtectionEnabled()) { try { retValue = AccessController .doPrivileged(new PrivilegedExceptionAction() { } } } }
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { this.functions = (Map) in.readObject(); }
public boolean offer(Runnable o) { if (parent == null) return super.offer(o); if (parent.getPoolSize() == parent.getMaximumPoolSize()) return super.offer(o); if (parent.getActiveCount() < (parent.getPoolSize())) return super.offer(o); if (parent.getPoolSize() < parent.getMaximumPoolSize()) return false; return super.offer(o); }	public int getPoolSize() { return (executor != null) ? executor.getPoolSize() : 0; }
public boolean hasResourcePermission(Request request, Response response, SecurityConstraint[] constraints, Context context) throws IOException { if (constraints == null || constraints.length == 0) return (true); // Specifically allow access to the form login and form error pages LoginConfig config = context.getLoginConfig(); if ((config != null) && (Constants.FORM_METHOD.equals(config.getAuthMethod()))) { String requestURI = request.getRequestPathMB().toString(); String loginPage = config.getLoginPage(); if (loginPage.equals(requestURI)) { if (log.isDebugEnabled()) log.debug(" Allow access to login page " + loginPage); return (true); } String errorPage = config.getErrorPage(); if (errorPage.equals(requestURI)) { if (log.isDebugEnabled()) log.debug(" Allow access to error page " + errorPage); return (true); } if (requestURI.endsWith(Constants.FORM_ACTION)) { if (log.isDebugEnabled()) log.debug(" Allow access to username/password submission"); return (true); } } Principal principal = request.getPrincipal(); boolean status = false; boolean denyfromall = false; for (int i = 0; i < constraints.length; i++) { SecurityConstraint constraint = constraints[i]; String[] roles; if (constraint.getAllRoles()) { roles = request.getContext().findSecurityRoles(); } else { roles = constraint.findAuthRoles(); } if (roles == null) roles = new String[0]; if (log.isDebugEnabled()) log.debug(" Checking roles " + principal); if (roles.length == 0 && !constraint.getAllRoles()) { if (constraint.getAuthConstraint()) { if (log.isDebugEnabled()) log.debug("No roles "); status = false; denyfromall = true; } else { if (log.isDebugEnabled()) log.debug("Passing all access"); return (true); } } else if (principal == null) { if (log.isDebugEnabled()) log.debug(" No user authenticated, cannot grant access"); status = false; } else if (!denyfromall) { for (int j = 0; j < roles.length; j++) { if (hasRole(principal, roles[j])) status = true; if (log.isDebugEnabled()) log.debug("No role found: " + roles[j]); } } } if (allRolesMode != AllRolesMode.STRICT_MODE && !status && principal != null) { if (log.isDebugEnabled()) { log.debug("Checking for all roles mode: " + allRolesMode); } for (int i = 0; i < constraints.length; i++) { SecurityConstraint constraint = constraints[i]; String[] roles; if (constraint.getAllRoles()) { if (allRolesMode == AllRolesMode.AUTH_ONLY_MODE) { if (log.isDebugEnabled()) { log.debug("Granting access for role-name=*, auth-only"); } status = true; break; } roles = request.getContext().findSecurityRoles(); if (roles.length == 0 && allRolesMode == AllRolesMode.STRICT_AUTH_ONLY_MODE) { if (log.isDebugEnabled()) { log.debug("Granting access for role-name=*, strict auth-only"); } status = true; break; } } } } if (!status) { response.sendError(HttpServletResponse.SC_FORBIDDEN, sm.getString("realmBase.forbidden")); } return status; }
public boolean ready() throws IOException { return (available() > 0); }	public int read() throws IOException { return cb.substract(); }	public int read(byte[] b, int off, int len) throws IOException { return bb.substract(b, off, len); }	public int read(char[] cbuf) throws IOException { return read(cbuf, 0, cbuf.length); }	public int read(char[] cbuf, int off, int len) throws IOException { return cb.substract(cbuf, off, len); }	public int readByte() throws IOException { return bb.substract(); }	public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException(); } long nRead = 0; while (nRead < n) { if (cb.getLength() >= n) { cb.setOffset(cb.getStart() + (int) n); nRead = n; } else { nRead += cb.getLength(); cb.setOffset(cb.getEnd()); int toRead = 0; if (cb.getChars().length < (n - nRead)) { toRead = cb.getChars().length; } else { toRead = (int) (n - nRead); } int nb = realReadChars(cb.getChars(), 0, toRead); if (nb < 0) break; } } return nRead; }	public void mark(int readAheadLimit) throws IOException { if (cb.getLength() <= 0) { cb.setOffset(0); cb.setEnd(0); } else { if ((cb.getBuffer().length > (2 * size)) && (cb.getLength()) < (cb.getStart())) { System.arraycopy(cb.getBuffer(), cb.getStart(), cb.getBuffer(), 0, cb.getLength()); cb.setEnd(cb.getLength()); cb.setOffset(0); } } int offset = readAheadLimit; if (offset < size) { offset = size; } cb.setLimit(cb.getStart() + offset); markPos = cb.getStart(); }	public void reset() throws IOException { if (state == CHAR_STATE) { if (markPos < 0) { cb.recycle(); markPos = -1; throw new IOException(); } else { cb.setOffset(markPos); } } else { bb.recycle(); } }
public void event(Request request, Response response, CometEvent event) throws IOException, ServletException { boolean ok = false; try { getNext().event(request, response, event); ok = true; } finally { if (!ok || response.isClosed() || (event.getEventType() == CometEvent.EventType.END) || (event.getEventType() == CometEvent.EventType.ERROR && !(event.getEventSubType() == CometEvent.EventSubType.TIMEOUT))) { HttpSession session = request.getSession(true); synchronized (session) { ConnectionInfo[] connectionInfos = connections.get(session.getId()); if (connectionInfos != null) { boolean found = false; for (int i = 0; !found && (i < connectionInfos.length); i++) { found = (connectionInfos[i].request == request); } if (found) { ConnectionInfo[] newConnectionInfos = new ConnectionInfo[connectionInfos.length - 1]; int pos = 0; for (int i = 0; i < connectionInfos.length; i++) { if (connectionInfos[i].request != request) { newConnectionInfos[pos++] = connectionInfos[i]; } } connections.put(session.getId(), newConnectionInfos); } } } } } }	public void invoke(Request request, Response response) throws IOException, ServletException { getNext().invoke(request, response); if (request.isComet() && !response.isClosed()) { // Start tracking this connection, since this is a HttpSession session = request.getSession(true); ConnectionInfo newConnectionInfo = new ConnectionInfo(); newConnectionInfo.request = request; newConnectionInfo.response = response; newConnectionInfo.event = request.getEvent(); synchronized (session) { String id = session.getId(); ConnectionInfo[] connectionInfos = connections.get(id); if (connectionInfos == null) { connectionInfos = new ConnectionInfo[1]; connectionInfos[0] = newConnectionInfo; connections.put(id, connectionInfos); } else { ConnectionInfo[] newConnectionInfos = new ConnectionInfo[connectionInfos.length + 1]; for (int i = 0; i < connectionInfos.length; i++) { newConnectionInfos[i] = connectionInfos[i]; } newConnectionInfos[connectionInfos.length] = newConnectionInfo; connections.put(id, newConnectionInfos); } } } }	public void lifecycleEvent(LifecycleEvent event) { if (event.getType() == Lifecycle.BEFORE_STOP_EVENT) { // The webapp is getting stopped, so all current connections // should be closed Iterator<ConnectionInfo[]> iterator = connections.values().iterator(); while (iterator.hasNext()) { ConnectionInfo[] connectionInfos = iterator.next(); if (connectionInfos != null) { for (int i = 0; i < connectionInfos.length; i++) { ConnectionInfo connectionInfo = connectionInfos[i]; try { ((CometEventImpl) connectionInfo.event).setEventType(CometEvent.EventType.END); ((CometEventImpl) connectionInfo.event).setEventSubType(CometEvent.EventSubType.WEBAPP_RELOAD); getNext().event(connectionInfo.request, connectionInfo.response, connectionInfo.event); connectionInfo.event.close(); } catch (Exception e) { container.getLogger().warn(sm.getString("cometConnectionManagerValve.event"), e); } } } } connections.clear(); } }	public void sessionDestroyed(HttpSessionEvent se) { ConnectionInfo[] connectionInfos = connections.remove(se.getSession().getId()); if (connectionInfos != null) { for (int i = 0; i < connectionInfos.length; i++) { ConnectionInfo connectionInfo = connectionInfos[i]; try { ((CometEventImpl) connectionInfo.event).setEventType(CometEvent.EventType.END); ((CometEventImpl) connectionInfo.event).setEventSubType(CometEvent.EventSubType.SESSION_END); getNext().event(connectionInfo.request, connectionInfo.response, connectionInfo.event); connectionInfo.event.close(); } catch (Exception e) { container.getLogger().warn(sm.getString("cometConnectionManagerValve.event"), e); } } } }	public void stop() throws LifecycleException { if (!started) throw new LifecycleException(sm.getString("semaphoreValve.notStarted")); lifecycle.fireLifecycleEvent(STOP_EVENT, null); started = false; if (container instanceof Context) { ((Lifecycle) container).removeLifecycleListener(this); } // The webapp is getting stopped, so all current connections // should be closed // Close all Comet connections associated with this session // Note: this will only be done if the container was not a Context // (otherwise, this needs to be done before stop, as the servlet would Iterator<ConnectionInfo[]> iterator = connections.values().iterator(); while (iterator.hasNext()) { ConnectionInfo[] connectionInfos = iterator.next(); if (connectionInfos != null) { for (int i = 0; i < connectionInfos.length; i++) { ConnectionInfo connectionInfo = connectionInfos[i]; try { connectionInfo.event.close(); } catch (Exception e) { container.getLogger().warn(sm.getString("cometConnectionManagerValve.event"), e); } } } } connections.clear(); }
void init() throws Exception { if (initialized) return; if (acceptorThreadCount == 0) { acceptorThreadCount = 1; } if (serverSocketFactory == null) { serverSocketFactory = ServerSocketFactory.getDefault(); } if (serverSocket == null) { try { if (address == null) { serverSocket = serverSocketFactory.createSocket(port, backlog); } else { serverSocket = serverSocketFactory.createSocket(port, backlog, address); } } catch (BindException be) { throw new BindException(be.getMessage() + ":" + port); } } //if( serverTimeout >= 0 ) initialized = true; }
public PrintWriter getWriter() throws UnsupportedEncodingException { if (writer == null) { OutputStreamWriter w; w = new OutputStreamWriter(noBody, getCharacterEncoding()); writer = new PrintWriter(w); } return writer; }	public ServletOutputStream getOutputStream() throws IOException { return noBody; }	public String getCharacterEncoding() { return resp.getCharacterEncoding(); }	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { HttpServletRequest request; HttpServletResponse response; try { request = (HttpServletRequest) req; response = (HttpServletResponse) res; } catch (ClassCastException e) { throw new ServletException("non-HTTP request or response"); } service(request, response); }	public void setContentLength(int len) { resp.setContentLength(len); didSetContentLength = true; }	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { HttpServletRequest request; HttpServletResponse response; try { request = (HttpServletRequest) req; response = (HttpServletResponse) res; } catch (ClassCastException e) { throw new ServletException("non-HTTP request or response"); } service(request, response); }
protected InputStream findXsltInputStream(DirContext directory) throws IOException, ServletException { if (localXsltFile != null) { try { Object obj = directory.lookup(localXsltFile); if ((obj != null) && (obj instanceof Resource)) { InputStream is = ((Resource) obj).streamContent(); if (is != null) return is; } } catch (NamingException e) { throw new ServletException("Error opening XSLT resource", e); } } if (globalXsltFile != null) { FileInputStream fis = null; try { File f = new File(globalXsltFile); if (f.exists()) { fis = new FileInputStream(f); byte[] b = new byte[(int) f.length()]; fis.read(b); return new ByteArrayInputStream(b); } } finally { if (fis != null) fis.close(); } } return null; }	protected String getReadme(DirContext directory) throws IOException, ServletException { if (readmeFile != null) { try { Object obj = directory.lookup(readmeFile); if ((obj != null) && (obj instanceof Resource)) { StringWriter buffer = new StringWriter(); InputStream is = ((Resource) obj).streamContent(); copyRange(new InputStreamReader(is), new PrintWriter(buffer)); return buffer.toString(); } } catch (NamingException e) { throw new ServletException("Error opening readme resource", e); } } return null; }
protected boolean processSocket(NioChannel socket, SocketStatus status, boolean dispatch) { try { KeyAttachment attachment = (KeyAttachment) socket.getAttachment(false); attachment.setCometNotify(false); if (executor == null) { getWorkerThread().assign(socket, status); } else { SocketProcessor sc = processorCache.poll(); if (sc == null) sc = new SocketProcessor(socket, status); else sc.reset(socket, status); if (dispatch) executor.execute(sc); else sc.run(); } } catch (Throwable t) { // This means we got an OOM or similar creating a thread, or that log.error(sm.getString("endpoint.process.fail"), t); return false; } return true; }
public Class findClass(String name) throws ClassNotFoundException { if (log.isDebugEnabled()) log.debug(" findClass(" + name + ")"); if (!started) { throw new ClassNotFoundException(name); } if (securityManager != null) { int i = name.lastIndexOf('.'); if (i >= 0) { try { if (log.isTraceEnabled()) log.trace(" securityManager.checkPackageDefinition"); securityManager.checkPackageDefinition(name.substring(0, i)); } catch (Exception se) { if (log.isTraceEnabled()) log.trace(" -->Exception-->ClassNotFoundException", se); throw new ClassNotFoundException(name, se); } } } // Ask our superclass to locate this class, if possible Class clazz = null; try { if (log.isTraceEnabled()) log.trace(" findClassInternal(" + name + ")"); try { clazz = findClassInternal(name); } catch (ClassNotFoundException cnfe) { if (!hasExternalRepositories) { throw cnfe; } } catch (AccessControlException ace) { throw new ClassNotFoundException(name, ace); } catch (RuntimeException e) { if (log.isTraceEnabled()) log.trace(" -->RuntimeException Rethrown", e); throw e; } if ((clazz == null) && hasExternalRepositories) { try { synchronized (this) { clazz = super.findClass(name); } } catch (AccessControlException ace) { throw new ClassNotFoundException(name, ace); } catch (RuntimeException e) { if (log.isTraceEnabled()) log.trace(" -->RuntimeException Rethrown", e); throw e; } } if (clazz == null) { if (log.isDebugEnabled()) log.debug(" --> Returning ClassNotFoundException"); throw new ClassNotFoundException(name); } } catch (ClassNotFoundException e) { if (log.isTraceEnabled()) log.trace(" --> Passing on ClassNotFoundException"); throw e; } if (log.isTraceEnabled()) log.debug(" Returning class " + clazz); if ((log.isTraceEnabled()) && (clazz != null)) log.debug(" Loaded by " + clazz.getClassLoader()); return (clazz); }	public Object run() { return findResourceInternal(file, path); }
public void addApplicationListener(String listener) { synchronized (applicationListeners) { String[] results = new String[applicationListeners.length + 1]; for (int i = 0; i < applicationListeners.length; i++) { if (listener.equals(applicationListeners[i])) return; results[i] = applicationListeners[i]; } results[applicationListeners.length] = listener; applicationListeners = results; } fireContainerEvent("addApplicationListener", listener); // FIXME - add instance if already started? }
protected KeyStore getTrustStore(String keystoreType) throws IOException { KeyStore trustStore = null; String trustStoreFile = (String) attributes.get("truststoreFile"); if (trustStoreFile == null) { trustStoreFile = System.getProperty("javax.net.ssl.trustStore"); } if (log.isDebugEnabled()) { log.debug("Truststore = " + trustStoreFile); } String trustStorePassword = (String) attributes.get("truststorePass"); if (trustStorePassword == null) { trustStorePassword = System.getProperty("javax.net.ssl.trustStorePassword"); } if (trustStorePassword == null) { trustStorePassword = getKeystorePassword(); } if (log.isDebugEnabled()) { log.debug("TrustPass = " + trustStorePassword); } String truststoreType = (String) attributes.get("truststoreType"); if (truststoreType == null) { truststoreType = keystoreType; } if (log.isDebugEnabled()) { log.debug("trustType = " + truststoreType); } if (trustStoreFile != null && trustStorePassword != null) { trustStore = getStore(truststoreType, trustStoreFile, trustStorePassword); } return trustStore; }
public void list(HttpServletRequest request, HttpServletResponse response, String message) throws IOException { if (debug >= 1) log("list: Listing contexts for virtual host '" + host.getName() + "'"); PrintWriter writer = response.getWriter(); writer.print(Constants.HTML_HEADER_SECTION); Object[] args = new Object[2]; args[0] = request.getContextPath(); args[1] = sm.getString("htmlManagerServlet.title"); writer.print(MessageFormat.format(Constants.BODY_HEADER_SECTION, args)); args = new Object[3]; args[0] = sm.getString("htmlManagerServlet.messageLabel"); if (message == null || message.length() == 0) { args[1] = "OK"; } else { args[1] = RequestUtil.filter(message); } writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args)); args = new Object[9]; args[0] = sm.getString("htmlManagerServlet.manager"); args[1] = response.encodeURL(request.getContextPath() + "/html/list"); args[2] = sm.getString("htmlManagerServlet.list"); args[3] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpHtmlManagerFile")); args[4] = sm.getString("htmlManagerServlet.helpHtmlManager"); args[5] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpManagerFile")); args[6] = sm.getString("htmlManagerServlet.helpManager"); args[7] = response.encodeURL(request.getContextPath() + "/status"); args[8] = sm.getString("statusServlet.title"); writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args)); args = new Object[6]; args[0] = sm.getString("htmlManagerServlet.appsTitle"); args[1] = sm.getString("htmlManagerServlet.appsPath"); args[2] = sm.getString("htmlManagerServlet.appsName"); args[3] = sm.getString("htmlManagerServlet.appsAvailable"); args[4] = sm.getString("htmlManagerServlet.appsSessions"); args[5] = sm.getString("htmlManagerServlet.appsTasks"); writer.print(MessageFormat.format(APPS_HEADER_SECTION, args)); // Apps Row Section Container[] children = host.findChildren(); String[] contextPaths = new String[children.length]; for (int i = 0; i < children.length; i++) contextPaths[i] = children[i].getName(); TreeMap sortedContextPathsMap = new TreeMap(); for (int i = 0; i < contextPaths.length; i++) { String displayPath = contextPaths[i]; sortedContextPathsMap.put(displayPath, contextPaths[i]); } String appsStart = sm.getString("htmlManagerServlet.appsStart"); String appsStop = sm.getString("htmlManagerServlet.appsStop"); String appsReload = sm.getString("htmlManagerServlet.appsReload"); String appsUndeploy = sm.getString("htmlManagerServlet.appsUndeploy"); String appsExpire = sm.getString("htmlManagerServlet.appsExpire"); Iterator iterator = sortedContextPathsMap.entrySet().iterator(); boolean isHighlighted = true; boolean isDeployed = true; String highlightColor = null; while (iterator.hasNext()) { isHighlighted = !isHighlighted; if (isHighlighted) { highlightColor = "#C3F3C3"; } else { highlightColor = "#FFFFFF"; } Map.Entry entry = (Map.Entry) iterator.next(); String displayPath = (String) entry.getKey(); String contextPath = (String) entry.getKey(); Context context = (Context) host.findChild(contextPath); if (displayPath.equals("")) { displayPath = "/"; } if (context != null) { try { isDeployed = isDeployed(contextPath); } catch (Exception e) { isDeployed = false; } args = new Object[6]; args[0] = displayPath; args[1] = context.getDisplayName(); if (args[1] == null) { args[1] = "&nbsp;"; } args[2] = new Boolean(context.getAvailable()); args[3] = response.encodeURL(request.getContextPath() + "/html/sessions?path=" + displayPath); if (context.getManager() != null) { args[4] = new Integer(context.getManager().getActiveSessions()); } else { args[4] = new Integer(0); } args[5] = highlightColor; writer.print(MessageFormat.format(APPS_ROW_DETAILS_SECTION, args)); args = new Object[14]; args[0] = response.encodeURL(request.getContextPath() + "/html/start?path=" + displayPath); args[1] = appsStart; args[2] = response.encodeURL(request.getContextPath() + "/html/stop?path=" + displayPath); args[3] = appsStop; args[4] = response.encodeURL(request.getContextPath() + "/html/reload?path=" + displayPath); args[5] = appsReload; args[6] = response.encodeURL(request.getContextPath() + "/html/undeploy?path=" + displayPath); args[7] = appsUndeploy; args[8] = response.encodeURL(request.getContextPath() + "/html/expire?path=" + displayPath); args[9] = appsExpire; args[10] = sm.getString("htmlManagerServlet.expire.explain"); args[11] = new Integer(context.getManager().getMaxInactiveInterval() / 60); args[12] = sm.getString("htmlManagerServlet.expire.unit"); args[13] = highlightColor; if (context.getPath().equals(this.context.getPath())) { writer.print(MessageFormat.format(MANAGER_APP_ROW_BUTTON_SECTION, args)); } else if (context.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STARTED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (context.getAvailable() && !isDeployed) { writer.print(MessageFormat.format(STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (!context.getAvailable() && isDeployed) { writer.print(MessageFormat.format(STOPPED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else { writer.print(MessageFormat.format(STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } } } args = new Object[7]; args[0] = sm.getString("htmlManagerServlet.deployTitle"); args[1] = sm.getString("htmlManagerServlet.deployServer"); args[2] = response.encodeURL(request.getContextPath() + "/html/deploy"); args[3] = sm.getString("htmlManagerServlet.deployPath"); args[4] = sm.getString("htmlManagerServlet.deployConfig"); args[5] = sm.getString("htmlManagerServlet.deployWar"); args[6] = sm.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(DEPLOY_SECTION, args)); args = new Object[4]; args[0] = sm.getString("htmlManagerServlet.deployUpload"); args[1] = response.encodeURL(request.getContextPath() + "/html/upload"); args[2] = sm.getString("htmlManagerServlet.deployUploadFile"); args[3] = sm.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(UPLOAD_SECTION, args)); args = new Object[7]; args[0] = sm.getString("htmlManagerServlet.serverTitle"); args[1] = sm.getString("htmlManagerServlet.serverVersion"); args[2] = sm.getString("htmlManagerServlet.serverJVMVersion"); args[3] = sm.getString("htmlManagerServlet.serverJVMVendor"); args[4] = sm.getString("htmlManagerServlet.serverOSName"); args[5] = sm.getString("htmlManagerServlet.serverOSVersion"); args[6] = sm.getString("htmlManagerServlet.serverOSArch"); writer.print(MessageFormat.format(Constants.SERVER_HEADER_SECTION, args)); args = new Object[6]; args[0] = ServerInfo.getServerInfo(); args[1] = System.getProperty("java.runtime.version"); args[2] = System.getProperty("java.vm.vendor"); args[3] = System.getProperty("os.name"); args[4] = System.getProperty("os.version"); args[5] = System.getProperty("os.arch"); writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args)); writer.print(Constants.HTML_TAIL_SECTION); writer.flush(); writer.close(); }
protected boolean parseCRLF() throws IOException { boolean eol = false; while (!eol) { if (pos >= lastValid) { if (readBytes() <= 0) throw new IOException("Invalid CRLF"); } if (buf[pos] == Constants.CR) { } else if (buf[pos] == Constants.LF) { eol = true; } else { throw new IOException("Invalid CRLF"); } pos++; } return true; }	public int doRead(ByteChunk chunk, Request req) throws IOException { if (endChunk) return -1; if (needCRLFParse) { needCRLFParse = false; parseCRLF(); } if (remaining <= 0) { if (!parseChunkHeader()) { throw new IOException("Invalid chunk header"); } if (endChunk) { parseEndChunk(); return -1; } } int result = 0; if (pos >= lastValid) { readBytes(); } if (remaining > (lastValid - pos)) { result = lastValid - pos; remaining = remaining - result; chunk.setBytes(buf, pos, result); pos = lastValid; } else { result = remaining; chunk.setBytes(buf, pos, remaining); pos = pos + remaining; remaining = 0; needCRLFParse = true; } return result; }
private void parseTaglibDirective(Node parent) throws JasperException { Attributes attrs = parseAttributes(); String uri = attrs.getValue("uri"); String prefix = attrs.getValue("prefix"); if (prefix != null) { Mark prevMark = pageInfo.getNonCustomTagPrefix(prefix); if (prevMark != null) { err.jspError(reader.mark(), "jsp.error.prefix.use_before_dcl", prefix, prevMark.getFile(), "" + prevMark.getLineNumber()); } if (uri != null) { String uriPrev = pageInfo.getURI(prefix); if (uriPrev != null && !uriPrev.equals(uri)) { err.jspError(reader.mark(), "jsp.error.prefix.refined", prefix, uri, uriPrev); } if (pageInfo.getTaglib(uri) == null) { TagLibraryInfoImpl impl = null; if (ctxt.getOptions().isCaching()) { impl = (TagLibraryInfoImpl) ctxt.getOptions().getCache().get(uri); } if (impl == null) { String[] location = ctxt.getTldLocation(uri); impl = new TagLibraryInfoImpl(ctxt, parserController, pageInfo, prefix, uri, location, err); if (ctxt.getOptions().isCaching()) { ctxt.getOptions().getCache().put(uri, impl); } } pageInfo.addTaglib(uri, impl); } pageInfo.addPrefixMapping(prefix, uri); } else { String tagdir = attrs.getValue("tagdir"); if (tagdir != null) { String urnTagdir = URN_JSPTAGDIR + tagdir; if (pageInfo.getTaglib(urnTagdir) == null) { pageInfo.addTaglib(urnTagdir, new ImplicitTagLibraryInfo(ctxt, parserController, pageInfo, prefix, tagdir, err)); } pageInfo.addPrefixMapping(prefix, urnTagdir); } } } new Node.TaglibDirective(attrs, start, parent); }
private void addToParent(Node parent) { if (parent != null) { this.parent = parent; Nodes parentBody = parent.getBody(); if (parentBody == null) { parentBody = new Nodes(); parent.setBody(parentBody); } parentBody.add(this); } }
public Method getInvoke(String aname, Object[] params, String[] signature, BaseModelMBean bean, Object resource) throws MBeanException, ReflectionException { Method method = null; if (method == null) { if (params == null) params = new Object[0]; if (signature == null) signature = new String[0]; if (params.length != signature.length) throw new RuntimeOperationsException(new IllegalArgumentException("Inconsistent arguments and signature"), "Inconsistent arguments and signature"); // Acquire the ModelMBeanOperationInfo information for OperationInfo opInfo = (OperationInfo) operations.get(aname); if (opInfo == null) throw new MBeanException(new ServiceNotFoundException("Cannot find operation " + aname), "Cannot find operation " + aname); // Prepare the signature required by Java reflection APIs Class[] types = new Class[signature.length]; for (int i = 0; i < signature.length; i++) { types[i] = BaseModelMBean.getAttributeClass(signature[i]); } // Locate the method to be invoked, either in this MBean itself // or in the corresponding managed resource Object object = null; Exception exception = null; try { object = this; method = object.getClass().getMethod(aname, types); } catch (NoSuchMethodException e) { exception = e; ; } try { if ((method == null) && (resource != null)) { object = resource; method = object.getClass().getMethod(aname, types); } } catch (NoSuchMethodException e) { exception = e; } if (method == null) { throw new ReflectionException(exception, "Cannot find method " + aname + " with this signature"); } // invokeAttMap.put(mkey, method); } return method; }	public Method getSetter(String aname, BaseModelMBean bean, Object resource) throws AttributeNotFoundException, MBeanException, ReflectionException { // Cache may be needed for getters, but it is a really bad idea for setters, this is far // less frequent. Method m = null; if (m == null) { AttributeInfo attrInfo = (AttributeInfo) attributes.get(aname); if (attrInfo == null) throw new AttributeNotFoundException(" Cannot find attribute " + aname); String setMethod = attrInfo.getSetMethod(); if (setMethod == null) throw new AttributeNotFoundException("Cannot find attribute " + aname + " set method name"); String argType = attrInfo.getType(); Class[] signature = new Class[] { BaseModelMBean.getAttributeClass(argType) }; Object object = null; NoSuchMethodException exception = null; try { object = this; m = object.getClass().getMethod(setMethod, signature); } catch (NoSuchMethodException e) { exception = e; ; } if (m == null && resource != null) { try { object = resource; m = object.getClass().getMethod(setMethod, signature); exception = null; } catch (NoSuchMethodException e) { exception = e; } } if (exception != null) throw new ReflectionException(exception, "Cannot find setter method " + setMethod + " " + resource); //setAttMap.put( name, m ); } return m; }
public void setValue(EvaluationContext ctx, Object value) throws ELException { Target t = getTarget(ctx); ctx.setPropertyResolved(false); ctx.getELResolver().setValue(ctx, t.base, t.property, value); }
public Date getCreationDate() { if (creation == -1L) { creation = file.lastModified(); } return super.getCreationDate(); }	public Date getLastModifiedDate() { if (lastModified == -1L) { lastModified = file.lastModified(); } return super.getLastModifiedDate(); }	public InputStream streamContent() throws IOException { if (binaryContent == null) { inputStream = new FileInputStream(file); } return super.streamContent(); }	public long getCreation() { if (creation != -1L) return creation; creation = file.lastModified(); return creation; }
protected boolean postParseRequest(org.apache.coyote.Request req, Request request, org.apache.coyote.Response res, Response response) throws Exception { if (!req.scheme().isNull()) { request.setSecure(req.scheme().equals("https")); } else { // use connector scheme and secure configuration, (defaults to req.scheme().setString(connector.getScheme()); request.setSecure(connector.getSecure()); } // FIXME: the code below doesnt belongs to here, // this is only have sense // in Http11, not in ajp13.. // At this point the Host header has been processed. String proxyName = connector.getProxyName(); int proxyPort = connector.getProxyPort(); if (proxyPort != 0) { req.setServerPort(proxyPort); } if (proxyName != null) { req.serverName().setString(proxyName); } parseSessionId(req, request); MessageBytes decodedURI = req.decodedURI(); decodedURI.duplicate(req.requestURI()); if (decodedURI.getType() == MessageBytes.T_BYTES) { ByteChunk uriBB = decodedURI.getByteChunk(); int semicolon = uriBB.indexOf(';', 0); if (semicolon > 0) { decodedURI.setBytes(uriBB.getBuffer(), uriBB.getStart(), semicolon); } try { req.getURLDecoder().convert(decodedURI, false); } catch (IOException ioe) { res.setStatus(400); res.setMessage("Invalid URI: " + ioe.getMessage()); return false; } if (!normalize(req.decodedURI())) { res.setStatus(400); res.setMessage("Invalid URI"); return false; } convertURI(decodedURI, request); } else { // The URL is chars or String, and has been sent using an in-memory // protocol handler, we have to assume the URL has been properly decodedURI.toChars(); CharChunk uriCC = decodedURI.getCharChunk(); int semicolon = uriCC.indexOf(';'); if (semicolon > 0) { decodedURI.setChars(uriCC.getBuffer(), uriCC.getStart(), semicolon); } } String principal = req.getRemoteUser().toString(); if (principal != null) { request.setUserPrincipal(new CoyotePrincipal(principal)); } String authtype = req.getAuthType().toString(); if (authtype != null) { request.setAuthType(authtype); } MessageBytes serverName; if (connector.getUseIPVHosts()) { serverName = req.localName(); if (serverName.isNull()) { res.action(ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE, null); } } else { serverName = req.serverName(); } connector.getMapper().map(serverName, decodedURI, request.getMappingData()); request.setContext((Context) request.getMappingData().context); request.setWrapper((Wrapper) request.getMappingData().wrapper); if (!connector.getAllowTrace() && req.method().equalsIgnoreCase("TRACE")) { Wrapper wrapper = request.getWrapper(); String header = null; if (wrapper != null) { String[] methods = wrapper.getServletMethods(); if (methods != null) { for (int i = 0; i < methods.length; i++) { if ("TRACE".equals(methods[i])) { continue; } if (header == null) { header = methods[i]; } else { header += ", " + methods[i]; } } } } res.setStatus(405); res.addHeader("Allow", header); res.setMessage("TRACE method is not allowed"); return false; } MessageBytes redirectPathMB = request.getMappingData().redirectPath; if (!redirectPathMB.isNull()) { String redirectPath = redirectPathMB.toString(); String query = request.getQueryString(); if (request.isRequestedSessionIdFromURL()) { // This is not optimal, but as this is not very common, it redirectPath = redirectPath + ";" + Globals.SESSION_PARAMETER_NAME + "=" + request.getRequestedSessionId(); } if (query != null) { // This is not optimal, but as this is not very common, it redirectPath = redirectPath + "?" + query; } response.sendRedirect(redirectPath); return false; } parseSessionCookiesId(req, request); return true; }
public void setPropertyResolved(boolean resolved) { this.elContext.setPropertyResolved(resolved); }
protected final Number coerce(final Object obj) { if (isNumber(obj)) { return coerce((Number) obj); } if (obj instanceof String) { return coerce((String) obj); } if (obj == null || "".equals(obj)) { return coerce(ZERO); } Class objType = obj.getClass(); if (Character.class.equals(objType) || Character.TYPE == objType) { return coerce(new Short((short) ((Character) obj).charValue())); } throw new IllegalArgumentException(MessageFactory.get("el.convert", obj, objType)); }
protected Comparator getComparator(String sortBy) { Comparator comparator = null; if ("CreationTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(session.getCreationTime()); } }; } else if ("id".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return session.getId(); } }; } else if ("LastAccessedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(session.getLastAccessedTime()); } }; } else if ("MaxInactiveInterval".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(session.getMaxInactiveInterval()); } }; } else if ("new".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return Boolean.valueOf(session.getSession().isNew()); } }; } else if ("locale".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return JspHelper.guessDisplayLocaleFromSession(session); } }; } else if ("user".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return JspHelper.guessDisplayUserFromSession(session); } }; } else if ("UsedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(SessionUtils.getUsedTimeForSession(session)); } }; } else if ("InactiveTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(SessionUtils.getInactiveTimeForSession(session)); } }; } else if ("TTL".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(SessionUtils.getTTLForSession(session)); } }; } return comparator; }
protected Principal createPrincipal(String username, Subject subject) { List<String> roles = new ArrayList<String>(); Principal userPrincipal = null; Iterator principals = subject.getPrincipals().iterator(); while (principals.hasNext()) { Principal principal = (Principal) principals.next(); String principalClass = principal.getClass().getName(); if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.checkPrincipal", principal, principalClass)); } if (userPrincipal == null && userClasses.contains(principalClass)) { userPrincipal = principal; if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.userPrincipalSuccess", principal.getName())); } } if (roleClasses.contains(principalClass)) { roles.add(principal.getName()); if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.rolePrincipalAdd", principal.getName())); } } } if (userPrincipal == null) { if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.userPrincipalFailure")); log.debug(sm.getString("jaasRealm.rolePrincipalFailure")); } } else { if (roles.size() == 0) { if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.rolePrincipalFailure")); } } } return new GenericPrincipal(this, username, null, roles, userPrincipal); }	protected void parseClassNames(String classNamesString, List<String> classNamesList) { classNamesList.clear(); if (classNamesString == null) return; String[] classNames = classNamesString.split("[ ]*,[ ]*"); for (int i = 0; i < classNames.length; i++) { if (classNames[i].length() == 0) continue; try { Class principalClass = Class.forName(classNames[i]); if (Principal.class.isAssignableFrom(principalClass)) { classNamesList.add(classNames[i]); } else { log.error("Class " + classNames[i] + " is not implementing " + "java.security.Principal! Class not added."); } } catch (ClassNotFoundException e) { log.error("Class " + classNames[i] + " not found! Class not added."); } } }	public Principal authenticate(String username, String credentials) { try { LoginContext loginContext = null; if (appName == null) appName = "Tomcat"; if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.beginLogin", username, appName)); ClassLoader ocl = null; if (isUseContextClassLoader()) { ocl = Thread.currentThread().getContextClassLoader(); Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); } try { loginContext = new LoginContext(appName, new JAASCallbackHandler(this, username, credentials)); } catch (Throwable e) { log.error(sm.getString("jaasRealm.unexpectedError"), e); return (null); } finally { if (isUseContextClassLoader()) { Thread.currentThread().setContextClassLoader(ocl); } } if (log.isDebugEnabled()) log.debug("Login context created " + username); Subject subject = null; try { loginContext.login(); subject = loginContext.getSubject(); if (subject == null) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.failedLogin", username)); return (null); } } catch (AccountExpiredException e) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.accountExpired", username)); return (null); } catch (CredentialExpiredException e) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.credentialExpired", username)); return (null); } catch (FailedLoginException e) { if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.failedLogin", username)); return (null); } catch (LoginException e) { log.warn(sm.getString("jaasRealm.loginException", username), e); return (null); } catch (Throwable e) { log.error(sm.getString("jaasRealm.unexpectedError"), e); return (null); } if (log.isDebugEnabled()) log.debug(sm.getString("jaasRealm.loginContextCreated", username)); Principal principal = createPrincipal(username, subject); if (principal == null) { log.debug(sm.getString("jaasRealm.authenticateFailure", username)); return (null); } if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.authenticateSuccess", username)); } return (principal); } catch (Throwable t) { log.error("error ", t); return null; } }	public String getRoleClassNames() { return (this.roleClassNames); }	public String getUserClassNames() { return (this.userClassNames); }	public void setRoleClassNames(String roleClassNames) { this.roleClassNames = roleClassNames; parseClassNames(roleClassNames, roleClasses); }	public void setUserClassNames(String userClassNames) { this.userClassNames = userClassNames; parseClassNames(userClassNames, userClasses); }	public void start() throws LifecycleException { super.start(); }
public void reset() { if (included) return; coyoteResponse.reset(); outputBuffer.reset(); }
private String normalize(String path) { if (path == null) { return null; } String normalized = path; if (normalized.indexOf('\\') >= 0) normalized = normalized.replace('\\', '/'); while (true) { int index = normalized.indexOf("/../"); if (index < 0) break; if (index == 0) return (null); int index2 = normalized.lastIndexOf('/', index - 1); normalized = normalized.substring(0, index2) + normalized.substring(index + 3); } return (normalized); }	public InputStream getResourceAsStream(String path) { path = normalize(path); if (path == null) return (null); DirContext resources = context.getResources(); if (resources != null) { try { Object resource = resources.lookup(path); if (resource instanceof Resource) return (((Resource) resource).streamContent()); } catch (Exception e) { } } return (null); }
public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { String command = request.getPathInfo(); if (command == null || !command.equals("/upload")) { doGet(request, response); return; } response.setContentType("text/html; charset=" + Constants.CHARSET); String message = ""; DiskFileUpload upload = new DiskFileUpload(); File tempdir = (File) getServletContext().getAttribute("javax.servlet.context.tempdir"); upload.setSizeMax(-1); upload.setRepositoryPath(tempdir.getCanonicalPath()); String basename = null; String war = null; FileItem warUpload = null; try { List items = upload.parseRequest(request); Iterator iter = items.iterator(); while (iter.hasNext()) { FileItem item = (FileItem) iter.next(); if (!item.isFormField()) { if (item.getFieldName().equals("deployWar") && warUpload == null) { warUpload = item; } else { item.delete(); } } } while (true) { if (warUpload == null) { message = sm.getString("htmlManagerServlet.deployUploadNoFile"); break; } war = warUpload.getName(); if (!war.toLowerCase().endsWith(".war")) { message = sm.getString("htmlManagerServlet.deployUploadNotWar", war); break; } if (war.lastIndexOf('\\') >= 0) { war = war.substring(war.lastIndexOf('\\') + 1); } if (war.lastIndexOf('/') >= 0) { war = war.substring(war.lastIndexOf('/') + 1); } // Identify the appBase of the owning Host of this Context basename = war.substring(0, war.toLowerCase().indexOf(".war")); File file = new File(getAppBase(), war); if (file.exists()) { message = sm.getString("htmlManagerServlet.deployUploadWarExists", war); break; } String path = null; if (basename.equals("ROOT")) { path = ""; } else { path = "/" + basename; } if (!isServiced(path)) { addServiced(path); try { warUpload.write(file); check(path); } finally { removeServiced(path); } } break; } } catch (Exception e) { message = sm.getString("htmlManagerServlet.deployUploadFail", e.getMessage()); log(message, e); } finally { if (warUpload != null) { warUpload.delete(); } warUpload = null; } list(request, response, message); }
protected Http11AprProcessor createProcessor() { Http11AprProcessor processor = new Http11AprProcessor(proto.maxHttpHeaderSize, proto.endpoint); processor.setAdapter(proto.adapter); processor.setMaxKeepAliveRequests(proto.maxKeepAliveRequests); processor.setTimeout(proto.timeout); processor.setDisableUploadTimeout(proto.disableUploadTimeout); processor.setCompression(proto.compression); processor.setCompressionMinSize(proto.compressionMinSize); processor.setNoCompressionUserAgents(proto.noCompressionUserAgents); processor.setCompressableMimeTypes(proto.compressableMimeTypes); processor.setRestrictedUserAgents(proto.restrictedUserAgents); processor.setSocketBuffer(proto.socketBuffer); processor.setMaxSavePostSize(proto.maxSavePostSize); processor.setServer(proto.server); register(processor); return processor; }	protected Http11Processor createProcessor() { Http11Processor processor = new Http11Processor(proto.maxHttpHeaderSize, proto.endpoint); processor.setAdapter(proto.adapter); processor.setMaxKeepAliveRequests(proto.maxKeepAliveRequests); processor.setKeepAliveTimeout(proto.keepAliveTimeout); processor.setTimeout(proto.timeout); processor.setDisableUploadTimeout(proto.disableUploadTimeout); processor.setCompression(proto.compression); processor.setCompressionMinSize(proto.compressionMinSize); processor.setNoCompressionUserAgents(proto.noCompressionUserAgents); processor.setCompressableMimeTypes(proto.compressableMimeTypes); processor.setRestrictedUserAgents(proto.restrictedUserAgents); processor.setSocketBuffer(proto.socketBuffer); processor.setMaxSavePostSize(proto.maxSavePostSize); processor.setServer(proto.server); register(processor); return processor; }	public Http11NioProcessor createProcessor() { Http11NioProcessor processor = new Http11NioProcessor(proto.ep.getSocketProperties().getRxBufSize(), proto.ep.getSocketProperties().getTxBufSize(), proto.maxHttpHeaderSize, proto.ep); processor.setAdapter(proto.adapter); processor.setMaxKeepAliveRequests(proto.maxKeepAliveRequests); processor.setTimeout(proto.timeout); processor.setDisableUploadTimeout(proto.disableUploadTimeout); processor.setCompression(proto.compression); processor.setCompressionMinSize(proto.compressionMinSize); processor.setNoCompressionUserAgents(proto.noCompressionUserAgents); processor.setCompressableMimeTypes(proto.compressableMimeTypes); processor.setRestrictedUserAgents(proto.restrictedUserAgents); processor.setSocketBuffer(proto.socketBuffer); processor.setMaxSavePostSize(proto.maxSavePostSize); processor.setServer(proto.server); register(processor); return processor; }
public static JavacErrorDetail createJavacError(String fname, Node.Nodes page, StringBuffer errMsgBuf, int lineNum, JspCompilationContext ctxt) throws JasperException { JavacErrorDetail javacError; ErrorVisitor errVisitor = new ErrorVisitor(lineNum); page.visit(errVisitor); Node errNode = errVisitor.getJspSourceNode(); if ((errNode != null) && (errNode.getStart() != null)) { javacError = new JavacErrorDetail(fname, lineNum, errNode.getStart().getFile(), errNode.getStart().getLineNumber(), errMsgBuf, ctxt); } else { javacError = new JavacErrorDetail(fname, lineNum, errMsgBuf); } return javacError; }
private boolean copyResource(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String destinationPath = req.getHeader("Destination"); if (destinationPath == null) { resp.sendError(WebdavStatus.SC_BAD_REQUEST); return false; } destinationPath = RequestUtil.URLDecode(destinationPath, "UTF8"); int protocolIndex = destinationPath.indexOf("://"); if (protocolIndex >= 0) { // if the Destination URL contains the protocol, we can safely int firstSeparator = destinationPath.indexOf("/", protocolIndex + 4); if (firstSeparator < 0) { destinationPath = "/"; } else { destinationPath = destinationPath.substring(firstSeparator); } } else { String hostName = req.getServerName(); if ((hostName != null) && (destinationPath.startsWith(hostName))) { destinationPath = destinationPath.substring(hostName.length()); } int portIndex = destinationPath.indexOf(":"); if (portIndex >= 0) { destinationPath = destinationPath.substring(portIndex); } if (destinationPath.startsWith(":")) { int firstSeparator = destinationPath.indexOf("/"); if (firstSeparator < 0) { destinationPath = "/"; } else { destinationPath = destinationPath.substring(firstSeparator); } } } destinationPath = normalize(destinationPath); String contextPath = req.getContextPath(); if ((contextPath != null) && (destinationPath.startsWith(contextPath))) { destinationPath = destinationPath.substring(contextPath.length()); } String pathInfo = req.getPathInfo(); if (pathInfo != null) { String servletPath = req.getServletPath(); if ((servletPath != null) && (destinationPath.startsWith(servletPath))) { destinationPath = destinationPath.substring(servletPath.length()); } } if (debug > 0) log("Dest path :" + destinationPath); if ((destinationPath.toUpperCase().startsWith("/WEB-INF")) || (destinationPath.toUpperCase().startsWith("/META-INF"))) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return false; } String path = getRelativePath(req); if ((path.toUpperCase().startsWith("/WEB-INF")) || (path.toUpperCase().startsWith("/META-INF"))) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return false; } if (destinationPath.equals(path)) { resp.sendError(WebdavStatus.SC_FORBIDDEN); return false; } boolean overwrite = true; String overwriteHeader = req.getHeader("Overwrite"); if (overwriteHeader != null) { if (overwriteHeader.equalsIgnoreCase("T")) { overwrite = true; } else { overwrite = false; } } boolean exists = true; try { resources.lookup(destinationPath); } catch (NamingException e) { exists = false; } if (overwrite) { if (exists) { if (!deleteResource(destinationPath, req, resp, true)) { return false; } } else { resp.setStatus(WebdavStatus.SC_CREATED); } } else { if (exists) { resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED); return false; } } Hashtable<String, Integer> errorList = new Hashtable<String, Integer>(); boolean result = copyResource(resources, errorList, path, destinationPath); if ((!result) || (!errorList.isEmpty())) { sendReport(req, resp, errorList); return false; } // Removing any lock-null resource which would be present at lockNullResources.remove(destinationPath); return true; }
protected void registerJMX(StandardContext ctx) { String parentName = ctx.getName(); parentName = ("".equals(parentName)) ? "/" : parentName; String hostName = ctx.getParent().getName(); hostName = (hostName == null) ? "DEFAULT" : hostName; String domain = ctx.getDomain(); String webMod = "//" + hostName + parentName; String onameStr = domain + ":j2eeType=Servlet,name=" + getName() + ",WebModule=" + webMod + ",J2EEApplication=" + ctx.getJ2EEApplication() + ",J2EEServer=" + ctx.getJ2EEServer(); try { oname = new ObjectName(onameStr); controller = oname; Registry.getRegistry(null, null).registerComponent(this, oname, null); if (this.getObjectName() != null) { Notification notification = new Notification("j2ee.object.created", this.getObjectName(), sequenceNumber++); broadcaster.sendNotification(notification); } } catch (Exception ex) { log.info("Error registering servlet with jmx " + this); } if (isJspServlet) { onameStr = domain + ":type=JspMonitor,name=" + getName() + ",WebModule=" + webMod + ",J2EEApplication=" + ctx.getJ2EEApplication() + ",J2EEServer=" + ctx.getJ2EEServer(); try { jspMonitorON = new ObjectName(onameStr); Registry.getRegistry(null, null).registerComponent(instance, jspMonitorON, null); } catch (Exception ex) { log.info("Error registering JSP monitoring with jmx " + instance); } } }
protected String getRelativePath(HttpServletRequest request) { if (request.getAttribute(Globals.INCLUDE_REQUEST_URI_ATTR) != null) { String result = (String) request.getAttribute(Globals.INCLUDE_PATH_INFO_ATTR); if ((result == null) || (result.equals(""))) result = "/"; return (result); } String result = request.getPathInfo(); if ((result == null) || (result.equals(""))) { result = "/"; } return (result); }
protected void remove(SendfileData data) { int rv = Poll.remove(sendfilePollset, data.socket); if (rv == Status.APR_SUCCESS) { sendfileCount--; } sendfileData.remove(data); }	protected boolean processSocket(long socket, SocketStatus status) { try { if (executor == null) { getWorkerThread().assign(socket, status); } else { executor.execute(new SocketEventProcessor(socket, status)); } } catch (Throwable t) { // This means we got an OOM or similar creating a thread, or that log.error(sm.getString("endpoint.process.fail"), t); return false; } return true; }
public int[] findStatusPages() { synchronized (statusPages) { int[] results = new int[statusPages.size()]; Iterator elements = statusPages.keySet().iterator(); int i = 0; while (elements.hasNext()) results[i++] = ((Integer) elements.next()).intValue(); return (results); } }
public void memberDisappeared(Member member) { boolean removed = false; synchronized (mapMembers) { removed = (mapMembers.remove(member) != null); } Iterator i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry e = (Map.Entry) i.next(); MapEntry entry = (MapEntry) super.get(e.getKey()); if (entry == null) continue; if (entry.isPrimary() && inSet(member, entry.getBackupNodes())) { if (log.isDebugEnabled()) log.debug("[1] Primary choosing a new backup"); try { Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue()); entry.setBackupNodes(backup); entry.setPrimary(channel.getLocalMember(false)); } catch (ChannelException x) { log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node", x); } } else if (member.equals(entry.getPrimary())) { if (log.isDebugEnabled()) log.debug("[2] Primary disappeared"); entry.setPrimary(null); } if (entry.isProxy() && entry.getPrimary() == null && entry.getBackupNodes() != null && entry.getBackupNodes().length == 1 && entry.getBackupNodes()[0].equals(member)) { if (log.isDebugEnabled()) log.debug("[3] Removing orphaned proxy"); i.remove(); } else if (entry.getPrimary() == null && entry.isBackup() && entry.getBackupNodes() != null && entry.getBackupNodes().length == 1 && entry.getBackupNodes()[0].equals(channel.getLocalMember(false))) { try { if (log.isDebugEnabled()) log.debug("[4] Backup becoming primary"); entry.setPrimary(channel.getLocalMember(false)); entry.setBackup(false); entry.setProxy(false); Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue()); entry.setBackupNodes(backup); if (mapOwner != null) mapOwner.objectMadePrimay(entry.getKey(), entry.getValue()); } catch (ChannelException x) { log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node", x); } } } //while }
protected SSLEngine createSSLEngine() { SSLEngine engine = sslContext.createSSLEngine(); engine.setNeedClientAuth(getClientAuth()); engine.setUseClientMode(false); if (ciphersarr.length > 0) engine.setEnabledCipherSuites(ciphersarr); if (sslEnabledProtocolsarr.length > 0) engine.setEnabledProtocols(sslEnabledProtocolsarr); return engine; }	public void init() throws Exception { if (initialized) return; serverSock = ServerSocketChannel.open(); serverSock.socket().setPerformancePreferences(socketProperties.getPerformanceConnectionTime(), socketProperties.getPerformanceLatency(), socketProperties.getPerformanceBandwidth()); InetSocketAddress addr = (address != null ? new InetSocketAddress(address, port) : new InetSocketAddress(port)); serverSock.socket().bind(addr, backlog); serverSock.configureBlocking(true); if (acceptorThreadCount == 0) { acceptorThreadCount = 1; } if (pollerThreadCount <= 0) { pollerThreadCount = 1; } if (isSSLEnabled()) { char[] passphrase = getKeystorePass().toCharArray(); KeyStore ks = KeyStore.getInstance(getKeystoreType()); ks.load(new FileInputStream(getKeystoreFile()), passphrase); KeyStore ts = KeyStore.getInstance(getKeystoreType()); ts.load(new FileInputStream(getKeystoreFile()), passphrase); KeyManagerFactory kmf = KeyManagerFactory.getInstance(getAlgorithm()); kmf.init(ks, passphrase); TrustManagerFactory tmf = TrustManagerFactory.getInstance(getAlgorithm()); tmf.init(ts); sslContext = SSLContext.getInstance(getSslProtocol()); sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null); } if (oomParachute > 0) reclaimParachute(true); initialized = true; }	public void setSSLEnabled(boolean SSLEnabled) { ep.setSSLEnabled(SSLEnabled); }	public void setSslProtocol(String s) { sslProtocol = s; }
private void checkSameObjects(ServletRequest appRequest, ServletResponse appResponse) throws ServletException { ServletRequest originalRequest = ApplicationFilterChain.getLastServicedRequest(); ServletResponse originalResponse = ApplicationFilterChain.getLastServicedResponse(); if (originalRequest == null || originalResponse == null) { return; } boolean same = false; ServletRequest dispatchedRequest = appRequest; while (originalRequest instanceof ServletRequestWrapper && ((ServletRequestWrapper) originalRequest).getRequest() != null) { originalRequest = ((ServletRequestWrapper) originalRequest).getRequest(); } while (!same) { if (originalRequest.equals(dispatchedRequest)) { same = true; } if (!same && dispatchedRequest instanceof ServletRequestWrapper) { dispatchedRequest = ((ServletRequestWrapper) dispatchedRequest).getRequest(); } else { break; } } if (!same) { throw new ServletException(sm.getString("applicationDispatcher.specViolation.request")); } same = false; ServletResponse dispatchedResponse = appResponse; while (originalResponse instanceof ServletResponseWrapper && ((ServletResponseWrapper) originalResponse).getResponse() != null) { originalResponse = ((ServletResponseWrapper) originalResponse).getResponse(); } while (!same) { if (originalResponse.equals(dispatchedResponse)) { same = true; } if (!same && dispatchedResponse instanceof ServletResponseWrapper) { dispatchedResponse = ((ServletResponseWrapper) dispatchedResponse).getResponse(); } else { break; } } if (!same) { throw new ServletException(sm.getString("applicationDispatcher.specViolation.response")); } }	void invoke(ServletRequest request, ServletResponse response, State state) throws IOException, ServletException { // Checking to see if the context classloader is the current context // classloader. If it's not, we're saving it, and setting the context ClassLoader oldCCL = Thread.currentThread().getContextClassLoader(); ClassLoader contextClassLoader = context.getLoader().getClassLoader(); if (oldCCL != contextClassLoader) { Thread.currentThread().setContextClassLoader(contextClassLoader); } else { oldCCL = null; } HttpServletResponse hresponse = (HttpServletResponse) response; Servlet servlet = null; IOException ioException = null; ServletException servletException = null; RuntimeException runtimeException = null; boolean unavailable = false; if (wrapper.isUnavailable()) { wrapper.getLogger().warn(sm.getString("applicationDispatcher.isUnavailable", wrapper.getName())); long available = wrapper.getAvailable(); if ((available > 0L) && (available < Long.MAX_VALUE)) hresponse.setDateHeader("Retry-After", available); hresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("applicationDispatcher.isUnavailable", wrapper.getName())); unavailable = true; } try { if (!unavailable) { servlet = wrapper.allocate(); } } catch (ServletException e) { wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException", wrapper.getName()), StandardWrapper.getRootCause(e)); servletException = e; servlet = null; } catch (Throwable e) { wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException", wrapper.getName()), e); servletException = new ServletException(sm.getString("applicationDispatcher.allocateException", wrapper.getName()), e); servlet = null; } ApplicationFilterFactory factory = ApplicationFilterFactory.getInstance(); ApplicationFilterChain filterChain = factory.createFilterChain(request, wrapper, servlet); try { String jspFile = wrapper.getJspFile(); if (jspFile != null) request.setAttribute(Globals.JSP_FILE_ATTR, jspFile); else request.removeAttribute(Globals.JSP_FILE_ATTR); support.fireInstanceEvent(InstanceEvent.BEFORE_DISPATCH_EVENT, servlet, request, response); if ((servlet != null) && (filterChain != null)) { filterChain.doFilter(request, response); } request.removeAttribute(Globals.JSP_FILE_ATTR); support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT, servlet, request, response); } catch (ClientAbortException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT, servlet, request, response); ioException = e; } catch (IOException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT, servlet, request, response); wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException", wrapper.getName()), e); ioException = e; } catch (UnavailableException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT, servlet, request, response); wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException", wrapper.getName()), e); servletException = e; wrapper.unavailable(e); } catch (ServletException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT, servlet, request, response); Throwable rootCause = StandardWrapper.getRootCause(e); if (!(rootCause instanceof ClientAbortException)) { wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException", wrapper.getName()), rootCause); } servletException = e; } catch (RuntimeException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT, servlet, request, response); wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException", wrapper.getName()), e); runtimeException = e; } try { if (filterChain != null) filterChain.release(); } catch (Throwable e) { wrapper.getLogger().error(sm.getString("standardWrapper.releaseFilters", wrapper.getName()), e); // FIXME: Exception handling needs to be simpiler to what is in the StandardWrapperValue } try { if (servlet != null) { wrapper.deallocate(servlet); } } catch (ServletException e) { wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException", wrapper.getName()), e); servletException = e; } catch (Throwable e) { wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException", wrapper.getName()), e); servletException = new ServletException(sm.getString("applicationDispatcher.deallocateException", wrapper.getName()), e); } if (oldCCL != null) Thread.currentThread().setContextClassLoader(oldCCL); // Unwrap request/response if needed unwrapRequest(state); unwrapResponse(state); if (ioException != null) throw ioException; if (servletException != null) throw servletException; if (runtimeException != null) throw runtimeException; }
protected void doLoad() throws ClassNotFoundException, IOException { if (log.isDebugEnabled()) log.debug("Start: Loading persisted sessions"); sessions.clear(); File file = file(); if (file == null) return; if (log.isDebugEnabled()) log.debug(sm.getString("standardManager.loading", pathname)); FileInputStream fis = null; ObjectInputStream ois = null; Loader loader = null; ClassLoader classLoader = null; try { fis = new FileInputStream(file.getAbsolutePath()); BufferedInputStream bis = new BufferedInputStream(fis); if (container != null) loader = container.getLoader(); if (loader != null) classLoader = loader.getClassLoader(); if (classLoader != null) { if (log.isDebugEnabled()) log.debug("Creating custom object input stream for class loader "); ois = new CustomObjectInputStream(bis, classLoader); } else { if (log.isDebugEnabled()) log.debug("Creating standard object input stream"); ois = new ObjectInputStream(bis); } } catch (FileNotFoundException e) { if (log.isDebugEnabled()) log.debug("No persisted data file found"); return; } catch (IOException e) { log.error(sm.getString("standardManager.loading.ioe", e), e); if (ois != null) { try { ois.close(); } catch (IOException f) { ; } ois = null; } throw e; } synchronized (sessions) { try { Integer count = (Integer) ois.readObject(); int n = count.intValue(); if (log.isDebugEnabled()) log.debug("Loading " + n + " persisted sessions"); for (int i = 0; i < n; i++) { StandardSession session = getNewSession(); session.readObjectData(ois); session.setManager(this); sessions.put(session.getIdInternal(), session); session.activate(); session.endAccess(); } } catch (ClassNotFoundException e) { log.error(sm.getString("standardManager.loading.cnfe", e), e); if (ois != null) { try { ois.close(); } catch (IOException f) { ; } ois = null; } throw e; } catch (IOException e) { log.error(sm.getString("standardManager.loading.ioe", e), e); if (ois != null) { try { ois.close(); } catch (IOException f) { ; } ois = null; } throw e; } finally { try { if (ois != null) ois.close(); } catch (IOException f) { // ignored } if (file != null && file.exists()) file.delete(); } } if (log.isDebugEnabled()) log.debug("Finish: Loading persisted sessions"); }
public static String URLDecode(String str) { return URLDecode(str, null); }	public static String URLDecode(String str, String enc) { if (str == null) return (null); // use the specified encoding to extract bytes out of the // given string so that the encoding is not lost. If an byte[] bytes = null; try { if (enc == null) { bytes = str.getBytes(); } else { bytes = str.getBytes(enc); } } catch (UnsupportedEncodingException uee) { } return URLDecode(bytes, enc); }	public static String URLDecode(byte[] bytes) { return URLDecode(bytes, null); }	public static String URLDecode(byte[] bytes, String enc) { if (bytes == null) return (null); int len = bytes.length; int ix = 0; int ox = 0; while (ix < len) { byte b = bytes[ix++]; if (b == '+') { b = (byte) ' '; } else if (b == '%') { b = (byte) ((convertHexDigit(bytes[ix++]) << 4) + convertHexDigit(bytes[ix++])); } bytes[ox++] = b; } if (enc != null) { try { return new String(bytes, 0, ox, enc); } catch (Exception e) { e.printStackTrace(); } } return new String(bytes, 0, ox); }	public static void parseParameters(Map map, String data, String encoding) throws UnsupportedEncodingException { if ((data != null) && (data.length() > 0)) { // use the specified encoding to extract bytes out of the // given string so that the encoding is not lost. If an byte[] bytes = null; try { if (encoding == null) { bytes = data.getBytes(); } else { bytes = data.getBytes(encoding); } } catch (UnsupportedEncodingException uee) { } parseParameters(map, bytes, encoding); } }
public void processRequest(HttpServletRequest request) { if (submit == null) addItem(item); if (submit.equals("add")) addItem(item); }	public String[] getItems() { String[] s = new String[v.size()]; v.copyInto(s); return s; }
public ApplicationFilterChain createFilterChain(ServletRequest request, Wrapper wrapper, Servlet servlet) { int dispatcher = -1; if (request.getAttribute(DISPATCHER_TYPE_ATTR) != null) { Integer dispatcherInt = (Integer) request.getAttribute(DISPATCHER_TYPE_ATTR); dispatcher = dispatcherInt.intValue(); } String requestPath = null; Object attribute = request.getAttribute(DISPATCHER_REQUEST_PATH_ATTR); if (attribute != null) { requestPath = attribute.toString(); } HttpServletRequest hreq = null; if (request instanceof HttpServletRequest) hreq = (HttpServletRequest) request; if (servlet == null) return (null); boolean comet = false; ApplicationFilterChain filterChain = null; if (request instanceof Request) { Request req = (Request) request; if (Globals.IS_SECURITY_ENABLED) { filterChain = new ApplicationFilterChain(); } else { filterChain = (ApplicationFilterChain) req.getFilterChain(); if (filterChain == null) { filterChain = new ApplicationFilterChain(); req.setFilterChain(filterChain); } } comet = req.isComet(); } else { filterChain = new ApplicationFilterChain(); } filterChain.setServlet(servlet); filterChain.setSupport(((StandardWrapper) wrapper).getInstanceSupport()); StandardContext context = (StandardContext) wrapper.getParent(); FilterMap[] filterMaps = context.findFilterMaps(); if ((filterMaps == null) || (filterMaps.length == 0)) return (filterChain); String servletName = wrapper.getName(); for (int i = 0; i < filterMaps.length; i++) { if (!matchDispatcher(filterMaps[i], dispatcher)) { continue; } if (!matchFiltersURL(filterMaps[i], requestPath)) continue; ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) context.findFilterConfig(filterMaps[i].getFilterName()); if (filterConfig == null) { ; continue; } boolean isCometFilter = false; if (comet) { try { isCometFilter = filterConfig.getFilter() instanceof CometFilter; } catch (Exception e) { // Note: The try catch is there because getFilter has a lot of // declared exceptions. However, the filter is allocated much // earlier } if (isCometFilter) { filterChain.addFilter(filterConfig); } } else { filterChain.addFilter(filterConfig); } } for (int i = 0; i < filterMaps.length; i++) { if (!matchDispatcher(filterMaps[i], dispatcher)) { continue; } if (!matchFiltersServlet(filterMaps[i], servletName)) continue; ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) context.findFilterConfig(filterMaps[i].getFilterName()); if (filterConfig == null) { ; continue; } boolean isCometFilter = false; if (comet) { try { isCometFilter = filterConfig.getFilter() instanceof CometFilter; } catch (Exception e) { // Note: The try catch is there because getFilter has a lot of // declared exceptions. However, the filter is allocated much // earlier } if (isCometFilter) { filterChain.addFilter(filterConfig); } } else { filterChain.addFilter(filterConfig); } } return (filterChain); }
public void addRuleInstances(Digester digester) { sessionConfig = new SetSessionConfig(); jspConfig = new SetJspConfig(); loginConfig = new SetLoginConfig(); digester.addRule(prefix + "web-app", new SetPublicIdRule("setPublicId")); digester.addRule(prefix + "web-app", new IgnoreAnnotationsRule()); digester.addCallMethod(prefix + "web-app/context-param", "addParameter", 2); digester.addCallParam(prefix + "web-app/context-param/param-name", 0); digester.addCallParam(prefix + "web-app/context-param/param-value", 1); digester.addCallMethod(prefix + "web-app/display-name", "setDisplayName", 0); digester.addRule(prefix + "web-app/distributable", new SetDistributableRule()); digester.addObjectCreate(prefix + "web-app/ejb-local-ref", "org.apache.catalina.deploy.ContextLocalEjb"); digester.addRule(prefix + "web-app/ejb-local-ref", new SetNextNamingRule("addLocalEjb", "org.apache.catalina.deploy.ContextLocalEjb")); digester.addCallMethod(prefix + "web-app/ejb-local-ref/description", "setDescription", 0); digester.addCallMethod(prefix + "web-app/ejb-local-ref/ejb-link", "setLink", 0); digester.addCallMethod(prefix + "web-app/ejb-local-ref/ejb-ref-name", "setName", 0); digester.addCallMethod(prefix + "web-app/ejb-local-ref/ejb-ref-type", "setType", 0); digester.addCallMethod(prefix + "web-app/ejb-local-ref/local", "setLocal", 0); digester.addCallMethod(prefix + "web-app/ejb-local-ref/local-home", "setHome", 0); digester.addObjectCreate(prefix + "web-app/ejb-ref", "org.apache.catalina.deploy.ContextEjb"); digester.addRule(prefix + "web-app/ejb-ref", new SetNextNamingRule("addEjb", "org.apache.catalina.deploy.ContextEjb")); digester.addCallMethod(prefix + "web-app/ejb-ref/description", "setDescription", 0); digester.addCallMethod(prefix + "web-app/ejb-ref/ejb-link", "setLink", 0); digester.addCallMethod(prefix + "web-app/ejb-ref/ejb-ref-name", "setName", 0); digester.addCallMethod(prefix + "web-app/ejb-ref/ejb-ref-type", "setType", 0); digester.addCallMethod(prefix + "web-app/ejb-ref/home", "setHome", 0); digester.addCallMethod(prefix + "web-app/ejb-ref/remote", "setRemote", 0); digester.addObjectCreate(prefix + "web-app/env-entry", "org.apache.catalina.deploy.ContextEnvironment"); digester.addRule(prefix + "web-app/env-entry", new SetNextNamingRule("addEnvironment", "org.apache.catalina.deploy.ContextEnvironment")); digester.addCallMethod(prefix + "web-app/env-entry/description", "setDescription", 0); digester.addCallMethod(prefix + "web-app/env-entry/env-entry-name", "setName", 0); digester.addCallMethod(prefix + "web-app/env-entry/env-entry-type", "setType", 0); digester.addCallMethod(prefix + "web-app/env-entry/env-entry-value", "setValue", 0); digester.addObjectCreate(prefix + "web-app/error-page", "org.apache.catalina.deploy.ErrorPage"); digester.addSetNext(prefix + "web-app/error-page", "addErrorPage", "org.apache.catalina.deploy.ErrorPage"); digester.addCallMethod(prefix + "web-app/error-page/error-code", "setErrorCode", 0); digester.addCallMethod(prefix + "web-app/error-page/exception-type", "setExceptionType", 0); digester.addCallMethod(prefix + "web-app/error-page/location", "setLocation", 0); digester.addObjectCreate(prefix + "web-app/filter", "org.apache.catalina.deploy.FilterDef"); digester.addSetNext(prefix + "web-app/filter", "addFilterDef", "org.apache.catalina.deploy.FilterDef"); digester.addCallMethod(prefix + "web-app/filter/description", "setDescription", 0); digester.addCallMethod(prefix + "web-app/filter/display-name", "setDisplayName", 0); digester.addCallMethod(prefix + "web-app/filter/filter-class", "setFilterClass", 0); digester.addCallMethod(prefix + "web-app/filter/filter-name", "setFilterName", 0); digester.addCallMethod(prefix + "web-app/filter/large-icon", "setLargeIcon", 0); digester.addCallMethod(prefix + "web-app/filter/small-icon", "setSmallIcon", 0); digester.addCallMethod(prefix + "web-app/filter/init-param", "addInitParameter", 2); digester.addCallParam(prefix + "web-app/filter/init-param/param-name", 0); digester.addCallParam(prefix + "web-app/filter/init-param/param-value", 1); digester.addObjectCreate(prefix + "web-app/filter-mapping", "org.apache.catalina.deploy.FilterMap"); digester.addSetNext(prefix + "web-app/filter-mapping", "addFilterMap", "org.apache.catalina.deploy.FilterMap"); digester.addCallMethod(prefix + "web-app/filter-mapping/filter-name", "setFilterName", 0); digester.addCallMethod(prefix + "web-app/filter-mapping/servlet-name", "addServletName", 0); digester.addCallMethod(prefix + "web-app/filter-mapping/url-pattern", "addURLPattern", 0); digester.addCallMethod(prefix + "web-app/filter-mapping/dispatcher", "setDispatcher", 0); digester.addCallMethod(prefix + "web-app/listener/listener-class", "addApplicationListener", 0); digester.addRule(prefix + "web-app/jsp-config", jspConfig); digester.addCallMethod(prefix + "web-app/jsp-config/jsp-property-group/url-pattern", "addJspMapping", 0); digester.addCallMethod(prefix + "web-app/listener/listener-class", "addApplicationListener", 0); digester.addRule(prefix + "web-app/login-config", loginConfig); digester.addObjectCreate(prefix + "web-app/login-config", "org.apache.catalina.deploy.LoginConfig"); digester.addSetNext(prefix + "web-app/login-config", "setLoginConfig", "org.apache.catalina.deploy.LoginConfig"); digester.addCallMethod(prefix + "web-app/login-config/auth-method", "setAuthMethod", 0); digester.addCallMethod(prefix + "web-app/login-config/realm-name", "setRealmName", 0); digester.addCallMethod(prefix + "web-app/login-config/form-login-config/form-error-page", "setErrorPage", 0); digester.addCallMethod(prefix + "web-app/login-config/form-login-config/form-login-page", "setLoginPage", 0); digester.addCallMethod(prefix + "web-app/mime-mapping", "addMimeMapping", 2); digester.addCallParam(prefix + "web-app/mime-mapping/extension", 0); digester.addCallParam(prefix + "web-app/mime-mapping/mime-type", 1); digester.addObjectCreate(prefix + "web-app/resource-env-ref", "org.apache.catalina.deploy.ContextResourceEnvRef"); digester.addRule(prefix + "web-app/resource-env-ref", new SetNextNamingRule("addResourceEnvRef", "org.apache.catalina.deploy.ContextResourceEnvRef")); digester.addCallMethod(prefix + "web-app/resource-env-ref/resource-env-ref-name", "setName", 0); digester.addCallMethod(prefix + "web-app/resource-env-ref/resource-env-ref-type", "setType", 0); digester.addObjectCreate(prefix + "web-app/message-destination", "org.apache.catalina.deploy.MessageDestination"); digester.addSetNext(prefix + "web-app/message-destination", "addMessageDestination", "org.apache.catalina.deploy.MessageDestination"); digester.addCallMethod(prefix + "web-app/message-destination/description", "setDescription", 0); digester.addCallMethod(prefix + "web-app/message-destination/display-name", "setDisplayName", 0); digester.addCallMethod(prefix + "web-app/message-destination/icon/large-icon", "setLargeIcon", 0); digester.addCallMethod(prefix + "web-app/message-destination/icon/small-icon", "setSmallIcon", 0); digester.addCallMethod(prefix + "web-app/message-destination/message-destination-name", "setName", 0); digester.addObjectCreate(prefix + "web-app/message-destination-ref", "org.apache.catalina.deploy.MessageDestinationRef"); digester.addSetNext(prefix + "web-app/message-destination-ref", "addMessageDestinationRef", "org.apache.catalina.deploy.MessageDestinationRef"); digester.addCallMethod(prefix + "web-app/message-destination-ref/description", "setDescription", 0); digester.addCallMethod(prefix + "web-app/message-destination-ref/message-destination-link", "setLink", 0); digester.addCallMethod(prefix + "web-app/message-destination-ref/message-destination-ref-name", "setName", 0); digester.addCallMethod(prefix + "web-app/message-destination-ref/message-destination-type", "setType", 0); digester.addCallMethod(prefix + "web-app/message-destination-ref/message-destination-usage", "setUsage", 0); digester.addObjectCreate(prefix + "web-app/resource-ref", "org.apache.catalina.deploy.ContextResource"); digester.addRule(prefix + "web-app/resource-ref", new SetNextNamingRule("addResource", "org.apache.catalina.deploy.ContextResource")); digester.addCallMethod(prefix + "web-app/resource-ref/description", "setDescription", 0); digester.addCallMethod(prefix + "web-app/resource-ref/res-auth", "setAuth", 0); digester.addCallMethod(prefix + "web-app/resource-ref/res-ref-name", "setName", 0); digester.addCallMethod(prefix + "web-app/resource-ref/res-sharing-scope", "setScope", 0); digester.addCallMethod(prefix + "web-app/resource-ref/res-type", "setType", 0); digester.addObjectCreate(prefix + "web-app/security-constraint", "org.apache.catalina.deploy.SecurityConstraint"); digester.addSetNext(prefix + "web-app/security-constraint", "addConstraint", "org.apache.catalina.deploy.SecurityConstraint"); digester.addRule(prefix + "web-app/security-constraint/auth-constraint", new SetAuthConstraintRule()); digester.addCallMethod(prefix + "web-app/security-constraint/auth-constraint/role-name", "addAuthRole", 0); digester.addCallMethod(prefix + "web-app/security-constraint/display-name", "setDisplayName", 0); digester.addCallMethod(prefix + "web-app/security-constraint/user-data-constraint/transport-guarantee", "setUserConstraint", 0); digester.addObjectCreate(prefix + "web-app/security-constraint/web-resource-collection", "org.apache.catalina.deploy.SecurityCollection"); digester.addSetNext(prefix + "web-app/security-constraint/web-resource-collection", "addCollection", "org.apache.catalina.deploy.SecurityCollection"); digester.addCallMethod(prefix + "web-app/security-constraint/web-resource-collection/http-method", "addMethod", 0); digester.addCallMethod(prefix + "web-app/security-constraint/web-resource-collection/url-pattern", "addPattern", 0); digester.addCallMethod(prefix + "web-app/security-constraint/web-resource-collection/web-resource-name", "setName", 0); digester.addCallMethod(prefix + "web-app/security-role/role-name", "addSecurityRole", 0); digester.addObjectCreate(prefix + "web-app/service-ref", "org.apache.catalina.deploy.ContextService"); digester.addRule(prefix + "web-app/service-ref", new SetNextNamingRule("addService", "org.apache.catalina.deploy.ContextService")); digester.addCallMethod(prefix + "web-app/service-ref/description", "setDescription", 0); digester.addCallMethod(prefix + "web-app/service-ref/display-name", "setDisplayname", 0); digester.addCallMethod(prefix + "web-app/service-ref/icon", "setIcon", 0); digester.addCallMethod(prefix + "web-app/service-ref/service-ref-name", "setName", 0); digester.addCallMethod(prefix + "web-app/service-ref/service-interface", "setType", 0); digester.addCallMethod(prefix + "web-app/service-ref/wsdl-file", "setWsdlfile", 0); digester.addCallMethod(prefix + "web-app/service-ref/jaxrpc-mapping-file", "setJaxrpcmappingfile", 0); digester.addRule(prefix + "web-app/service-ref/service-qname", new ServiceQnameRule()); digester.addRule(prefix + "web-app/service-ref/port-component-ref", new CallMethodMultiRule("addPortcomponent", 2, 1)); digester.addCallParam(prefix + "web-app/service-ref/port-component-ref/service-endpoint-interface", 0); digester.addRule(prefix + "web-app/service-ref/port-component-ref/port-component-link", new CallParamMultiRule(1)); digester.addObjectCreate(prefix + "web-app/service-ref/handler", "org.apache.catalina.deploy.ContextHandler"); digester.addRule(prefix + "web-app/service-ref/handler", new SetNextRule("addHandler", "org.apache.catalina.deploy.ContextHandler")); digester.addCallMethod(prefix + "web-app/service-ref/handler/handler-name", "setName", 0); digester.addCallMethod(prefix + "web-app/service-ref/handler/handler-class", "setHandlerclass", 0); digester.addCallMethod(prefix + "web-app/service-ref/handler/init-param", "setProperty", 2); digester.addCallParam(prefix + "web-app/service-ref/handler/init-param/param-name", 0); digester.addCallParam(prefix + "web-app/service-ref/handler/init-param/param-value", 1); digester.addRule(prefix + "web-app/service-ref/handler/soap-header", new SoapHeaderRule()); digester.addCallMethod(prefix + "web-app/service-ref/handler/soap-role", "addSoapRole", 0); digester.addCallMethod(prefix + "web-app/service-ref/handler/port-name", "addPortName", 0); digester.addRule(prefix + "web-app/servlet", new WrapperCreateRule()); digester.addSetNext(prefix + "web-app/servlet", "addChild", "org.apache.catalina.Container"); digester.addCallMethod(prefix + "web-app/servlet/init-param", "addInitParameter", 2); digester.addCallParam(prefix + "web-app/servlet/init-param/param-name", 0); digester.addCallParam(prefix + "web-app/servlet/init-param/param-value", 1); digester.addCallMethod(prefix + "web-app/servlet/jsp-file", "setJspFile", 0); digester.addCallMethod(prefix + "web-app/servlet/load-on-startup", "setLoadOnStartupString", 0); digester.addCallMethod(prefix + "web-app/servlet/run-as/role-name", "setRunAs", 0); digester.addCallMethod(prefix + "web-app/servlet/security-role-ref", "addSecurityReference", 2); digester.addCallParam(prefix + "web-app/servlet/security-role-ref/role-link", 1); digester.addCallParam(prefix + "web-app/servlet/security-role-ref/role-name", 0); digester.addCallMethod(prefix + "web-app/servlet/servlet-class", "setServletClass", 0); digester.addCallMethod(prefix + "web-app/servlet/servlet-name", "setName", 0); digester.addRule(prefix + "web-app/servlet-mapping", new CallMethodMultiRule("addServletMapping", 2, 0)); digester.addCallParam(prefix + "web-app/servlet-mapping/servlet-name", 1); digester.addRule(prefix + "web-app/servlet-mapping/url-pattern", new CallParamMultiRule(0)); digester.addRule(prefix + "web-app/session-config", sessionConfig); digester.addCallMethod(prefix + "web-app/session-config/session-timeout", "setSessionTimeout", 1, new Class[] { Integer.TYPE }); digester.addCallParam(prefix + "web-app/session-config/session-timeout", 0); digester.addCallMethod(prefix + "web-app/taglib", "addTaglib", 2); digester.addCallParam(prefix + "web-app/taglib/taglib-location", 1); digester.addCallParam(prefix + "web-app/taglib/taglib-uri", 0); digester.addCallMethod(prefix + "web-app/welcome-file-list/welcome-file", "addWelcomeFile", 0); digester.addCallMethod(prefix + "web-app/locale-encoding-mapping-list/locale-encoding-mapping", "addLocaleEncodingMappingParameter", 2); digester.addCallParam(prefix + "web-app/locale-encoding-mapping-list/locale-encoding-mapping/locale", 0); digester.addCallParam(prefix + "web-app/locale-encoding-mapping-list/locale-encoding-mapping/encoding", 1); }	public void begin(String namespace, String name, Attributes attributes) throws Exception { if (isLoginConfigSet) { throw new IllegalArgumentException("<login-config> element is limited to 1 occurance"); } isLoginConfigSet = true; }	public void body(String text) throws Exception { String namespaceuri = null; String localpart = text; int colon = text.indexOf(':'); if (colon >= 0) { String prefix = text.substring(0, colon); namespaceuri = digester.findNamespaceURI(prefix); localpart = text.substring(colon + 1); } ContextHandler contextHandler = (ContextHandler) digester.peek(); contextHandler.addSoapHeaders(localpart, namespaceuri); }

public void addEnvironment(ContextEnvironment environment) { if (entries.containsKey(environment.getName())) { if (findEnvironment(environment.getName()).getOverride()) { removeEnvironment(environment.getName()); } else { return; } } entries.put(environment.getName(), environment.getType()); synchronized (envs) { environment.setNamingResources(this); envs.put(environment.getName(), environment); } support.firePropertyChange("environment", null, environment); }
String matchMap(ArrayList functions) { String mapName = null; for (int i = 0; i < functions.size(); i++) { ELNode.Function f = (ELNode.Function) functions.get(i); String temName = (String) gMap.get(f.getPrefix() + ':' + f.getName() + ':' + f.getUri()); if (temName == null) { return null; } if (mapName == null) { mapName = temName; } else if (!temName.equals(mapName)) { return null; } } return mapName; }	private void doMap(ELNode.Nodes el) throws JasperException { class Fvisitor extends ELNode.Visitor { ArrayList funcs = new ArrayList(); HashMap keyMap = new HashMap(); } }	private void doMap(Node.JspAttribute attr) throws JasperException { if (attr != null) { doMap(attr.getEL()); } }	public static void map(Compiler compiler, Node.Nodes page) throws JasperException { currFunc = 0; ELFunctionMapper map = new ELFunctionMapper(); map.err = compiler.getErrorDispatcher(); map.ds = new StringBuffer(); map.ss = new StringBuffer(); page.visit(map.new ELFunctionVisitor()); String ds = map.ds.toString(); if (ds.length() > 0) { Node root = page.getRoot(); new Node.Declaration(map.ss.toString(), null, root); new Node.Declaration("static {\n" + ds + "}\n", null, root); } }	private void doMap(ELNode.Nodes el) throws JasperException { class Fvisitor extends ELNode.Visitor { ArrayList funcs = new ArrayList(); HashMap keyMap = new HashMap(); public void visit(ELNode.Function n) throws JasperException { String key = n.getPrefix() + ":" + n.getName(); if (!keyMap.containsKey(key)) { keyMap.put(key, ""); funcs.add(n); } } } if (el == null) { return; } Fvisitor fv = new Fvisitor(); el.visit(fv); ArrayList functions = fv.funcs; if (functions.size() == 0) { return; } String decName = matchMap(functions); if (decName != null) { el.setMapName(decName); return; } decName = getMapName(); ss.append("static private org.apache.jasper.runtime.ProtectedFunctionMapper " + decName + ";\n"); ds.append(" " + decName + "= "); ds.append("org.apache.jasper.runtime.ProtectedFunctionMapper"); String funcMethod = null; if (functions.size() == 1) { funcMethod = ".getMapForFunction"; } else { ds.append(".getInstance();\n"); funcMethod = " " + decName + ".mapFunction"; } for (int i = 0; i < functions.size(); i++) { ELNode.Function f = (ELNode.Function) functions.get(i); FunctionInfo funcInfo = f.getFunctionInfo(); String key = f.getPrefix() + ":" + f.getName(); ds.append(funcMethod + "(\"" + key + "\", " + funcInfo.getFunctionClass() + ".class, " + '\"' + f.getMethodName() + "\", " + "new Class[] {"); String[] params = f.getParameters(); for (int k = 0; k < params.length; k++) { if (k != 0) { ds.append(", "); } int iArray = params[k].indexOf('['); if (iArray < 0) { ds.append(params[k] + ".class"); } else { String baseType = params[k].substring(0, iArray); ds.append("java.lang.reflect.Array.newInstance("); ds.append(baseType); ds.append(".class,"); int aCount = 0; for (int jj = iArray; jj < params[k].length(); jj++) { if (params[k].charAt(jj) == '[') { aCount++; } } if (aCount == 1) { ds.append("0).getClass()"); } else { ds.append("new int[" + aCount + "]).getClass()"); } } } ds.append("});\n"); gMap.put(f.getPrefix() + ':' + f.getName() + ':' + f.getUri(), decName); } el.setMapName(decName); }	public void visit(Node.CustomTag n) throws JasperException { Node.JspAttribute[] attrs = n.getJspAttributes(); for (int i = 0; attrs != null && i < attrs.length; i++) { doMap(attrs[i]); } visitBody(n); }	public void visit(Node.ELExpression n) throws JasperException { doMap(n.getEL()); }	public void visit(Node.JspElement n) throws JasperException { Node.JspAttribute[] attrs = n.getJspAttributes(); for (int i = 0; attrs != null && i < attrs.length; i++) { doMap(attrs[i]); } doMap(n.getNameAttribute()); visitBody(n); }	public void visit(Node.PlugIn n) throws JasperException { doMap(n.getHeight()); doMap(n.getWidth()); visitBody(n); }	public void visit(Node.SetProperty n) throws JasperException { doMap(n.getValue()); visitBody(n); }	public void visit(Node.UninterpretedTag n) throws JasperException { Node.JspAttribute[] attrs = n.getJspAttributes(); for (int i = 0; attrs != null && i < attrs.length; i++) { doMap(attrs[i]); } visitBody(n); }	public void visit(Node.UseBean n) throws JasperException { doMap(n.getBeanName()); visitBody(n); }
protected ArrayList parseRange(HttpServletRequest request, HttpServletResponse response, ResourceAttributes resourceAttributes) throws IOException { String headerValue = request.getHeader("If-Range"); if (headerValue != null) { long headerValueTime = (-1L); try { headerValueTime = request.getDateHeader("If-Range"); } catch (IllegalArgumentException e) { ; } String eTag = getETag(resourceAttributes); long lastModified = resourceAttributes.getLastModified(); if (headerValueTime == (-1L)) { if (!eTag.equals(headerValue.trim())) return FULL; } else { if (lastModified > (headerValueTime + 1000)) return FULL; } } long fileLength = resourceAttributes.getContentLength(); if (fileLength == 0) return null; String rangeHeader = request.getHeader("Range"); if (rangeHeader == null) return null; if (!rangeHeader.startsWith("bytes")) { response.addHeader("Content-Range", "bytes */" + fileLength); response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE); return null; } rangeHeader = rangeHeader.substring(6); // Vector which will contain all the ranges which are successfully ArrayList result = new ArrayList(); StringTokenizer commaTokenizer = new StringTokenizer(rangeHeader, ","); while (commaTokenizer.hasMoreTokens()) { String rangeDefinition = commaTokenizer.nextToken().trim(); Range currentRange = new Range(); currentRange.length = fileLength; int dashPos = rangeDefinition.indexOf('-'); if (dashPos == -1) { response.addHeader("Content-Range", "bytes */" + fileLength); response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE); return null; } if (dashPos == 0) { try { long offset = Long.parseLong(rangeDefinition); currentRange.start = fileLength + offset; currentRange.end = fileLength - 1; } catch (NumberFormatException e) { response.addHeader("Content-Range", "bytes */" + fileLength); response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE); return null; } } else { try { currentRange.start = Long.parseLong(rangeDefinition.substring(0, dashPos)); if (dashPos < rangeDefinition.length() - 1) currentRange.end = Long.parseLong(rangeDefinition.substring(dashPos + 1, rangeDefinition.length())); else currentRange.end = fileLength - 1; } catch (NumberFormatException e) { response.addHeader("Content-Range", "bytes */" + fileLength); response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE); return null; } } if (!currentRange.validate()) { response.addHeader("Content-Range", "bytes */" + fileLength); response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE); return null; } result.add(currentRange); } return result; }	protected boolean checkIfModifiedSince(HttpServletRequest request, HttpServletResponse response, ResourceAttributes resourceAttributes) throws IOException { try { long headerValue = request.getDateHeader("If-Modified-Since"); long lastModified = resourceAttributes.getLastModified(); if (headerValue != -1) { if ((request.getHeader("If-None-Match") == null) && (lastModified < headerValue + 1000)) { // The entity has not been modified since the date response.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return false; } } } catch (IllegalArgumentException illegalArgument) { return true; } return true; }	protected boolean checkIfNoneMatch(HttpServletRequest request, HttpServletResponse response, ResourceAttributes resourceAttributes) throws IOException { String eTag = getETag(resourceAttributes); String headerValue = request.getHeader("If-None-Match"); if (headerValue != null) { boolean conditionSatisfied = false; if (!headerValue.equals("*")) { StringTokenizer commaTokenizer = new StringTokenizer(headerValue, ","); while (!conditionSatisfied && commaTokenizer.hasMoreTokens()) { String currentToken = commaTokenizer.nextToken(); if (currentToken.trim().equals(eTag)) conditionSatisfied = true; } } else { conditionSatisfied = true; } if (conditionSatisfied) { if (("GET".equals(request.getMethod())) || ("HEAD".equals(request.getMethod()))) { response.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return false; } else { response.sendError(HttpServletResponse.SC_PRECONDITION_FAILED); return false; } } } return true; }
public void invoke(Request request, Response response) throws IOException, ServletException { getNext().invoke(request, response); Throwable throwable = (Throwable) request.getAttribute(Globals.EXCEPTION_ATTR); if (response.isAppCommitted()) { return; } if (throwable != null) { response.setError(); try { response.reset(); } catch (IllegalStateException e) { ; } response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); } response.setSuspended(false); try { report(request, response, throwable); } catch (Throwable tt) { ; } }
private SecurityConstraint[] resultsToArray(ArrayList results) { if (results == null) { return null; } SecurityConstraint[] array = new SecurityConstraint[results.size()]; results.toArray(array); return array; }	public void init() { this.containerLog = container.getLogger(); if (initialized && container != null) return; initialized = true; if (container == null) { ObjectName parent = null; try { if (host == null) { parent = new ObjectName(domain + ":type=Engine"); } else if (path == null) { parent = new ObjectName(domain + ":type=Host,host=" + host); } else { parent = new ObjectName(domain + ":j2eeType=WebModule,name=//" + host + path); } if (mserver.isRegistered(parent)) { if (log.isDebugEnabled()) log.debug("Register with " + parent); mserver.setAttribute(parent, new Attribute("realm", this)); } } catch (Exception e) { log.error("Parent not available yet: " + parent); } } if (oname == null) { try { ContainerBase cb = (ContainerBase) container; oname = new ObjectName(cb.getDomain() + ":type=Realm" + cb.getContainerSuffix()); Registry.getRegistry(null, null).registerComponent(this, oname, null); if (log.isDebugEnabled()) log.debug("Register Realm " + oname); } catch (Throwable e) { log.error("Can't register " + oname, e); } } }
public String getTemporaryVariableName() { return temporaryVariableName; }
protected Comparator getComparator(String sortBy) { Comparator comparator = null; if ("CreationTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(session.getCreationTime()); } }; } else if ("id".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return session.getId(); } }; } else if ("LastAccessedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(session.getLastAccessedTime()); } }; } else if ("MaxInactiveInterval".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(session.getMaxInactiveInterval()); } }; } else if ("new".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return Boolean.valueOf(session.getSession().isNew()); } }; } else if ("locale".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return JspHelper.guessDisplayLocaleFromSession(session); } }; } else if ("user".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return JspHelper.guessDisplayUserFromSession(session); } }; } else if ("UsedTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(SessionUtils.getUsedTimeForSession(session)); } }; } else if ("InactiveTime".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(SessionUtils.getInactiveTimeForSession(session)); } }; } else if ("TTL".equalsIgnoreCase(sortBy)) { comparator = new BaseSessionComparator() { public Comparable getComparableObject(Session session) { return new Date(SessionUtils.getTTLForSession(session)); } }; } return comparator; }
protected AccessLogElement[] createLogElements() { List<AccessLogElement> list = new ArrayList<AccessLogElement>(); boolean replace = false; StringBuffer buf = new StringBuffer(); for (int i = 0; i < pattern.length(); i++) { char ch = pattern.charAt(i); if (replace) { if ('{' == ch) { StringBuffer name = new StringBuffer(); int j = i + 1; for (; j < pattern.length() && '}' != pattern.charAt(j); j++) { name.append(pattern.charAt(j)); } if (j + 1 < pattern.length()) { j++; list.add(createAccessLogElement(name.toString(), pattern.charAt(j))); i = j; /* Since we walked more than one character */ } else { // D'oh - end of string - pretend we never did this list.add(createAccessLogElement(ch)); } } else { list.add(createAccessLogElement(ch)); } replace = false; } else if (ch == '%') { replace = true; list.add(new StringElement(buf.toString())); buf = new StringBuffer(); } else { buf.append(ch); } } if (buf.length() > 0) { list.add(new StringElement(buf.toString())); } return (AccessLogElement[]) list.toArray(new AccessLogElement[0]); }
protected boolean restoreRequest(Request request, Session session) throws IOException { SavedRequest saved = (SavedRequest) session.getNote(Constants.FORM_REQUEST_NOTE); session.removeNote(Constants.FORM_REQUEST_NOTE); session.removeNote(Constants.FORM_PRINCIPAL_NOTE); if (saved == null) return (false); request.clearCookies(); Iterator cookies = saved.getCookies(); while (cookies.hasNext()) { request.addCookie((Cookie) cookies.next()); } MimeHeaders rmh = request.getCoyoteRequest().getMimeHeaders(); rmh.recycle(); Iterator names = saved.getHeaderNames(); while (names.hasNext()) { String name = (String) names.next(); Iterator values = saved.getHeaderValues(name); while (values.hasNext()) { rmh.addValue(name).setString((String) values.next()); } } request.clearLocales(); Iterator locales = saved.getLocales(); while (locales.hasNext()) { request.addLocale((Locale) locales.next()); } request.getCoyoteRequest().getParameters().recycle(); if ("POST".equalsIgnoreCase(saved.getMethod())) { ByteChunk body = saved.getBody(); if (body != null) { request.getCoyoteRequest().action(ActionCode.ACTION_REQ_SET_BODY_REPLAY, body); MessageBytes contentType = MessageBytes.newInstance(); contentType.setString("application/x-www-form-urlencoded"); request.getCoyoteRequest().setContentType(contentType); } } request.getCoyoteRequest().method().setString(saved.getMethod()); request.getCoyoteRequest().queryString().setString(saved.getQueryString()); request.getCoyoteRequest().requestURI().setString(saved.getRequestURI()); return (true); }	protected void saveRequest(Request request, Session session) throws IOException { SavedRequest saved = new SavedRequest(); Cookie[] cookies = request.getCookies(); if (cookies != null) { for (int i = 0; i < cookies.length; i++) saved.addCookie(cookies[i]); } Enumeration names = request.getHeaderNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); Enumeration values = request.getHeaders(name); while (values.hasMoreElements()) { String value = (String) values.nextElement(); saved.addHeader(name, value); } } Enumeration locales = request.getLocales(); while (locales.hasMoreElements()) { Locale locale = (Locale) locales.nextElement(); saved.addLocale(locale); } if ("POST".equalsIgnoreCase(request.getMethod())) { ByteChunk body = new ByteChunk(); body.setLimit(request.getConnector().getMaxSavePostSize()); byte[] buffer = new byte[4096]; int bytesRead; InputStream is = request.getInputStream(); while ((bytesRead = is.read(buffer)) >= 0) { body.append(buffer, 0, bytesRead); } saved.setBody(body); } saved.setMethod(request.getMethod()); saved.setQueryString(request.getQueryString()); saved.setRequestURI(request.getRequestURI()); session.setNote(Constants.FORM_REQUEST_NOTE, saved); }	public void setBody(ByteChunk body) { this.body = body; }
public Connector createConnector(String address, int port, String protocol) { Connector connector = null; if (address != null) { int index = address.indexOf('/'); if (index != -1) { address = address.substring(index + 1); } } if (log.isDebugEnabled()) { log.debug("Creating connector for address='" + ((address == null) ? "ALL" : address) + "' port='" + port + "' protocol='" + protocol + "'"); } try { if (protocol.equals("ajp")) { connector = new Connector("org.apache.jk.server.JkCoyoteHandler"); } else if (protocol.equals("memory")) { connector = new Connector("org.apache.coyote.memory.MemoryProtocolHandler"); } else if (protocol.equals("http")) { connector = new Connector(); } else if (protocol.equals("https")) { connector = new Connector(); connector.setScheme("https"); connector.setSecure(true); // FIXME !!!! SET SSL PROPERTIES } if (address != null) { IntrospectionUtils.setProperty(connector, "address", "" + address); } IntrospectionUtils.setProperty(connector, "port", "" + port); } catch (Exception e) { log.error("Couldn't create connector."); } return (connector); }
public SocketState process(NioChannel socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); remoteAddr = null; remoteHost = null; localAddr = null; localName = null; remotePort = -1; localPort = -1; this.socket = socket; inputBuffer.setSocket(socket); outputBuffer.setSocket(socket); inputBuffer.setSelectorPool(endpoint.getSelectorPool()); outputBuffer.setSelectorPool(endpoint.getSelectorPool()); error = false; keepAlive = true; int keepAliveLeft = maxKeepAliveRequests; long soTimeout = endpoint.getSoTimeout(); int limit = 0; if (endpoint.getFirstReadTimeout() > 0 || endpoint.getFirstReadTimeout() < -1) { limit = endpoint.getMaxThreads() / 2; } boolean keptAlive = false; boolean openSocket = false; boolean recycle = true; while (!error && keepAlive && !comet) { try { if (!disableUploadTimeout && keptAlive && soTimeout > 0) { socket.getIOChannel().socket().setSoTimeout((int) soTimeout); inputBuffer.readTimeout = soTimeout; } if (!inputBuffer.parseRequestLine(keptAlive && (endpoint.getCurrentThreadsBusy() >= limit))) { // This means that no data is available right now // (long keepalive), so that the processor should be recycled openSocket = true; socket.getPoller().add(socket); break; } keptAlive = true; if (!inputBuffer.parseHeaders()) { openSocket = true; socket.getPoller().add(socket); recycle = false; break; } request.setStartTime(System.currentTimeMillis()); if (!disableUploadTimeout) { socket.getIOChannel().socket().setSoTimeout((int) timeout); inputBuffer.readTimeout = soTimeout; } } catch (IOException e) { error = true; break; } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.header.parse"), t); } response.setStatus(400); error = true; } rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare"), t); } response.setStatus(400); error = true; } if (maxKeepAliveRequests > 0 && --keepAliveLeft == 0) keepAlive = false; if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); if (keepAlive && !error) { error = response.getErrorException() != null || statusDropsConnection(response.getStatus()); } SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); if (key != null) { NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment(); if (attach != null) { attach.setComet(comet); if (comet) { Integer comettimeout = (Integer) request.getAttribute("org.apache.tomcat.comet.timeout"); if (comettimeout != null) attach.setTimeout(comettimeout.longValue()); } } } } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("http11processor.request.process"), t); response.setStatus(500); error = true; } } if (!comet) { endRequest(); } if (error) { response.setStatus(500); } request.updateCounters(); if (sendfileData != null && !error) { KeyAttachment ka = (KeyAttachment) socket.getAttachment(false); ka.setSendfileData(sendfileData); sendfileData.keepAlive = keepAlive; SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector()); openSocket = socket.getPoller().processSendfile(key, ka, true); break; } rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (comet) { if (error) { recycle(); return SocketState.CLOSED; } else { return SocketState.LONG; } } else { if (recycle) recycle(); return (openSocket) ? SocketState.OPEN : SocketState.CLOSED; } }	public SocketState process(long socket) throws IOException { RequestInfo rp = request.getRequestProcessor(); rp.setStage(org.apache.coyote.Constants.STAGE_PARSE); remoteAddr = null; remoteHost = null; localAddr = null; localName = null; remotePort = -1; localPort = -1; this.socket = socket; inputBuffer.setSocket(socket); outputBuffer.setSocket(socket); error = false; keepAlive = true; int keepAliveLeft = maxKeepAliveRequests; long soTimeout = endpoint.getSoTimeout(); boolean keptAlive = false; boolean openSocket = false; while (!error && keepAlive && !comet) { try { if (!disableUploadTimeout && keptAlive && soTimeout > 0) { Socket.timeoutSet(socket, soTimeout * 1000); } if (!inputBuffer.parseRequestLine(keptAlive)) { // This means that no data is available right now // (long keepalive), so that the processor should be recycled openSocket = true; endpoint.getPoller().add(socket); break; } request.setStartTime(System.currentTimeMillis()); keptAlive = true; if (!disableUploadTimeout) { Socket.timeoutSet(socket, timeout * 1000); } inputBuffer.parseHeaders(); } catch (IOException e) { error = true; break; } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.header.parse"), t); } response.setStatus(400); error = true; } rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { prepareRequest(); } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(sm.getString("http11processor.request.prepare"), t); } response.setStatus(400); error = true; } if (maxKeepAliveRequests > 0 && --keepAliveLeft == 0) keepAlive = false; if (!error) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); if (keepAlive && !error) { error = response.getErrorException() != null || statusDropsConnection(response.getStatus()); } } catch (InterruptedIOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("http11processor.request.process"), t); response.setStatus(500); error = true; } } if (!comet) { endRequest(); } if (error) { response.setStatus(500); } request.updateCounters(); if (sendfileData != null && !error) { sendfileData.socket = socket; sendfileData.keepAlive = keepAlive; if (!endpoint.getSendfile().add(sendfileData)) { openSocket = true; break; } } rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE); } rp.setStage(org.apache.coyote.Constants.STAGE_ENDED); if (comet) { if (error) { recycle(); return SocketState.CLOSED; } else { return SocketState.LONG; } } else { recycle(); return (openSocket) ? SocketState.OPEN : SocketState.CLOSED; } }	public void endRequest() { try { inputBuffer.endRequest(); } catch (IOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("http11processor.request.finish"), t); response.setStatus(500); error = true; } try { outputBuffer.endRequest(); } catch (IOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("http11processor.response.finish"), t); error = true; } inputBuffer.nextRequest(); outputBuffer.nextRequest(); }	public void endRequest() { try { inputBuffer.endRequest(); } catch (IOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("http11processor.request.finish"), t); response.setStatus(500); error = true; } try { outputBuffer.endRequest(); } catch (IOException e) { error = true; } catch (Throwable t) { log.error(sm.getString("http11processor.response.finish"), t); error = true; } inputBuffer.nextRequest(); outputBuffer.nextRequest(); }	public void nextRequest() { request.recycle(); if (lastValid - pos > 0) { int npos = 0; int opos = pos; while (lastValid - opos > opos - npos) { System.arraycopy(buf, opos, buf, npos, opos - npos); npos += pos; opos += pos; } System.arraycopy(buf, opos, buf, npos, lastValid - opos); } for (int i = 0; i <= lastActiveFilter; i++) { activeFilters[i].recycle(); } lastValid = lastValid - pos; pos = 0; lastActiveFilter = -1; parsingHeader = true; headerParsePos = HeaderParsePosition.HEADER_START; parsingRequestLine = true; headerData.recycle(); swallowInput = true; }
private Map getJarPaths() { HashMap jarPathMap = null; ClassLoader webappLoader = Thread.currentThread().getContextClassLoader(); ClassLoader loader = webappLoader; while (loader != null) { if (loader instanceof URLClassLoader) { URL[] urls = ((URLClassLoader) loader).getURLs(); for (int i = 0; i < urls.length; i++) { // Expect file URLs // This is definitely not as clean as using JAR URLs either // over file or the custom jndi handler, but a lot less File file = new File(urls[i].getFile()); try { file = file.getCanonicalFile(); } catch (IOException e) { // Ignore } if (!file.exists()) { continue; } String path = file.getAbsolutePath(); if (!path.endsWith(".jar")) { continue; } if (loader == webappLoader || noTldJars == null || !noTldJars.contains(file.getName())) { if (jarPathMap == null) { jarPathMap = new HashMap(); jarPathMap.put(path, file); } else if (!jarPathMap.containsKey(path)) { jarPathMap.put(path, file); } } } } loader = loader.getParent(); } return jarPathMap; }	private void tldScanJar(String resourcePath) throws Exception { if (log.isDebugEnabled()) { log.debug(" Scanning JAR at resource path '" + resourcePath + "'"); } URL url = context.getServletContext().getResource(resourcePath); if (url == null) { throw new IllegalArgumentException(sm.getString("contextConfig.tldResourcePath", resourcePath)); } File file = new File(url.getFile()); file = file.getCanonicalFile(); tldScanJar(file); }
public void service(HttpServletRequest request, HttpServletResponse response, boolean precompile) throws ServletException, IOException, FileNotFoundException { try { if (ctxt.isRemoved()) { throw new FileNotFoundException(jspUri); } if ((available > 0L) && (available < Long.MAX_VALUE)) { response.setDateHeader("Retry-After", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, Localizer.getMessage("jsp.error.unavailable")); } if (options.getDevelopment() || firstTime) { synchronized (this) { firstTime = false; ctxt.compile(); } } else { if (compileException != null) { throw compileException; } } getServlet(); if (precompile) { return; } } catch (FileNotFoundException ex) { ctxt.incrementRemoved(); String includeRequestUri = (String) request.getAttribute("javax.servlet.include.request_uri"); if (includeRequestUri != null) { throw new ServletException(ex); } else { try { response.sendError(HttpServletResponse.SC_NOT_FOUND, ex.getMessage()); } catch (IllegalStateException ise) { log.error(Localizer.getMessage("jsp.error.file.not.found", ex.getMessage()), ex); } } } catch (ServletException ex) { if (options.getDevelopment()) { throw handleJspException(ex); } else { throw ex; } } catch (IOException ex) { if (options.getDevelopment()) { throw handleJspException(ex); } else { throw ex; } } catch (IllegalStateException ex) { if (options.getDevelopment()) { throw handleJspException(ex); } else { throw ex; } } catch (Exception ex) { if (options.getDevelopment()) { throw handleJspException(ex); } else { throw new JasperException(ex); } } try { if (theServlet instanceof SingleThreadModel) { synchronized (this) { theServlet.service(request, response); } } else { theServlet.service(request, response); } } catch (UnavailableException ex) { String includeRequestUri = (String) request.getAttribute("javax.servlet.include.request_uri"); if (includeRequestUri != null) { throw ex; } else { int unavailableSeconds = ex.getUnavailableSeconds(); if (unavailableSeconds <= 0) { unavailableSeconds = 60; } available = System.currentTimeMillis() + (unavailableSeconds * 1000L); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, ex.getMessage()); } } catch (ServletException ex) { if (options.getDevelopment()) { throw handleJspException(ex); } else { throw ex; } } catch (IOException ex) { if (options.getDevelopment()) { throw handleJspException(ex); } else { throw ex; } } catch (IllegalStateException ex) { if (options.getDevelopment()) { throw handleJspException(ex); } else { throw ex; } } catch (Exception ex) { if (options.getDevelopment()) { throw handleJspException(ex); } else { throw new JasperException(ex); } } }
public final void invoke(Request request, Response response) throws IOException, ServletException { boolean unavailable = false; Throwable throwable = null; long t1 = System.currentTimeMillis(); requestCount++; StandardWrapper wrapper = (StandardWrapper) getContainer(); Servlet servlet = null; Context context = (Context) wrapper.getParent(); if (!context.getAvailable()) { response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("standardContext.isUnavailable")); unavailable = true; } if (!unavailable && wrapper.isUnavailable()) { container.getLogger().info(sm.getString("standardWrapper.isUnavailable", wrapper.getName())); long available = wrapper.getAvailable(); if ((available > 0L) && (available < Long.MAX_VALUE)) { response.setDateHeader("Retry-After", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("standardWrapper.isUnavailable", wrapper.getName())); } else if (available == Long.MAX_VALUE) { response.sendError(HttpServletResponse.SC_NOT_FOUND, sm.getString("standardWrapper.notFound", wrapper.getName())); } unavailable = true; } try { if (!unavailable) { servlet = wrapper.allocate(); } } catch (UnavailableException e) { long available = wrapper.getAvailable(); if ((available > 0L) && (available < Long.MAX_VALUE)) { response.setDateHeader("Retry-After", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("standardWrapper.isUnavailable", wrapper.getName())); } else if (available == Long.MAX_VALUE) { response.sendError(HttpServletResponse.SC_NOT_FOUND, sm.getString("standardWrapper.notFound", wrapper.getName())); } } catch (ServletException e) { container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), StandardWrapper.getRootCause(e)); throwable = e; exception(request, response, e); servlet = null; } catch (Throwable e) { container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), e); throwable = e; exception(request, response, e); servlet = null; } boolean comet = false; if (servlet instanceof CometProcessor && request.getAttribute("org.apache.tomcat.comet.support") == Boolean.TRUE) { comet = true; } try { response.sendAcknowledgement(); } catch (IOException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); container.getLogger().warn(sm.getString("standardWrapper.acknowledgeException", wrapper.getName()), e); throwable = e; exception(request, response, e); } catch (Throwable e) { container.getLogger().error(sm.getString("standardWrapper.acknowledgeException", wrapper.getName()), e); throwable = e; exception(request, response, e); servlet = null; } MessageBytes requestPathMB = null; if (request != null) { requestPathMB = request.getRequestPathMB(); } request.setAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR, ApplicationFilterFactory.REQUEST_INTEGER); request.setAttribute(ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB); ApplicationFilterFactory factory = ApplicationFilterFactory.getInstance(); ApplicationFilterChain filterChain = factory.createFilterChain(request, wrapper, servlet); try { String jspFile = wrapper.getJspFile(); if (jspFile != null) request.setAttribute(Globals.JSP_FILE_ATTR, jspFile); else request.removeAttribute(Globals.JSP_FILE_ATTR); if ((servlet != null) && (filterChain != null)) { if (context.getSwallowOutput()) { try { SystemLogHandler.startCapture(); if (comet) { filterChain.doFilterEvent(request.getEvent()); request.setComet(true); } else { filterChain.doFilter(request.getRequest(), response.getResponse()); } } finally { String log = SystemLogHandler.stopCapture(); if (log != null && log.length() > 0) { context.getLogger().info(log); } } } else { if (comet) { filterChain.doFilterEvent(request.getEvent()); request.setComet(true); } else { filterChain.doFilter(request.getRequest(), response.getResponse()); } } } request.removeAttribute(Globals.JSP_FILE_ATTR); } catch (ClientAbortException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); throwable = e; exception(request, response, e); } catch (IOException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName()), e); throwable = e; exception(request, response, e); } catch (UnavailableException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName()), e); // throwable = e; wrapper.unavailable(e); long available = wrapper.getAvailable(); if ((available > 0L) && (available < Long.MAX_VALUE)) { response.setDateHeader("Retry-After", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("standardWrapper.isUnavailable", wrapper.getName())); } else if (available == Long.MAX_VALUE) { response.sendError(HttpServletResponse.SC_NOT_FOUND, sm.getString("standardWrapper.notFound", wrapper.getName())); } // Do not save exception in 'throwable', because we // do not want to do exception(request, response, e) processing } catch (ServletException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); Throwable rootCause = StandardWrapper.getRootCause(e); if (!(rootCause instanceof ClientAbortException)) { container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName()), rootCause); } throwable = e; exception(request, response, e); } catch (Throwable e) { request.removeAttribute(Globals.JSP_FILE_ATTR); container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName()), e); throwable = e; exception(request, response, e); } if (filterChain != null) { if (request.isComet()) { // If this is a Comet request, then the same chain will be used for the filterChain.reuse(); } else { filterChain.release(); } } try { if (servlet != null) { wrapper.deallocate(servlet); } } catch (Throwable e) { container.getLogger().error(sm.getString("standardWrapper.deallocateException", wrapper.getName()), e); if (throwable == null) { throwable = e; exception(request, response, e); } } try { if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) { wrapper.unload(); } } catch (Throwable e) { container.getLogger().error(sm.getString("standardWrapper.unloadException", wrapper.getName()), e); if (throwable == null) { throwable = e; exception(request, response, e); } } long t2 = System.currentTimeMillis(); long time = t2 - t1; processingTime += time; if (time > maxTime) maxTime = time; if (time < minTime) minTime = time; }

protected void readConfiguration(InputStream is, ClassLoader classLoader) throws IOException { ClassLoaderLogInfo info = (ClassLoaderLogInfo) classLoaderLoggers.get(classLoader); try { info.props.load(is); } catch (IOException e) { System.err.println("Configuration error"); e.printStackTrace(); } finally { try { is.close(); } catch (Throwable t) { } } String rootHandlers = info.props.getProperty(".handlers"); String handlers = info.props.getProperty("handlers"); Logger localRootLogger = info.rootNode.logger; if (handlers != null) { StringTokenizer tok = new StringTokenizer(handlers, ","); while (tok.hasMoreTokens()) { String handlerName = (tok.nextToken().trim()); String handlerClassName = handlerName; String prefix = ""; if (handlerClassName.length() <= 0) { continue; } if (Character.isDigit(handlerClassName.charAt(0))) { int pos = handlerClassName.indexOf('.'); if (pos >= 0) { prefix = handlerClassName.substring(0, pos + 1); handlerClassName = handlerClassName.substring(pos + 1); } } try { this.prefix.set(prefix); Handler handler = (Handler) classLoader.loadClass(handlerClassName).newInstance(); // The specification strongly implies all configuration should be done // during the creation of the handler object. this.prefix.set(null); info.handlers.put(handlerName, handler); if (rootHandlers == null) { localRootLogger.addHandler(handler); } } catch (Exception e) { System.err.println("Handler error"); e.printStackTrace(); } } if (rootHandlers != null) { StringTokenizer tok2 = new StringTokenizer(rootHandlers, ","); while (tok2.hasMoreTokens()) { String handlerName = (tok2.nextToken().trim()); Handler handler = (Handler) info.handlers.get(handlerName); if (handler != null) { localRootLogger.addHandler(handler); } } } } }
public Servlet getServlet() throws ServletException, IOException, FileNotFoundException { if (reload) { synchronized (this) { if (reload) { destroy(); try { servletClass = ctxt.load(); theServlet = (Servlet) servletClass.newInstance(); AnnotationProcessor annotationProcessor = (AnnotationProcessor) config.getServletContext().getAttribute(AnnotationProcessor.class.getName()); if (annotationProcessor != null) { annotationProcessor.processAnnotations(theServlet); annotationProcessor.postConstruct(theServlet); } } catch (IllegalAccessException e) { throw new JasperException(e); } catch (InstantiationException e) { throw new JasperException(e); } catch (Exception e) { throw new JasperException(e); } theServlet.init(config); if (!firstTime) { ctxt.getRuntimeContext().incrementJspReloadCount(); } reload = false; } } } return theServlet; }
protected void deploy(PrintWriter writer, String config, String path, String war, boolean update) { if (config != null && config.length() == 0) { config = null; } if (war != null && war.length() == 0) { war = null; } if (debug >= 1) { if (config != null && config.length() > 0) { if (war != null) { log("install: Installing context configuration at '" + config + "' from '" + war + "'"); } else { log("install: Installing context configuration at '" + config + "'"); } } else { if (path != null && path.length() > 0) { log("install: Installing web application at '" + path + "' from '" + war + "'"); } else { log("install: Installing web application from '" + war + "'"); } } } if (path == null || path.length() == 0 || !path.startsWith("/")) { writer.println(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); return; } String displayPath = path; if ("/".equals(path)) { path = ""; } Context context = (Context) host.findChild(path); if (update) { if (context != null) { undeploy(writer, displayPath); } context = (Context) host.findChild(path); } if (context != null) { writer.println(sm.getString("managerServlet.alreadyContext", displayPath)); return; } if (config != null && (config.startsWith("file:"))) { config = config.substring("file:".length()); } if (war != null && (war.startsWith("file:"))) { war = war.substring("file:".length()); } try { if (!isServiced(path)) { addServiced(path); try { if (config != null) { copy(new File(config), new File(configBase, getConfigFile(path) + ".xml")); } if (war != null) { if (war.endsWith(".war")) { copy(new File(war), new File(getAppBase(), getDocBase(path) + ".war")); } else { copy(new File(war), new File(getAppBase(), getDocBase(path))); } } check(path); } finally { removeServiced(path); } } context = (Context) host.findChild(path); if (context != null && context.getConfigured()) { writer.println(sm.getString("managerServlet.deployed", displayPath)); } else { writer.println(sm.getString("managerServlet.deployFailed", displayPath)); } } catch (Throwable t) { log("ManagerServlet.install[" + displayPath + "]", t); writer.println(sm.getString("managerServlet.exception", t.toString())); } }
public void setAddress(Member member) { this.address = address; }
public void expire(boolean notify, boolean notifyCluster) { String expiredId = getIdInternal(); super.expire(notify); if (notifyCluster) { if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.notifying", ((DeltaManager) manager).getName(), new Boolean(isPrimarySession()), expiredId)); if (manager instanceof DeltaManager) { ((DeltaManager) manager).sessionExpired(expiredId); } } }
public Object remove(Object key) { MapEntry entry = (MapEntry) super.remove(key); try { if (getMapMembers().length > 0) { MapMessage msg = new MapMessage(getMapContextName(), MapMessage.MSG_REMOVE, false, (Serializable) key, null, null, null); getChannel().send(getMapMembers(), msg, getChannelSendOptions()); } } catch (ChannelException x) { log.error("Unable to replicate out data for a LazyReplicatedMap.remove operation", x); } return entry != null ? entry.getValue() : null; }	public Object setKey(Object key) { Object old = this.key; this.key = (Serializable) key; return old; }	public Object setValue(Object value) { Object old = this.value; this.value = (Serializable) value; return old; }	public ServletContext getServletContext() { return ((ReplApplContext) context).getFacade(); }	public Set entrySet() { LinkedHashSet set = new LinkedHashSet(super.size()); Iterator i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry e = (Map.Entry) i.next(); MapEntry entry = (MapEntry) e.getValue(); if (entry.isPrimary()) set.add(entry); } return Collections.unmodifiableSet(set); }	public Set keySet() { //todo implement LinkedHashSet set = new LinkedHashSet(super.size()); Iterator i = super.entrySet().iterator(); while (i.hasNext()) { Map.Entry e = (Map.Entry) i.next(); MapEntry entry = (MapEntry) e.getValue(); if (entry.isPrimary()) set.add(entry.getKey()); } return Collections.unmodifiableSet(set); }	public void clear() { Iterator keys = keySet().iterator(); while (keys.hasNext()) remove(keys.next()); }	public void putAll(Map m) { Iterator i = m.entrySet().iterator(); while (i.hasNext()) { Map.Entry entry = (Map.Entry) i.next(); put(entry.getKey(), entry.getValue()); } }	public void setAttribute(String name, Object value) { if (name == null) throw new IllegalArgumentException(sm.getString("applicationContext.setAttribute.namenull")); if (value == null) { removeAttribute(name); return; } Object oldValue = null; boolean replaced = false; if (readOnlyAttributes.containsKey(name)) return; oldValue = attributes.get(name); if (oldValue != null) replaced = true; attributes.put(name, value); Object[] listeners = context.getApplicationEventListeners(); if ((listeners == null) || (listeners.length == 0)) return; ServletContextAttributeEvent event = null; if (replaced) event = new ServletContextAttributeEvent(context.getServletContext(), name, oldValue); else event = new ServletContextAttributeEvent(context.getServletContext(), name, value); for (int i = 0; i < listeners.length; i++) { if (!(listeners[i] instanceof ServletContextAttributeListener)) continue; ServletContextAttributeListener listener = (ServletContextAttributeListener) listeners[i]; try { if (replaced) { context.fireContainerEvent("beforeContextAttributeReplaced", listener); listener.attributeReplaced(event); context.fireContainerEvent("afterContextAttributeReplaced", listener); } else { context.fireContainerEvent("beforeContextAttributeAdded", listener); listener.attributeAdded(event); context.fireContainerEvent("afterContextAttributeAdded", listener); } } catch (Throwable t) { if (replaced) context.fireContainerEvent("afterContextAttributeReplaced", listener); else context.fireContainerEvent("afterContextAttributeAdded", listener); log(sm.getString("applicationContext.attributeEvent"), t); } } }	public void setAttributeMap(AbstractMap map) { this.attributes = map; }
protected void prepareRequest() { http11 = true; http09 = false; contentDelimitation = false; expectation = false; if (sslSupport != null) { request.scheme().setString("https"); } MessageBytes protocolMB = request.protocol(); if (protocolMB.equals(Constants.HTTP_11)) { http11 = true; protocolMB.setString(Constants.HTTP_11); } else if (protocolMB.equals(Constants.HTTP_10)) { http11 = false; keepAlive = false; protocolMB.setString(Constants.HTTP_10); } else if (protocolMB.equals("")) { http09 = true; http11 = false; keepAlive = false; } else { http11 = false; error = true; response.setStatus(505); } MessageBytes methodMB = request.method(); if (methodMB.equals(Constants.GET)) { methodMB.setString(Constants.GET); } else if (methodMB.equals(Constants.POST)) { methodMB.setString(Constants.POST); } MimeHeaders headers = request.getMimeHeaders(); MessageBytes connectionValueMB = headers.getValue("connection"); if (connectionValueMB != null) { ByteChunk connectionValueBC = connectionValueMB.getByteChunk(); if (findBytes(connectionValueBC, Constants.CLOSE_BYTES) != -1) { keepAlive = false; } else if (findBytes(connectionValueBC, Constants.KEEPALIVE_BYTES) != -1) { keepAlive = true; } } MessageBytes expectMB = null; if (http11) expectMB = headers.getValue("expect"); if ((expectMB != null) && (expectMB.indexOfIgnoreCase("100-continue", 0) != -1)) { inputBuffer.setSwallowInput(false); expectation = true; } if ((restrictedUserAgents != null) && ((http11) || (keepAlive))) { MessageBytes userAgentValueMB = headers.getValue("user-agent"); if (userAgentValueMB != null) { String userAgentValue = userAgentValueMB.toString(); for (int i = 0; i < restrictedUserAgents.length; i++) { if (restrictedUserAgents[i].matcher(userAgentValue).matches()) { http11 = false; keepAlive = false; break; } } } } ByteChunk uriBC = request.requestURI().getByteChunk(); if (uriBC.startsWithIgnoreCase("http", 0)) { int pos = uriBC.indexOf("://", 0, 3, 4); int uriBCStart = uriBC.getStart(); int slashPos = -1; if (pos != -1) { byte[] uriB = uriBC.getBytes(); slashPos = uriBC.indexOf('/', pos + 3); if (slashPos == -1) { slashPos = uriBC.getLength(); request.requestURI().setBytes(uriB, uriBCStart + pos + 1, 1); } else { request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos); } MessageBytes hostMB = headers.setValue("host"); hostMB.setBytes(uriB, uriBCStart + pos + 3, slashPos - pos - 3); } } InputFilter[] inputFilters = inputBuffer.getFilters(); MessageBytes transferEncodingValueMB = null; if (http11) transferEncodingValueMB = headers.getValue("transfer-encoding"); if (transferEncodingValueMB != null) { String transferEncodingValue = transferEncodingValueMB.toString(); int startPos = 0; int commaPos = transferEncodingValue.indexOf(','); String encodingName = null; while (commaPos != -1) { encodingName = transferEncodingValue.substring(startPos, commaPos).toLowerCase().trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; response.setStatus(501); } startPos = commaPos + 1; commaPos = transferEncodingValue.indexOf(',', startPos); } encodingName = transferEncodingValue.substring(startPos).toLowerCase().trim(); if (!addInputFilter(inputFilters, encodingName)) { error = true; response.setStatus(501); } } long contentLength = request.getContentLengthLong(); if (contentLength >= 0 && !contentDelimitation) { inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]); contentDelimitation = true; } MessageBytes valueMB = headers.getValue("host"); if (http11 && (valueMB == null)) { error = true; response.setStatus(400); } parseHost(valueMB); if (!contentDelimitation) { // If there's no content length // (broken HTTP/1.0 or HTTP/1.1), assume inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]); contentDelimitation = true; } }
protected Principal createPrincipal(String username, Subject subject) { // Prepare to scan the Principals for this Subject String password = null; List roles = new ArrayList(); Principal userPrincipal = null; Iterator principals = subject.getPrincipals().iterator(); while (principals.hasNext()) { Principal principal = (Principal) principals.next(); String principalClass = principal.getClass().getName(); if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.checkPrincipal", principal, principalClass)); } if (userPrincipal == null && userClasses.contains(principalClass)) { userPrincipal = principal; if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.userPrincipalSuccess", principal.getName())); } } if (roleClasses.contains(principalClass)) { roles.add(principal.getName()); if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.rolePrincipalAdd", principal.getName())); } } } if (userPrincipal == null) { if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.userPrincipalFailure")); log.debug(sm.getString("jaasRealm.rolePrincipalFailure")); } } else { if (roles.size() == 0) { if (log.isDebugEnabled()) { log.debug(sm.getString("jaasRealm.rolePrincipalFailure")); } } } return new GenericPrincipal(this, username, null, roles, userPrincipal); }	public void setContainer(Container container) { super.setContainer(container); if (appName == null) { String name = container.getName(); name = makeLegalForJAAS(name); appName = name; log.info("Set JAAS app name " + appName); } }	public void setRoleClassNames(String roleClassNames) { this.roleClassNames = roleClassNames; roleClasses.clear(); String temp = this.roleClassNames; if (temp == null) { return; } while (true) { int comma = temp.indexOf(','); if (comma < 0) { break; } roleClasses.add(temp.substring(0, comma).trim()); temp = temp.substring(comma + 1); } temp = temp.trim(); if (temp.length() > 0) { roleClasses.add(temp); } }	public void setUserClassNames(String userClassNames) { this.userClassNames = userClassNames; userClasses.clear(); String temp = this.userClassNames; if (temp == null) { return; } while (true) { int comma = temp.indexOf(','); if (comma < 0) { break; } userClasses.add(temp.substring(0, comma).trim()); temp = temp.substring(comma + 1); } temp = temp.trim(); if (temp.length() > 0) { userClasses.add(temp); } }
protected void generateClass(String[] smap) throws FileNotFoundException, JasperException, Exception { long t1 = 0; if (log.isDebugEnabled()) { t1 = System.currentTimeMillis(); } final String sourceFile = ctxt.getServletJavaFileName(); final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); String packageName = ctxt.getServletPackageName(); final String targetClassName = ((packageName.length() != 0) ? (packageName + ".") : "") + ctxt.getServletClassName(); final ClassLoader classLoader = ctxt.getJspLoader(); String[] fileNames = new String[] {sourceFile}; String[] classNames = new String[] {targetClassName}; final ArrayList problemList = new ArrayList(); class CompilationUnit implements ICompilationUnit { String className; String sourceFile; CompilationUnit(String sourceFile, String className) { this.className = className; this.sourceFile = sourceFile; } public char[] getFileName() { return sourceFile.toCharArray(); } public char[] getContents() { char[] result = null; try { InputStreamReader isReader = new InputStreamReader(new FileInputStream(sourceFile), ctxt.getOptions().getJavaEncoding()); Reader reader = new BufferedReader(isReader); if (reader != null) { char[] chars = new char[8192]; StringBuffer buf = new StringBuffer(); int count; while ((count = reader.read(chars, 0, chars.length)) > 0) { buf.append(chars, 0, count); } result = new char[buf.length()]; buf.getChars(0, result.length, result, 0); } } catch (IOException e) { log.error("Compilation error", e); } return result; } public char[] getMainTypeName() { int dot = className.lastIndexOf('.'); if (dot > 0) { return className.substring(dot + 1).toCharArray(); } return className.toCharArray(); } public char[][] getPackageName() { StringTokenizer izer = new StringTokenizer(className, "."); char[][] result = new char[izer.countTokens()-1][]; for (int i = 0; i < result.length; i++) { String tok = izer.nextToken(); result[i] = tok.toCharArray(); } return result; } } final INameEnvironment env = new INameEnvironment() { public NameEnvironmentAnswer findType(char[][] compoundTypeName) { String result = ""; String sep = ""; for (int i = 0; i < compoundTypeName.length; i++) { result += sep; result += new String(compoundTypeName[i]); sep = "."; } return findType(result); } public NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) { String result = ""; String sep = ""; for (int i = 0; i < packageName.length; i++) { result += sep; result += new String(packageName[i]); sep = "."; } result += sep; result += new String(typeName); return findType(result); } } }
public synchronized void start() throws LifecycleException { super.start(); File file = new File(pathname); if (!file.isAbsolute()) file = new File(System.getProperty("catalina.base"), pathname); if (!file.exists() || !file.canRead()) throw new LifecycleException(sm.getString("memoryRealm.loadExist", file.getAbsolutePath())); if (log.isDebugEnabled()) log.debug(sm.getString("memoryRealm.loadPath", file.getAbsolutePath())); Digester digester = getDigester(); try { synchronized (digester) { digester.push(this); digester.parse(file); } } catch (Exception e) { throw new LifecycleException("memoryRealm.readXml", e); } finally { digester.reset(); } }
protected boolean checkIfModifiedSince(HttpServletRequest request, HttpServletResponse response, ResourceAttributes resourceAttributes) throws IOException { try { long headerValue = request.getDateHeader("If-Modified-Since"); long lastModified = resourceAttributes.getLastModified(); if (headerValue != -1) { if ((request.getHeader("If-None-Match") == null) && (lastModified <= headerValue + 1000)) { // The entity has not been modified since the date response.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return false; } } } catch (IllegalArgumentException illegalArgument) { return true; } return true; }	protected boolean checkIfUnmodifiedSince(HttpServletRequest request, HttpServletResponse response, ResourceAttributes resourceAttributes) throws IOException { try { long lastModified = resourceAttributes.getLastModified(); long headerValue = request.getDateHeader("If-Unmodified-Since"); if (headerValue != -1) { if (lastModified > (headerValue + 1000)) { // The entity has not been modified since the date response.sendError(HttpServletResponse.SC_PRECONDITION_FAILED); return false; } } } catch (IllegalArgumentException illegalArgument) { return true; } return true; }
public void loadOnStartup(Container[] children) { TreeMap map = new TreeMap(); for (int i = 0; i < children.length; i++) { Wrapper wrapper = (Wrapper) children[i]; int loadOnStartup = wrapper.getLoadOnStartup(); if (loadOnStartup < 0) continue; if (loadOnStartup == 0) loadOnStartup = Integer.MAX_VALUE; Integer key = new Integer(loadOnStartup); ArrayList list = (ArrayList) map.get(key); if (list == null) { list = new ArrayList(); map.put(key, list); } list.add(wrapper); } Iterator keys = map.keySet().iterator(); while (keys.hasNext()) { Integer key = (Integer) keys.next(); ArrayList list = (ArrayList) map.get(key); Iterator wrappers = list.iterator(); while (wrappers.hasNext()) { Wrapper wrapper = (Wrapper) wrappers.next(); try { wrapper.load(); } catch (ServletException e) { getLogger().error(sm.getString("standardWrapper.loadException", getName()), StandardWrapper.getRootCause(e)); // NOTE: load errors (including a servlet that throws // UnavailableException from tht init() method) are NOT // fatal to application startup } } } }
public final void invoke(Request request, Response response) throws IOException, ServletException { boolean unavailable = false; Throwable throwable = null; long t1 = System.currentTimeMillis(); requestCount++; StandardWrapper wrapper = (StandardWrapper) getContainer(); Servlet servlet = null; Context context = (Context) wrapper.getParent(); if (!context.getAvailable()) { response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("standardContext.isUnavailable")); unavailable = true; } if (!unavailable && wrapper.isUnavailable()) { container.getLogger().info(sm.getString("standardWrapper.isUnavailable", wrapper.getName())); long available = wrapper.getAvailable(); if ((available > 0L) && (available < Long.MAX_VALUE)) { response.setDateHeader("Retry-After", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("standardWrapper.isUnavailable", wrapper.getName())); } else if (available == Long.MAX_VALUE) { response.sendError(HttpServletResponse.SC_NOT_FOUND, sm.getString("standardWrapper.notFound", wrapper.getName())); } unavailable = true; } try { if (!unavailable) { servlet = wrapper.allocate(); } } catch (UnavailableException e) { long available = wrapper.getAvailable(); if ((available > 0L) && (available < Long.MAX_VALUE)) { response.setDateHeader("Retry-After", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("standardWrapper.isUnavailable", wrapper.getName())); } else if (available == Long.MAX_VALUE) { response.sendError(HttpServletResponse.SC_NOT_FOUND, sm.getString("standardWrapper.notFound", wrapper.getName())); } } catch (ServletException e) { container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), StandardWrapper.getRootCause(e)); throwable = e; exception(request, response, e); servlet = null; } catch (Throwable e) { container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), e); throwable = e; exception(request, response, e); servlet = null; } if (servlet instanceof CometProcessor && request.getAttribute("org.apache.tomcat.comet.support") == Boolean.TRUE) { request.setComet(true); } try { response.sendAcknowledgement(); } catch (IOException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); container.getLogger().warn(sm.getString("standardWrapper.acknowledgeException", wrapper.getName()), e); throwable = e; exception(request, response, e); } catch (Throwable e) { container.getLogger().error(sm.getString("standardWrapper.acknowledgeException", wrapper.getName()), e); throwable = e; exception(request, response, e); servlet = null; } MessageBytes requestPathMB = null; if (request != null) { requestPathMB = request.getRequestPathMB(); } request.setAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR, ApplicationFilterFactory.REQUEST_INTEGER); request.setAttribute(ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB); ApplicationFilterFactory factory = ApplicationFilterFactory.getInstance(); ApplicationFilterChain filterChain = factory.createFilterChain(request, wrapper, servlet); try { String jspFile = wrapper.getJspFile(); if (jspFile != null) request.setAttribute(Globals.JSP_FILE_ATTR, jspFile); else request.removeAttribute(Globals.JSP_FILE_ATTR); if ((servlet != null) && (filterChain != null)) { if (context.getSwallowOutput()) { try { SystemLogHandler.startCapture(); if (request.isComet()) { filterChain.doFilterEvent(request.getEvent()); } else { filterChain.doFilter(request.getRequest(), response.getResponse()); } } finally { String log = SystemLogHandler.stopCapture(); if (log != null && log.length() > 0) { context.getLogger().info(log); } } } else { if (request.isComet()) { filterChain.doFilterEvent(request.getEvent()); } else { filterChain.doFilter(request.getRequest(), response.getResponse()); } } } request.removeAttribute(Globals.JSP_FILE_ATTR); } catch (ClientAbortException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); throwable = e; exception(request, response, e); } catch (IOException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); container.getLogger().warn(sm.getString("standardWrapper.serviceException", wrapper.getName()), e); throwable = e; exception(request, response, e); } catch (UnavailableException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); container.getLogger().warn(sm.getString("standardWrapper.serviceException", wrapper.getName()), e); // throwable = e; wrapper.unavailable(e); long available = wrapper.getAvailable(); if ((available > 0L) && (available < Long.MAX_VALUE)) { response.setDateHeader("Retry-After", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString("standardWrapper.isUnavailable", wrapper.getName())); } else if (available == Long.MAX_VALUE) { response.sendError(HttpServletResponse.SC_NOT_FOUND, sm.getString("standardWrapper.notFound", wrapper.getName())); } // Do not save exception in 'throwable', because we // do not want to do exception(request, response, e) processing } catch (ServletException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); Throwable rootCause = StandardWrapper.getRootCause(e); if (!(rootCause instanceof ClientAbortException)) { container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName()), rootCause); } throwable = e; exception(request, response, e); } catch (Throwable e) { request.removeAttribute(Globals.JSP_FILE_ATTR); container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName()), e); throwable = e; exception(request, response, e); } if (filterChain != null) { if (request.isComet()) { // If this is a Comet request, then the same chain will be used for the filterChain.reuse(); } else { filterChain.release(); } } try { if (servlet != null) { wrapper.deallocate(servlet); } } catch (Throwable e) { container.getLogger().error(sm.getString("standardWrapper.deallocateException", wrapper.getName()), e); if (throwable == null) { throwable = e; exception(request, response, e); } } try { if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) { wrapper.unload(); } } catch (Throwable e) { container.getLogger().error(sm.getString("standardWrapper.unloadException", wrapper.getName()), e); if (throwable == null) { throwable = e; exception(request, response, e); } } long t2 = System.currentTimeMillis(); long time = t2 - t1; processingTime += time; if (time > maxTime) maxTime = time; if (time < minTime) minTime = time; }	public void event(Request request, Response response, CometEvent event) throws IOException, ServletException { Throwable throwable = null; long t1 = System.currentTimeMillis(); StandardWrapper wrapper = (StandardWrapper) getContainer(); Servlet servlet = null; Context context = (Context) wrapper.getParent(); boolean unavailable = !context.getAvailable() || wrapper.isUnavailable(); try { if (!unavailable) { servlet = wrapper.allocate(); } } catch (UnavailableException e) { // The response is already committed, so it's not possible to do anything } catch (ServletException e) { container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), StandardWrapper.getRootCause(e)); throwable = e; exception(request, response, e); servlet = null; } catch (Throwable e) { container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), e); throwable = e; exception(request, response, e); servlet = null; } MessageBytes requestPathMB = null; if (request != null) { requestPathMB = request.getRequestPathMB(); } request.setAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR, ApplicationFilterFactory.REQUEST_INTEGER); request.setAttribute(ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB); ApplicationFilterChain filterChain = (ApplicationFilterChain) request.getFilterChain(); try { String jspFile = wrapper.getJspFile(); if (jspFile != null) request.setAttribute(Globals.JSP_FILE_ATTR, jspFile); else request.removeAttribute(Globals.JSP_FILE_ATTR); if ((servlet != null) && (filterChain != null)) { if (context.getSwallowOutput()) { try { SystemLogHandler.startCapture(); filterChain.doFilterEvent(request.getEvent()); } finally { String log = SystemLogHandler.stopCapture(); if (log != null && log.length() > 0) { context.getLogger().info(log); } } } else { filterChain.doFilterEvent(request.getEvent()); } } request.removeAttribute(Globals.JSP_FILE_ATTR); } catch (ClientAbortException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); throwable = e; exception(request, response, e); } catch (IOException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); container.getLogger().warn(sm.getString("standardWrapper.serviceException", wrapper.getName()), e); throwable = e; exception(request, response, e); } catch (UnavailableException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); container.getLogger().warn(sm.getString("standardWrapper.serviceException", wrapper.getName()), e); // Do not save exception in 'throwable', because we // do not want to do exception(request, response, e) processing } catch (ServletException e) { request.removeAttribute(Globals.JSP_FILE_ATTR); Throwable rootCause = StandardWrapper.getRootCause(e); if (!(rootCause instanceof ClientAbortException)) { container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName()), rootCause); } throwable = e; exception(request, response, e); } catch (Throwable e) { request.removeAttribute(Globals.JSP_FILE_ATTR); container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName()), e); throwable = e; exception(request, response, e); } if (filterChain != null) { filterChain.reuse(); } try { if (servlet != null) { wrapper.deallocate(servlet); } } catch (Throwable e) { container.getLogger().error(sm.getString("standardWrapper.deallocateException", wrapper.getName()), e); if (throwable == null) { throwable = e; exception(request, response, e); } } try { if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) { wrapper.unload(); } } catch (Throwable e) { container.getLogger().error(sm.getString("standardWrapper.unloadException", wrapper.getName()), e); if (throwable == null) { throwable = e; exception(request, response, e); } } long t2 = System.currentTimeMillis(); long time = t2 - t1; processingTime += time; if (time > maxTime) maxTime = time; if (time < minTime) minTime = time; }
PageContext internalGetPageContext(Servlet servlet, ServletRequest request, ServletResponse response, String errorPageURL, boolean needsSession, int bufferSize, boolean autoflush) { try { PageContext pc; if (USE_POOL) { pc = (PageContext) pool.get(); if (pc == null) { pc = new PageContextImpl(); } } else { pc = new PageContextImpl(); } pc.initialize(servlet, request, response, errorPageURL, needsSession, bufferSize, autoflush); return pc; } catch (Throwable ex) { log.fatal("Exception initializing page context", ex); return null; } }	private void internalReleasePageContext(PageContext pc) { pc.release(); if (USE_POOL && (pc instanceof PageContextImpl)) { pool.put(pc); } }	private void internalReleasePageContext(PageContext pc) { pc.release(); if (USE_POOL && (pc instanceof PageContextImpl)) { pool.put(pc); } }
private void genPreambleStaticInitializers() throws JasperException { out.printil("private static java.util.List _jspx_dependants;"); out.println(); List dependants = pageInfo.getDependants(); Iterator iter = dependants.iterator(); if (!dependants.isEmpty()) { out.printil("static {"); out.pushIndent(); out.printin("_jspx_dependants = new java.util.ArrayList("); out.print("" + dependants.size()); out.println(");"); while (iter.hasNext()) { out.printin("_jspx_dependants.add(\""); out.print((String) iter.next()); out.println("\");"); } out.popIndent(); out.printil("}"); out.println(); } }	void generateInit() { if (ctxt.isTagFile()) { out.printil("private void _jspInit(ServletConfig config) {"); } else { out.printil("public void _jspInit() {"); } out.pushIndent(); if (isPoolingEnabled) { for (int i = 0; i < tagHandlerPoolNames.size(); i++) { out.printin(tagHandlerPoolNames.elementAt(i)); out.print(" = org.apache.jasper.runtime.TagHandlerPool.getTagHandlerPool("); if (ctxt.isTagFile()) { out.print("config"); } else { out.print("getServletConfig()"); } out.println(");"); } } out.printin(VAR_EXPRESSIONFACTORY); out.print(" = JspFactory.getDefaultFactory().getJspApplicationContext("); if (ctxt.isTagFile()) { out.print("config"); } else { out.print("getServletConfig()"); } out.println(".getServletContext()).getExpressionFactory();"); out.printin(VAR_ANNOTATIONPROCESSOR); out.print(" = (org.apache.AnnotationProcessor) "); if (ctxt.isTagFile()) { out.print("config"); } else { out.print("getServletConfig()"); } out.println(".getServletContext().getAttribute(org.apache.AnnotationProcessor.class.getName());"); out.popIndent(); out.printil("}"); out.println(); }	private void generatePostamble(Node.Nodes page) { out.popIndent(); out.printil("} catch (Throwable t) {"); out.pushIndent(); out.printil("if (!(t instanceof SkipPageException)){"); out.pushIndent(); out.printil("out = _jspx_out;"); out.printil("if (out != null && out.getBufferSize() != 0)"); out.pushIndent(); out.printil("try { out.clearBuffer(); } catch (java.io.IOException e) {}"); out.popIndent(); out.printil("if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("} finally {"); out.pushIndent(); out.printil("if (_jspxFactory != null) _jspxFactory.releasePageContext(_jspx_page_context);"); out.popIndent(); out.printil("}"); out.popIndent(); out.printil("}"); genCommonPostamble(); }	private void generatePreamble(Node.Nodes page) throws JasperException { String servletPackageName = ctxt.getServletPackageName(); String servletClassName = ctxt.getServletClassName(); String serviceMethodName = Constants.SERVICE_METHOD_NAME; genPreamblePackage(servletPackageName); genPreambleImports(); out.printin("public final class "); out.print(servletClassName); out.print(" extends "); out.println(pageInfo.getExtends()); out.printin(" implements org.apache.jasper.runtime.JspSourceDependent"); if (!pageInfo.isThreadSafe()) { out.println(","); out.printin(" SingleThreadModel"); } out.println(" {"); out.pushIndent(); generateDeclarations(page); genPreambleStaticInitializers(); genPreambleClassVariableDeclarations(servletClassName); // Constructor // generateConstructor(className); genPreambleMethods(); out.printin("public void "); out.print(serviceMethodName); out.println("(HttpServletRequest request, HttpServletResponse response)"); out.println(" throws java.io.IOException, ServletException {"); out.pushIndent(); out.println(); out.printil("JspFactory _jspxFactory = null;"); out.printil("PageContext pageContext = null;"); if (pageInfo.isSession()) out.printil("HttpSession session = null;"); if (pageInfo.isErrorPage()) { out.printil("Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);"); out.printil("if (exception != null) {"); out.pushIndent(); out.printil("response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);"); out.popIndent(); out.printil("}"); } out.printil("ServletContext application = null;"); out.printil("ServletConfig config = null;"); out.printil("JspWriter out = null;"); out.printil("Object page = this;"); out.printil("JspWriter _jspx_out = null;"); out.printil("PageContext _jspx_page_context = null;"); out.println(); declareTemporaryScriptingVars(page); out.println(); out.printil("try {"); out.pushIndent(); out.printil("_jspxFactory = JspFactory.getDefaultFactory();"); out.printin("response.setContentType("); out.print(quote(pageInfo.getContentType())); out.println(");"); if (ctxt.getOptions().isXpoweredBy()) { out.printil("response.addHeader(\"X-Powered-By\", \"JSP/2.1\");"); } out.printil("pageContext = _jspxFactory.getPageContext(this, request, response,"); out.printin("\t\t\t"); out.print(quote(pageInfo.getErrorPage())); out.print(", " + pageInfo.isSession()); out.print(", " + pageInfo.getBuffer()); out.print(", " + pageInfo.isAutoFlush()); out.println(");"); out.printil("_jspx_page_context = pageContext;"); out.printil("application = pageContext.getServletContext();"); out.printil("config = pageContext.getServletConfig();"); if (pageInfo.isSession()) out.printil("session = pageContext.getSession();"); out.printil("out = pageContext.getOut();"); out.printil("_jspx_out = out;"); out.println(); }
private boolean matchFiltersServlet(FilterMap filterMap, String servletName) { if (servletName == null) { return (false); } else { String[] servletNames = filterMap.getServletNames(); for (int i = 0; i < servletNames.length; i++) { if (servletName.equals(servletNames[i])) { return (true); } } return false; } }	private boolean matchFiltersURL(FilterMap filterMap, String requestPath) { if (filterMap.getAllMatch()) return (true); if (requestPath == null) return (false); String[] testPaths = filterMap.getURLPatterns(); for (int i = 0; i < testPaths.length; i++) { if (matchFiltersURL(testPaths[i], requestPath)) { return (true); } } return (false); }	public String[] getURLPatterns() { return (this.urlPatterns); }	public void addServletName(String servletName) { String[] results = new String[servletNames.length + 1]; System.arraycopy(servletNames, 0, results, 0, servletNames.length); results[servletNames.length] = servletName; servletNames = results; }	public void addURLPattern(String urlPattern) { if ("*".equals(urlPattern)) { this.allMatch = true; } else { String[] results = new String[urlPatterns.length + 1]; System.arraycopy(urlPatterns, 0, results, 0, urlPatterns.length); results[urlPatterns.length] = RequestUtil.URLDecode(urlPattern); urlPatterns = results; } }
public int write(ByteBuffer buf, NioChannel socket, Selector selector, long writeTimeout) throws IOException { SelectionKey key = null; int written = 0; boolean timedout = false; int keycount = 1; long time = System.currentTimeMillis(); try { while ((!timedout) && buf.hasRemaining()) { if (keycount > 0) { //only write if we were registered for a write int cnt = socket.write(buf); if (cnt == -1) throw new EOFException(); written += cnt; if (cnt > 0) { time = System.currentTimeMillis(); continue; } } if (selector != null) { if (key == null) key = socket.getIOChannel().register(selector, SelectionKey.OP_WRITE); else key.interestOps(SelectionKey.OP_WRITE); keycount = selector.select(writeTimeout); } if (writeTimeout > 0 && (selector == null || keycount == 0)) timedout = (System.currentTimeMillis() - time) >= writeTimeout; } if (timedout) throw new SocketTimeoutException(); } finally { if (key != null) { key.cancel(); if (selector != null) selector.selectNow(); } } return written; }
public void setContentLength(int length) { }	public void writeToGZip(byte[] b, int off, int len) throws IOException { if (debug > 1) { System.out.println("writeToGZip, len = " + len); } if (debug > 2) { System.out.print("writeToGZip("); System.out.write(b, off, len); System.out.println(")"); } if (gzipstream == null) { if (debug > 1) { System.out.println("new GZIPOutputStream"); } response.addHeader("Content-Encoding", "gzip"); gzipstream = new GZIPOutputStream(output); } gzipstream.write(b, off, len); }
public boolean getDisplaySourceFragment() { return displaySourceFragment; }
protected void register(String ssoId, Principal principal, String authType, String username, String password) { if (containerLog.isDebugEnabled()) containerLog.debug("Registering sso id '" + ssoId + "' for user '" + (principal != null ? principal.getName() : "") + "' with auth type '" + authType + "'"); synchronized (cache) { cache.put(ssoId, new SingleSignOnEntry(principal, authType, username, password)); } }	public String getUsername() { return (this.username); }	public boolean authenticate(Request request, Response response, LoginConfig config) throws IOException { Principal principal = request.getUserPrincipal(); if (principal != null) { if (containerLog.isDebugEnabled()) containerLog.debug("Already authenticated '" + principal.getName() + "'"); // Associate the session with any existing SSO session in order String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (ssoId != null) associate(ssoId, request.getSessionInternal(true)); return (true); } if (containerLog.isDebugEnabled()) containerLog.debug(" Looking up certificates"); X509Certificate[] certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR); if ((certs == null) || (certs.length < 1)) { request.getCoyoteRequest().action(ActionCode.ACTION_REQ_SSL_CERTIFICATE, null); certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR); } if ((certs == null) || (certs.length < 1)) { if (containerLog.isDebugEnabled()) containerLog.debug(" No certificates included with this request"); response.sendError(HttpServletResponse.SC_BAD_REQUEST, sm.getString("authenticator.certificates")); return (false); } principal = context.getRealm().authenticate(certs); if (principal == null) { if (containerLog.isDebugEnabled()) containerLog.debug(" Realm.authenticate() returned false"); response.sendError(HttpServletResponse.SC_UNAUTHORIZED, sm.getString("authenticator.unauthorized")); return (false); } register(request, response, principal, Constants.CERT_METHOD, null, null); return (true); }	public synchronized Session[] findSessions() { return (this.sessions); }
protected void register(Request request, Response response, Principal principal, String authType, String username, String password) { if (log.isDebugEnabled()) log.debug("Authenticated '" + principal.getName() + "' with type '" + authType + "'"); request.setAuthType(authType); request.setUserPrincipal(principal); Session session = request.getSessionInternal(false); if (cache) { if (session != null) { session.setAuthType(authType); session.setPrincipal(principal); if (username != null) session.setNote(Constants.SESS_USERNAME_NOTE, username); else session.removeNote(Constants.SESS_USERNAME_NOTE); if (password != null) session.setNote(Constants.SESS_PASSWORD_NOTE, password); else session.removeNote(Constants.SESS_PASSWORD_NOTE); } } if (sso == null) return; // Only create a new SSO entry if the SSO did not already set a note // for an existing entry (as it would do with subsequent requests String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE); if (ssoId == null) { ssoId = generateSessionId(); Cookie cookie = new Cookie(Constants.SINGLE_SIGN_ON_COOKIE, ssoId); cookie.setMaxAge(-1); cookie.setPath("/"); String ssoDomain = sso.getCookieDomain(); if (ssoDomain != null) { cookie.setDomain(ssoDomain); } response.addCookie(cookie); sso.register(ssoId, principal, authType, username, password); request.setNote(Constants.REQ_SSOID_NOTE, ssoId); } else { sso.update(ssoId, principal, authType, username, password); } if (session == null) session = request.getSessionInternal(true); sso.associate(ssoId, session); }
private void serviceJspFile(HttpServletRequest request, HttpServletResponse response, String jspUri, Throwable exception, boolean precompile) throws ServletException, IOException { JspServletWrapper wrapper = (JspServletWrapper) rctxt.getWrapper(jspUri); if (wrapper == null) { synchronized (this) { wrapper = (JspServletWrapper) rctxt.getWrapper(jspUri); if (wrapper == null) { if (null == context.getResource(jspUri)) { response.sendError(HttpServletResponse.SC_NOT_FOUND, jspUri); return; } boolean isErrorPage = exception != null; wrapper = new JspServletWrapper(config, options, jspUri, isErrorPage, rctxt); rctxt.addWrapper(jspUri, wrapper); } } } wrapper.service(request, response, precompile); }
public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.INIT_EVENT.equals(event.getType())) { try { this.getClass().getClassLoader().loadClass("org.apache.jasper.compiler.JspRuntimeContext"); } catch (Throwable t) { log.warn("Couldn't initialize Jasper", t); } // Another possibility is to do directly: // JspFactory.setDefaultFactory(new JspFactoryImpl()); } }

private void configure() { Timestamp ts = new Timestamp(System.currentTimeMillis()); String tsString = ts.toString().substring(0, 19); date = tsString.substring(0, 10); LogManager manager = LogManager.getLogManager(); String className = FileHandler.class.getName(); ClassLoader cl = Thread.currentThread().getContextClassLoader(); directory = getProperty(className + ".directory", "logs"); prefix = getProperty(className + ".prefix", "juli."); suffix = getProperty(className + ".suffix", ".log"); setLevel(Level.parse(getProperty(className + ".level", "" + Level.ALL))); String filterName = getProperty(className + ".filter", null); if (filterName != null) { try { setFilter((Filter) cl.loadClass(filterName).newInstance()); } catch (Exception e) { // Ignore } } String formatterName = getProperty(className + ".formatter", null); if (formatterName != null) { try { setFormatter((Formatter) cl.loadClass(formatterName).newInstance()); } catch (Exception e) { // Ignore } } else { setFormatter(new SimpleFormatter()); } setErrorManager(new ErrorManager()); }
private void compareTagEncodings(String pageDirEnc, Node.TagDirective pageDir) throws JasperException { Node.Root root = pageDir.getRoot(); if ((root.isXmlSyntax() && root.isEncodingSpecifiedInProlog()) || root.isBomPresent()) { String pageEnc = root.getPageEncoding(); if (!pageDirEnc.equals(pageEnc) && (!pageDirEnc.startsWith("UTF-16") || !pageEnc.startsWith("UTF-16"))) { err.jspError(pageDir, "jsp.error.prolog_pagedir_encoding_mismatch", pageEnc, pageDirEnc); } } }
public static String toString(ByteChunk bc) { if (bcCache == null) { String value = bc.toStringInternal(); if (byteEnabled) { synchronized (bcStats) { if (bcCache != null) { return value; } if (bcCount > trainThreshold) { long t1 = System.currentTimeMillis(); TreeMap tempMap = new TreeMap(); Iterator entries = bcStats.keySet().iterator(); while (entries.hasNext()) { ByteEntry entry = (ByteEntry) entries.next(); int[] countA = (int[]) bcStats.get(entry); Integer count = new Integer(countA[0]); ArrayList list = (ArrayList) tempMap.get(count); if (list == null) { list = new ArrayList(); tempMap.put(count, list); } list.add(entry); } int size = bcStats.size(); if (size > cacheSize) { size = cacheSize; } ByteEntry[] tempbcCache = new ByteEntry[size]; // Fill it up using an alphabetical order ByteChunk tempChunk = new ByteChunk(); int n = 0; while (n < size) { Object key = tempMap.lastKey(); ArrayList list = (ArrayList) tempMap.get(key); ByteEntry[] list2 = (ByteEntry[]) list.toArray(new ByteEntry[list.size()]); for (int i = 0; i < list.size() && n < size; i++) { ByteEntry entry = (ByteEntry) list.get(i); tempChunk.setBytes(entry.name, 0, entry.name.length); int insertPos = findClosest(tempChunk, tempbcCache, n); if (insertPos == n) { tempbcCache[n + 1] = entry; } else { System.arraycopy(tempbcCache, insertPos + 1, tempbcCache, insertPos + 2, n - insertPos - 1); tempbcCache[insertPos + 1] = entry; } n++; } tempMap.remove(key); } bcCount = 0; bcStats.clear(); bcCache = tempbcCache; if (log.isDebugEnabled()) { long t2 = System.currentTimeMillis(); log.debug("ByteCache generation time: " + (t2 - t1) + "ms"); } } else { bcCount++; ByteEntry entry = new ByteEntry(); entry.value = value; int[] count = (int[]) bcStats.get(entry); if (count == null) { int end = bc.getEnd(); int start = bc.getStart(); entry.name = new byte[bc.getLength()]; System.arraycopy(bc.getBuffer(), start, entry.name, 0, end - start); entry.enc = bc.getEncoding(); count = new int[1]; count[0] = 1; bcStats.put(entry, count); } else { count[0] = count[0] + 1; } } } } return value; } else { accessCount++; String result = find(bc); if (result == null) { return bc.toStringInternal(); } hitCount++; return result; } }	public static String toString(CharChunk cc) { if (ccCache == null) { String value = cc.toStringInternal(); if (charEnabled) { synchronized (ccStats) { if (ccCache != null) { return value; } if (ccCount > trainThreshold) { long t1 = System.currentTimeMillis(); TreeMap tempMap = new TreeMap(); Iterator entries = ccStats.keySet().iterator(); while (entries.hasNext()) { CharEntry entry = (CharEntry) entries.next(); int[] countA = (int[]) ccStats.get(entry); Integer count = new Integer(countA[0]); ArrayList list = (ArrayList) tempMap.get(count); if (list == null) { list = new ArrayList(); tempMap.put(count, list); } list.add(entry); } int size = ccStats.size(); if (size > cacheSize) { size = cacheSize; } CharEntry[] tempccCache = new CharEntry[size]; // Fill it up using an alphabetical order CharChunk tempChunk = new CharChunk(); int n = 0; while (n < size) { Object key = tempMap.lastKey(); ArrayList list = (ArrayList) tempMap.get(key); CharEntry[] list2 = (CharEntry[]) list.toArray(new CharEntry[list.size()]); for (int i = 0; i < list.size() && n < size; i++) { CharEntry entry = (CharEntry) list.get(i); tempChunk.setChars(entry.name, 0, entry.name.length); int insertPos = findClosest(tempChunk, tempccCache, n); if (insertPos == n) { tempccCache[n + 1] = entry; } else { System.arraycopy(tempccCache, insertPos + 1, tempccCache, insertPos + 2, n - insertPos - 1); tempccCache[insertPos + 1] = entry; } n++; } tempMap.remove(key); } ccCount = 0; ccStats.clear(); ccCache = tempccCache; if (log.isDebugEnabled()) { long t2 = System.currentTimeMillis(); log.debug("CharCache generation time: " + (t2 - t1) + "ms"); } } else { ccCount++; CharEntry entry = new CharEntry(); entry.value = value; int[] count = (int[]) ccStats.get(entry); if (count == null) { int end = cc.getEnd(); int start = cc.getStart(); entry.name = new char[cc.getLength()]; System.arraycopy(cc.getBuffer(), start, entry.name, 0, end - start); count = new int[1]; count[0] = 1; ccStats.put(entry, count); } else { count[0] = count[0] + 1; } } } } return value; } else { accessCount++; String result = find(cc); if (result == null) { return cc.toStringInternal(); } hitCount++; return result; } }
protected String[] findCGI(String pathInfo, String webAppRootDir, String contextPath, String servletPath, String cgiPathPrefix) { String path = null; String name = null; String scriptname = null; String cginame = null; if ((webAppRootDir != null) && (webAppRootDir.lastIndexOf(File.separator) == (webAppRootDir.length() - 1))) { webAppRootDir = webAppRootDir.substring(0, (webAppRootDir.length() - 1)); } if (cgiPathPrefix != null) { webAppRootDir = webAppRootDir + File.separator + cgiPathPrefix; } if (debug >= 2) { log("findCGI: path=" + pathInfo + ", " + webAppRootDir); } File currentLocation = new File(webAppRootDir); StringTokenizer dirWalker = new StringTokenizer(pathInfo, "/"); if (debug >= 3) { log("findCGI: currentLoc=" + currentLocation); } while (!currentLocation.isFile() && dirWalker.hasMoreElements()) { if (debug >= 3) { log("findCGI: currentLoc=" + currentLocation); } currentLocation = new File(currentLocation, (String) dirWalker.nextElement()); } if (!currentLocation.isFile()) { return new String[] { null, null, null, null }; } else { if (debug >= 2) { log("findCGI: FOUND cgi at " + currentLocation); } path = currentLocation.getAbsolutePath(); name = currentLocation.getName(); cginame = (currentLocation.getParent() + File.separator).substring(webAppRootDir.length()) + name; if (".".equals(contextPath)) { scriptname = servletPath + cginame; } else { scriptname = contextPath + servletPath + cginame; } } if (debug >= 1) { log("findCGI calc: name=" + name + ", path=" + path + ", scriptname=" + scriptname + ", cginame=" + cginame); } return new String[] { path, scriptname, cginame, name }; }
protected InputStream renderHtml(String contextPath, CacheEntry cacheEntry) throws IOException, ServletException { String name = cacheEntry.name; int trim = name.length(); if (!name.endsWith("/")) trim += 1; if (name.equals("/")) trim = 1; ByteArrayOutputStream stream = new ByteArrayOutputStream(); OutputStreamWriter osWriter = new OutputStreamWriter(stream, "UTF8"); PrintWriter writer = new PrintWriter(osWriter); StringBuffer sb = new StringBuffer(); String rewrittenContextPath = rewriteUrl(contextPath); sb.append("<html>\r\n"); sb.append("<head>\r\n"); sb.append("<title>"); sb.append(sm.getString("directory.title", name)); sb.append("</title>\r\n"); sb.append("<STYLE><!--"); sb.append(org.apache.catalina.util.TomcatCSS.TOMCAT_CSS); sb.append("--></STYLE> "); sb.append("</head>\r\n"); sb.append("<body>"); sb.append("<h1>"); sb.append(sm.getString("directory.title", name)); String parentDirectory = name; if (parentDirectory.endsWith("/")) { parentDirectory = parentDirectory.substring(0, parentDirectory.length() - 1); } int slash = parentDirectory.lastIndexOf('/'); if (slash >= 0) { String parent = name.substring(0, slash); sb.append(" - <a href=\""); sb.append(rewrittenContextPath); if (parent.equals("")) parent = "/"; sb.append(rewriteUrl(parent)); if (!parent.endsWith("/")) sb.append("/"); sb.append("\">"); sb.append("<b>"); sb.append(sm.getString("directory.parent", parent)); sb.append("</b>"); sb.append("</a>"); } sb.append("</h1>"); sb.append("<HR size=\"1\" noshade=\"noshade\">"); sb.append("<table width=\"100%\" cellspacing=\"0\"" + " cellpadding=\"5\" align=\"center\">\r\n"); sb.append("<tr>\r\n"); sb.append("<td align=\"left\"><font size=\"+1\"><strong>"); sb.append(sm.getString("directory.filename")); sb.append("</strong></font></td>\r\n"); sb.append("<td align=\"center\"><font size=\"+1\"><strong>"); sb.append(sm.getString("directory.size")); sb.append("</strong></font></td>\r\n"); sb.append("<td align=\"right\"><font size=\"+1\"><strong>"); sb.append(sm.getString("directory.lastModified")); sb.append("</strong></font></td>\r\n"); sb.append("</tr>"); try { NamingEnumeration enumeration = resources.list(cacheEntry.name); boolean shade = false; while (enumeration.hasMoreElements()) { NameClassPair ncPair = (NameClassPair) enumeration.nextElement(); String resourceName = ncPair.getName(); String trimmed = resourceName; if (trimmed.equalsIgnoreCase("WEB-INF") || trimmed.equalsIgnoreCase("META-INF")) continue; CacheEntry childCacheEntry = resources.lookupCache(cacheEntry.name + resourceName); if (!childCacheEntry.exists) { continue; } sb.append("<tr"); if (shade) sb.append(" bgcolor=\"#eeeeee\""); sb.append(">\r\n"); shade = !shade; sb.append("<td align=\"left\">&nbsp;&nbsp;\r\n"); sb.append("<a href=\""); sb.append(rewrittenContextPath); resourceName = rewriteUrl(name + resourceName); sb.append(resourceName); if (childCacheEntry.context != null) sb.append("/"); sb.append("\"><tt>"); sb.append(trimmed); if (childCacheEntry.context != null) sb.append("/"); sb.append("</tt></a></td>\r\n"); sb.append("<td align=\"right\"><tt>"); if (childCacheEntry.context != null) sb.append("&nbsp;"); else sb.append(renderSize(childCacheEntry.attributes.getContentLength())); sb.append("</tt></td>\r\n"); sb.append("<td align=\"right\"><tt>"); sb.append(childCacheEntry.attributes.getLastModifiedHttp()); sb.append("</tt></td>\r\n"); sb.append("</tr>\r\n"); } } catch (NamingException e) { throw new ServletException("Error accessing resource", e); } sb.append("</table>\r\n"); sb.append("<HR size=\"1\" noshade=\"noshade\">"); String readme = getReadme(cacheEntry.context); if (readme != null) { sb.append(readme); sb.append("<HR size=\"1\" noshade=\"noshade\">"); } sb.append("<h3>").append(ServerInfo.getServerInfo()).append("</h3>"); sb.append("</body>\r\n"); sb.append("</html>\r\n"); writer.write(sb.toString()); writer.flush(); return (new ByteArrayInputStream(stream.toByteArray())); }	protected InputStream renderXml(String contextPath, CacheEntry cacheEntry, InputStream xsltInputStream) throws IOException, ServletException { StringBuffer sb = new StringBuffer(); sb.append("<?xml version=\"1.0\"?>"); sb.append("<listing "); sb.append(" contextPath='"); sb.append(contextPath); sb.append("'"); sb.append(" directory='"); sb.append(cacheEntry.name); sb.append("' "); sb.append(" hasParent='").append(!cacheEntry.name.equals("/")); sb.append("'>"); sb.append("<entries>"); try { NamingEnumeration enumeration = resources.list(cacheEntry.name); String rewrittenContextPath = rewriteUrl(contextPath); while (enumeration.hasMoreElements()) { NameClassPair ncPair = (NameClassPair) enumeration.nextElement(); String resourceName = ncPair.getName(); String trimmed = resourceName; if (trimmed.equalsIgnoreCase("WEB-INF") || trimmed.equalsIgnoreCase("META-INF") || trimmed.equalsIgnoreCase(localXsltFile)) continue; CacheEntry childCacheEntry = resources.lookupCache(cacheEntry.name + resourceName); if (!childCacheEntry.exists) { continue; } sb.append("<entry"); sb.append(" type='").append((childCacheEntry.context != null) ? "dir" : "file").append("'"); sb.append(" urlPath='").append(rewrittenContextPath).append(rewriteUrl(cacheEntry.name + resourceName)).append((childCacheEntry.context != null) ? "/" : "").append("'"); if (childCacheEntry.resource != null) { sb.append(" size='").append(renderSize(childCacheEntry.attributes.getContentLength())).append("'"); } sb.append(" date='").append(childCacheEntry.attributes.getLastModifiedHttp()).append("'"); sb.append(">"); sb.append(trimmed); if (childCacheEntry.context != null) sb.append("/"); sb.append("</entry>"); } } catch (NamingException e) { throw new ServletException("Error accessing resource", e); } sb.append("</entries>"); String readme = getReadme(cacheEntry.context); if (readme != null) { sb.append("<readme><![CDATA["); sb.append(readme); sb.append("]]></readme>"); } sb.append("</listing>"); try { TransformerFactory tFactory = TransformerFactory.newInstance(); Source xmlSource = new StreamSource(new StringReader(sb.toString())); Source xslSource = new StreamSource(xsltInputStream); Transformer transformer = tFactory.newTransformer(xslSource); ByteArrayOutputStream stream = new ByteArrayOutputStream(); OutputStreamWriter osWriter = new OutputStreamWriter(stream, "UTF8"); StreamResult out = new StreamResult(osWriter); transformer.transform(xmlSource, out); osWriter.flush(); return (new ByteArrayInputStream(stream.toByteArray())); } catch (TransformerException e) { throw new ServletException("XSL transformer error", e); } }

protected void parseParameters() { parametersParsed = true; Parameters parameters = coyoteRequest.getParameters(); // getCharacterEncoding() may have been overridden to search for String enc = getCharacterEncoding(); boolean useBodyEncodingForURI = connector.getUseBodyEncodingForURI(); if (enc != null) { parameters.setEncoding(enc); if (useBodyEncodingForURI) { parameters.setQueryStringEncoding(enc); } } else { parameters.setEncoding(org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING); if (useBodyEncodingForURI) { parameters.setQueryStringEncoding(org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING); } } parameters.handleQueryParameters(); if (usingInputStream || usingReader) return; if (!getMethod().equalsIgnoreCase("POST")) return; String contentType = getContentType(); if (contentType == null) contentType = ""; int semicolon = contentType.indexOf(';'); if (semicolon >= 0) { contentType = contentType.substring(0, semicolon).trim(); } else { contentType = contentType.trim(); } if (!("application/x-www-form-urlencoded".equals(contentType))) return; int len = getContentLength(); if (len > 0) { int maxPostSize = connector.getMaxPostSize(); if ((maxPostSize > 0) && (len > maxPostSize)) { context.getLogger().info(sm.getString("coyoteRequest.postTooLarge")); throw new IllegalStateException("Post too large"); } try { byte[] formData = null; if (len < CACHED_POST_LEN) { if (postData == null) postData = new byte[CACHED_POST_LEN]; formData = postData; } else { formData = new byte[len]; } int actualLen = readPostBody(formData, len); if (actualLen == len) { parameters.processParameters(formData, 0, len); } } catch (Throwable t) { ; } } }	public void processParameters(byte[] bytes, int start, int len, String enc) { int end = start + len; int pos = start; if (debug > 0) log("Bytes: " + new String(bytes, start, len)); do { boolean noEq = false; int valStart = -1; int valEnd = -1; int nameStart = pos; int nameEnd = ByteChunk.indexOf(bytes, nameStart, end, '='); int nameEnd2 = ByteChunk.indexOf(bytes, nameStart, end, '&'); if ((nameEnd2 != -1) && (nameEnd == -1 || nameEnd > nameEnd2)) { nameEnd = nameEnd2; noEq = true; valStart = nameEnd; valEnd = nameEnd; if (debug > 0) log("no equal " + nameStart + " " + nameEnd + " " + new String(bytes, nameStart, nameEnd - nameStart)); } if (nameEnd == -1) nameEnd = end; if (!noEq) { valStart = (nameEnd < end) ? nameEnd + 1 : end; valEnd = ByteChunk.indexOf(bytes, valStart, end, '&'); if (valEnd == -1) valEnd = (valStart < end) ? end : valStart; } pos = valEnd + 1; if (nameEnd <= nameStart) { continue; // invalid chunk - it's better to ignore // XXX log it ? } tmpName.setBytes(bytes, nameStart, nameEnd - nameStart); tmpValue.setBytes(bytes, valStart, valEnd - valStart); try { addParam(urlDecode(tmpName, enc), urlDecode(tmpValue, enc)); } catch (IOException e) { // Exception during character decoding: skip parameter } tmpName.recycle(); tmpValue.recycle(); } while (pos < end); }
String replace(String str) { String result = str.trim(); if (result.startsWith("${")) { int pos = result.indexOf('}'); if (pos != -1) { String propName = result.substring(2, pos); String replacement = System.getProperty(propName); if (replacement != null) { result = replacement + result.substring(pos + 1); } } } return result; }
protected String getName() { return (name); }	protected void release(Connection dbConnection) { ; }
private void checkXmlAttributes(Node.CustomTag n, Node.JspAttribute[] jspAttrs, Hashtable<String, Object> tagDataAttrs) throws JasperException { TagInfo tagInfo = n.getTagInfo(); if (tagInfo == null) { err.jspError(n, "jsp.error.missing.tagInfo", n.getQName()); } TagAttributeInfo[] tldAttrs = tagInfo.getAttributes(); Attributes attrs = n.getAttributes(); for (int i = 0; attrs != null && i < attrs.getLength(); i++) { boolean found = false; for (int j = 0; tldAttrs != null && j < tldAttrs.length; j++) { if (attrs.getLocalName(i).equals(tldAttrs[j].getName()) && (attrs.getURI(i) == null || attrs.getURI(i).length() == 0 || attrs.getURI(i).equals(n.getURI()))) { boolean checkDeferred = !tagInfo.getTagLibrary().getRequiredVersion().equals("2.0"); boolean deferred = false; boolean deferredValueIsLiteral = false; boolean expression = isExpression(n, attrs.getValue(i), checkDeferred); if (checkDeferred && attrs.getValue(i).indexOf("#{") != -1) { deferred = true; if (pageInfo.isELIgnored()) { deferredValueIsLiteral = true; } } if (tldAttrs[j].canBeRequestTime() || tldAttrs[j].isDeferredMethod() || tldAttrs[j].isDeferredValue()) { if (!expression) { if (deferredValueIsLiteral && !pageInfo.isDeferredSyntaxAllowedAsLiteral()) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } String expectedType = null; if (tldAttrs[j].isDeferredMethod()) { // The String litteral must be castable to what is declared as type String m = tldAttrs[j].getMethodSignature(); if (m != null) { int rti = m.trim().indexOf(' '); if (rti > 0) { expectedType = m.substring(0, rti).trim(); } } else { expectedType = "java.lang.Object"; } } if (tldAttrs[j].isDeferredValue()) { // The String litteral must be castable to what is declared as type expectedType = tldAttrs[j].getExpectedTypeName(); } if (expectedType != null) { Class expectedClass = String.class; try { expectedClass = JspUtil.toClass(expectedType, loader); } catch (ClassNotFoundException e) { err.jspError(n, "jsp.error.unknown_attribute_type", tldAttrs[j].getName(), expectedType); } try { ELSupport.coerceToType(attrs.getValue(i), expectedClass); } catch (Exception e) { err.jspError(n, "jsp.error.coerce_to_type", tldAttrs[j].getName(), expectedType, attrs.getValue(i)); } } jspAttrs[i] = new Node.JspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), false, null, false); } else { if (deferred && !tldAttrs[j].isDeferredMethod() && !tldAttrs[j].isDeferredValue()) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } if (!deferred && (tldAttrs[j].isDeferredMethod() || tldAttrs[j].isDeferredValue())) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } Class expectedType = String.class; try { String typeStr = tldAttrs[j].getTypeName(); if (tldAttrs[j].isFragment()) { expectedType = JspFragment.class; } else if (typeStr != null) { expectedType = JspUtil.toClass(typeStr, loader); } jspAttrs[i] = getJspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), expectedType, n, false); } catch (ClassNotFoundException e) { err.jspError(n, "jsp.error.unknown_attribute_type", tldAttrs[j].getName(), tldAttrs[j].getTypeName()); } } } else { if (expression) { err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } jspAttrs[i] = new Node.JspAttribute(tldAttrs[j], attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), false, null, false); } if (jspAttrs[i].isExpression()) { tagDataAttrs.put(attrs.getQName(i), TagData.REQUEST_TIME_VALUE); } else { tagDataAttrs.put(attrs.getQName(i), attrs.getValue(i)); } found = true; break; } } if (!found) { if (tagInfo.hasDynamicAttributes()) { jspAttrs[i] = getJspAttribute(null, attrs.getQName(i), attrs.getURI(i), attrs.getLocalName(i), attrs.getValue(i), java.lang.Object.class, n, true); } else { err.jspError(n, "jsp.error.bad_attribute", attrs.getQName(i), n.getLocalName()); } } } }
private ServletResponse wrapResponse() { ServletResponse previous = null; ServletResponse current = outerResponse; while (current != null) { if (!(current instanceof ServletResponseWrapper)) break; if (current instanceof ApplicationHttpResponse) break; if (current instanceof ApplicationResponse) break; if (current instanceof Response) break; previous = current; current = ((ServletResponseWrapper) current).getResponse(); } ServletResponse wrapper = null; if ((current instanceof ApplicationHttpResponse) || (current instanceof Response) || (current instanceof HttpServletResponse)) wrapper = new ApplicationHttpResponse((HttpServletResponse) current, including); else wrapper = new ApplicationResponse(current, including); if (previous == null) outerResponse = wrapper; else ((ServletResponseWrapper) previous).setResponse(wrapper); wrapResponse = wrapper; return (wrapper); }	private void doForward(ServletRequest request, ServletResponse response) throws ServletException, IOException { if (response.isCommitted()) { if (log.isDebugEnabled()) log.debug(" Forward on committed response --> ISE"); throw new IllegalStateException(sm.getString("applicationDispatcher.forward.ise")); } try { response.resetBuffer(); } catch (IllegalStateException e) { if (log.isDebugEnabled()) log.debug(" Forward resetBuffer() returned ISE: " + e); throw e; } setup(request, response, false); HttpServletRequest hrequest = null; if (request instanceof HttpServletRequest) hrequest = (HttpServletRequest) request; HttpServletResponse hresponse = null; if (response instanceof HttpServletResponse) hresponse = (HttpServletResponse) response; if ((hrequest == null) || (hresponse == null)) { if (log.isDebugEnabled()) log.debug(" Non-HTTP Forward"); processRequest(hrequest, hresponse); } }	private void doInclude(ServletRequest request, ServletResponse response) throws ServletException, IOException { setup(request, response, true); // Create a wrapped response to use for this request ServletResponse wresponse = wrapResponse(); if (!(request instanceof HttpServletRequest) || !(response instanceof HttpServletResponse)) { if (log.isDebugEnabled()) log.debug(" Non-HTTP Include"); request.setAttribute(ApplicationFilterFactory.DISPATCHER_TYPE_ATTR, Integer.valueOf(ApplicationFilterFactory.INCLUDE)); request.setAttribute(ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, origServletPath); invoke(request, outerResponse); } }	void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { if (pos < n) { ApplicationFilterConfig filterConfig = filters[pos++]; Filter filter = null; try { filter = filterConfig.getFilter(); support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT, filter, request, response); if (System.getSecurityManager() != null) { final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[] { req, res, this }; SecurityUtil.doAsPrivilege("doFilter", filter, classType, args); args = null; } else { filter.doFilter(request, response, this); } support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response); } catch (IOException e) { if (filter != null) support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response, e); throw e; } catch (ServletException e) { if (filter != null) support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response, e); throw e; } catch (RuntimeException e) { if (filter != null) support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response, e); throw e; } catch (Throwable e) { if (filter != null) support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT, filter, request, response, e); throw new ServletException(sm.getString("filterChain.filter"), e); } return; } try { support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT, servlet, request, response); if ((request instanceof HttpServletRequest) && (response instanceof HttpServletResponse)) { if (System.getSecurityManager() != null) { final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[] { req, res }; SecurityUtil.doAsPrivilege("service", servlet, classTypeUsedInService, args, principal); args = null; } else { servlet.service((HttpServletRequest) request, (HttpServletResponse) response); } } else { servlet.service(request, response); } support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response); } catch (IOException e) { support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response, e); throw e; } catch (ServletException e) { support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response, e); throw e; } catch (RuntimeException e) { support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response, e); throw e; } catch (Throwable e) { support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT, servlet, request, response, e); throw new ServletException(sm.getString("filterChain.servlet"), e); } }
protected boolean setCGIEnvironment(HttpServletRequest req) throws IOException { Hashtable envp = new Hashtable(); envp.putAll(shellEnv); String sPathInfoOrig = null; String sPathTranslatedOrig = null; String sPathInfoCGI = null; String sPathTranslatedCGI = null; String sCGIFullPath = null; String sCGIScriptName = null; String sCGIFullName = null; String sCGIName = null; String[] sCGINames; sPathInfoOrig = this.pathInfo; sPathInfoOrig = sPathInfoOrig == null ? "" : sPathInfoOrig; sPathTranslatedOrig = req.getPathTranslated(); sPathTranslatedOrig = sPathTranslatedOrig == null ? "" : sPathTranslatedOrig; if (webAppRootDir == null) { webAppRootDir = tmpDir.toString(); expandCGIScript(); } sCGINames = findCGI(sPathInfoOrig, webAppRootDir, contextPath, servletPath, cgiPathPrefix); sCGIFullPath = sCGINames[0]; sCGIScriptName = sCGINames[1]; sCGIFullName = sCGINames[2]; sCGIName = sCGINames[3]; if (sCGIFullPath == null || sCGIScriptName == null || sCGIFullName == null || sCGIName == null) { return false; } envp.put("SERVER_SOFTWARE", "TOMCAT"); envp.put("SERVER_NAME", nullsToBlanks(req.getServerName())); envp.put("GATEWAY_INTERFACE", "CGI/1.1"); envp.put("SERVER_PROTOCOL", nullsToBlanks(req.getProtocol())); int port = req.getServerPort(); Integer iPort = (port == 0 ? new Integer(-1) : new Integer(port)); envp.put("SERVER_PORT", iPort.toString()); envp.put("REQUEST_METHOD", nullsToBlanks(req.getMethod())); envp.put("REQUEST_URI", nullsToBlanks(req.getRequestURI())); if (pathInfo == null || (pathInfo.substring(sCGIFullName.length()).length() <= 0)) { sPathInfoCGI = ""; } else { sPathInfoCGI = pathInfo.substring(sCGIFullName.length()); } envp.put("PATH_INFO", sPathInfoCGI); if (sPathInfoCGI != null && !("".equals(sPathInfoCGI))) { sPathTranslatedCGI = context.getRealPath(sPathInfoCGI); } else { sPathTranslatedCGI = null; } if (sPathTranslatedCGI == null || "".equals(sPathTranslatedCGI)) { //NOOP } else { envp.put("PATH_TRANSLATED", nullsToBlanks(sPathTranslatedCGI)); } envp.put("SCRIPT_NAME", nullsToBlanks(sCGIScriptName)); envp.put("QUERY_STRING", nullsToBlanks(req.getQueryString())); envp.put("REMOTE_HOST", nullsToBlanks(req.getRemoteHost())); envp.put("REMOTE_ADDR", nullsToBlanks(req.getRemoteAddr())); envp.put("AUTH_TYPE", nullsToBlanks(req.getAuthType())); envp.put("REMOTE_USER", nullsToBlanks(req.getRemoteUser())); envp.put("REMOTE_IDENT", ""); envp.put("CONTENT_TYPE", nullsToBlanks(req.getContentType())); int contentLength = req.getContentLength(); String sContentLength = (contentLength <= 0 ? "" : (new Integer(contentLength)).toString()); envp.put("CONTENT_LENGTH", sContentLength); Enumeration headers = req.getHeaderNames(); String header = null; while (headers.hasMoreElements()) { header = null; header = ((String) headers.nextElement()).toUpperCase(); if ("AUTHORIZATION".equalsIgnoreCase(header) || "PROXY_AUTHORIZATION".equalsIgnoreCase(header)) { //NOOP per CGI specification section 11.2 } else { envp.put("HTTP_" + header.replace('-', '_'), req.getHeader(header)); } } File fCGIFullPath = new File(sCGIFullPath); command = fCGIFullPath.getCanonicalPath(); envp.put("X_TOMCAT_SCRIPT_PATH", command); this.env = envp; return true; }	protected String[] findCGI(String pathInfo, String webAppRootDir, String contextPath, String servletPath, String cgiPathPrefix) { String path = null; String name = null; String scriptname = null; String cginame = null; if ((webAppRootDir != null) && (webAppRootDir.lastIndexOf(File.separator) == (webAppRootDir.length() - 1))) { webAppRootDir = webAppRootDir.substring(0, (webAppRootDir.length() - 1)); } if (cgiPathPrefix != null) { webAppRootDir = webAppRootDir + File.separator + cgiPathPrefix; } if (debug >= 2) { log("findCGI: path=" + pathInfo + ", " + webAppRootDir); } File currentLocation = new File(webAppRootDir); StringTokenizer dirWalker = new StringTokenizer(pathInfo, "/"); if (debug >= 3) { log("findCGI: currentLoc=" + currentLocation); } while (!currentLocation.isFile() && dirWalker.hasMoreElements()) { if (debug >= 3) { log("findCGI: currentLoc=" + currentLocation); } currentLocation = new File(currentLocation, (String) dirWalker.nextElement()); } if (!currentLocation.isFile()) { return new String[] { null, null, null, null }; } else { if (debug >= 2) { log("findCGI: FOUND cgi at " + currentLocation); } path = currentLocation.getAbsolutePath(); name = currentLocation.getName(); cginame = currentLocation.getParent().substring(webAppRootDir.length()) + File.separator + name; if (".".equals(contextPath)) { scriptname = servletPath + cginame; } else { scriptname = contextPath + servletPath + cginame; } } if (debug >= 1) { log("findCGI calc: name=" + name + ", path=" + path + ", scriptname=" + scriptname + ", cginame=" + cginame); } return new String[] { path, scriptname, cginame, name }; }
protected Class findClassInternal(String name) throws ClassNotFoundException { if (!validate(name)) throw new ClassNotFoundException(name); String tempPath = name.replace('.', '/'); String classPath = tempPath + ".class"; ResourceEntry entry = null; entry = findResourceInternal(name, classPath); if (entry == null) throw new ClassNotFoundException(name); Class clazz = entry.loadedClass; if (clazz != null) return clazz; synchronized (this) { if (entry.binaryContent == null && entry.loadedClass == null) throw new ClassNotFoundException(name); } String packageName = null; int pos = name.lastIndexOf('.'); if (pos != -1) packageName = name.substring(0, pos); Package pkg = null; if (packageName != null) { pkg = getPackage(packageName); if (pkg == null) { if (entry.manifest == null) { definePackage(packageName, null, null, null, null, null, null, null); } else { definePackage(packageName, entry.manifest, entry.codeBase); } } } CodeSource codeSource = new CodeSource(entry.codeBase, entry.certificates); if (securityManager != null) { if (pkg != null) { boolean sealCheck = true; if (pkg.isSealed()) { sealCheck = pkg.isSealed(entry.codeBase); } else { sealCheck = (entry.manifest == null) || !isPackageSealed(packageName, entry.manifest); } if (!sealCheck) throw new SecurityException("Sealing violation loading " + name + " : Package " + packageName + " is sealed."); } } synchronized (this) { if (entry.loadedClass == null) { clazz = defineClass(name, entry.binaryContent, 0, entry.binaryContent.length, codeSource); entry.loadedClass = clazz; entry.binaryContent = null; entry.source = null; entry.codeBase = null; entry.manifest = null; entry.certificates = null; } else { clazz = entry.loadedClass; } } return clazz; }

public int doRead(ByteChunk chunk, org.apache.coyote.Request request) throws IOException { int writeLength = 0; if (chunk.getLimit() > 0 && chunk.getLimit() < input.getLength()) { writeLength = chunk.getLimit(); } else { writeLength = input.getLength(); } input.substract(chunk.getBuffer(), 0, writeLength); chunk.setOffset(0); chunk.setEnd(writeLength); return writeLength; }
public void removeValve(Valve valve) { Valve current; if (first == valve) { first = first.getNext(); current = null; } else { current = first; } while (current != null) { if (current.getNext() == valve) { current.setNext(valve.getNext()); break; } current = current.getNext(); } if (valve instanceof Contained) ((Contained) valve).setContainer(null); if (started) { if (valve instanceof Lifecycle) { try { ((Lifecycle) valve).stop(); } catch (LifecycleException e) { log.error("StandardPipeline.removeValve: stop: ", e); } } unregisterValve(valve); } }
public void addEnvironment(ContextEnvironment environment) { if (entries.containsKey(environment.getName())) { return; } else { entries.put(environment.getName(), environment.getType()); } synchronized (envs) { environment.setNamingResources(this); envs.put(environment.getName(), environment); } support.firePropertyChange("environment", null, environment); }
protected void run() throws IOException { if (!isReady()) { throw new IOException(this.getClass().getName() + ": not ready to run."); } if (debug >= 1) { log("runCGI(envp=[" + env + "], command=" + command + ")"); } if ((command.indexOf(File.separator + "." + File.separator) >= 0) || (command.indexOf(File.separator + "..") >= 0) || (command.indexOf(".." + File.separator) >= 0)) { throw new IOException(this.getClass().getName() + "Illegal Character in CGI command " + "path ('.' or '..') detected. Not " + "running CGI [" + command + "]."); } Runtime rt = null; InputStream cgiOutput = null; BufferedReader commandsStdErr = null; BufferedOutputStream commandsStdIn = null; Process proc = null; int bufRead = -1; StringBuffer cmdAndArgs = new StringBuffer(); if (command.indexOf(" ") < 0) { cmdAndArgs.append(command); } else { cmdAndArgs.append("\""); cmdAndArgs.append(command); cmdAndArgs.append("\""); } for (int i = 0; i < params.size(); i++) { cmdAndArgs.append(" "); String param = (String) params.get(i); if (param.indexOf(" ") < 0) { cmdAndArgs.append(param); } else { cmdAndArgs.append("\""); cmdAndArgs.append(param); cmdAndArgs.append("\""); } } StringBuffer command = new StringBuffer(cgiExecutable); command.append(" "); command.append(cmdAndArgs.toString()); cmdAndArgs = command; try { rt = Runtime.getRuntime(); proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd); String sContentLength = (String) env.get("CONTENT_LENGTH"); if (!"".equals(sContentLength)) { commandsStdIn = new BufferedOutputStream(proc.getOutputStream()); IOTools.flow(stdin, commandsStdIn); commandsStdIn.flush(); commandsStdIn.close(); } boolean isRunning = true; commandsStdErr = new BufferedReader(new InputStreamReader(proc.getErrorStream())); final BufferedReader stdErrRdr = commandsStdErr; new Thread() { public void run() { sendToLog(stdErrRdr); } ; }.start(); InputStream cgiHeaderStream = new HTTPHeaderInputStream(proc.getInputStream()); BufferedReader cgiHeaderReader = new BufferedReader(new InputStreamReader(cgiHeaderStream)); while (isRunning) { try { String line = null; while (((line = cgiHeaderReader.readLine()) != null) && !("".equals(line))) { if (debug >= 2) { log("runCGI: addHeader(\"" + line + "\")"); } if (line.startsWith("HTTP")) { response.setStatus(getSCFromHttpStatusLine(line)); } else if (line.indexOf(":") >= 0) { String header = line.substring(0, line.indexOf(":")).trim(); String value = line.substring(line.indexOf(":") + 1).trim(); if (header.equalsIgnoreCase("status")) { response.setStatus(getSCFromCGIStatusHeader(value)); } else { response.addHeader(header, value); } } else { log("runCGI: bad header line \"" + line + "\""); } } byte[] bBuf = new byte[2048]; OutputStream out = response.getOutputStream(); cgiOutput = proc.getInputStream(); try { while ((bufRead = cgiOutput.read(bBuf)) != -1) { if (debug >= 4) { log("runCGI: output " + bufRead + " bytes of data"); } out.write(bBuf, 0, bufRead); } } finally { if (bufRead != -1) { while ((bufRead = cgiOutput.read(bBuf)) != -1) { } } } proc.exitValue(); isRunning = false; } catch (IllegalThreadStateException e) { try { Thread.sleep(500); } catch (InterruptedException ignored) { } } } //replacement for Process.waitFor() cgiOutput.close(); } catch (IOException e) { log("Caught exception " + e); throw new IOException(e.toString()); } finally { if (debug > 4) { log("Running finally block"); } if (proc != null) { proc.destroy(); proc = null; } } }
public final void event(Request request, Response response, CometEvent event) throws IOException, ServletException { Wrapper wrapper = request.getWrapper(); // Normal request processing // FIXME: This could be an addition to the core API too wrapper.getPipeline().getFirst().event(request, response, event); /* if ((instances !=null ) && (instances.length > 0)) { // create post-service event for (int i = 0; i < instances.length; i++) { if (instances[i] == null) continue; if (!(instances[i] instanceof ServletRequestListener)) continue; ServletRequestListener listener = (ServletRequestListener) instances[i]; try { listener.requestDestroyed(event); } catch (Throwable t) { container.getLogger().error(sm.getString("requestListenerValve.requestDestroy", instances[i].getClass().getName()), t); ServletRequest sreq = request.getRequest(); sreq.setAttribute(Globals.EXCEPTION_ATTR,t); } } } */ }	public final void invoke(Request request, Response response) throws IOException, ServletException { MessageBytes requestPathMB = request.getRequestPathMB(); if ((requestPathMB.startsWithIgnoreCase("/META-INF/", 0)) || (requestPathMB.equalsIgnoreCase("/META-INF")) || (requestPathMB.startsWithIgnoreCase("/WEB-INF/", 0)) || (requestPathMB.equalsIgnoreCase("/WEB-INF"))) { String requestURI = request.getDecodedRequestURI(); notFound(requestURI, response); return; } while (context.getPaused()) { try { Thread.sleep(1000); } catch (InterruptedException e) { ; } } Wrapper wrapper = request.getWrapper(); if (wrapper == null) { String requestURI = request.getDecodedRequestURI(); notFound(requestURI, response); return; } Object[] instances = context.getApplicationEventListeners(); ServletRequestEvent event = null; if ((instances != null) && (instances.length > 0)) { event = new ServletRequestEvent(((StandardContext) container).getServletContext(), request.getRequest()); for (int i = 0; i < instances.length; i++) { if (instances[i] == null) continue; if (!(instances[i] instanceof ServletRequestListener)) continue; ServletRequestListener listener = (ServletRequestListener) instances[i]; try { listener.requestInitialized(event); } catch (Throwable t) { container.getLogger().error(sm.getString("requestListenerValve.requestInit", instances[i].getClass().getName()), t); ServletRequest sreq = request.getRequest(); sreq.setAttribute(Globals.EXCEPTION_ATTR, t); return; } } } wrapper.getPipeline().getFirst().invoke(request, response); if ((instances != null) && (instances.length > 0)) { for (int i = 0; i < instances.length; i++) { if (instances[i] == null) continue; if (!(instances[i] instanceof ServletRequestListener)) continue; ServletRequestListener listener = (ServletRequestListener) instances[i]; try { listener.requestDestroyed(event); } catch (Throwable t) { container.getLogger().error(sm.getString("requestListenerValve.requestDestroy", instances[i].getClass().getName()), t); ServletRequest sreq = request.getRequest(); sreq.setAttribute(Globals.EXCEPTION_ATTR, t); } } } }
protected File getAppBase() { if (appBase != null) { return appBase; } File file = new File(host.getAppBase()); if (!file.isAbsolute()) file = new File(System.getProperty("catalina.base"), host.getAppBase()); try { appBase = file.getCanonicalFile(); } catch (IOException e) { appBase = file; } return (appBase); }	protected String stop(String path) { StringWriter stringWriter = new StringWriter(); PrintWriter printWriter = new PrintWriter(stringWriter); super.stop(printWriter, path); return stringWriter.toString(); }	protected boolean isServiced(String name) throws Exception { String[] params = { name }; String[] signature = { "java.lang.String" }; Boolean result = (Boolean) mBeanServer.invoke(oname, "isServiced", params, signature); return result.booleanValue(); }	protected void addServiced(String name) throws Exception { String[] params = { name }; String[] signature = { "java.lang.String" }; mBeanServer.invoke(oname, "addServiced", params, signature); }	protected void check(String name) throws Exception { String[] params = { name }; String[] signature = { "java.lang.String" }; mBeanServer.invoke(oname, "check", params, signature); }	protected void deployWARs(File appBase, String[] files) { if (files == null) return; boolean checkAdditionalDeployments = false; for (int i = 0; i < files.length; i++) { if (files[i].equalsIgnoreCase("META-INF")) continue; if (files[i].equalsIgnoreCase("WEB-INF")) continue; File dir = new File(appBase, files[i]); if (files[i].toLowerCase().endsWith(".war")) { String contextPath = "/" + files[i]; int period = contextPath.lastIndexOf("."); if (period >= 0) contextPath = contextPath.substring(0, period); if (contextPath.equals("/ROOT")) contextPath = ""; if (isServiced(contextPath)) continue; String file = files[i]; deployWAR(contextPath, dir, file); } } }	protected void undeploy(PrintWriter writer, String path) { if (debug >= 1) log("undeploy: Undeploying web application at '" + path + "'"); if ((path == null) || (!path.startsWith("/") && path.equals(""))) { writer.println(sm.getString("managerServlet.invalidPath", RequestUtil.filter(path))); return; } String displayPath = path; if (path.equals("/")) path = ""; try { Context context = (Context) host.findChild(path); if (context == null) { writer.println(sm.getString("managerServlet.noContext", RequestUtil.filter(displayPath))); return; } String appBase = null; File appBaseDir = null; if (context.getParent() instanceof Host) { appBase = ((Host) context.getParent()).getAppBase(); appBaseDir = new File(appBase); if (!appBaseDir.isAbsolute()) { appBaseDir = new File(System.getProperty("catalina.base"), appBase); } } if (!isServiced(path)) { addServiced(path); try { ((Lifecycle) context).stop(); } catch (Throwable t) { // Ignore } try { File war = new File(getAppBase(), getDocBase(path) + ".war"); File dir = new File(getAppBase(), getDocBase(path)); File xml = new File(configBase, getConfigFile(path) + ".xml"); if (war.exists()) { war.delete(); } else if (dir.exists()) { undeployDir(dir); } else { xml.delete(); } check(path); } finally { removeServiced(path); } } writer.println(sm.getString("managerServlet.undeployed", displayPath)); } catch (Throwable t) { log("ManagerServlet.undeploy[" + displayPath + "]", t); writer.println(sm.getString("managerServlet.exception", t.toString())); } }	public long getDeploymentTime(String name) { DeployedApplication app = (DeployedApplication) deployed.get(name); if (app == null) { return 0L; } else { return app.timestamp; } }	public void list(HttpServletRequest request, HttpServletResponse response, String message) throws IOException { if (debug >= 1) log("list: Listing contexts for virtual host '" + host.getName() + "'"); PrintWriter writer = response.getWriter(); writer.print(Constants.HTML_HEADER_SECTION); Object[] args = new Object[2]; args[0] = request.getContextPath(); args[1] = sm.getString("htmlManagerServlet.title"); writer.print(MessageFormat.format(Constants.BODY_HEADER_SECTION, args)); args = new Object[3]; args[0] = sm.getString("htmlManagerServlet.messageLabel"); args[1] = (message == null || message.length() == 0) ? "OK" : message; writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args)); args = new Object[9]; args[0] = sm.getString("htmlManagerServlet.manager"); args[1] = response.encodeURL(request.getContextPath() + "/html/list"); args[2] = sm.getString("htmlManagerServlet.list"); args[3] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpHtmlManagerFile")); args[4] = sm.getString("htmlManagerServlet.helpHtmlManager"); args[5] = response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpManagerFile")); args[6] = sm.getString("htmlManagerServlet.helpManager"); args[7] = response.encodeURL(request.getContextPath() + "/status"); args[8] = sm.getString("statusServlet.title"); writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args)); args = new Object[6]; args[0] = sm.getString("htmlManagerServlet.appsTitle"); args[1] = sm.getString("htmlManagerServlet.appsPath"); args[2] = sm.getString("htmlManagerServlet.appsName"); args[3] = sm.getString("htmlManagerServlet.appsAvailable"); args[4] = sm.getString("htmlManagerServlet.appsSessions"); args[5] = sm.getString("htmlManagerServlet.appsTasks"); writer.print(MessageFormat.format(APPS_HEADER_SECTION, args)); // Apps Row Section Container[] children = host.findChildren(); String[] contextPaths = new String[children.length]; for (int i = 0; i < children.length; i++) contextPaths[i] = children[i].getName(); TreeMap sortedContextPathsMap = new TreeMap(); for (int i = 0; i < contextPaths.length; i++) { String displayPath = contextPaths[i]; sortedContextPathsMap.put(displayPath, contextPaths[i]); } String appsStart = sm.getString("htmlManagerServlet.appsStart"); String appsStop = sm.getString("htmlManagerServlet.appsStop"); String appsReload = sm.getString("htmlManagerServlet.appsReload"); String appsUndeploy = sm.getString("htmlManagerServlet.appsUndeploy"); Iterator iterator = sortedContextPathsMap.entrySet().iterator(); boolean isHighlighted = true; String highlightColor = null; while (iterator.hasNext()) { isHighlighted = !isHighlighted; if (isHighlighted) { highlightColor = "#C3F3C3"; } else { highlightColor = "#FFFFFF"; } Map.Entry entry = (Map.Entry) iterator.next(); String displayPath = (String) entry.getKey(); String contextPath = (String) entry.getKey(); Context context = (Context) host.findChild(contextPath); if (displayPath.equals("")) { displayPath = "/"; } if (context != null) { args = new Object[6]; args[0] = displayPath; args[1] = context.getDisplayName(); if (args[1] == null) { args[1] = "&nbsp;"; } args[2] = new Boolean(context.getAvailable()); args[3] = response.encodeURL(request.getContextPath() + "/html/sessions?path=" + displayPath); if (context.getManager() != null) { args[4] = new Integer(context.getManager().getActiveSessions()); } else { args[4] = new Integer(0); } args[5] = highlightColor; writer.print(MessageFormat.format(APPS_ROW_DETAILS_SECTION, args)); args = new Object[9]; args[0] = response.encodeURL(request.getContextPath() + "/html/start?path=" + displayPath); args[1] = appsStart; args[2] = response.encodeURL(request.getContextPath() + "/html/stop?path=" + displayPath); args[3] = appsStop; args[4] = response.encodeURL(request.getContextPath() + "/html/reload?path=" + displayPath); args[5] = appsReload; args[6] = response.encodeURL(request.getContextPath() + "/html/undeploy?path=" + displayPath); args[7] = appsUndeploy; args[8] = highlightColor; if (context.getPath().equals(this.context.getPath())) { writer.print(MessageFormat.format(MANAGER_APP_ROW_BUTTON_SECTION, args)); } else if (context.getAvailable()) { writer.print(MessageFormat.format(STARTED_APPS_ROW_BUTTON_SECTION, args)); } else { writer.print(MessageFormat.format(STOPPED_APPS_ROW_BUTTON_SECTION, args)); } } } args = new Object[7]; args[0] = sm.getString("htmlManagerServlet.deployTitle"); args[1] = sm.getString("htmlManagerServlet.deployServer"); args[2] = response.encodeURL(request.getContextPath() + "/html/deploy"); args[3] = sm.getString("htmlManagerServlet.deployPath"); args[4] = sm.getString("htmlManagerServlet.deployConfig"); args[5] = sm.getString("htmlManagerServlet.deployWar"); args[6] = sm.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(DEPLOY_SECTION, args)); args = new Object[4]; args[0] = sm.getString("htmlManagerServlet.deployUpload"); args[1] = response.encodeURL(request.getContextPath() + "/html/upload"); args[2] = sm.getString("htmlManagerServlet.deployUploadFile"); args[3] = sm.getString("htmlManagerServlet.deployButton"); writer.print(MessageFormat.format(UPLOAD_SECTION, args)); args = new Object[7]; args[0] = sm.getString("htmlManagerServlet.serverTitle"); args[1] = sm.getString("htmlManagerServlet.serverVersion"); args[2] = sm.getString("htmlManagerServlet.serverJVMVersion"); args[3] = sm.getString("htmlManagerServlet.serverJVMVendor"); args[4] = sm.getString("htmlManagerServlet.serverOSName"); args[5] = sm.getString("htmlManagerServlet.serverOSVersion"); args[6] = sm.getString("htmlManagerServlet.serverOSArch"); writer.print(MessageFormat.format(Constants.SERVER_HEADER_SECTION, args)); args = new Object[6]; args[0] = ServerInfo.getServerInfo(); args[1] = System.getProperty("java.runtime.version"); args[2] = System.getProperty("java.vm.vendor"); args[3] = System.getProperty("os.name"); args[4] = System.getProperty("os.version"); args[5] = System.getProperty("os.arch"); writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args)); writer.print(Constants.HTML_TAIL_SECTION); writer.flush(); writer.close(); }
private String createTagHandlerPoolName(String prefix, String shortName, Attributes attrs, boolean hasEmptyBody) { String poolName = null; poolName = "_jspx_tagPool_" + prefix + "_" + shortName; if (attrs != null) { String[] attrNames = new String[attrs.getLength()]; for (int i = 0; i < attrNames.length; i++) { attrNames[i] = attrs.getQName(i); } Arrays.sort(attrNames, Collections.reverseOrder()); for (int i = 0; i < attrNames.length; i++) { poolName = poolName + "_" + attrNames[i]; } } if (hasEmptyBody) { poolName = poolName + "_nobody"; } return JspUtil.makeXmlJavaIdentifier(poolName); }	private String createTagVarName(String fullName, String prefix, String shortName) { String varName; synchronized (tagVarNumbers) { varName = prefix + "_" + shortName + "_"; if (tagVarNumbers.get(fullName) != null) { Integer i = (Integer) tagVarNumbers.get(fullName); varName = varName + i.intValue(); tagVarNumbers.put(fullName, new Integer(i.intValue() + 1)); } else { tagVarNumbers.put(fullName, new Integer(1)); varName = varName + "0"; } } return JspUtil.makeXmlJavaIdentifier(varName); }
private String skipUntilEL() { char prev = 0; StringBuffer buf = new StringBuffer(); while (hasNextChar()) { char ch = nextChar(); if (prev == '\\') { prev = 0; if (ch == '\\') { buf.append('\\'); if (!escapeBS) prev = '\\'; } else if (ch == '$' || ch == '#') { buf.append(ch); } // else error! } else if (prev == '$' || prev == '#') { if (ch == '{') { this.type = prev; prev = 0; break; } buf.append(prev); } if (ch == '\\' || ch == '$' || ch == '#') { prev = ch; } else { buf.append(ch); } } if (prev != 0) { buf.append(prev); } return buf.toString(); }
private void generateSetters(Node.CustomTag n, String tagHandlerVar, TagHandlerInfo handlerInfo, boolean simpleTag) throws JasperException { if (simpleTag) { String aliasMapVar = null; if (n.isTagFile()) { aliasMapVar = generateAliasMap(n, tagHandlerVar); } out.printin(tagHandlerVar); if (aliasMapVar == null) { out.println(".setJspContext(_jspx_page_context);"); } else { out.print(".setJspContext(_jspx_page_context, "); out.print(aliasMapVar); out.println(");"); } } else { out.printin(tagHandlerVar); out.println(".setPageContext(_jspx_page_context);"); } if (!simpleTag) { out.printin(tagHandlerVar); out.print(".setParent("); if (parent != null) { if (isSimpleTagParent) { out.print("new javax.servlet.jsp.tagext.TagAdapter("); out.print("(javax.servlet.jsp.tagext.SimpleTag) "); out.print(parent); out.println("));"); } else { out.print("(javax.servlet.jsp.tagext.Tag) "); out.print(parent); out.println(");"); } } else { out.println("null);"); } } else { if (parent != null) { out.printin(tagHandlerVar); out.print(".setParent("); out.print(parent); out.println(");"); } } Node.JspAttribute[] attrs = n.getJspAttributes(); for (int i = 0; attrs != null && i < attrs.length; i++) { String attrValue = evaluateAttribute(handlerInfo, attrs[i], n, tagHandlerVar); Mark m = n.getStart(); out.printil("// " + m.getFile() + "(" + m.getLineNumber() + "," + m.getColumnNumber() + ") " + attrs[i].getTagAttributeInfo()); if (attrs[i].isDynamic()) { out.printin(tagHandlerVar); out.print("."); out.print("setDynamicAttribute("); String uri = attrs[i].getURI(); if ("".equals(uri) || (uri == null)) { out.print("null"); } else { out.print("\"" + attrs[i].getURI() + "\""); } out.print(", \""); out.print(attrs[i].getLocalName()); out.print("\", "); out.print(attrValue); out.println(");"); } else { out.printin(tagHandlerVar); out.print("."); out.print(handlerInfo.getSetterMethod(attrs[i].getLocalName()).getName()); out.print("("); out.print(attrValue); out.println(");"); } } }
public boolean isOutDated(boolean checkClass) { String jsp = ctxt.getJspFile(); if (jsw != null && (ctxt.getOptions().getModificationTestInterval() > 0)) { if (jsw.getLastModificationTest() + (ctxt.getOptions().getModificationTestInterval() * 1000) > System.currentTimeMillis()) { return false; } else { jsw.setLastModificationTest(System.currentTimeMillis()); } } long jspRealLastModified = 0; try { URL jspUrl = ctxt.getResource(jsp); if (jspUrl == null) { ctxt.incrementRemoved(); return false; } URLConnection uc = jspUrl.openConnection(); jspRealLastModified = uc.getLastModified(); uc.getInputStream().close(); } catch (Exception e) { e.printStackTrace(); return true; } long targetLastModified = 0; File targetFile; if (checkClass) { targetFile = new File(ctxt.getClassFileName()); } else { targetFile = new File(ctxt.getServletJavaFileName()); } if (!targetFile.exists()) { return true; } targetLastModified = targetFile.lastModified(); if (checkClass && jsw != null) { jsw.setServletClassLastModifiedTime(targetLastModified); } if (targetLastModified < jspRealLastModified) { if (log.isDebugEnabled()) { log.debug("Compiler: outdated: " + targetFile + " " + targetLastModified); } return true; } if (jsw == null) { return false; } List depends = jsw.getDependants(); if (depends == null) { return false; } Iterator it = depends.iterator(); while (it.hasNext()) { String include = (String) it.next(); try { URL includeUrl = ctxt.getResource(include); if (includeUrl == null) { return true; } URLConnection includeUconn = includeUrl.openConnection(); long includeLastModified = includeUconn.getLastModified(); includeUconn.getInputStream().close(); if (includeLastModified > targetLastModified) { return true; } } catch (Exception e) { e.printStackTrace(); return true; } } return false; }	public void compile() throws JasperException, FileNotFoundException { createCompiler(); if (isPackagedTagFile || jspCompiler.isOutDated()) { try { jspLoader = null; jspCompiler.compile(); jsw.setReload(true); jsw.setCompilationException(null); } catch (JasperException ex) { jsw.setCompilationException(ex); throw ex; } catch (Exception ex) { ex.printStackTrace(); JasperException je = new JasperException(Localizer.getMessage("jsp.error.unable.compile"), ex); jsw.setCompilationException(je); throw je; } } }	public void incrementRemoved() { if (removed > 1) { jspCompiler.removeGeneratedFiles(); if (rctxt != null) rctxt.removeWrapper(jspUri); } removed++; }	public void service(HttpServletRequest request, HttpServletResponse response, boolean precompile) throws ServletException, IOException, FileNotFoundException { try { if (ctxt.isRemoved()) { throw new FileNotFoundException(jspUri); } if ((available > 0L) && (available < Long.MAX_VALUE)) { response.setDateHeader("Retry-After", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, Localizer.getMessage("jsp.error.unavailable")); } if (options.getDevelopment() || firstTime) { synchronized (this) { firstTime = false; ctxt.compile(); } } else { if (compileException != null) { throw compileException; } } getServlet(); if (precompile) { return; } if (theServlet instanceof SingleThreadModel) { synchronized (this) { theServlet.service(request, response); } } else { theServlet.service(request, response); } } catch (UnavailableException ex) { String includeRequestUri = (String) request.getAttribute("javax.servlet.include.request_uri"); if (includeRequestUri != null) { throw ex; } else { int unavailableSeconds = ex.getUnavailableSeconds(); if (unavailableSeconds <= 0) { unavailableSeconds = 60; } available = System.currentTimeMillis() + (unavailableSeconds * 1000L); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, ex.getMessage()); } } catch (FileNotFoundException ex) { ctxt.incrementRemoved(); String includeRequestUri = (String) request.getAttribute("javax.servlet.include.request_uri"); if (includeRequestUri != null) { throw new ServletException(ex); } else { try { response.sendError(HttpServletResponse.SC_NOT_FOUND, ex.getMessage()); } catch (IllegalStateException ise) { log.error(Localizer.getMessage("jsp.error.file.not.found", ex.getMessage()), ex); } } } catch (ServletException ex) { if (options.getDevelopment()) { throw handleJspException(ex); } else { throw ex; } } catch (IOException ex) { if (options.getDevelopment()) { throw handleJspException(ex); } else { throw ex; } } catch (IllegalStateException ex) { if (options.getDevelopment()) { throw handleJspException(ex); } else { throw ex; } } catch (Exception ex) { if (options.getDevelopment()) { throw handleJspException(ex); } else { throw new JasperException(ex); } } }
public void action(ActionCode actionCode, Object param) { if (actionCode == ActionCode.ACTION_COMMIT) { if (response.isCommitted()) return; try { prepareResponse(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_CLIENT_FLUSH) { if (!response.isCommitted()) { try { prepareResponse(); } catch (IOException e) { error = true; return; } } try { flush(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_CLOSE) { try { finish(); } catch (IOException e) { error = true; } } else if (actionCode == ActionCode.ACTION_START) { started = true; } else if (actionCode == ActionCode.ACTION_STOP) { started = false; } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE) { if (!certificates.isNull()) { ByteChunk certData = certificates.getByteChunk(); X509Certificate[] jsseCerts = null; ByteArrayInputStream bais = new ByteArrayInputStream(certData.getBytes(), certData.getStart(), certData.getLength()); try { CertificateFactory cf = CertificateFactory.getInstance("X.509"); X509Certificate cert = (X509Certificate) cf.generateCertificate(bais); jsseCerts = new X509Certificate[1]; jsseCerts[0] = cert; request.setAttribute(AprEndpoint.CERTIFICATE_KEY, jsseCerts); } catch (java.security.cert.CertificateException e) { log.error(sm.getString("ajpprocessor.certs.fail"), e); return; } } } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) { if (request.remoteHost().isNull()) { try { request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName()); } catch (IOException iex) { // Ignore } } } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) { request.localAddr().setString(request.localName().toString()); } else if (actionCode == ActionCode.ACTION_REQ_SET_BODY_REPLAY) { ByteChunk bc = (ByteChunk) param; bodyBytes.setBytes(bc.getBytes(), bc.getStart(), bc.getLength()); first = false; empty = false; replay = true; } }	public void action(ActionCode actionCode, Object param) { if (actionCode == ActionCode.ACTION_COMMIT) { if (log.isDebugEnabled()) log.debug("COMMIT "); Response res = (Response) param; if (res.isCommitted()) { if (log.isDebugEnabled()) log.debug("Response already committed "); } else { try { jkIS.appendHead(res); } catch (IOException iex) { log.warn("Unable to send headers", iex); setStatus(JK_STATUS_ERROR); } } } else if (actionCode == ActionCode.ACTION_RESET) { if (log.isDebugEnabled()) log.debug("RESET "); } else if (actionCode == ActionCode.ACTION_CLIENT_FLUSH) { if (log.isDebugEnabled()) log.debug("CLIENT_FLUSH "); try { source.flush(null, this); } catch (IOException iex) { log.debug("Error during flush", iex); Response res = (Response) param; res.setErrorException(iex); setStatus(JK_STATUS_ERROR); } } else if (actionCode == ActionCode.ACTION_CLOSE) { if (log.isDebugEnabled()) log.debug("CLOSE "); Response res = (Response) param; if (getStatus() == JK_STATUS_CLOSED || getStatus() == JK_STATUS_ERROR) { if (log.isDebugEnabled()) log.debug("Double CLOSE - forward ? " + res.getRequest().requestURI()); return; } if (!res.isCommitted()) this.action(ActionCode.ACTION_COMMIT, param); try { jkIS.endMessage(); } catch (IOException iex) { log.warn("Error sending end packet", iex); setStatus(JK_STATUS_ERROR); } if (getStatus() != JK_STATUS_ERROR) { setStatus(JK_STATUS_CLOSED); } if (logTime.isDebugEnabled()) logTime(res.getRequest(), res); } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE) { Request req = (Request) param; MessageBytes certString = (MessageBytes) req.getNote(WorkerEnv.SSL_CERT_NOTE); if (certString != null && !certString.isNull()) { ByteChunk certData = certString.getByteChunk(); ByteArrayInputStream bais = new ByteArrayInputStream(certData.getBytes(), certData.getStart(), certData.getLength()); X509Certificate[] jsseCerts = null; try { CertificateFactory cf = CertificateFactory.getInstance("X.509"); X509Certificate cert = (X509Certificate) cf.generateCertificate(bais); jsseCerts = new X509Certificate[1]; jsseCerts[0] = cert; } catch (java.security.cert.CertificateException e) { log.error("Certificate convertion failed", e); return; } req.setAttribute(SSLSupport.CERTIFICATE_KEY, jsseCerts); } } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) { Request req = (Request) param; if (req.remoteHost().isNull()) { try { req.remoteHost().setString(InetAddress.getByName(req.remoteAddr().toString()).getHostName()); } catch (IOException iex) { if (log.isDebugEnabled()) log.debug("Unable to resolve " + req.remoteAddr()); } } } else if (actionCode == ActionCode.ACTION_ACK) { if (log.isTraceEnabled()) log.trace("ACK "); } else if (actionCode == ActionCode.ACTION_REQ_SET_BODY_REPLAY) { if (log.isTraceEnabled()) log.trace("Replay "); ByteChunk bc = (ByteChunk) param; jkIS.setReplay(bc); } }
public Class loadTagFile() throws JasperException { try { if (ctxt.isRemoved()) { throw new FileNotFoundException(jspUri); } if (options.getDevelopment() || firstTime) { synchronized (this) { firstTime = false; ctxt.compile(); } } else { if (compileException != null) { throw compileException; } } if (reload) { tagHandlerClass = ctxt.load(); } } catch (FileNotFoundException ex) { throw new JasperException(ex); } return tagHandlerClass; }	public java.util.List getDependants() { try { Object target; if (isTagFile) { if (reload) { tagHandlerClass = ctxt.load(); } target = tagHandlerClass.newInstance(); } else { target = getServlet(); } if (target != null && target instanceof JspSourceDependent) { return ((java.util.List) ((JspSourceDependent) target).getDependants()); } } catch (Throwable ex) { } return null; }	public static final Object coerceToType(final Object obj, final Class type) throws IllegalArgumentException { if (type == null || Object.class.equals(type)) { return obj; } if (String.class.equals(type)) { return coerceToString(obj); } if (ELArithmetic.isNumberType(type)) { return coerceToNumber(obj, type); } if (Character.class.equals(type) || Character.TYPE == type) { return coerceToCharacter(obj); } if (Boolean.class.equals(type) || Boolean.TYPE == type) { return coerceToBoolean(obj); } if (obj != null && type.isAssignableFrom(obj.getClass())) { return obj; } if (obj == null) return null; if (obj instanceof String) { if ("".equals(obj)) return null; PropertyEditor editor = PropertyEditorManager.findEditor(type); if (editor != null) { editor.setAsText((String) obj); return editor.getValue(); } } throw new IllegalArgumentException(MessageFactory.get("error.convert", obj, obj.getClass(), type)); }	public static final String coerceToString(final Object obj) { if (obj == null) { return ""; } else if (obj instanceof String) { return (String) obj; } else { return obj.toString(); } }	public static final boolean equals(final Object obj0, final Object obj1) throws ELException { if (obj0 == obj1) { return true; } else if (obj0 == null || obj1 == null) { return false; } else if (obj0 instanceof Boolean || obj1 instanceof Boolean) { return coerceToBoolean(obj0).equals(coerceToBoolean(obj1)); } if (isBigDecimalOp(obj0, obj1)) { BigDecimal bd0 = (BigDecimal) coerceToNumber(obj0, BigDecimal.class); BigDecimal bd1 = (BigDecimal) coerceToNumber(obj1, BigDecimal.class); return bd0.equals(bd1); } if (isDoubleOp(obj0, obj1)) { Double d0 = (Double) coerceToNumber(obj0, Double.class); Double d1 = (Double) coerceToNumber(obj1, Double.class); return d0.equals(d1); } if (isBigIntegerOp(obj0, obj1)) { BigInteger bi0 = (BigInteger) coerceToNumber(obj0, BigInteger.class); BigInteger bi1 = (BigInteger) coerceToNumber(obj1, BigInteger.class); return bi0.equals(bi1); } if (isLongOp(obj0, obj1)) { Long l0 = (Long) coerceToNumber(obj0, Long.class); Long l1 = (Long) coerceToNumber(obj1, Long.class); return l0.equals(l1); } else { return obj0.equals(obj1); } }
public String getFileText(String originalPath, boolean virtual) throws IOException { try { ServletContextAndPath csAndP = getServletContextAndPath(originalPath, virtual); ServletContext context = csAndP.getServletContext(); String path = csAndP.getPath(); RequestDispatcher rd = context.getRequestDispatcher(path); if (rd == null) { throw new IOException("Couldn't get request dispatcher for path: " + path); } ByteArrayServletOutputStream basos = new ByteArrayServletOutputStream(); ResponseIncludeWrapper responseIncludeWrapper = new ResponseIncludeWrapper(context, req, res, basos); rd.include(req, responseIncludeWrapper); responseIncludeWrapper.flushOutputStreamOrWriter(); byte[] bytes = basos.toByteArray(); String retVal; if (inputEncoding == null) { retVal = new String(bytes); } else { retVal = new String(bytes, inputEncoding); } if (retVal.equals("")) { throw new IOException("Couldn't find file: " + path); } return retVal; } catch (ServletException e) { throw new IOException("Couldn't include file: " + originalPath + " because of ServletException: " + e.getMessage()); } }
protected boolean isSpace(char c) { return c == ' ' || c == '\n' || c == '\t' || c == '\r'; }	protected String[] parseParamValues(StringBuffer cmd, int start, int count) { int valIndex = 0; boolean inside = false; String[] vals = new String[count]; StringBuffer sb = new StringBuffer(); for (int bIdx = start; bIdx < cmd.length(); bIdx++) { if (!inside) { while (bIdx < cmd.length() && cmd.charAt(bIdx) != '"') bIdx++; if (bIdx >= cmd.length()) break; inside = !inside; } else { boolean escaped = false; for (; bIdx < cmd.length(); bIdx++) { char c = cmd.charAt(bIdx); if (c == '\\' && !escaped) { escaped = true; continue; } if (c == '"' && !escaped) break; if (c == '$' && escaped) sb.append('\\'); escaped = false; sb.append(c); } if (bIdx == cmd.length()) return null; vals[valIndex++] = sb.toString(); sb.delete(0, sb.length()); inside = !inside; } } return vals; }
/** * Executes a CGI script with the desired environment, current working * directory, and input/output streams * * <p> * This implements the following CGI specification recommedations: * <UL> * <LI> Servers SHOULD provide the "<code>query</code>" component of * the script-URI as command-line arguments to scripts if it * does not contain any unencoded "=" characters and the * command-line arguments can be generated in an unambiguous * manner. * <LI> Servers SHOULD set the AUTH_TYPE metavariable to the value * of the "<code>auth-scheme</code>" token of the * "<code>Authorization</code>" if it was supplied as part of the * request header. See <code>getCGIEnvironment</code> method. * <LI> Where applicable, servers SHOULD set the current working * directory to the directory in which the script is located * before invoking it. * <LI> Server implementations SHOULD define their behavior for the * following cases: * <ul> * <LI> <u>Allowed characters in pathInfo</u>: This implementation * does not allow ASCII NUL nor any character which cannot * be URL-encoded according to internet standards; * <LI> <u>Allowed characters in path segments</u>: This * implementation does not allow non-terminal NULL * segments in the the path -- IOExceptions may be thrown; * <LI> <u>"<code>.</code>" and "<code>..</code>" path * segments</u>: * This implementation does not allow "<code>.</code>" and * "<code>..</code>" in the the path, and such characters * will result in an IOException being thrown; * <LI> <u>Implementation limitations</u>: This implementation * does not impose any limitations except as documented * above. This implementation may be limited by the * servlet container used to house this implementation. * In particular, all the primary CGI variable values * are derived either directly or indirectly from the * container's implementation of the Servlet API methods. * </ul> * </UL> * </p> * * @exception IOException if problems during reading/writing occur * * @see java.lang.Runtime#exec(String command, String[] envp, * File dir) */ protected void run() throws IOException { /* * REMIND: this method feels too big; should it be re-written? */ if (!isReady()) { throw new IOException(this.getClass().getName() + ": not ready to run."); } if (debug >= 1 ) { log("runCGI(envp=[" + env + "], command=" + command + ")"); } if ((command.indexOf(File.separator + "." + File.separator) >= 0) || (command.indexOf(File.separator + "..") >= 0) || (command.indexOf(".." + File.separator) >= 0)) { throw new IOException(this.getClass().getName() + "Illegal Character in CGI command " + "path ('.' or '..') detected. Not " + "running CGI [" + command + "]."); } /* original content/structure of this section taken from * http://developer.java.sun.com/developer/ * bugParade/bugs/4216884.html * with major modifications by Martin Dengler */ Runtime rt = null; InputStream cgiOutput = null; BufferedReader commandsStdErr = null; BufferedOutputStream commandsStdIn = null; Process proc = null; int bufRead = -1; //create query arguments StringBuffer cmdAndArgs = new StringBuffer(); if (command.indexOf(" ") < 0) { cmdAndArgs.append(command); } else { // Spaces used as delimiter, so need to use quotes cmdAndArgs.append("\""); cmdAndArgs.append(command); cmdAndArgs.append("\""); } for (int i=0; i < params.size(); i++) { cmdAndArgs.append(" "); String param = (String) params.get(i); if (param.indexOf(" ") < 0) { cmdAndArgs.append(param); } else { // Spaces used as delimiter, so need to use quotes cmdAndArgs.append("\""); cmdAndArgs.append(param); cmdAndArgs.append("\""); } } StringBuffer command = new StringBuffer(cgiExecutable); command.append(" "); command.append(cmdAndArgs.toString()); cmdAndArgs = command; rt = Runtime.getRuntime(); proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd); String sContentLength = (String) env.get("CONTENT_LENGTH"); if(!"".equals(sContentLength)) { commandsStdIn = new BufferedOutputStream(proc.getOutputStream()); IOTools.flow(stdin, commandsStdIn); commandsStdIn.flush(); commandsStdIn.close(); } /* we want to wait for the process to exit, Process.waitFor() * is useless in our situation; see * http://developer.java.sun.com/developer/ * bugParade/bugs/4223650.html */ boolean isRunning = true; commandsStdErr = new BufferedReader (new InputStreamReader(proc.getErrorStream())); final BufferedReader stdErrRdr = commandsStdErr ; new Thread() { } }	protected void run() throws IOException { if (!isReady()) { throw new IOException(this.getClass().getName() + ": not ready to run."); } if (debug >= 1) { log("runCGI(envp=[" + env + "], command=" + command + ")"); } if ((command.indexOf(File.separator + "." + File.separator) >= 0) || (command.indexOf(File.separator + "..") >= 0) || (command.indexOf(".." + File.separator) >= 0)) { throw new IOException(this.getClass().getName() + "Illegal Character in CGI command " + "path ('.' or '..') detected. Not " + "running CGI [" + command + "]."); } Runtime rt = null; InputStream cgiOutput = null; BufferedReader commandsStdErr = null; BufferedOutputStream commandsStdIn = null; Process proc = null; int bufRead = -1; StringBuffer cmdAndArgs = new StringBuffer(); if (command.indexOf(" ") < 0) { cmdAndArgs.append(command); } else { cmdAndArgs.append("\""); cmdAndArgs.append(command); cmdAndArgs.append("\""); } for (int i = 0; i < params.size(); i++) { cmdAndArgs.append(" "); String param = (String) params.get(i); if (param.indexOf(" ") < 0) { cmdAndArgs.append(param); } else { cmdAndArgs.append("\""); cmdAndArgs.append(param); cmdAndArgs.append("\""); } } StringBuffer command = new StringBuffer(cgiExecutable); command.append(" "); command.append(cmdAndArgs.toString()); cmdAndArgs = command; rt = Runtime.getRuntime(); proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd); String sContentLength = (String) env.get("CONTENT_LENGTH"); if (!"".equals(sContentLength)) { commandsStdIn = new BufferedOutputStream(proc.getOutputStream()); IOTools.flow(stdin, commandsStdIn); commandsStdIn.flush(); commandsStdIn.close(); } boolean isRunning = true; commandsStdErr = new BufferedReader(new InputStreamReader(proc.getErrorStream())); final BufferedReader stdErrRdr = commandsStdErr; new Thread() { public void run() { sendToLog(stdErrRdr); } ; }.start(); InputStream cgiHeaderStream = new HTTPHeaderInputStream(proc.getInputStream()); BufferedReader cgiHeaderReader = new BufferedReader(new InputStreamReader(cgiHeaderStream)); while (isRunning) { try { String line = null; while (((line = cgiHeaderReader.readLine()) != null) && !("".equals(line))) { if (debug >= 2) { log("runCGI: addHeader(\"" + line + "\")"); } if (line.startsWith("HTTP")) { response.setStatus(getSCFromHttpStatusLine(line)); } else if (line.indexOf(":") >= 0) { String header = line.substring(0, line.indexOf(":")).trim(); String value = line.substring(line.indexOf(":") + 1).trim(); if (header.equalsIgnoreCase("status")) { response.setStatus(getSCFromCGIStatusHeader(value)); } else { response.addHeader(header, value); } } else { log("runCGI: bad header line \"" + line + "\""); } } byte[] bBuf = new byte[2048]; OutputStream out = response.getOutputStream(); cgiOutput = proc.getInputStream(); try { while ((bufRead = cgiOutput.read(bBuf)) != -1) { if (debug >= 4) { log("runCGI: output " + bufRead + " bytes of data"); } out.write(bBuf, 0, bufRead); } } finally { if (bufRead != -1) { while ((bufRead = cgiOutput.read(bBuf)) != -1) { } } } proc.exitValue(); isRunning = false; } catch (IllegalThreadStateException e) { try { Thread.sleep(500); } catch (InterruptedException ignored) { } } } //replacement for Process.waitFor() cgiOutput.close(); }
public Object resolveVariable(String pName) throws ELException { return this.ctx.getELResolver().getValue(this.ctx, pName, null); }
synchronized void unload() throws ServletException { if (!singleThreadModel && (instance == null)) return; unloading = true; if (countAllocated > 0) { int nRetries = 0; long delay = unloadDelay / 20; while ((nRetries < 21) && (countAllocated > 0)) { if ((nRetries % 10) == 0) { log.info(sm.getString("standardWrapper.waiting", new Integer(countAllocated))); } try { Thread.sleep(delay); } catch (InterruptedException e) { ; } nRetries++; } } ClassLoader oldCtxClassLoader = Thread.currentThread().getContextClassLoader(); ClassLoader classLoader = instance.getClass().getClassLoader(); PrintStream out = System.out; if (swallowOutput) { SystemLogHandler.startCapture(); } try { instanceSupport.fireInstanceEvent(InstanceEvent.BEFORE_DESTROY_EVENT, instance); Thread.currentThread().setContextClassLoader(classLoader); if (System.getSecurityManager() != null) { SecurityUtil.doAsPrivilege("destroy", instance); SecurityUtil.remove(instance); } else { instance.destroy(); } instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_DESTROY_EVENT, instance); if (!((Context) getParent()).getIgnoreAnnotations()) { AnnotationProcessor.preDestroy(instance); } } catch (Throwable t) { instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_DESTROY_EVENT, instance, t); instance = null; instancePool = null; nInstances = 0; fireContainerEvent("unload", this); unloading = false; throw new ServletException(sm.getString("standardWrapper.destroyException", getName()), t); } finally { Thread.currentThread().setContextClassLoader(oldCtxClassLoader); if (swallowOutput) { String log = SystemLogHandler.stopCapture(); if (log != null && log.length() > 0) { if (getServletContext() != null) { getServletContext().log(log); } else { out.println(log); } } } } instance = null; if (singleThreadModel && (instancePool != null)) { try { Thread.currentThread().setContextClassLoader(classLoader); while (!instancePool.isEmpty()) { Servlet s = (Servlet) instancePool.pop(); if (System.getSecurityManager() != null) { SecurityUtil.doAsPrivilege("destroy", s); SecurityUtil.remove(instance); } else { s.destroy(); } if (!((Context) getParent()).getIgnoreAnnotations()) { AnnotationProcessor.preDestroy(s); } } } catch (Throwable t) { instancePool = null; nInstances = 0; unloading = false; fireContainerEvent("unload", this); throw new ServletException(sm.getString("standardWrapper.destroyException", getName()), t); } finally { Thread.currentThread().setContextClassLoader(oldCtxClassLoader); } instancePool = null; nInstances = 0; } singleThreadModel = false; unloading = false; fireContainerEvent("unload", this); }
public synchronized void start() throws LifecycleException { if (started) { if (log.isInfoEnabled()) log.info(sm.getString("containerBase.alreadyStarted", logName())); return; } if (!initialized) { try { init(); } catch (Exception ex) { throw new LifecycleException("Error initializaing ", ex); } } if (log.isDebugEnabled()) log.debug("Starting " + ("".equals(getName()) ? "ROOT" : getName())); preRegisterJMX(); if ((oname != null) && (Registry.getRegistry(null, null).getMBeanServer().isRegistered(oname))) { // As things depend on the JMX registration, the context Registry.getRegistry(null, null).unregisterComponent(oname); } lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null); setAvailable(false); setConfigured(false); boolean ok = true; if (webappResources == null) { if (log.isDebugEnabled()) log.debug("Configuring default Resources"); try { if ((docBase != null) && (docBase.endsWith(".war")) && (!(new File(getBasePath())).isDirectory())) setResources(new WARDirContext()); else setResources(new FileDirContext()); } catch (IllegalArgumentException e) { log.error("Error initializing resources: " + e.getMessage()); ok = false; } } if (ok) { if (!resourcesStart()) { log.error("Error in resourceStart()"); ok = false; } } if (realm == null && mserver != null) { ObjectName realmName = null; try { realmName = new ObjectName(getEngineName() + ":type=Realm,host=" + getHostname() + ",path=" + getPath()); if (mserver.isRegistered(realmName)) { mserver.invoke(realmName, "init", new Object[] {}, new String[] {}); } } catch (Throwable t) { if (log.isDebugEnabled()) log.debug("No realm for this host " + realmName); } } if (getLoader() == null) { ClassLoader parent = null; if (getPrivileged()) { if (log.isDebugEnabled()) log.debug("Configuring privileged default Loader"); parent = this.getClass().getClassLoader(); } else { if (log.isDebugEnabled()) log.debug("Configuring non-privileged default Loader"); parent = getParentClassLoader(); } WebappLoader webappLoader = new WebappLoader(parent); webappLoader.setDelegate(getDelegate()); setLoader(webappLoader); } getCharsetMapper(); postWorkDirectory(); boolean dependencyCheck = true; try { dependencyCheck = ExtensionValidator.validateApplication(getResources(), this); } catch (IOException ioe) { log.error("Error in dependencyCheck", ioe); dependencyCheck = false; } if (!dependencyCheck) { ok = false; } String useNamingProperty = System.getProperty("catalina.useNaming"); if ((useNamingProperty != null) && (useNamingProperty.equals("false"))) { useNaming = false; } if (ok && isUseNaming()) { if (namingContextListener == null) { namingContextListener = new NamingContextListener(); namingContextListener.setName(getNamingContextName()); addLifecycleListener(namingContextListener); } } if (log.isDebugEnabled()) log.debug("Processing standard container startup"); ClassLoader oldCCL = bindThread(); boolean mainOk = false; try { if (ok) { started = true; if ((loader != null) && (loader instanceof Lifecycle)) ((Lifecycle) loader).start(); unbindThread(oldCCL); oldCCL = bindThread(); // Initialize logger again. Other components might have used it too early, logger = null; getLogger(); if ((logger != null) && (logger instanceof Lifecycle)) ((Lifecycle) logger).start(); if ((cluster != null) && (cluster instanceof Lifecycle)) ((Lifecycle) cluster).start(); if ((realm != null) && (realm instanceof Lifecycle)) ((Lifecycle) realm).start(); if ((resources != null) && (resources instanceof Lifecycle)) ((Lifecycle) resources).start(); Container[] children = findChildren(); for (int i = 0; i < children.length; i++) { if (children[i] instanceof Lifecycle) ((Lifecycle) children[i]).start(); } if (pipeline instanceof Lifecycle) { ((Lifecycle) pipeline).start(); } if (getProcessTlds()) { processTlds(); } lifecycle.fireLifecycleEvent(START_EVENT, null); if (manager == null) { if ((getCluster() != null) && distributable) { try { setManager(getCluster().createManager(getName())); } catch (Exception ex) { log.error("standardContext.clusterFail", ex); ok = false; } } else { setManager(new StandardManager()); } } if ((manager != null) && (manager instanceof Lifecycle)) { ((Lifecycle) getManager()).start(); } super.threadStart(); mainOk = true; } } finally { unbindThread(oldCCL); if (!mainOk) { // An exception occurred registerJMX(); } } if (!getConfigured()) { log.error("Error getConfigured"); ok = false; } if (ok) getServletContext().setAttribute(Globals.RESOURCES_ATTR, getResources()); mapper.setContext(getPath(), welcomeFiles, resources); oldCCL = bindThread(); if (ignoreAnnotations) { Wrapper jspServlet = (Wrapper) findChild(Constants.JSP_SERVLET_NAME); jspServlet.addInitParameter("org.apache.jasper.IGNORE_ANNOTATIONS", "true"); } try { if (ok) { postWelcomeFiles(); } if (ok) { lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null); } if (ok) { if (!listenerStart()) { log.error("Error listenerStart"); ok = false; } } if (ok) { if (!filterStart()) { log.error("Error filterStart"); ok = false; } } if (ok) { loadOnStartup(findChildren()); } } finally { unbindThread(oldCCL); } if (ok) { if (log.isDebugEnabled()) log.debug("Starting completed"); setAvailable(true); } else { log.error(sm.getString("standardContext.startFailed", getName())); try { stop(); } catch (Throwable t) { log.error(sm.getString("standardContext.startCleanup"), t); } setAvailable(false); } registerJMX(); startTime = System.currentTimeMillis(); if (ok && (this.getObjectName() != null)) { Notification notification = new Notification("j2ee.state.running", this.getObjectName(), sequenceNumber++); broadcaster.sendNotification(notification); } if (getLoader() instanceof WebappLoader) { ((WebappLoader) getLoader()).closeJARs(true); } if (!ok && started) { stop(); } //cacheContext(); }
